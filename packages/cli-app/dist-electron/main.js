var ux = Object.defineProperty;
var vp = (e) => {
  throw TypeError(e);
};
var fx = (e, t, r) => t in e ? ux(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Se = (e, t, r) => fx(e, typeof t != "symbol" ? t + "" : t, r), Qa = (e, t, r) => t.has(e) || vp("Cannot " + r);
var Xe = (e, t, r) => (Qa(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Vr = (e, t, r) => t.has(e) ? vp("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), wn = (e, t, r, n) => (Qa(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), wt = (e, t, r) => (Qa(e, t, "access private method"), r);
import { app as zs, Menu as hv, BrowserWindow as mv, ipcMain as Ct, shell as dx } from "electron";
import px, { fileURLToPath as hx } from "node:url";
import { createRequire as mx } from "node:module";
import Qo from "node:events";
import yn from "node:util";
import ea from "node:http";
import zu from "node:diagnostics_channel";
import yx from "node:https";
import gx from "node:dns";
import yv from "node:os";
import ri from "node:stream";
import gt from "fs";
import gv, { EventEmitter as vx } from "events";
import gn from "util";
import $t from "path";
import Uu from "assert";
import vv from "worker_threads";
import bx from "module";
import vr from "node:path";
import ni from "url";
import _x from "buffer";
import Ex from "node:async_hooks";
import vn from "node:assert";
import xx from "node:crypto";
import zt, { Readable as Sx } from "stream";
import qu from "http";
import Hu from "https";
import bv from "crypto";
import _v from "tty";
import wx from "os";
import fr from "zlib";
import { execSync as ao } from "child_process";
var be = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function si(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ii = { exports: {} }, Bu = { exports: {} };
function Rx(e) {
  var t = new e(), r = t;
  function n() {
    var i = t;
    return i.next ? t = i.next : (t = new e(), r = t), i.next = null, i;
  }
  function s(i) {
    r.next = i, r = i;
  }
  return {
    get: n,
    release: s
  };
}
var $x = Rx, Tx = $x;
function Ev(e, t, r) {
  if (typeof e == "function" && (r = t, t = e, e = null), !(r >= 1))
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var n = Tx(Ox), s = null, i = null, o = 0, a = null, c = {
    push: h,
    drain: Mt,
    saturated: Mt,
    pause: l,
    paused: !1,
    get concurrency() {
      return r;
    },
    set concurrency(R) {
      if (!(R >= 1))
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      if (r = R, !c.paused)
        for (; s && o < r; )
          o++, m();
    },
    running: f,
    resume: p,
    idle: u,
    length: d,
    getQueue: g,
    unshift: b,
    empty: Mt,
    kill: v,
    killAndDrain: y,
    error: _
  };
  return c;
  function f() {
    return o;
  }
  function l() {
    c.paused = !0;
  }
  function d() {
    for (var R = s, E = 0; R; )
      R = R.next, E++;
    return E;
  }
  function g() {
    for (var R = s, E = []; R; )
      E.push(R.value), R = R.next;
    return E;
  }
  function p() {
    if (c.paused) {
      if (c.paused = !1, s === null) {
        o++, m();
        return;
      }
      for (; s && o < r; )
        o++, m();
    }
  }
  function u() {
    return o === 0 && c.length() === 0;
  }
  function h(R, E) {
    var O = n.get();
    O.context = e, O.release = m, O.value = R, O.callback = E || Mt, O.errorHandler = a, o >= r || c.paused ? i ? (i.next = O, i = O) : (s = O, i = O, c.saturated()) : (o++, t.call(e, O.value, O.worked));
  }
  function b(R, E) {
    var O = n.get();
    O.context = e, O.release = m, O.value = R, O.callback = E || Mt, O.errorHandler = a, o >= r || c.paused ? s ? (O.next = s, s = O) : (s = O, i = O, c.saturated()) : (o++, t.call(e, O.value, O.worked));
  }
  function m(R) {
    R && n.release(R);
    var E = s;
    E && o <= r ? c.paused ? o-- : (i === s && (i = null), s = E.next, E.next = null, t.call(e, E.value, E.worked), i === null && c.empty()) : --o === 0 && c.drain();
  }
  function v() {
    s = null, i = null, c.drain = Mt;
  }
  function y() {
    s = null, i = null, c.drain(), c.drain = Mt;
  }
  function _(R) {
    a = R;
  }
}
function Mt() {
}
function Ox() {
  this.value = null, this.callback = Mt, this.next = null, this.release = Mt, this.context = null, this.errorHandler = null;
  var e = this;
  this.worked = function(r, n) {
    var s = e.callback, i = e.errorHandler, o = e.value;
    e.value = null, e.callback = Mt, e.errorHandler && i(r, o), s.call(e.context, r, n), e.release(e);
  };
}
function Px(e, t, r) {
  typeof e == "function" && (r = t, t = e, e = null);
  function n(l, d) {
    t.call(this, l).then(function(g) {
      d(null, g);
    }, d);
  }
  var s = Ev(e, n, r), i = s.push, o = s.unshift;
  return s.push = a, s.unshift = c, s.drained = f, s;
  function a(l) {
    var d = new Promise(function(g, p) {
      i(l, function(u, h) {
        if (u) {
          p(u);
          return;
        }
        g(h);
      });
    });
    return d.catch(Mt), d;
  }
  function c(l) {
    var d = new Promise(function(g, p) {
      o(l, function(u, h) {
        if (u) {
          p(u);
          return;
        }
        g(h);
      });
    });
    return d.catch(Mt), d;
  }
  function f() {
    var l = new Promise(function(d) {
      process.nextTick(function() {
        if (s.idle())
          d();
        else {
          var g = s.drain;
          s.drain = function() {
            typeof g == "function" && g(), d(), s.drain = g;
          };
        }
      });
    });
    return l;
  }
}
Bu.exports = Ev;
Bu.exports.promise = Px;
var Cx = Bu.exports, ta = { exports: {} };
const { format: Ix } = yn;
function Nx() {
  return `${this.name} [${this.code}]: ${this.message}`;
}
function oi(e, t, r = 500, n = Error, s = oi.captureStackTrace) {
  if (!e) throw new Error("Fastify error code must not be empty");
  if (!t) throw new Error("Fastify error message must not be empty");
  e = e.toUpperCase(), !r && (r = void 0);
  function i(...o) {
    if (!new.target)
      return new i(...o);
    this.code = e, this.name = "FastifyError", this.statusCode = r;
    const a = o.length - 1;
    a !== -1 && o[a] && typeof o[a] == "object" && "cause" in o[a] && (this.cause = o.pop().cause), this.message = Ix(t, ...o), Error.stackTraceLimit && s && Error.captureStackTrace(this, i);
  }
  return i.prototype = Object.create(n.prototype, {
    constructor: {
      value: i,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), i.prototype[Symbol.toStringTag] = "Error", i.prototype.toString = Nx, i;
}
oi.captureStackTrace = !0;
ta.exports = oi;
ta.exports.default = oi;
ta.exports.createError = oi;
var xv = ta.exports;
const { createError: Or } = xv;
var Vu = {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: Or(
    "AVV_ERR_EXPOSE_ALREADY_DEFINED",
    "'%s' is already defined, specify an expose option for '%s'"
  ),
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: Or(
    "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
    "'%s' is already defined"
  ),
  AVV_ERR_CALLBACK_NOT_FN: Or(
    "AVV_ERR_CALLBACK_NOT_FN",
    "Callback for '%s' hook is not a function. Received: '%s'"
  ),
  AVV_ERR_PLUGIN_NOT_VALID: Or(
    "AVV_ERR_PLUGIN_NOT_VALID",
    "Plugin must be a function or a promise. Received: '%s'"
  ),
  AVV_ERR_ROOT_PLG_BOOTED: Or(
    "AVV_ERR_ROOT_PLG_BOOTED",
    "Root plugin has already booted"
  ),
  AVV_ERR_PARENT_PLG_LOADED: Or(
    "AVV_ERR_PARENT_PLG_LOADED",
    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
  ),
  AVV_ERR_READY_TIMEOUT: Or(
    "AVV_ERR_READY_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: Or(
    "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  )
};
const Ax = Symbol("avvio.Boot"), kx = Symbol("isOnCloseHandler"), Lx = Symbol("avvio.ThenifyDoNotWrap"), jx = Symbol("avvio.TimeTree.untrackNode"), Dx = Symbol("avvio.TimeTree.trackNode"), Fx = Symbol("avvio.TimeTree.getParent"), Mx = Symbol("avvio.TimeTree.getNode"), zx = Symbol("avvio.TimeTree.addNode"), Ux = Symbol.for("plugin-meta");
var ai = {
  kAvvio: Ax,
  kIsOnCloseHandler: kx,
  kThenifyDoNotWrap: Lx,
  kUntrackNode: jx,
  kTrackNode: Dx,
  kGetParent: Fx,
  kGetNode: Mx,
  kAddNode: zx,
  kPluginMeta: Ux
};
const {
  kUntrackNode: bp,
  kTrackNode: ec,
  kGetParent: _p,
  kGetNode: Ep,
  kAddNode: xp
} = ai;
let qx = class {
  constructor() {
    this.root = null, this.tableId = /* @__PURE__ */ new Map(), this.tableLabel = /* @__PURE__ */ new Map();
  }
  /**
   * @param {TimeTreeNode} node
   */
  [ec](t) {
    this.tableId.set(t.id, t), this.tableLabel.has(t.label) ? this.tableLabel.get(t.label).push(t) : this.tableLabel.set(t.label, [t]);
  }
  /**
   * @param {TimeTreeNode} node
   */
  [bp](t) {
    this.tableId.delete(t.id);
    const r = this.tableLabel.get(t.label);
    r.pop(), r.length === 0 && this.tableLabel.delete(t.label);
  }
  /**
   * @param {string} parent
   * @returns {TimeTreeNode}
   */
  [_p](t) {
    if (t === null)
      return null;
    if (this.tableLabel.has(t)) {
      const r = this.tableLabel.get(t);
      return r[r.length - 1];
    } else
      return null;
  }
  /**
   *
   * @param {string} nodeId
   * @returns {TimeTreeNode}
   */
  [Ep](t) {
    return this.tableId.get(t);
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number} start
   * @returns {TimeTreeNode["id"]}
   */
  [xp](t, r, n) {
    const s = this[_p](t);
    if (s === null)
      return this.root = {
        parent: null,
        id: "root",
        label: r,
        nodes: [],
        start: n,
        stop: null,
        diff: -1
      }, this[ec](this.root), this.root.id;
    const o = `${r}-${Math.random()}`, a = {
      parent: t,
      id: o,
      label: r,
      nodes: [],
      start: n,
      stop: null,
      diff: -1
    };
    return s.nodes.push(a), this[ec](a), o;
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number|undefined} start
   * @returns {TimeTreeNode["id"]}
   */
  start(t, r, n = Date.now()) {
    return this[xp](t, r, n);
  }
  /**
   * @param {string} nodeId
   * @param {number|undefined} stop
   */
  stop(t, r = Date.now()) {
    const n = this[Ep](t);
    n && (n.stop = r, n.diff = n.stop - n.start || 0, this[bp](n));
  }
  /**
   * @returns {TimeTreeNode}
   */
  toJSON() {
    return Object.assign({}, this.root);
  }
  /**
   * @returns {string}
   */
  prettyPrint() {
    return Sv(this.toJSON());
  }
};
function Sv(e, t = "") {
  let r = t;
  const n = e.nodes.length, s = n - 1;
  r += `${e.label} ${e.diff} ms
`;
  for (let i = 0; i < n; ++i) {
    const o = e.nodes[i], a = t + (i === s ? "  " : "│ ");
    r += t, r += i === s ? "└─" : "├─", r += o.nodes.length === 0 ? "─ " : "┬ ", r += Sv(o, a).slice(t.length + 2);
  }
  return r;
}
var Hx = {
  TimeTree: qx
};
const { debuglog: Bx } = yn, Vx = Bx("avvio");
var Gu = {
  debug: Vx
};
function Gx() {
  const e = {
    resolve: null,
    reject: null,
    promise: null
  };
  return e.promise = new Promise((t, r) => {
    e.resolve = t, e.reject = r;
  }), e;
}
var Wx = {
  createPromise: Gx
};
const { kPluginMeta: tc } = ai;
function Kx(e, t) {
  return e[tc] && e[tc].name ? e[tc].name : t && t.name ? t.name : e.name ? e.name : e.toString().split(`
`).slice(0, 2).map((r) => r.trim()).join(" -- ");
}
var Jx = {
  getPluginName: Kx
};
function Yx(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var Wu = {
  isPromiseLike: Yx
};
const { EventEmitter: Xx } = Qo, { inherits: Zx } = yn, { debug: lt } = Gu, { createPromise: Qx } = Wx, { AVV_ERR_PLUGIN_EXEC_TIMEOUT: eS } = Vu, { getPluginName: tS } = Jx, { isPromiseLike: rS } = Wu;
function es(e, t, r, n, s) {
  this.queue = e, this.func = t, this.options = r, this.isAfter = n, this.timeout = s, this.started = !1, this.name = tS(t, r), this.queue.pause(), this._error = null, this.loaded = !1, this._promise = null, this.startTime = null;
}
Zx(es, Xx);
es.prototype.exec = function(e, t) {
  lt("exec", this.name), this.server = e;
  const r = this.func, n = this.name;
  let s = !1;
  this.options = typeof this.options == "function" ? this.options(this.server) : this.options;
  let i = null;
  const o = (c) => {
    if (s) {
      lt("loading complete", n);
      return;
    }
    this._error = c, lt(c ? "exec errored" : "exec completed", n), s = !0, i && clearTimeout(i), t(c);
  };
  this.timeout > 0 && (lt("setting up timeout", n, this.timeout), i = setTimeout(function() {
    lt("timed out", n), i = null;
    const c = new eS(n);
    c.fn = r, o(c);
  }, this.timeout)), this.started = !0, this.startTime = Date.now(), this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
  const a = r(this.server, this.options, o);
  rS(a) ? (lt("exec: resolving promise", n), a.then(
    () => process.nextTick(o),
    (c) => process.nextTick(o, c)
  )) : r.length < 3 && o();
};
es.prototype.loadedSoFar = function() {
  if (lt("loadedSoFar", this.name), this.loaded)
    return Promise.resolve();
  const e = () => {
    this.server.after((r, n) => {
      this._error = r, this.queue.pause(), this._promise && (r ? (lt("rejecting promise", this.name, r), this._promise.reject(r)) : (lt("resolving promise", this.name), this._promise.resolve()), this._promise = null), process.nextTick(n, r);
    }), this.queue.resume();
  };
  let t;
  return this._promise ? t = Promise.resolve() : (this._promise = Qx(), t = this._promise.promise, this.server ? e() : this.on("start", e)), t;
};
es.prototype.enqueue = function(e, t) {
  lt("enqueue", this.name, e.name), this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now()), this.queue.push(e, t);
};
es.prototype.finish = function(e, t) {
  lt("finish", this.name, e);
  const r = () => {
    this.loaded || (lt("loaded", this.name), this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now()), this.loaded = !0, t(e));
  };
  if (e) {
    this._promise && (this._promise.reject(e), this._promise = null), r();
    return;
  }
  const n = () => {
    if (lt("check", this.name, this.queue.length(), this.queue.running(), this._promise), this.queue.length() === 0 && this.queue.running() === 0)
      if (this._promise) {
        const s = () => {
          lt("wrap"), queueMicrotask(n);
        };
        this._promise.resolve(), this._promise.promise.then(s, s), this._promise = null;
      } else
        r();
    else
      lt("delayed", this.name), this.queue.drain = () => {
        lt("drain", this.name), this.queue.drain = nS, queueMicrotask(n);
      };
  };
  queueMicrotask(n), this.queue.resume();
};
function nS() {
}
var sS = {
  Plugin: es
};
const { AVV_ERR_PLUGIN_NOT_VALID: rc } = Vu;
function iS(e) {
  if (!(e && (typeof e == "function" || typeof e.then == "function")))
    throw Array.isArray(e) ? new rc("array") : e === null ? new rc("null") : new rc(typeof e);
}
var oS = {
  validatePlugin: iS
};
function aS(e) {
  return e !== null && typeof e == "object" && typeof e.default == "function";
}
var cS = {
  isBundledOrTypescriptPlugin: aS
};
const { debug: Sp } = Gu, { kThenifyDoNotWrap: nc } = ai;
function lS() {
  if (this.booted) {
    Sp("thenify returning undefined because we are already booted");
    return;
  }
  if (this[nc]) {
    this[nc] = !1;
    return;
  }
  return Sp("thenify"), (e, t) => this._loadRegistered().then(() => (this[nc] = !0, e(this._server)), t);
}
var uS = {
  thenify: lS
};
const { isPromiseLike: fS } = Wu, { kAvvio: dS } = ai;
function pS(e, t, r) {
  const n = e.apply(e, t);
  fS(n) && !n[dS] ? n.then(() => process.nextTick(r), (s) => process.nextTick(r, s)) : r && process.nextTick(r);
}
var hS = {
  executeWithThenable: pS
};
const co = Cx, mS = Qo.EventEmitter, yS = yn.inherits, {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: hs,
  AVV_ERR_CALLBACK_NOT_FN: zn,
  AVV_ERR_ROOT_PLG_BOOTED: gS,
  AVV_ERR_READY_TIMEOUT: vS,
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: bS
} = Vu, {
  kAvvio: wv,
  kIsOnCloseHandler: Rv
} = ai, { TimeTree: _S } = Hx, { Plugin: $v } = sS, { debug: Gn } = Gu, { validatePlugin: ES } = oS, { isBundledOrTypescriptPlugin: xS } = cS, { isPromiseLike: SS } = Wu, { thenify: Tv } = uS, { executeWithThenable: wp } = hS;
function Ze(e, t, r) {
  if (typeof e == "function" && arguments.length === 1 && (r = e, t = {}, e = null), typeof t == "function" && (r = t, t = {}), t = t || {}, t.autostart = t.autostart !== !1, t.timeout = Number(t.timeout) || 0, t.expose = t.expose || {}, !new.target)
    return new Ze(e, t, r);
  this._server = e || this, this._opts = t, e && this._expose(), this._current = [], this._error = null, this._lastUsed = null, this.setMaxListeners(0), r && this.once("start", r), this.started = !1, this.booted = !1, this.pluginTree = new _S(), this._readyQ = co(this, Ov, 1), this._readyQ.pause(), this._readyQ.drain = () => {
    this.emit("start"), this._readyQ.drain = Rp;
  }, this._closeQ = co(this, RS, 1), this._closeQ.pause(), this._closeQ.drain = () => {
    this.emit("close"), this._closeQ.drain = Rp;
  }, this._doStart = null;
  const n = this;
  this._root = new $v(co(this, this._loadPluginNextTick, 1), function(i, o, a) {
    n._doStart = a, o.autostart && n.start();
  }, t, !1, 0), this._trackPluginLoading(this._root), this._loadPlugin(this._root, (s) => {
    Gn("root plugin ready");
    try {
      this.emit("preReady"), this._root = null;
    } catch (i) {
      s = s || this._error || i;
    }
    if (s) {
      if (this._error = s, this._readyQ.length() === 0)
        throw s;
    } else
      this.booted = !0;
    this._readyQ.resume();
  });
}
yS(Ze, mS);
Ze.prototype.start = function() {
  return this.started = !0, process.nextTick(this._doStart), this;
};
Ze.prototype.override = function(e, t, r) {
  return e;
};
Ze.prototype[wv] = !0;
Ze.prototype.use = function(e, t) {
  return this._lastUsed = this._addPlugin(e, t, !1), this;
};
Ze.prototype._loadRegistered = function() {
  const e = this._current[0];
  return !this.started && !this.booted && process.nextTick(() => this._root.queue.resume()), e ? e.loadedSoFar() : Promise.resolve();
};
Object.defineProperty(Ze.prototype, "then", { get: Tv });
Ze.prototype._addPlugin = function(e, t, r) {
  if (xS(e) && (e = e.default), ES(e), t = t || {}, this.booted)
    throw new gS();
  const n = this._current[0];
  let s = this._opts.timeout;
  if (!n.loaded && n.timeout > 0) {
    const o = Date.now() - n.startTime;
    s = n.timeout - (o + 3);
  }
  const i = new $v(co(this, this._loadPluginNextTick, 1), e, t, r, s);
  if (this._trackPluginLoading(i), n.loaded)
    throw new Error(i.name, n.name);
  return n.enqueue(i, (o) => {
    o && (this._error = o);
  }), i;
};
Ze.prototype._expose = function() {
  const t = this, r = t._server, {
    use: n = "use",
    after: s = "after",
    ready: i = "ready",
    onClose: o = "onClose",
    close: a = "close"
  } = this._opts.expose;
  if (r[n])
    throw new hs(n, "use");
  if (r[n] = function(c, f) {
    return t.use(c, f), this;
  }, r[s])
    throw new hs(s, "after");
  if (r[s] = function(c) {
    return typeof c != "function" ? t._loadRegistered() : (t.after(sc(c, this)), this);
  }, r[i])
    throw new hs(i, "ready");
  if (r[i] = function(c) {
    if (c && typeof c != "function")
      throw new zn(i, typeof c);
    return t.ready(c ? sc(c, this) : void 0);
  }, r[o])
    throw new hs(o, "onClose");
  if (r[o] = function(c) {
    if (typeof c != "function")
      throw new zn(o, typeof c);
    return t.onClose($S(c, this)), this;
  }, r[a])
    throw new hs(a, "close");
  if (r[a] = function(c) {
    if (c && typeof c != "function")
      throw new zn(a, typeof c);
    return c ? (t.close(sc(c, this)), this) : t.close();
  }, r.then)
    throw new bS("then");
  Object.defineProperty(r, "then", { get: Tv.bind(t) }), r[wv] = !0;
};
Ze.prototype.after = function(e) {
  if (!e)
    return this._loadRegistered();
  this._addPlugin(t.bind(this), {}, !0);
  function t(r, n, s) {
    Ov.call(this, e, s);
  }
  return this;
};
Ze.prototype.onClose = function(e) {
  if (typeof e != "function")
    throw new zn("onClose", typeof e);
  return e[Rv] = !0, this._closeQ.unshift(e, (t) => {
    t && (this._error = t);
  }), this;
};
Ze.prototype.close = function(e) {
  let t;
  if (e) {
    if (typeof e != "function")
      throw new zn("close", typeof e);
  } else
    t = new Promise(function(r, n) {
      e = function(s) {
        if (s)
          return n(s);
        r();
      };
    });
  return this.ready(() => {
    this._error = null, this._closeQ.push(e), process.nextTick(this._closeQ.resume.bind(this._closeQ));
  }), t;
};
Ze.prototype.ready = function(e) {
  if (e) {
    if (typeof e != "function")
      throw new zn("ready", typeof e);
    this._readyQ.push(e), queueMicrotask(this.start.bind(this));
    return;
  }
  return new Promise((t, r) => {
    this._readyQ.push(s), this.start();
    const n = this._current[0].server;
    function s(i, o, a) {
      i ? r(i) : t(n), process.nextTick(a);
    }
  });
};
Ze.prototype._trackPluginLoading = function(e) {
  var r;
  const t = ((r = this._current[0]) == null ? void 0 : r.name) || null;
  e.once("start", (n, s, i) => {
    const o = this.pluginTree.start(t || null, s, i);
    e.once("loaded", (a, c, f) => {
      this.pluginTree.stop(o, f);
    });
  });
};
Ze.prototype.prettyPrint = function() {
  return this.pluginTree.prettyPrint();
};
Ze.prototype.toJSON = function() {
  return this.pluginTree.toJSON();
};
Ze.prototype._loadPlugin = function(e, t) {
  const r = this;
  if (SS(e.func)) {
    e.func.then((o) => {
      typeof o.default == "function" && (o = o.default), e.func = o, this._loadPlugin(e, t);
    }, t);
    return;
  }
  const n = r._current[0];
  if (r._current.unshift(e), r._error && !e.isAfter) {
    Gn("skipping loading of plugin as instance errored and it is not an after", e.name), process.nextTick(i);
    return;
  }
  let s = n && n.server || r._server;
  if (!e.isAfter)
    try {
      s = r.override(s, e.func, e.options);
    } catch (o) {
      return Gn("override errored", e.name), i(o);
    }
  e.exec(s, i);
  function i(o) {
    e.finish(o, (a) => {
      r._current.shift(), t(a);
    });
  }
};
Ze.prototype._loadPluginNextTick = function(e, t) {
  process.nextTick(this._loadPlugin.bind(this), e, t);
};
function Rp() {
}
function Ov(e, t) {
  const r = this._server, n = this._error;
  if (this._error = null, e.length === 0)
    this._error = n, wp(e, [], t);
  else if (e.length === 1)
    wp(e, [n], t);
  else if (this._opts.timeout === 0) {
    const s = (i) => {
      this._error = i, t(this._error);
    };
    e.length === 2 ? e(n, s) : e(n, r, s);
  } else
    wS.call(this, e, n, r, t);
}
function wS(e, t, r, n) {
  const s = e.unwrappedName ?? e.name;
  Gn("setting up ready timeout", s, this._opts.timeout);
  let i = setTimeout(() => {
    Gn("timed out", s), i = null;
    const a = new vS(s);
    a.fn = e, this._error = a, n(a);
  }, this._opts.timeout);
  e.length === 2 ? e(t, o.bind(this)) : e(t, r, o.bind(this));
  function o(a) {
    i && (clearTimeout(i), this._error = a, n(this._error));
  }
}
function RS(e, t) {
  const r = this._server, n = e[Rv];
  if (e.length === 0 || e.length === 1) {
    let s;
    n ? s = e(r) : s = e(this._error), s && typeof s.then == "function" ? (Gn("resolving close/onClose promise"), s.then(
      () => process.nextTick(t),
      (i) => process.nextTick(t, i)
    )) : process.nextTick(t);
  } else e.length === 2 ? e(n ? r : this._error, t) : n ? e(r, t) : e(this._error, r, t);
}
function $S(e, t) {
  return r.bind(t);
  function r(n, s) {
    let i;
    e.length === 0 ? (i = e(), i && i.then ? i.then(function() {
      process.nextTick(s);
    }, s) : process.nextTick(s)) : e.length === 1 ? (i = e(this), i && i.then ? i.then(function() {
      process.nextTick(s);
    }, s) : process.nextTick(s)) : e(this, s);
  }
}
function sc(e, t) {
  const r = n.bind(t);
  return r.unwrappedName = e.name, r;
  function n(s, i) {
    let o;
    e ? e.length === 0 ? (o = e(), o && o.then ? o.then(function() {
      process.nextTick(i, s);
    }, i) : process.nextTick(i, s)) : e.length === 1 ? (o = e(s), o && o.then ? o.then(function() {
      process.nextTick(i);
    }, i) : process.nextTick(i)) : e.length === 2 ? e(s, i) : e(s, this, i) : process.nextTick(i);
  }
}
var TS = Ze;
const OS = {
  kAvvioBoot: Symbol("fastify.avvioBoot"),
  kChildren: Symbol("fastify.children"),
  kServerBindings: Symbol("fastify.serverBindings"),
  kBodyLimit: Symbol("fastify.bodyLimit"),
  kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
  kRoutePrefix: Symbol("fastify.routePrefix"),
  kLogLevel: Symbol("fastify.logLevel"),
  kLogSerializers: Symbol("fastify.logSerializers"),
  kHooks: Symbol("fastify.hooks"),
  kContentTypeParser: Symbol("fastify.contentTypeParser"),
  kState: Symbol("fastify.state"),
  kOptions: Symbol("fastify.options"),
  kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
  kPluginNameChain: Symbol("fastify.pluginNameChain"),
  kRouteContext: Symbol("fastify.context"),
  kGenReqId: Symbol("fastify.genReqId"),
  // Schema
  kSchemaController: Symbol("fastify.schemaController"),
  kSchemaHeaders: Symbol("headers-schema"),
  kSchemaParams: Symbol("params-schema"),
  kSchemaQuerystring: Symbol("querystring-schema"),
  kSchemaBody: Symbol("body-schema"),
  kSchemaResponse: Symbol("response-schema"),
  kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
  kSchemaVisited: Symbol("fastify.schemas.visited"),
  // Request
  kRequest: Symbol("fastify.Request"),
  kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
  kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
  kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
  kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
  // 404
  kFourOhFour: Symbol("fastify.404"),
  kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
  kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
  kFourOhFourContext: Symbol("fastify.404ContextKey"),
  kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
  // Reply
  kReply: Symbol("fastify.Reply"),
  kReplySerializer: Symbol("fastify.reply.serializer"),
  kReplyIsError: Symbol("fastify.reply.isError"),
  kReplyHeaders: Symbol("fastify.reply.headers"),
  kReplyTrailers: Symbol("fastify.reply.trailers"),
  kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
  kReplyHijacked: Symbol("fastify.reply.hijacked"),
  kReplyStartTime: Symbol("fastify.reply.startTime"),
  kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
  kReplyEndTime: Symbol("fastify.reply.endTime"),
  kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
  kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
  kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
  kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
  kTestInternals: Symbol("fastify.testInternals"),
  kErrorHandler: Symbol("fastify.errorHandler"),
  kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
  kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
  kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
  kRouteByFastify: Symbol("fastify.routeByFastify")
};
var pt = OS, Pv = {}, ra = { exports: {} };
const { format: ic } = yn;
function PS(e) {
  return Cv({ ...e, name: "DeprecationWarning" });
}
function Cv({ name: e, code: t, message: r, unlimited: n = !1 } = {}) {
  if (!e) throw new Error("Warning name must not be empty");
  if (!t) throw new Error("Warning code must not be empty");
  if (!r) throw new Error("Warning message must not be empty");
  if (typeof n != "boolean") throw new Error("Warning opts.unlimited must be a boolean");
  t = t.toUpperCase();
  let s = {
    [e]: function(o, a, c) {
      i.emitted === !0 && i.unlimited !== !0 || (i.emitted = !0, process.emitWarning(i.format(o, a, c), i.name, i.code));
    }
  };
  n && (s = {
    [e]: function(o, a, c) {
      i.emitted = !0, process.emitWarning(i.format(o, a, c), i.name, i.code);
    }
  });
  const i = s[e];
  return i.emitted = !1, i.message = r, i.unlimited = n, i.code = t, i.format = function(o, a, c) {
    let f;
    return o && a && c ? f = ic(r, o, a, c) : o && a ? f = ic(r, o, a) : o ? f = ic(r, o) : f = r, f;
  }, i;
}
const Ku = { createWarning: Cv, createDeprecation: PS };
ra.exports = Ku;
ra.exports.default = Ku;
ra.exports.processWarning = Ku;
var Iv = ra.exports;
const { createWarning: Ju } = Iv, CS = Ju({
  name: "FastifyWarning",
  code: "FSTWRN001",
  message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
  unlimited: !0
}), IS = Ju({
  name: "FastifyWarning",
  code: "FSTWRN003",
  message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
  unlimited: !0
}), NS = Ju({
  name: "FastifySecurity",
  code: "FSTSEC001",
  message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
  unlimited: !0
});
var Yu = {
  FSTWRN001: CS,
  FSTWRN003: IS,
  FSTSEC001: NS
}, na = { exports: {} };
const te = xv, Zr = {
  /**
   * Basic
   */
  FST_ERR_NOT_FOUND: te(
    "FST_ERR_NOT_FOUND",
    "Not Found",
    404
  ),
  FST_ERR_OPTIONS_NOT_OBJ: te(
    "FST_ERR_OPTIONS_NOT_OBJ",
    "Options must be an object",
    500,
    TypeError
  ),
  FST_ERR_QSP_NOT_FN: te(
    "FST_ERR_QSP_NOT_FN",
    "querystringParser option should be a function, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: te(
    "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
    "schemaController.bucket option should be a function, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: te(
    "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
    "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
    500,
    TypeError
  ),
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: te(
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
    "ajv.customOptions option should be an object, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: te(
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
    "ajv.plugins option should be an array, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_VALIDATION: te(
    "FST_ERR_VALIDATION",
    "%s",
    400
  ),
  FST_ERR_LISTEN_OPTIONS_INVALID: te(
    "FST_ERR_LISTEN_OPTIONS_INVALID",
    "Invalid listen options: '%s'",
    500,
    TypeError
  ),
  FST_ERR_ERROR_HANDLER_NOT_FN: te(
    "FST_ERR_ERROR_HANDLER_NOT_FN",
    "Error Handler must be a function",
    500,
    TypeError
  ),
  /**
   * ContentTypeParser
  */
  FST_ERR_CTP_ALREADY_PRESENT: te(
    "FST_ERR_CTP_ALREADY_PRESENT",
    "Content type parser '%s' already present."
  ),
  FST_ERR_CTP_INVALID_TYPE: te(
    "FST_ERR_CTP_INVALID_TYPE",
    "The content type should be a string or a RegExp",
    500,
    TypeError
  ),
  FST_ERR_CTP_EMPTY_TYPE: te(
    "FST_ERR_CTP_EMPTY_TYPE",
    "The content type cannot be an empty string",
    500,
    TypeError
  ),
  FST_ERR_CTP_INVALID_HANDLER: te(
    "FST_ERR_CTP_INVALID_HANDLER",
    "The content type handler should be a function",
    500,
    TypeError
  ),
  FST_ERR_CTP_INVALID_PARSE_TYPE: te(
    "FST_ERR_CTP_INVALID_PARSE_TYPE",
    "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
    500,
    TypeError
  ),
  FST_ERR_CTP_BODY_TOO_LARGE: te(
    "FST_ERR_CTP_BODY_TOO_LARGE",
    "Request body is too large",
    413,
    RangeError
  ),
  FST_ERR_CTP_INVALID_MEDIA_TYPE: te(
    "FST_ERR_CTP_INVALID_MEDIA_TYPE",
    "Unsupported Media Type: %s",
    415
  ),
  FST_ERR_CTP_INVALID_CONTENT_LENGTH: te(
    "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
    "Request body size did not match Content-Length",
    400,
    RangeError
  ),
  FST_ERR_CTP_EMPTY_JSON_BODY: te(
    "FST_ERR_CTP_EMPTY_JSON_BODY",
    "Body cannot be empty when content-type is set to 'application/json'",
    400
  ),
  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: te(
    "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
    'Cannot call "%s" when fastify instance is already started!',
    400
  ),
  /**
   * decorate
  */
  FST_ERR_DEC_ALREADY_PRESENT: te(
    "FST_ERR_DEC_ALREADY_PRESENT",
    "The decorator '%s' has already been added!"
  ),
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: te(
    "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
    "The dependencies of decorator '%s' must be of type Array.",
    500,
    TypeError
  ),
  FST_ERR_DEC_MISSING_DEPENDENCY: te(
    "FST_ERR_DEC_MISSING_DEPENDENCY",
    "The decorator is missing dependency '%s'."
  ),
  FST_ERR_DEC_AFTER_START: te(
    "FST_ERR_DEC_AFTER_START",
    "The decorator '%s' has been added after start!"
  ),
  FST_ERR_DEC_REFERENCE_TYPE: te(
    "FST_ERR_DEC_REFERENCE_TYPE",
    "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
  ),
  /**
   * hooks
  */
  FST_ERR_HOOK_INVALID_TYPE: te(
    "FST_ERR_HOOK_INVALID_TYPE",
    "The hook name must be a string",
    500,
    TypeError
  ),
  FST_ERR_HOOK_INVALID_HANDLER: te(
    "FST_ERR_HOOK_INVALID_HANDLER",
    "%s hook should be a function, instead got %s",
    500,
    TypeError
  ),
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: te(
    "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
    "Async function has too many arguments. Async hooks should not use the 'done' argument.",
    500,
    TypeError
  ),
  FST_ERR_HOOK_NOT_SUPPORTED: te(
    "FST_ERR_HOOK_NOT_SUPPORTED",
    "%s hook not supported!",
    500,
    TypeError
  ),
  /**
   * Middlewares
   */
  FST_ERR_MISSING_MIDDLEWARE: te(
    "FST_ERR_MISSING_MIDDLEWARE",
    "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
    500
  ),
  FST_ERR_HOOK_TIMEOUT: te(
    "FST_ERR_HOOK_TIMEOUT",
    "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  /**
   * logger
  */
  FST_ERR_LOG_INVALID_DESTINATION: te(
    "FST_ERR_LOG_INVALID_DESTINATION",
    "Cannot specify both logger.stream and logger.file options"
  ),
  FST_ERR_LOG_INVALID_LOGGER: te(
    "FST_ERR_LOG_INVALID_LOGGER",
    "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
    500,
    TypeError
  ),
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: te(
    "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
    "loggerInstance only accepts a logger instance.",
    500,
    TypeError
  ),
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: te(
    "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
    "logger options only accepts a configuration object.",
    500,
    TypeError
  ),
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: te(
    "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
    "You cannot provide both logger and loggerInstance. Please provide only one.",
    500,
    TypeError
  ),
  /**
   * reply
  */
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: te(
    "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
    "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
    500,
    TypeError
  ),
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: te(
    "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
    "Response.body is already consumed."
  ),
  FST_ERR_REP_READABLE_STREAM_LOCKED: te(
    "FST_ERR_REP_READABLE_STREAM_LOCKED",
    "ReadableStream was locked. You should call releaseLock() method on reader before sending."
  ),
  FST_ERR_REP_ALREADY_SENT: te(
    "FST_ERR_REP_ALREADY_SENT",
    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
  ),
  FST_ERR_REP_SENT_VALUE: te(
    "FST_ERR_REP_SENT_VALUE",
    "The only possible value for reply.sent is true.",
    500,
    TypeError
  ),
  FST_ERR_SEND_INSIDE_ONERR: te(
    "FST_ERR_SEND_INSIDE_ONERR",
    "You cannot use `send` inside the `onError` hook"
  ),
  FST_ERR_SEND_UNDEFINED_ERR: te(
    "FST_ERR_SEND_UNDEFINED_ERR",
    "Undefined error has occurred"
  ),
  FST_ERR_BAD_STATUS_CODE: te(
    "FST_ERR_BAD_STATUS_CODE",
    "Called reply with an invalid status code: %s"
  ),
  FST_ERR_BAD_TRAILER_NAME: te(
    "FST_ERR_BAD_TRAILER_NAME",
    "Called reply.trailer with an invalid header name: %s"
  ),
  FST_ERR_BAD_TRAILER_VALUE: te(
    "FST_ERR_BAD_TRAILER_VALUE",
    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
  ),
  FST_ERR_FAILED_ERROR_SERIALIZATION: te(
    "FST_ERR_FAILED_ERROR_SERIALIZATION",
    "Failed to serialize an error. Error: %s. Original error: %s"
  ),
  FST_ERR_MISSING_SERIALIZATION_FN: te(
    "FST_ERR_MISSING_SERIALIZATION_FN",
    'Missing serialization function. Key "%s"'
  ),
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: te(
    "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
    'Missing serialization function. Key "%s:%s"'
  ),
  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: te(
    "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
    'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
  ),
  /**
   * schemas
  */
  FST_ERR_SCH_MISSING_ID: te(
    "FST_ERR_SCH_MISSING_ID",
    "Missing schema $id property"
  ),
  FST_ERR_SCH_ALREADY_PRESENT: te(
    "FST_ERR_SCH_ALREADY_PRESENT",
    "Schema with id '%s' already declared!"
  ),
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: te(
    "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
    "Schema is missing for the content type '%s'"
  ),
  FST_ERR_SCH_DUPLICATE: te(
    "FST_ERR_SCH_DUPLICATE",
    "Schema with '%s' already present!"
  ),
  FST_ERR_SCH_VALIDATION_BUILD: te(
    "FST_ERR_SCH_VALIDATION_BUILD",
    "Failed building the validation schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_SERIALIZATION_BUILD: te(
    "FST_ERR_SCH_SERIALIZATION_BUILD",
    "Failed building the serialization schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: te(
    "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
    'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
  ),
  /**
   * http2
   */
  FST_ERR_HTTP2_INVALID_VERSION: te(
    "FST_ERR_HTTP2_INVALID_VERSION",
    "HTTP2 is available only from node >= 8.8.1"
  ),
  /**
   * initialConfig
   */
  FST_ERR_INIT_OPTS_INVALID: te(
    "FST_ERR_INIT_OPTS_INVALID",
    "Invalid initialization options: '%s'"
  ),
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: te(
    "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
    "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
  ),
  /**
   * router
   */
  FST_ERR_DUPLICATED_ROUTE: te(
    "FST_ERR_DUPLICATED_ROUTE",
    "Method '%s' already declared for route '%s'"
  ),
  FST_ERR_BAD_URL: te(
    "FST_ERR_BAD_URL",
    "'%s' is not a valid url component",
    400,
    URIError
  ),
  FST_ERR_ASYNC_CONSTRAINT: te(
    "FST_ERR_ASYNC_CONSTRAINT",
    "Unexpected error from async constraint",
    500
  ),
  FST_ERR_INVALID_URL: te(
    "FST_ERR_INVALID_URL",
    "URL must be a string. Received '%s'",
    400,
    TypeError
  ),
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: te(
    "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
    'Options for "%s:%s" route must be an object',
    500,
    TypeError
  ),
  FST_ERR_ROUTE_DUPLICATED_HANDLER: te(
    "FST_ERR_ROUTE_DUPLICATED_HANDLER",
    'Duplicate handler for "%s:%s" route is not allowed!',
    500
  ),
  FST_ERR_ROUTE_HANDLER_NOT_FN: te(
    "FST_ERR_ROUTE_HANDLER_NOT_FN",
    "Error Handler for %s:%s route, if defined, must be a function",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_MISSING_HANDLER: te(
    "FST_ERR_ROUTE_MISSING_HANDLER",
    'Missing handler function for "%s:%s" route.',
    500
  ),
  FST_ERR_ROUTE_METHOD_INVALID: te(
    "FST_ERR_ROUTE_METHOD_INVALID",
    "Provided method is invalid!",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: te(
    "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
    "%s method is not supported.",
    500
  ),
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: te(
    "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
    "Body validation schema for %s:%s route is not supported!",
    500
  ),
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: te(
    "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
    "'bodyLimit' option must be an integer > 0. Got '%s'",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_REWRITE_NOT_STR: te(
    "FST_ERR_ROUTE_REWRITE_NOT_STR",
    'Rewrite url for "%s" needs to be of type "string" but received "%s"',
    500,
    TypeError
  ),
  /**
   *  again listen when close server
   */
  FST_ERR_REOPENED_CLOSE_SERVER: te(
    "FST_ERR_REOPENED_CLOSE_SERVER",
    "Fastify has already been closed and cannot be reopened"
  ),
  FST_ERR_REOPENED_SERVER: te(
    "FST_ERR_REOPENED_SERVER",
    "Fastify is already listening"
  ),
  FST_ERR_INSTANCE_ALREADY_LISTENING: te(
    "FST_ERR_INSTANCE_ALREADY_LISTENING",
    "Fastify instance is already listening. %s"
  ),
  /**
   * plugin
   */
  FST_ERR_PLUGIN_VERSION_MISMATCH: te(
    "FST_ERR_PLUGIN_VERSION_MISMATCH",
    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
  ),
  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: te(
    "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
    "The decorator '%s'%s is not present in %s"
  ),
  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: te(
    "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
    "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
    500,
    TypeError
  ),
  /**
   *  Avvio Errors
   */
  FST_ERR_PLUGIN_CALLBACK_NOT_FN: te(
    "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
    "fastify-plugin: %s",
    500,
    TypeError
  ),
  FST_ERR_PLUGIN_NOT_VALID: te(
    "FST_ERR_PLUGIN_NOT_VALID",
    "fastify-plugin: %s"
  ),
  FST_ERR_ROOT_PLG_BOOTED: te(
    "FST_ERR_ROOT_PLG_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PARENT_PLUGIN_BOOTED: te(
    "FST_ERR_PARENT_PLUGIN_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PLUGIN_TIMEOUT: te(
    "FST_ERR_PLUGIN_TIMEOUT",
    "fastify-plugin: %s"
  )
};
function AS(e, t) {
  return t.cause = e, t;
}
na.exports = Zr;
na.exports.appendStackTrace = AS;
na.exports.AVVIO_ERRORS_MAP = {
  AVV_ERR_CALLBACK_NOT_FN: Zr.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
  AVV_ERR_PLUGIN_NOT_VALID: Zr.FST_ERR_PLUGIN_NOT_VALID,
  AVV_ERR_ROOT_PLG_BOOTED: Zr.FST_ERR_ROOT_PLG_BOOTED,
  AVV_ERR_PARENT_PLG_LOADED: Zr.FST_ERR_PARENT_PLUGIN_BOOTED,
  AVV_ERR_READY_TIMEOUT: Zr.FST_ERR_PLUGIN_TIMEOUT,
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: Zr.FST_ERR_PLUGIN_TIMEOUT
};
var bt = na.exports;
const kS = [
  "onRoute",
  "onRegister",
  "onReady",
  "onListen",
  "preClose",
  "onClose"
], Nv = [
  "onTimeout",
  "onRequest",
  "preParsing",
  "preValidation",
  "preSerialization",
  "preHandler",
  "onSend",
  "onResponse",
  "onError",
  "onRequestAbort"
], LS = Nv.concat(kS), {
  FST_ERR_HOOK_INVALID_TYPE: jS,
  FST_ERR_HOOK_INVALID_HANDLER: DS,
  FST_ERR_SEND_UNDEFINED_ERR: sa,
  FST_ERR_HOOK_TIMEOUT: FS,
  FST_ERR_HOOK_NOT_SUPPORTED: MS,
  AVVIO_ERRORS_MAP: $p,
  appendStackTrace: Tp
} = bt, {
  kChildren: As,
  kHooks: Av,
  kRequestPayloadStream: Op
} = pt;
function ci() {
  this.onRequest = [], this.preParsing = [], this.preValidation = [], this.preSerialization = [], this.preHandler = [], this.onResponse = [], this.onSend = [], this.onError = [], this.onRoute = [], this.onRegister = [], this.onReady = [], this.onListen = [], this.onTimeout = [], this.onRequestAbort = [], this.preClose = [];
}
ci.prototype = /* @__PURE__ */ Object.create(null);
ci.prototype.validate = function(e, t) {
  if (typeof e != "string") throw new jS();
  if (Array.isArray(this[e]) === !1)
    throw new MS(e);
  if (typeof t != "function") throw new DS(e, Object.prototype.toString.call(t));
};
ci.prototype.add = function(e, t) {
  this.validate(e, t), this[e].push(t);
};
function zS(e) {
  const t = new ci();
  return t.onRequest = e.onRequest.slice(), t.preParsing = e.preParsing.slice(), t.preValidation = e.preValidation.slice(), t.preSerialization = e.preSerialization.slice(), t.preHandler = e.preHandler.slice(), t.onSend = e.onSend.slice(), t.onResponse = e.onResponse.slice(), t.onError = e.onError.slice(), t.onRoute = e.onRoute.slice(), t.onRegister = e.onRegister.slice(), t.onTimeout = e.onTimeout.slice(), t.onRequestAbort = e.onRequestAbort.slice(), t.onReady = [], t.onListen = [], t.preClose = [], t;
}
function kv(e, t, r, n) {
  const s = r[Av][e];
  let i = 0, o = 0;
  c();
  function a(l) {
    var p;
    const d = (p = s[i - 1]) == null ? void 0 : p.name, g = d ? ` "${d}"` : "";
    if (l) {
      l.code === "AVV_ERR_READY_TIMEOUT" ? l = Tp(l, new FS(e, g)) : l = $p[l.code] != null ? Tp(l, new $p[l.code](l.message)) : l, n(l);
      return;
    }
    n();
  }
  function c(l) {
    if (l) {
      a(l);
      return;
    }
    if (i === s.length && o === r[As].length) {
      i === 0 && o === 0 ? a() : t(function(g, p) {
        a(g), p(g);
      });
      return;
    }
    if (i === s.length && o < r[As].length) {
      const d = r[As][o++];
      kv(e, t, d, c);
      return;
    }
    t(f(s[i++], r)), c();
  }
  function f(l, d) {
    return function(g, p) {
      if (g) {
        p(g);
        return;
      }
      if (l.length === 1) {
        try {
          l.call(d, p);
        } catch (u) {
          p(u);
        }
        return;
      }
      try {
        const u = l.call(d);
        if (u && typeof u.then == "function") {
          u.then(p, p);
          return;
        }
      } catch (u) {
        g = u;
      }
      p(g);
    };
  }
}
function Lv(e) {
  const t = e[Av].onListen, r = t.length;
  let n = 0, s = 0;
  i();
  function i(a) {
    if (a && e.log.error(a), n === r) {
      for (; s < e[As].length; ) {
        const c = e[As][s++];
        Lv(c);
      }
      return;
    }
    o(t[n++], e, i);
  }
  async function o(a, c, f) {
    if (a.length === 1) {
      try {
        a.call(c, f);
      } catch (l) {
        f(l);
      }
      return;
    }
    try {
      const l = a.call(c);
      if (l && typeof l.then == "function") {
        l.then(f, f);
        return;
      }
      f();
    } catch (l) {
      f(l);
    }
  }
}
function li(e) {
  return function(r, n, s, i) {
    let o = 0;
    function a(l) {
      if (l || o === r.length) {
        i(l, n, s);
        return;
      }
      let d;
      try {
        d = e(r[o++], n, s, a);
      } catch (g) {
        i(g, n, s);
        return;
      }
      d && typeof d.then == "function" && d.then(c, f);
    }
    function c() {
      a();
    }
    function f(l) {
      l || (l = new sa()), i(l, n, s);
    }
    a();
  };
}
function US(e, t, r, n) {
  return e(t, r, n);
}
const qS = li(US), HS = li(ia), BS = li(ia), VS = li(ia), GS = li(ia);
function jv(e, t, r, n, s) {
  let i = 0;
  function o(f, l) {
    if (f) {
      s(f, t, r, n);
      return;
    }
    if (l !== void 0 && (n = l), i === e.length) {
      s(null, t, r, n);
      return;
    }
    let d;
    try {
      d = e[i++](t, r, n, o);
    } catch (g) {
      s(g, t, r);
      return;
    }
    d && typeof d.then == "function" && d.then(a, c);
  }
  function a(f) {
    o(null, f);
  }
  function c(f) {
    f || (f = new sa()), s(f, t, r, n);
  }
  o();
}
const WS = jv;
function KS(e, t, r, n) {
  let s = 0;
  function i(c, f) {
    if (r.sent)
      return;
    if (f !== void 0 && (t[Op] = f), c || s === e.length) {
      n(c, t, r);
      return;
    }
    let l;
    try {
      l = e[s++](t, r, t[Op], i);
    } catch (d) {
      n(d, t, r);
      return;
    }
    l && typeof l.then == "function" && l.then(o, a);
  }
  function o(c) {
    i(null, c);
  }
  function a(c) {
    c || (c = new sa()), n(c, t, r);
  }
  i();
}
function JS(e, t, r) {
  let n = 0;
  function s(a) {
    if (a || n === e.length) {
      r(a, t);
      return;
    }
    let c;
    try {
      c = e[n++](t, s);
    } catch (f) {
      r(f, t);
      return;
    }
    c && typeof c.then == "function" && c.then(i, o);
  }
  function i() {
    s();
  }
  function o(a) {
    a || (a = new sa()), r(a, t);
  }
  s();
}
function ia(e, t, r, n) {
  if (r.sent !== !0)
    return e(t, r, n);
}
var bn = {
  Hooks: ci,
  buildHooks: zS,
  preParsingHookRunner: KS,
  onResponseHookRunner: qS,
  onSendHookRunner: jv,
  preSerializationHookRunner: WS,
  onRequestAbortHookRunner: JS,
  hookRunnerApplication: kv,
  onListenHookRunner: Lv,
  preHandlerHookRunner: BS,
  preValidationHookRunner: HS,
  onRequestHookRunner: GS,
  onTimeoutHookRunner: VS,
  lifecycleHooks: Nv,
  supportedHooks: LS
};
const YS = ea, XS = yx, ZS = gx, QS = yv, { kState: vt, kOptions: ew, kServerBindings: tw } = pt, { FSTWRN003: rw } = Yu, { onListenHookRunner: Oi } = bn, {
  FST_ERR_HTTP2_INVALID_VERSION: nw,
  FST_ERR_REOPENED_CLOSE_SERVER: Dv,
  FST_ERR_REOPENED_SERVER: Fv,
  FST_ERR_LISTEN_OPTIONS_INVALID: sw
} = bt;
Pv.createServer = iw;
function Mv(e) {
  return `Server listening at ${e}`;
}
function iw(e, t) {
  const r = Uv(e, t);
  function n(s = { port: 0, host: "localhost" }, i = void 0) {
    if (typeof i == "function" && (i.constructor.name === "AsyncFunction" && rw("listen method"), s.cb = i), s.signal) {
      if (typeof s.signal.on != "function" && typeof s.signal.addEventListener != "function")
        throw new sw("Invalid options.signal");
      if (s.signal.aborted)
        this.close();
      else {
        const a = () => {
          this.close();
        };
        s.signal.addEventListener("abort", a, { once: !0 });
      }
    }
    let o;
    if (s.path == null ? o = s.host ?? "localhost" : o = s.host, (!Object.hasOwn(s, "host") || s.host == null) && (s.host = o), o === "localhost" ? s.cb = (a, c) => {
      if (a) {
        i(a, c);
        return;
      }
      Pp.call(this, r, t, e, s, () => {
        this[vt].listening = !0, i(null, c), Oi(this);
      });
    } : s.cb = (a, c) => {
      if (a) {
        i(a, c);
        return;
      }
      this[vt].listening = !0, i(null, c), Oi(this);
    }, i === void 0)
      return ow.call(this, r, s).then((c) => new Promise((f, l) => {
        o === "localhost" ? Pp.call(this, r, t, e, s, () => {
          this[vt].listening = !0, f(c), Oi(this);
        }) : (f(c), Oi(this));
      }));
    this.ready(zv.call(this, r, s));
  }
  return { server: r, listen: n };
}
function Pp(e, t, r, n, s) {
  this[vt].listening = !1, ZS.lookup(n.host, { all: !0 }, (i, o) => {
    if (i) {
      s();
      return;
    }
    const a = e.listening && r.serverFactory;
    let c = 0, f = 0;
    if (!a) {
      const d = e.address();
      for (const g of o)
        if (g.address !== d.address) {
          c++;
          const p = Object.assign({}, n, {
            host: g.address,
            port: d.port,
            cb: (b) => {
              f++, b || this[tw].push(u), f === c && s();
            }
          }), u = Uv(r, t), h = () => {
            u.close(() => {
            }), typeof u.closeAllConnections == "function" && r.forceCloseConnections === !0 && u.closeAllConnections();
          };
          u.on("upgrade", e.emit.bind(e, "upgrade")), e.on("unref", h), e.on("close", h), e.on("error", h), this[vt].listening = !1, zv.call(this, u, p)();
        }
    }
    if (c === 0) {
      s();
      return;
    }
    const l = e.unref;
    e.unref = function() {
      l.call(e), e.emit("unref");
    };
  });
}
function zv(e, t) {
  const r = (n) => {
    if (e.removeListener("error", r), e.removeListener("listening", r), n)
      this[vt].listening = !1, t.cb(n, null);
    else {
      const s = qv.call(this, e, t.listenTextResolver || Mv);
      t.cb(null, s);
    }
  };
  return (n) => {
    if (n != null) return t.cb(n);
    if (this[vt].listening && this[vt].closing)
      return t.cb(new Dv(), null);
    if (this[vt].listening)
      return t.cb(new Fv(), null);
    e.once("error", r), this[vt].closing || (e.once("listening", r), e.listen(t), this[vt].listening = !0);
  };
}
function ow(e, t) {
  return this[vt].listening && this[vt].closing ? Promise.reject(new Dv()) : this[vt].listening ? Promise.reject(new Fv()) : this.ready().then(() => {
    let r, n;
    function s() {
      e.removeListener("error", r), e.removeListener("listening", n);
    }
    const i = new Promise((a, c) => {
      r = (f) => {
        s(), this[vt].listening = !1, c(f);
      }, e.once("error", r);
    }), o = new Promise((a, c) => {
      n = () => {
        s(), this[vt].listening = !0, a(qv.call(this, e, t.listenTextResolver || Mv));
      }, e.once("listening", n);
    });
    return e.listen(t), Promise.race([
      i,
      // e.g invalid port range error is always emitted before the server listening
      o
    ]);
  });
}
function Uv(e, t) {
  let r = null;
  const n = e.https === !0 ? {} : e.https;
  return e.serverFactory ? r = e.serverFactory(t, e) : e.http2 ? (typeof n == "object" ? r = Cp().createSecureServer(n, t) : r = Cp().createServer(t), r.on("session", cw(e.http2SessionTimeout))) : (n ? r = XS.createServer(n, t) : r = YS.createServer(e.http, t), r.keepAliveTimeout = e.keepAliveTimeout, r.requestTimeout = e.requestTimeout, e.maxRequestsPerSocket > 0 && (r.maxRequestsPerSocket = e.maxRequestsPerSocket)), e.serverFactory || r.setTimeout(e.connectionTimeout), r;
}
function aw(e) {
  return e.address === "0.0.0.0" ? Object.values(QS.networkInterfaces()).flatMap((t) => t.filter((r) => r.family === "IPv4")).sort((t) => t.internal ? -1 : 1).map((t) => t.address) : [e.address];
}
function qv(e, t) {
  let r;
  typeof e.address() == "string" ? r = [e.address()] : (e.address().address.indexOf(":") === -1 ? r = aw(e.address()).map((s) => s + ":" + e.address().port) : r = ["[" + e.address().address + "]:" + e.address().port], r = r.map((s) => "http" + (this[ew].https ? "s" : "") + "://" + s));
  for (const s of r)
    this.log.info(t(s));
  return r[0];
}
function Cp() {
  try {
    return require("node:http2");
  } catch {
    throw new nw();
  }
}
function cw(e) {
  return function(t) {
    t.setTimeout(e, lw);
  };
}
function lw() {
  this.close();
}
var oa = { exports: {} }, Hv = { exports: {} };
const {
  kSchemaHeaders: tu,
  kSchemaParams: Bv,
  kSchemaQuerystring: Vv,
  kSchemaBody: Dn,
  kSchemaResponse: uw
} = pt, fw = /^[1-5](?:\d{2}|xx)$|^default$/, {
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: dw
} = bt, { FSTWRN001: Pi } = Yu;
function pw(e, t) {
  if (!e.schema || !e.schema.response)
    return;
  const { method: r, url: n } = e.config || {};
  e[uw] = Object.keys(e.schema.response).reduce(function(s, i) {
    const o = e.schema.response[i];
    if (i = i.toLowerCase(), !fw.test(i))
      throw new dw();
    if (o.content) {
      const a = {};
      for (const c of Object.keys(o.content)) {
        const f = o.content[c].schema;
        a[c] = t({
          schema: f,
          url: n,
          method: r,
          httpStatus: i,
          contentType: c
        });
      }
      s[i] = a;
    } else
      s[i] = t({
        schema: o,
        url: n,
        method: r,
        httpStatus: i
      });
    return s;
  }, {});
}
function hw(e, t, r) {
  const { schema: n } = e;
  if (!n)
    return;
  const { method: s, url: i } = e.config || {}, o = n.headers;
  if (o && (r || Object.getPrototypeOf(o) !== Object.prototype))
    e[tu] = t({ schema: o, method: s, url: i, httpPart: "headers" });
  else if (o) {
    const a = {};
    Object.keys(o).forEach((c) => {
      a[c] = o[c];
    }), a.required instanceof Array && (a.required = a.required.map((c) => c.toLowerCase())), o.properties && (a.properties = {}, Object.keys(o.properties).forEach((c) => {
      a.properties[c.toLowerCase()] = o.properties[c];
    })), e[tu] = t({ schema: a, method: s, url: i, httpPart: "headers" });
  } else Object.hasOwn(n, "headers") && Pi("headers", s, i);
  if (n.body) {
    const a = n.body.content;
    if (a) {
      const c = {};
      for (const f of Object.keys(a)) {
        const l = a[f].schema;
        c[f] = t({ schema: l, method: s, url: i, httpPart: "body", contentType: f });
      }
      e[Dn] = c;
    } else
      e[Dn] = t({ schema: n.body, method: s, url: i, httpPart: "body" });
  } else Object.hasOwn(n, "body") && Pi("body", s, i);
  n.querystring ? e[Vv] = t({ schema: n.querystring, method: s, url: i, httpPart: "querystring" }) : Object.hasOwn(n, "querystring") && Pi("querystring", s, i), n.params ? e[Bv] = t({ schema: n.params, method: s, url: i, httpPart: "params" }) : Object.hasOwn(n, "params") && Pi("params", s, i);
}
function Ci(e, t, r) {
  const n = t[r] === void 0, s = e && e(n ? null : t[r]);
  if (s && typeof s.then == "function")
    return s.then((o) => i(o)).catch((o) => o);
  return i(s);
  function i(o) {
    return o === !1 ? e.errors : o && o.error ? o.error : (o && o.value && (t[r] = o.value), !1);
  }
}
function aa(e, t, r) {
  var i;
  const n = r === void 0;
  if (n || !r.skipParams) {
    const o = Ci(e[Bv], t, "params");
    if (o)
      return typeof o.then != "function" ? jr(o, "params", e.schemaErrorFormatter) : mw(o, e, t);
  }
  if (n || !r.skipBody) {
    let o = null;
    if (typeof e[Dn] == "function")
      o = e[Dn];
    else if (e[Dn]) {
      const c = (i = t.headers["content-type"]) == null ? void 0 : i.split(";", 1)[0], f = e[Dn][c];
      f && (o = f);
    }
    const a = Ci(o, t, "body");
    if (a)
      return typeof a.then != "function" ? jr(a, "body", e.schemaErrorFormatter) : yw(a, e, t);
  }
  if (n || !r.skipQuery) {
    const o = Ci(e[Vv], t, "query");
    if (o)
      return typeof o.then != "function" ? jr(o, "querystring", e.schemaErrorFormatter) : gw(o, e, t);
  }
  const s = Ci(e[tu], t, "headers");
  return s ? typeof s.then != "function" ? jr(s, "headers", e.schemaErrorFormatter) : vw(s, e) : !1;
}
function mw(e, t, r) {
  return e.then((n) => n ? jr(n, "params", t.schemaErrorFormatter) : aa(t, r, { skipParams: !0 }));
}
function yw(e, t, r) {
  return e.then((n) => n ? jr(n, "body", t.schemaErrorFormatter) : aa(t, r, { skipParams: !0, skipBody: !0 }));
}
function gw(e, t, r) {
  return e.then((n) => n ? jr(n, "querystring", t.schemaErrorFormatter) : aa(t, r, { skipParams: !0, skipBody: !0, skipQuery: !0 }));
}
function vw(e, t, r) {
  return e.then((n) => n ? jr(n, "headers", t.schemaErrorFormatter) : !1);
}
function jr(e, t, r) {
  if (e instanceof Error)
    return e.statusCode = e.statusCode || 400, e.code = e.code || "FST_ERR_VALIDATION", e.validationContext = e.validationContext || t, e;
  const n = r(e, t);
  return n.statusCode = n.statusCode || 400, n.code = n.code || "FST_ERR_VALIDATION", n.validation = e, n.validationContext = t, n;
}
var Gv = {
  compileSchemasForValidation: hw,
  compileSchemasForSerialization: pw,
  validate: aa
};
const {
  kReplyIsError: Ip,
  kReplyHijacked: bw
} = pt, _w = zu, ms = _w.tracingChannel("fastify.request.handler");
function Ew(e, t, r) {
  r && (r.async = !0), e.then(function(n) {
    if (t[bw] !== !0) {
      r && ms.asyncStart.publish(r);
      try {
        if (n !== void 0 || //
        t.sent === !1 && //
        t.raw.headersSent === !1 && t.request.raw.aborted === !1 && t.request.socket && !t.request.socket.destroyed)
          try {
            t.send(n);
          } catch (s) {
            t[Ip] = !0, t.send(s);
          }
      } finally {
        r && ms.asyncEnd.publish(r);
      }
    }
  }, function(n) {
    r && (r.error = n, ms.error.publish(r), ms.asyncStart.publish(r));
    try {
      if (t.sent === !0) {
        t.log.error({ err: n }, "Promise errored, but reply.sent = true was set");
        return;
      }
      t[Ip] = !0, t.send(n);
    } catch (s) {
      t.send(s);
    } finally {
      r && ms.asyncEnd.publish(r);
    }
  });
}
var Wv = Ew;
(function(e) {
  const t = zu, { validate: r } = Gv, { preValidationHookRunner: n, preHandlerHookRunner: s } = bn, i = Wv, {
    kReplyIsError: o,
    kRouteContext: a,
    kFourOhFourContext: c,
    kSupportedHTTPMethods: f
  } = pt, l = t.tracingChannel("fastify.request.handler");
  function d(m, v, y) {
    if (y.sent === !0) return;
    if (m != null) {
      y[o] = !0, y.send(m);
      return;
    }
    const _ = v.raw.method, R = v.headers, E = v[a];
    if (this[f].bodyless.has(_)) {
      g(v, y);
      return;
    }
    if (this[f].bodywith.has(_)) {
      const O = R["content-type"], z = R["content-length"], x = R["transfer-encoding"];
      if (O === void 0)
        (z === void 0 || z === "0") && x === void 0 ? g(v, y) : E.contentTypeParser.run("", g, v, y);
      else {
        if (z === void 0 && x === void 0 && _ === "OPTIONS") {
          g(v, y);
          return;
        }
        E.contentTypeParser.run(O, g, v, y);
      }
      return;
    }
    g(v, y);
  }
  function g(m, v) {
    try {
      m[a].preValidation !== null ? n(
        m[a].preValidation,
        m,
        v,
        p
      ) : p(null, m, v);
    } catch (y) {
      p(y, m, v);
    }
  }
  function p(m, v, y) {
    if (y.sent === !0) return;
    if (m != null) {
      y[o] = !0, y.send(m);
      return;
    }
    const _ = r(y[a], v);
    if (_ && typeof _.then == "function" || !1) {
      const E = u.bind(null, v, y);
      _.then(E, E);
    } else
      u(v, y, _);
  }
  function u(m, v, y) {
    if (y) {
      if (v[a].attachValidation === !1) {
        v.send(y);
        return;
      }
      v.request.validationError = y;
    }
    m[a].preHandler !== null ? s(
      m[a].preHandler,
      m,
      v,
      h
    ) : h(null, m, v);
  }
  function h(m, v, y) {
    if (y.sent) return;
    const _ = v[a];
    if (!l.hasSubscribers || _[c] === null)
      b(m, v, y);
    else {
      const R = {
        request: v,
        reply: y,
        async: !1,
        route: {
          url: _.config.url,
          method: _.config.method
        }
      };
      l.start.runStores(R, b, void 0, m, v, y, R);
    }
  }
  function b(m, v, y, _) {
    const R = v[a];
    try {
      if (m != null) {
        y[o] = !0, y.send(m), _ && (_.error = m, l.error.publish(_));
        return;
      }
      let E;
      try {
        E = R.handler(v, y);
      } catch (O) {
        _ && (_.error = O, l.error.publish(_)), y[o] = !0, y.send(O);
        return;
      }
      E !== void 0 && (E !== null && typeof E.then == "function" ? i(E, y, _) : y.send(E));
    } finally {
      _ && l.end.publish(_);
    }
  }
  e.exports = d, e.exports[Symbol.for("internals")] = { handler: g, preHandlerCallback: h };
})(Hv);
var Kv = Hv.exports, lo = { exports: {} };
lo.exports;
var Np;
function xw() {
  return Np || (Np = 1, function(e) {
    function t() {
    }
    const r = {
      fatal: t,
      error: t,
      warn: t,
      info: t,
      debug: t,
      trace: t
    };
    Object.defineProperty(e, "exports", {
      get() {
        return Object.create(r);
      }
    });
  }(lo)), lo.exports;
}
var It = { exports: {} }, oc, Ap;
function Jv() {
  if (Ap) return oc;
  Ap = 1;
  const e = (o) => o && typeof o.message == "string", t = (o) => {
    if (!o) return;
    const a = o.cause;
    if (typeof a == "function") {
      const c = o.cause();
      return e(c) ? c : void 0;
    } else
      return e(a) ? a : void 0;
  }, r = (o, a) => {
    if (!e(o)) return "";
    const c = o.stack || "";
    if (a.has(o))
      return c + `
causes have become circular...`;
    const f = t(o);
    return f ? (a.add(o), c + `
caused by: ` + r(f, a)) : c;
  }, n = (o) => r(o, /* @__PURE__ */ new Set()), s = (o, a, c) => {
    if (!e(o)) return "";
    const f = c ? "" : o.message || "";
    if (a.has(o))
      return f + ": ...";
    const l = t(o);
    if (l) {
      a.add(o);
      const d = typeof o.cause == "function";
      return f + (d ? "" : ": ") + s(l, a, d);
    } else
      return f;
  };
  return oc = {
    isErrorLike: e,
    getErrorCause: t,
    stackWithCauses: n,
    messageWithCauses: (o) => s(o, /* @__PURE__ */ new Set())
  }, oc;
}
var ac, kp;
function Yv() {
  if (kp) return ac;
  kp = 1;
  const e = Symbol("circular-ref-tag"), t = Symbol("pino-raw-err-ref"), r = Object.create({}, {
    type: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    message: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    stack: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    aggregateErrors: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[t];
      },
      set: function(n) {
        this[t] = n;
      }
    }
  });
  return Object.defineProperty(r, t, {
    writable: !0,
    value: {}
  }), ac = {
    pinoErrProto: r,
    pinoErrorSymbols: {
      seen: e,
      rawSymbol: t
    }
  }, ac;
}
var cc, Lp;
function Sw() {
  if (Lp) return cc;
  Lp = 1, cc = a;
  const { messageWithCauses: e, stackWithCauses: t, isErrorLike: r } = Jv(), { pinoErrProto: n, pinoErrorSymbols: s } = Yv(), { seen: i } = s, { toString: o } = Object.prototype;
  function a(c) {
    if (!r(c))
      return c;
    c[i] = void 0;
    const f = Object.create(n);
    f.type = o.call(c.constructor) === "[object Function]" ? c.constructor.name : c.name, f.message = e(c), f.stack = t(c), Array.isArray(c.errors) && (f.aggregateErrors = c.errors.map((l) => a(l)));
    for (const l in c)
      if (f[l] === void 0) {
        const d = c[l];
        r(d) ? l !== "cause" && !Object.prototype.hasOwnProperty.call(d, i) && (f[l] = a(d)) : f[l] = d;
      }
    return delete c[i], f.raw = c, f;
  }
  return cc;
}
var lc, jp;
function ww() {
  if (jp) return lc;
  jp = 1, lc = i;
  const { isErrorLike: e } = Jv(), { pinoErrProto: t, pinoErrorSymbols: r } = Yv(), { seen: n } = r, { toString: s } = Object.prototype;
  function i(o) {
    if (!e(o))
      return o;
    o[n] = void 0;
    const a = Object.create(t);
    a.type = s.call(o.constructor) === "[object Function]" ? o.constructor.name : o.name, a.message = o.message, a.stack = o.stack, Array.isArray(o.errors) && (a.aggregateErrors = o.errors.map((c) => i(c))), e(o.cause) && !Object.prototype.hasOwnProperty.call(o.cause, n) && (a.cause = i(o.cause));
    for (const c in o)
      if (a[c] === void 0) {
        const f = o[c];
        e(f) ? Object.prototype.hasOwnProperty.call(f, n) || (a[c] = i(f)) : a[c] = f;
      }
    return delete o[n], a.raw = o, a;
  }
  return lc;
}
var uc, Dp;
function Rw() {
  if (Dp) return uc;
  Dp = 1, uc = {
    mapHttpRequest: n,
    reqSerializer: r
  };
  const e = Symbol("pino-raw-req-ref"), t = Object.create({}, {
    id: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    method: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    url: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    query: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    params: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    headers: {
      enumerable: !0,
      writable: !0,
      value: {}
    },
    remoteAddress: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    remotePort: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[e];
      },
      set: function(s) {
        this[e] = s;
      }
    }
  });
  Object.defineProperty(t, e, {
    writable: !0,
    value: {}
  });
  function r(s) {
    const i = s.info || s.socket, o = Object.create(t);
    if (o.id = typeof s.id == "function" ? s.id() : s.id || (s.info ? s.info.id : void 0), o.method = s.method, s.originalUrl)
      o.url = s.originalUrl;
    else {
      const a = s.path;
      o.url = typeof a == "string" ? a : s.url ? s.url.path || s.url : void 0;
    }
    return s.query && (o.query = s.query), s.params && (o.params = s.params), o.headers = s.headers, o.remoteAddress = i && i.remoteAddress, o.remotePort = i && i.remotePort, o.raw = s.raw || s, o;
  }
  function n(s) {
    return {
      req: r(s)
    };
  }
  return uc;
}
var fc, Fp;
function $w() {
  if (Fp) return fc;
  Fp = 1, fc = {
    mapHttpResponse: n,
    resSerializer: r
  };
  const e = Symbol("pino-raw-res-ref"), t = Object.create({}, {
    statusCode: {
      enumerable: !0,
      writable: !0,
      value: 0
    },
    headers: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[e];
      },
      set: function(s) {
        this[e] = s;
      }
    }
  });
  Object.defineProperty(t, e, {
    writable: !0,
    value: {}
  });
  function r(s) {
    const i = Object.create(t);
    return i.statusCode = s.headersSent ? s.statusCode : null, i.headers = s.getHeaders ? s.getHeaders() : s._headers, i.raw = s, i;
  }
  function n(s) {
    return {
      res: r(s)
    };
  }
  return fc;
}
var dc, Mp;
function Xv() {
  if (Mp) return dc;
  Mp = 1;
  const e = Sw(), t = ww(), r = Rw(), n = $w();
  return dc = {
    err: e,
    errWithCause: t,
    mapHttpRequest: r.mapHttpRequest,
    mapHttpResponse: n.mapHttpResponse,
    req: r.reqSerializer,
    res: n.resSerializer,
    wrapErrorSerializer: function(i) {
      return i === e ? i : function(a) {
        return i(e(a));
      };
    },
    wrapRequestSerializer: function(i) {
      return i === r.reqSerializer ? i : function(a) {
        return i(r.reqSerializer(a));
      };
    },
    wrapResponseSerializer: function(i) {
      return i === n.resSerializer ? i : function(a) {
        return i(n.resSerializer(a));
      };
    }
  }, dc;
}
var pc, zp;
function Zv() {
  if (zp) return pc;
  zp = 1;
  function e(t, r) {
    return r;
  }
  return pc = function() {
    const r = Error.prepareStackTrace;
    Error.prepareStackTrace = e;
    const n = new Error().stack;
    if (Error.prepareStackTrace = r, !Array.isArray(n))
      return;
    const s = n.slice(2), i = [];
    for (const o of s)
      o && i.push(o.getFileName());
    return i;
  }, pc;
}
var hc, Up;
function Tw() {
  if (Up) return hc;
  Up = 1, hc = e;
  function e(t = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS: r = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH: n = (s) => `fast-redact – Invalid path (${s})`
    } = t;
    return function({ paths: i }) {
      i.forEach((o) => {
        if (typeof o != "string")
          throw Error(r());
        try {
          if (/〇/.test(o)) throw Error();
          const a = (o[0] === "[" ? "" : ".") + o.replace(/^\*/, "〇").replace(/\.\*/g, ".〇").replace(/\[\*\]/g, "[〇]");
          if (/\n|\r|;/.test(a) || /\/\*/.test(a)) throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const 〇 = null;
            o${a}
            if ([o${a}].length !== 1) throw Error()`)();
        } catch {
          throw Error(n(o));
        }
      });
    };
  }
  return hc;
}
var mc, qp;
function Xu() {
  return qp || (qp = 1, mc = /[^.[\]]+|\[((?:.)*?)\]/g), mc;
}
var yc, Hp;
function Ow() {
  if (Hp) return yc;
  Hp = 1;
  const e = Xu();
  yc = t;
  function t({ paths: r }) {
    const n = [];
    var s = 0;
    const i = r.reduce(function(o, a, c) {
      var f = a.match(e).map((g) => g.replace(/'|"|`/g, ""));
      const l = a[0] === "[";
      f = f.map((g) => g[0] === "[" ? g.substr(1, g.length - 2) : g);
      const d = f.indexOf("*");
      if (d > -1) {
        const g = f.slice(0, d), p = g.join("."), u = f.slice(d + 1, f.length), h = u.length > 0;
        s++, n.push({
          before: g,
          beforeStr: p,
          after: u,
          nested: h
        });
      } else
        o[a] = {
          path: f,
          val: void 0,
          precensored: !1,
          circle: "",
          escPath: JSON.stringify(a),
          leadingBracket: l
        };
      return o;
    }, {});
    return { wildcards: n, wcLen: s, secret: i };
  }
  return yc;
}
var gc, Bp;
function Pw() {
  if (Bp) return gc;
  Bp = 1;
  const e = Xu();
  gc = t;
  function t({ secret: o, serialize: a, wcLen: c, strict: f, isCensorFct: l, censorFctTakesPath: d }, g) {
    const p = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${i(f, a)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${r(o, l, d)}
    this.compileRestore()
    ${n(c > 0, l, d)}
    this.secret = originalSecret
    ${s(a)}
  `).bind(g);
    return p.state = g, a === !1 && (p.restore = (u) => g.restore(u)), p;
  }
  function r(o, a, c) {
    return Object.keys(o).map((f) => {
      const { escPath: l, leadingBracket: d, path: g } = o[f], p = d ? 1 : 0, u = d ? "" : ".", h = [];
      for (var b; (b = e.exec(f)) !== null; ) {
        const [, _] = b, { index: R, input: E } = b;
        R > p && h.push(E.substring(0, R - (_ ? 0 : 1)));
      }
      var m = h.map((_) => `o${u}${_}`).join(" && ");
      m.length === 0 ? m += `o${u}${f} != null` : m += ` && o${u}${f} != null`;
      const v = `
      switch (true) {
        ${h.reverse().map((_) => `
          case o${u}${_} === censor:
            secret[${l}].circle = ${JSON.stringify(_)}
            break
        `).join(`
`)}
      }
    `, y = c ? `val, ${JSON.stringify(g)}` : "val";
      return `
      if (${m}) {
        const val = o${u}${f}
        if (val === censor) {
          secret[${l}].precensored = true
        } else {
          secret[${l}].val = val
          o${u}${f} = ${a ? `censor(${y})` : "censor"}
          ${v}
        }
      }
    `;
    }).join(`
`);
  }
  function n(o, a, c) {
    return o === !0 ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${a}, ${c})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${a}, ${c})
      }
    }
  ` : "";
  }
  function s(o) {
    return o === !1 ? "return o" : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
  function i(o, a) {
    return o === !0 ? "throw Error('fast-redact: primitives cannot be redacted')" : a === !1 ? "return o" : "return this.serialize(o)";
  }
  return gc;
}
var vc, Vp;
function Qv() {
  if (Vp) return vc;
  Vp = 1, vc = {
    groupRedact: t,
    groupRestore: e,
    nestedRedact: n,
    nestedRestore: r
  };
  function e({ keys: d, values: g, target: p }) {
    if (p == null || typeof p == "string") return;
    const u = d.length;
    for (var h = 0; h < u; h++) {
      const b = d[h];
      p[b] = g[h];
    }
  }
  function t(d, g, p, u, h) {
    const b = o(d, g);
    if (b == null || typeof b == "string") return { keys: null, values: null, target: b, flat: !0 };
    const m = Object.keys(b), v = m.length, y = g.length, _ = h ? [...g] : void 0, R = new Array(v);
    for (var E = 0; E < v; E++) {
      const O = m[E];
      R[E] = b[O], h ? (_[y] = O, b[O] = p(b[O], _)) : u ? b[O] = p(b[O]) : b[O] = p;
    }
    return { keys: m, values: R, target: b, flat: !0 };
  }
  function r(d) {
    for (let g = 0; g < d.length; g++) {
      const { target: p, path: u, value: h } = d[g];
      let b = p;
      for (let m = u.length - 1; m > 0; m--)
        b = b[u[m]];
      b[u[0]] = h;
    }
  }
  function n(d, g, p, u, h, b, m) {
    const v = o(g, p);
    if (v == null) return;
    const y = Object.keys(v), _ = y.length;
    for (var R = 0; R < _; R++) {
      const E = y[R];
      i(d, v, E, p, u, h, b, m);
    }
    return d;
  }
  function s(d, g) {
    return d != null ? "hasOwn" in Object ? Object.hasOwn(d, g) : Object.prototype.hasOwnProperty.call(d, g) : !1;
  }
  function i(d, g, p, u, h, b, m, v) {
    const y = h.length, _ = y - 1, R = p;
    var E = -1, O, z, x, L = null, M, U, $ = !1, S = 0, I = 0, T = c();
    if (x = O = g[p], typeof O == "object") {
      for (; O != null && ++E < y && (I += 1, p = h[E], !(p !== "*" && !L && !(typeof O == "object" && p in O))); )
        if (!(p === "*" && (L === "*" && ($ = !0), L = p, E !== _))) {
          if (L) {
            const P = Object.keys(O);
            for (var j = 0; j < P.length; j++) {
              const A = P[j];
              if (U = O[A], M = p === "*", $)
                T = f(T, A, I), S = E, x = a(U, S - 1, p, u, h, b, m, v, R, O, z, x, M, A, E, _, T, d, g[R], I + 1);
              else if (M || typeof U == "object" && U !== null && p in U) {
                if (M ? x = U : x = U[p], z = E !== _ ? x : m ? v ? b(x, [...u, R, ...h]) : b(x) : b, M) {
                  const k = l(f(T, A, I), x, g[R]);
                  d.push(k), O[A] = z;
                } else if (U[p] !== z) if (z === void 0 && b !== void 0 || s(U, p) && z === x)
                  T = f(T, A, I);
                else {
                  T = f(T, A, I);
                  const k = l(f(T, p, I + 1), x, g[R]);
                  d.push(k), U[p] = z;
                }
              }
            }
            L = null;
          } else {
            if (x = O[p], T = f(T, p, I), z = E !== _ ? x : m ? v ? b(x, [...u, R, ...h]) : b(x) : b, !(s(O, p) && z === x || z === void 0 && b !== void 0)) {
              const P = l(T, x, g[R]);
              d.push(P), O[p] = z;
            }
            O = O[p];
          }
          if (typeof O != "object") break;
        }
    }
  }
  function o(d, g) {
    for (var p = -1, u = g.length, h = d; h != null && ++p < u; )
      h = h[g[p]];
    return h;
  }
  function a(d, g, p, u, h, b, m, v, y, _, R, E, O, z, x, L, M, U, $, S) {
    if (g === 0 && (O || typeof d == "object" && d !== null && p in d)) {
      if (O ? E = d : E = d[p], R = x !== L ? E : m ? v ? b(E, [...u, y, ...h]) : b(E) : b, O) {
        const I = l(M, E, $);
        U.push(I), _[z] = R;
      } else if (d[p] !== R) {
        if (!(R === void 0 && b !== void 0 || s(d, p) && R === E)) {
          const I = l(f(M, p, S + 1), E, $);
          U.push(I), d[p] = R;
        }
      }
    }
    for (const I in d)
      typeof d[I] == "object" && (M = f(M, I, S), a(d[I], g - 1, p, u, h, b, m, v, y, _, R, E, O, z, x, L, M, U, $, S + 1));
  }
  function c() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
  function f(d, g, p) {
    if (d.depth === p)
      return f(d.parent, g, p);
    var u = {
      parent: d,
      key: g,
      depth: p,
      children: []
    };
    return d.children.push(u), u;
  }
  function l(d, g, p) {
    let u = d;
    const h = [];
    do
      h.push(u.key), u = u.parent;
    while (u.parent != null);
    return { path: h, value: g, target: p };
  }
  return vc;
}
var bc, Gp;
function Cw() {
  if (Gp) return bc;
  Gp = 1;
  const { groupRestore: e, nestedRestore: t } = Qv();
  bc = r;
  function r() {
    return function() {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
      const { secret: o, wcLen: a } = this, c = Object.keys(o), f = n(o, c), l = a > 0, d = l ? { secret: o, groupRestore: e, nestedRestore: t } : { secret: o };
      this.restore = Function(
        "o",
        s(f, c, l)
      ).bind(d), this.restore.state = d;
    };
  }
  function n(i, o) {
    return o.map((a) => {
      const { circle: c, escPath: f, leadingBracket: l } = i[a], g = c ? `o.${c} = secret[${f}].val` : `o${l ? "" : "."}${a} = secret[${f}].val`, p = `secret[${f}].val = undefined`;
      return `
      if (secret[${f}].val !== undefined) {
        try { ${g} } catch (e) {}
        ${p}
      }
    `;
    }).join("");
  }
  function s(i, o, a) {
    return `
    const secret = this.secret
    ${a === !0 ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${o.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : ""}
    ${i}
    return o
  `;
  }
  return bc;
}
var _c, Wp;
function Iw() {
  if (Wp) return _c;
  Wp = 1, _c = e;
  function e(t) {
    const {
      secret: r,
      censor: n,
      compileRestore: s,
      serialize: i,
      groupRedact: o,
      nestedRedact: a,
      wildcards: c,
      wcLen: f
    } = t, l = [{ secret: r, censor: n, compileRestore: s }];
    return i !== !1 && l.push({ serialize: i }), f > 0 && l.push({ groupRedact: o, nestedRedact: a, wildcards: c, wcLen: f }), Object.assign(...l);
  }
  return _c;
}
var Ec, Kp;
function Nw() {
  if (Kp) return Ec;
  Kp = 1;
  const e = Tw(), t = Ow(), r = Pw(), n = Cw(), { groupRedact: s, nestedRedact: i } = Qv(), o = Iw(), a = Xu(), c = e(), f = (g) => g;
  f.restore = f;
  const l = "[REDACTED]";
  d.rx = a, d.validator = e, Ec = d;
  function d(g = {}) {
    const p = Array.from(new Set(g.paths || [])), u = "serialize" in g && (g.serialize === !1 || typeof g.serialize == "function") ? g.serialize : JSON.stringify, h = g.remove;
    if (h === !0 && u !== JSON.stringify)
      throw Error("fast-redact – remove option may only be set when serializer is JSON.stringify");
    const b = h === !0 ? void 0 : "censor" in g ? g.censor : l, m = typeof b == "function", v = m && b.length > 1;
    if (p.length === 0) return u || f;
    c({ paths: p, serialize: u, censor: b });
    const { wildcards: y, wcLen: _, secret: R } = t({ paths: p, censor: b }), E = n(), O = "strict" in g ? g.strict : !0;
    return r({ secret: R, wcLen: _, serialize: u, strict: O, isCensorFct: m, censorFctTakesPath: v }, o({
      secret: R,
      censor: b,
      compileRestore: E,
      serialize: u,
      groupRedact: s,
      nestedRedact: i,
      wildcards: y,
      wcLen: _
    }));
  }
  return Ec;
}
var xc, Jp;
function ui() {
  if (Jp) return xc;
  Jp = 1;
  const e = Symbol("pino.setLevel"), t = Symbol("pino.getLevel"), r = Symbol("pino.levelVal"), n = Symbol("pino.levelComp"), s = Symbol("pino.useLevelLabels"), i = Symbol("pino.useOnlyCustomLevels"), o = Symbol("pino.mixin"), a = Symbol("pino.lsCache"), c = Symbol("pino.chindings"), f = Symbol("pino.asJson"), l = Symbol("pino.write"), d = Symbol("pino.redactFmt"), g = Symbol("pino.time"), p = Symbol("pino.timeSliceIndex"), u = Symbol("pino.stream"), h = Symbol("pino.stringify"), b = Symbol("pino.stringifySafe"), m = Symbol("pino.stringifiers"), v = Symbol("pino.end"), y = Symbol("pino.formatOpts"), _ = Symbol("pino.messageKey"), R = Symbol("pino.errorKey"), E = Symbol("pino.nestedKey"), O = Symbol("pino.nestedKeyStr"), z = Symbol("pino.mixinMergeStrategy"), x = Symbol("pino.msgPrefix"), L = Symbol("pino.wildcardFirst"), M = Symbol.for("pino.serializers"), U = Symbol.for("pino.formatters"), $ = Symbol.for("pino.hooks"), S = Symbol.for("pino.metadata");
  return xc = {
    setLevelSym: e,
    getLevelSym: t,
    levelValSym: r,
    levelCompSym: n,
    useLevelLabelsSym: s,
    mixinSym: o,
    lsCacheSym: a,
    chindingsSym: c,
    asJsonSym: f,
    writeSym: l,
    serializersSym: M,
    redactFmtSym: d,
    timeSym: g,
    timeSliceIndexSym: p,
    streamSym: u,
    stringifySym: h,
    stringifySafeSym: b,
    stringifiersSym: m,
    endSym: v,
    formatOptsSym: y,
    messageKeySym: _,
    errorKeySym: R,
    nestedKeySym: E,
    wildcardFirstSym: L,
    needsMetadataGsym: S,
    useOnlyCustomLevelsSym: i,
    formattersSym: U,
    hooksSym: $,
    nestedKeyStrSym: O,
    mixinMergeStrategySym: z,
    msgPrefixSym: x
  }, xc;
}
var Sc, Yp;
function eb() {
  if (Yp) return Sc;
  Yp = 1;
  const e = Nw(), { redactFmtSym: t, wildcardFirstSym: r } = ui(), { rx: n, validator: s } = e, i = s({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino – redacted paths must be strings",
    ERR_INVALID_PATH: (l) => `pino – redact paths array contains an invalid path (${l})`
  }), o = "[Redacted]", a = !1;
  function c(l, d) {
    const { paths: g, censor: p } = f(l), u = g.reduce((m, v) => {
      n.lastIndex = 0;
      const y = n.exec(v), _ = n.exec(v);
      let R = y[1] !== void 0 ? y[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : y[0];
      if (R === "*" && (R = r), _ === null)
        return m[R] = null, m;
      if (m[R] === null)
        return m;
      const { index: E } = _, O = `${v.substr(E, v.length - 1)}`;
      return m[R] = m[R] || [], R !== r && m[R].length === 0 && m[R].push(...m[r] || []), R === r && Object.keys(m).forEach(function(z) {
        m[z] && m[z].push(O);
      }), m[R].push(O), m;
    }, {}), h = {
      [t]: e({ paths: g, censor: p, serialize: d, strict: a })
    }, b = (...m) => d(typeof p == "function" ? p(...m) : p);
    return [...Object.keys(u), ...Object.getOwnPropertySymbols(u)].reduce((m, v) => {
      if (u[v] === null)
        m[v] = (y) => b(y, [v]);
      else {
        const y = typeof p == "function" ? (_, R) => p(_, [v, ...R]) : p;
        m[v] = e({
          paths: u[v],
          censor: y,
          serialize: d,
          strict: a
        });
      }
      return m;
    }, h);
  }
  function f(l) {
    if (Array.isArray(l))
      return l = { paths: l, censor: o }, i(l), l;
    let { paths: d, censor: g = o, remove: p } = l;
    if (Array.isArray(d) === !1)
      throw Error("pino – redact must contain an array of strings");
    return p === !0 && (g = void 0), i({ paths: d, censor: g }), { paths: d, censor: g };
  }
  return Sc = c, Sc;
}
var wc, Xp;
function Aw() {
  return Xp || (Xp = 1, wc = { nullTime: () => "", epochTime: () => `,"time":${Date.now()}`, unixTime: () => `,"time":${Math.round(Date.now() / 1e3)}`, isoTime: () => `,"time":"${new Date(Date.now()).toISOString()}"` }), wc;
}
var Rc, Zp;
function kw() {
  if (Zp) return Rc;
  Zp = 1;
  function e(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  Rc = t;
  function t(r, n, s) {
    var i = s && s.stringify || e, o = 1;
    if (typeof r == "object" && r !== null) {
      var a = n.length + o;
      if (a === 1) return r;
      var c = new Array(a);
      c[0] = i(r);
      for (var f = 1; f < a; f++)
        c[f] = i(n[f]);
      return c.join(" ");
    }
    if (typeof r != "string")
      return r;
    var l = n.length;
    if (l === 0) return r;
    for (var d = "", g = 1 - o, p = -1, u = r && r.length || 0, h = 0; h < u; ) {
      if (r.charCodeAt(h) === 37 && h + 1 < u) {
        switch (p = p > -1 ? p : 0, r.charCodeAt(h + 1)) {
          case 100:
          case 102:
            if (g >= l || n[g] == null) break;
            p < h && (d += r.slice(p, h)), d += Number(n[g]), p = h + 2, h++;
            break;
          case 105:
            if (g >= l || n[g] == null) break;
            p < h && (d += r.slice(p, h)), d += Math.floor(Number(n[g])), p = h + 2, h++;
            break;
          case 79:
          case 111:
          case 106:
            if (g >= l || n[g] === void 0) break;
            p < h && (d += r.slice(p, h));
            var b = typeof n[g];
            if (b === "string") {
              d += "'" + n[g] + "'", p = h + 2, h++;
              break;
            }
            if (b === "function") {
              d += n[g].name || "<anonymous>", p = h + 2, h++;
              break;
            }
            d += i(n[g]), p = h + 2, h++;
            break;
          case 115:
            if (g >= l)
              break;
            p < h && (d += r.slice(p, h)), d += String(n[g]), p = h + 2, h++;
            break;
          case 37:
            p < h && (d += r.slice(p, h)), d += "%", p = h + 2, h++, g--;
            break;
        }
        ++g;
      }
      ++h;
    }
    return p === -1 ? r : (p < u && (d += r.slice(p)), d);
  }
  return Rc;
}
var Ii = { exports: {} }, Qp;
function tb() {
  if (Qp) return Ii.exports;
  if (Qp = 1, typeof SharedArrayBuffer < "u" && typeof Atomics < "u") {
    let t = function(r) {
      if ((r > 0 && r < 1 / 0) === !1)
        throw typeof r != "number" && typeof r != "bigint" ? TypeError("sleep: ms must be a number") : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      Atomics.wait(e, 0, 0, Number(r));
    };
    const e = new Int32Array(new SharedArrayBuffer(4));
    Ii.exports = t;
  } else {
    let e = function(t) {
      if ((t > 0 && t < 1 / 0) === !1)
        throw typeof t != "number" && typeof t != "bigint" ? TypeError("sleep: ms must be a number") : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
    };
    Ii.exports = e;
  }
  return Ii.exports;
}
var $c, eh;
function Lw() {
  if (eh) return $c;
  eh = 1;
  const e = gt, t = gv, r = gn.inherits, n = $t, s = tb(), i = Uu, o = 100, a = Buffer.allocUnsafe(0), c = 16 * 1024, f = "buffer", l = "utf8", [d, g] = (process.versions.node || "0.0").split(".").map(Number), p = d >= 22 && g >= 7;
  function u($, S) {
    S._opening = !0, S._writing = !0, S._asyncDrainScheduled = !1;
    function I(P, A) {
      if (P) {
        S._reopening = !1, S._writing = !1, S._opening = !1, S.sync ? process.nextTick(() => {
          S.listenerCount("error") > 0 && S.emit("error", P);
        }) : S.emit("error", P);
        return;
      }
      const k = S._reopening;
      S.fd = A, S.file = $, S._reopening = !1, S._opening = !1, S._writing = !1, S.sync ? process.nextTick(() => S.emit("ready")) : S.emit("ready"), !S.destroyed && (!S._writing && S._len > S.minLength || S._flushPending ? S._actualWrite() : k && process.nextTick(() => S.emit("drain")));
    }
    const T = S.append ? "a" : "w", j = S.mode;
    if (S.sync)
      try {
        S.mkdir && e.mkdirSync(n.dirname($), { recursive: !0 });
        const P = e.openSync($, T, j);
        I(null, P);
      } catch (P) {
        throw I(P), P;
      }
    else S.mkdir ? e.mkdir(n.dirname($), { recursive: !0 }, (P) => {
      if (P) return I(P);
      e.open($, T, j, I);
    }) : e.open($, T, j, I);
  }
  function h($) {
    if (!(this instanceof h))
      return new h($);
    let { fd: S, dest: I, minLength: T, maxLength: j, maxWrite: P, periodicFlush: A, sync: k, append: C = !0, mkdir: D, retryEAGAIN: F, fsync: w, contentMode: N, mode: q } = $ || {};
    S = S || I, this._len = 0, this.fd = -1, this._bufs = [], this._lens = [], this._writing = !1, this._ending = !1, this._reopening = !1, this._asyncDrainScheduled = !1, this._flushPending = !1, this._hwm = Math.max(T || 0, 16387), this.file = null, this.destroyed = !1, this.minLength = T || 0, this.maxLength = j || 0, this.maxWrite = P || c, this._periodicFlush = A || 0, this._periodicFlushTimer = void 0, this.sync = k || !1, this.writable = !0, this._fsync = w || !1, this.append = C || !1, this.mode = q, this.retryEAGAIN = F || (() => !0), this.mkdir = D || !1;
    let K, V;
    if (N === f)
      this._writingBuf = a, this.write = _, this.flush = O, this.flushSync = x, this._actualWrite = M, K = () => e.writeSync(this.fd, this._writingBuf), V = () => e.write(this.fd, this._writingBuf, this.release);
    else if (N === void 0 || N === l)
      this._writingBuf = "", this.write = y, this.flush = E, this.flushSync = z, this._actualWrite = L, K = () => e.writeSync(this.fd, this._writingBuf, "utf8"), V = () => e.write(this.fd, this._writingBuf, "utf8", this.release);
    else
      throw new Error(`SonicBoom supports "${l}" and "${f}", but passed ${N}`);
    if (typeof S == "number")
      this.fd = S, process.nextTick(() => this.emit("ready"));
    else if (typeof S == "string")
      u(S, this);
    else
      throw new Error("SonicBoom supports only file descriptors and files");
    if (this.minLength >= this.maxWrite)
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    this.release = (Z, Y) => {
      if (Z) {
        if ((Z.code === "EAGAIN" || Z.code === "EBUSY") && this.retryEAGAIN(Z, this._writingBuf.length, this._len - this._writingBuf.length))
          if (this.sync)
            try {
              s(o), this.release(void 0, 0);
            } catch (W) {
              this.release(W);
            }
          else
            setTimeout(V, o);
        else
          this._writing = !1, this.emit("error", Z);
        return;
      }
      this.emit("write", Y);
      const J = b(this._writingBuf, this._len, Y);
      if (this._len = J.len, this._writingBuf = J.writingBuf, this._writingBuf.length) {
        if (!this.sync) {
          V();
          return;
        }
        try {
          do {
            const W = K(), G = b(this._writingBuf, this._len, W);
            this._len = G.len, this._writingBuf = G.writingBuf;
          } while (this._writingBuf.length);
        } catch (W) {
          this.release(W);
          return;
        }
      }
      this._fsync && e.fsyncSync(this.fd);
      const H = this._len;
      this._reopening ? (this._writing = !1, this._reopening = !1, this.reopen()) : H > this.minLength ? this._actualWrite() : this._ending ? H > 0 ? this._actualWrite() : (this._writing = !1, U(this)) : (this._writing = !1, this.sync ? this._asyncDrainScheduled || (this._asyncDrainScheduled = !0, process.nextTick(m, this)) : this.emit("drain"));
    }, this.on("newListener", function(Z) {
      Z === "drain" && (this._asyncDrainScheduled = !1);
    }), this._periodicFlush !== 0 && (this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush), this._periodicFlushTimer.unref());
  }
  function b($, S, I) {
    return typeof $ == "string" && Buffer.byteLength($) !== I && (I = Buffer.from($).subarray(0, I).toString().length), S = Math.max(S - I, 0), $ = $.slice(I), { writingBuf: $, len: S };
  }
  function m($) {
    $.listenerCount("drain") > 0 && ($._asyncDrainScheduled = !1, $.emit("drain"));
  }
  r(h, t);
  function v($, S) {
    return $.length === 0 ? a : $.length === 1 ? $[0] : Buffer.concat($, S);
  }
  function y($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    const S = this._len + $.length, I = this._bufs;
    return this.maxLength && S > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (I.length === 0 || I[I.length - 1].length + $.length > this.maxWrite ? I.push("" + $) : I[I.length - 1] += $, this._len = S, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
  }
  function _($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    const S = this._len + $.length, I = this._bufs, T = this._lens;
    return this.maxLength && S > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (I.length === 0 || T[T.length - 1] + $.length > this.maxWrite ? (I.push([$]), T.push($.length)) : (I[I.length - 1].push($), T[T.length - 1] += $.length), this._len = S, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
  }
  function R($) {
    this._flushPending = !0;
    const S = () => {
      if (this._fsync)
        this._flushPending = !1, $();
      else
        try {
          e.fsync(this.fd, (T) => {
            this._flushPending = !1, $(T);
          });
        } catch (T) {
          $(T);
        }
      this.off("error", I);
    }, I = (T) => {
      this._flushPending = !1, $(T), this.off("drain", S);
    };
    this.once("drain", S), this.once("error", I);
  }
  function E($) {
    if ($ != null && typeof $ != "function")
      throw new Error("flush cb must be a function");
    if (this.destroyed) {
      const S = new Error("SonicBoom destroyed");
      if ($) {
        $(S);
        return;
      }
      throw S;
    }
    if (this.minLength <= 0) {
      $ == null || $();
      return;
    }
    $ && R.call(this, $), !this._writing && (this._bufs.length === 0 && this._bufs.push(""), this._actualWrite());
  }
  function O($) {
    if ($ != null && typeof $ != "function")
      throw new Error("flush cb must be a function");
    if (this.destroyed) {
      const S = new Error("SonicBoom destroyed");
      if ($) {
        $(S);
        return;
      }
      throw S;
    }
    if (this.minLength <= 0) {
      $ == null || $();
      return;
    }
    $ && R.call(this, $), !this._writing && (this._bufs.length === 0 && (this._bufs.push([]), this._lens.push(0)), this._actualWrite());
  }
  h.prototype.reopen = function($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.reopen($);
      });
      return;
    }
    if (this._ending)
      return;
    if (!this.file)
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    if ($ && (this.file = $), this._reopening = !0, this._writing)
      return;
    const S = this.fd;
    this.once("ready", () => {
      S !== this.fd && e.close(S, (I) => {
        if (I)
          return this.emit("error", I);
      });
    }), u(this.file, this);
  }, h.prototype.end = function() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    this._ending || (this._ending = !0, !this._writing && (this._len > 0 && this.fd >= 0 ? this._actualWrite() : U(this)));
  };
  function z() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this.fd < 0)
      throw new Error("sonic boom is not ready yet");
    !this._writing && this._writingBuf.length > 0 && (this._bufs.unshift(this._writingBuf), this._writingBuf = "");
    let $ = "";
    for (; this._bufs.length || $; ) {
      $.length <= 0 && ($ = this._bufs[0]);
      try {
        const S = e.writeSync(this.fd, $, "utf8"), I = b($, this._len, S);
        $ = I.writingBuf, this._len = I.len, $.length <= 0 && this._bufs.shift();
      } catch (S) {
        if ((S.code === "EAGAIN" || S.code === "EBUSY") && !this.retryEAGAIN(S, $.length, this._len - $.length))
          throw S;
        s(o);
      }
    }
    try {
      e.fsyncSync(this.fd);
    } catch {
    }
  }
  function x() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this.fd < 0)
      throw new Error("sonic boom is not ready yet");
    !this._writing && this._writingBuf.length > 0 && (this._bufs.unshift([this._writingBuf]), this._writingBuf = a);
    let $ = a;
    for (; this._bufs.length || $.length; ) {
      $.length <= 0 && ($ = v(this._bufs[0], this._lens[0]));
      try {
        const S = e.writeSync(this.fd, $);
        $ = $.subarray(S), this._len = Math.max(this._len - S, 0), $.length <= 0 && (this._bufs.shift(), this._lens.shift());
      } catch (S) {
        if ((S.code === "EAGAIN" || S.code === "EBUSY") && !this.retryEAGAIN(S, $.length, this._len - $.length))
          throw S;
        s(o);
      }
    }
  }
  h.prototype.destroy = function() {
    this.destroyed || U(this);
  };
  function L() {
    const $ = this.release;
    if (this._writing = !0, this._writingBuf = this._writingBuf || this._bufs.shift() || "", this.sync)
      try {
        const S = e.writeSync(this.fd, this._writingBuf, "utf8");
        $(null, S);
      } catch (S) {
        $(S);
      }
    else
      e.write(this.fd, this._writingBuf, "utf8", $);
  }
  function M() {
    const $ = this.release;
    if (this._writing = !0, this._writingBuf = this._writingBuf.length ? this._writingBuf : v(this._bufs.shift(), this._lens.shift()), this.sync)
      try {
        const S = e.writeSync(this.fd, this._writingBuf);
        $(null, S);
      } catch (S) {
        $(S);
      }
    else
      p && (this._writingBuf = Buffer.from(this._writingBuf)), e.write(this.fd, this._writingBuf, $);
  }
  function U($) {
    if ($.fd === -1) {
      $.once("ready", U.bind(null, $));
      return;
    }
    $._periodicFlushTimer !== void 0 && clearInterval($._periodicFlushTimer), $.destroyed = !0, $._bufs = [], $._lens = [], i(typeof $.fd == "number", `sonic.fd must be a number, got ${typeof $.fd}`);
    try {
      e.fsync($.fd, S);
    } catch {
    }
    function S() {
      $.fd !== 1 && $.fd !== 2 ? e.close($.fd, I) : I();
    }
    function I(T) {
      if (T) {
        $.emit("error", T);
        return;
      }
      $._ending && !$._writing && $.emit("finish"), $.emit("close");
    }
  }
  return h.SonicBoom = h, h.default = h, $c = h, $c;
}
var Tc, th;
function rb() {
  if (th) return Tc;
  th = 1;
  const e = {
    exit: [],
    beforeExit: []
  }, t = {
    exit: o,
    beforeExit: a
  };
  let r;
  function n() {
    r === void 0 && (r = new FinalizationRegistry(f));
  }
  function s(u) {
    e[u].length > 0 || process.on(u, t[u]);
  }
  function i(u) {
    e[u].length > 0 || (process.removeListener(u, t[u]), e.exit.length === 0 && e.beforeExit.length === 0 && (r = void 0));
  }
  function o() {
    c("exit");
  }
  function a() {
    c("beforeExit");
  }
  function c(u) {
    for (const h of e[u]) {
      const b = h.deref(), m = h.fn;
      b !== void 0 && m(b, u);
    }
    e[u] = [];
  }
  function f(u) {
    for (const h of ["exit", "beforeExit"]) {
      const b = e[h].indexOf(u);
      e[h].splice(b, b + 1), i(h);
    }
  }
  function l(u, h, b) {
    if (h === void 0)
      throw new Error("the object can't be undefined");
    s(u);
    const m = new WeakRef(h);
    m.fn = b, n(), r.register(h, m), e[u].push(m);
  }
  function d(u, h) {
    l("exit", u, h);
  }
  function g(u, h) {
    l("beforeExit", u, h);
  }
  function p(u) {
    if (r !== void 0) {
      r.unregister(u);
      for (const h of ["exit", "beforeExit"])
        e[h] = e[h].filter((b) => {
          const m = b.deref();
          return m && m !== u;
        }), i(h);
    }
  }
  return Tc = {
    register: d,
    registerBeforeExit: g,
    unregister: p
  }, Tc;
}
const jw = "3.1.0", Dw = {
  version: jw
};
var Oc, rh;
function Fw() {
  if (rh) return Oc;
  rh = 1;
  const e = 1e3;
  function t(n, s, i, o, a) {
    const c = Date.now() + o;
    let f = Atomics.load(n, s);
    if (f === i) {
      a(null, "ok");
      return;
    }
    let l = f;
    const d = (g) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        l = f, f = Atomics.load(n, s), f === l ? d(g >= e ? e : g * 2) : f === i ? a(null, "ok") : a(null, "not-equal");
      }, g);
    };
    d(1);
  }
  function r(n, s, i, o, a) {
    const c = Date.now() + o;
    let f = Atomics.load(n, s);
    if (f !== i) {
      a(null, "ok");
      return;
    }
    const l = (d) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        f = Atomics.load(n, s), f !== i ? a(null, "ok") : l(d >= e ? e : d * 2);
      }, d);
    };
    l(1);
  }
  return Oc = { wait: t, waitDiff: r }, Oc;
}
var Pc, nh;
function Mw() {
  return nh || (nh = 1, Pc = {
    WRITE_INDEX: 4,
    READ_INDEX: 8
  }), Pc;
}
var Cc, sh;
function zw() {
  if (sh) return Cc;
  sh = 1;
  const { version: e } = Dw, { EventEmitter: t } = gv, { Worker: r } = vv, { join: n } = $t, { pathToFileURL: s } = ni, { wait: i } = Fw(), {
    WRITE_INDEX: o,
    READ_INDEX: a
  } = Mw(), c = _x, f = Uu, l = Symbol("kImpl"), d = c.constants.MAX_STRING_LENGTH;
  class g {
    constructor(S) {
      this._value = S;
    }
    deref() {
      return this._value;
    }
  }
  class p {
    register() {
    }
    unregister() {
    }
  }
  const u = process.env.NODE_V8_COVERAGE ? p : be.FinalizationRegistry || p, h = process.env.NODE_V8_COVERAGE ? g : be.WeakRef || g, b = new u(($) => {
    $.exited || $.terminate();
  });
  function m($, S) {
    const { filename: I, workerData: T } = S, P = ("__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {})["thread-stream-worker"] || n(__dirname, "lib", "worker.js"), A = new r(P, {
      ...S.workerOpts,
      trackUnmanagedFds: !1,
      workerData: {
        filename: I.indexOf("file://") === 0 ? I : s(I).href,
        dataBuf: $[l].dataBuf,
        stateBuf: $[l].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: e
          },
          ...T
        }
      }
    });
    return A.stream = new g($), A.on("message", _), A.on("exit", R), b.register($, A), A;
  }
  function v($) {
    f(!$[l].sync), $[l].needDrain && ($[l].needDrain = !1, $.emit("drain"));
  }
  function y($) {
    const S = Atomics.load($[l].state, o);
    let I = $[l].data.length - S;
    if (I > 0) {
      if ($[l].buf.length === 0) {
        $[l].flushing = !1, $[l].ending ? L($) : $[l].needDrain && process.nextTick(v, $);
        return;
      }
      let T = $[l].buf.slice(0, I), j = Buffer.byteLength(T);
      j <= I ? ($[l].buf = $[l].buf.slice(I), x($, T, y.bind(null, $))) : $.flush(() => {
        if (!$.destroyed) {
          for (Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); j > $[l].data.length; )
            I = I / 2, T = $[l].buf.slice(0, I), j = Buffer.byteLength(T);
          $[l].buf = $[l].buf.slice(I), x($, T, y.bind(null, $));
        }
      });
    } else if (I === 0) {
      if (S === 0 && $[l].buf.length === 0)
        return;
      $.flush(() => {
        Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0), y($);
      });
    } else
      z($, new Error("overwritten"));
  }
  function _($) {
    const S = this.stream.deref();
    if (S === void 0) {
      this.exited = !0, this.terminate();
      return;
    }
    switch ($.code) {
      case "READY":
        this.stream = new h(S), S.flush(() => {
          S[l].ready = !0, S.emit("ready");
        });
        break;
      case "ERROR":
        z(S, $.err);
        break;
      case "EVENT":
        Array.isArray($.args) ? S.emit($.name, ...$.args) : S.emit($.name, $.args);
        break;
      case "WARNING":
        process.emitWarning($.err);
        break;
      default:
        z(S, new Error("this should not happen: " + $.code));
    }
  }
  function R($) {
    const S = this.stream.deref();
    S !== void 0 && (b.unregister(S), S.worker.exited = !0, S.worker.off("exit", R), z(S, $ !== 0 ? new Error("the worker thread exited") : null));
  }
  class E extends t {
    constructor(S = {}) {
      if (super(), S.bufferSize < 4)
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      this[l] = {}, this[l].stateBuf = new SharedArrayBuffer(128), this[l].state = new Int32Array(this[l].stateBuf), this[l].dataBuf = new SharedArrayBuffer(S.bufferSize || 4 * 1024 * 1024), this[l].data = Buffer.from(this[l].dataBuf), this[l].sync = S.sync || !1, this[l].ending = !1, this[l].ended = !1, this[l].needDrain = !1, this[l].destroyed = !1, this[l].flushing = !1, this[l].ready = !1, this[l].finished = !1, this[l].errored = null, this[l].closed = !1, this[l].buf = "", this.worker = m(this, S), this.on("message", (I, T) => {
        this.worker.postMessage(I, T);
      });
    }
    write(S) {
      if (this[l].destroyed)
        return O(this, new Error("the worker has exited")), !1;
      if (this[l].ending)
        return O(this, new Error("the worker is ending")), !1;
      if (this[l].flushing && this[l].buf.length + S.length >= d)
        try {
          M(this), this[l].flushing = !0;
        } catch (I) {
          return z(this, I), !1;
        }
      if (this[l].buf += S, this[l].sync)
        try {
          return M(this), !0;
        } catch (I) {
          return z(this, I), !1;
        }
      return this[l].flushing || (this[l].flushing = !0, setImmediate(y, this)), this[l].needDrain = this[l].data.length - this[l].buf.length - Atomics.load(this[l].state, o) <= 0, !this[l].needDrain;
    }
    end() {
      this[l].destroyed || (this[l].ending = !0, L(this));
    }
    flush(S) {
      if (this[l].destroyed) {
        typeof S == "function" && process.nextTick(S, new Error("the worker has exited"));
        return;
      }
      const I = Atomics.load(this[l].state, o);
      i(this[l].state, a, I, 1 / 0, (T, j) => {
        if (T) {
          z(this, T), process.nextTick(S, T);
          return;
        }
        if (j === "not-equal") {
          this.flush(S);
          return;
        }
        process.nextTick(S);
      });
    }
    flushSync() {
      this[l].destroyed || (M(this), U(this));
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[l].ready;
    }
    get destroyed() {
      return this[l].destroyed;
    }
    get closed() {
      return this[l].closed;
    }
    get writable() {
      return !this[l].destroyed && !this[l].ending;
    }
    get writableEnded() {
      return this[l].ending;
    }
    get writableFinished() {
      return this[l].finished;
    }
    get writableNeedDrain() {
      return this[l].needDrain;
    }
    get writableObjectMode() {
      return !1;
    }
    get writableErrored() {
      return this[l].errored;
    }
  }
  function O($, S) {
    setImmediate(() => {
      $.emit("error", S);
    });
  }
  function z($, S) {
    $[l].destroyed || ($[l].destroyed = !0, S && ($[l].errored = S, O($, S)), $.worker.exited ? setImmediate(() => {
      $[l].closed = !0, $.emit("close");
    }) : $.worker.terminate().catch(() => {
    }).then(() => {
      $[l].closed = !0, $.emit("close");
    }));
  }
  function x($, S, I) {
    const T = Atomics.load($[l].state, o), j = Buffer.byteLength(S);
    return $[l].data.write(S, T), Atomics.store($[l].state, o, T + j), Atomics.notify($[l].state, o), I(), !0;
  }
  function L($) {
    if (!($[l].ended || !$[l].ending || $[l].flushing)) {
      $[l].ended = !0;
      try {
        $.flushSync();
        let S = Atomics.load($[l].state, a);
        Atomics.store($[l].state, o, -1), Atomics.notify($[l].state, o);
        let I = 0;
        for (; S !== -1; ) {
          if (Atomics.wait($[l].state, a, S, 1e3), S = Atomics.load($[l].state, a), S === -2) {
            z($, new Error("end() failed"));
            return;
          }
          if (++I === 10) {
            z($, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          $[l].finished = !0, $.emit("finish");
        });
      } catch (S) {
        z($, S);
      }
    }
  }
  function M($) {
    const S = () => {
      $[l].ending ? L($) : $[l].needDrain && process.nextTick(v, $);
    };
    for ($[l].flushing = !1; $[l].buf.length !== 0; ) {
      const I = Atomics.load($[l].state, o);
      let T = $[l].data.length - I;
      if (T === 0) {
        U($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0);
        continue;
      } else if (T < 0)
        throw new Error("overwritten");
      let j = $[l].buf.slice(0, T), P = Buffer.byteLength(j);
      if (P <= T)
        $[l].buf = $[l].buf.slice(T), x($, j, S);
      else {
        for (U($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); P > $[l].buf.length; )
          T = T / 2, j = $[l].buf.slice(0, T), P = Buffer.byteLength(j);
        $[l].buf = $[l].buf.slice(T), x($, j, S);
      }
    }
  }
  function U($) {
    if ($[l].flushing)
      throw new Error("unable to flush while flushing");
    const S = Atomics.load($[l].state, o);
    let I = 0;
    for (; ; ) {
      const T = Atomics.load($[l].state, a);
      if (T === -2)
        throw Error("_flushSync failed");
      if (T !== S)
        Atomics.wait($[l].state, a, T, 1e3);
      else
        break;
      if (++I === 10)
        throw new Error("_flushSync took too long (10s)");
    }
  }
  return Cc = E, Cc;
}
var Ic, ih;
function nb() {
  if (ih) return Ic;
  ih = 1;
  const { createRequire: e } = bx, t = Zv(), { join: r, isAbsolute: n, sep: s } = vr, i = tb(), o = rb(), a = zw();
  function c(p) {
    o.register(p, l), o.registerBeforeExit(p, d), p.on("close", function() {
      o.unregister(p);
    });
  }
  function f(p, u, h, b) {
    const m = new a({
      filename: p,
      workerData: u,
      workerOpts: h,
      sync: b
    });
    m.on("ready", v), m.on("close", function() {
      process.removeListener("exit", y);
    }), process.on("exit", y);
    function v() {
      process.removeListener("exit", y), m.unref(), h.autoEnd !== !1 && c(m);
    }
    function y() {
      m.closed || (m.flushSync(), i(100), m.end());
    }
    return m;
  }
  function l(p) {
    p.ref(), p.flushSync(), p.end(), p.once("close", function() {
      p.unref();
    });
  }
  function d(p) {
    p.flushSync();
  }
  function g(p) {
    const { pipeline: u, targets: h, levels: b, dedupe: m, worker: v = {}, caller: y = t(), sync: _ = !1 } = p, R = {
      ...p.options
    }, E = typeof y == "string" ? [y] : y, O = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let z = p.target;
    if (z && h)
      throw new Error("only one of target or targets can be specified");
    return h ? (z = O["pino-worker"] || r(__dirname, "worker.js"), R.targets = h.filter((L) => L.target).map((L) => ({
      ...L,
      target: x(L.target)
    })), R.pipelines = h.filter((L) => L.pipeline).map((L) => L.pipeline.map((M) => ({
      ...M,
      level: L.level,
      // duplicate the pipeline `level` property defined in the upper level
      target: x(M.target)
    })))) : u && (z = O["pino-worker"] || r(__dirname, "worker.js"), R.pipelines = [u.map((L) => ({
      ...L,
      target: x(L.target)
    }))]), b && (R.levels = b), m && (R.dedupe = m), R.pinoWillSendConfig = !0, f(x(z), R, v, _);
    function x(L) {
      if (L = O[L] || L, n(L) || L.indexOf("file://") === 0)
        return L;
      if (L === "pino/file")
        return r(__dirname, "..", "file.js");
      let M;
      for (const U of E)
        try {
          const $ = U === "node:repl" ? process.cwd() + s : U;
          M = e($).resolve(L);
          break;
        } catch {
          continue;
        }
      if (!M)
        throw new Error(`unable to determine transport target for "${L}"`);
      return M;
    }
  }
  return Ic = g, Ic;
}
var Nc, oh;
function Zu() {
  if (oh) return Nc;
  oh = 1;
  const e = kw(), { mapHttpRequest: t, mapHttpResponse: r } = Xv(), n = Lw(), s = rb(), {
    lsCacheSym: i,
    chindingsSym: o,
    writeSym: a,
    serializersSym: c,
    formatOptsSym: f,
    endSym: l,
    stringifiersSym: d,
    stringifySym: g,
    stringifySafeSym: p,
    wildcardFirstSym: u,
    nestedKeySym: h,
    formattersSym: b,
    messageKeySym: m,
    errorKeySym: v,
    nestedKeyStrSym: y,
    msgPrefixSym: _
  } = ui(), { isMainThread: R } = vv, E = nb();
  function O() {
  }
  function z(k, C) {
    if (!C) return D;
    return function(...w) {
      C.call(this, w, D, k);
    };
    function D(F, ...w) {
      if (typeof F == "object") {
        let N = F;
        F !== null && (F.method && F.headers && F.socket ? F = t(F) : typeof F.setHeader == "function" && (F = r(F)));
        let q;
        N === null && w.length === 0 ? q = [null] : (N = w.shift(), q = w), typeof this[_] == "string" && N !== void 0 && N !== null && (N = this[_] + N), this[a](F, e(N, q, this[f]), k);
      } else {
        let N = F === void 0 ? w.shift() : F;
        typeof this[_] == "string" && N !== void 0 && N !== null && (N = this[_] + N), this[a](null, e(N, w, this[f]), k);
      }
    }
  }
  function x(k) {
    let C = "", D = 0, F = !1, w = 255;
    const N = k.length;
    if (N > 100)
      return JSON.stringify(k);
    for (var q = 0; q < N && w >= 32; q++)
      w = k.charCodeAt(q), (w === 34 || w === 92) && (C += k.slice(D, q) + "\\", D = q, F = !0);
    return F ? C += k.slice(D) : C = k, w < 32 ? JSON.stringify(k) : '"' + C + '"';
  }
  function L(k, C, D, F) {
    const w = this[g], N = this[p], q = this[d], K = this[l], V = this[o], Z = this[c], Y = this[b], J = this[m], H = this[v];
    let W = this[i][D] + F;
    W = W + V;
    let G;
    Y.log && (k = Y.log(k));
    const ee = q[u];
    let le = "";
    for (const ce in k)
      if (G = k[ce], Object.prototype.hasOwnProperty.call(k, ce) && G !== void 0) {
        Z[ce] ? G = Z[ce](G) : ce === H && Z.err && (G = Z.err(G));
        const _e = q[ce] || ee;
        switch (typeof G) {
          case "undefined":
          case "function":
            continue;
          case "number":
            Number.isFinite(G) === !1 && (G = null);
          case "boolean":
            _e && (G = _e(G));
            break;
          case "string":
            G = (_e || x)(G);
            break;
          default:
            G = (_e || w)(G, N);
        }
        if (G === void 0) continue;
        const pe = x(ce);
        le += "," + pe + ":" + G;
      }
    let X = "";
    if (C !== void 0) {
      G = Z[J] ? Z[J](C) : C;
      const ce = q[J] || ee;
      switch (typeof G) {
        case "function":
          break;
        case "number":
          Number.isFinite(G) === !1 && (G = null);
        case "boolean":
          ce && (G = ce(G)), X = ',"' + J + '":' + G;
          break;
        case "string":
          G = (ce || x)(G), X = ',"' + J + '":' + G;
          break;
        default:
          G = (ce || w)(G, N), X = ',"' + J + '":' + G;
      }
    }
    return this[h] && le ? W + this[y] + le.slice(1) + "}" + X + K : W + le + X + K;
  }
  function M(k, C) {
    let D, F = k[o];
    const w = k[g], N = k[p], q = k[d], K = q[u], V = k[c], Z = k[b].bindings;
    C = Z(C);
    for (const Y in C)
      if (D = C[Y], (Y !== "level" && Y !== "serializers" && Y !== "formatters" && Y !== "customLevels" && C.hasOwnProperty(Y) && D !== void 0) === !0) {
        if (D = V[Y] ? V[Y](D) : D, D = (q[Y] || K || w)(D, N), D === void 0) continue;
        F += ',"' + Y + '":' + D;
      }
    return F;
  }
  function U(k) {
    return k.write !== k.constructor.prototype.write;
  }
  const $ = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function S(k) {
    const C = new n(k);
    return C.on("error", D), !$ && !k.sync && R && (s.register(C, I), C.on("close", function() {
      s.unregister(C);
    })), C;
    function D(F) {
      if (F.code === "EPIPE") {
        C.write = O, C.end = O, C.flushSync = O, C.destroy = O;
        return;
      }
      C.removeListener("error", D), C.emit("error", F);
    }
  }
  function I(k, C) {
    k.destroyed || (C === "beforeExit" ? (k.flush(), k.on("drain", function() {
      k.end();
    })) : k.flushSync());
  }
  function T(k) {
    return function(D, F, w = {}, N) {
      if (typeof w == "string")
        N = S({ dest: w }), w = {};
      else if (typeof N == "string") {
        if (w && w.transport)
          throw Error("only one of option.transport or stream can be specified");
        N = S({ dest: N });
      } else if (w instanceof n || w.writable || w._writableState)
        N = w, w = {};
      else if (w.transport) {
        if (w.transport instanceof n || w.transport.writable || w.transport._writableState)
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        if (w.transport.targets && w.transport.targets.length && w.formatters && typeof w.formatters.level == "function")
          throw Error("option.transport.targets do not allow custom level formatters");
        let V;
        w.customLevels && (V = w.useOnlyCustomLevels ? w.customLevels : Object.assign({}, w.levels, w.customLevels)), N = E({ caller: F, ...w.transport, levels: V });
      }
      if (w = Object.assign({}, k, w), w.serializers = Object.assign({}, k.serializers, w.serializers), w.formatters = Object.assign({}, k.formatters, w.formatters), w.prettyPrint)
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      const { enabled: q, onChild: K } = w;
      return q === !1 && (w.level = "silent"), K || (w.onChild = O), N || (U(process.stdout) ? N = process.stdout : N = S({ fd: process.stdout.fd || 1 })), { opts: w, stream: N };
    };
  }
  function j(k, C) {
    try {
      return JSON.stringify(k);
    } catch {
      try {
        return (C || this[p])(k);
      } catch {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function P(k, C, D) {
    return {
      level: k,
      bindings: C,
      log: D
    };
  }
  function A(k) {
    const C = Number(k);
    return typeof k == "string" && Number.isFinite(C) ? C : k === void 0 ? 1 : k;
  }
  return Nc = {
    noop: O,
    buildSafeSonicBoom: S,
    asChindings: M,
    asJson: L,
    genLog: z,
    createArgsNormalizer: T,
    stringify: j,
    buildFormatters: P,
    normalizeDestFileDescriptor: A
  }, Nc;
}
var Ac, ah;
function Qu() {
  return ah || (ah = 1, Ac = {
    DEFAULT_LEVELS: {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    },
    SORTING_ORDER: {
      ASC: "ASC",
      DESC: "DESC"
    }
  }), Ac;
}
var kc, ch;
function sb() {
  if (ch) return kc;
  ch = 1;
  const {
    lsCacheSym: e,
    levelValSym: t,
    useOnlyCustomLevelsSym: r,
    streamSym: n,
    formattersSym: s,
    hooksSym: i,
    levelCompSym: o
  } = ui(), { noop: a, genLog: c } = Zu(), { DEFAULT_LEVELS: f, SORTING_ORDER: l } = Qu(), d = {
    fatal: (x) => {
      const L = c(f.fatal, x);
      return function(...M) {
        const U = this[n];
        if (L.call(this, ...M), typeof U.flushSync == "function")
          try {
            U.flushSync();
          } catch {
          }
      };
    },
    error: (x) => c(f.error, x),
    warn: (x) => c(f.warn, x),
    info: (x) => c(f.info, x),
    debug: (x) => c(f.debug, x),
    trace: (x) => c(f.trace, x)
  }, g = Object.keys(f).reduce((x, L) => (x[f[L]] = L, x), {}), p = Object.keys(g).reduce((x, L) => (x[L] = '{"level":' + Number(L), x), {});
  function u(x) {
    const L = x[s].level, { labels: M } = x.levels, U = {};
    for (const $ in M) {
      const S = L(M[$], Number($));
      U[$] = JSON.stringify(S).slice(0, -1);
    }
    return x[e] = U, x;
  }
  function h(x, L) {
    if (L)
      return !1;
    switch (x) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return !0;
      default:
        return !1;
    }
  }
  function b(x) {
    const { labels: L, values: M } = this.levels;
    if (typeof x == "number") {
      if (L[x] === void 0) throw Error("unknown level value" + x);
      x = L[x];
    }
    if (M[x] === void 0) throw Error("unknown level " + x);
    const U = this[t], $ = this[t] = M[x], S = this[r], I = this[o], T = this[i].logMethod;
    for (const j in M) {
      if (I(M[j], $) === !1) {
        this[j] = a;
        continue;
      }
      this[j] = h(j, S) ? d[j](T) : c(M[j], T);
    }
    this.emit(
      "level-change",
      x,
      $,
      L[U],
      U,
      this
    );
  }
  function m(x) {
    const { levels: L, levelVal: M } = this;
    return L && L.labels ? L.labels[M] : "";
  }
  function v(x) {
    const { values: L } = this.levels, M = L[x];
    return M !== void 0 && this[o](M, this[t]);
  }
  function y(x, L, M) {
    return x === l.DESC ? L <= M : L >= M;
  }
  function _(x) {
    return typeof x == "string" ? y.bind(null, x) : x;
  }
  function R(x = null, L = !1) {
    const M = x ? Object.keys(x).reduce((S, I) => (S[x[I]] = I, S), {}) : null, U = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      L ? null : g,
      M
    ), $ = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      L ? null : f,
      x
    );
    return { labels: U, values: $ };
  }
  function E(x, L, M) {
    if (typeof x == "number") {
      if (![].concat(
        Object.keys(L || {}).map((S) => L[S]),
        M ? [] : Object.keys(g).map((S) => +S),
        1 / 0
      ).includes(x))
        throw Error(`default level:${x} must be included in custom levels`);
      return;
    }
    const U = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      M ? null : f,
      L
    );
    if (!(x in U))
      throw Error(`default level:${x} must be included in custom levels`);
  }
  function O(x, L) {
    const { labels: M, values: U } = x;
    for (const $ in L) {
      if ($ in U)
        throw Error("levels cannot be overridden");
      if (L[$] in M)
        throw Error("pre-existing level values cannot be used for new levels");
    }
  }
  function z(x) {
    if (typeof x != "function" && !(typeof x == "string" && Object.values(l).includes(x)))
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  return kc = {
    initialLsCache: p,
    genLsCache: u,
    levelMethods: d,
    getLevel: m,
    setLevel: b,
    isLevelEnabled: v,
    mappings: R,
    assertNoLevelCollisions: O,
    assertDefaultLevelFound: E,
    genLevelComparison: _,
    assertLevelComparison: z
  }, kc;
}
var Lc, lh;
function ib() {
  return lh || (lh = 1, Lc = { version: "9.6.0" }), Lc;
}
var jc, uh;
function Uw() {
  if (uh) return jc;
  uh = 1;
  const { EventEmitter: e } = Qo, {
    lsCacheSym: t,
    levelValSym: r,
    setLevelSym: n,
    getLevelSym: s,
    chindingsSym: i,
    parsedChindingsSym: o,
    mixinSym: a,
    asJsonSym: c,
    writeSym: f,
    mixinMergeStrategySym: l,
    timeSym: d,
    timeSliceIndexSym: g,
    streamSym: p,
    serializersSym: u,
    formattersSym: h,
    errorKeySym: b,
    messageKeySym: m,
    useOnlyCustomLevelsSym: v,
    needsMetadataGsym: y,
    redactFmtSym: _,
    stringifySym: R,
    formatOptsSym: E,
    stringifiersSym: O,
    msgPrefixSym: z,
    hooksSym: x
  } = ui(), {
    getLevel: L,
    setLevel: M,
    isLevelEnabled: U,
    mappings: $,
    initialLsCache: S,
    genLsCache: I,
    assertNoLevelCollisions: T
  } = sb(), {
    asChindings: j,
    asJson: P,
    buildFormatters: A,
    stringify: k
  } = Zu(), {
    version: C
  } = ib(), D = eb(), w = {
    constructor: class {
    },
    child: q,
    bindings: K,
    setBindings: V,
    flush: H,
    isLevelEnabled: U,
    version: C,
    get level() {
      return this[s]();
    },
    set level(W) {
      this[n](W);
    },
    get levelVal() {
      return this[r];
    },
    set levelVal(W) {
      throw Error("levelVal is read-only");
    },
    [t]: S,
    [f]: Y,
    [c]: P,
    [s]: L,
    [n]: M
  };
  Object.setPrototypeOf(w, e.prototype), jc = function() {
    return Object.create(w);
  };
  const N = (W) => W;
  function q(W, G) {
    if (!W)
      throw Error("missing bindings for child Pino");
    G = G || {};
    const ee = this[u], le = this[h], X = Object.create(this);
    if (G.hasOwnProperty("serializers") === !0) {
      X[u] = /* @__PURE__ */ Object.create(null);
      for (const we in ee)
        X[u][we] = ee[we];
      const he = Object.getOwnPropertySymbols(ee);
      for (var ce = 0; ce < he.length; ce++) {
        const we = he[ce];
        X[u][we] = ee[we];
      }
      for (const we in G.serializers)
        X[u][we] = G.serializers[we];
      const Ge = Object.getOwnPropertySymbols(G.serializers);
      for (var _e = 0; _e < Ge.length; _e++) {
        const we = Ge[_e];
        X[u][we] = G.serializers[we];
      }
    } else X[u] = ee;
    if (G.hasOwnProperty("formatters")) {
      const { level: he, bindings: Ge, log: we } = G.formatters;
      X[h] = A(
        he || le.level,
        Ge || N,
        we || le.log
      );
    } else
      X[h] = A(
        le.level,
        N,
        le.log
      );
    if (G.hasOwnProperty("customLevels") === !0 && (T(this.levels, G.customLevels), X.levels = $(G.customLevels, X[v]), I(X)), typeof G.redact == "object" && G.redact !== null || Array.isArray(G.redact)) {
      X.redact = G.redact;
      const he = D(X.redact, k), Ge = { stringify: he[_] };
      X[R] = k, X[O] = he, X[E] = Ge;
    }
    typeof G.msgPrefix == "string" && (X[z] = (this[z] || "") + G.msgPrefix), X[i] = j(X, W);
    const pe = G.level || this.level;
    return X[n](pe), this.onChild(X), X;
  }
  function K() {
    const G = `{${this[i].substr(1)}}`, ee = JSON.parse(G);
    return delete ee.pid, delete ee.hostname, ee;
  }
  function V(W) {
    const G = j(this, W);
    this[i] = G, delete this[o];
  }
  function Z(W, G) {
    return Object.assign(G, W);
  }
  function Y(W, G, ee) {
    const le = this[d](), X = this[a], ce = this[b], _e = this[m], pe = this[l] || Z;
    let he;
    const Ge = this[x].streamWrite;
    W == null ? he = {} : W instanceof Error ? (he = { [ce]: W }, G === void 0 && (G = W.message)) : (he = W, G === void 0 && W[_e] === void 0 && W[ce] && (G = W[ce].message)), X && (he = pe(he, X(he, ee, this)));
    const we = this[c](he, G, ee, le), _t = this[p];
    _t[y] === !0 && (_t.lastLevel = ee, _t.lastObj = he, _t.lastMsg = G, _t.lastTime = le.slice(this[g]), _t.lastLogger = this), _t.write(Ge ? Ge(we) : we);
  }
  function J() {
  }
  function H(W) {
    if (W != null && typeof W != "function")
      throw Error("callback must be a function");
    const G = this[p];
    typeof G.flush == "function" ? G.flush(W || J) : W && W();
  }
  return jc;
}
var Ni = { exports: {} }, fh;
function qw() {
  return fh || (fh = 1, function(e, t) {
    const { hasOwnProperty: r } = Object.prototype, n = m();
    n.configure = m, n.stringify = n, n.default = n, t.stringify = n, t.configure = m, e.exports = n;
    const s = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function i(v) {
      return v.length < 5e3 && !s.test(v) ? `"${v}"` : JSON.stringify(v);
    }
    function o(v, y) {
      if (v.length > 200 || y)
        return v.sort(y);
      for (let _ = 1; _ < v.length; _++) {
        const R = v[_];
        let E = _;
        for (; E !== 0 && v[E - 1] > R; )
          v[E] = v[E - 1], E--;
        v[E] = R;
      }
      return v;
    }
    const a = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function c(v) {
      return a.call(v) !== void 0 && v.length !== 0;
    }
    function f(v, y, _) {
      v.length < _ && (_ = v.length);
      const R = y === "," ? "" : " ";
      let E = `"0":${R}${v[0]}`;
      for (let O = 1; O < _; O++)
        E += `${y}"${O}":${R}${v[O]}`;
      return E;
    }
    function l(v) {
      if (r.call(v, "circularValue")) {
        const y = v.circularValue;
        if (typeof y == "string")
          return `"${y}"`;
        if (y == null)
          return y;
        if (y === Error || y === TypeError)
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function d(v) {
      let y;
      if (r.call(v, "deterministic") && (y = v.deterministic, typeof y != "boolean" && typeof y != "function"))
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      return y === void 0 ? !0 : y;
    }
    function g(v, y) {
      let _;
      if (r.call(v, y) && (_ = v[y], typeof _ != "boolean"))
        throw new TypeError(`The "${y}" argument must be of type boolean`);
      return _ === void 0 ? !0 : _;
    }
    function p(v, y) {
      let _;
      if (r.call(v, y)) {
        if (_ = v[y], typeof _ != "number")
          throw new TypeError(`The "${y}" argument must be of type number`);
        if (!Number.isInteger(_))
          throw new TypeError(`The "${y}" argument must be an integer`);
        if (_ < 1)
          throw new RangeError(`The "${y}" argument must be >= 1`);
      }
      return _ === void 0 ? 1 / 0 : _;
    }
    function u(v) {
      return v === 1 ? "1 item" : `${v} items`;
    }
    function h(v) {
      const y = /* @__PURE__ */ new Set();
      for (const _ of v)
        (typeof _ == "string" || typeof _ == "number") && y.add(String(_));
      return y;
    }
    function b(v) {
      if (r.call(v, "strict")) {
        const y = v.strict;
        if (typeof y != "boolean")
          throw new TypeError('The "strict" argument must be of type boolean');
        if (y)
          return (_) => {
            let R = `Object can not safely be stringified. Received type ${typeof _}`;
            throw typeof _ != "function" && (R += ` (${_.toString()})`), new Error(R);
          };
      }
    }
    function m(v) {
      v = { ...v };
      const y = b(v);
      y && (v.bigint === void 0 && (v.bigint = !1), "circularValue" in v || (v.circularValue = Error));
      const _ = l(v), R = g(v, "bigint"), E = d(v), O = typeof E == "function" ? E : void 0, z = p(v, "maximumDepth"), x = p(v, "maximumBreadth");
      function L(I, T, j, P, A, k) {
        let C = T[I];
        switch (typeof C == "object" && C !== null && typeof C.toJSON == "function" && (C = C.toJSON(I)), C = P.call(T, I, C), typeof C) {
          case "string":
            return i(C);
          case "object": {
            if (C === null)
              return "null";
            if (j.indexOf(C) !== -1)
              return _;
            let D = "", F = ",";
            const w = k;
            if (Array.isArray(C)) {
              if (C.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(C), A !== "" && (k += A, D += `
${k}`, F = `,
${k}`);
              const Y = Math.min(C.length, x);
              let J = 0;
              for (; J < Y - 1; J++) {
                const W = L(String(J), C, j, P, A, k);
                D += W !== void 0 ? W : "null", D += F;
              }
              const H = L(String(J), C, j, P, A, k);
              if (D += H !== void 0 ? H : "null", C.length - 1 > x) {
                const W = C.length - x - 1;
                D += `${F}"... ${u(W)} not stringified"`;
              }
              return A !== "" && (D += `
${w}`), j.pop(), `[${D}]`;
            }
            let N = Object.keys(C);
            const q = N.length;
            if (q === 0)
              return "{}";
            if (z < j.length + 1)
              return '"[Object]"';
            let K = "", V = "";
            A !== "" && (k += A, F = `,
${k}`, K = " ");
            const Z = Math.min(q, x);
            E && !c(C) && (N = o(N, O)), j.push(C);
            for (let Y = 0; Y < Z; Y++) {
              const J = N[Y], H = L(J, C, j, P, A, k);
              H !== void 0 && (D += `${V}${i(J)}:${K}${H}`, V = F);
            }
            if (q > x) {
              const Y = q - x;
              D += `${V}"...":${K}"${u(Y)} not stringified"`, V = F;
            }
            return A !== "" && V.length > 1 && (D = `
${k}${D}
${w}`), j.pop(), `{${D}}`;
          }
          case "number":
            return isFinite(C) ? String(C) : y ? y(C) : "null";
          case "boolean":
            return C === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(C);
          default:
            return y ? y(C) : void 0;
        }
      }
      function M(I, T, j, P, A, k) {
        switch (typeof T == "object" && T !== null && typeof T.toJSON == "function" && (T = T.toJSON(I)), typeof T) {
          case "string":
            return i(T);
          case "object": {
            if (T === null)
              return "null";
            if (j.indexOf(T) !== -1)
              return _;
            const C = k;
            let D = "", F = ",";
            if (Array.isArray(T)) {
              if (T.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(T), A !== "" && (k += A, D += `
${k}`, F = `,
${k}`);
              const q = Math.min(T.length, x);
              let K = 0;
              for (; K < q - 1; K++) {
                const Z = M(String(K), T[K], j, P, A, k);
                D += Z !== void 0 ? Z : "null", D += F;
              }
              const V = M(String(K), T[K], j, P, A, k);
              if (D += V !== void 0 ? V : "null", T.length - 1 > x) {
                const Z = T.length - x - 1;
                D += `${F}"... ${u(Z)} not stringified"`;
              }
              return A !== "" && (D += `
${C}`), j.pop(), `[${D}]`;
            }
            j.push(T);
            let w = "";
            A !== "" && (k += A, F = `,
${k}`, w = " ");
            let N = "";
            for (const q of P) {
              const K = M(q, T[q], j, P, A, k);
              K !== void 0 && (D += `${N}${i(q)}:${w}${K}`, N = F);
            }
            return A !== "" && N.length > 1 && (D = `
${k}${D}
${C}`), j.pop(), `{${D}}`;
          }
          case "number":
            return isFinite(T) ? String(T) : y ? y(T) : "null";
          case "boolean":
            return T === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(T);
          default:
            return y ? y(T) : void 0;
        }
      }
      function U(I, T, j, P, A) {
        switch (typeof T) {
          case "string":
            return i(T);
          case "object": {
            if (T === null)
              return "null";
            if (typeof T.toJSON == "function") {
              if (T = T.toJSON(I), typeof T != "object")
                return U(I, T, j, P, A);
              if (T === null)
                return "null";
            }
            if (j.indexOf(T) !== -1)
              return _;
            const k = A;
            if (Array.isArray(T)) {
              if (T.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(T), A += P;
              let K = `
${A}`;
              const V = `,
${A}`, Z = Math.min(T.length, x);
              let Y = 0;
              for (; Y < Z - 1; Y++) {
                const H = U(String(Y), T[Y], j, P, A);
                K += H !== void 0 ? H : "null", K += V;
              }
              const J = U(String(Y), T[Y], j, P, A);
              if (K += J !== void 0 ? J : "null", T.length - 1 > x) {
                const H = T.length - x - 1;
                K += `${V}"... ${u(H)} not stringified"`;
              }
              return K += `
${k}`, j.pop(), `[${K}]`;
            }
            let C = Object.keys(T);
            const D = C.length;
            if (D === 0)
              return "{}";
            if (z < j.length + 1)
              return '"[Object]"';
            A += P;
            const F = `,
${A}`;
            let w = "", N = "", q = Math.min(D, x);
            c(T) && (w += f(T, F, x), C = C.slice(T.length), q -= T.length, N = F), E && (C = o(C, O)), j.push(T);
            for (let K = 0; K < q; K++) {
              const V = C[K], Z = U(V, T[V], j, P, A);
              Z !== void 0 && (w += `${N}${i(V)}: ${Z}`, N = F);
            }
            if (D > x) {
              const K = D - x;
              w += `${N}"...": "${u(K)} not stringified"`, N = F;
            }
            return N !== "" && (w = `
${A}${w}
${k}`), j.pop(), `{${w}}`;
          }
          case "number":
            return isFinite(T) ? String(T) : y ? y(T) : "null";
          case "boolean":
            return T === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(T);
          default:
            return y ? y(T) : void 0;
        }
      }
      function $(I, T, j) {
        switch (typeof T) {
          case "string":
            return i(T);
          case "object": {
            if (T === null)
              return "null";
            if (typeof T.toJSON == "function") {
              if (T = T.toJSON(I), typeof T != "object")
                return $(I, T, j);
              if (T === null)
                return "null";
            }
            if (j.indexOf(T) !== -1)
              return _;
            let P = "";
            const A = T.length !== void 0;
            if (A && Array.isArray(T)) {
              if (T.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(T);
              const w = Math.min(T.length, x);
              let N = 0;
              for (; N < w - 1; N++) {
                const K = $(String(N), T[N], j);
                P += K !== void 0 ? K : "null", P += ",";
              }
              const q = $(String(N), T[N], j);
              if (P += q !== void 0 ? q : "null", T.length - 1 > x) {
                const K = T.length - x - 1;
                P += `,"... ${u(K)} not stringified"`;
              }
              return j.pop(), `[${P}]`;
            }
            let k = Object.keys(T);
            const C = k.length;
            if (C === 0)
              return "{}";
            if (z < j.length + 1)
              return '"[Object]"';
            let D = "", F = Math.min(C, x);
            A && c(T) && (P += f(T, ",", x), k = k.slice(T.length), F -= T.length, D = ","), E && (k = o(k, O)), j.push(T);
            for (let w = 0; w < F; w++) {
              const N = k[w], q = $(N, T[N], j);
              q !== void 0 && (P += `${D}${i(N)}:${q}`, D = ",");
            }
            if (C > x) {
              const w = C - x;
              P += `${D}"...":"${u(w)} not stringified"`;
            }
            return j.pop(), `{${P}}`;
          }
          case "number":
            return isFinite(T) ? String(T) : y ? y(T) : "null";
          case "boolean":
            return T === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(T);
          default:
            return y ? y(T) : void 0;
        }
      }
      function S(I, T, j) {
        if (arguments.length > 1) {
          let P = "";
          if (typeof j == "number" ? P = " ".repeat(Math.min(j, 10)) : typeof j == "string" && (P = j.slice(0, 10)), T != null) {
            if (typeof T == "function")
              return L("", { "": I }, [], T, P, "");
            if (Array.isArray(T))
              return M("", I, [], h(T), P, "");
          }
          if (P.length !== 0)
            return U("", I, [], P, "");
        }
        return $("", I, []);
      }
      return S;
    }
  }(Ni, Ni.exports)), Ni.exports;
}
var Dc, dh;
function Hw() {
  if (dh) return Dc;
  dh = 1;
  const e = Symbol.for("pino.metadata"), { DEFAULT_LEVELS: t } = Qu(), r = t.info;
  function n(c, f) {
    let l = 0;
    c = c || [], f = f || { dedupe: !1 };
    const d = Object.create(t);
    d.silent = 1 / 0, f.levels && typeof f.levels == "object" && Object.keys(f.levels).forEach((y) => {
      d[y] = f.levels[y];
    });
    const g = {
      write: p,
      add: b,
      emit: u,
      flushSync: h,
      end: m,
      minLevel: 0,
      streams: [],
      clone: v,
      [e]: !0,
      streamLevels: d
    };
    return Array.isArray(c) ? c.forEach(b, g) : b.call(g, c), c = null, g;
    function p(y) {
      let _;
      const R = this.lastLevel, { streams: E } = this;
      let O = 0, z;
      for (let x = i(E.length, f.dedupe); a(x, E.length, f.dedupe); x = o(x, f.dedupe))
        if (_ = E[x], _.level <= R) {
          if (O !== 0 && O !== _.level)
            break;
          if (z = _.stream, z[e]) {
            const { lastTime: L, lastMsg: M, lastObj: U, lastLogger: $ } = this;
            z.lastLevel = R, z.lastTime = L, z.lastMsg = M, z.lastObj = U, z.lastLogger = $;
          }
          z.write(y), f.dedupe && (O = _.level);
        } else if (!f.dedupe)
          break;
    }
    function u(...y) {
      for (const { stream: _ } of this.streams)
        typeof _.emit == "function" && _.emit(...y);
    }
    function h() {
      for (const { stream: y } of this.streams)
        typeof y.flushSync == "function" && y.flushSync();
    }
    function b(y) {
      if (!y)
        return g;
      const _ = typeof y.write == "function" || y.stream, R = y.write ? y : y.stream;
      if (!_)
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      const { streams: E, streamLevels: O } = this;
      let z;
      typeof y.levelVal == "number" ? z = y.levelVal : typeof y.level == "string" ? z = O[y.level] : typeof y.level == "number" ? z = y.level : z = r;
      const x = {
        stream: R,
        level: z,
        levelVal: void 0,
        id: l++
      };
      return E.unshift(x), E.sort(s), this.minLevel = E[0].level, g;
    }
    function m() {
      for (const { stream: y } of this.streams)
        typeof y.flushSync == "function" && y.flushSync(), y.end();
    }
    function v(y) {
      const _ = new Array(this.streams.length);
      for (let R = 0; R < _.length; R++)
        _[R] = {
          level: y,
          stream: this.streams[R].stream
        };
      return {
        write: p,
        add: b,
        minLevel: y,
        streams: _,
        clone: v,
        emit: u,
        flushSync: h,
        [e]: !0
      };
    }
  }
  function s(c, f) {
    return c.level - f.level;
  }
  function i(c, f) {
    return f ? c - 1 : 0;
  }
  function o(c, f) {
    return f ? c - 1 : c + 1;
  }
  function a(c, f, l) {
    return l ? c >= 0 : c < f;
  }
  return Dc = n, Dc;
}
var ph;
function Bw() {
  if (ph) return It.exports;
  ph = 1;
  const e = yv, t = Xv(), r = Zv(), n = eb(), s = Aw(), i = Uw(), o = ui(), { configure: a } = qw(), { assertDefaultLevelFound: c, mappings: f, genLsCache: l, genLevelComparison: d, assertLevelComparison: g } = sb(), { DEFAULT_LEVELS: p, SORTING_ORDER: u } = Qu(), {
    createArgsNormalizer: h,
    asChindings: b,
    buildSafeSonicBoom: m,
    buildFormatters: v,
    stringify: y,
    normalizeDestFileDescriptor: _,
    noop: R
  } = Zu(), { version: E } = ib(), {
    chindingsSym: O,
    redactFmtSym: z,
    serializersSym: x,
    timeSym: L,
    timeSliceIndexSym: M,
    streamSym: U,
    stringifySym: $,
    stringifySafeSym: S,
    stringifiersSym: I,
    setLevelSym: T,
    endSym: j,
    formatOptsSym: P,
    messageKeySym: A,
    errorKeySym: k,
    nestedKeySym: C,
    mixinSym: D,
    levelCompSym: F,
    useOnlyCustomLevelsSym: w,
    formattersSym: N,
    hooksSym: q,
    nestedKeyStrSym: K,
    mixinMergeStrategySym: V,
    msgPrefixSym: Z
  } = o, { epochTime: Y, nullTime: J } = s, { pid: H } = process, W = e.hostname(), G = t.err, ee = {
    level: "info",
    levelComparison: u.ASC,
    levels: p,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: !0,
    base: { pid: H, hostname: W },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: G
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(_e) {
        return _e;
      },
      level(_e, pe) {
        return { level: pe };
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
    timestamp: Y,
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: !1,
    depthLimit: 5,
    edgeLimit: 100
  }, le = h(ee), X = Object.assign(/* @__PURE__ */ Object.create(null), t);
  function ce(..._e) {
    const pe = {}, { opts: he, stream: Ge } = le(pe, r(), ..._e);
    he.level && typeof he.level == "string" && p[he.level.toLowerCase()] !== void 0 && (he.level = he.level.toLowerCase());
    const {
      redact: we,
      crlf: _t,
      serializers: xn,
      timestamp: Pe,
      messageKey: Bt,
      errorKey: $r,
      nestedKey: Te,
      base: it,
      name: pp,
      level: Ot,
      customLevels: Vt,
      levelComparison: hp,
      mixin: Qe,
      mixinMergeStrategy: Xa,
      useOnlyCustomLevels: $i,
      formatters: ht,
      hooks: Ti,
      depthLimit: ix,
      edgeLimit: Sn,
      onChild: Pt,
      msgPrefix: Br
    } = he, tr = a({
      maximumDepth: ix,
      maximumBreadth: Sn
    }), Tr = v(
      ht.level,
      ht.bindings,
      ht.log
    ), ps = y.bind({
      [S]: tr
    }), rr = we ? n(we, ps) : {}, ox = we ? { stringify: rr[z] } : { stringify: ps }, ax = "}" + (_t ? `\r
` : `
`), mp = b.bind(null, {
      [O]: "",
      [x]: xn,
      [I]: rr,
      [$]: y,
      [S]: tr,
      [N]: Tr
    });
    let Za = "";
    it !== null && (pp === void 0 ? Za = mp(it) : Za = mp(Object.assign({}, it, { name: pp })));
    const yp = Pe instanceof Function ? Pe : Pe ? Y : J, cx = yp().indexOf(":") + 1;
    if ($i && !Vt) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (Qe && typeof Qe != "function") throw Error(`Unknown mixin type "${typeof Qe}" - expected "function"`);
    if (Br && typeof Br != "string") throw Error(`Unknown msgPrefix type "${typeof Br}" - expected "string"`);
    c(Ot, Vt, $i);
    const gp = f(Vt, $i);
    typeof Ge.emit == "function" && Ge.emit("message", { code: "PINO_CONFIG", config: { levels: gp, messageKey: Bt, errorKey: $r } }), g(hp);
    const lx = d(hp);
    return Object.assign(pe, {
      levels: gp,
      [F]: lx,
      [w]: $i,
      [U]: Ge,
      [L]: yp,
      [M]: cx,
      [$]: y,
      [S]: tr,
      [I]: rr,
      [j]: ax,
      [P]: ox,
      [A]: Bt,
      [k]: $r,
      [C]: Te,
      // protect against injection
      [K]: Te ? `,${JSON.stringify(Te)}:{` : "",
      [x]: xn,
      [D]: Qe,
      [V]: Xa,
      [O]: Za,
      [N]: Tr,
      [q]: Ti,
      silent: R,
      onChild: Pt,
      [Z]: Br
    }), Object.setPrototypeOf(pe, i()), l(pe), pe[T](Ot), pe;
  }
  return It.exports = ce, It.exports.destination = (_e = process.stdout.fd) => typeof _e == "object" ? (_e.dest = _(_e.dest || process.stdout.fd), m(_e)) : m({ dest: _(_e), minLength: 0 }), It.exports.transport = nb(), It.exports.multistream = Hw(), It.exports.levels = f(), It.exports.stdSerializers = X, It.exports.stdTimeFunctions = Object.assign({}, s), It.exports.symbols = o, It.exports.version = E, It.exports.default = ce, It.exports.pino = ce, It.exports;
}
var Fc, hh;
function Vw() {
  if (hh) return Fc;
  hh = 1;
  const e = Bw(), { serializersSym: t } = e.symbols, {
    FST_ERR_LOG_INVALID_DESTINATION: r
  } = bt;
  function n(i) {
    if (i.stream && i.file)
      throw new r();
    i.file && (i.stream = e.destination(i.file), delete i.file);
    const o = i.logger, a = i.genReqId;
    let c = null;
    return o ? (i.logger = void 0, i.genReqId = void 0, o[t] && (i.serializers = Object.assign({}, i.serializers, o[t])), c = o.child({}, i), i.logger = o, i.genReqId = a) : c = e(i, i.stream), c;
  }
  return Fc = {
    serializers: {
      req: function(o) {
        return {
          method: o.method,
          url: o.url,
          version: o.headers && o.headers["accept-version"],
          host: o.host,
          remoteAddress: o.ip,
          remotePort: o.socket ? o.socket.remotePort : void 0
        };
      },
      err: e.stdSerializers.err,
      res: function(o) {
        return {
          statusCode: o.statusCode
        };
      }
    },
    createPinoLogger: n
  }, Fc;
}
const {
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: Gw,
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: Ww,
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: Kw,
  FST_ERR_LOG_INVALID_LOGGER: Jw
} = bt;
function Yw(e, t, r, n, s) {
  const i = {
    [e.requestIdLogLabel]: n
  }, o = e.childLoggerFactory.call(e.server, t, i, s || {}, r);
  return e.childLoggerFactory !== ob && ru(o, !0), o;
}
function ob(e, t, r) {
  return e.child(t, r);
}
function ru(e, t) {
  const r = ["info", "error", "debug", "fatal", "warn", "trace", "child"], n = e ? r.filter((s) => !e[s] || typeof e[s] != "function") : r;
  if (n.length) {
    if (n.length === r.length && !t)
      return !1;
    throw Jw(n.join(","));
  } else return !0;
}
function Xw(e) {
  if (e.logger && e.loggerInstance)
    throw new Gw();
  if (!e.loggerInstance && !e.logger) {
    const o = xw();
    return o.child = () => o, { logger: o, hasLogger: !1 };
  }
  const { createPinoLogger: t, serializers: r } = Vw();
  if (ru(e.loggerInstance))
    return { logger: t({
      logger: e.loggerInstance,
      serializers: Object.assign({}, r, e.loggerInstance.serializers)
    }), hasLogger: !0 };
  if (ru(e.logger))
    throw Ww();
  if (e.loggerInstance)
    throw Kw();
  const n = {};
  return Object.prototype.toString.call(e.logger) === "[object Object]" && Reflect.ownKeys(e.logger).forEach((i) => {
    Object.defineProperty(n, i, {
      value: e.logger[i],
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }), n.level = n.level || "info", n.serializers = Object.assign({}, r, n.serializers), e.logger = n, { logger: t(e.logger), hasLogger: !0 };
}
function Zw() {
  const e = process.hrtime();
  return e[0] * 1e3 + e[1] / 1e6;
}
var ca = {
  createChildLogger: Yw,
  defaultChildLoggerFactory: ob,
  createLogger: Xw,
  now: Zw
}, ef = Qw;
function Un(e) {
  return e instanceof Buffer ? Buffer.from(e) : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
}
function Qw(e) {
  if (e = e || {}, e.circles) return eR(e);
  const t = /* @__PURE__ */ new Map();
  if (t.set(Date, (o) => new Date(o)), t.set(Map, (o, a) => new Map(n(Array.from(o), a))), t.set(Set, (o, a) => new Set(n(Array.from(o), a))), e.constructorHandlers)
    for (const o of e.constructorHandlers)
      t.set(o[0], o[1]);
  let r = null;
  return e.proto ? i : s;
  function n(o, a) {
    const c = Object.keys(o), f = new Array(c.length);
    for (let l = 0; l < c.length; l++) {
      const d = c[l], g = o[d];
      typeof g != "object" || g === null ? f[d] = g : g.constructor !== Object && (r = t.get(g.constructor)) ? f[d] = r(g, a) : ArrayBuffer.isView(g) ? f[d] = Un(g) : f[d] = a(g);
    }
    return f;
  }
  function s(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, s);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, s);
    const a = {};
    for (const c in o) {
      if (Object.hasOwnProperty.call(o, c) === !1) continue;
      const f = o[c];
      typeof f != "object" || f === null ? a[c] = f : f.constructor !== Object && (r = t.get(f.constructor)) ? a[c] = r(f, s) : ArrayBuffer.isView(f) ? a[c] = Un(f) : a[c] = s(f);
    }
    return a;
  }
  function i(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, i);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, i);
    const a = {};
    for (const c in o) {
      const f = o[c];
      typeof f != "object" || f === null ? a[c] = f : f.constructor !== Object && (r = t.get(f.constructor)) ? a[c] = r(f, i) : ArrayBuffer.isView(f) ? a[c] = Un(f) : a[c] = i(f);
    }
    return a;
  }
}
function eR(e) {
  const t = [], r = [], n = /* @__PURE__ */ new Map();
  if (n.set(Date, (c) => new Date(c)), n.set(Map, (c, f) => new Map(i(Array.from(c), f))), n.set(Set, (c, f) => new Set(i(Array.from(c), f))), e.constructorHandlers)
    for (const c of e.constructorHandlers)
      n.set(c[0], c[1]);
  let s = null;
  return e.proto ? a : o;
  function i(c, f) {
    const l = Object.keys(c), d = new Array(l.length);
    for (let g = 0; g < l.length; g++) {
      const p = l[g], u = c[p];
      if (typeof u != "object" || u === null)
        d[p] = u;
      else if (u.constructor !== Object && (s = n.get(u.constructor)))
        d[p] = s(u, f);
      else if (ArrayBuffer.isView(u))
        d[p] = Un(u);
      else {
        const h = t.indexOf(u);
        h !== -1 ? d[p] = r[h] : d[p] = f(u);
      }
    }
    return d;
  }
  function o(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return i(c, o);
    if (c.constructor !== Object && (s = n.get(c.constructor)))
      return s(c, o);
    const f = {};
    t.push(c), r.push(f);
    for (const l in c) {
      if (Object.hasOwnProperty.call(c, l) === !1) continue;
      const d = c[l];
      if (typeof d != "object" || d === null)
        f[l] = d;
      else if (d.constructor !== Object && (s = n.get(d.constructor)))
        f[l] = s(d, o);
      else if (ArrayBuffer.isView(d))
        f[l] = Un(d);
      else {
        const g = t.indexOf(d);
        g !== -1 ? f[l] = r[g] : f[l] = o(d);
      }
    }
    return t.pop(), r.pop(), f;
  }
  function a(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return i(c, a);
    if (c.constructor !== Object && (s = n.get(c.constructor)))
      return s(c, a);
    const f = {};
    t.push(c), r.push(f);
    for (const l in c) {
      const d = c[l];
      if (typeof d != "object" || d === null)
        f[l] = d;
      else if (d.constructor !== Object && (s = n.get(d.constructor)))
        f[l] = s(d, a);
      else if (ArrayBuffer.isView(d))
        f[l] = Un(d);
      else {
        const g = t.indexOf(d);
        g !== -1 ? f[l] = r[g] : f[l] = a(d);
      }
    }
    return t.pop(), r.pop(), f;
  }
}
const tR = ef({ circles: !1, proto: !0 }), { kSchemaVisited: mh, kSchemaResponse: rR } = pt, nu = Symbol.for("fluent-schema-object"), {
  FST_ERR_SCH_MISSING_ID: nR,
  FST_ERR_SCH_ALREADY_PRESENT: sR,
  FST_ERR_SCH_DUPLICATE: iR,
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: yh
} = bt, ab = ["params", "body", "querystring", "query", "headers"];
function la(e) {
  this.store = e || {};
}
la.prototype.add = function(e) {
  const t = tR(
    e.isFluentSchema || e.isFluentJSONSchema || e[nu] ? e.valueOf() : e
  ), r = t.$id;
  if (!r)
    throw new nR();
  if (this.store[r])
    throw new sR(r);
  this.store[r] = t;
};
la.prototype.getSchemas = function() {
  return Object.assign({}, this.store);
};
la.prototype.getSchema = function(e) {
  return this.store[e];
};
function gh(e) {
  return typeof e == "object" && Object.getPrototypeOf(e) !== Object.prototype;
}
function oR(e, t) {
  if (e[mh])
    return e;
  if (e.query) {
    if (e.querystring)
      throw new iR("querystring");
    e.querystring = e.query;
  }
  aR(e);
  for (const r of ab) {
    const n = e[r];
    if (n && !gh(n) && r === "body" && n.content) {
      const s = n.content, i = Object.keys(s);
      for (let o = 0; o < i.length; o++) {
        const a = i[o];
        if (!s[a].schema)
          throw new yh(a);
      }
      continue;
    }
  }
  if (e.response) {
    const r = Object.keys(e.response);
    for (const n of r) {
      if (gh(e.response[n]))
        continue;
      const s = e.response[n].content;
      if (s) {
        const i = Object.keys(s);
        for (let o = 0; o < i.length; o++) {
          const a = i[o];
          if (!s[a].schema)
            throw new yh(a);
        }
      }
    }
  }
  return e[mh] = !0, e;
}
function aR(e) {
  for (const t of ab)
    e[t] && (e[t].isFluentSchema || e[t][nu]) && (e[t] = e[t].valueOf());
  if (e.response) {
    const t = Object.keys(e.response);
    for (const r of t)
      (e.response[r].isFluentSchema || e.response[r][nu]) && (e.response[r] = e.response[r].valueOf());
  }
}
function cR(e, t, r) {
  const n = e[rR];
  if (!n)
    return !1;
  if (n[t]) {
    if (n[t].constructor === Object && r) {
      const i = r.split(";", 1)[0];
      return n[t][i] ? n[t][i] : n[t]["*/*"] ? n[t]["*/*"] : !1;
    }
    return n[t];
  }
  const s = (t + "")[0] + "xx";
  if (n[s]) {
    if (n[s].constructor === Object && r) {
      const i = r.split(";", 1)[0];
      return n[s][i] ? n[s][i] : n[s]["*/*"] ? n[s]["*/*"] : !1;
    }
    return n[s];
  }
  if (n.default) {
    if (n.default.constructor === Object && r) {
      const i = r.split(";", 1)[0];
      return n.default[i] ? n.default[i] : n.default["*/*"] ? n.default["*/*"] : !1;
    }
    return n.default;
  }
  return !1;
}
var ua = {
  buildSchemas(e) {
    return new la(e);
  },
  getSchemaSerializer: cR,
  normalizeSchema: oR
};
const lR = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
var tf = class cb {
  constructor(t) {
    switch (t && t.rounding) {
      case "floor":
        this.parseInteger = Math.floor;
        break;
      case "ceil":
        this.parseInteger = Math.ceil;
        break;
      case "round":
        this.parseInteger = Math.round;
        break;
      case "trunc":
      default:
        this.parseInteger = Math.trunc;
        break;
    }
    this._options = t;
  }
  asInteger(t) {
    if (Number.isInteger(t))
      return "" + t;
    if (typeof t == "bigint")
      return t.toString();
    const r = this.parseInteger(t);
    if (r === 1 / 0 || r === -1 / 0 || r !== r)
      throw new Error(`The value "${t}" cannot be converted to an integer.`);
    return "" + r;
  }
  asNumber(t) {
    const r = Number(t);
    if (r !== r)
      throw new Error(`The value "${t}" cannot be converted to a number.`);
    return r === 1 / 0 || r === -1 / 0 ? "null" : "" + r;
  }
  asBoolean(t) {
    return t && "true" || "false";
  }
  asDateTime(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + t.toISOString() + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date-time.`);
  }
  asDate(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date.`);
  }
  asTime(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a time.`);
  }
  asString(t) {
    const r = t.length;
    if (r < 42) {
      let n = "", s = -1, i = 255;
      for (let o = 0; o < r; o++)
        if (i = t.charCodeAt(o), i === 34 || // '"'
        i === 92)
          s === -1 && (s = 0), n += t.slice(s, o) + "\\", s = o;
        else if (i < 32 || i >= 55296 && i <= 57343)
          return JSON.stringify(t);
      return s === -1 && '"' + t + '"' || '"' + n + t.slice(s) + '"';
    } else return r < 5e3 && lR.test(t) === !1 ? '"' + t + '"' : JSON.stringify(t);
  }
  asUnsafeString(t) {
    return '"' + t + '"';
  }
  getState() {
    return this._options;
  }
  static restoreFromState(t) {
    return new cb(t);
  }
};
const uR = tf, fR = { mode: "standalone" }, dR = uR.restoreFromState(fR), pR = null;
var hR = function(t, r) {
  const n = "{", s = "}", i = ",", o = '"', a = n + s, c = o + o;
  function f(d) {
    const g = d && typeof d.toJSON == "function" ? d.toJSON() : d;
    if (g === null) return a;
    let p, u = n, h = !1;
    return p = g.statusCode, p !== void 0 && (!h && (h = !0) || (u += i), u += '"statusCode":', u += r.asNumber(p)), p = g.code, p !== void 0 && (!h && (h = !0) || (u += i), u += '"code":', typeof p != "string" ? p === null ? u += c : p instanceof Date ? u += o + p.toISOString() + o : p instanceof RegExp ? u += r.asString(p.source) : u += r.asString(p.toString()) : u += r.asString(p)), p = g.error, p !== void 0 && (!h && (h = !0) || (u += i), u += '"error":', typeof p != "string" ? p === null ? u += c : p instanceof Date ? u += o + p.toISOString() + o : p instanceof RegExp ? u += r.asString(p.source) : u += r.asString(p.toString()) : u += r.asString(p)), p = g.message, p !== void 0 && (!h && (h = !0) || (u += i), u += '"message":', typeof p != "string" ? p === null ? u += c : p instanceof Date ? u += o + p.toISOString() + o : p instanceof RegExp ? u += r.asString(p.source) : u += r.asString(p.toString()) : u += r.asString(p)), u + s;
  }
  return f;
}(pR, dR);
const vh = ea.STATUS_CODES, mR = Wv, {
  kReplyHeaders: on,
  kReplyNextErrorHandler: Ai,
  kReplyIsRunningOnErrorHook: yR,
  kReplyHasStatusCode: gR,
  kRouteContext: lb,
  kDisableRequestLogging: Co
} = pt, {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: vR,
  FST_ERR_FAILED_ERROR_SERIALIZATION: bR
} = bt, { getSchemaSerializer: _R } = ua, Mc = hR, ER = {
  func: SR,
  toJSON() {
    return this.func.name.toString() + "()";
  }
};
function xR(e, t, r) {
  e[yR] = !1;
  const n = e[lb];
  if (e[Ai] === !1) {
    bh(t, e, function(o, a) {
      try {
        o.raw.writeHead(o.raw.statusCode, o[on]);
      } catch (c) {
        o.log[Co] || o.log.warn(
          { req: o.request, res: o, err: c },
          c && c.message
        ), o.raw.writeHead(o.raw.statusCode);
      }
      o.raw.end(a);
    });
    return;
  }
  const s = e[Ai] || n.errorHandler;
  e[Ai] = Object.getPrototypeOf(s), delete e[on]["content-type"], delete e[on]["content-length"];
  const i = s.func;
  if (!i) {
    e[Ai] = !1, bh(t, e, r);
    return;
  }
  try {
    const o = i(t, e.request, e);
    o !== void 0 && (o !== null && typeof o.then == "function" ? mR(o, e) : e.send(o));
  } catch (o) {
    e.send(o);
  }
}
function SR(e, t, r) {
  if (RR(e, r), !r[gR] || r.statusCode === 200) {
    const n = e.statusCode || e.status;
    r.code(n >= 400 ? n : 500);
  }
  r.statusCode < 500 ? r.log[Co] || r.log.info(
    { res: r, err: e },
    e && e.message
  ) : r.log[Co] || r.log.error(
    { req: t, res: r, err: e },
    e && e.message
  ), r.send(e);
}
function bh(e, t, r) {
  const n = t.raw, s = t.statusCode;
  t[on]["content-type"] = t[on]["content-type"] ?? "application/json; charset=utf-8";
  let i;
  try {
    const o = _R(t[lb], s, t[on]["content-type"]);
    o === !1 ? i = Mc({
      error: vh[s + ""],
      code: e.code,
      message: e.message,
      statusCode: s
    }) : i = o(Object.create(e, {
      error: { value: vh[s + ""] },
      message: { value: e.message },
      statusCode: { value: s }
    }));
  } catch (o) {
    t.log[Co] || t.log.error({ err: o, statusCode: n.statusCode }, "The serializer for the given status code failed"), t.code(500), i = Mc(new bR(o.message, e.message));
  }
  typeof i != "string" && !Buffer.isBuffer(i) && (i = Mc(new vR(typeof i))), t[on]["content-length"] = "" + Buffer.byteLength(i), r(t, i);
}
function wR(e = ER, t) {
  if (!t)
    return e;
  const r = Object.create(e);
  return r.func = t, r;
}
function RR(e, t) {
  const r = t.raw;
  let n = r.statusCode;
  n = n >= 400 ? n : 500, e != null && (e.headers !== void 0 && t.headers(e.headers), e.status >= 400 ? n = e.status : e.statusCode >= 400 && (n = e.statusCode)), r.statusCode = n;
}
var fa = {
  buildErrorHandler: wR,
  handleError: xR
};
const su = ri.finished, $R = ri.Readable, {
  kFourOhFourContext: _h,
  kReplyErrorHandlerCalled: ub,
  kReplyHijacked: rf,
  kReplyStartTime: Us,
  kReplyEndTime: nf,
  kReplySerializer: xr,
  kReplySerializerDefault: Io,
  kReplyIsError: No,
  kReplyHeaders: Ne,
  kReplyTrailers: st,
  kReplyHasStatusCode: sf,
  kReplyIsRunningOnErrorHook: of,
  kReplyNextErrorHandler: TR,
  kDisableRequestLogging: fb,
  kSchemaResponse: Ao,
  kReplyCacheSerializeFns: Lr,
  kSchemaController: zc,
  kOptions: OR,
  kRouteContext: ye
} = pt, {
  onSendHookRunner: db,
  onResponseHookRunner: PR,
  preHandlerHookRunner: CR,
  preSerializationHookRunner: IR
} = bn, Eh = Kv[Symbol.for("internals")], NR = ca, iu = NR.now, { handleError: xh } = fa, { getSchemaSerializer: AR } = ua, Uc = {
  JSON: "application/json; charset=utf-8",
  PLAIN: "text/plain; charset=utf-8",
  OCTET: "application/octet-stream"
}, {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: kR,
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: LR,
  FST_ERR_REP_READABLE_STREAM_LOCKED: jR,
  FST_ERR_REP_ALREADY_SENT: DR,
  FST_ERR_SEND_INSIDE_ONERR: FR,
  FST_ERR_BAD_STATUS_CODE: MR,
  FST_ERR_BAD_TRAILER_NAME: zR,
  FST_ERR_BAD_TRAILER_VALUE: UR,
  FST_ERR_MISSING_SERIALIZATION_FN: qR,
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: HR
} = bt, pb = Object.prototype.toString;
function Ie(e, t, r) {
  this.raw = e, this[xr] = null, this[ub] = !1, this[No] = !1, this[of] = !1, this.request = t, this[Ne] = {}, this[st] = null, this[sf] = !1, this[Us] = void 0, this.log = r;
}
Ie.props = [];
Object.defineProperties(Ie.prototype, {
  [ye]: {
    get() {
      return this.request[ye];
    }
  },
  elapsedTime: {
    get() {
      return this[Us] === void 0 ? 0 : (this[nf] || iu()) - this[Us];
    }
  },
  server: {
    get() {
      return this.request[ye].server;
    }
  },
  sent: {
    enumerable: !0,
    get() {
      return (this[rf] || this.raw.writableEnded) === !0;
    }
  },
  statusCode: {
    get() {
      return this.raw.statusCode;
    },
    set(e) {
      this.code(e);
    }
  },
  routeOptions: {
    get() {
      return this.request.routeOptions;
    }
  }
});
Ie.prototype.writeEarlyHints = function(e, t) {
  return this.raw.writeEarlyHints(e, t), this;
};
Ie.prototype.hijack = function() {
  return this[rf] = !0, this;
};
Ie.prototype.send = function(e) {
  if (this[of] === !0)
    throw new FR();
  if (this.sent)
    return this.log.warn({ err: new DR(this.request.url, this.request.method) }), this;
  if (e instanceof Error || this[No] === !0)
    return this[No] = !1, qs(this, e, Qr), this;
  if (e === void 0)
    return Qr(this, e), this;
  const t = this.getHeader("content-type"), r = t !== void 0;
  if (e !== null) {
    if (
      // node:stream
      typeof e.pipe == "function" || // node:stream/web
      typeof e.getReader == "function" || // Response
      pb.call(e) === "[object Response]"
    )
      return Qr(this, e), this;
    if ((e == null ? void 0 : e.buffer) instanceof ArrayBuffer) {
      r === !1 && (this[Ne]["content-type"] = Uc.OCTET);
      const n = Buffer.isBuffer(e) ? e : Buffer.from(e.buffer, e.byteOffset, e.byteLength);
      return Qr(this, n), this;
    }
    if (r === !1 && typeof e == "string")
      return this[Ne]["content-type"] = Uc.PLAIN, Qr(this, e), this;
  }
  if (this[xr] !== null) {
    if (typeof e != "string")
      return Sh(this, e), this;
    e = this[xr](e);
  } else if (r === !1 || t.indexOf("json") > -1) {
    if (r === !1)
      this[Ne]["content-type"] = Uc.JSON;
    else if (t.indexOf("charset") === -1) {
      const n = t.trim();
      n.endsWith(";") ? this[Ne]["content-type"] = `${n} charset=utf-8` : this[Ne]["content-type"] = `${n}; charset=utf-8`;
    }
    if (typeof e != "string")
      return Sh(this, e), this;
  }
  return Qr(this, e), this;
};
Ie.prototype.getHeader = function(e) {
  e = e.toLowerCase();
  const t = this.raw;
  let r = this[Ne][e];
  return r === void 0 && t.hasHeader(e) && (r = t.getHeader(e)), r;
};
Ie.prototype.getHeaders = function() {
  return {
    ...this.raw.getHeaders(),
    ...this[Ne]
  };
};
Ie.prototype.hasHeader = function(e) {
  return e = e.toLowerCase(), this[Ne][e] !== void 0 || this.raw.hasHeader(e);
};
Ie.prototype.removeHeader = function(e) {
  return delete this[Ne][e.toLowerCase()], this;
};
Ie.prototype.header = function(e, t = "") {
  return e = e.toLowerCase(), this[Ne][e] && e === "set-cookie" ? (typeof this[Ne][e] == "string" && (this[Ne][e] = [this[Ne][e]]), Array.isArray(t) ? Array.prototype.push.apply(this[Ne][e], t) : this[Ne][e].push(t)) : this[Ne][e] = t, this;
};
Ie.prototype.headers = function(e) {
  const t = Object.keys(e);
  for (let r = 0; r !== t.length; ++r) {
    const n = t[r];
    this.header(n, e[n]);
  }
  return this;
};
const BR = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "content-length",
  "host",
  "cache-control",
  "max-forwards",
  "te",
  "authorization",
  "set-cookie",
  "content-encoding",
  "content-type",
  "content-range",
  "trailer"
]);
Ie.prototype.trailer = function(e, t) {
  if (e = e.toLowerCase(), BR.has(e))
    throw new zR(e);
  if (typeof t != "function")
    throw new UR(e, typeof t);
  return this[st] === null && (this[st] = {}), this[st][e] = t, this;
};
Ie.prototype.hasTrailer = function(e) {
  var t;
  return ((t = this[st]) == null ? void 0 : t[e.toLowerCase()]) !== void 0;
};
Ie.prototype.removeTrailer = function(e) {
  return this[st] === null ? this : (this[st][e.toLowerCase()] = void 0, this);
};
Ie.prototype.code = function(e) {
  const t = Number(e);
  if (isNaN(t) || t < 100 || t > 599)
    throw new MR(e || String(e));
  return this.raw.statusCode = t, this[sf] = !0, this;
};
Ie.prototype.status = Ie.prototype.code;
Ie.prototype.getSerializationFunction = function(e, t) {
  var n, s, i, o;
  let r;
  return typeof e == "string" || typeof e == "number" ? typeof t == "string" ? r = (s = (n = this[ye][Ao]) == null ? void 0 : n[e]) == null ? void 0 : s[t] : r = (i = this[ye][Ao]) == null ? void 0 : i[e] : typeof e == "object" && (r = (o = this[ye][Lr]) == null ? void 0 : o.get(e)), r;
};
Ie.prototype.compileSerializationSchema = function(e, t = null, r = null) {
  var c;
  const { request: n } = this, { method: s, url: i } = n;
  if ((c = this[ye][Lr]) != null && c.has(e))
    return this[ye][Lr].get(e);
  const a = (this[ye].serializerCompiler || this.server[zc].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
  // nor set
  this.server[zc].setupSerializer(this.server[OR]) || this.server[zc].serializerCompiler)({
    schema: e,
    method: s,
    url: i,
    httpStatus: t,
    contentType: r
  });
  return this[ye][Lr] == null && (this[ye][Lr] = /* @__PURE__ */ new WeakMap()), this[ye][Lr].set(e, a), a;
};
Ie.prototype.serializeInput = function(e, t, r, n) {
  var o, a, c, f;
  const s = r;
  let i;
  if (r = typeof t == "string" || typeof t == "number" ? t : r, n = r && s !== r ? s : n, r != null) {
    if (n != null ? i = (a = (o = this[ye][Ao]) == null ? void 0 : o[r]) == null ? void 0 : a[n] : i = (c = this[ye][Ao]) == null ? void 0 : c[r], i == null)
      throw n ? new HR(r, n) : new qR(r);
  } else
    (f = this[ye][Lr]) != null && f.has(t) ? i = this[ye][Lr].get(t) : i = this.compileSerializationSchema(t, r, n);
  return i(e);
};
Ie.prototype.serialize = function(e) {
  return this[xr] !== null ? this[xr](e) : this[ye] && this[ye][Io] ? this[ye][Io](e, this.raw.statusCode) : yb(this[ye], e, this.raw.statusCode);
};
Ie.prototype.serializer = function(e) {
  return this[xr] = e, this;
};
Ie.prototype.type = function(e) {
  return this[Ne]["content-type"] = e, this;
};
Ie.prototype.redirect = function(e, t) {
  return t || (t = this[sf] ? this.raw.statusCode : 302), this.header("location", e).code(t).send();
};
Ie.prototype.callNotFound = function() {
  return XR(this), this;
};
Ie.prototype.then = function(e, t) {
  if (this.sent) {
    e();
    return;
  }
  su(this.raw, (r) => {
    r && r.code !== "ERR_STREAM_PREMATURE_CLOSE" ? t ? t(r) : this.log && this.log.warn("unhandled rejection on reply.then") : e();
  });
};
function Sh(e, t) {
  e[ye].preSerialization !== null ? IR(
    e[ye].preSerialization,
    e.request,
    e,
    t,
    wh
  ) : wh(null, e.request, e, t);
}
function wh(e, t, r, n) {
  if (e != null) {
    qs(r, e);
    return;
  }
  try {
    r[xr] !== null ? n = r[xr](n) : r[ye] && r[ye][Io] ? n = r[ye][Io](n, r.raw.statusCode) : n = yb(r[ye], n, r.raw.statusCode, r[Ne]["content-type"]);
  } catch (s) {
    VR(s, r), qs(r, s);
    return;
  }
  Qr(r, n);
}
function VR(e, t) {
  e.serialization = t[ye].config;
}
function Qr(e, t) {
  e[ye].onSend !== null ? db(
    e[ye].onSend,
    e.request,
    e,
    t,
    GR
  ) : hb(e, t);
}
function GR(e, t, r, n) {
  e != null ? qs(r, e) : hb(r, n);
}
function qc(e, t) {
  const r = e.raw;
  try {
    r.writeHead(t, e[Ne]);
  } catch (n) {
    throw n.code === "ERR_HTTP_HEADERS_SENT" && e.log.warn(`Reply was already sent, did you forget to "return reply" in the "${e.request.raw.url}" (${e.request.raw.method}) route?`), n;
  }
}
function hb(e, t) {
  const r = e.raw, n = e.request;
  if (e[st] !== null) {
    const i = Object.keys(e[st]);
    let o = "";
    for (const a of i)
      typeof e[st][a] == "function" && (o += " ", o += a);
    e.header("Transfer-Encoding", "chunked"), e.header("Trailer", o.trim());
  }
  if (pb.call(t) === "[object Response]") {
    if (typeof t.status == "number" && e.code(t.status), typeof t.headers == "object" && typeof t.headers.forEach == "function")
      for (const [i, o] of t.headers)
        e.header(i, o);
    if (t.body !== null && t.bodyUsed)
      throw new LR();
    t = t.body;
  }
  const s = r.statusCode;
  if (t == null) {
    s >= 200 && s !== 204 && s !== 304 && n.method !== "HEAD" && e[st] === null && (e[Ne]["content-length"] = "0"), qc(e, s), uo(t, r, e);
    return;
  }
  if (s >= 100 && s < 200 || s === 204) {
    e.removeHeader("content-type"), e.removeHeader("content-length"), qc(e, s), uo(void 0, r, e), typeof t.resume == "function" && (t.on("error", gb), t.resume());
    return;
  }
  if (typeof t.pipe == "function") {
    mb(t, r, e);
    return;
  }
  if (typeof t.getReader == "function") {
    WR(t, r, e);
    return;
  }
  if (typeof t != "string" && !Buffer.isBuffer(t))
    throw new kR(typeof t);
  if (e[st] === null) {
    const i = e[Ne]["content-length"];
    (!i || n.raw.method !== "HEAD" && Number(i) !== Buffer.byteLength(t)) && (e[Ne]["content-length"] = "" + Buffer.byteLength(t));
  }
  qc(e, s), r.write(t), uo(t, r, e);
}
function Rh(e, t, r) {
  t.code === "ERR_STREAM_PREMATURE_CLOSE" ? e[fb] || e.info({ res: r }, "stream closed prematurely") : e.warn({ err: t }, "response terminated with an error with headers already sent");
}
function WR(e, t, r) {
  if (e.locked)
    throw jR();
  const n = $R.fromWeb(e);
  mb(n, t, r);
}
function mb(e, t, r) {
  let n = !0, s = !1;
  if (KR(e, t, r), su(e, { readable: !0, writable: !1 }, function(i) {
    n = !1, i != null && (t.headersSent || r.request.raw.aborted === !0 ? (s || (s = !0, Rh(r.log, i, r)), t.destroy()) : qs(r, i));
  }), su(t, function(i) {
    n && (i != null && t.headersSent && !s && (s = !0, Rh(r.log, i, t)), typeof e.destroy == "function" ? e.destroy() : typeof e.close == "function" ? e.close(gb) : typeof e.abort == "function" ? e.abort() : r.log.warn("stream payload does not end properly"));
  }), t.headersSent)
    r.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
  else
    for (const i in r[Ne])
      t.setHeader(i, r[Ne][i]);
  e.pipe(t);
}
function uo(e, t, r) {
  if (r[st] === null) {
    t.end(null, null, null);
    return;
  }
  const n = Object.keys(r[st]), s = {};
  let i = 0, o = !0;
  function a() {
    i === 0 && (t.addTrailers(s), t.end(null, null, null));
  }
  for (const c of n) {
    let f = function(d, g) {
      i++, d ? r.log.debug(d) : s[c] = g, process.nextTick(a);
    };
    if (typeof r[st][c] != "function") continue;
    o = !1, i--;
    const l = r[st][c](r, e, f);
    typeof l == "object" && typeof l.then == "function" && l.then((d) => f(null, d), f);
  }
  o && t.end(null, null, null);
}
function KR(e, t, r) {
  r[st] !== null && e.on("end", () => uo(null, t, r));
}
function qs(e, t, r) {
  e[ye].onError !== null && !e[TR] ? (e[of] = !0, db(
    e[ye].onError,
    e.request,
    e,
    t,
    () => xh(e, t, r)
  )) : xh(e, t, r);
}
function JR(e) {
  e[Us] = iu();
  const t = (r) => {
    e[nf] = iu(), e.raw.removeListener("finish", t), e.raw.removeListener("error", t);
    const n = e[ye];
    n && n.onResponse !== null ? PR(
      n.onResponse,
      e.request,
      e,
      $h
    ) : $h(r, e.request, e);
  };
  e.raw.on("finish", t), e.raw.on("error", t);
}
function $h(e, t, r) {
  if (r.log[fb])
    return;
  const n = r.elapsedTime;
  if (e != null) {
    r.log.error({
      res: r,
      err: e,
      responseTime: n
    }, "request errored");
    return;
  }
  r.log.info({
    res: r,
    responseTime: n
  }, "request completed");
}
function YR(e) {
  const t = e.props.slice();
  function r(n, s, i) {
    this.raw = n, this[No] = !1, this[ub] = !1, this[rf] = !1, this[xr] = null, this.request = s, this[Ne] = {}, this[st] = null, this[Us] = void 0, this[nf] = void 0, this.log = i;
    let o;
    for (let a = 0; a < t.length; a++)
      o = t[a], this[o.key] = o.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.parent = e, r.props = t, r;
}
function XR(e) {
  if (e[ye][_h] === null) {
    e.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response."), e.code(404).send("404 Not Found");
    return;
  }
  e.request[ye] = e[ye][_h], e[ye].preHandler !== null ? CR(
    e[ye].preHandler,
    e.request,
    e,
    Eh.preHandlerCallback
  ) : Eh.preHandlerCallback(null, e.request, e);
}
function yb(e, t, r, n) {
  const s = AR(e, r, n);
  return s ? s(t) : JSON.stringify(t);
}
function gb() {
}
oa.exports = Ie;
oa.exports.buildReply = YR;
oa.exports.setupResponseListeners = JR;
var af = oa.exports, cf = { exports: {} }, ts = { exports: {} }, da = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
function lf(e) {
  if (!e)
    throw new TypeError("argument req is required");
  const t = e.headers["x-forwarded-for"], r = e.socket.remoteAddress;
  if (!t || typeof t != "string")
    return [r];
  if (t.indexOf(",") === -1) {
    const n = t.trim();
    return n.length ? [r, n] : [r];
  } else
    return ZR(t, r);
}
function ZR(e, t) {
  const r = [t];
  let n = e.length, s = n, i, o;
  for (o = n - 1; o >= 0; --o)
    i = e[o], i === " " ? s === n && (s = n = o) : i === "," ? (s !== n && r.push(e.slice(s, n)), s = n = o) : s = o;
  return s !== n && r.push(e.substring(s, n)), r;
}
da.exports = lf;
da.exports.default = lf;
da.exports.forwarded = lf;
var QR = da.exports, vb = { exports: {} };
(function(e) {
  (function(t) {
    const r = "(0?\\d+|0x[a-f0-9]+)", n = {
      fourOctet: new RegExp(`^${r}\\.${r}\\.${r}\\.${r}$`, "i"),
      threeOctet: new RegExp(`^${r}\\.${r}\\.${r}$`, "i"),
      twoOctet: new RegExp(`^${r}\\.${r}$`, "i"),
      longValue: new RegExp(`^${r}$`, "i")
    }, s = new RegExp("^0[0-7]+$", "i"), i = new RegExp("^0x[a-f0-9]+$", "i"), o = "%[0-9a-z]{1,}", a = "(?:[0-9a-f]+::?)+", c = {
      zoneIndex: new RegExp(o, "i"),
      native: new RegExp(`^(::)?(${a})?([0-9a-f]+)?(::)?(${o})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${r}\\.${r}\\.${r}\\.${r}(${o})?)$`, "i"),
      transitional: new RegExp(`^((?:${a})|(?:::)(?:${a})?)${r}\\.${r}\\.${r}\\.${r}(${o})?$`, "i")
    };
    function f(u, h) {
      if (u.indexOf("::") !== u.lastIndexOf("::"))
        return null;
      let b = 0, m = -1, v = (u.match(c.zoneIndex) || [])[0], y, _;
      for (v && (v = v.substring(1), u = u.replace(/%.+$/, "")); (m = u.indexOf(":", m + 1)) >= 0; )
        b++;
      if (u.substr(0, 2) === "::" && b--, u.substr(-2, 2) === "::" && b--, b > h)
        return null;
      for (_ = h - b, y = ":"; _--; )
        y += "0:";
      return u = u.replace("::", y), u[0] === ":" && (u = u.slice(1)), u[u.length - 1] === ":" && (u = u.slice(0, -1)), h = function() {
        const R = u.split(":"), E = [];
        for (let O = 0; O < R.length; O++)
          E.push(parseInt(R[O], 16));
        return E;
      }(), {
        parts: h,
        zoneId: v
      };
    }
    function l(u, h, b, m) {
      if (u.length !== h.length)
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      let v = 0, y;
      for (; m > 0; ) {
        if (y = b - m, y < 0 && (y = 0), u[v] >> y !== h[v] >> y)
          return !1;
        m -= b, v += 1;
      }
      return !0;
    }
    function d(u) {
      if (i.test(u))
        return parseInt(u, 16);
      if (u[0] === "0" && !isNaN(parseInt(u[1], 10))) {
        if (s.test(u))
          return parseInt(u, 8);
        throw new Error(`ipaddr: cannot parse ${u} as octal`);
      }
      return parseInt(u, 10);
    }
    function g(u, h) {
      for (; u.length < h; )
        u = `0${u}`;
      return u;
    }
    const p = {};
    p.IPv4 = function() {
      function u(h) {
        if (h.length !== 4)
          throw new Error("ipaddr: ipv4 octet count should be 4");
        let b, m;
        for (b = 0; b < h.length; b++)
          if (m = h[b], !(0 <= m && m <= 255))
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        this.octets = h;
      }
      return u.prototype.SpecialRanges = {
        unspecified: [[new u([0, 0, 0, 0]), 8]],
        broadcast: [[new u([255, 255, 255, 255]), 32]],
        // RFC3171
        multicast: [[new u([224, 0, 0, 0]), 4]],
        // RFC3927
        linkLocal: [[new u([169, 254, 0, 0]), 16]],
        // RFC5735
        loopback: [[new u([127, 0, 0, 0]), 8]],
        // RFC6598
        carrierGradeNat: [[new u([100, 64, 0, 0]), 10]],
        // RFC1918
        private: [
          [new u([10, 0, 0, 0]), 8],
          [new u([172, 16, 0, 0]), 12],
          [new u([192, 168, 0, 0]), 16]
        ],
        // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
        reserved: [
          [new u([192, 0, 0, 0]), 24],
          [new u([192, 0, 2, 0]), 24],
          [new u([192, 88, 99, 0]), 24],
          [new u([198, 18, 0, 0]), 15],
          [new u([198, 51, 100, 0]), 24],
          [new u([203, 0, 113, 0]), 24],
          [new u([240, 0, 0, 0]), 4]
        ],
        // RFC7534, RFC7535
        as112: [
          [new u([192, 175, 48, 0]), 24],
          [new u([192, 31, 196, 0]), 24]
        ],
        // RFC7450
        amt: [
          [new u([192, 52, 193, 0]), 24]
        ]
      }, u.prototype.kind = function() {
        return "ipv4";
      }, u.prototype.match = function(h, b) {
        let m;
        if (b === void 0 && (m = h, h = m[0], b = m[1]), h.kind() !== "ipv4")
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        return l(this.octets, h.octets, 8, b);
      }, u.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, b = !1;
        const m = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let v, y, _;
        for (v = 3; v >= 0; v -= 1)
          if (y = this.octets[v], y in m) {
            if (_ = m[y], b && _ !== 0)
              return null;
            _ !== 8 && (b = !0), h += _;
          } else
            return null;
        return 32 - h;
      }, u.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, u.prototype.toByteArray = function() {
        return this.octets.slice(0);
      }, u.prototype.toIPv4MappedAddress = function() {
        return p.IPv6.parse(`::ffff:${this.toString()}`);
      }, u.prototype.toNormalizedString = function() {
        return this.toString();
      }, u.prototype.toString = function() {
        return this.octets.join(".");
      }, u;
    }(), p.IPv4.broadcastAddressFromCIDR = function(u) {
      try {
        const h = this.parseCIDR(u), b = h[0].toByteArray(), m = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 4; )
          v.push(parseInt(b[y], 10) | parseInt(m[y], 10) ^ 255), y++;
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, p.IPv4.isIPv4 = function(u) {
      return this.parser(u) !== null;
    }, p.IPv4.isValid = function(u) {
      try {
        return new this(this.parser(u)), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidCIDR = function(u) {
      try {
        return this.parseCIDR(u), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidFourPartDecimal = function(u) {
      return !!(p.IPv4.isValid(u) && u.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
    }, p.IPv4.networkAddressFromCIDR = function(u) {
      let h, b, m, v, y;
      try {
        for (h = this.parseCIDR(u), m = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], b = 0; b < 4; )
          v.push(parseInt(m[b], 10) & parseInt(y[b], 10)), b++;
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, p.IPv4.parse = function(u) {
      const h = this.parser(u);
      if (h === null)
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      return new this(h);
    }, p.IPv4.parseCIDR = function(u) {
      let h;
      if (h = u.match(/^(.+)\/(\d+)$/)) {
        const b = parseInt(h[2]);
        if (b >= 0 && b <= 32) {
          const m = [this.parse(h[1]), b];
          return Object.defineProperty(m, "toString", {
            value: function() {
              return this.join("/");
            }
          }), m;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    }, p.IPv4.parser = function(u) {
      let h, b, m;
      if (h = u.match(n.fourOctet))
        return function() {
          const v = h.slice(1, 6), y = [];
          for (let _ = 0; _ < v.length; _++)
            b = v[_], y.push(d(b));
          return y;
        }();
      if (h = u.match(n.longValue)) {
        if (m = d(h[1]), m > 4294967295 || m < 0)
          throw new Error("ipaddr: address outside defined range");
        return function() {
          const v = [];
          let y;
          for (y = 0; y <= 24; y += 8)
            v.push(m >> y & 255);
          return v;
        }().reverse();
      } else return (h = u.match(n.twoOctet)) ? function() {
        const v = h.slice(1, 4), y = [];
        if (m = d(v[1]), m > 16777215 || m < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(d(v[0])), y.push(m >> 16 & 255), y.push(m >> 8 & 255), y.push(m & 255), y;
      }() : (h = u.match(n.threeOctet)) ? function() {
        const v = h.slice(1, 5), y = [];
        if (m = d(v[2]), m > 65535 || m < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(d(v[0])), y.push(d(v[1])), y.push(m >> 8 & 255), y.push(m & 255), y;
      }() : null;
    }, p.IPv4.subnetMaskFromPrefixLength = function(u) {
      if (u = parseInt(u), u < 0 || u > 32)
        throw new Error("ipaddr: invalid IPv4 prefix length");
      const h = [0, 0, 0, 0];
      let b = 0;
      const m = Math.floor(u / 8);
      for (; b < m; )
        h[b] = 255, b++;
      return m < 4 && (h[m] = Math.pow(2, u % 8) - 1 << 8 - u % 8), new this(h);
    }, p.IPv6 = function() {
      function u(h, b) {
        let m, v;
        if (h.length === 16)
          for (this.parts = [], m = 0; m <= 14; m += 2)
            this.parts.push(h[m] << 8 | h[m + 1]);
        else if (h.length === 8)
          this.parts = h;
        else
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        for (m = 0; m < this.parts.length; m++)
          if (v = this.parts[m], !(0 <= v && v <= 65535))
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        b && (this.zoneId = b);
      }
      return u.prototype.SpecialRanges = {
        // RFC4291, here and after
        unspecified: [new u([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new u([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new u([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new u([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new u([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new u([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        // RFC6666
        discard: [new u([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        // RFC6145
        rfc6145: [new u([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        // RFC6052
        rfc6052: [new u([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        // RFC3056
        "6to4": [new u([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        // RFC6052, RFC6146
        teredo: [new u([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        // RFC5180
        benchmarking: [new u([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        // RFC7450
        amt: [new u([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new u([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new u([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new u([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new u([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new u([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          // RFC3849
          [new u([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          // RFC2928
          [new u([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      }, u.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      }, u.prototype.kind = function() {
        return "ipv6";
      }, u.prototype.match = function(h, b) {
        let m;
        if (b === void 0 && (m = h, h = m[0], b = m[1]), h.kind() !== "ipv6")
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        return l(this.parts, h.parts, 16, b);
      }, u.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, b = !1;
        const m = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let v, y;
        for (let _ = 7; _ >= 0; _ -= 1)
          if (v = this.parts[_], v in m) {
            if (y = m[v], b && y !== 0)
              return null;
            y !== 16 && (b = !0), h += y;
          } else
            return null;
        return 128 - h;
      }, u.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, u.prototype.toByteArray = function() {
        let h;
        const b = [], m = this.parts;
        for (let v = 0; v < m.length; v++)
          h = m[v], b.push(h >> 8), b.push(h & 255);
        return b;
      }, u.prototype.toFixedLengthString = function() {
        const h = (function() {
          const m = [];
          for (let v = 0; v < this.parts.length; v++)
            m.push(g(this.parts[v].toString(16), 4));
          return m;
        }).call(this).join(":");
        let b = "";
        return this.zoneId && (b = `%${this.zoneId}`), h + b;
      }, u.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress())
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        const h = this.parts.slice(-2), b = h[0], m = h[1];
        return new p.IPv4([b >> 8, b & 255, m >> 8, m & 255]);
      }, u.prototype.toNormalizedString = function() {
        const h = (function() {
          const m = [];
          for (let v = 0; v < this.parts.length; v++)
            m.push(this.parts[v].toString(16));
          return m;
        }).call(this).join(":");
        let b = "";
        return this.zoneId && (b = `%${this.zoneId}`), h + b;
      }, u.prototype.toRFC5952String = function() {
        const h = /((^|:)(0(:|$)){2,})/g, b = this.toNormalizedString();
        let m = 0, v = -1, y;
        for (; y = h.exec(b); )
          y[0].length > v && (m = y.index, v = y[0].length);
        return v < 0 ? b : `${b.substring(0, m)}::${b.substring(m + v)}`;
      }, u.prototype.toString = function() {
        return this.toRFC5952String();
      }, u;
    }(), p.IPv6.broadcastAddressFromCIDR = function(u) {
      try {
        const h = this.parseCIDR(u), b = h[0].toByteArray(), m = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 16; )
          v.push(parseInt(b[y], 10) | parseInt(m[y], 10) ^ 255), y++;
        return new this(v);
      } catch (h) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${h})`);
      }
    }, p.IPv6.isIPv6 = function(u) {
      return this.parser(u) !== null;
    }, p.IPv6.isValid = function(u) {
      if (typeof u == "string" && u.indexOf(":") === -1)
        return !1;
      try {
        const h = this.parser(u);
        return new this(h.parts, h.zoneId), !0;
      } catch {
        return !1;
      }
    }, p.IPv6.isValidCIDR = function(u) {
      if (typeof u == "string" && u.indexOf(":") === -1)
        return !1;
      try {
        return this.parseCIDR(u), !0;
      } catch {
        return !1;
      }
    }, p.IPv6.networkAddressFromCIDR = function(u) {
      let h, b, m, v, y;
      try {
        for (h = this.parseCIDR(u), m = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], b = 0; b < 16; )
          v.push(parseInt(m[b], 10) & parseInt(y[b], 10)), b++;
        return new this(v);
      } catch (_) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${_})`);
      }
    }, p.IPv6.parse = function(u) {
      const h = this.parser(u);
      if (h.parts === null)
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      return new this(h.parts, h.zoneId);
    }, p.IPv6.parseCIDR = function(u) {
      let h, b, m;
      if ((b = u.match(/^(.+)\/(\d+)$/)) && (h = parseInt(b[2]), h >= 0 && h <= 128))
        return m = [this.parse(b[1]), h], Object.defineProperty(m, "toString", {
          value: function() {
            return this.join("/");
          }
        }), m;
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    }, p.IPv6.parser = function(u) {
      let h, b, m, v, y, _;
      if (m = u.match(c.deprecatedTransitional))
        return this.parser(`::ffff:${m[1]}`);
      if (c.native.test(u))
        return f(u, 8);
      if ((m = u.match(c.transitional)) && (_ = m[6] || "", h = m[1], m[1].endsWith("::") || (h = h.slice(0, -1)), h = f(h + _, 6), h.parts)) {
        for (y = [
          parseInt(m[2]),
          parseInt(m[3]),
          parseInt(m[4]),
          parseInt(m[5])
        ], b = 0; b < y.length; b++)
          if (v = y[b], !(0 <= v && v <= 255))
            return null;
        return h.parts.push(y[0] << 8 | y[1]), h.parts.push(y[2] << 8 | y[3]), {
          parts: h.parts,
          zoneId: h.zoneId
        };
      }
      return null;
    }, p.IPv6.subnetMaskFromPrefixLength = function(u) {
      if (u = parseInt(u), u < 0 || u > 128)
        throw new Error("ipaddr: invalid IPv6 prefix length");
      const h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let b = 0;
      const m = Math.floor(u / 8);
      for (; b < m; )
        h[b] = 255, b++;
      return m < 16 && (h[m] = Math.pow(2, u % 8) - 1 << 8 - u % 8), new this(h);
    }, p.fromByteArray = function(u) {
      const h = u.length;
      if (h === 4)
        return new p.IPv4(u);
      if (h === 16)
        return new p.IPv6(u);
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }, p.isValid = function(u) {
      return p.IPv6.isValid(u) || p.IPv4.isValid(u);
    }, p.isValidCIDR = function(u) {
      return p.IPv6.isValidCIDR(u) || p.IPv4.isValidCIDR(u);
    }, p.parse = function(u) {
      if (p.IPv6.isValid(u))
        return p.IPv6.parse(u);
      if (p.IPv4.isValid(u))
        return p.IPv4.parse(u);
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }, p.parseCIDR = function(u) {
      try {
        return p.IPv6.parseCIDR(u);
      } catch {
        try {
          return p.IPv4.parseCIDR(u);
        } catch {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    }, p.process = function(u) {
      const h = this.parse(u);
      return h.kind() === "ipv6" && h.isIPv4MappedAddress() ? h.toIPv4Address() : h;
    }, p.subnetMatch = function(u, h, b) {
      let m, v, y, _;
      b == null && (b = "unicast");
      for (v in h)
        if (Object.prototype.hasOwnProperty.call(h, v)) {
          for (y = h[v], y[0] && !(y[0] instanceof Array) && (y = [y]), m = 0; m < y.length; m++)
            if (_ = y[m], u.kind() === _[0].kind() && u.match.apply(u, _))
              return v;
        }
      return b;
    }, e.exports ? e.exports = p : t.ipaddr = p;
  })(be);
})(vb);
var e$ = vb.exports;
/*!
 * proxy-addr
 * Copyright(c) 2021 Fastify collaborators
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
ts.exports = uf;
ts.exports.default = uf;
ts.exports.proxyaddr = uf;
ts.exports.all = _b;
ts.exports.compile = Eb;
const t$ = QR, bb = e$, r$ = /^\d+$/u, ko = bb.isValid, pa = bb.parse, Th = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function _b(e, t) {
  const r = t$(e);
  if (!t)
    return r;
  typeof t != "function" && (t = Eb(t));
  for (var n = 0; n < r.length - 1; n++)
    t(r[n], n) || (r.length = n + 1);
  return r;
}
function Eb(e) {
  if (!e)
    throw new TypeError("argument is required");
  let t;
  if (typeof e == "string")
    t = [e];
  else if (Array.isArray(e))
    t = e.slice();
  else
    throw new TypeError("unsupported trust argument");
  for (var r = 0; r < t.length; r++)
    e = t[r], Object.prototype.hasOwnProperty.call(Th, e) && (e = Th[e], t.splice.apply(t, [r, 1].concat(e)), r += e.length - 1);
  return s$(n$(t));
}
function n$(e) {
  const t = new Array(e.length);
  for (var r = 0; r < e.length; r++)
    t[r] = i$(e[r]);
  return t;
}
function s$(e) {
  const t = e.length;
  return t === 0 ? a$ : t === 1 ? l$(e[0]) : c$(e);
}
function i$(e) {
  const t = e.lastIndexOf("/"), r = t !== -1 ? e.substring(0, t) : e;
  if (!ko(r))
    throw new TypeError("invalid IP address: " + r);
  let n = pa(r);
  t === -1 && n.kind() === "ipv6" && n.isIPv4MappedAddress() && (n = n.toIPv4Address());
  const s = n.kind() === "ipv6" ? 128 : 32;
  let i = t !== -1 ? e.substring(t + 1, e.length) : null;
  if (i === null ? i = s : r$.test(i) ? i = parseInt(i, 10) : n.kind() === "ipv4" && ko(i) ? i = o$(i) : i = null, i <= 0 || i > s)
    throw new TypeError("invalid range on address: " + e);
  return [n, i];
}
function o$(e) {
  const t = pa(e);
  return t.kind() === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
}
function uf(e, t) {
  if (!e)
    throw new TypeError("req argument is required");
  if (!t)
    throw new TypeError("trust argument is required");
  const r = _b(e, t);
  return r[r.length - 1];
}
function a$() {
  return !1;
}
function c$(e) {
  return function(r) {
    if (!ko(r)) return !1;
    const n = pa(r);
    let s;
    const i = n.kind();
    for (var o = 0; o < e.length; o++) {
      const a = e[o], c = a[0], f = c.kind(), l = a[1];
      let d = n;
      if (i !== f) {
        if (f === "ipv4" && !n.isIPv4MappedAddress())
          continue;
        s || (s = f === "ipv4" ? n.toIPv4Address() : n.toIPv4MappedAddress()), d = s;
      }
      if (d.match(c, l))
        return !0;
    }
    return !1;
  };
}
function l$(e) {
  const t = e[0], r = t.kind(), n = r === "ipv4", s = e[1];
  return function(o) {
    if (!ko(o)) return !1;
    let a = pa(o);
    if (a.kind() !== r) {
      if (n && !a.isIPv4MappedAddress())
        return !1;
      a = n ? a.toIPv4Address() : a.toIPv4MappedAddress();
    }
    return a.match(t, s);
  };
}
var u$ = ts.exports;
const Lo = u$, {
  kHasBeenDecorated: f$,
  kSchemaBody: d$,
  kSchemaHeaders: p$,
  kSchemaParams: h$,
  kSchemaQuerystring: Oh,
  kSchemaController: Hc,
  kOptions: m$,
  kRequestCacheValidateFns: Pr,
  kRouteContext: yt,
  kRequestOriginalUrl: Bc
} = pt, { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: y$ } = bt, Ph = {
  body: d$,
  headers: p$,
  params: h$,
  querystring: Oh,
  query: Oh
};
function ff(e, t, r, n, s, i) {
  this.id = e, this[yt] = i, this.params = t, this.raw = r, this.query = n, this.log = s, this.body = void 0;
}
ff.props = [];
function g$(e) {
  if (typeof e == "function")
    return e;
  if (e === !0)
    return null;
  if (typeof e == "number")
    return function(t, r) {
      return r < e;
    };
  if (typeof e == "string") {
    const t = e.split(",").map((r) => r.trim());
    return Lo.compile(t);
  }
  return Lo.compile(e);
}
function v$(e, t) {
  return t ? b$(e, t) : xb(e);
}
function xb(e) {
  const t = e.props.slice();
  function r(n, s, i, o, a, c) {
    this.id = n, this[yt] = c, this.params = s, this.raw = i, this.query = o, this.log = a, this.body = void 0;
    let f;
    for (let l = 0; l < t.length; l++)
      f = t[l], this[f.key] = f.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.props = t, r.parent = e, r;
}
function Ch(e) {
  const t = e.lastIndexOf(",");
  return t === -1 ? e.trim() : e.slice(t + 1).trim();
}
function b$(e, t) {
  const r = xb(e), n = g$(t);
  return r[f$] = !0, Object.defineProperties(r.prototype, {
    ip: {
      get() {
        const s = Lo.all(this.raw, n);
        return s[s.length - 1];
      }
    },
    ips: {
      get() {
        return Lo.all(this.raw, n);
      }
    },
    host: {
      get() {
        return this.ip !== void 0 && this.headers["x-forwarded-host"] ? Ch(this.headers["x-forwarded-host"]) : this.headers.host ?? this.headers[":authority"] ?? "";
      }
    },
    protocol: {
      get() {
        if (this.headers["x-forwarded-proto"])
          return Ch(this.headers["x-forwarded-proto"]);
        if (this.socket)
          return this.socket.encrypted ? "https" : "http";
      }
    }
  }), r;
}
Object.defineProperties(ff.prototype, {
  server: {
    get() {
      return this[yt].server;
    }
  },
  url: {
    get() {
      return this.raw.url;
    }
  },
  originalUrl: {
    get() {
      return this[Bc] || (this[Bc] = this.raw.originalUrl || this.raw.url), this[Bc];
    }
  },
  method: {
    get() {
      return this.raw.method;
    }
  },
  routeOptions: {
    get() {
      var i, o;
      const e = this[yt], t = e._parserOptions.limit, r = e.server.initialConfig.bodyLimit, n = e.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0, s = {
        method: (i = e.config) == null ? void 0 : i.method,
        url: (o = e.config) == null ? void 0 : o.url,
        bodyLimit: t || r,
        attachValidation: e.attachValidation,
        logLevel: e.logLevel,
        exposeHeadRoute: e.exposeHeadRoute,
        prefixTrailingSlash: e.prefixTrailingSlash,
        handler: e.handler,
        version: n
      };
      return Object.defineProperties(s, {
        config: {
          get: () => e.config
        },
        schema: {
          get: () => e.schema
        }
      }), Object.freeze(s);
    }
  },
  is404: {
    get() {
      var e;
      return ((e = this[yt].config) == null ? void 0 : e.url) === void 0;
    }
  },
  socket: {
    get() {
      return this.raw.socket;
    }
  },
  ip: {
    get() {
      if (this.socket)
        return this.socket.remoteAddress;
    }
  },
  host: {
    get() {
      return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
    }
  },
  hostname: {
    get() {
      return this.host.split(":", 1)[0];
    }
  },
  port: {
    get() {
      const e = parseInt(this.host.split(":").slice(-1)[0]);
      if (!isNaN(e))
        return e;
      const t = this.headers.host ?? this.headers[":authority"] ?? "", r = parseInt(t.split(":").slice(-1)[0]);
      return isNaN(r) ? null : r;
    }
  },
  protocol: {
    get() {
      if (this.socket)
        return this.socket.encrypted ? "https" : "http";
    }
  },
  headers: {
    get() {
      return this.additionalHeaders ? Object.assign({}, this.raw.headers, this.additionalHeaders) : this.raw.headers;
    },
    set(e) {
      this.additionalHeaders = e;
    }
  },
  getValidationFunction: {
    value: function(e) {
      var t;
      if (typeof e == "string") {
        const r = Ph[e];
        return this[yt][r];
      } else if (typeof e == "object")
        return (t = this[yt][Pr]) == null ? void 0 : t.get(e);
    }
  },
  compileValidationSchema: {
    value: function(e, t = null) {
      var o;
      const { method: r, url: n } = this;
      if ((o = this[yt][Pr]) != null && o.has(e))
        return this[yt][Pr].get(e);
      const i = (this[yt].validatorCompiler || this.server[Hc].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
      // nor set
      this.server[Hc].setupValidator(this.server[m$]) || this.server[Hc].validatorCompiler)({
        schema: e,
        method: r,
        url: n,
        httpPart: t
      });
      return this[yt][Pr] == null && (this[yt][Pr] = /* @__PURE__ */ new WeakMap()), this[yt][Pr].set(e, i), i;
    }
  },
  validateInput: {
    value: function(e, t, r) {
      var i;
      r = typeof t == "string" ? t : r;
      const n = r != null && typeof r == "string" && Ph[r];
      let s;
      if (n && (s = this[yt][n]), s == null && (t == null || typeof t != "object" || Array.isArray(t)))
        throw new y$(r);
      return s == null && ((i = this[yt][Pr]) != null && i.has(t) ? s = this[yt][Pr].get(t) : s = this.compileValidationSchema(t, r)), s(e);
    }
  }
});
cf.exports = ff;
cf.exports.buildRequest = v$;
var df = cf.exports;
const {
  kFourOhFourContext: _$,
  kReplySerializerDefault: E$,
  kSchemaErrorFormatter: x$,
  kErrorHandler: S$,
  kChildLoggerFactory: w$,
  kOptions: R$,
  kReply: $$,
  kRequest: T$,
  kBodyLimit: O$,
  kLogLevel: P$,
  kContentTypeParser: C$,
  kRouteByFastify: I$,
  kRequestCacheValidateFns: N$,
  kReplyCacheSerializeFns: A$
} = pt;
function k$({
  schema: e,
  handler: t,
  config: r,
  requestIdLogLabel: n,
  childLoggerFactory: s,
  errorHandler: i,
  bodyLimit: o,
  logLevel: a,
  logSerializers: c,
  attachValidation: f,
  validatorCompiler: l,
  serializerCompiler: d,
  replySerializer: g,
  schemaErrorFormatter: p,
  exposeHeadRoute: u,
  prefixTrailingSlash: h,
  server: b,
  isFastify: m
}) {
  this.schema = e, this.handler = t, this.Reply = b[$$], this.Request = b[T$], this.contentTypeParser = b[C$], this.onRequest = null, this.onSend = null, this.onError = null, this.onTimeout = null, this.preHandler = null, this.onResponse = null, this.preSerialization = null, this.onRequestAbort = null, this.config = r, this.errorHandler = i || b[S$], this.requestIdLogLabel = n || b[R$].requestIdLogLabel, this.childLoggerFactory = s || b[w$], this._middie = null, this._parserOptions = {
    limit: o || b[O$]
  }, this.exposeHeadRoute = u, this.prefixTrailingSlash = h, this.logLevel = a || b[P$], this.logSerializers = c, this[_$] = null, this.attachValidation = f, this[E$] = g, this.schemaErrorFormatter = p || b[x$] || L$, this[I$] = m, this[N$] = null, this[A$] = null, this.validatorCompiler = l || null, this.serializerCompiler = d || null, this.server = b;
}
function L$(e, t) {
  let r = "";
  const n = ", ";
  for (let s = 0; s !== e.length; ++s) {
    const i = e[s];
    r += t + (i.instancePath || "") + " " + i.message + n;
  }
  return new Error(r.slice(0, -n.length));
}
var pf = k$;
const {
  kReply: ou,
  kRequest: au,
  kState: j$,
  kHasBeenDecorated: D$
} = pt, {
  FST_ERR_DEC_ALREADY_PRESENT: Sb,
  FST_ERR_DEC_MISSING_DEPENDENCY: F$,
  FST_ERR_DEC_AFTER_START: M$,
  FST_ERR_DEC_REFERENCE_TYPE: z$,
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: U$
} = bt;
function q$(e, t, r, n) {
  if (Object.hasOwn(e, t))
    throw new Sb(t);
  $b(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(e, t, {
    get: r.getter,
    set: r.setter
  }) : e[t] = r;
}
function wb(e, t, r, n) {
  const s = e.prototype;
  if (Object.hasOwn(s, t) || ma(e, t))
    throw new Sb(t);
  e[D$] = !0, $b(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(s, t, {
    get: r.getter,
    set: r.setter
  }) : typeof r == "function" ? s[t] = r : e.props.push({ key: t, value: r });
}
function Rb(e, t) {
  if (typeof t == "object" && t && !(typeof t.getter == "function" || typeof t.setter == "function"))
    throw new z$(e, typeof t);
}
function H$(e, t, r) {
  return hf(this, e), q$(this, e, t, r), this;
}
function ha(e, t) {
  return t ? t in e || e.prototype && t in e.prototype || ma(e, t) : e in this;
}
function ma(e, t) {
  return e.props ? e.props.find(({ key: r }) => r === t) : !1;
}
function B$(e) {
  return e && ma(this[au], e) ? !0 : ha(this[au].prototype, e);
}
function V$(e) {
  return e && ma(this[ou], e) ? !0 : ha(this[ou].prototype, e);
}
function $b(e, t, r) {
  if (r != null) {
    if (!Array.isArray(r))
      throw new U$(t);
    for (let n = 0; n !== r.length; ++n)
      if (!ha(e, r[n]))
        throw new F$(r[n]);
  }
}
function G$(e, t, r) {
  return hf(this, e), Rb(e, t), wb(this[ou], e, t, r), this;
}
function W$(e, t, r) {
  return hf(this, e), Rb(e, t), wb(this[au], e, t, r), this;
}
function hf(e, t) {
  if (e[j$].started)
    throw new M$(t);
}
var Tb = {
  add: H$,
  exist: ha,
  existRequest: B$,
  existReply: V$,
  decorateReply: G$,
  decorateRequest: W$
}, Ob = { exports: {} }, hr = {};
/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */
class K$ {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ new Map(), this.last = null, this.max = t, this.ttl = r;
  }
  get size() {
    return this.items.size;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map(), this.first = null, this.last = null;
  }
  delete(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      this.items.delete(t), r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      this.items.delete(t.key), this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (this.items.has(t))
      return this.items.get(t).expiry;
  }
  get(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return this.items.keys();
  }
  set(t, r) {
    if (this.items.has(t)) {
      const s = this.items.get(t);
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items.set(t, n), this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
class J$ {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ new Map(), this.last = null, this.max = t, this.ttl = r;
  }
  get size() {
    return this.items.size;
  }
  bumpLru(t) {
    if (this.last === t)
      return;
    const r = this.last, n = t.next, s = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, s !== null && (s.next = n), n !== null && (n.prev = s), this.last = t;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map(), this.first = null, this.last = null;
  }
  delete(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      this.items.delete(t), r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      this.items.delete(t.key), this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (this.items.has(t))
      return this.items.get(t).expiry;
  }
  get(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.bumpLru(r), r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return this.items.keys();
  }
  set(t, r) {
    if (this.items.has(t)) {
      const s = this.items.get(t);
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== s && this.bumpLru(s);
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items.set(t, n), this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
class mf {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this.max = t, this.ttl = r;
  }
  bumpLru(t) {
    if (this.last === t)
      return;
    const r = this.last, n = t.next, s = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, s !== null && (s.next = n), n !== null && (n.prev = s), this.last = t;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null), this.first = null, this.last = null, this.size = 0;
  }
  delete(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      delete this.items[t], this.size--, r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t))
      return this.items[t].expiry;
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.bumpLru(r), r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(t, r) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const s = this.items[t];
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== s && this.bumpLru(s);
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items[t] = n, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
class Pb {
  constructor() {
    this.records = {};
  }
  initForCache(t, r) {
    this.records[t] = {
      [r]: {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      }
    };
  }
  resetForCache(t) {
    for (let r of Object.keys(this.records[t]))
      this.records[t][r] = {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      };
  }
  getStatistics() {
    return this.records;
  }
}
function Ih(e) {
  return `${e.getFullYear()}-${(e.getMonth() + 1).toString().padStart(2, "0")}-${e.getDate().toString().padStart(2, "0")}`;
}
class Y$ {
  constructor(t, r, n) {
    this.cacheId = t, this.statisticTtlInHours = r, this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = Ih(this.collectionStart), this.records = n || new Pb(), this.records.initForCache(this.cacheId, this.currentTimeStamp);
  }
  get currentRecord() {
    return this.records.records[this.cacheId][this.currentTimeStamp] || (this.records.records[this.cacheId][this.currentTimeStamp] = {
      cacheSize: 0,
      hits: 0,
      falsyHits: 0,
      emptyHits: 0,
      misses: 0,
      expirations: 0,
      evictions: 0,
      sets: 0,
      invalidateOne: 0,
      invalidateAll: 0
    }), this.records.records[this.cacheId][this.currentTimeStamp];
  }
  hoursPassed() {
    return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
  }
  addHit() {
    this.archiveIfNeeded(), this.currentRecord.hits++;
  }
  addFalsyHit() {
    this.archiveIfNeeded(), this.currentRecord.falsyHits++;
  }
  addEmptyHit() {
    this.archiveIfNeeded(), this.currentRecord.emptyHits++;
  }
  addMiss() {
    this.archiveIfNeeded(), this.currentRecord.misses++;
  }
  addEviction() {
    this.archiveIfNeeded(), this.currentRecord.evictions++;
  }
  setCacheSize(t) {
    this.archiveIfNeeded(), this.currentRecord.cacheSize = t;
  }
  addExpiration() {
    this.archiveIfNeeded(), this.currentRecord.expirations++;
  }
  addSet() {
    this.archiveIfNeeded(), this.currentRecord.sets++;
  }
  addInvalidateOne() {
    this.archiveIfNeeded(), this.currentRecord.invalidateOne++;
  }
  addInvalidateAll() {
    this.archiveIfNeeded(), this.currentRecord.invalidateAll++;
  }
  getStatistics() {
    return this.records.getStatistics();
  }
  archiveIfNeeded() {
    this.hoursPassed() >= this.statisticTtlInHours && (this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = Ih(this.collectionStart), this.records.initForCache(this.cacheId, this.currentTimeStamp));
  }
}
class Cb extends mf {
  constructor(t, r, n, s, i) {
    if (super(t || 1e3, r || 0), !n)
      throw new Error("Cache id is mandatory");
    this.hitStatistics = new Y$(
      n,
      i !== void 0 ? i : 24,
      s
    );
  }
  getStatistics() {
    return this.hitStatistics.getStatistics();
  }
  set(t, r) {
    super.set(t, r), this.hitStatistics.addSet(), this.hitStatistics.setCacheSize(this.size);
  }
  evict() {
    super.evict(), this.hitStatistics.addEviction(), this.hitStatistics.setCacheSize(this.size);
  }
  delete(t, r = !1) {
    super.delete(t), r || this.hitStatistics.addInvalidateOne(), this.hitStatistics.setCacheSize(this.size);
  }
  clear() {
    super.clear(), this.hitStatistics.addInvalidateAll(), this.hitStatistics.setCacheSize(this.size);
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t, !0), this.hitStatistics.addExpiration();
        return;
      }
      return this.bumpLru(r), r.value || this.hitStatistics.addFalsyHit(), (r.value === void 0 || r.value === null || r.value === "") && this.hitStatistics.addEmptyHit(), this.hitStatistics.addHit(), r.value;
    }
    this.hitStatistics.addMiss();
  }
}
class Ib {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this.max = t, this.ttl = r;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null), this.first = null, this.last = null, this.size = 0;
  }
  delete(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      delete this.items[t], this.size--, r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t))
      return this.items[t].expiry;
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(t, r) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const s = this.items[t];
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items[t] = n, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
hr.Fifo = Ib;
hr.FifoMap = K$;
hr.FifoObject = Ib;
hr.HitStatisticsRecord = Pb;
hr.Lru = mf;
hr.LruHitStatistics = Cb;
hr.LruMap = J$;
hr.LruObject = mf;
hr.LruObjectHitStatistics = Cb;
var rs = { exports: {} };
const X$ = typeof Buffer < "u", Nh = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, Ah = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function Nb(e, t, r) {
  r == null && t !== null && typeof t == "object" && (r = t, t = void 0), X$ && Buffer.isBuffer(e) && (e = e.toString()), e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
  const n = JSON.parse(e, t);
  if (n === null || typeof n != "object")
    return n;
  const s = r && r.protoAction || "error", i = r && r.constructorAction || "error";
  if (s === "ignore" && i === "ignore")
    return n;
  if (s !== "ignore" && i !== "ignore") {
    if (Nh.test(e) === !1 && Ah.test(e) === !1)
      return n;
  } else if (s !== "ignore" && i === "ignore") {
    if (Nh.test(e) === !1)
      return n;
  } else if (Ah.test(e) === !1)
    return n;
  return Ab(n, { protoAction: s, constructorAction: i, safe: r && r.safe });
}
function Ab(e, { protoAction: t = "error", constructorAction: r = "error", safe: n } = {}) {
  let s = [e];
  for (; s.length; ) {
    const i = s;
    s = [];
    for (const o of i) {
      if (t !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
        if (n === !0)
          return null;
        if (t === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.__proto__;
      }
      if (r !== "ignore" && Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype")) {
        if (n === !0)
          return null;
        if (r === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.constructor;
      }
      for (const a in o) {
        const c = o[a];
        c && typeof c == "object" && s.push(c);
      }
    }
  }
  return e;
}
function yf(e, t, r) {
  const { stackTraceLimit: n } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Nb(e, t, r);
  } finally {
    Error.stackTraceLimit = n;
  }
}
function Z$(e, t) {
  const { stackTraceLimit: r } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Nb(e, t, { safe: !0 });
  } catch {
    return null;
  } finally {
    Error.stackTraceLimit = r;
  }
}
rs.exports = yf;
rs.exports.default = yf;
rs.exports.parse = yf;
rs.exports.safeParse = Z$;
rs.exports.scan = Ab;
var Q$ = rs.exports;
(function(e) {
  const { AsyncResource: t } = Ex, { FifoMap: r } = hr, { parse: n } = Q$, {
    kDefaultJsonParse: s,
    kContentTypeParser: i,
    kBodyLimit: o,
    kRequestPayloadStream: a,
    kState: c,
    kTestInternals: f,
    kReplyIsError: l,
    kRouteContext: d
  } = pt, {
    FST_ERR_CTP_INVALID_TYPE: g,
    FST_ERR_CTP_EMPTY_TYPE: p,
    FST_ERR_CTP_ALREADY_PRESENT: u,
    FST_ERR_CTP_INVALID_HANDLER: h,
    FST_ERR_CTP_INVALID_PARSE_TYPE: b,
    FST_ERR_CTP_BODY_TOO_LARGE: m,
    FST_ERR_CTP_INVALID_MEDIA_TYPE: v,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: y,
    FST_ERR_CTP_EMPTY_JSON_BODY: _,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: R
  } = bt, { FSTSEC001: E } = Yu;
  function O(P, A, k) {
    this[s] = x(A, k), this.customParsers = /* @__PURE__ */ new Map(), this.customParsers.set("application/json", new M(!0, !1, P, this[s])), this.customParsers.set("text/plain", new M(!0, !1, P, L)), this.parserList = ["application/json", "text/plain"], this.parserRegExpList = [], this.cache = new r(100);
  }
  O.prototype.add = function(P, A, k) {
    const C = typeof P == "string";
    if (C) {
      if (P = P.trim().toLowerCase(), P.length === 0) throw new p();
    } else if (!(P instanceof RegExp))
      throw new g();
    if (typeof k != "function")
      throw new h();
    if (this.existingParser(P))
      throw new u(P);
    if (A.parseAs !== void 0 && A.parseAs !== "string" && A.parseAs !== "buffer")
      throw new b(A.parseAs);
    const D = new M(
      A.parseAs === "string",
      A.parseAs === "buffer",
      A.bodyLimit,
      k
    );
    P === "*" ? this.customParsers.set("", D) : C ? (this.parserList.unshift(P), this.customParsers.set(P, D)) : (j(P), this.parserRegExpList.unshift(P), this.customParsers.set(P.toString(), D));
  }, O.prototype.hasParser = function(P) {
    if (typeof P == "string")
      P = P.trim().toLowerCase();
    else {
      if (!(P instanceof RegExp)) throw new g();
      P = P.toString();
    }
    return this.customParsers.has(P);
  }, O.prototype.existingParser = function(P) {
    return P === "application/json" && this.customParsers.has(P) ? this.customParsers.get(P).fn !== this[s] : P === "text/plain" && this.customParsers.has(P) ? this.customParsers.get(P).fn !== L : this.hasParser(P);
  }, O.prototype.getParser = function(P) {
    let A = this.customParsers.get(P);
    if (A !== void 0 || (A = this.cache.get(P), A !== void 0)) return A;
    const k = P.toLowerCase();
    for (let C = 0; C !== this.parserList.length; ++C) {
      const D = this.parserList[C];
      if (k.slice(0, D.length) === D && (k.length === D.length || k.charCodeAt(D.length) === 59 || k.charCodeAt(D.length) === 32))
        return A = this.customParsers.get(D), this.cache.set(P, A), A;
    }
    for (let C = 0; C !== this.parserRegExpList.length; ++C) {
      const D = this.parserRegExpList[C];
      if (D.test(P))
        return A = this.customParsers.get(D.toString()), this.cache.set(P, A), A;
    }
    return this.customParsers.get("");
  }, O.prototype.removeAll = function() {
    this.customParsers = /* @__PURE__ */ new Map(), this.parserRegExpList = [], this.parserList = [], this.cache = new r(100);
  }, O.prototype.remove = function(P) {
    let A;
    if (typeof P == "string")
      P = P.trim().toLowerCase(), A = this.parserList;
    else {
      if (!(P instanceof RegExp)) throw new g();
      P = P.toString(), A = this.parserRegExpList;
    }
    const k = this.customParsers.delete(P), C = A.findIndex((D) => D.toString() === P);
    return C > -1 && A.splice(C, 1), k || C > -1;
  }, O.prototype.run = function(P, A, k, C) {
    const D = this.getParser(P);
    if (D === void 0) {
      k.is404 ? A(k, C) : C.send(new v(P || void 0));
      return;
    }
    const F = new t("content-type-parser:run", k);
    if (D.asString === !0 || D.asBuffer === !0)
      z(
        k,
        C,
        C[d]._parserOptions,
        D,
        w
      );
    else {
      const N = D.fn(k, k[a], w);
      N && typeof N.then == "function" && N.then((q) => w(null, q), w);
    }
    function w(N, q) {
      F.runInAsyncScope(() => {
        F.emitDestroy(), N ? (C[l] = !0, C.send(N)) : (k.body = q, A(k, C));
      });
    }
  };
  function z(P, A, k, C, D) {
    const F = C.asString, w = k.limit === null ? C.bodyLimit : k.limit, N = Number(P.headers["content-length"]);
    if (N > w) {
      A.header("connection", "close"), A.send(new m());
      return;
    }
    let q = 0, K = F === !0 ? "" : [];
    const V = P[a] || P.raw;
    F === !0 && V.setEncoding("utf8"), V.on("data", Z), V.on("end", Y), V.on("error", Y), V.resume();
    function Z(J) {
      q += J.length;
      const { receivedEncodedLength: H = 0 } = V;
      if (q > w || H > w) {
        V.removeListener("data", Z), V.removeListener("end", Y), V.removeListener("error", Y), A.send(new m());
        return;
      }
      F === !0 ? K += J : K.push(J);
    }
    function Y(J) {
      if (V.removeListener("data", Z), V.removeListener("end", Y), V.removeListener("error", Y), J !== void 0) {
        typeof J.statusCode == "number" && J.statusCode >= 400 || (J.statusCode = 400), A[l] = !0, A.code(J.statusCode).send(J);
        return;
      }
      if (F === !0 && (q = Buffer.byteLength(K)), !Number.isNaN(N) && (V.receivedEncodedLength || q) !== N) {
        A.header("connection", "close"), A.send(new y());
        return;
      }
      F === !1 && (K = Buffer.concat(K));
      const H = C.fn(P, K, D);
      H && typeof H.then == "function" && H.then((W) => D(null, W), D);
    }
  }
  function x(P, A) {
    return k;
    function k(C, D, F) {
      if (D.length === 0) {
        F(new _(), void 0);
        return;
      }
      try {
        F(null, n(D, { protoAction: P, constructorAction: A }));
      } catch (w) {
        w.statusCode = 400, F(w, void 0);
      }
    }
  }
  function L(P, A, k) {
    k(null, A);
  }
  function M(P, A, k, C) {
    this.asString = P, this.asBuffer = A, this.bodyLimit = k, this.fn = C;
  }
  function U(P) {
    const A = new O();
    return A[s] = P[s], A.customParsers = new Map(P.customParsers.entries()), A.parserList = P.parserList.slice(), A.parserRegExpList = P.parserRegExpList.slice(), A;
  }
  function $(P, A, k) {
    if (this[c].started)
      throw new R("addContentTypeParser");
    return typeof A == "function" && (k = A, A = {}), A || (A = {}), A.bodyLimit || (A.bodyLimit = this[o]), Array.isArray(P) ? P.forEach((C) => this[i].add(C, A, k)) : this[i].add(P, A, k), this;
  }
  function S(P) {
    return this[i].hasParser(P);
  }
  function I(P) {
    if (this[c].started)
      throw new R("removeContentTypeParser");
    if (Array.isArray(P))
      for (const A of P)
        this[i].remove(A);
    else
      this[i].remove(P);
  }
  function T() {
    if (this[c].started)
      throw new R("removeAllContentTypeParsers");
    this[i].removeAll();
  }
  function j(P) {
    P.source[0] !== "^" && P.source.includes(";?") === !1 && E(P.source);
  }
  e.exports = O, e.exports.helpers = {
    buildContentTypeParser: U,
    addContentTypeParser: $,
    hasContentTypeParser: S,
    removeContentTypeParser: I,
    removeAllContentTypeParsers: T
  }, e.exports.defaultParsers = {
    getDefaultJsonParser: x,
    defaultTextParser: L
  }, e.exports[f] = { rawBody: z };
})(Ob);
var kb = Ob.exports, fi = { exports: {} }, ya = {}, ns = { exports: {} }, ga = {}, kh = Object.prototype.hasOwnProperty;
function Lh(e, t, r) {
  for (r of e.keys())
    if (ks(r, t)) return r;
}
function ks(e, t) {
  var r, n, s;
  if (e === t) return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date) return e.getTime() === t.getTime();
    if (r === RegExp) return e.toString() === t.toString();
    if (r === Array) {
      if ((n = e.length) === t.length)
        for (; n-- && ks(e[n], t[n]); ) ;
      return n === -1;
    }
    if (r === Set) {
      if (e.size !== t.size)
        return !1;
      for (n of e)
        if (s = n, s && typeof s == "object" && (s = Lh(t, s), !s) || !t.has(s)) return !1;
      return !0;
    }
    if (r === Map) {
      if (e.size !== t.size)
        return !1;
      for (n of e)
        if (s = n[0], s && typeof s == "object" && (s = Lh(t, s), !s) || !ks(n[1], t.get(s)))
          return !1;
      return !0;
    }
    if (r === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (r === DataView) {
      if ((n = e.byteLength) === t.byteLength)
        for (; n-- && e.getInt8(n) === t.getInt8(n); ) ;
      return n === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((n = e.byteLength) === t.byteLength)
        for (; n-- && e[n] === t[n]; ) ;
      return n === -1;
    }
    if (!r || typeof e == "object") {
      n = 0;
      for (r in e)
        if (kh.call(e, r) && ++n && !kh.call(t, r) || !(r in t) || !ks(e[r], t[r])) return !1;
      return Object.keys(t).length === n;
    }
  }
  return e !== e && t !== t;
}
ga.dequal = ks;
const { dequal: jh } = ga, e1 = Symbol.for("json-schema-ref");
var At, Kt, Qs, ei, ti, Ue, cu, fo, lu, uu, Lb, fu, jb, pv;
let t1 = (pv = class {
  constructor(t = {}) {
    Vr(this, Ue);
    Vr(this, At);
    Vr(this, Kt);
    Vr(this, Qs);
    Vr(this, ei);
    Vr(this, ti);
    wn(this, At, {}), wn(this, Kt, {}), wn(this, Qs, t.insertRefSymbol ?? !1), wn(this, ei, t.allowEqualDuplicates ?? !0), wn(this, ti, t.cloneSchemaWithoutRefs ?? !1);
  }
  addSchema(t, r, n = !0) {
    n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : wt(this, Ue, uu).call(this, t, r));
    const s = t.$id;
    s !== void 0 && typeof s == "string" && (s.charAt(0) === "#" ? wt(this, Ue, Lb).call(this, t, r, s) : (wt(this, Ue, uu).call(this, t, s), r = s));
    const i = t.$ref;
    if (i !== void 0 && typeof i == "string") {
      const { refSchemaId: o, refJsonPointer: a } = wt(this, Ue, cu).call(this, i, r);
      Xe(this, At)[r].refs.push({
        schemaId: o,
        jsonPointer: a
      });
    }
    for (const o in t)
      typeof t[o] == "object" && t[o] !== null && this.addSchema(t[o], r, !1);
  }
  getSchema(t, r = "#") {
    const n = Xe(this, At)[t];
    if (n === void 0)
      throw new Error(
        `Cannot resolve ref "${t}${r}". Schema with id "${t}" is not found.`
      );
    return n.anchors[r] !== void 0 ? n.anchors[r] : Dh(n.schema, r);
  }
  hasSchema(t) {
    return Xe(this, At)[t] !== void 0;
  }
  getSchemaRefs(t) {
    const r = Xe(this, At)[t];
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    return r.refs;
  }
  getSchemaDependencies(t, r = {}) {
    const n = Xe(this, At)[t];
    for (const s of n.refs) {
      const i = s.schemaId;
      i === t || r[i] !== void 0 || (r[i] = this.getSchema(i), this.getSchemaDependencies(i, r));
    }
    return r;
  }
  derefSchema(t) {
    if (Xe(this, Kt)[t] !== void 0) return;
    const r = Xe(this, At)[t];
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    !Xe(this, ti) && r.refs.length === 0 && (Xe(this, Kt)[t] = {
      schema: r.schema,
      anchors: r.anchors
    });
    const n = [];
    wt(this, Ue, fo).call(this, r.schema, t, !0, n);
    const s = this.getSchemaDependencies(t);
    for (const i in s) {
      const o = s[i];
      wt(this, Ue, fo).call(this, o, i, !0, n);
    }
    for (const i of n) {
      const {
        refSchemaId: o,
        refJsonPointer: a
      } = wt(this, Ue, cu).call(this, i.ref, i.sourceSchemaId), c = this.getDerefSchema(o, a);
      if (c === null)
        throw new Error(
          `Cannot resolve ref "${i.ref}". Ref "${a}" is not found in schema "${o}".`
        );
      i.targetSchema = c, i.targetSchemaId = o;
    }
    for (const i of n)
      wt(this, Ue, lu).call(this, i, n);
  }
  getDerefSchema(t, r = "#") {
    let n = Xe(this, Kt)[t];
    return n === void 0 && (this.derefSchema(t), n = Xe(this, Kt)[t]), n.anchors[r] !== void 0 ? n.anchors[r] : Dh(n.schema, r);
  }
}, At = new WeakMap(), Kt = new WeakMap(), Qs = new WeakMap(), ei = new WeakMap(), ti = new WeakMap(), Ue = new WeakSet(), cu = function(t, r) {
  const n = t.indexOf("#");
  return n === -1 ? { refSchemaId: t, refJsonPointer: "#" } : n === 0 ? { refSchemaId: r, refJsonPointer: t } : {
    refSchemaId: t.slice(0, n),
    refJsonPointer: t.slice(n)
  };
}, fo = function(t, r, n, s = []) {
  const i = Array.isArray(t) ? [...t] : { ...t };
  n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : wt(this, Ue, fu).call(this, i, r));
  const o = i.$id;
  o !== void 0 && typeof o == "string" && (o.charAt(0) === "#" ? wt(this, Ue, jb).call(this, i, r, o) : (wt(this, Ue, fu).call(this, i, o), r = o)), i.$ref !== void 0 && s.push({
    ref: i.$ref,
    sourceSchemaId: r,
    sourceSchema: i
  });
  for (const a in i) {
    const c = i[a];
    typeof c == "object" && c !== null && (i[a] = wt(this, Ue, fo).call(this, c, r, !1, s));
  }
  return i;
}, lu = function(t, r) {
  const { sourceSchema: n, targetSchema: s } = t;
  if (n.$ref) {
    if (Xe(this, Qs) && (n[e1] = n.$ref), delete n.$ref, s.$ref) {
      const i = r.find((o) => o.sourceSchema === s);
      wt(this, Ue, lu).call(this, i, r);
    }
    for (const i in s)
      if (i !== "$id") {
        if (n[i] !== void 0) {
          if (jh(n[i], s[i])) continue;
          throw new Error(
            `Cannot resolve ref "${t.ref}". Property "${i}" already exists in schema "${t.sourceSchemaId}".`
          );
        }
        n[i] = s[i];
      }
    t.isResolved = !0;
  }
}, uu = function(t, r) {
  const n = Xe(this, At)[r];
  if (n !== void 0) {
    if (Xe(this, ei) && jh(t, n.schema)) return;
    throw new Error(`There is already another schema with id "${r}".`);
  }
  Xe(this, At)[r] = { schema: t, anchors: {}, refs: [] };
}, Lb = function(t, r, n) {
  const { anchors: s } = Xe(this, At)[r];
  if (s[n] !== void 0)
    throw new Error(`There is already another anchor "${n}" in schema "${r}".`);
  s[n] = t;
}, fu = function(t, r) {
  Xe(this, Kt)[r] === void 0 && (Xe(this, Kt)[r] = { schema: t, anchors: {} });
}, jb = function(t, r, n) {
  const { anchors: s } = Xe(this, Kt)[r];
  s[n] = t;
}, pv);
function Dh(e, t) {
  const r = t.split("/");
  let n = e;
  for (const s of r)
    if (!(s === "" || s === "#")) {
      if (typeof n != "object" || n === null)
        return null;
      n = n[s];
    }
  return n ?? null;
}
var r1 = { RefResolver: t1 }, du = { exports: {} }, gf = {}, Ut = {}, Wn = {}, di = {}, ae = {}, Kn = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(v) {
      if (super(), !e.IDENTIFIER.test(v))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(v) {
      super(), this._items = typeof v == "string" ? [v] : v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const v = this._items[0];
      return v === "" || v === '""';
    }
    get str() {
      var v;
      return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((y, _) => `${y}${_}`, "");
    }
    get names() {
      var v;
      return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((y, _) => (_ instanceof r && (y[_.str] = (y[_.str] || 0) + 1), y), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function s(m, ...v) {
    const y = [m[0]];
    let _ = 0;
    for (; _ < v.length; )
      a(y, v[_]), y.push(m[++_]);
    return new n(y);
  }
  e._ = s;
  const i = new n("+");
  function o(m, ...v) {
    const y = [p(m[0])];
    let _ = 0;
    for (; _ < v.length; )
      y.push(i), a(y, v[_]), y.push(i, p(m[++_]));
    return c(y), new n(y);
  }
  e.str = o;
  function a(m, v) {
    v instanceof n ? m.push(...v._items) : v instanceof r ? m.push(v) : m.push(d(v));
  }
  e.addCodeArg = a;
  function c(m) {
    let v = 1;
    for (; v < m.length - 1; ) {
      if (m[v] === i) {
        const y = f(m[v - 1], m[v + 1]);
        if (y !== void 0) {
          m.splice(v - 1, 3, y);
          continue;
        }
        m[v++] = "+";
      }
      v++;
    }
  }
  function f(m, v) {
    if (v === '""')
      return m;
    if (m === '""')
      return v;
    if (typeof m == "string")
      return v instanceof r || m[m.length - 1] !== '"' ? void 0 : typeof v != "string" ? `${m.slice(0, -1)}${v}"` : v[0] === '"' ? m.slice(0, -1) + v.slice(1) : void 0;
    if (typeof v == "string" && v[0] === '"' && !(m instanceof r))
      return `"${m}${v.slice(1)}`;
  }
  function l(m, v) {
    return v.emptyStr() ? m : m.emptyStr() ? v : o`${m}${v}`;
  }
  e.strConcat = l;
  function d(m) {
    return typeof m == "number" || typeof m == "boolean" || m === null ? m : p(Array.isArray(m) ? m.join(",") : m);
  }
  function g(m) {
    return new n(p(m));
  }
  e.stringify = g;
  function p(m) {
    return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function u(m) {
    return typeof m == "string" && e.IDENTIFIER.test(m) ? new n(`.${m}`) : s`[${m}]`;
  }
  e.getProperty = u;
  function h(m) {
    if (typeof m == "string" && e.IDENTIFIER.test(m))
      return new n(`${m}`);
    throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`);
  }
  e.getEsmExportName = h;
  function b(m) {
    return new n(m.toString());
  }
  e.regexpCode = b;
})(Kn);
var jo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = Kn;
  class r extends Error {
    constructor(f) {
      super(`CodeGen: "code" for ${f} not defined`), this.value = f.value;
    }
  }
  var n;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(n || (e.UsedValueState = n = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class s {
    constructor({ prefixes: f, parent: l } = {}) {
      this._names = {}, this._prefixes = f, this._parent = l;
    }
    toName(f) {
      return f instanceof t.Name ? f : this.name(f);
    }
    name(f) {
      return new t.Name(this._newName(f));
    }
    _newName(f) {
      const l = this._names[f] || this._nameGroup(f);
      return `${f}${l.index++}`;
    }
    _nameGroup(f) {
      var l, d;
      if (!((d = (l = this._parent) === null || l === void 0 ? void 0 : l._prefixes) === null || d === void 0) && d.has(f) || this._prefixes && !this._prefixes.has(f))
        throw new Error(`CodeGen: prefix "${f}" is not allowed in this scope`);
      return this._names[f] = { prefix: f, index: 0 };
    }
  }
  e.Scope = s;
  class i extends t.Name {
    constructor(f, l) {
      super(l), this.prefix = f;
    }
    setValue(f, { property: l, itemIndex: d }) {
      this.value = f, this.scopePath = (0, t._)`.${new t.Name(l)}[${d}]`;
    }
  }
  e.ValueScopeName = i;
  const o = (0, t._)`\n`;
  class a extends s {
    constructor(f) {
      super(f), this._values = {}, this._scope = f.scope, this.opts = { ...f, _n: f.lines ? o : t.nil };
    }
    get() {
      return this._scope;
    }
    name(f) {
      return new i(f, this._newName(f));
    }
    value(f, l) {
      var d;
      if (l.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const g = this.toName(f), { prefix: p } = g, u = (d = l.key) !== null && d !== void 0 ? d : l.ref;
      let h = this._values[p];
      if (h) {
        const v = h.get(u);
        if (v)
          return v;
      } else
        h = this._values[p] = /* @__PURE__ */ new Map();
      h.set(u, g);
      const b = this._scope[p] || (this._scope[p] = []), m = b.length;
      return b[m] = l.ref, g.setValue(l, { property: p, itemIndex: m }), g;
    }
    getValue(f, l) {
      const d = this._values[f];
      if (d)
        return d.get(l);
    }
    scopeRefs(f, l = this._values) {
      return this._reduceValues(l, (d) => {
        if (d.scopePath === void 0)
          throw new Error(`CodeGen: name "${d}" has no value`);
        return (0, t._)`${f}${d.scopePath}`;
      });
    }
    scopeCode(f = this._values, l, d) {
      return this._reduceValues(f, (g) => {
        if (g.value === void 0)
          throw new Error(`CodeGen: name "${g}" has no value`);
        return g.value.code;
      }, l, d);
    }
    _reduceValues(f, l, d = {}, g) {
      let p = t.nil;
      for (const u in f) {
        const h = f[u];
        if (!h)
          continue;
        const b = d[u] = d[u] || /* @__PURE__ */ new Map();
        h.forEach((m) => {
          if (b.has(m))
            return;
          b.set(m, n.Started);
          let v = l(m);
          if (v) {
            const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${y} ${m} = ${v};${this.opts._n}`;
          } else if (v = g == null ? void 0 : g(m))
            p = (0, t._)`${p}${v}${this.opts._n}`;
          else
            throw new r(m);
          b.set(m, n.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = a;
})(jo);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = Kn, r = jo;
  var n = Kn;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var s = jo;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return s.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return s.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return s.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return s.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class i {
    optimizeNodes() {
      return this;
    }
    optimizeNames(w, N) {
      return this;
    }
  }
  class o extends i {
    constructor(w, N, q) {
      super(), this.varKind = w, this.name = N, this.rhs = q;
    }
    render({ es5: w, _n: N }) {
      const q = w ? r.varKinds.var : this.varKind, K = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${q} ${this.name}${K};` + N;
    }
    optimizeNames(w, N) {
      if (w[this.name.str])
        return this.rhs && (this.rhs = S(this.rhs, w, N)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class a extends i {
    constructor(w, N, q) {
      super(), this.lhs = w, this.rhs = N, this.sideEffects = q;
    }
    render({ _n: w }) {
      return `${this.lhs} = ${this.rhs};` + w;
    }
    optimizeNames(w, N) {
      if (!(this.lhs instanceof t.Name && !w[this.lhs.str] && !this.sideEffects))
        return this.rhs = S(this.rhs, w, N), this;
    }
    get names() {
      const w = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return $(w, this.rhs);
    }
  }
  class c extends a {
    constructor(w, N, q, K) {
      super(w, q, K), this.op = N;
    }
    render({ _n: w }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + w;
    }
  }
  class f extends i {
    constructor(w) {
      super(), this.label = w, this.names = {};
    }
    render({ _n: w }) {
      return `${this.label}:` + w;
    }
  }
  class l extends i {
    constructor(w) {
      super(), this.label = w, this.names = {};
    }
    render({ _n: w }) {
      return `break${this.label ? ` ${this.label}` : ""};` + w;
    }
  }
  class d extends i {
    constructor(w) {
      super(), this.error = w;
    }
    render({ _n: w }) {
      return `throw ${this.error};` + w;
    }
    get names() {
      return this.error.names;
    }
  }
  class g extends i {
    constructor(w) {
      super(), this.code = w;
    }
    render({ _n: w }) {
      return `${this.code};` + w;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(w, N) {
      return this.code = S(this.code, w, N), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends i {
    constructor(w = []) {
      super(), this.nodes = w;
    }
    render(w) {
      return this.nodes.reduce((N, q) => N + q.render(w), "");
    }
    optimizeNodes() {
      const { nodes: w } = this;
      let N = w.length;
      for (; N--; ) {
        const q = w[N].optimizeNodes();
        Array.isArray(q) ? w.splice(N, 1, ...q) : q ? w[N] = q : w.splice(N, 1);
      }
      return w.length > 0 ? this : void 0;
    }
    optimizeNames(w, N) {
      const { nodes: q } = this;
      let K = q.length;
      for (; K--; ) {
        const V = q[K];
        V.optimizeNames(w, N) || (I(w, V.names), q.splice(K, 1));
      }
      return q.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((w, N) => U(w, N.names), {});
    }
  }
  class u extends p {
    render(w) {
      return "{" + w._n + super.render(w) + "}" + w._n;
    }
  }
  class h extends p {
  }
  class b extends u {
  }
  b.kind = "else";
  class m extends u {
    constructor(w, N) {
      super(N), this.condition = w;
    }
    render(w) {
      let N = `if(${this.condition})` + super.render(w);
      return this.else && (N += "else " + this.else.render(w)), N;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const w = this.condition;
      if (w === !0)
        return this.nodes;
      let N = this.else;
      if (N) {
        const q = N.optimizeNodes();
        N = this.else = Array.isArray(q) ? new b(q) : q;
      }
      if (N)
        return w === !1 ? N instanceof m ? N : N.nodes : this.nodes.length ? this : new m(T(w), N instanceof m ? [N] : N.nodes);
      if (!(w === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(w, N) {
      var q;
      if (this.else = (q = this.else) === null || q === void 0 ? void 0 : q.optimizeNames(w, N), !!(super.optimizeNames(w, N) || this.else))
        return this.condition = S(this.condition, w, N), this;
    }
    get names() {
      const w = super.names;
      return $(w, this.condition), this.else && U(w, this.else.names), w;
    }
  }
  m.kind = "if";
  class v extends u {
  }
  v.kind = "for";
  class y extends v {
    constructor(w) {
      super(), this.iteration = w;
    }
    render(w) {
      return `for(${this.iteration})` + super.render(w);
    }
    optimizeNames(w, N) {
      if (super.optimizeNames(w, N))
        return this.iteration = S(this.iteration, w, N), this;
    }
    get names() {
      return U(super.names, this.iteration.names);
    }
  }
  class _ extends v {
    constructor(w, N, q, K) {
      super(), this.varKind = w, this.name = N, this.from = q, this.to = K;
    }
    render(w) {
      const N = w.es5 ? r.varKinds.var : this.varKind, { name: q, from: K, to: V } = this;
      return `for(${N} ${q}=${K}; ${q}<${V}; ${q}++)` + super.render(w);
    }
    get names() {
      const w = $(super.names, this.from);
      return $(w, this.to);
    }
  }
  class R extends v {
    constructor(w, N, q, K) {
      super(), this.loop = w, this.varKind = N, this.name = q, this.iterable = K;
    }
    render(w) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(w);
    }
    optimizeNames(w, N) {
      if (super.optimizeNames(w, N))
        return this.iterable = S(this.iterable, w, N), this;
    }
    get names() {
      return U(super.names, this.iterable.names);
    }
  }
  class E extends u {
    constructor(w, N, q) {
      super(), this.name = w, this.args = N, this.async = q;
    }
    render(w) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(w);
    }
  }
  E.kind = "func";
  class O extends p {
    render(w) {
      return "return " + super.render(w);
    }
  }
  O.kind = "return";
  class z extends u {
    render(w) {
      let N = "try" + super.render(w);
      return this.catch && (N += this.catch.render(w)), this.finally && (N += this.finally.render(w)), N;
    }
    optimizeNodes() {
      var w, N;
      return super.optimizeNodes(), (w = this.catch) === null || w === void 0 || w.optimizeNodes(), (N = this.finally) === null || N === void 0 || N.optimizeNodes(), this;
    }
    optimizeNames(w, N) {
      var q, K;
      return super.optimizeNames(w, N), (q = this.catch) === null || q === void 0 || q.optimizeNames(w, N), (K = this.finally) === null || K === void 0 || K.optimizeNames(w, N), this;
    }
    get names() {
      const w = super.names;
      return this.catch && U(w, this.catch.names), this.finally && U(w, this.finally.names), w;
    }
  }
  class x extends u {
    constructor(w) {
      super(), this.error = w;
    }
    render(w) {
      return `catch(${this.error})` + super.render(w);
    }
  }
  x.kind = "catch";
  class L extends u {
    render(w) {
      return "finally" + super.render(w);
    }
  }
  L.kind = "finally";
  class M {
    constructor(w, N = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...N, _n: N.lines ? `
` : "" }, this._extScope = w, this._scope = new r.Scope({ parent: w }), this._nodes = [new h()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(w) {
      return this._scope.name(w);
    }
    // reserves unique name in the external scope
    scopeName(w) {
      return this._extScope.name(w);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(w, N) {
      const q = this._extScope.value(w, N);
      return (this._values[q.prefix] || (this._values[q.prefix] = /* @__PURE__ */ new Set())).add(q), q;
    }
    getScopeValue(w, N) {
      return this._extScope.getValue(w, N);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(w) {
      return this._extScope.scopeRefs(w, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(w, N, q, K) {
      const V = this._scope.toName(N);
      return q !== void 0 && K && (this._constants[V.str] = q), this._leafNode(new o(w, V, q)), V;
    }
    // `const` declaration (`var` in es5 mode)
    const(w, N, q) {
      return this._def(r.varKinds.const, w, N, q);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(w, N, q) {
      return this._def(r.varKinds.let, w, N, q);
    }
    // `var` declaration with optional assignment
    var(w, N, q) {
      return this._def(r.varKinds.var, w, N, q);
    }
    // assignment code
    assign(w, N, q) {
      return this._leafNode(new a(w, N, q));
    }
    // `+=` code
    add(w, N) {
      return this._leafNode(new c(w, e.operators.ADD, N));
    }
    // appends passed SafeExpr to code or executes Block
    code(w) {
      return typeof w == "function" ? w() : w !== t.nil && this._leafNode(new g(w)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...w) {
      const N = ["{"];
      for (const [q, K] of w)
        N.length > 1 && N.push(","), N.push(q), (q !== K || this.opts.es5) && (N.push(":"), (0, t.addCodeArg)(N, K));
      return N.push("}"), new t._Code(N);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(w, N, q) {
      if (this._blockNode(new m(w)), N && q)
        this.code(N).else().code(q).endIf();
      else if (N)
        this.code(N).endIf();
      else if (q)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(w) {
      return this._elseNode(new m(w));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new b());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(m, b);
    }
    _for(w, N) {
      return this._blockNode(w), N && this.code(N).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(w, N) {
      return this._for(new y(w), N);
    }
    // `for` statement for a range of values
    forRange(w, N, q, K, V = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Z = this._scope.toName(w);
      return this._for(new _(V, Z, N, q), () => K(Z));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(w, N, q, K = r.varKinds.const) {
      const V = this._scope.toName(w);
      if (this.opts.es5) {
        const Z = N instanceof t.Name ? N : this.var("_arr", N);
        return this.forRange("_i", 0, (0, t._)`${Z}.length`, (Y) => {
          this.var(V, (0, t._)`${Z}[${Y}]`), q(V);
        });
      }
      return this._for(new R("of", K, V, N), () => q(V));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(w, N, q, K = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(w, (0, t._)`Object.keys(${N})`, q);
      const V = this._scope.toName(w);
      return this._for(new R("in", K, V, N), () => q(V));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(v);
    }
    // `label` statement
    label(w) {
      return this._leafNode(new f(w));
    }
    // `break` statement
    break(w) {
      return this._leafNode(new l(w));
    }
    // `return` statement
    return(w) {
      const N = new O();
      if (this._blockNode(N), this.code(w), N.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(O);
    }
    // `try` statement
    try(w, N, q) {
      if (!N && !q)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const K = new z();
      if (this._blockNode(K), this.code(w), N) {
        const V = this.name("e");
        this._currNode = K.catch = new x(V), N(V);
      }
      return q && (this._currNode = K.finally = new L(), this.code(q)), this._endBlockNode(x, L);
    }
    // `throw` statement
    throw(w) {
      return this._leafNode(new d(w));
    }
    // start self-balancing block
    block(w, N) {
      return this._blockStarts.push(this._nodes.length), w && this.code(w).endBlock(N), this;
    }
    // end the current self-balancing block
    endBlock(w) {
      const N = this._blockStarts.pop();
      if (N === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const q = this._nodes.length - N;
      if (q < 0 || w !== void 0 && q !== w)
        throw new Error(`CodeGen: wrong number of nodes: ${q} vs ${w} expected`);
      return this._nodes.length = N, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(w, N = t.nil, q, K) {
      return this._blockNode(new E(w, N, q)), K && this.code(K).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(E);
    }
    optimize(w = 1) {
      for (; w-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(w) {
      return this._currNode.nodes.push(w), this;
    }
    _blockNode(w) {
      this._currNode.nodes.push(w), this._nodes.push(w);
    }
    _endBlockNode(w, N) {
      const q = this._currNode;
      if (q instanceof w || N && q instanceof N)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${N ? `${w.kind}/${N.kind}` : w.kind}"`);
    }
    _elseNode(w) {
      const N = this._currNode;
      if (!(N instanceof m))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = N.else = w, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const w = this._nodes;
      return w[w.length - 1];
    }
    set _currNode(w) {
      const N = this._nodes;
      N[N.length - 1] = w;
    }
  }
  e.CodeGen = M;
  function U(F, w) {
    for (const N in w)
      F[N] = (F[N] || 0) + (w[N] || 0);
    return F;
  }
  function $(F, w) {
    return w instanceof t._CodeOrName ? U(F, w.names) : F;
  }
  function S(F, w, N) {
    if (F instanceof t.Name)
      return q(F);
    if (!K(F))
      return F;
    return new t._Code(F._items.reduce((V, Z) => (Z instanceof t.Name && (Z = q(Z)), Z instanceof t._Code ? V.push(...Z._items) : V.push(Z), V), []));
    function q(V) {
      const Z = N[V.str];
      return Z === void 0 || w[V.str] !== 1 ? V : (delete w[V.str], Z);
    }
    function K(V) {
      return V instanceof t._Code && V._items.some((Z) => Z instanceof t.Name && w[Z.str] === 1 && N[Z.str] !== void 0);
    }
  }
  function I(F, w) {
    for (const N in w)
      F[N] = (F[N] || 0) - (w[N] || 0);
  }
  function T(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null ? !F : (0, t._)`!${D(F)}`;
  }
  e.not = T;
  const j = C(e.operators.AND);
  function P(...F) {
    return F.reduce(j);
  }
  e.and = P;
  const A = C(e.operators.OR);
  function k(...F) {
    return F.reduce(A);
  }
  e.or = k;
  function C(F) {
    return (w, N) => w === t.nil ? N : N === t.nil ? w : (0, t._)`${D(w)} ${F} ${D(N)}`;
  }
  function D(F) {
    return F instanceof t.Name ? F : (0, t._)`(${F})`;
  }
})(ae);
var re = {};
Object.defineProperty(re, "__esModule", { value: !0 });
re.checkStrictMode = re.getErrorPath = re.Type = re.useFunc = re.setEvaluated = re.evaluatedPropsToName = re.mergeEvaluated = re.eachItem = re.unescapeJsonPointer = re.escapeJsonPointer = re.escapeFragment = re.unescapeFragment = re.schemaRefOrVal = re.schemaHasRulesButRef = re.schemaHasRules = re.checkUnknownRules = re.alwaysValidSchema = re.toHash = void 0;
const Ce = ae, n1 = Kn;
function s1(e) {
  const t = {};
  for (const r of e)
    t[r] = !0;
  return t;
}
re.toHash = s1;
function i1(e, t) {
  return typeof t == "boolean" ? t : Object.keys(t).length === 0 ? !0 : (Db(e, t), !Fb(t, e.self.RULES.all));
}
re.alwaysValidSchema = i1;
function Db(e, t = e.schema) {
  const { opts: r, self: n } = e;
  if (!r.strictSchema || typeof t == "boolean")
    return;
  const s = n.RULES.keywords;
  for (const i in t)
    s[i] || Ub(e, `unknown keyword: "${i}"`);
}
re.checkUnknownRules = Db;
function Fb(e, t) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t[r])
      return !0;
  return !1;
}
re.schemaHasRules = Fb;
function o1(e, t) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (r !== "$ref" && t.all[r])
      return !0;
  return !1;
}
re.schemaHasRulesButRef = o1;
function a1({ topSchemaRef: e, schemaPath: t }, r, n, s) {
  if (!s) {
    if (typeof r == "number" || typeof r == "boolean")
      return r;
    if (typeof r == "string")
      return (0, Ce._)`${r}`;
  }
  return (0, Ce._)`${e}${t}${(0, Ce.getProperty)(n)}`;
}
re.schemaRefOrVal = a1;
function c1(e) {
  return Mb(decodeURIComponent(e));
}
re.unescapeFragment = c1;
function l1(e) {
  return encodeURIComponent(vf(e));
}
re.escapeFragment = l1;
function vf(e) {
  return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
re.escapeJsonPointer = vf;
function Mb(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
re.unescapeJsonPointer = Mb;
function u1(e, t) {
  if (Array.isArray(e))
    for (const r of e)
      t(r);
  else
    t(e);
}
re.eachItem = u1;
function Fh({ mergeNames: e, mergeToName: t, mergeValues: r, resultToName: n }) {
  return (s, i, o, a) => {
    const c = o === void 0 ? i : o instanceof Ce.Name ? (i instanceof Ce.Name ? e(s, i, o) : t(s, i, o), o) : i instanceof Ce.Name ? (t(s, o, i), i) : r(i, o);
    return a === Ce.Name && !(c instanceof Ce.Name) ? n(s, c) : c;
  };
}
re.mergeEvaluated = {
  props: Fh({
    mergeNames: (e, t, r) => e.if((0, Ce._)`${r} !== true && ${t} !== undefined`, () => {
      e.if((0, Ce._)`${t} === true`, () => e.assign(r, !0), () => e.assign(r, (0, Ce._)`${r} || {}`).code((0, Ce._)`Object.assign(${r}, ${t})`));
    }),
    mergeToName: (e, t, r) => e.if((0, Ce._)`${r} !== true`, () => {
      t === !0 ? e.assign(r, !0) : (e.assign(r, (0, Ce._)`${r} || {}`), bf(e, r, t));
    }),
    mergeValues: (e, t) => e === !0 ? !0 : { ...e, ...t },
    resultToName: zb
  }),
  items: Fh({
    mergeNames: (e, t, r) => e.if((0, Ce._)`${r} !== true && ${t} !== undefined`, () => e.assign(r, (0, Ce._)`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)),
    mergeToName: (e, t, r) => e.if((0, Ce._)`${r} !== true`, () => e.assign(r, t === !0 ? !0 : (0, Ce._)`${r} > ${t} ? ${r} : ${t}`)),
    mergeValues: (e, t) => e === !0 ? !0 : Math.max(e, t),
    resultToName: (e, t) => e.var("items", t)
  })
};
function zb(e, t) {
  if (t === !0)
    return e.var("props", !0);
  const r = e.var("props", (0, Ce._)`{}`);
  return t !== void 0 && bf(e, r, t), r;
}
re.evaluatedPropsToName = zb;
function bf(e, t, r) {
  Object.keys(r).forEach((n) => e.assign((0, Ce._)`${t}${(0, Ce.getProperty)(n)}`, !0));
}
re.setEvaluated = bf;
const Mh = {};
function f1(e, t) {
  return e.scopeValue("func", {
    ref: t,
    code: Mh[t.code] || (Mh[t.code] = new n1._Code(t.code))
  });
}
re.useFunc = f1;
var pu;
(function(e) {
  e[e.Num = 0] = "Num", e[e.Str = 1] = "Str";
})(pu || (re.Type = pu = {}));
function d1(e, t, r) {
  if (e instanceof Ce.Name) {
    const n = t === pu.Num;
    return r ? n ? (0, Ce._)`"[" + ${e} + "]"` : (0, Ce._)`"['" + ${e} + "']"` : n ? (0, Ce._)`"/" + ${e}` : (0, Ce._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return r ? (0, Ce.getProperty)(e).toString() : "/" + vf(e);
}
re.getErrorPath = d1;
function Ub(e, t, r = e.opts.strictSchema) {
  if (r) {
    if (t = `strict mode: ${t}`, r === !0)
      throw new Error(t);
    e.self.logger.warn(t);
  }
}
re.checkStrictMode = Ub;
var jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
const mt = ae, p1 = {
  // validation function arguments
  data: new mt.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new mt.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new mt.Name("instancePath"),
  parentData: new mt.Name("parentData"),
  parentDataProperty: new mt.Name("parentDataProperty"),
  rootData: new mt.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new mt.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new mt.Name("vErrors"),
  // null or array of validation errors
  errors: new mt.Name("errors"),
  // counter of validation errors
  this: new mt.Name("this"),
  // "globals"
  self: new mt.Name("self"),
  scope: new mt.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new mt.Name("json"),
  jsonPos: new mt.Name("jsonPos"),
  jsonLen: new mt.Name("jsonLen"),
  jsonPart: new mt.Name("jsonPart")
};
jt.default = p1;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = ae, r = re, n = jt;
  e.keywordError = {
    message: ({ keyword: b }) => (0, t.str)`must pass "${b}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: b, schemaType: m }) => m ? (0, t.str)`"${b}" keyword must be ${m} ($data)` : (0, t.str)`"${b}" keyword is invalid ($data)`
  };
  function s(b, m = e.keywordError, v, y) {
    const { it: _ } = b, { gen: R, compositeRule: E, allErrors: O } = _, z = d(b, m, v);
    y ?? (E || O) ? c(R, z) : f(_, (0, t._)`[${z}]`);
  }
  e.reportError = s;
  function i(b, m = e.keywordError, v) {
    const { it: y } = b, { gen: _, compositeRule: R, allErrors: E } = y, O = d(b, m, v);
    c(_, O), R || E || f(y, n.default.vErrors);
  }
  e.reportExtraError = i;
  function o(b, m) {
    b.assign(n.default.errors, m), b.if((0, t._)`${n.default.vErrors} !== null`, () => b.if(m, () => b.assign((0, t._)`${n.default.vErrors}.length`, m), () => b.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = o;
  function a({ gen: b, keyword: m, schemaValue: v, data: y, errsCount: _, it: R }) {
    if (_ === void 0)
      throw new Error("ajv implementation error");
    const E = b.name("err");
    b.forRange("i", _, n.default.errors, (O) => {
      b.const(E, (0, t._)`${n.default.vErrors}[${O}]`), b.if((0, t._)`${E}.instancePath === undefined`, () => b.assign((0, t._)`${E}.instancePath`, (0, t.strConcat)(n.default.instancePath, R.errorPath))), b.assign((0, t._)`${E}.schemaPath`, (0, t.str)`${R.errSchemaPath}/${m}`), R.opts.verbose && (b.assign((0, t._)`${E}.schema`, v), b.assign((0, t._)`${E}.data`, y));
    });
  }
  e.extendErrors = a;
  function c(b, m) {
    const v = b.const("err", m);
    b.if((0, t._)`${n.default.vErrors} === null`, () => b.assign(n.default.vErrors, (0, t._)`[${v}]`), (0, t._)`${n.default.vErrors}.push(${v})`), b.code((0, t._)`${n.default.errors}++`);
  }
  function f(b, m) {
    const { gen: v, validateName: y, schemaEnv: _ } = b;
    _.$async ? v.throw((0, t._)`new ${b.ValidationError}(${m})`) : (v.assign((0, t._)`${y}.errors`, m), v.return(!1));
  }
  const l = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    // also used in JTD errors
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function d(b, m, v) {
    const { createErrors: y } = b.it;
    return y === !1 ? (0, t._)`{}` : g(b, m, v);
  }
  function g(b, m, v = {}) {
    const { gen: y, it: _ } = b, R = [
      p(_, v),
      u(b, v)
    ];
    return h(b, m, R), y.object(...R);
  }
  function p({ errorPath: b }, { instancePath: m }) {
    const v = m ? (0, t.str)`${b}${(0, r.getErrorPath)(m, r.Type.Str)}` : b;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, v)];
  }
  function u({ keyword: b, it: { errSchemaPath: m } }, { schemaPath: v, parentSchema: y }) {
    let _ = y ? m : (0, t.str)`${m}/${b}`;
    return v && (_ = (0, t.str)`${_}${(0, r.getErrorPath)(v, r.Type.Str)}`), [l.schemaPath, _];
  }
  function h(b, { params: m, message: v }, y) {
    const { keyword: _, data: R, schemaValue: E, it: O } = b, { opts: z, propertyName: x, topSchemaRef: L, schemaPath: M } = O;
    y.push([l.keyword, _], [l.params, typeof m == "function" ? m(b) : m || (0, t._)`{}`]), z.messages && y.push([l.message, typeof v == "function" ? v(b) : v]), z.verbose && y.push([l.schema, E], [l.parentSchema, (0, t._)`${L}${M}`], [n.default.data, R]), x && y.push([l.propertyName, x]);
  }
})(di);
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.boolOrEmptySchema = Wn.topBoolOrEmptySchema = void 0;
const h1 = di, m1 = ae, y1 = jt, g1 = {
  message: "boolean schema is false"
};
function v1(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? qb(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(y1.default.data) : (t.assign((0, m1._)`${n}.errors`, null), t.return(!0));
}
Wn.topBoolOrEmptySchema = v1;
function b1(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), qb(e)) : r.var(t, !0);
}
Wn.boolOrEmptySchema = b1;
function qb(e, t) {
  const { gen: r, data: n } = e, s = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, h1.reportError)(s, g1, void 0, t);
}
var tt = {}, dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.getRules = dn.isJSONType = void 0;
const _1 = ["string", "number", "integer", "boolean", "null", "object", "array"], E1 = new Set(_1);
function x1(e) {
  return typeof e == "string" && E1.has(e);
}
dn.isJSONType = x1;
function S1() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
dn.getRules = S1;
var br = {};
Object.defineProperty(br, "__esModule", { value: !0 });
br.shouldUseRule = br.shouldUseGroup = br.schemaHasRulesForType = void 0;
function w1({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && Hb(e, n);
}
br.schemaHasRulesForType = w1;
function Hb(e, t) {
  return t.rules.some((r) => Bb(e, r));
}
br.shouldUseGroup = Hb;
function Bb(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
br.shouldUseRule = Bb;
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.reportTypeError = tt.checkDataTypes = tt.checkDataType = tt.coerceAndCheckDataType = tt.getJSONTypes = tt.getSchemaTypes = tt.DataType = void 0;
const R1 = dn, $1 = br, T1 = di, de = ae, Vb = re;
var qn;
(function(e) {
  e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong";
})(qn || (tt.DataType = qn = {}));
function O1(e) {
  const t = Gb(e.type);
  if (t.includes("null")) {
    if (e.nullable === !1)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!t.length && e.nullable !== void 0)
      throw new Error('"nullable" cannot be used without "type"');
    e.nullable === !0 && t.push("null");
  }
  return t;
}
tt.getSchemaTypes = O1;
function Gb(e) {
  const t = Array.isArray(e) ? e : e ? [e] : [];
  if (t.every(R1.isJSONType))
    return t;
  throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
}
tt.getJSONTypes = Gb;
function P1(e, t) {
  const { gen: r, data: n, opts: s } = e, i = C1(t, s.coerceTypes), o = t.length > 0 && !(i.length === 0 && t.length === 1 && (0, $1.schemaHasRulesForType)(e, t[0]));
  if (o) {
    const a = _f(t, n, s.strictNumbers, qn.Wrong);
    r.if(a, () => {
      i.length ? I1(e, t, i) : Ef(e);
    });
  }
  return o;
}
tt.coerceAndCheckDataType = P1;
const Wb = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function C1(e, t) {
  return t ? e.filter((r) => Wb.has(r) || t === "array" && r === "array") : [];
}
function I1(e, t, r) {
  const { gen: n, data: s, opts: i } = e, o = n.let("dataType", (0, de._)`typeof ${s}`), a = n.let("coerced", (0, de._)`undefined`);
  i.coerceTypes === "array" && n.if((0, de._)`${o} == 'object' && Array.isArray(${s}) && ${s}.length == 1`, () => n.assign(s, (0, de._)`${s}[0]`).assign(o, (0, de._)`typeof ${s}`).if(_f(t, s, i.strictNumbers), () => n.assign(a, s))), n.if((0, de._)`${a} !== undefined`);
  for (const f of r)
    (Wb.has(f) || f === "array" && i.coerceTypes === "array") && c(f);
  n.else(), Ef(e), n.endIf(), n.if((0, de._)`${a} !== undefined`, () => {
    n.assign(s, a), N1(e, a);
  });
  function c(f) {
    switch (f) {
      case "string":
        n.elseIf((0, de._)`${o} == "number" || ${o} == "boolean"`).assign(a, (0, de._)`"" + ${s}`).elseIf((0, de._)`${s} === null`).assign(a, (0, de._)`""`);
        return;
      case "number":
        n.elseIf((0, de._)`${o} == "boolean" || ${s} === null
              || (${o} == "string" && ${s} && ${s} == +${s})`).assign(a, (0, de._)`+${s}`);
        return;
      case "integer":
        n.elseIf((0, de._)`${o} === "boolean" || ${s} === null
              || (${o} === "string" && ${s} && ${s} == +${s} && !(${s} % 1))`).assign(a, (0, de._)`+${s}`);
        return;
      case "boolean":
        n.elseIf((0, de._)`${s} === "false" || ${s} === 0 || ${s} === null`).assign(a, !1).elseIf((0, de._)`${s} === "true" || ${s} === 1`).assign(a, !0);
        return;
      case "null":
        n.elseIf((0, de._)`${s} === "" || ${s} === 0 || ${s} === false`), n.assign(a, null);
        return;
      case "array":
        n.elseIf((0, de._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${s} === null`).assign(a, (0, de._)`[${s}]`);
    }
  }
}
function N1({ gen: e, parentData: t, parentDataProperty: r }, n) {
  e.if((0, de._)`${t} !== undefined`, () => e.assign((0, de._)`${t}[${r}]`, n));
}
function hu(e, t, r, n = qn.Correct) {
  const s = n === qn.Correct ? de.operators.EQ : de.operators.NEQ;
  let i;
  switch (e) {
    case "null":
      return (0, de._)`${t} ${s} null`;
    case "array":
      i = (0, de._)`Array.isArray(${t})`;
      break;
    case "object":
      i = (0, de._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
      break;
    case "integer":
      i = o((0, de._)`!(${t} % 1) && !isNaN(${t})`);
      break;
    case "number":
      i = o();
      break;
    default:
      return (0, de._)`typeof ${t} ${s} ${e}`;
  }
  return n === qn.Correct ? i : (0, de.not)(i);
  function o(a = de.nil) {
    return (0, de.and)((0, de._)`typeof ${t} == "number"`, a, r ? (0, de._)`isFinite(${t})` : de.nil);
  }
}
tt.checkDataType = hu;
function _f(e, t, r, n) {
  if (e.length === 1)
    return hu(e[0], t, r, n);
  let s;
  const i = (0, Vb.toHash)(e);
  if (i.array && i.object) {
    const o = (0, de._)`typeof ${t} != "object"`;
    s = i.null ? o : (0, de._)`!${t} || ${o}`, delete i.null, delete i.array, delete i.object;
  } else
    s = de.nil;
  i.number && delete i.integer;
  for (const o in i)
    s = (0, de.and)(s, hu(o, t, r, n));
  return s;
}
tt.checkDataTypes = _f;
const A1 = {
  message: ({ schema: e }) => `must be ${e}`,
  params: ({ schema: e, schemaValue: t }) => typeof e == "string" ? (0, de._)`{type: ${e}}` : (0, de._)`{type: ${t}}`
};
function Ef(e) {
  const t = k1(e);
  (0, T1.reportError)(t, A1);
}
tt.reportTypeError = Ef;
function k1(e) {
  const { gen: t, data: r, schema: n } = e, s = (0, Vb.schemaRefOrVal)(e, n, "type");
  return {
    gen: t,
    keyword: "type",
    data: r,
    schema: n.type,
    schemaCode: s,
    schemaValue: s,
    parentSchema: n,
    params: {},
    it: e
  };
}
var va = {};
Object.defineProperty(va, "__esModule", { value: !0 });
va.assignDefaults = void 0;
const Rn = ae, L1 = re;
function j1(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const s in r)
      zh(e, s, r[s].default);
  else t === "array" && Array.isArray(n) && n.forEach((s, i) => zh(e, i, s.default));
}
va.assignDefaults = j1;
function zh(e, t, r) {
  const { gen: n, compositeRule: s, data: i, opts: o } = e;
  if (r === void 0)
    return;
  const a = (0, Rn._)`${i}${(0, Rn.getProperty)(t)}`;
  if (s) {
    (0, L1.checkStrictMode)(e, `default is ignored for: ${a}`);
    return;
  }
  let c = (0, Rn._)`${a} === undefined`;
  o.useDefaults === "empty" && (c = (0, Rn._)`${c} || ${a} === null || ${a} === ""`), n.if(c, (0, Rn._)`${a} = ${(0, Rn.stringify)(r)}`);
}
var cr = {}, fe = {};
Object.defineProperty(fe, "__esModule", { value: !0 });
fe.validateUnion = fe.validateArray = fe.usePattern = fe.callValidateCode = fe.schemaProperties = fe.allSchemaProperties = fe.noPropertyInData = fe.propertyInData = fe.isOwnProperty = fe.hasPropFunc = fe.reportMissingProp = fe.checkMissingProp = fe.checkReportMissingProp = void 0;
const ke = ae, xf = re, Cr = jt, D1 = re;
function F1(e, t) {
  const { gen: r, data: n, it: s } = e;
  r.if(wf(r, n, t, s.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, ke._)`${t}` }, !0), e.error();
  });
}
fe.checkReportMissingProp = F1;
function M1({ gen: e, data: t, it: { opts: r } }, n, s) {
  return (0, ke.or)(...n.map((i) => (0, ke.and)(wf(e, t, i, r.ownProperties), (0, ke._)`${s} = ${i}`)));
}
fe.checkMissingProp = M1;
function z1(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
fe.reportMissingProp = z1;
function Kb(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, ke._)`Object.prototype.hasOwnProperty`
  });
}
fe.hasPropFunc = Kb;
function Sf(e, t, r) {
  return (0, ke._)`${Kb(e)}.call(${t}, ${r})`;
}
fe.isOwnProperty = Sf;
function U1(e, t, r, n) {
  const s = (0, ke._)`${t}${(0, ke.getProperty)(r)} !== undefined`;
  return n ? (0, ke._)`${s} && ${Sf(e, t, r)}` : s;
}
fe.propertyInData = U1;
function wf(e, t, r, n) {
  const s = (0, ke._)`${t}${(0, ke.getProperty)(r)} === undefined`;
  return n ? (0, ke.or)(s, (0, ke.not)(Sf(e, t, r))) : s;
}
fe.noPropertyInData = wf;
function Jb(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
fe.allSchemaProperties = Jb;
function q1(e, t) {
  return Jb(t).filter((r) => !(0, xf.alwaysValidSchema)(e, t[r]));
}
fe.schemaProperties = q1;
function H1({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: s, errorPath: i }, it: o }, a, c, f) {
  const l = f ? (0, ke._)`${e}, ${t}, ${n}${s}` : t, d = [
    [Cr.default.instancePath, (0, ke.strConcat)(Cr.default.instancePath, i)],
    [Cr.default.parentData, o.parentData],
    [Cr.default.parentDataProperty, o.parentDataProperty],
    [Cr.default.rootData, Cr.default.rootData]
  ];
  o.opts.dynamicRef && d.push([Cr.default.dynamicAnchors, Cr.default.dynamicAnchors]);
  const g = (0, ke._)`${l}, ${r.object(...d)}`;
  return c !== ke.nil ? (0, ke._)`${a}.call(${c}, ${g})` : (0, ke._)`${a}(${g})`;
}
fe.callValidateCode = H1;
const B1 = (0, ke._)`new RegExp`;
function V1({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: s } = t.code, i = s(r, n);
  return e.scopeValue("pattern", {
    key: i.toString(),
    ref: i,
    code: (0, ke._)`${s.code === "new RegExp" ? B1 : (0, D1.useFunc)(e, s)}(${r}, ${n})`
  });
}
fe.usePattern = V1;
function G1(e) {
  const { gen: t, data: r, keyword: n, it: s } = e, i = t.name("valid");
  if (s.allErrors) {
    const a = t.let("valid", !0);
    return o(() => t.assign(a, !1)), a;
  }
  return t.var(i, !0), o(() => t.break()), i;
  function o(a) {
    const c = t.const("len", (0, ke._)`${r}.length`);
    t.forRange("i", 0, c, (f) => {
      e.subschema({
        keyword: n,
        dataProp: f,
        dataPropType: xf.Type.Num
      }, i), t.if((0, ke.not)(i), a);
    });
  }
}
fe.validateArray = G1;
function W1(e) {
  const { gen: t, schema: r, keyword: n, it: s } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, xf.alwaysValidSchema)(s, c)) && !s.opts.unevaluated)
    return;
  const o = t.let("valid", !1), a = t.name("_valid");
  t.block(() => r.forEach((c, f) => {
    const l = e.subschema({
      keyword: n,
      schemaProp: f,
      compositeRule: !0
    }, a);
    t.assign(o, (0, ke._)`${o} || ${a}`), e.mergeValidEvaluated(l, a) || t.if((0, ke.not)(o));
  })), e.result(o, () => e.reset(), () => e.error(!0));
}
fe.validateUnion = W1;
Object.defineProperty(cr, "__esModule", { value: !0 });
cr.validateKeywordUsage = cr.validSchemaType = cr.funcKeywordCode = cr.macroKeywordCode = void 0;
const xt = ae, tn = jt, K1 = fe, J1 = di;
function Y1(e, t) {
  const { gen: r, keyword: n, schema: s, parentSchema: i, it: o } = e, a = t.macro.call(o.self, s, i, o), c = Yb(r, n, a);
  o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
  const f = r.name("valid");
  e.subschema({
    schema: a,
    schemaPath: xt.nil,
    errSchemaPath: `${o.errSchemaPath}/${n}`,
    topSchemaRef: c,
    compositeRule: !0
  }, f), e.pass(f, () => e.error(!0));
}
cr.macroKeywordCode = Y1;
function X1(e, t) {
  var r;
  const { gen: n, keyword: s, schema: i, parentSchema: o, $data: a, it: c } = e;
  Q1(c, t);
  const f = !a && t.compile ? t.compile.call(c.self, i, o, c) : t.validate, l = Yb(n, s, f), d = n.let("valid");
  e.block$data(d, g), e.ok((r = t.valid) !== null && r !== void 0 ? r : d);
  function g() {
    if (t.errors === !1)
      h(), t.modifying && Uh(e), b(() => e.error());
    else {
      const m = t.async ? p() : u();
      t.modifying && Uh(e), b(() => Z1(e, m));
    }
  }
  function p() {
    const m = n.let("ruleErrs", null);
    return n.try(() => h((0, xt._)`await `), (v) => n.assign(d, !1).if((0, xt._)`${v} instanceof ${c.ValidationError}`, () => n.assign(m, (0, xt._)`${v}.errors`), () => n.throw(v))), m;
  }
  function u() {
    const m = (0, xt._)`${l}.errors`;
    return n.assign(m, null), h(xt.nil), m;
  }
  function h(m = t.async ? (0, xt._)`await ` : xt.nil) {
    const v = c.opts.passContext ? tn.default.this : tn.default.self, y = !("compile" in t && !a || t.schema === !1);
    n.assign(d, (0, xt._)`${m}${(0, K1.callValidateCode)(e, l, v, y)}`, t.modifying);
  }
  function b(m) {
    var v;
    n.if((0, xt.not)((v = t.valid) !== null && v !== void 0 ? v : d), m);
  }
}
cr.funcKeywordCode = X1;
function Uh(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, xt._)`${n.parentData}[${n.parentDataProperty}]`));
}
function Z1(e, t) {
  const { gen: r } = e;
  r.if((0, xt._)`Array.isArray(${t})`, () => {
    r.assign(tn.default.vErrors, (0, xt._)`${tn.default.vErrors} === null ? ${t} : ${tn.default.vErrors}.concat(${t})`).assign(tn.default.errors, (0, xt._)`${tn.default.vErrors}.length`), (0, J1.extendErrors)(e);
  }, () => e.error());
}
function Q1({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function Yb(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, xt.stringify)(r) });
}
function eT(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
cr.validSchemaType = eT;
function tT({ schema: e, opts: t, self: r, errSchemaPath: n }, s, i) {
  if (Array.isArray(s.keyword) ? !s.keyword.includes(i) : s.keyword !== i)
    throw new Error("ajv implementation error");
  const o = s.dependencies;
  if (o != null && o.some((a) => !Object.prototype.hasOwnProperty.call(e, a)))
    throw new Error(`parent schema must have dependencies of ${i}: ${o.join(",")}`);
  if (s.validateSchema && !s.validateSchema(e[i])) {
    const c = `keyword "${i}" value is invalid at path "${n}": ` + r.errorsText(s.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(c);
    else
      throw new Error(c);
  }
}
cr.validateKeywordUsage = tT;
var zr = {};
Object.defineProperty(zr, "__esModule", { value: !0 });
zr.extendSubschemaMode = zr.extendSubschemaData = zr.getSubschema = void 0;
const ar = ae, Xb = re;
function rT(e, { keyword: t, schemaProp: r, schema: n, schemaPath: s, errSchemaPath: i, topSchemaRef: o }) {
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const a = e.schema[t];
    return r === void 0 ? {
      schema: a,
      schemaPath: (0, ar._)`${e.schemaPath}${(0, ar.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: a[r],
      schemaPath: (0, ar._)`${e.schemaPath}${(0, ar.getProperty)(t)}${(0, ar.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, Xb.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (s === void 0 || i === void 0 || o === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: s,
      topSchemaRef: o,
      errSchemaPath: i
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
zr.getSubschema = rT;
function nT(e, t, { dataProp: r, dataPropType: n, data: s, dataTypes: i, propertyName: o }) {
  if (s !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = t;
  if (r !== void 0) {
    const { errorPath: f, dataPathArr: l, opts: d } = t, g = a.let("data", (0, ar._)`${t.data}${(0, ar.getProperty)(r)}`, !0);
    c(g), e.errorPath = (0, ar.str)`${f}${(0, Xb.getErrorPath)(r, n, d.jsPropertySyntax)}`, e.parentDataProperty = (0, ar._)`${r}`, e.dataPathArr = [...l, e.parentDataProperty];
  }
  if (s !== void 0) {
    const f = s instanceof ar.Name ? s : a.let("data", s, !0);
    c(f), o !== void 0 && (e.propertyName = o);
  }
  i && (e.dataTypes = i);
  function c(f) {
    e.data = f, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, f];
  }
}
zr.extendSubschemaData = nT;
function sT(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: s, allErrors: i }) {
  n !== void 0 && (e.compositeRule = n), s !== void 0 && (e.createErrors = s), i !== void 0 && (e.allErrors = i), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
zr.extendSubschemaMode = sT;
var ut = {}, ba = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var n, s, i;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length) return !1;
      for (s = n; s-- !== 0; )
        if (!e(t[s], r[s])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
    if (i = Object.keys(t), n = i.length, n !== Object.keys(r).length) return !1;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, i[s])) return !1;
    for (s = n; s-- !== 0; ) {
      var o = i[s];
      if (!e(t[o], r[o])) return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, Zb = { exports: {} }, Dr = Zb.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, s = r.post || function() {
  };
  po(t, n, s, e, "", e);
};
Dr.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
Dr.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
Dr.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
Dr.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function po(e, t, r, n, s, i, o, a, c, f) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, s, i, o, a, c, f);
    for (var l in n) {
      var d = n[l];
      if (Array.isArray(d)) {
        if (l in Dr.arrayKeywords)
          for (var g = 0; g < d.length; g++)
            po(e, t, r, d[g], s + "/" + l + "/" + g, i, s, l, n, g);
      } else if (l in Dr.propsKeywords) {
        if (d && typeof d == "object")
          for (var p in d)
            po(e, t, r, d[p], s + "/" + l + "/" + iT(p), i, s, l, n, p);
      } else (l in Dr.keywords || e.allKeys && !(l in Dr.skipKeywords)) && po(e, t, r, d, s + "/" + l, i, s, l, n);
    }
    r(n, s, i, o, a, c, f);
  }
}
function iT(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var oT = Zb.exports;
Object.defineProperty(ut, "__esModule", { value: !0 });
ut.getSchemaRefs = ut.resolveUrl = ut.normalizeId = ut._getFullPath = ut.getFullPath = ut.inlineRef = void 0;
const aT = re, cT = ba, lT = oT, uT = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function fT(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !mu(e) : t ? Qb(e) <= t : !1;
}
ut.inlineRef = fT;
const dT = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function mu(e) {
  for (const t in e) {
    if (dT.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(mu) || typeof r == "object" && mu(r))
      return !0;
  }
  return !1;
}
function Qb(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !uT.has(r) && (typeof e[r] == "object" && (0, aT.eachItem)(e[r], (n) => t += Qb(n)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function e0(e, t = "", r) {
  r !== !1 && (t = Hn(t));
  const n = e.parse(t);
  return t0(e, n);
}
ut.getFullPath = e0;
function t0(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
ut._getFullPath = t0;
const pT = /#\/?$/;
function Hn(e) {
  return e ? e.replace(pT, "") : "";
}
ut.normalizeId = Hn;
function hT(e, t, r) {
  return r = Hn(r), e.resolve(t, r);
}
ut.resolveUrl = hT;
const mT = /^[a-z_][-a-z0-9._]*$/i;
function yT(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, s = Hn(e[r] || t), i = { "": s }, o = e0(n, s, !1), a = {}, c = /* @__PURE__ */ new Set();
  return lT(e, { allKeys: !0 }, (d, g, p, u) => {
    if (u === void 0)
      return;
    const h = o + g;
    let b = i[u];
    typeof d[r] == "string" && (b = m.call(this, d[r])), v.call(this, d.$anchor), v.call(this, d.$dynamicAnchor), i[g] = b;
    function m(y) {
      const _ = this.opts.uriResolver.resolve;
      if (y = Hn(b ? _(b, y) : y), c.has(y))
        throw l(y);
      c.add(y);
      let R = this.refs[y];
      return typeof R == "string" && (R = this.refs[R]), typeof R == "object" ? f(d, R.schema, y) : y !== Hn(h) && (y[0] === "#" ? (f(d, a[y], y), a[y] = d) : this.refs[y] = h), y;
    }
    function v(y) {
      if (typeof y == "string") {
        if (!mT.test(y))
          throw new Error(`invalid anchor "${y}"`);
        m.call(this, `#${y}`);
      }
    }
  }), a;
  function f(d, g, p) {
    if (g !== void 0 && !cT(d, g))
      throw l(p);
  }
  function l(d) {
    return new Error(`reference "${d}" resolves to more than one schema`);
  }
}
ut.getSchemaRefs = yT;
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.getData = Ut.KeywordCxt = Ut.validateFunctionCode = void 0;
const r0 = Wn, qh = tt, Rf = br, Do = tt, gT = va, Ls = cr, Vc = zr, ie = ae, ue = jt, vT = ut, _r = re, ys = di;
function bT(e) {
  if (i0(e) && (o0(e), s0(e))) {
    xT(e);
    return;
  }
  n0(e, () => (0, r0.topBoolOrEmptySchema)(e));
}
Ut.validateFunctionCode = bT;
function n0({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: s }, i) {
  s.code.es5 ? e.func(t, (0, ie._)`${ue.default.data}, ${ue.default.valCxt}`, n.$async, () => {
    e.code((0, ie._)`"use strict"; ${Hh(r, s)}`), ET(e, s), e.code(i);
  }) : e.func(t, (0, ie._)`${ue.default.data}, ${_T(s)}`, n.$async, () => e.code(Hh(r, s)).code(i));
}
function _T(e) {
  return (0, ie._)`{${ue.default.instancePath}="", ${ue.default.parentData}, ${ue.default.parentDataProperty}, ${ue.default.rootData}=${ue.default.data}${e.dynamicRef ? (0, ie._)`, ${ue.default.dynamicAnchors}={}` : ie.nil}}={}`;
}
function ET(e, t) {
  e.if(ue.default.valCxt, () => {
    e.var(ue.default.instancePath, (0, ie._)`${ue.default.valCxt}.${ue.default.instancePath}`), e.var(ue.default.parentData, (0, ie._)`${ue.default.valCxt}.${ue.default.parentData}`), e.var(ue.default.parentDataProperty, (0, ie._)`${ue.default.valCxt}.${ue.default.parentDataProperty}`), e.var(ue.default.rootData, (0, ie._)`${ue.default.valCxt}.${ue.default.rootData}`), t.dynamicRef && e.var(ue.default.dynamicAnchors, (0, ie._)`${ue.default.valCxt}.${ue.default.dynamicAnchors}`);
  }, () => {
    e.var(ue.default.instancePath, (0, ie._)`""`), e.var(ue.default.parentData, (0, ie._)`undefined`), e.var(ue.default.parentDataProperty, (0, ie._)`undefined`), e.var(ue.default.rootData, ue.default.data), t.dynamicRef && e.var(ue.default.dynamicAnchors, (0, ie._)`{}`);
  });
}
function xT(e) {
  const { schema: t, opts: r, gen: n } = e;
  n0(e, () => {
    r.$comment && t.$comment && c0(e), TT(e), n.let(ue.default.vErrors, null), n.let(ue.default.errors, 0), r.unevaluated && ST(e), a0(e), CT(e);
  });
}
function ST(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, ie._)`${r}.evaluated`), t.if((0, ie._)`${e.evaluated}.dynamicProps`, () => t.assign((0, ie._)`${e.evaluated}.props`, (0, ie._)`undefined`)), t.if((0, ie._)`${e.evaluated}.dynamicItems`, () => t.assign((0, ie._)`${e.evaluated}.items`, (0, ie._)`undefined`));
}
function Hh(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, ie._)`/*# sourceURL=${r} */` : ie.nil;
}
function wT(e, t) {
  if (i0(e) && (o0(e), s0(e))) {
    RT(e, t);
    return;
  }
  (0, r0.boolOrEmptySchema)(e, t);
}
function s0({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
function i0(e) {
  return typeof e.schema != "boolean";
}
function RT(e, t) {
  const { schema: r, gen: n, opts: s } = e;
  s.$comment && r.$comment && c0(e), OT(e), PT(e);
  const i = n.const("_errs", ue.default.errors);
  a0(e, i), n.var(t, (0, ie._)`${i} === ${ue.default.errors}`);
}
function o0(e) {
  (0, _r.checkUnknownRules)(e), $T(e);
}
function a0(e, t) {
  if (e.opts.jtd)
    return Bh(e, [], !1, t);
  const r = (0, qh.getSchemaTypes)(e.schema), n = (0, qh.coerceAndCheckDataType)(e, r);
  Bh(e, r, !n, t);
}
function $T(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: s } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, _r.schemaHasRulesButRef)(t, s.RULES) && s.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function TT(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, _r.checkStrictMode)(e, "default is ignored in the schema root");
}
function OT(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, vT.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function PT(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function c0({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: s }) {
  const i = r.$comment;
  if (s.$comment === !0)
    e.code((0, ie._)`${ue.default.self}.logger.log(${i})`);
  else if (typeof s.$comment == "function") {
    const o = (0, ie.str)`${n}/$comment`, a = e.scopeValue("root", { ref: t.root });
    e.code((0, ie._)`${ue.default.self}.opts.$comment(${i}, ${o}, ${a}.schema)`);
  }
}
function CT(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: s, opts: i } = e;
  r.$async ? t.if((0, ie._)`${ue.default.errors} === 0`, () => t.return(ue.default.data), () => t.throw((0, ie._)`new ${s}(${ue.default.vErrors})`)) : (t.assign((0, ie._)`${n}.errors`, ue.default.vErrors), i.unevaluated && IT(e), t.return((0, ie._)`${ue.default.errors} === 0`));
}
function IT({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof ie.Name && e.assign((0, ie._)`${t}.props`, r), n instanceof ie.Name && e.assign((0, ie._)`${t}.items`, n);
}
function Bh(e, t, r, n) {
  const { gen: s, schema: i, data: o, allErrors: a, opts: c, self: f } = e, { RULES: l } = f;
  if (i.$ref && (c.ignoreKeywordsWithRef || !(0, _r.schemaHasRulesButRef)(i, l))) {
    s.block(() => f0(e, "$ref", l.all.$ref.definition));
    return;
  }
  c.jtd || NT(e, t), s.block(() => {
    for (const g of l.rules)
      d(g);
    d(l.post);
  });
  function d(g) {
    (0, Rf.shouldUseGroup)(i, g) && (g.type ? (s.if((0, Do.checkDataType)(g.type, o, c.strictNumbers)), Vh(e, g), t.length === 1 && t[0] === g.type && r && (s.else(), (0, Do.reportTypeError)(e)), s.endIf()) : Vh(e, g), a || s.if((0, ie._)`${ue.default.errors} === ${n || 0}`));
  }
}
function Vh(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: s } } = e;
  s && (0, gT.assignDefaults)(e, t.type), r.block(() => {
    for (const i of t.rules)
      (0, Rf.shouldUseRule)(n, i) && f0(e, i.keyword, i.definition, t.type);
  });
}
function NT(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (AT(e, t), e.opts.allowUnionTypes || kT(e, t), LT(e, e.dataTypes));
}
function AT(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      l0(e.dataTypes, r) || $f(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), DT(e, t);
  }
}
function kT(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && $f(e, "use allowUnionTypes to allow union type keyword");
}
function LT(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const s = r[n];
    if (typeof s == "object" && (0, Rf.shouldUseRule)(e.schema, s)) {
      const { type: i } = s.definition;
      i.length && !i.some((o) => jT(t, o)) && $f(e, `missing type "${i.join(",")}" for keyword "${n}"`);
    }
  }
}
function jT(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function l0(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function DT(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    l0(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function $f(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, _r.checkStrictMode)(e, t, e.opts.strictTypes);
}
class u0 {
  constructor(t, r, n) {
    if ((0, Ls.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, _r.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", d0(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Ls.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", ue.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, ie.not)(t), r, n);
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, ie.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, ie._)`${r} !== undefined && (${(0, ie.or)(this.invalid$data(), t)})`);
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
    (t ? ys.reportExtraError : ys.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, ys.reportError)(this, this.def.$dataError || ys.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, ys.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, n = ie.nil) {
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
  check$data(t = ie.nil, r = ie.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: s, schemaType: i, def: o } = this;
    n.if((0, ie.or)((0, ie._)`${s} === undefined`, r)), t !== ie.nil && n.assign(t, !0), (i.length || o.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== ie.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: s, it: i } = this;
    return (0, ie.or)(o(), a());
    function o() {
      if (n.length) {
        if (!(r instanceof ie.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(n) ? n : [n];
        return (0, ie._)`${(0, Do.checkDataTypes)(c, r, i.opts.strictNumbers, Do.DataType.Wrong)}`;
      }
      return ie.nil;
    }
    function a() {
      if (s.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: s.validateSchema });
        return (0, ie._)`!${c}(${r})`;
      }
      return ie.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Vc.getSubschema)(this.it, t);
    (0, Vc.extendSubschemaData)(n, this.it, t), (0, Vc.extendSubschemaMode)(n, t);
    const s = { ...this.it, ...n, items: void 0, props: void 0 };
    return wT(s, r), s;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: s } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = _r.mergeEvaluated.props(s, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = _r.mergeEvaluated.items(s, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: s } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return s.if(r, () => this.mergeEvaluated(t, ie.Name)), !0;
  }
}
Ut.KeywordCxt = u0;
function f0(e, t, r, n) {
  const s = new u0(e, r, t);
  "code" in r ? r.code(s, n) : s.$data && r.validate ? (0, Ls.funcKeywordCode)(s, r) : "macro" in r ? (0, Ls.macroKeywordCode)(s, r) : (r.compile || r.validate) && (0, Ls.funcKeywordCode)(s, r);
}
const FT = /^\/(?:[^~]|~0|~1)*$/, MT = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function d0(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let s, i;
  if (e === "")
    return ue.default.rootData;
  if (e[0] === "/") {
    if (!FT.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    s = e, i = ue.default.rootData;
  } else {
    const f = MT.exec(e);
    if (!f)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const l = +f[1];
    if (s = f[2], s === "#") {
      if (l >= t)
        throw new Error(c("property/index", l));
      return n[t - l];
    }
    if (l > t)
      throw new Error(c("data", l));
    if (i = r[t - l], !s)
      return i;
  }
  let o = i;
  const a = s.split("/");
  for (const f of a)
    f && (i = (0, ie._)`${i}${(0, ie.getProperty)((0, _r.unescapeJsonPointer)(f))}`, o = (0, ie._)`${o} && ${i}`);
  return o;
  function c(f, l) {
    return `Cannot access ${f} ${l} levels up, current level is ${t}`;
  }
}
Ut.getData = d0;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
class zT extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
ss.default = zT;
var mr = {};
Object.defineProperty(mr, "__esModule", { value: !0 });
const Gc = ut;
class UT extends Error {
  constructor(t, r, n, s) {
    super(s || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, Gc.resolveUrl)(t, r, n), this.missingSchema = (0, Gc.normalizeId)((0, Gc.getFullPath)(t, this.missingRef));
  }
}
mr.default = UT;
var ft = {};
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.resolveSchema = ft.getCompilingSchema = ft.resolveRef = ft.compileSchema = ft.SchemaEnv = void 0;
const Gt = ae, qT = ss, Gr = jt, Jt = ut, Gh = re, HT = Ut;
class _a {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Jt.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
ft.SchemaEnv = _a;
function Tf(e) {
  const t = p0.call(this, e);
  if (t)
    return t;
  const r = (0, Jt.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, o = new Gt.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i });
  let a;
  e.$async && (a = o.scopeValue("Error", {
    ref: qT.default,
    code: (0, Gt._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = o.scopeName("validate");
  e.validateName = c;
  const f = {
    gen: o,
    allErrors: this.opts.allErrors,
    data: Gr.default.data,
    parentData: Gr.default.parentData,
    parentDataProperty: Gr.default.parentDataProperty,
    dataNames: [Gr.default.data],
    dataPathArr: [Gt.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: o.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, Gt.stringify)(e.schema) } : { ref: e.schema }),
    validateName: c,
    ValidationError: a,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: Gt.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Gt._)`""`,
    opts: this.opts,
    self: this
  };
  let l;
  try {
    this._compilations.add(e), (0, HT.validateFunctionCode)(f), o.optimize(this.opts.code.optimize);
    const d = o.toString();
    l = `${o.scopeRefs(Gr.default.scope)}return ${d}`, this.opts.code.process && (l = this.opts.code.process(l, e));
    const p = new Function(`${Gr.default.self}`, `${Gr.default.scope}`, l)(this, this.scope.get());
    if (this.scope.value(c, { ref: p }), p.errors = null, p.schema = e.schema, p.schemaEnv = e, e.$async && (p.$async = !0), this.opts.code.source === !0 && (p.source = { validateName: c, validateCode: d, scopeValues: o._values }), this.opts.unevaluated) {
      const { props: u, items: h } = f;
      p.evaluated = {
        props: u instanceof Gt.Name ? void 0 : u,
        items: h instanceof Gt.Name ? void 0 : h,
        dynamicProps: u instanceof Gt.Name,
        dynamicItems: h instanceof Gt.Name
      }, p.source && (p.source.evaluated = (0, Gt.stringify)(p.evaluated));
    }
    return e.validate = p, e;
  } catch (d) {
    throw delete e.validate, delete e.validateName, l && this.logger.error("Error compiling schema, function code:", l), d;
  } finally {
    this._compilations.delete(e);
  }
}
ft.compileSchema = Tf;
function BT(e, t, r) {
  var n;
  r = (0, Jt.resolveUrl)(this.opts.uriResolver, t, r);
  const s = e.refs[r];
  if (s)
    return s;
  let i = WT.call(this, e, r);
  if (i === void 0) {
    const o = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: a } = this.opts;
    o && (i = new _a({ schema: o, schemaId: a, root: e, baseId: t }));
  }
  if (i !== void 0)
    return e.refs[r] = VT.call(this, i);
}
ft.resolveRef = BT;
function VT(e) {
  return (0, Jt.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : Tf.call(this, e);
}
function p0(e) {
  for (const t of this._compilations)
    if (GT(t, e))
      return t;
}
ft.getCompilingSchema = p0;
function GT(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function WT(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Ea.call(this, e, t);
}
function Ea(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, Jt._getFullPath)(this.opts.uriResolver, r);
  let s = (0, Jt.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === s)
    return Wc.call(this, r, e);
  const i = (0, Jt.normalizeId)(n), o = this.refs[i] || this.schemas[i];
  if (typeof o == "string") {
    const a = Ea.call(this, e, o);
    return typeof (a == null ? void 0 : a.schema) != "object" ? void 0 : Wc.call(this, r, a);
  }
  if (typeof (o == null ? void 0 : o.schema) == "object") {
    if (o.validate || Tf.call(this, o), i === (0, Jt.normalizeId)(t)) {
      const { schema: a } = o, { schemaId: c } = this.opts, f = a[c];
      return f && (s = (0, Jt.resolveUrl)(this.opts.uriResolver, s, f)), new _a({ schema: a, schemaId: c, root: e, baseId: s });
    }
    return Wc.call(this, r, o);
  }
}
ft.resolveSchema = Ea;
const KT = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Wc(e, { baseId: t, schema: r, root: n }) {
  var s;
  if (((s = e.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/")
    return;
  for (const a of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const c = r[(0, Gh.unescapeFragment)(a)];
    if (c === void 0)
      return;
    r = c;
    const f = typeof r == "object" && r[this.opts.schemaId];
    !KT.has(a) && f && (t = (0, Jt.resolveUrl)(this.opts.uriResolver, t, f));
  }
  let i;
  if (typeof r != "boolean" && r.$ref && !(0, Gh.schemaHasRulesButRef)(r, this.RULES)) {
    const a = (0, Jt.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    i = Ea.call(this, n, a);
  }
  const { schemaId: o } = this.opts;
  if (i = i || new _a({ schema: r, schemaId: o, root: n, baseId: t }), i.schema !== i.root.schema)
    return i;
}
const JT = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", YT = "Meta-schema for $data reference (JSON AnySchema extension proposal)", XT = "object", ZT = [
  "$data"
], QT = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, eO = !1, tO = {
  $id: JT,
  description: YT,
  type: XT,
  required: ZT,
  properties: QT,
  additionalProperties: eO
};
var Of = {}, xa = { exports: {} };
const rO = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var nO = {
  HEX: rO
};
const { HEX: sO } = nO, iO = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
function h0(e) {
  if (y0(e, ".") < 3)
    return { host: e, isIPV4: !1 };
  const t = e.match(iO) || [], [r] = t;
  return r ? { host: aO(r, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
}
function Wh(e, t = !1) {
  let r = "", n = !0;
  for (const s of e) {
    if (sO[s] === void 0) return;
    s !== "0" && n === !0 && (n = !1), n || (r += s);
  }
  return t && r.length === 0 && (r = "0"), r;
}
function oO(e) {
  let t = 0;
  const r = { error: !1, address: "", zone: "" }, n = [], s = [];
  let i = !1, o = !1, a = !1;
  function c() {
    if (s.length) {
      if (i === !1) {
        const f = Wh(s);
        if (f !== void 0)
          n.push(f);
        else
          return r.error = !0, !1;
      }
      s.length = 0;
    }
    return !0;
  }
  for (let f = 0; f < e.length; f++) {
    const l = e[f];
    if (!(l === "[" || l === "]"))
      if (l === ":") {
        if (o === !0 && (a = !0), !c())
          break;
        if (t++, n.push(":"), t > 7) {
          r.error = !0;
          break;
        }
        f - 1 >= 0 && e[f - 1] === ":" && (o = !0);
        continue;
      } else if (l === "%") {
        if (!c())
          break;
        i = !0;
      } else {
        s.push(l);
        continue;
      }
  }
  return s.length && (i ? r.zone = s.join("") : a ? n.push(s.join("")) : n.push(Wh(s))), r.address = n.join(""), r;
}
function m0(e) {
  if (y0(e, ":") < 2)
    return { host: e, isIPV6: !1 };
  const t = oO(e);
  if (t.error)
    return { host: e, isIPV6: !1 };
  {
    let r = t.address, n = t.address;
    return t.zone && (r += "%" + t.zone, n += "%25" + t.zone), { host: r, escapedHost: n, isIPV6: !0 };
  }
}
function aO(e, t) {
  let r = "", n = !0;
  const s = e.length;
  for (let i = 0; i < s; i++) {
    const o = e[i];
    o === "0" && n ? (i + 1 <= s && e[i + 1] === t || i + 1 === s) && (r += o, n = !1) : (o === t ? n = !0 : n = !1, r += o);
  }
  return r;
}
function y0(e, t) {
  let r = 0;
  for (let n = 0; n < e.length; n++)
    e[n] === t && r++;
  return r;
}
const Kh = /^\.\.?\//u, Jh = /^\/\.(?:\/|$)/u, Yh = /^\/\.\.(?:\/|$)/u, cO = /^\/?(?:.|\n)*?(?=\/|$)/u;
function lO(e) {
  const t = [];
  for (; e.length; )
    if (e.match(Kh))
      e = e.replace(Kh, "");
    else if (e.match(Jh))
      e = e.replace(Jh, "/");
    else if (e.match(Yh))
      e = e.replace(Yh, "/"), t.pop();
    else if (e === "." || e === "..")
      e = "";
    else {
      const r = e.match(cO);
      if (r) {
        const n = r[0];
        e = e.slice(n.length), t.push(n);
      } else
        throw new Error("Unexpected dot segment condition");
    }
  return t.join("");
}
function uO(e, t) {
  const r = t !== !0 ? escape : unescape;
  return e.scheme !== void 0 && (e.scheme = r(e.scheme)), e.userinfo !== void 0 && (e.userinfo = r(e.userinfo)), e.host !== void 0 && (e.host = r(e.host)), e.path !== void 0 && (e.path = r(e.path)), e.query !== void 0 && (e.query = r(e.query)), e.fragment !== void 0 && (e.fragment = r(e.fragment)), e;
}
function fO(e) {
  const t = [];
  if (e.userinfo !== void 0 && (t.push(e.userinfo), t.push("@")), e.host !== void 0) {
    let r = unescape(e.host);
    const n = h0(r);
    if (n.isIPV4)
      r = n.host;
    else {
      const s = m0(n.host);
      s.isIPV6 === !0 ? r = `[${s.escapedHost}]` : r = e.host;
    }
    t.push(r);
  }
  return (typeof e.port == "number" || typeof e.port == "string") && (t.push(":"), t.push(String(e.port))), t.length ? t.join("") : void 0;
}
var dO = {
  recomposeAuthority: fO,
  normalizeComponentEncoding: uO,
  removeDotSegments: lO,
  normalizeIPv4: h0,
  normalizeIPv6: m0
};
const pO = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, hO = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function g0(e) {
  return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
}
function v0(e) {
  return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
}
function b0(e) {
  const t = String(e.scheme).toLowerCase() === "https";
  return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e;
}
function mO(e) {
  return e.secure = g0(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e;
}
function yO(e) {
  if ((e.port === (g0(e) ? 443 : 80) || e.port === "") && (e.port = void 0), typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
    const [t, r] = e.resourceName.split("?");
    e.path = t && t !== "/" ? t : void 0, e.query = r, e.resourceName = void 0;
  }
  return e.fragment = void 0, e;
}
function gO(e, t) {
  if (!e.path)
    return e.error = "URN can not be parsed", e;
  const r = e.path.match(hO);
  if (r) {
    const n = t.scheme || e.scheme || "urn";
    e.nid = r[1].toLowerCase(), e.nss = r[2];
    const s = `${n}:${t.nid || e.nid}`, i = Pf[s];
    e.path = void 0, i && (e = i.parse(e, t));
  } else
    e.error = e.error || "URN can not be parsed.";
  return e;
}
function vO(e, t) {
  const r = t.scheme || e.scheme || "urn", n = e.nid.toLowerCase(), s = `${r}:${t.nid || n}`, i = Pf[s];
  i && (e = i.serialize(e, t));
  const o = e, a = e.nss;
  return o.path = `${n || t.nid}:${a}`, t.skipEscape = !0, o;
}
function bO(e, t) {
  const r = e;
  return r.uuid = r.nss, r.nss = void 0, !t.tolerant && (!r.uuid || !pO.test(r.uuid)) && (r.error = r.error || "UUID is not valid."), r;
}
function _O(e) {
  const t = e;
  return t.nss = (e.uuid || "").toLowerCase(), t;
}
const _0 = {
  scheme: "http",
  domainHost: !0,
  parse: v0,
  serialize: b0
}, EO = {
  scheme: "https",
  domainHost: _0.domainHost,
  parse: v0,
  serialize: b0
}, ho = {
  scheme: "ws",
  domainHost: !0,
  parse: mO,
  serialize: yO
}, xO = {
  scheme: "wss",
  domainHost: ho.domainHost,
  parse: ho.parse,
  serialize: ho.serialize
}, SO = {
  scheme: "urn",
  parse: gO,
  serialize: vO,
  skipNormalize: !0
}, wO = {
  scheme: "urn:uuid",
  parse: bO,
  serialize: _O,
  skipNormalize: !0
}, Pf = {
  http: _0,
  https: EO,
  ws: ho,
  wss: xO,
  urn: SO,
  "urn:uuid": wO
};
var RO = Pf;
const { normalizeIPv6: $O, normalizeIPv4: TO, removeDotSegments: Is, recomposeAuthority: OO, normalizeComponentEncoding: ki } = dO, Cf = RO;
function PO(e, t) {
  return typeof e == "string" ? e = lr(Sr(e, t), t) : typeof e == "object" && (e = Sr(lr(e, t), t)), e;
}
function CO(e, t, r) {
  const n = Object.assign({ scheme: "null" }, r), s = E0(Sr(e, n), Sr(t, n), n, !0);
  return lr(s, { ...n, skipEscape: !0 });
}
function E0(e, t, r, n) {
  const s = {};
  return n || (e = Sr(lr(e, r), r), t = Sr(lr(t, r), r)), r = r || {}, !r.tolerant && t.scheme ? (s.scheme = t.scheme, s.userinfo = t.userinfo, s.host = t.host, s.port = t.port, s.path = Is(t.path || ""), s.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (s.userinfo = t.userinfo, s.host = t.host, s.port = t.port, s.path = Is(t.path || ""), s.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? s.path = Is(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? s.path = "/" + t.path : e.path ? s.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : s.path = t.path, s.path = Is(s.path)), s.query = t.query) : (s.path = e.path, t.query !== void 0 ? s.query = t.query : s.query = e.query), s.userinfo = e.userinfo, s.host = e.host, s.port = e.port), s.scheme = e.scheme), s.fragment = t.fragment, s;
}
function IO(e, t, r) {
  return typeof e == "string" ? (e = unescape(e), e = lr(ki(Sr(e, r), !0), { ...r, skipEscape: !0 })) : typeof e == "object" && (e = lr(ki(e, !0), { ...r, skipEscape: !0 })), typeof t == "string" ? (t = unescape(t), t = lr(ki(Sr(t, r), !0), { ...r, skipEscape: !0 })) : typeof t == "object" && (t = lr(ki(t, !0), { ...r, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase();
}
function lr(e, t) {
  const r = {
    host: e.host,
    scheme: e.scheme,
    userinfo: e.userinfo,
    port: e.port,
    path: e.path,
    query: e.query,
    nid: e.nid,
    nss: e.nss,
    uuid: e.uuid,
    fragment: e.fragment,
    reference: e.reference,
    resourceName: e.resourceName,
    secure: e.secure,
    error: ""
  }, n = Object.assign({}, t), s = [], i = Cf[(n.scheme || r.scheme || "").toLowerCase()];
  i && i.serialize && i.serialize(r, n), r.path !== void 0 && (n.skipEscape ? r.path = unescape(r.path) : (r.path = escape(r.path), r.scheme !== void 0 && (r.path = r.path.split("%3A").join(":")))), n.reference !== "suffix" && r.scheme && s.push(r.scheme, ":");
  const o = OO(r);
  if (o !== void 0 && (n.reference !== "suffix" && s.push("//"), s.push(o), r.path && r.path.charAt(0) !== "/" && s.push("/")), r.path !== void 0) {
    let a = r.path;
    !n.absolutePath && (!i || !i.absolutePath) && (a = Is(a)), o === void 0 && (a = a.replace(/^\/\//u, "/%2F")), s.push(a);
  }
  return r.query !== void 0 && s.push("?", r.query), r.fragment !== void 0 && s.push("#", r.fragment), s.join("");
}
const NO = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
function AO(e) {
  let t = 0;
  for (let r = 0, n = e.length; r < n; ++r)
    if (t = e.charCodeAt(r), t > 126 || NO[t])
      return !0;
  return !1;
}
const kO = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function Sr(e, t) {
  const r = Object.assign({}, t), n = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  }, s = e.indexOf("%") !== -1;
  let i = !1;
  r.reference === "suffix" && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e);
  const o = e.match(kO);
  if (o) {
    if (n.scheme = o[1], n.userinfo = o[3], n.host = o[4], n.port = parseInt(o[5], 10), n.path = o[6] || "", n.query = o[7], n.fragment = o[8], isNaN(n.port) && (n.port = o[5]), n.host) {
      const c = TO(n.host);
      if (c.isIPV4 === !1) {
        const f = $O(c.host);
        n.host = f.host.toLowerCase(), i = f.isIPV6;
      } else
        n.host = c.host, i = !0;
    }
    n.scheme === void 0 && n.userinfo === void 0 && n.host === void 0 && n.port === void 0 && n.query === void 0 && !n.path ? n.reference = "same-document" : n.scheme === void 0 ? n.reference = "relative" : n.fragment === void 0 ? n.reference = "absolute" : n.reference = "uri", r.reference && r.reference !== "suffix" && r.reference !== n.reference && (n.error = n.error || "URI is not a " + r.reference + " reference.");
    const a = Cf[(r.scheme || n.scheme || "").toLowerCase()];
    if (!r.unicodeSupport && (!a || !a.unicodeSupport) && n.host && (r.domainHost || a && a.domainHost) && i === !1 && AO(n.host))
      try {
        n.host = URL.domainToASCII(n.host.toLowerCase());
      } catch (c) {
        n.error = n.error || "Host's domain name can not be converted to ASCII: " + c;
      }
    (!a || a && !a.skipNormalize) && (s && n.scheme !== void 0 && (n.scheme = unescape(n.scheme)), s && n.host !== void 0 && (n.host = unescape(n.host)), n.path && (n.path = escape(unescape(n.path))), n.fragment && (n.fragment = encodeURI(decodeURIComponent(n.fragment)))), a && a.parse && a.parse(n, r);
  } else
    n.error = n.error || "URI can not be parsed.";
  return n;
}
const If = {
  SCHEMES: Cf,
  normalize: PO,
  resolve: CO,
  resolveComponents: E0,
  equal: IO,
  serialize: lr,
  parse: Sr
};
xa.exports = If;
xa.exports.default = If;
xa.exports.fastUri = If;
var Nf = xa.exports;
Object.defineProperty(Of, "__esModule", { value: !0 });
const x0 = Nf;
x0.code = 'require("ajv/dist/runtime/uri").default';
Of.default = x0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Ut;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = ae;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = ss, s = mr, i = dn, o = ft, a = ae, c = ut, f = tt, l = re, d = tO, g = Of, p = (k, C) => new RegExp(k, C);
  p.code = "new RegExp";
  const u = ["removeAdditional", "useDefaults", "coerceTypes"], h = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), b = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, m = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, v = 200;
  function y(k) {
    var C, D, F, w, N, q, K, V, Z, Y, J, H, W, G, ee, le, X, ce, _e, pe, he, Ge, we, _t, xn;
    const Pe = k.strict, Bt = (C = k.code) === null || C === void 0 ? void 0 : C.optimize, $r = Bt === !0 || Bt === void 0 ? 1 : Bt || 0, Te = (F = (D = k.code) === null || D === void 0 ? void 0 : D.regExp) !== null && F !== void 0 ? F : p, it = (w = k.uriResolver) !== null && w !== void 0 ? w : g.default;
    return {
      strictSchema: (q = (N = k.strictSchema) !== null && N !== void 0 ? N : Pe) !== null && q !== void 0 ? q : !0,
      strictNumbers: (V = (K = k.strictNumbers) !== null && K !== void 0 ? K : Pe) !== null && V !== void 0 ? V : !0,
      strictTypes: (Y = (Z = k.strictTypes) !== null && Z !== void 0 ? Z : Pe) !== null && Y !== void 0 ? Y : "log",
      strictTuples: (H = (J = k.strictTuples) !== null && J !== void 0 ? J : Pe) !== null && H !== void 0 ? H : "log",
      strictRequired: (G = (W = k.strictRequired) !== null && W !== void 0 ? W : Pe) !== null && G !== void 0 ? G : !1,
      code: k.code ? { ...k.code, optimize: $r, regExp: Te } : { optimize: $r, regExp: Te },
      loopRequired: (ee = k.loopRequired) !== null && ee !== void 0 ? ee : v,
      loopEnum: (le = k.loopEnum) !== null && le !== void 0 ? le : v,
      meta: (X = k.meta) !== null && X !== void 0 ? X : !0,
      messages: (ce = k.messages) !== null && ce !== void 0 ? ce : !0,
      inlineRefs: (_e = k.inlineRefs) !== null && _e !== void 0 ? _e : !0,
      schemaId: (pe = k.schemaId) !== null && pe !== void 0 ? pe : "$id",
      addUsedSchema: (he = k.addUsedSchema) !== null && he !== void 0 ? he : !0,
      validateSchema: (Ge = k.validateSchema) !== null && Ge !== void 0 ? Ge : !0,
      validateFormats: (we = k.validateFormats) !== null && we !== void 0 ? we : !0,
      unicodeRegExp: (_t = k.unicodeRegExp) !== null && _t !== void 0 ? _t : !0,
      int32range: (xn = k.int32range) !== null && xn !== void 0 ? xn : !0,
      uriResolver: it
    };
  }
  class _ {
    constructor(C = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), C = this.opts = { ...C, ...y(C) };
      const { es5: D, lines: F } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: h, es5: D, lines: F }), this.logger = U(C.logger);
      const w = C.validateFormats;
      C.validateFormats = !1, this.RULES = (0, i.getRules)(), R.call(this, b, C, "NOT SUPPORTED"), R.call(this, m, C, "DEPRECATED", "warn"), this._metaOpts = L.call(this), C.formats && z.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), C.keywords && x.call(this, C.keywords), typeof C.meta == "object" && this.addMetaSchema(C.meta), O.call(this), C.validateFormats = w;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: C, meta: D, schemaId: F } = this.opts;
      let w = d;
      F === "id" && (w = { ...d }, w.id = w.$id, delete w.$id), D && C && this.addMetaSchema(w, w[F], !1);
    }
    defaultMeta() {
      const { meta: C, schemaId: D } = this.opts;
      return this.opts.defaultMeta = typeof C == "object" ? C[D] || C : void 0;
    }
    validate(C, D) {
      let F;
      if (typeof C == "string") {
        if (F = this.getSchema(C), !F)
          throw new Error(`no schema with key or ref "${C}"`);
      } else
        F = this.compile(C);
      const w = F(D);
      return "$async" in F || (this.errors = F.errors), w;
    }
    compile(C, D) {
      const F = this._addSchema(C, D);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(C, D) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return w.call(this, C, D);
      async function w(Y, J) {
        await N.call(this, Y.$schema);
        const H = this._addSchema(Y, J);
        return H.validate || q.call(this, H);
      }
      async function N(Y) {
        Y && !this.getSchema(Y) && await w.call(this, { $ref: Y }, !0);
      }
      async function q(Y) {
        try {
          return this._compileSchemaEnv(Y);
        } catch (J) {
          if (!(J instanceof s.default))
            throw J;
          return K.call(this, J), await V.call(this, J.missingSchema), q.call(this, Y);
        }
      }
      function K({ missingSchema: Y, missingRef: J }) {
        if (this.refs[Y])
          throw new Error(`AnySchema ${Y} is loaded but ${J} cannot be resolved`);
      }
      async function V(Y) {
        const J = await Z.call(this, Y);
        this.refs[Y] || await N.call(this, J.$schema), this.refs[Y] || this.addSchema(J, Y, D);
      }
      async function Z(Y) {
        const J = this._loading[Y];
        if (J)
          return J;
        try {
          return await (this._loading[Y] = F(Y));
        } finally {
          delete this._loading[Y];
        }
      }
    }
    // Adds schema to the instance
    addSchema(C, D, F, w = this.opts.validateSchema) {
      if (Array.isArray(C)) {
        for (const q of C)
          this.addSchema(q, void 0, F, w);
        return this;
      }
      let N;
      if (typeof C == "object") {
        const { schemaId: q } = this.opts;
        if (N = C[q], N !== void 0 && typeof N != "string")
          throw new Error(`schema ${q} must be string`);
      }
      return D = (0, c.normalizeId)(D || N), this._checkUnique(D), this.schemas[D] = this._addSchema(C, F, D, w, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(C, D, F = this.opts.validateSchema) {
      return this.addSchema(C, D, !0, F), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(C, D) {
      if (typeof C == "boolean")
        return !0;
      let F;
      if (F = C.$schema, F !== void 0 && typeof F != "string")
        throw new Error("$schema must be a string");
      if (F = F || this.opts.defaultMeta || this.defaultMeta(), !F)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const w = this.validate(F, C);
      if (!w && D) {
        const N = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(N);
        else
          throw new Error(N);
      }
      return w;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(C) {
      let D;
      for (; typeof (D = E.call(this, C)) == "string"; )
        C = D;
      if (D === void 0) {
        const { schemaId: F } = this.opts, w = new o.SchemaEnv({ schema: {}, schemaId: F });
        if (D = o.resolveSchema.call(this, w, C), !D)
          return;
        this.refs[C] = D;
      }
      return D.validate || this._compileSchemaEnv(D);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(C) {
      if (C instanceof RegExp)
        return this._removeAllSchemas(this.schemas, C), this._removeAllSchemas(this.refs, C), this;
      switch (typeof C) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const D = E.call(this, C);
          return typeof D == "object" && this._cache.delete(D.schema), delete this.schemas[C], delete this.refs[C], this;
        }
        case "object": {
          const D = C;
          this._cache.delete(D);
          let F = C[this.opts.schemaId];
          return F && (F = (0, c.normalizeId)(F), delete this.schemas[F], delete this.refs[F]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(C) {
      for (const D of C)
        this.addKeyword(D);
      return this;
    }
    addKeyword(C, D) {
      let F;
      if (typeof C == "string")
        F = C, typeof D == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), D.keyword = F);
      else if (typeof C == "object" && D === void 0) {
        if (D = C, F = D.keyword, Array.isArray(F) && !F.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (S.call(this, F, D), !D)
        return (0, l.eachItem)(F, (N) => I.call(this, N)), this;
      j.call(this, D);
      const w = {
        ...D,
        type: (0, f.getJSONTypes)(D.type),
        schemaType: (0, f.getJSONTypes)(D.schemaType)
      };
      return (0, l.eachItem)(F, w.type.length === 0 ? (N) => I.call(this, N, w) : (N) => w.type.forEach((q) => I.call(this, N, w, q))), this;
    }
    getKeyword(C) {
      const D = this.RULES.all[C];
      return typeof D == "object" ? D.definition : !!D;
    }
    // Remove keyword
    removeKeyword(C) {
      const { RULES: D } = this;
      delete D.keywords[C], delete D.all[C];
      for (const F of D.rules) {
        const w = F.rules.findIndex((N) => N.keyword === C);
        w >= 0 && F.rules.splice(w, 1);
      }
      return this;
    }
    // Add format
    addFormat(C, D) {
      return typeof D == "string" && (D = new RegExp(D)), this.formats[C] = D, this;
    }
    errorsText(C = this.errors, { separator: D = ", ", dataVar: F = "data" } = {}) {
      return !C || C.length === 0 ? "No errors" : C.map((w) => `${F}${w.instancePath} ${w.message}`).reduce((w, N) => w + D + N);
    }
    $dataMetaSchema(C, D) {
      const F = this.RULES.all;
      C = JSON.parse(JSON.stringify(C));
      for (const w of D) {
        const N = w.split("/").slice(1);
        let q = C;
        for (const K of N)
          q = q[K];
        for (const K in F) {
          const V = F[K];
          if (typeof V != "object")
            continue;
          const { $data: Z } = V.definition, Y = q[K];
          Z && Y && (q[K] = A(Y));
        }
      }
      return C;
    }
    _removeAllSchemas(C, D) {
      for (const F in C) {
        const w = C[F];
        (!D || D.test(F)) && (typeof w == "string" ? delete C[F] : w && !w.meta && (this._cache.delete(w.schema), delete C[F]));
      }
    }
    _addSchema(C, D, F, w = this.opts.validateSchema, N = this.opts.addUsedSchema) {
      let q;
      const { schemaId: K } = this.opts;
      if (typeof C == "object")
        q = C[K];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof C != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let V = this._cache.get(C);
      if (V !== void 0)
        return V;
      F = (0, c.normalizeId)(q || F);
      const Z = c.getSchemaRefs.call(this, C, F);
      return V = new o.SchemaEnv({ schema: C, schemaId: K, meta: D, baseId: F, localRefs: Z }), this._cache.set(V.schema, V), N && !F.startsWith("#") && (F && this._checkUnique(F), this.refs[F] = V), w && this.validateSchema(C, !0), V;
    }
    _checkUnique(C) {
      if (this.schemas[C] || this.refs[C])
        throw new Error(`schema with key or id "${C}" already exists`);
    }
    _compileSchemaEnv(C) {
      if (C.meta ? this._compileMetaSchema(C) : o.compileSchema.call(this, C), !C.validate)
        throw new Error("ajv implementation error");
      return C.validate;
    }
    _compileMetaSchema(C) {
      const D = this.opts;
      this.opts = this._metaOpts;
      try {
        o.compileSchema.call(this, C);
      } finally {
        this.opts = D;
      }
    }
  }
  _.ValidationError = n.default, _.MissingRefError = s.default, e.default = _;
  function R(k, C, D, F = "error") {
    for (const w in k) {
      const N = w;
      N in C && this.logger[F](`${D}: option ${w}. ${k[N]}`);
    }
  }
  function E(k) {
    return k = (0, c.normalizeId)(k), this.schemas[k] || this.refs[k];
  }
  function O() {
    const k = this.opts.schemas;
    if (k)
      if (Array.isArray(k))
        this.addSchema(k);
      else
        for (const C in k)
          this.addSchema(k[C], C);
  }
  function z() {
    for (const k in this.opts.formats) {
      const C = this.opts.formats[k];
      C && this.addFormat(k, C);
    }
  }
  function x(k) {
    if (Array.isArray(k)) {
      this.addVocabulary(k);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const C in k) {
      const D = k[C];
      D.keyword || (D.keyword = C), this.addKeyword(D);
    }
  }
  function L() {
    const k = { ...this.opts };
    for (const C of u)
      delete k[C];
    return k;
  }
  const M = { log() {
  }, warn() {
  }, error() {
  } };
  function U(k) {
    if (k === !1)
      return M;
    if (k === void 0)
      return console;
    if (k.log && k.warn && k.error)
      return k;
    throw new Error("logger must implement log, warn and error methods");
  }
  const $ = /^[a-z_$][a-z0-9_$:-]*$/i;
  function S(k, C) {
    const { RULES: D } = this;
    if ((0, l.eachItem)(k, (F) => {
      if (D.keywords[F])
        throw new Error(`Keyword ${F} is already defined`);
      if (!$.test(F))
        throw new Error(`Keyword ${F} has invalid name`);
    }), !!C && C.$data && !("code" in C || "validate" in C))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function I(k, C, D) {
    var F;
    const w = C == null ? void 0 : C.post;
    if (D && w)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: N } = this;
    let q = w ? N.post : N.rules.find(({ type: V }) => V === D);
    if (q || (q = { type: D, rules: [] }, N.rules.push(q)), N.keywords[k] = !0, !C)
      return;
    const K = {
      keyword: k,
      definition: {
        ...C,
        type: (0, f.getJSONTypes)(C.type),
        schemaType: (0, f.getJSONTypes)(C.schemaType)
      }
    };
    C.before ? T.call(this, q, K, C.before) : q.rules.push(K), N.all[k] = K, (F = C.implements) === null || F === void 0 || F.forEach((V) => this.addKeyword(V));
  }
  function T(k, C, D) {
    const F = k.rules.findIndex((w) => w.keyword === D);
    F >= 0 ? k.rules.splice(F, 0, C) : (k.rules.push(C), this.logger.warn(`rule ${D} is not defined`));
  }
  function j(k) {
    let { metaSchema: C } = k;
    C !== void 0 && (k.$data && this.opts.$data && (C = A(C)), k.validateSchema = this.compile(C, !0));
  }
  const P = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function A(k) {
    return { anyOf: [k, P] };
  }
})(gf);
var Af = {}, kf = {}, Lf = {};
Object.defineProperty(Lf, "__esModule", { value: !0 });
const LO = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
Lf.default = LO;
var qr = {};
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.callRef = qr.getValidate = void 0;
const jO = mr, Xh = fe, Rt = ae, $n = jt, Zh = ft, Li = re, DO = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: s, schemaEnv: i, validateName: o, opts: a, self: c } = n, { root: f } = i;
    if ((r === "#" || r === "#/") && s === f.baseId)
      return d();
    const l = Zh.resolveRef.call(c, f, s, r);
    if (l === void 0)
      throw new jO.default(n.opts.uriResolver, s, r);
    if (l instanceof Zh.SchemaEnv)
      return g(l);
    return p(l);
    function d() {
      if (i === f)
        return mo(e, o, i, i.$async);
      const u = t.scopeValue("root", { ref: f });
      return mo(e, (0, Rt._)`${u}.validate`, f, f.$async);
    }
    function g(u) {
      const h = S0(e, u);
      mo(e, h, u, u.$async);
    }
    function p(u) {
      const h = t.scopeValue("schema", a.code.source === !0 ? { ref: u, code: (0, Rt.stringify)(u) } : { ref: u }), b = t.name("valid"), m = e.subschema({
        schema: u,
        dataTypes: [],
        schemaPath: Rt.nil,
        topSchemaRef: h,
        errSchemaPath: r
      }, b);
      e.mergeEvaluated(m), e.ok(b);
    }
  }
};
function S0(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Rt._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
qr.getValidate = S0;
function mo(e, t, r, n) {
  const { gen: s, it: i } = e, { allErrors: o, schemaEnv: a, opts: c } = i, f = c.passContext ? $n.default.this : Rt.nil;
  n ? l() : d();
  function l() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const u = s.let("valid");
    s.try(() => {
      s.code((0, Rt._)`await ${(0, Xh.callValidateCode)(e, t, f)}`), p(t), o || s.assign(u, !0);
    }, (h) => {
      s.if((0, Rt._)`!(${h} instanceof ${i.ValidationError})`, () => s.throw(h)), g(h), o || s.assign(u, !1);
    }), e.ok(u);
  }
  function d() {
    e.result((0, Xh.callValidateCode)(e, t, f), () => p(t), () => g(t));
  }
  function g(u) {
    const h = (0, Rt._)`${u}.errors`;
    s.assign($n.default.vErrors, (0, Rt._)`${$n.default.vErrors} === null ? ${h} : ${$n.default.vErrors}.concat(${h})`), s.assign($n.default.errors, (0, Rt._)`${$n.default.vErrors}.length`);
  }
  function p(u) {
    var h;
    if (!i.opts.unevaluated)
      return;
    const b = (h = r == null ? void 0 : r.validate) === null || h === void 0 ? void 0 : h.evaluated;
    if (i.props !== !0)
      if (b && !b.dynamicProps)
        b.props !== void 0 && (i.props = Li.mergeEvaluated.props(s, b.props, i.props));
      else {
        const m = s.var("props", (0, Rt._)`${u}.evaluated.props`);
        i.props = Li.mergeEvaluated.props(s, m, i.props, Rt.Name);
      }
    if (i.items !== !0)
      if (b && !b.dynamicItems)
        b.items !== void 0 && (i.items = Li.mergeEvaluated.items(s, b.items, i.items));
      else {
        const m = s.var("items", (0, Rt._)`${u}.evaluated.items`);
        i.items = Li.mergeEvaluated.items(s, m, i.items, Rt.Name);
      }
  }
}
qr.callRef = mo;
qr.default = DO;
Object.defineProperty(kf, "__esModule", { value: !0 });
const FO = Lf, MO = qr, zO = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  FO.default,
  MO.default
];
kf.default = zO;
var jf = {}, Df = {};
Object.defineProperty(Df, "__esModule", { value: !0 });
const Fo = ae, Ir = Fo.operators, Mo = {
  maximum: { okStr: "<=", ok: Ir.LTE, fail: Ir.GT },
  minimum: { okStr: ">=", ok: Ir.GTE, fail: Ir.LT },
  exclusiveMaximum: { okStr: "<", ok: Ir.LT, fail: Ir.GTE },
  exclusiveMinimum: { okStr: ">", ok: Ir.GT, fail: Ir.LTE }
}, UO = {
  message: ({ keyword: e, schemaCode: t }) => (0, Fo.str)`must be ${Mo[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, Fo._)`{comparison: ${Mo[e].okStr}, limit: ${t}}`
}, qO = {
  keyword: Object.keys(Mo),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: UO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, Fo._)`${r} ${Mo[t].fail} ${n} || isNaN(${r})`);
  }
};
Df.default = qO;
var Ff = {};
Object.defineProperty(Ff, "__esModule", { value: !0 });
const js = ae, HO = {
  message: ({ schemaCode: e }) => (0, js.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, js._)`{multipleOf: ${e}}`
}, BO = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: HO,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: s } = e, i = s.opts.multipleOfPrecision, o = t.let("res"), a = i ? (0, js._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${i}` : (0, js._)`${o} !== parseInt(${o})`;
    e.fail$data((0, js._)`(${n} === 0 || (${o} = ${r}/${n}, ${a}))`);
  }
};
Ff.default = BO;
var Mf = {}, zf = {};
Object.defineProperty(zf, "__esModule", { value: !0 });
function w0(e) {
  const t = e.length;
  let r = 0, n = 0, s;
  for (; n < t; )
    r++, s = e.charCodeAt(n++), s >= 55296 && s <= 56319 && n < t && (s = e.charCodeAt(n), (s & 64512) === 56320 && n++);
  return r;
}
zf.default = w0;
w0.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Mf, "__esModule", { value: !0 });
const rn = ae, VO = re, GO = zf, WO = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, rn.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, rn._)`{limit: ${e}}`
}, KO = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: WO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: s } = e, i = t === "maxLength" ? rn.operators.GT : rn.operators.LT, o = s.opts.unicode === !1 ? (0, rn._)`${r}.length` : (0, rn._)`${(0, VO.useFunc)(e.gen, GO.default)}(${r})`;
    e.fail$data((0, rn._)`${o} ${i} ${n}`);
  }
};
Mf.default = KO;
var Uf = {};
Object.defineProperty(Uf, "__esModule", { value: !0 });
const JO = fe, zo = ae, YO = {
  message: ({ schemaCode: e }) => (0, zo.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, zo._)`{pattern: ${e}}`
}, XO = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: YO,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: s, it: i } = e, o = i.opts.unicodeRegExp ? "u" : "", a = r ? (0, zo._)`(new RegExp(${s}, ${o}))` : (0, JO.usePattern)(e, n);
    e.fail$data((0, zo._)`!${a}.test(${t})`);
  }
};
Uf.default = XO;
var qf = {};
Object.defineProperty(qf, "__esModule", { value: !0 });
const Ds = ae, ZO = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Ds.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Ds._)`{limit: ${e}}`
}, QO = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: ZO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, s = t === "maxProperties" ? Ds.operators.GT : Ds.operators.LT;
    e.fail$data((0, Ds._)`Object.keys(${r}).length ${s} ${n}`);
  }
};
qf.default = QO;
var Hf = {};
Object.defineProperty(Hf, "__esModule", { value: !0 });
const gs = fe, Fs = ae, eP = re, tP = {
  message: ({ params: { missingProperty: e } }) => (0, Fs.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, Fs._)`{missingProperty: ${e}}`
}, rP = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: tP,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: s, $data: i, it: o } = e, { opts: a } = o;
    if (!i && r.length === 0)
      return;
    const c = r.length >= a.loopRequired;
    if (o.allErrors ? f() : l(), a.strictRequired) {
      const p = e.parentSchema.properties, { definedProperties: u } = e.it;
      for (const h of r)
        if ((p == null ? void 0 : p[h]) === void 0 && !u.has(h)) {
          const b = o.schemaEnv.baseId + o.errSchemaPath, m = `required property "${h}" is not defined at "${b}" (strictRequired)`;
          (0, eP.checkStrictMode)(o, m, o.opts.strictRequired);
        }
    }
    function f() {
      if (c || i)
        e.block$data(Fs.nil, d);
      else
        for (const p of r)
          (0, gs.checkReportMissingProp)(e, p);
    }
    function l() {
      const p = t.let("missing");
      if (c || i) {
        const u = t.let("valid", !0);
        e.block$data(u, () => g(p, u)), e.ok(u);
      } else
        t.if((0, gs.checkMissingProp)(e, r, p)), (0, gs.reportMissingProp)(e, p), t.else();
    }
    function d() {
      t.forOf("prop", n, (p) => {
        e.setParams({ missingProperty: p }), t.if((0, gs.noPropertyInData)(t, s, p, a.ownProperties), () => e.error());
      });
    }
    function g(p, u) {
      e.setParams({ missingProperty: p }), t.forOf(p, n, () => {
        t.assign(u, (0, gs.propertyInData)(t, s, p, a.ownProperties)), t.if((0, Fs.not)(u), () => {
          e.error(), t.break();
        });
      }, Fs.nil);
    }
  }
};
Hf.default = rP;
var Bf = {};
Object.defineProperty(Bf, "__esModule", { value: !0 });
const Ms = ae, nP = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, Ms.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, Ms._)`{limit: ${e}}`
}, sP = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: nP,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, s = t === "maxItems" ? Ms.operators.GT : Ms.operators.LT;
    e.fail$data((0, Ms._)`${r}.length ${s} ${n}`);
  }
};
Bf.default = sP;
var Vf = {}, is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
const R0 = ba;
R0.code = 'require("ajv/dist/runtime/equal").default';
is.default = R0;
Object.defineProperty(Vf, "__esModule", { value: !0 });
const Kc = tt, at = ae, iP = re, oP = is, aP = {
  message: ({ params: { i: e, j: t } }) => (0, at.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, at._)`{i: ${e}, j: ${t}}`
}, cP = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: aP,
  code(e) {
    const { gen: t, data: r, $data: n, schema: s, parentSchema: i, schemaCode: o, it: a } = e;
    if (!n && !s)
      return;
    const c = t.let("valid"), f = i.items ? (0, Kc.getSchemaTypes)(i.items) : [];
    e.block$data(c, l, (0, at._)`${o} === false`), e.ok(c);
    function l() {
      const u = t.let("i", (0, at._)`${r}.length`), h = t.let("j");
      e.setParams({ i: u, j: h }), t.assign(c, !0), t.if((0, at._)`${u} > 1`, () => (d() ? g : p)(u, h));
    }
    function d() {
      return f.length > 0 && !f.some((u) => u === "object" || u === "array");
    }
    function g(u, h) {
      const b = t.name("item"), m = (0, Kc.checkDataTypes)(f, b, a.opts.strictNumbers, Kc.DataType.Wrong), v = t.const("indices", (0, at._)`{}`);
      t.for((0, at._)`;${u}--;`, () => {
        t.let(b, (0, at._)`${r}[${u}]`), t.if(m, (0, at._)`continue`), f.length > 1 && t.if((0, at._)`typeof ${b} == "string"`, (0, at._)`${b} += "_"`), t.if((0, at._)`typeof ${v}[${b}] == "number"`, () => {
          t.assign(h, (0, at._)`${v}[${b}]`), e.error(), t.assign(c, !1).break();
        }).code((0, at._)`${v}[${b}] = ${u}`);
      });
    }
    function p(u, h) {
      const b = (0, iP.useFunc)(t, oP.default), m = t.name("outer");
      t.label(m).for((0, at._)`;${u}--;`, () => t.for((0, at._)`${h} = ${u}; ${h}--;`, () => t.if((0, at._)`${b}(${r}[${u}], ${r}[${h}])`, () => {
        e.error(), t.assign(c, !1).break(m);
      })));
    }
  }
};
Vf.default = cP;
var Gf = {};
Object.defineProperty(Gf, "__esModule", { value: !0 });
const yu = ae, lP = re, uP = is, fP = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, yu._)`{allowedValue: ${e}}`
}, dP = {
  keyword: "const",
  $data: !0,
  error: fP,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: s, schema: i } = e;
    n || i && typeof i == "object" ? e.fail$data((0, yu._)`!${(0, lP.useFunc)(t, uP.default)}(${r}, ${s})`) : e.fail((0, yu._)`${i} !== ${r}`);
  }
};
Gf.default = dP;
var Wf = {};
Object.defineProperty(Wf, "__esModule", { value: !0 });
const Ns = ae, pP = re, hP = is, mP = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Ns._)`{allowedValues: ${e}}`
}, yP = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: mP,
  code(e) {
    const { gen: t, data: r, $data: n, schema: s, schemaCode: i, it: o } = e;
    if (!n && s.length === 0)
      throw new Error("enum must have non-empty array");
    const a = s.length >= o.opts.loopEnum;
    let c;
    const f = () => c ?? (c = (0, pP.useFunc)(t, hP.default));
    let l;
    if (a || n)
      l = t.let("valid"), e.block$data(l, d);
    else {
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const p = t.const("vSchema", i);
      l = (0, Ns.or)(...s.map((u, h) => g(p, h)));
    }
    e.pass(l);
    function d() {
      t.assign(l, !1), t.forOf("v", i, (p) => t.if((0, Ns._)`${f()}(${r}, ${p})`, () => t.assign(l, !0).break()));
    }
    function g(p, u) {
      const h = s[u];
      return typeof h == "object" && h !== null ? (0, Ns._)`${f()}(${r}, ${p}[${u}])` : (0, Ns._)`${r} === ${h}`;
    }
  }
};
Wf.default = yP;
Object.defineProperty(jf, "__esModule", { value: !0 });
const gP = Df, vP = Ff, bP = Mf, _P = Uf, EP = qf, xP = Hf, SP = Bf, wP = Vf, RP = Gf, $P = Wf, TP = [
  // number
  gP.default,
  vP.default,
  // string
  bP.default,
  _P.default,
  // object
  EP.default,
  xP.default,
  // array
  SP.default,
  wP.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  RP.default,
  $P.default
];
jf.default = TP;
var Kf = {}, os = {};
Object.defineProperty(os, "__esModule", { value: !0 });
os.validateAdditionalItems = void 0;
const nn = ae, gu = re, OP = {
  message: ({ params: { len: e } }) => (0, nn.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, nn._)`{limit: ${e}}`
}, PP = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: OP,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, gu.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    $0(e, n);
  }
};
function $0(e, t) {
  const { gen: r, schema: n, data: s, keyword: i, it: o } = e;
  o.items = !0;
  const a = r.const("len", (0, nn._)`${s}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, nn._)`${a} <= ${t.length}`);
  else if (typeof n == "object" && !(0, gu.alwaysValidSchema)(o, n)) {
    const f = r.var("valid", (0, nn._)`${a} <= ${t.length}`);
    r.if((0, nn.not)(f), () => c(f)), e.ok(f);
  }
  function c(f) {
    r.forRange("i", t.length, a, (l) => {
      e.subschema({ keyword: i, dataProp: l, dataPropType: gu.Type.Num }, f), o.allErrors || r.if((0, nn.not)(f), () => r.break());
    });
  }
}
os.validateAdditionalItems = $0;
os.default = PP;
var Jf = {}, as = {};
Object.defineProperty(as, "__esModule", { value: !0 });
as.validateTuple = void 0;
const Qh = ae, yo = re, CP = fe, IP = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return T0(e, "additionalItems", t);
    r.items = !0, !(0, yo.alwaysValidSchema)(r, t) && e.ok((0, CP.validateArray)(e));
  }
};
function T0(e, t, r = e.schema) {
  const { gen: n, parentSchema: s, data: i, keyword: o, it: a } = e;
  l(s), a.opts.unevaluated && r.length && a.items !== !0 && (a.items = yo.mergeEvaluated.items(n, r.length, a.items));
  const c = n.name("valid"), f = n.const("len", (0, Qh._)`${i}.length`);
  r.forEach((d, g) => {
    (0, yo.alwaysValidSchema)(a, d) || (n.if((0, Qh._)`${f} > ${g}`, () => e.subschema({
      keyword: o,
      schemaProp: g,
      dataProp: g
    }, c)), e.ok(c));
  });
  function l(d) {
    const { opts: g, errSchemaPath: p } = a, u = r.length, h = u === d.minItems && (u === d.maxItems || d[t] === !1);
    if (g.strictTuples && !h) {
      const b = `"${o}" is ${u}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, yo.checkStrictMode)(a, b, g.strictTuples);
    }
  }
}
as.validateTuple = T0;
as.default = IP;
Object.defineProperty(Jf, "__esModule", { value: !0 });
const NP = as, AP = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, NP.validateTuple)(e, "items")
};
Jf.default = AP;
var Yf = {};
Object.defineProperty(Yf, "__esModule", { value: !0 });
const em = ae, kP = re, LP = fe, jP = os, DP = {
  message: ({ params: { len: e } }) => (0, em.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, em._)`{limit: ${e}}`
}, FP = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: DP,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: s } = r;
    n.items = !0, !(0, kP.alwaysValidSchema)(n, t) && (s ? (0, jP.validateAdditionalItems)(e, s) : e.ok((0, LP.validateArray)(e)));
  }
};
Yf.default = FP;
var Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 });
const Ft = ae, ji = re, MP = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ft.str)`must contain at least ${e} valid item(s)` : (0, Ft.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ft._)`{minContains: ${e}}` : (0, Ft._)`{minContains: ${e}, maxContains: ${t}}`
}, zP = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: MP,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, it: i } = e;
    let o, a;
    const { minContains: c, maxContains: f } = n;
    i.opts.next ? (o = c === void 0 ? 1 : c, a = f) : o = 1;
    const l = t.const("len", (0, Ft._)`${s}.length`);
    if (e.setParams({ min: o, max: a }), a === void 0 && o === 0) {
      (0, ji.checkStrictMode)(i, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && o > a) {
      (0, ji.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, ji.alwaysValidSchema)(i, r)) {
      let h = (0, Ft._)`${l} >= ${o}`;
      a !== void 0 && (h = (0, Ft._)`${h} && ${l} <= ${a}`), e.pass(h);
      return;
    }
    i.items = !0;
    const d = t.name("valid");
    a === void 0 && o === 1 ? p(d, () => t.if(d, () => t.break())) : o === 0 ? (t.let(d, !0), a !== void 0 && t.if((0, Ft._)`${s}.length > 0`, g)) : (t.let(d, !1), g()), e.result(d, () => e.reset());
    function g() {
      const h = t.name("_valid"), b = t.let("count", 0);
      p(h, () => t.if(h, () => u(b)));
    }
    function p(h, b) {
      t.forRange("i", 0, l, (m) => {
        e.subschema({
          keyword: "contains",
          dataProp: m,
          dataPropType: ji.Type.Num,
          compositeRule: !0
        }, h), b();
      });
    }
    function u(h) {
      t.code((0, Ft._)`${h}++`), a === void 0 ? t.if((0, Ft._)`${h} >= ${o}`, () => t.assign(d, !0).break()) : (t.if((0, Ft._)`${h} > ${a}`, () => t.assign(d, !1).break()), o === 1 ? t.assign(d, !0) : t.if((0, Ft._)`${h} >= ${o}`, () => t.assign(d, !0)));
    }
  }
};
Xf.default = zP;
var O0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = ae, r = re, n = fe;
  e.error = {
    message: ({ params: { property: c, depsCount: f, deps: l } }) => {
      const d = f === 1 ? "property" : "properties";
      return (0, t.str)`must have ${d} ${l} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: f, deps: l, missingProperty: d } }) => (0, t._)`{property: ${c},
    missingProperty: ${d},
    depsCount: ${f},
    deps: ${l}}`
    // TODO change to reference
  };
  const s = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [f, l] = i(c);
      o(c, f), a(c, l);
    }
  };
  function i({ schema: c }) {
    const f = {}, l = {};
    for (const d in c) {
      if (d === "__proto__")
        continue;
      const g = Array.isArray(c[d]) ? f : l;
      g[d] = c[d];
    }
    return [f, l];
  }
  function o(c, f = c.schema) {
    const { gen: l, data: d, it: g } = c;
    if (Object.keys(f).length === 0)
      return;
    const p = l.let("missing");
    for (const u in f) {
      const h = f[u];
      if (h.length === 0)
        continue;
      const b = (0, n.propertyInData)(l, d, u, g.opts.ownProperties);
      c.setParams({
        property: u,
        depsCount: h.length,
        deps: h.join(", ")
      }), g.allErrors ? l.if(b, () => {
        for (const m of h)
          (0, n.checkReportMissingProp)(c, m);
      }) : (l.if((0, t._)`${b} && (${(0, n.checkMissingProp)(c, h, p)})`), (0, n.reportMissingProp)(c, p), l.else());
    }
  }
  e.validatePropertyDeps = o;
  function a(c, f = c.schema) {
    const { gen: l, data: d, keyword: g, it: p } = c, u = l.name("valid");
    for (const h in f)
      (0, r.alwaysValidSchema)(p, f[h]) || (l.if(
        (0, n.propertyInData)(l, d, h, p.opts.ownProperties),
        () => {
          const b = c.subschema({ keyword: g, schemaProp: h }, u);
          c.mergeValidEvaluated(b, u);
        },
        () => l.var(u, !0)
        // TODO var
      ), c.ok(u));
  }
  e.validateSchemaDeps = a, e.default = s;
})(O0);
var Zf = {};
Object.defineProperty(Zf, "__esModule", { value: !0 });
const P0 = ae, UP = re, qP = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, P0._)`{propertyName: ${e.propertyName}}`
}, HP = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: qP,
  code(e) {
    const { gen: t, schema: r, data: n, it: s } = e;
    if ((0, UP.alwaysValidSchema)(s, r))
      return;
    const i = t.name("valid");
    t.forIn("key", n, (o) => {
      e.setParams({ propertyName: o }), e.subschema({
        keyword: "propertyNames",
        data: o,
        dataTypes: ["string"],
        propertyName: o,
        compositeRule: !0
      }, i), t.if((0, P0.not)(i), () => {
        e.error(!0), s.allErrors || t.break();
      });
    }), e.ok(i);
  }
};
Zf.default = HP;
var Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
const Di = fe, Wt = ae, BP = jt, Fi = re, VP = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, Wt._)`{additionalProperty: ${e.additionalProperty}}`
}, GP = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: VP,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, errsCount: i, it: o } = e;
    if (!i)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: c } = o;
    if (o.props = !0, c.removeAdditional !== "all" && (0, Fi.alwaysValidSchema)(o, r))
      return;
    const f = (0, Di.allSchemaProperties)(n.properties), l = (0, Di.allSchemaProperties)(n.patternProperties);
    d(), e.ok((0, Wt._)`${i} === ${BP.default.errors}`);
    function d() {
      t.forIn("key", s, (b) => {
        !f.length && !l.length ? u(b) : t.if(g(b), () => u(b));
      });
    }
    function g(b) {
      let m;
      if (f.length > 8) {
        const v = (0, Fi.schemaRefOrVal)(o, n.properties, "properties");
        m = (0, Di.isOwnProperty)(t, v, b);
      } else f.length ? m = (0, Wt.or)(...f.map((v) => (0, Wt._)`${b} === ${v}`)) : m = Wt.nil;
      return l.length && (m = (0, Wt.or)(m, ...l.map((v) => (0, Wt._)`${(0, Di.usePattern)(e, v)}.test(${b})`))), (0, Wt.not)(m);
    }
    function p(b) {
      t.code((0, Wt._)`delete ${s}[${b}]`);
    }
    function u(b) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        p(b);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: b }), e.error(), a || t.break();
        return;
      }
      if (typeof r == "object" && !(0, Fi.alwaysValidSchema)(o, r)) {
        const m = t.name("valid");
        c.removeAdditional === "failing" ? (h(b, m, !1), t.if((0, Wt.not)(m), () => {
          e.reset(), p(b);
        })) : (h(b, m), a || t.if((0, Wt.not)(m), () => t.break()));
      }
    }
    function h(b, m, v) {
      const y = {
        keyword: "additionalProperties",
        dataProp: b,
        dataPropType: Fi.Type.Str
      };
      v === !1 && Object.assign(y, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema(y, m);
    }
  }
};
Sa.default = GP;
var Qf = {};
Object.defineProperty(Qf, "__esModule", { value: !0 });
const WP = Ut, tm = fe, Jc = re, rm = Sa, KP = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, it: i } = e;
    i.opts.removeAdditional === "all" && n.additionalProperties === void 0 && rm.default.code(new WP.KeywordCxt(i, rm.default, "additionalProperties"));
    const o = (0, tm.allSchemaProperties)(r);
    for (const d of o)
      i.definedProperties.add(d);
    i.opts.unevaluated && o.length && i.props !== !0 && (i.props = Jc.mergeEvaluated.props(t, (0, Jc.toHash)(o), i.props));
    const a = o.filter((d) => !(0, Jc.alwaysValidSchema)(i, r[d]));
    if (a.length === 0)
      return;
    const c = t.name("valid");
    for (const d of a)
      f(d) ? l(d) : (t.if((0, tm.propertyInData)(t, s, d, i.opts.ownProperties)), l(d), i.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(d), e.ok(c);
    function f(d) {
      return i.opts.useDefaults && !i.compositeRule && r[d].default !== void 0;
    }
    function l(d) {
      e.subschema({
        keyword: "properties",
        schemaProp: d,
        dataProp: d
      }, c);
    }
  }
};
Qf.default = KP;
var ed = {};
Object.defineProperty(ed, "__esModule", { value: !0 });
const nm = fe, Mi = ae, sm = re, im = re, JP = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: n, parentSchema: s, it: i } = e, { opts: o } = i, a = (0, nm.allSchemaProperties)(r), c = a.filter((h) => (0, sm.alwaysValidSchema)(i, r[h]));
    if (a.length === 0 || c.length === a.length && (!i.opts.unevaluated || i.props === !0))
      return;
    const f = o.strictSchema && !o.allowMatchingProperties && s.properties, l = t.name("valid");
    i.props !== !0 && !(i.props instanceof Mi.Name) && (i.props = (0, im.evaluatedPropsToName)(t, i.props));
    const { props: d } = i;
    g();
    function g() {
      for (const h of a)
        f && p(h), i.allErrors ? u(h) : (t.var(l, !0), u(h), t.if(l));
    }
    function p(h) {
      for (const b in f)
        new RegExp(h).test(b) && (0, sm.checkStrictMode)(i, `property ${b} matches pattern ${h} (use allowMatchingProperties)`);
    }
    function u(h) {
      t.forIn("key", n, (b) => {
        t.if((0, Mi._)`${(0, nm.usePattern)(e, h)}.test(${b})`, () => {
          const m = c.includes(h);
          m || e.subschema({
            keyword: "patternProperties",
            schemaProp: h,
            dataProp: b,
            dataPropType: im.Type.Str
          }, l), i.opts.unevaluated && d !== !0 ? t.assign((0, Mi._)`${d}[${b}]`, !0) : !m && !i.allErrors && t.if((0, Mi.not)(l), () => t.break());
        });
      });
    }
  }
};
ed.default = JP;
var td = {};
Object.defineProperty(td, "__esModule", { value: !0 });
const YP = re, XP = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if ((0, YP.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const s = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, s), e.failResult(s, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
td.default = XP;
var rd = {};
Object.defineProperty(rd, "__esModule", { value: !0 });
const ZP = fe, QP = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: ZP.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
rd.default = QP;
var nd = {};
Object.defineProperty(nd, "__esModule", { value: !0 });
const go = ae, eC = re, tC = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, go._)`{passingSchemas: ${e.passing}}`
}, rC = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: tC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: s } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (s.opts.discriminator && n.discriminator)
      return;
    const i = r, o = t.let("valid", !1), a = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: a }), t.block(f), e.result(o, () => e.reset(), () => e.error(!0));
    function f() {
      i.forEach((l, d) => {
        let g;
        (0, eC.alwaysValidSchema)(s, l) ? t.var(c, !0) : g = e.subschema({
          keyword: "oneOf",
          schemaProp: d,
          compositeRule: !0
        }, c), d > 0 && t.if((0, go._)`${c} && ${o}`).assign(o, !1).assign(a, (0, go._)`[${a}, ${d}]`).else(), t.if(c, () => {
          t.assign(o, !0), t.assign(a, d), g && e.mergeEvaluated(g, go.Name);
        });
      });
    }
  }
};
nd.default = rC;
var sd = {};
Object.defineProperty(sd, "__esModule", { value: !0 });
const nC = re, sC = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const s = t.name("valid");
    r.forEach((i, o) => {
      if ((0, nC.alwaysValidSchema)(n, i))
        return;
      const a = e.subschema({ keyword: "allOf", schemaProp: o }, s);
      e.ok(s), e.mergeEvaluated(a);
    });
  }
};
sd.default = sC;
var id = {};
Object.defineProperty(id, "__esModule", { value: !0 });
const Uo = ae, C0 = re, iC = {
  message: ({ params: e }) => (0, Uo.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, Uo._)`{failingKeyword: ${e.ifClause}}`
}, oC = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: iC,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, C0.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const s = om(n, "then"), i = om(n, "else");
    if (!s && !i)
      return;
    const o = t.let("valid", !0), a = t.name("_valid");
    if (c(), e.reset(), s && i) {
      const l = t.let("ifClause");
      e.setParams({ ifClause: l }), t.if(a, f("then", l), f("else", l));
    } else s ? t.if(a, f("then")) : t.if((0, Uo.not)(a), f("else"));
    e.pass(o, () => e.error(!0));
    function c() {
      const l = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, a);
      e.mergeEvaluated(l);
    }
    function f(l, d) {
      return () => {
        const g = e.subschema({ keyword: l }, a);
        t.assign(o, a), e.mergeValidEvaluated(g, o), d ? t.assign(d, (0, Uo._)`${l}`) : e.setParams({ ifClause: l });
      };
    }
  }
};
function om(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, C0.alwaysValidSchema)(e, r);
}
id.default = oC;
var od = {};
Object.defineProperty(od, "__esModule", { value: !0 });
const aC = re, cC = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, aC.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
od.default = cC;
Object.defineProperty(Kf, "__esModule", { value: !0 });
const lC = os, uC = Jf, fC = as, dC = Yf, pC = Xf, hC = O0, mC = Zf, yC = Sa, gC = Qf, vC = ed, bC = td, _C = rd, EC = nd, xC = sd, SC = id, wC = od;
function RC(e = !1) {
  const t = [
    // any
    bC.default,
    _C.default,
    EC.default,
    xC.default,
    SC.default,
    wC.default,
    // object
    mC.default,
    yC.default,
    hC.default,
    gC.default,
    vC.default
  ];
  return e ? t.push(uC.default, dC.default) : t.push(lC.default, fC.default), t.push(pC.default), t;
}
Kf.default = RC;
var ad = {}, cd = {};
Object.defineProperty(cd, "__esModule", { value: !0 });
const Ke = ae, $C = {
  message: ({ schemaCode: e }) => (0, Ke.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, Ke._)`{format: ${e}}`
}, TC = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: $C,
  code(e, t) {
    const { gen: r, data: n, $data: s, schema: i, schemaCode: o, it: a } = e, { opts: c, errSchemaPath: f, schemaEnv: l, self: d } = a;
    if (!c.validateFormats)
      return;
    s ? g() : p();
    function g() {
      const u = r.scopeValue("formats", {
        ref: d.formats,
        code: c.code.formats
      }), h = r.const("fDef", (0, Ke._)`${u}[${o}]`), b = r.let("fType"), m = r.let("format");
      r.if((0, Ke._)`typeof ${h} == "object" && !(${h} instanceof RegExp)`, () => r.assign(b, (0, Ke._)`${h}.type || "string"`).assign(m, (0, Ke._)`${h}.validate`), () => r.assign(b, (0, Ke._)`"string"`).assign(m, h)), e.fail$data((0, Ke.or)(v(), y()));
      function v() {
        return c.strictSchema === !1 ? Ke.nil : (0, Ke._)`${o} && !${m}`;
      }
      function y() {
        const _ = l.$async ? (0, Ke._)`(${h}.async ? await ${m}(${n}) : ${m}(${n}))` : (0, Ke._)`${m}(${n})`, R = (0, Ke._)`(typeof ${m} == "function" ? ${_} : ${m}.test(${n}))`;
        return (0, Ke._)`${m} && ${m} !== true && ${b} === ${t} && !${R}`;
      }
    }
    function p() {
      const u = d.formats[i];
      if (!u) {
        v();
        return;
      }
      if (u === !0)
        return;
      const [h, b, m] = y(u);
      h === t && e.pass(_());
      function v() {
        if (c.strictSchema === !1) {
          d.logger.warn(R());
          return;
        }
        throw new Error(R());
        function R() {
          return `unknown format "${i}" ignored in schema at path "${f}"`;
        }
      }
      function y(R) {
        const E = R instanceof RegExp ? (0, Ke.regexpCode)(R) : c.code.formats ? (0, Ke._)`${c.code.formats}${(0, Ke.getProperty)(i)}` : void 0, O = r.scopeValue("formats", { key: i, ref: R, code: E });
        return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, Ke._)`${O}.validate`] : ["string", R, O];
      }
      function _() {
        if (typeof u == "object" && !(u instanceof RegExp) && u.async) {
          if (!l.$async)
            throw new Error("async format in sync schema");
          return (0, Ke._)`await ${m}(${n})`;
        }
        return typeof b == "function" ? (0, Ke._)`${m}(${n})` : (0, Ke._)`${m}.test(${n})`;
      }
    }
  }
};
cd.default = TC;
Object.defineProperty(ad, "__esModule", { value: !0 });
const OC = cd, PC = [OC.default];
ad.default = PC;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.contentVocabulary = Jn.metadataVocabulary = void 0;
Jn.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Jn.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Af, "__esModule", { value: !0 });
const CC = kf, IC = jf, NC = Kf, AC = ad, am = Jn, kC = [
  CC.default,
  IC.default,
  (0, NC.default)(),
  AC.default,
  am.metadataVocabulary,
  am.contentVocabulary
];
Af.default = kC;
var ld = {}, pi = {};
Object.defineProperty(pi, "__esModule", { value: !0 });
pi.DiscrError = void 0;
var cm;
(function(e) {
  e.Tag = "tag", e.Mapping = "mapping";
})(cm || (pi.DiscrError = cm = {}));
Object.defineProperty(ld, "__esModule", { value: !0 });
const kn = ae, vu = pi, lm = ft, LC = mr, jC = re, DC = {
  message: ({ params: { discrError: e, tagName: t } }) => e === vu.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, kn._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, FC = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: DC,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: s, it: i } = e, { oneOf: o } = s;
    if (!i.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const a = n.propertyName;
    if (typeof a != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!o)
      throw new Error("discriminator: requires oneOf keyword");
    const c = t.let("valid", !1), f = t.const("tag", (0, kn._)`${r}${(0, kn.getProperty)(a)}`);
    t.if((0, kn._)`typeof ${f} == "string"`, () => l(), () => e.error(!1, { discrError: vu.DiscrError.Tag, tag: f, tagName: a })), e.ok(c);
    function l() {
      const p = g();
      t.if(!1);
      for (const u in p)
        t.elseIf((0, kn._)`${f} === ${u}`), t.assign(c, d(p[u]));
      t.else(), e.error(!1, { discrError: vu.DiscrError.Mapping, tag: f, tagName: a }), t.endIf();
    }
    function d(p) {
      const u = t.name("valid"), h = e.subschema({ keyword: "oneOf", schemaProp: p }, u);
      return e.mergeEvaluated(h, kn.Name), u;
    }
    function g() {
      var p;
      const u = {}, h = m(s);
      let b = !0;
      for (let _ = 0; _ < o.length; _++) {
        let R = o[_];
        if (R != null && R.$ref && !(0, jC.schemaHasRulesButRef)(R, i.self.RULES)) {
          const O = R.$ref;
          if (R = lm.resolveRef.call(i.self, i.schemaEnv.root, i.baseId, O), R instanceof lm.SchemaEnv && (R = R.schema), R === void 0)
            throw new LC.default(i.opts.uriResolver, i.baseId, O);
        }
        const E = (p = R == null ? void 0 : R.properties) === null || p === void 0 ? void 0 : p[a];
        if (typeof E != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        b = b && (h || m(R)), v(E, _);
      }
      if (!b)
        throw new Error(`discriminator: "${a}" must be required`);
      return u;
      function m({ required: _ }) {
        return Array.isArray(_) && _.includes(a);
      }
      function v(_, R) {
        if (_.const)
          y(_.const, R);
        else if (_.enum)
          for (const E of _.enum)
            y(E, R);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function y(_, R) {
        if (typeof _ != "string" || _ in u)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        u[_] = R;
      }
    }
  }
};
ld.default = FC;
const MC = "http://json-schema.org/draft-07/schema#", zC = "http://json-schema.org/draft-07/schema#", UC = "Core schema meta-schema", qC = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, HC = [
  "object",
  "boolean"
], BC = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, VC = {
  $schema: MC,
  $id: zC,
  title: UC,
  definitions: qC,
  type: HC,
  properties: BC,
  default: !0
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const r = gf, n = Af, s = ld, i = VC, o = ["/properties"], a = "http://json-schema.org/draft-07/schema";
  class c extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((u) => this.addVocabulary(u)), this.opts.discriminator && this.addKeyword(s.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const u = this.opts.$data ? this.$dataMetaSchema(i, o) : i;
      this.addMetaSchema(u, a, !1), this.refs["http://json-schema.org/schema"] = a;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var f = Ut;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return f.KeywordCxt;
  } });
  var l = ae;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var d = ss;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var g = mr;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return g.default;
  } });
})(du, du.exports);
var ud = du.exports, zi = { exports: {} }, wa = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(M, U) {
    return { validate: M, compare: U };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(i, o),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(c(!0), f),
    "date-time": t(g(!0), p),
    "iso-time": t(c(), l),
    "iso-date-time": t(g(), u),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: m,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: L,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y,
    // signed 32 bit integer
    int32: { type: "number", validate: E },
    // signed 64 bit integer
    int64: { type: "number", validate: O },
    // C-type float
    float: { type: "number", validate: z },
    // C-type double
    double: { type: "number", validate: z },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, o),
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, f),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    "iso-time": t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, l),
    "iso-date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, u),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
  function r(M) {
    return M % 4 === 0 && (M % 100 !== 0 || M % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, s = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function i(M) {
    const U = n.exec(M);
    if (!U)
      return !1;
    const $ = +U[1], S = +U[2], I = +U[3];
    return S >= 1 && S <= 12 && I >= 1 && I <= (S === 2 && r($) ? 29 : s[S]);
  }
  function o(M, U) {
    if (M && U)
      return M > U ? 1 : M < U ? -1 : 0;
  }
  const a = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function c(M) {
    return function($) {
      const S = a.exec($);
      if (!S)
        return !1;
      const I = +S[1], T = +S[2], j = +S[3], P = S[4], A = S[5] === "-" ? -1 : 1, k = +(S[6] || 0), C = +(S[7] || 0);
      if (k > 23 || C > 59 || M && !P)
        return !1;
      if (I <= 23 && T <= 59 && j < 60)
        return !0;
      const D = T - C * A, F = I - k * A - (D < 0 ? 1 : 0);
      return (F === 23 || F === -1) && (D === 59 || D === -1) && j < 61;
    };
  }
  function f(M, U) {
    if (!(M && U))
      return;
    const $ = (/* @__PURE__ */ new Date("2020-01-01T" + M)).valueOf(), S = (/* @__PURE__ */ new Date("2020-01-01T" + U)).valueOf();
    if ($ && S)
      return $ - S;
  }
  function l(M, U) {
    if (!(M && U))
      return;
    const $ = a.exec(M), S = a.exec(U);
    if ($ && S)
      return M = $[1] + $[2] + $[3], U = S[1] + S[2] + S[3], M > U ? 1 : M < U ? -1 : 0;
  }
  const d = /t|\s/i;
  function g(M) {
    const U = c(M);
    return function(S) {
      const I = S.split(d);
      return I.length === 2 && i(I[0]) && U(I[1]);
    };
  }
  function p(M, U) {
    if (!(M && U))
      return;
    const $ = new Date(M).valueOf(), S = new Date(U).valueOf();
    if ($ && S)
      return $ - S;
  }
  function u(M, U) {
    if (!(M && U))
      return;
    const [$, S] = M.split(d), [I, T] = U.split(d), j = o($, I);
    if (j !== void 0)
      return j || f(S, T);
  }
  const h = /\/|:/, b = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function m(M) {
    return h.test(M) && b.test(M);
  }
  const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(M) {
    return v.lastIndex = 0, v.test(M);
  }
  const _ = -2147483648, R = 2 ** 31 - 1;
  function E(M) {
    return Number.isInteger(M) && M <= R && M >= _;
  }
  function O(M) {
    return Number.isInteger(M);
  }
  function z() {
    return !0;
  }
  const x = /[^\\]\\Z/;
  function L(M) {
    if (x.test(M))
      return !1;
    try {
      return new RegExp(M), !0;
    } catch {
      return !1;
    }
  }
})(wa);
var Yc = {}, um;
function GC() {
  return um || (um = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = ud, r = ae, n = r.operators, s = {
      formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
      formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
      formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
    }, i = {
      message: ({ keyword: a, schemaCode: c }) => (0, r.str)`should be ${s[a].okStr} ${c}`,
      params: ({ keyword: a, schemaCode: c }) => (0, r._)`{comparison: ${s[a].okStr}, limit: ${c}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(s),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: i,
      code(a) {
        const { gen: c, data: f, schemaCode: l, keyword: d, it: g } = a, { opts: p, self: u } = g;
        if (!p.validateFormats)
          return;
        const h = new t.KeywordCxt(g, u.RULES.all.format.definition, "format");
        h.$data ? b() : m();
        function b() {
          const y = c.scopeValue("formats", {
            ref: u.formats,
            code: p.code.formats
          }), _ = c.const("fmt", (0, r._)`${y}[${h.schemaCode}]`);
          a.fail$data((0, r.or)((0, r._)`typeof ${_} != "object"`, (0, r._)`${_} instanceof RegExp`, (0, r._)`typeof ${_}.compare != "function"`, v(_)));
        }
        function m() {
          const y = h.schema, _ = u.formats[y];
          if (!_ || _ === !0)
            return;
          if (typeof _ != "object" || _ instanceof RegExp || typeof _.compare != "function")
            throw new Error(`"${d}": format "${y}" does not define "compare" function`);
          const R = c.scopeValue("formats", {
            key: y,
            ref: _,
            code: p.code.formats ? (0, r._)`${p.code.formats}${(0, r.getProperty)(y)}` : void 0
          });
          a.fail$data(v(R));
        }
        function v(y) {
          return (0, r._)`${y}.compare(${f}, ${l}) ${s[d].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const o = (a) => (a.addKeyword(e.formatLimitDefinition), a);
    e.default = o;
  }(Yc)), Yc;
}
var fm;
function I0() {
  return fm || (fm = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const r = wa, n = GC(), s = ae, i = new s.Name("fullFormats"), o = new s.Name("fastFormats"), a = (f, l = { keywords: !0 }) => {
      if (Array.isArray(l))
        return c(f, l, r.fullFormats, i), f;
      const [d, g] = l.mode === "fast" ? [r.fastFormats, o] : [r.fullFormats, i], p = l.formats || r.formatNames;
      return c(f, p, d, g), l.keywords && (0, n.default)(f), f;
    };
    a.get = (f, l = "full") => {
      const g = (l === "fast" ? r.fastFormats : r.fullFormats)[f];
      if (!g)
        throw new Error(`Unknown format "${f}"`);
      return g;
    };
    function c(f, l, d, g) {
      var p, u;
      (p = (u = f.opts.code).formats) !== null && p !== void 0 || (u.formats = (0, s._)`require("ajv-formats/dist/formats").${g}`);
      for (const h of l)
        f.addFormat(h, d[h]);
    }
    e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
  }(zi, zi.exports)), zi.exports;
}
const WC = ud, KC = Nf, JC = I0(), YC = ef({ proto: !0 });
let XC = class N0 {
  constructor(t) {
    this.ajv = new WC({
      ...t,
      strictSchema: !1,
      validateSchema: !1,
      allowUnionTypes: !0,
      uriResolver: KC
    }), JC(this.ajv), this.ajv.addKeyword({
      keyword: "fjs_type",
      type: "object",
      errors: !1,
      validate: (r, n) => n instanceof Date
    }), this._ajvSchemas = {}, this._ajvOptions = t || {};
  }
  addSchema(t, r) {
    let n = t.$id || r;
    if (t.$id !== void 0 && t.$id[0] === "#" && (n = r + t.$id), this.ajv.refs[n] === void 0 && this.ajv.schemas[n] === void 0) {
      const s = YC(t);
      this.convertSchemaToAjvFormat(s), this.ajv.addSchema(s, n), this._ajvSchemas[n] = t;
    }
  }
  validate(t, r) {
    return this.ajv.validate(t, r);
  }
  // Ajv does not support js date format. In order to properly validate objects containing a date,
  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
  // (see https://github.com/fastify/fast-json-stringify/pull/441)
  convertSchemaToAjvFormat(t) {
    if (t !== null) {
      t.type === "string" ? (t.fjs_type = "string", t.type = ["string", "object"]) : Array.isArray(t.type) && t.type.includes("string") && !t.type.includes("object") && (t.fjs_type = "string", t.type.push("object"));
      for (const r in t)
        typeof t[r] == "object" && this.convertSchemaToAjvFormat(t[r]);
    }
  }
  getState() {
    return {
      ajvOptions: this._ajvOptions,
      ajvSchemas: this._ajvSchemas
    };
  }
  static restoreFromState(t) {
    const r = new N0(t.ajvOptions);
    for (const [n, s] of Object.entries(t.ajvSchemas))
      r.ajv.addSchema(s, n);
    return r;
  }
};
var A0 = XC;
let ZC = class k0 {
  constructor(t, r, n = "#") {
    this.schema = t, this.schemaId = r, this.jsonPointer = n;
  }
  getPropertyLocation(t) {
    return new k0(
      this.schema[t],
      this.schemaId,
      this.jsonPointer + "/" + t
    );
  }
  getSchemaRef() {
    return this.schemaId + this.jsonPointer;
  }
};
var QC = ZC, fd = { exports: {} };
fd.exports = Q;
fd.exports.default = Q;
const eI = { type: ["object", "boolean"] }, dm = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, pm = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, tI = wa.fullFormats.uri, hm = wa.fullFormats.regex;
function Dt(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  return typeof e == "number" && !(e % 1) && !isNaN(e) && isFinite(e) ? typeof e == "number" && isFinite(e) && (e < 0 || isNaN(e)) ? (Dt.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1) : (Dt.errors = i, o === 0) : (Dt.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1);
}
const Xc = { validate: Q };
function Et(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  if (o === 0)
    if (Array.isArray(e)) {
      if (e.length < 1)
        return Et.errors = [{ instancePath: t, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
      {
        var a = !0;
        const c = e.length;
        for (let f = 0; f < c; f++) {
          const l = o;
          Xc.validate(e[f], { instancePath: t + "/" + f, parentData: e, parentDataProperty: f, rootData: s }) || (i = i === null ? Xc.validate.errors : i.concat(Xc.validate.errors), o = i.length);
          var a = l === o;
          if (!a)
            break;
        }
      }
    } else
      return Et.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
  return Et.errors = i, o === 0;
}
const mm = is.default;
function Q(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  if (!(e && typeof e == "object" && !Array.isArray(e)) && typeof e != "boolean")
    return Q.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: eI.type }, message: "must be object,boolean" }], !1;
  if (o === 0 && e && typeof e == "object" && !Array.isArray(e)) {
    if (e.$id !== void 0) {
      let y = e.$id;
      const _ = o;
      if (o === _ && o === _)
        if (typeof y == "string") {
          if (!pm.test(y))
            return Q.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
        } else
          return Q.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
      var a = _ === o;
    } else
      var a = !0;
    if (a) {
      if (e.$schema !== void 0) {
        let y = e.$schema;
        const _ = o;
        if (o === _ && o === _)
          if (typeof y == "string") {
            if (!tI(y))
              return Q.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }], !1;
          } else
            return Q.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
        var a = _ === o;
      } else
        var a = !0;
      if (a) {
        if (e.$ref !== void 0) {
          let y = e.$ref;
          const _ = o;
          if (o === _ && o === _)
            if (typeof y == "string") {
              if (!pm.test(y))
                return Q.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
            } else
              return Q.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
          var a = _ === o;
        } else
          var a = !0;
        if (a) {
          if (e.$comment !== void 0) {
            const y = o;
            if (typeof e.$comment != "string")
              return Q.errors = [{ instancePath: t + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
            var a = y === o;
          } else
            var a = !0;
          if (a) {
            if (e.title !== void 0) {
              const y = o;
              if (typeof e.title != "string")
                return Q.errors = [{ instancePath: t + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
              var a = y === o;
            } else
              var a = !0;
            if (a) {
              if (e.description !== void 0) {
                const y = o;
                if (typeof e.description != "string")
                  return Q.errors = [{ instancePath: t + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                var a = y === o;
              } else
                var a = !0;
              if (a) {
                if (e.readOnly !== void 0) {
                  const y = o;
                  if (typeof e.readOnly != "boolean")
                    return Q.errors = [{ instancePath: t + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                  var a = y === o;
                } else
                  var a = !0;
                if (a) {
                  if (e.examples !== void 0) {
                    const y = o;
                    if (o === y && !Array.isArray(e.examples))
                      return Q.errors = [{ instancePath: t + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                    var a = y === o;
                  } else
                    var a = !0;
                  if (a) {
                    if (e.multipleOf !== void 0) {
                      let y = e.multipleOf;
                      const _ = o;
                      if (o === _)
                        if (typeof y == "number" && isFinite(y)) {
                          if (y <= 0 || isNaN(y))
                            return Q.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }], !1;
                        } else
                          return Q.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                      var a = _ === o;
                    } else
                      var a = !0;
                    if (a) {
                      if (e.maximum !== void 0) {
                        let y = e.maximum;
                        const _ = o;
                        if (!(typeof y == "number" && isFinite(y)))
                          return Q.errors = [{ instancePath: t + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                        var a = _ === o;
                      } else
                        var a = !0;
                      if (a) {
                        if (e.exclusiveMaximum !== void 0) {
                          let y = e.exclusiveMaximum;
                          const _ = o;
                          if (!(typeof y == "number" && isFinite(y)))
                            return Q.errors = [{ instancePath: t + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                          var a = _ === o;
                        } else
                          var a = !0;
                        if (a) {
                          if (e.minimum !== void 0) {
                            let y = e.minimum;
                            const _ = o;
                            if (!(typeof y == "number" && isFinite(y)))
                              return Q.errors = [{ instancePath: t + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                            var a = _ === o;
                          } else
                            var a = !0;
                          if (a) {
                            if (e.exclusiveMinimum !== void 0) {
                              let y = e.exclusiveMinimum;
                              const _ = o;
                              if (!(typeof y == "number" && isFinite(y)))
                                return Q.errors = [{ instancePath: t + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                              var a = _ === o;
                            } else
                              var a = !0;
                            if (a) {
                              if (e.maxLength !== void 0) {
                                let y = e.maxLength;
                                const _ = o, R = o;
                                if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                  return Q.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                  return Q.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                var a = _ === o;
                              } else
                                var a = !0;
                              if (a) {
                                if (e.minLength !== void 0) {
                                  const y = o;
                                  Dt(e.minLength, { instancePath: t + "/minLength", parentData: e, parentDataProperty: "minLength", rootData: s }) || (i = i === null ? Dt.errors : i.concat(Dt.errors), o = i.length);
                                  var a = y === o;
                                } else
                                  var a = !0;
                                if (a) {
                                  if (e.pattern !== void 0) {
                                    let y = e.pattern;
                                    const _ = o;
                                    if (o === _ && o === _)
                                      if (typeof y == "string") {
                                        if (!hm(y))
                                          return Q.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }], !1;
                                      } else
                                        return Q.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                    var a = _ === o;
                                  } else
                                    var a = !0;
                                  if (a) {
                                    if (e.additionalItems !== void 0) {
                                      const y = o;
                                      Q(e.additionalItems, { instancePath: t + "/additionalItems", parentData: e, parentDataProperty: "additionalItems", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                      var a = y === o;
                                    } else
                                      var a = !0;
                                    if (a) {
                                      if (e.items !== void 0) {
                                        let y = e.items;
                                        const _ = o, R = o;
                                        let E = !1;
                                        const O = o;
                                        Q(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                        var c = O === o;
                                        if (E = E || c, !E) {
                                          const x = o;
                                          Et(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: s }) || (i = i === null ? Et.errors : i.concat(Et.errors), o = i.length);
                                          var c = x === o;
                                          E = E || c;
                                        }
                                        if (E)
                                          o = R, i !== null && (R ? i.length = R : i = null);
                                        else {
                                          const x = { instancePath: t + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                          return i === null ? i = [x] : i.push(x), o++, Q.errors = i, !1;
                                        }
                                        var a = _ === o;
                                      } else
                                        var a = !0;
                                      if (a) {
                                        if (e.maxItems !== void 0) {
                                          let y = e.maxItems;
                                          const _ = o, R = o;
                                          if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                            return Q.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                            return Q.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                          var a = _ === o;
                                        } else
                                          var a = !0;
                                        if (a) {
                                          if (e.minItems !== void 0) {
                                            const y = o;
                                            Dt(e.minItems, { instancePath: t + "/minItems", parentData: e, parentDataProperty: "minItems", rootData: s }) || (i = i === null ? Dt.errors : i.concat(Dt.errors), o = i.length);
                                            var a = y === o;
                                          } else
                                            var a = !0;
                                          if (a) {
                                            if (e.uniqueItems !== void 0) {
                                              const y = o;
                                              if (typeof e.uniqueItems != "boolean")
                                                return Q.errors = [{ instancePath: t + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                              var a = y === o;
                                            } else
                                              var a = !0;
                                            if (a) {
                                              if (e.contains !== void 0) {
                                                const y = o;
                                                Q(e.contains, { instancePath: t + "/contains", parentData: e, parentDataProperty: "contains", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                var a = y === o;
                                              } else
                                                var a = !0;
                                              if (a) {
                                                if (e.maxProperties !== void 0) {
                                                  let y = e.maxProperties;
                                                  const _ = o, R = o;
                                                  if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                                    return Q.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                  if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                                    return Q.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                                  var a = _ === o;
                                                } else
                                                  var a = !0;
                                                if (a) {
                                                  if (e.minProperties !== void 0) {
                                                    const y = o;
                                                    Dt(e.minProperties, { instancePath: t + "/minProperties", parentData: e, parentDataProperty: "minProperties", rootData: s }) || (i = i === null ? Dt.errors : i.concat(Dt.errors), o = i.length);
                                                    var a = y === o;
                                                  } else
                                                    var a = !0;
                                                  if (a) {
                                                    if (e.required !== void 0) {
                                                      let y = e.required;
                                                      const _ = o;
                                                      if (o === o)
                                                        if (Array.isArray(y)) {
                                                          var f = !0;
                                                          const O = y.length;
                                                          for (let z = 0; z < O; z++) {
                                                            const x = o;
                                                            if (typeof y[z] != "string")
                                                              return Q.errors = [{ instancePath: t + "/required/" + z, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                            var f = x === o;
                                                            if (!f)
                                                              break;
                                                          }
                                                          if (f) {
                                                            let z = y.length, x;
                                                            if (z > 1) {
                                                              const L = {};
                                                              for (; z--; ) {
                                                                let M = y[z];
                                                                if (typeof M == "string") {
                                                                  if (typeof L[M] == "number")
                                                                    return x = L[M], Q.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: z, j: x }, message: "must NOT have duplicate items (items ## " + x + " and " + z + " are identical)" }], !1;
                                                                  L[M] = z;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        } else
                                                          return Q.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                      var a = _ === o;
                                                    } else
                                                      var a = !0;
                                                    if (a) {
                                                      if (e.additionalProperties !== void 0) {
                                                        const y = o;
                                                        Q(e.additionalProperties, { instancePath: t + "/additionalProperties", parentData: e, parentDataProperty: "additionalProperties", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                        var a = y === o;
                                                      } else
                                                        var a = !0;
                                                      if (a) {
                                                        if (e.definitions !== void 0) {
                                                          let y = e.definitions;
                                                          const _ = o;
                                                          if (o === _)
                                                            if (y && typeof y == "object" && !Array.isArray(y))
                                                              for (const E in y) {
                                                                const O = o;
                                                                Q(y[E], { instancePath: t + "/definitions/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                var l = O === o;
                                                                if (!l)
                                                                  break;
                                                              }
                                                            else
                                                              return Q.errors = [{ instancePath: t + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                          var a = _ === o;
                                                        } else
                                                          var a = !0;
                                                        if (a) {
                                                          if (e.properties !== void 0) {
                                                            let y = e.properties;
                                                            const _ = o;
                                                            if (o === _)
                                                              if (y && typeof y == "object" && !Array.isArray(y))
                                                                for (const E in y) {
                                                                  const O = o;
                                                                  Q(y[E], { instancePath: t + "/properties/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                  var d = O === o;
                                                                  if (!d)
                                                                    break;
                                                                }
                                                              else
                                                                return Q.errors = [{ instancePath: t + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var a = _ === o;
                                                          } else
                                                            var a = !0;
                                                          if (a) {
                                                            if (e.patternProperties !== void 0) {
                                                              let y = e.patternProperties;
                                                              const _ = o;
                                                              if (o === _)
                                                                if (y && typeof y == "object" && !Array.isArray(y)) {
                                                                  for (const E in y) {
                                                                    const O = o;
                                                                    if (o === O && typeof E == "string" && !hm(E)) {
                                                                      const z = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: E };
                                                                      i === null ? i = [z] : i.push(z), o++;
                                                                    }
                                                                    var g = O === o;
                                                                    if (!g) {
                                                                      const z = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: E }, message: "property name must be valid" };
                                                                      return i === null ? i = [z] : i.push(z), o++, Q.errors = i, !1;
                                                                    }
                                                                  }
                                                                  if (g)
                                                                    for (const E in y) {
                                                                      const O = o;
                                                                      Q(y[E], { instancePath: t + "/patternProperties/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                      var p = O === o;
                                                                      if (!p)
                                                                        break;
                                                                    }
                                                                } else
                                                                  return Q.errors = [{ instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                              var a = _ === o;
                                                            } else
                                                              var a = !0;
                                                            if (a) {
                                                              if (e.dependencies !== void 0) {
                                                                let y = e.dependencies;
                                                                const _ = o;
                                                                if (o === _)
                                                                  if (y && typeof y == "object" && !Array.isArray(y))
                                                                    for (const E in y) {
                                                                      let O = y[E];
                                                                      const z = o, x = o;
                                                                      let L = !1;
                                                                      const M = o;
                                                                      Q(O, { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                      var u = M === o;
                                                                      if (L = L || u, !L) {
                                                                        const U = o;
                                                                        if (o === o)
                                                                          if (Array.isArray(O)) {
                                                                            var h = !0;
                                                                            const I = O.length;
                                                                            for (let T = 0; T < I; T++) {
                                                                              const j = o;
                                                                              if (typeof O[T] != "string") {
                                                                                const A = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + T, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                i === null ? i = [A] : i.push(A), o++;
                                                                              }
                                                                              var h = j === o;
                                                                              if (!h)
                                                                                break;
                                                                            }
                                                                            if (h) {
                                                                              let T = O.length, j;
                                                                              if (T > 1) {
                                                                                const P = {};
                                                                                for (; T--; ) {
                                                                                  let A = O[T];
                                                                                  if (typeof A == "string") {
                                                                                    if (typeof P[A] == "number") {
                                                                                      j = P[A];
                                                                                      const k = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: T, j }, message: "must NOT have duplicate items (items ## " + j + " and " + T + " are identical)" };
                                                                                      i === null ? i = [k] : i.push(k), o++;
                                                                                      break;
                                                                                    }
                                                                                    P[A] = T;
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            const I = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            i === null ? i = [I] : i.push(I), o++;
                                                                          }
                                                                        var u = U === o;
                                                                        L = L || u;
                                                                      }
                                                                      if (L)
                                                                        o = x, i !== null && (x ? i.length = x : i = null);
                                                                      else {
                                                                        const U = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return i === null ? i = [U] : i.push(U), o++, Q.errors = i, !1;
                                                                      }
                                                                      var b = z === o;
                                                                      if (!b)
                                                                        break;
                                                                    }
                                                                  else
                                                                    return Q.errors = [{ instancePath: t + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                var a = _ === o;
                                                              } else
                                                                var a = !0;
                                                              if (a) {
                                                                if (e.propertyNames !== void 0) {
                                                                  const y = o;
                                                                  Q(e.propertyNames, { instancePath: t + "/propertyNames", parentData: e, parentDataProperty: "propertyNames", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                  var a = y === o;
                                                                } else
                                                                  var a = !0;
                                                                if (a) {
                                                                  if (e.enum !== void 0) {
                                                                    let y = e.enum;
                                                                    const _ = o;
                                                                    if (o === _)
                                                                      if (Array.isArray(y)) {
                                                                        if (y.length < 1)
                                                                          return Q.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
                                                                        {
                                                                          let E = y.length, O;
                                                                          if (E > 1) {
                                                                            for (; E--; )
                                                                              for (O = E; O--; )
                                                                                if (mm(y[E], y[O]))
                                                                                  return Q.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: E, j: O }, message: "must NOT have duplicate items (items ## " + O + " and " + E + " are identical)" }], !1;
                                                                          }
                                                                        }
                                                                      } else
                                                                        return Q.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                                    var a = _ === o;
                                                                  } else
                                                                    var a = !0;
                                                                  if (a) {
                                                                    if (e.type !== void 0) {
                                                                      let y = e.type;
                                                                      const _ = o, R = o;
                                                                      let E = !1;
                                                                      const O = o;
                                                                      if (!(y === "array" || y === "boolean" || y === "integer" || y === "null" || y === "number" || y === "object" || y === "string")) {
                                                                        const x = { instancePath: t + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: dm.enum }, message: "must be equal to one of the allowed values" };
                                                                        i === null ? i = [x] : i.push(x), o++;
                                                                      }
                                                                      var m = O === o;
                                                                      if (E = E || m, !E) {
                                                                        const x = o;
                                                                        if (o === x)
                                                                          if (Array.isArray(y))
                                                                            if (y.length < 1) {
                                                                              const M = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                              i === null ? i = [M] : i.push(M), o++;
                                                                            } else {
                                                                              var v = !0;
                                                                              const M = y.length;
                                                                              for (let U = 0; U < M; U++) {
                                                                                let $ = y[U];
                                                                                const S = o;
                                                                                if (!($ === "array" || $ === "boolean" || $ === "integer" || $ === "null" || $ === "number" || $ === "object" || $ === "string")) {
                                                                                  const T = { instancePath: t + "/type/" + U, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: dm.enum }, message: "must be equal to one of the allowed values" };
                                                                                  i === null ? i = [T] : i.push(T), o++;
                                                                                }
                                                                                var v = S === o;
                                                                                if (!v)
                                                                                  break;
                                                                              }
                                                                              if (v) {
                                                                                let U = y.length, $;
                                                                                if (U > 1) {
                                                                                  e:
                                                                                    for (; U--; )
                                                                                      for ($ = U; $--; )
                                                                                        if (mm(y[U], y[$])) {
                                                                                          const S = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: U, j: $ }, message: "must NOT have duplicate items (items ## " + $ + " and " + U + " are identical)" };
                                                                                          i === null ? i = [S] : i.push(S), o++;
                                                                                          break e;
                                                                                        }
                                                                                }
                                                                              }
                                                                            }
                                                                          else {
                                                                            const M = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            i === null ? i = [M] : i.push(M), o++;
                                                                          }
                                                                        var m = x === o;
                                                                        E = E || m;
                                                                      }
                                                                      if (E)
                                                                        o = R, i !== null && (R ? i.length = R : i = null);
                                                                      else {
                                                                        const x = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return i === null ? i = [x] : i.push(x), o++, Q.errors = i, !1;
                                                                      }
                                                                      var a = _ === o;
                                                                    } else
                                                                      var a = !0;
                                                                    if (a) {
                                                                      if (e.format !== void 0) {
                                                                        const y = o;
                                                                        if (typeof e.format != "string")
                                                                          return Q.errors = [{ instancePath: t + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                        var a = y === o;
                                                                      } else
                                                                        var a = !0;
                                                                      if (a) {
                                                                        if (e.contentMediaType !== void 0) {
                                                                          const y = o;
                                                                          if (typeof e.contentMediaType != "string")
                                                                            return Q.errors = [{ instancePath: t + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                          var a = y === o;
                                                                        } else
                                                                          var a = !0;
                                                                        if (a) {
                                                                          if (e.contentEncoding !== void 0) {
                                                                            const y = o;
                                                                            if (typeof e.contentEncoding != "string")
                                                                              return Q.errors = [{ instancePath: t + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                            var a = y === o;
                                                                          } else
                                                                            var a = !0;
                                                                          if (a) {
                                                                            if (e.if !== void 0) {
                                                                              const y = o;
                                                                              Q(e.if, { instancePath: t + "/if", parentData: e, parentDataProperty: "if", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                              var a = y === o;
                                                                            } else
                                                                              var a = !0;
                                                                            if (a) {
                                                                              if (e.then !== void 0) {
                                                                                const y = o;
                                                                                Q(e.then, { instancePath: t + "/then", parentData: e, parentDataProperty: "then", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                                var a = y === o;
                                                                              } else
                                                                                var a = !0;
                                                                              if (a) {
                                                                                if (e.else !== void 0) {
                                                                                  const y = o;
                                                                                  Q(e.else, { instancePath: t + "/else", parentData: e, parentDataProperty: "else", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                                  var a = y === o;
                                                                                } else
                                                                                  var a = !0;
                                                                                if (a) {
                                                                                  if (e.allOf !== void 0) {
                                                                                    const y = o;
                                                                                    Et(e.allOf, { instancePath: t + "/allOf", parentData: e, parentDataProperty: "allOf", rootData: s }) || (i = i === null ? Et.errors : i.concat(Et.errors), o = i.length);
                                                                                    var a = y === o;
                                                                                  } else
                                                                                    var a = !0;
                                                                                  if (a) {
                                                                                    if (e.anyOf !== void 0) {
                                                                                      const y = o;
                                                                                      Et(e.anyOf, { instancePath: t + "/anyOf", parentData: e, parentDataProperty: "anyOf", rootData: s }) || (i = i === null ? Et.errors : i.concat(Et.errors), o = i.length);
                                                                                      var a = y === o;
                                                                                    } else
                                                                                      var a = !0;
                                                                                    if (a) {
                                                                                      if (e.oneOf !== void 0) {
                                                                                        const y = o;
                                                                                        Et(e.oneOf, { instancePath: t + "/oneOf", parentData: e, parentDataProperty: "oneOf", rootData: s }) || (i = i === null ? Et.errors : i.concat(Et.errors), o = i.length);
                                                                                        var a = y === o;
                                                                                      } else
                                                                                        var a = !0;
                                                                                      if (a)
                                                                                        if (e.not !== void 0) {
                                                                                          const y = o;
                                                                                          Q(e.not, { instancePath: t + "/not", parentData: e, parentDataProperty: "not", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                                          var a = y === o;
                                                                                        } else
                                                                                          var a = !0;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return Q.errors = i, o === 0;
}
var rI = fd.exports;
let nI = class extends Error {
  constructor(t, r) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Failed to merge "${t}" keyword schemas.`, this.schemas = r;
  }
};
class sI extends Error {
  constructor(t, r) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Resolver for "${t}" keyword not found.`, this.schemas = r;
  }
}
class iI extends Error {
  constructor(t) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Invalid "onConflict" option: "${t}".`;
  }
}
var L0 = {
  MergeError: nI,
  ResolverNotFoundError: sI,
  InvalidOnConflictOptionError: iI
};
const { dequal: oI } = ga, { MergeError: dd } = L0;
function j0(e) {
  let t = e[0];
  for (let r = 1; r < e.length; r++)
    t = t.filter(
      (n) => e[r].includes(n)
    );
  return t;
}
function aI(e, t, r) {
  const n = j0(t);
  if (n.length === 0)
    throw new dd(e, t);
  r[e] = n;
}
function cI(e, t, r) {
  for (let s = 0; s < t.length; s++)
    Array.isArray(t[s]) || (t[s] = [t[s]]);
  const n = j0(t);
  if (n.length === 0)
    throw new dd(e, t);
  n.length === 1 ? r[e] = n[0] : r[e] = n;
}
function lI(e, t, r) {
  const n = [];
  for (const s of t)
    for (const i of s)
      n.includes(i) || n.push(i);
  r[e] = n;
}
function uI(e, t, r) {
  r[e] = Math.min(...t);
}
function fI(e, t, r) {
  r[e] = Math.max(...t);
}
function dI(e, t, r) {
  const n = (a, c) => c ? n(c, a % c) : a, s = (a, c) => a * c / n(a, c);
  let i = 1;
  for (const a of t)
    for (; a * i % 1 !== 0; )
      i *= 10;
  let o = t[0] * i;
  for (const a of t)
    o = s(o, a * i);
  r[e] = o / i;
}
function pI(e, t, r) {
  const n = t[0];
  for (let s = 1; s < t.length; s++)
    if (!oI(t[s], n))
      throw new dd(e, t);
  r[e] = n;
}
function hI() {
}
function mI(e, t, r) {
  for (const n of t)
    if (n === !1) {
      r[e] = !1;
      return;
    }
  r[e] = !0;
}
function yI(e, t, r) {
  for (const n of t)
    if (n === !0) {
      r[e] = !0;
      return;
    }
  r[e] = !1;
}
var gI = {
  arraysIntersection: aI,
  hybridArraysIntersection: cI,
  arraysUnion: lI,
  minNumber: uI,
  maxNumber: fI,
  commonMultiple: dI,
  allEqual: pI,
  booleanAnd: mI,
  booleanOr: yI,
  skip: hI
};
const { dequal: vI } = ga, Le = gI, qo = L0, bI = {
  $id: Le.skip,
  type: Le.hybridArraysIntersection,
  enum: Le.arraysIntersection,
  minLength: Le.maxNumber,
  maxLength: Le.minNumber,
  minimum: Le.maxNumber,
  maximum: Le.minNumber,
  multipleOf: Le.commonMultiple,
  exclusiveMinimum: Le.maxNumber,
  exclusiveMaximum: Le.minNumber,
  minItems: Le.maxNumber,
  maxItems: Le.minNumber,
  maxProperties: Le.minNumber,
  minProperties: Le.maxNumber,
  const: Le.allEqual,
  default: Le.allEqual,
  format: Le.allEqual,
  required: Le.arraysUnion,
  properties: RI,
  patternProperties: qi,
  additionalProperties: Ui,
  items: xI,
  additionalItems: SI,
  definitions: qi,
  $defs: qi,
  nullable: Le.booleanAnd,
  oneOf: ym,
  anyOf: ym,
  allOf: Le.arraysUnion,
  not: Ui,
  if: $I,
  then: Le.skip,
  else: Le.skip,
  dependencies: gm,
  dependentRequired: gm,
  dependentSchemas: qi,
  propertyNames: Ui,
  uniqueItems: Le.booleanOr,
  contains: Ui
};
function Ui(e, t, r, n, s) {
  r[e] = Yt(t, s);
}
function _I(e) {
  let t = [[]];
  for (const r of e) {
    const n = [];
    for (const s of t)
      for (const i of r)
        n.push([...s, i]);
    t = n;
  }
  return t;
}
function ym(e, t, r, n, s) {
  if (t.length === 1) {
    r[e] = t[0];
    return;
  }
  const i = _I(t), o = [];
  for (const a of i)
    try {
      const c = Yt(a, s);
      c !== void 0 && o.push(c);
    } catch (c) {
      if (c instanceof qo.MergeError) continue;
      throw c;
    }
  r[e] = o;
}
function EI(e, t) {
  const { items: r, additionalItems: n } = e;
  return Array.isArray(r) ? t < r.length ? r[t] : n : r !== void 0 ? r : n;
}
function xI(e, t, r, n, s) {
  let i = 0;
  for (const a of t)
    Array.isArray(a) && (i = Math.max(i, a.length));
  if (i === 0) {
    r[e] = Yt(t, s);
    return;
  }
  const o = [];
  for (let a = 0; a < i; a++) {
    const c = [];
    for (const f of n) {
      const l = EI(f, a);
      l !== void 0 && c.push(l);
    }
    o[a] = Yt(c, s);
  }
  r[e] = o;
}
function SI(e, t, r, n, s) {
  let i = !1;
  for (const a of n)
    if (Array.isArray(a.items)) {
      i = !0;
      break;
    }
  if (!i) {
    r[e] = Yt(t, s);
    return;
  }
  const o = [];
  for (const a of n) {
    let c = a.additionalItems;
    c === void 0 && !Array.isArray(a.items) && (c = a.items), c !== void 0 && o.push(c);
  }
  r[e] = Yt(o, s);
}
function wI(e, t) {
  const { properties: r, patternProperties: n, additionalProperties: s } = e;
  if ((r == null ? void 0 : r[t]) !== void 0)
    return r[t];
  for (const i of Object.keys(n ?? {}))
    if (new RegExp(i).test(t))
      return n[i];
  return s;
}
function RI(e, t, r, n, s) {
  const i = {};
  for (const a of n) {
    const c = a.properties ?? {};
    for (const f of Object.keys(c)) {
      if (i[f] !== void 0) continue;
      const l = c[f];
      i[f] = [l];
      for (const d of n) {
        if (a === d) continue;
        const g = wI(d, f);
        g !== void 0 && i[f].push(g);
      }
    }
  }
  const o = {};
  for (const a of Object.keys(i)) {
    const c = i[a];
    o[a] = Yt(c, s);
  }
  r[e] = o;
}
function qi(e, t, r, n, s) {
  const i = {};
  for (const a of t)
    for (const c of Object.keys(a))
      i[c] === void 0 && (i[c] = []), i[c].push(a[c]);
  const o = {};
  for (const a of Object.keys(i)) {
    const c = i[a], f = Yt(c, s);
    o[a] = f;
  }
  r[e] = o;
}
function $I(e, t, r, n, s) {
  for (let i = 0; i < n.length; i++) {
    const o = {
      if: n[i].if,
      then: n[i].then,
      else: n[i].else
    };
    if (o.if !== void 0) {
      if (r.if === void 0) {
        r.if = o.if, o.then !== void 0 && (r.then = o.then), o.else !== void 0 && (r.else = o.else);
        continue;
      }
      r.then !== void 0 && (r.then = Yt([r.then, o], s)), r.else !== void 0 && (r.else = Yt([r.else, o], s));
    }
  }
}
function gm(e, t, r) {
  const n = {};
  for (const s of t)
    for (const i of Object.keys(s)) {
      n[i] === void 0 && (n[i] = []);
      const o = n[i];
      for (const a of s[i])
        o.includes(a) || o.push(a);
    }
  r[e] = n;
}
function Yt(e, t) {
  if (e.length === 0) return {};
  if (e.length === 1) return e[0];
  const r = {}, n = {};
  let s = !0;
  for (const i of e) {
    if (i === !1) return !1;
    if (i !== !0) {
      s = !1;
      for (const o of Object.keys(i))
        n[o] === void 0 && (n[o] = []), n[o].push(i[o]);
    }
  }
  if (s) return !0;
  for (const i of Object.keys(n)) {
    const o = n[i];
    (t.resolvers[i] ?? t.defaultResolver)(i, o, r, e, t);
  }
  return r;
}
function TI(e, t, r, n, s) {
  const i = s.onConflict ?? "throw";
  if (t.length === 1 || i === "first") {
    r[e] = t[0];
    return;
  }
  let o = !0;
  for (let a = 1; a < t.length; a++)
    if (!vI(t[a], t[0])) {
      o = !1;
      break;
    }
  if (o) {
    r[e] = t[0];
    return;
  }
  if (i === "throw")
    throw new qo.ResolverNotFoundError(e, t);
  if (i !== "skip")
    throw new qo.InvalidOnConflictOptionError(i);
}
function OI(e, t = {}) {
  return t.defaultResolver === void 0 && (t.defaultResolver = TI), t.resolvers = { ...bI, ...t.resolvers }, Yt(e, t);
}
var PI = { mergeSchemas: OI, ...qo };
const { mergeSchemas: CI } = PI;
function II(e) {
  return CI(e, { onConflict: "skip" });
}
var NI = II, Hi = { exports: {} }, vm;
function AI() {
  if (vm) return Hi.exports;
  vm = 1;
  function e(t, r, n, s) {
    let i = "";
    r.validatorSchemasIds.size > 0 ? (i += `const Validator = require('fast-json-stringify/lib/validator')
`, i += `const validatorState = ${JSON.stringify(s.getState())}
`, i += `const validator = Validator.restoreFromState(validatorState)
`) : i += `const validator = null
`;
    const { schema: o, ...a } = n.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(a)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${i}

  module.exports = ${t.toString()}(validator, serializer)`;
  }
  return Hi.exports = e, Hi.exports.dependencies = {
    Serializer: tf,
    Validator: A0
  }, Hi.exports;
}
const { RefResolver: kI } = r1, LI = tf, jI = A0, _n = QC, bm = rI, DI = NI, FI = /'/g;
let vo = 2e4, D0 = "default";
const MI = [
  "floor",
  "ceil",
  "round",
  "trunc"
], F0 = [
  "default",
  "json-stringify"
];
let Hs = 0;
function bu(e, t) {
  if (!bm(e)) {
    t ? t = `"${t}" ` : t = "";
    const r = bm.errors[0], n = new Error(`${t}schema is invalid: data${r.instancePath} ${r.message}`);
    throw n.errors = bu.errors, n;
  }
}
function hi(e, t) {
  const r = t.schema.$ref;
  let n = r.indexOf("#");
  n === -1 && (n = r.length);
  const s = r.slice(0, n) || t.schemaId, i = r.slice(n) || "#", o = e.refResolver.getSchema(s, i);
  if (o === null)
    throw new Error(`Cannot find reference "${r}"`);
  const a = new _n(o, s, i);
  return o.$ref !== void 0 ? hi(e, a) : a;
}
function Ho(e, t) {
  const r = e.refResolver.getSchema(t, "#");
  return new _n(r, t, "#");
}
function _m(e, t) {
  return e.$id && e.$id.charAt(0) !== "#" ? e.$id : t;
}
function pd(e, t) {
  bu(e), t = t || {};
  const r = {
    functions: [],
    functionsCounter: 0,
    functionsNamesBySchema: /* @__PURE__ */ new Map(),
    options: t,
    refResolver: new kI(),
    rootSchemaId: e.$id || `__fjs_root_${Hs++}`,
    validatorSchemasIds: /* @__PURE__ */ new Set(),
    mergedSchemasIds: /* @__PURE__ */ new Map()
  }, n = _m(e, r.rootSchemaId);
  if (r.refResolver.hasSchema(n) || r.refResolver.addSchema(e, r.rootSchemaId), t.schema)
    for (const l in t.schema) {
      const d = t.schema[l], g = _m(d, l);
      r.refResolver.hasSchema(g) || (bu(d, l), r.refResolver.addSchema(d, l));
    }
  if (t.rounding && !MI.includes(t.rounding))
    throw new Error(`Unsupported integer rounding method ${t.rounding}`);
  if (t.largeArrayMechanism)
    if (F0.includes(t.largeArrayMechanism))
      D0 = t.largeArrayMechanism;
    else
      throw new Error(`Unsupported large array mechanism ${t.largeArrayMechanism}`);
  if (t.largeArraySize)
    if (typeof t.largeArraySize == "string" && Number.isFinite(Number.parseInt(t.largeArraySize, 10)))
      vo = Number.parseInt(t.largeArraySize, 10);
    else if (typeof t.largeArraySize == "number" && Number.isInteger(t.largeArraySize))
      vo = t.largeArraySize;
    else if (typeof t.largeArraySize == "bigint")
      vo = Number(t.largeArraySize);
    else
      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof t.largeArraySize} with value ${t.largeArraySize}`);
  const s = new _n(e, r.rootSchemaId), i = kt(r, s, "input");
  let o = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
  i === "json += anonymous0(input)" ? o += `
    ${r.functions.join(`
`)}
    const main = anonymous0
    return main
    ` : o += `
    function main (input) {
      let json = ''
      ${i}
      return json
    }
    ${r.functions.join(`
`)}
    return main
    `;
  const a = new LI(t), c = new jI(t.ajv);
  for (const l of r.validatorSchemasIds) {
    const d = r.refResolver.getSchema(l);
    c.addSchema(d, l);
    const g = r.refResolver.getSchemaDependencies(l);
    for (const [p, u] of Object.entries(g))
      c.addSchema(u, p);
  }
  if (t.debugMode && (t.mode = "debug"), t.mode === "debug")
    return {
      validator: c,
      serializer: a,
      code: `validator
serializer
${o}`,
      ajv: c.ajv
    };
  const f = new Function("validator", "serializer", o);
  return t.mode === "standalone" ? AI()(f, r, a, c) : f(c, a);
}
const zI = [
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "maxProperties",
  "minProperties",
  "dependencies"
], UI = [
  "items",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "contains"
], qI = [
  "maxLength",
  "minLength",
  "pattern"
], HI = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum"
];
function BI(e) {
  for (const t of zI)
    if (t in e) return "object";
  for (const t of UI)
    if (t in e) return "array";
  for (const t of qI)
    if (t in e) return "string";
  for (const t of HI)
    if (t in e) return "number";
  return e.type;
}
function VI(e, t, r) {
  const n = t.schema, s = Object.keys(n.properties || {});
  let i = `
    const propertiesKeys = ${JSON.stringify(s)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
  const o = t.getPropertyLocation("patternProperties"), a = o.schema;
  if (a !== void 0)
    for (const l in a) {
      const d = o.getPropertyLocation(l);
      i += `
        if (/${l.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${r}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${kt(e, d, "value")}
          continue
        }
      `;
    }
  const f = t.getPropertyLocation("additionalProperties").schema;
  if (f !== void 0)
    if (f === !0)
      i += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
    else {
      const l = t.getPropertyLocation("additionalProperties");
      i += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${kt(e, l, "value")}
      `;
    }
  return i += `
    }
  `, i;
}
function GI(e, t) {
  const r = t.schema, n = t.getPropertyLocation("properties"), s = r.required || [], i = Object.keys(r.properties || {}).sort(
    (f, l) => {
      const d = s.includes(f), g = s.includes(l);
      return d === g ? 0 : d ? -1 : 1;
    }
  ), o = s.includes(i[0]);
  let a = `let value
`;
  for (const f of s)
    if (!i.includes(f)) {
      const l = JSON.stringify(f);
      a += `if (obj[${l}] === undefined) throw new Error('${l.replace(/'/g, "\\'")} is required!')
`;
    }
  a += `let json = JSON_STR_BEGIN_OBJECT
`;
  let c = "";
  o || (a += `let addComma = false
`, c = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)");
  for (const f of i) {
    let l = n.getPropertyLocation(f);
    l.schema.$ref && (l = hi(e, l));
    const d = JSON.stringify(f), g = l.schema.default, p = s.includes(f);
    a += `
      value = obj[${d}]
      if (value !== undefined) {
        ${c}
        json += ${JSON.stringify(d + ":")}
        ${kt(e, l, "value")}
      }`, g !== void 0 ? a += ` else {
        ${c}
        json += ${JSON.stringify(d + ":" + JSON.stringify(g))}
      }
      ` : p ? a += ` else {
        throw new Error('${d.replace(/'/g, "\\'")} is required!')
      }
      ` : a += `
`, o && (c = "json += ','");
  }
  return (r.patternProperties || r.additionalProperties) && (a += VI(e, t, c)), a += `
    return json + JSON_STR_END_OBJECT
  `, a;
}
function Bo(e, t, r) {
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    a.schema.$ref && (r[o] = hi(e, a));
  }
  const n = [];
  for (const o of r) {
    const a = M0(e, o.schema, o.schemaId);
    delete a.$id, n.push(a);
  }
  const s = DI(n), i = new _n(s, t);
  return e.refResolver.addSchema(s, t), i;
}
function M0(e, t, r) {
  const n = Array.isArray(t) ? [] : {};
  t.$id !== void 0 && t.$id.charAt(0) !== "#" && (r = t.$id);
  const s = e.mergedSchemasIds.get(t);
  s && e.mergedSchemasIds.set(n, s);
  for (const i in t) {
    let o = t[i];
    i === "$ref" && typeof o == "string" && o.charAt(0) === "#" && (o = r + o), typeof o == "object" && o !== null && (o = M0(e, o, r)), n[i] = o;
  }
  return n;
}
function WI(e) {
  return `(${e} && typeof ${e}.toJSON === 'function')
    ? ${e}.toJSON()
    : ${e}
  `;
}
function KI(e, t) {
  const r = t.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const n = U0(e);
  e.functionsNamesBySchema.set(r, n);
  let s = t.getSchemaRef();
  s.startsWith(e.rootSchemaId) && (s = s.replace(e.rootSchemaId, ""));
  let i = `
  `;
  const o = r.nullable === !0;
  return i += `
    // ${s}
    function ${n} (input) {
      const obj = ${WI("input")}
      ${o ? "" : "if (obj === null) return JSON_STR_EMPTY_OBJECT"}

      ${GI(e, t)}
    }
  `, e.functions.push(i), n;
}
function JI(e, t) {
  const r = t.schema;
  let n = t.getPropertyLocation("items");
  n.schema = n.schema || {}, n.schema.$ref && (n = hi(e, n));
  const s = n.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const i = U0(e);
  e.functionsNamesBySchema.set(r, i);
  let o = t.getSchemaRef();
  o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, ""));
  let a = `
    function ${i} (obj) {
      // ${o}
  `;
  const c = r.nullable === !0;
  if (a += `
    ${c ? "" : "if (obj === null) return JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `, !r.additionalItems && Array.isArray(s) && (a += `
      if (arrayLength > ${s.length}) {
        throw new Error(\`Item at ${s.length} does not match schema definition.\`)
      }
    `), D0 === "json-stringify" && (a += `if (arrayLength >= ${vo}) return JSON.stringify(obj)
`), a += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `, Array.isArray(s)) {
    for (let f = 0; f < s.length; f++) {
      const l = s[f];
      a += `value = obj[${f}]`;
      const d = kt(e, n.getPropertyLocation(f), "value");
      a += `
        if (${f} < arrayLength) {
          if (${z0(l.type)}) {
            ${d}
            if (${f} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${f} does not match schema definition.\`)
          }
        }
        `;
    }
    r.additionalItems && (a += `
        for (let i = ${s.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`);
  } else {
    const f = kt(e, n, "obj[i]");
    a += `
      for (let i = 0; i < arrayLength; i++) {
        ${f}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
  }
  return a += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`, e.functions.push(a), i;
}
function z0(e, t) {
  let r;
  switch (e) {
    case "null":
      r = "value === null";
      break;
    case "string":
      r = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
      break;
    case "integer":
      r = "Number.isInteger(value)";
      break;
    case "number":
      r = "Number.isFinite(value)";
      break;
    case "boolean":
      r = "typeof value === 'boolean'";
      break;
    case "object":
      r = "value && typeof value === 'object' && value.constructor === Object";
      break;
    case "array":
      r = "Array.isArray(value)";
      break;
    default:
      Array.isArray(e) && (r = `(${e.map((s) => z0(s)).join(" || ")})`);
  }
  return r;
}
function U0(e) {
  return "anonymous" + e.functionsCounter++;
}
function YI(e, t, r) {
  const s = t.schema.type.sort((a) => a === "null" ? -1 : 1);
  let i = "";
  s.forEach((a, c) => {
    t.schema = { ...t.schema, type: a };
    const f = q0(e, t, r), l = c === 0 ? "if" : "else if";
    switch (a) {
      case "null":
        i += `
          ${l} (${r} === null)
            ${f}
          `;
        break;
      case "string": {
        i += `
          ${l}(
            typeof ${r} === "string" ||
            ${r} === null ||
            ${r} instanceof Date ||
            ${r} instanceof RegExp ||
            (
              typeof ${r} === "object" &&
              typeof ${r}.toString === "function" &&
              ${r}.toString !== Object.prototype.toString
            )
          )
            ${f}
        `;
        break;
      }
      case "array": {
        i += `
          ${l}(Array.isArray(${r}))
            ${f}
        `;
        break;
      }
      case "integer": {
        i += `
          ${l}(Number.isInteger(${r}) || ${r} === null)
            ${f}
        `;
        break;
      }
      default: {
        i += `
          ${l}(typeof ${r} === "${a}" || ${r} === null)
            ${f}
        `;
        break;
      }
    }
  });
  let o = t.getSchemaRef();
  return o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, "")), i += `
    else throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
  `, i;
}
function q0(e, t, r) {
  const n = t.schema;
  switch (n.type) {
    case "null":
      return "json += JSON_STR_NULL";
    case "string":
      return n.format === "date-time" ? `json += serializer.asDateTime(${r})` : n.format === "date" ? `json += serializer.asDate(${r})` : n.format === "time" ? `json += serializer.asTime(${r})` : n.format === "unsafe" ? `json += serializer.asUnsafeString(${r})` : `
        if (typeof ${r} !== 'string') {
          if (${r} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${r} instanceof Date) {
            json += JSON_STR_QUOTE + ${r}.toISOString() + JSON_STR_QUOTE
          } else if (${r} instanceof RegExp) {
            json += serializer.asString(${r}.source)
          } else {
            json += serializer.asString(${r}.toString())
          }
        } else {
          json += serializer.asString(${r})
        }
        `;
    case "integer":
      return `json += serializer.asInteger(${r})`;
    case "number":
      return `json += serializer.asNumber(${r})`;
    case "boolean":
      return `json += serializer.asBoolean(${r})`;
    case "object":
      return `json += ${KI(e, t)}(${r})`;
    case "array":
      return `json += ${JI(e, t)}(${r})`;
    case void 0:
      return `json += JSON.stringify(${r})`;
    default:
      throw new Error(`${n.type} unsupported`);
  }
}
function XI(e, t) {
  const r = e.schema, n = r.type, s = Array.isArray(n) && n.includes("null");
  let i = "";
  return s && (i += `
      if (${t} === null) {
        json += JSON_STR_NULL
      } else {
    `), i += `json += '${JSON.stringify(r.const).replace(FI, "\\'")}'`, s && (i += `
      }
    `), i;
}
function ZI(e, t, r) {
  const n = t.schema;
  let s = e.mergedSchemasIds.get(n);
  if (s) {
    const l = Ho(e, s);
    return kt(e, l, r);
  }
  s = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(n, s);
  const { allOf: i, ...o } = t.schema, a = [
    new _n(
      o,
      t.schemaId,
      t.jsonPointer
    )
  ], c = t.getPropertyLocation("allOf");
  for (let l = 0; l < i.length; l++)
    a.push(c.getPropertyLocation(l));
  const f = Bo(e, s, a);
  return kt(e, f, r);
}
function QI(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const s = t.schema.anyOf ? "anyOf" : "oneOf", { [s]: i, ...o } = t.schema, a = new _n(
    o,
    t.schemaId,
    t.jsonPointer
  ), c = t.getPropertyLocation(s);
  let f = "";
  for (let d = 0; d < i.length; d++) {
    const g = c.getPropertyLocation(d), p = g.schema;
    let u = e.mergedSchemasIds.get(p), h = null;
    u ? h = Ho(e, u) : (u = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(p, u), h = Bo(e, u, [
      a,
      g
    ]));
    const b = kt(e, h, r), m = g.getSchemaRef();
    f += `
      ${d === 0 ? "if" : "else if"}(validator.validate("${m}", ${r}))
        ${b}
    `;
  }
  let l = t.getSchemaRef();
  return l.startsWith(e.rootSchemaId) && (l = l.replace(e.rootSchemaId, "")), f += `
    else throw new TypeError(\`The value of '${l}' does not match schema definition.\`)
  `, f;
}
function eN(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const {
    if: n,
    then: s,
    else: i,
    ...o
  } = t.schema, a = new _n(
    o,
    t.schemaId,
    t.jsonPointer
  ), f = t.getPropertyLocation("if").getSchemaRef(), l = t.getPropertyLocation("then");
  let d = e.mergedSchemasIds.get(s), g = null;
  if (d ? g = Ho(e, d) : (d = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(s, d), g = Bo(e, d, [
    a,
    l
  ])), !i)
    return `
      if (validator.validate("${f}", ${r})) {
        ${kt(e, g, r)}
      } else {
        ${kt(e, a, r)}
      }
    `;
  const p = t.getPropertyLocation("else");
  let u = e.mergedSchemasIds.get(i), h = null;
  return u ? h = Ho(e, u) : (u = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(i, u), h = Bo(e, u, [
    a,
    p
  ])), `
    if (validator.validate("${f}", ${r})) {
      ${kt(e, g, r)}
    } else {
      ${kt(e, h, r)}
    }
  `;
}
function kt(e, t, r) {
  let n = t.schema;
  if (typeof n == "boolean")
    return `json += JSON.stringify(${r})`;
  if (n.$ref && (t = hi(e, t), n = t.schema), n.allOf)
    return ZI(e, t, r);
  if (n.anyOf || n.oneOf)
    return QI(e, t, r);
  if (n.if && n.then)
    return eN(e, t, r);
  if (n.type === void 0) {
    const a = BI(n);
    a && (n.type = a);
  }
  let s = "";
  const i = n.type, o = n.nullable === !0;
  return o && (s += `
      if (${r} === null) {
        json += JSON_STR_NULL
      } else {
    `), n.const !== void 0 ? s += XI(t, r) : Array.isArray(i) ? s += YI(e, t, r) : s += q0(e, t, r), o && (s += `
      }
    `), s;
}
ns.exports = pd;
ns.exports.default = pd;
ns.exports.build = pd;
ns.exports.validLargeArrayMechanisms = F0;
ns.exports.restore = function({ code: e, validator: t, serializer: r }) {
  return Function.apply(null, ["validator", "serializer", e]).apply(null, [t, r]);
};
var tN = ns.exports;
const rN = tN;
function H0() {
  return function(t, r) {
    const n = Object.assign({}, r, { schema: t });
    return nN.bind(null, n);
  };
}
function nN(e, {
  schema: t
  /* method, url, httpStatus */
}) {
  return e.schema && t.$id && e.schema[t.$id] && (e.schema = { ...e.schema }, delete e.schema[t.$id]), rN(t, e);
}
function B0(e = { readMode: !0 }) {
  if (e.readMode === !0 && typeof e.restoreFunction != "function")
    throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
  if (e.readMode !== !0 && typeof e.storeFunction != "function")
    throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
  if (e.readMode === !0)
    return function() {
      return function(n) {
        return e.restoreFunction(n);
      };
    };
  const t = H0();
  return function(n, s = {}) {
    s.mode = "standalone";
    const i = t(n, s);
    return function(o) {
      const a = i(o);
      return e.storeFunction(o, a), new Function(a);
    };
  };
}
ya.SerializerSelector = H0;
ya.StandaloneSerializer = B0;
ya.default = B0;
const { SerializerSelector: hd, StandaloneSerializer: sN } = ya;
fi.exports = hd;
fi.exports.default = hd;
fi.exports.SerializerSelector = hd;
fi.exports.StandaloneSerializer = sN;
var iN = fi.exports, Wr = { exports: {} }, _u = { exports: {} }, md = {}, En = {}, Ht = {};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.checkMetadata = void 0;
const oN = re, aN = {
  keyword: "metadata",
  schemaType: "object",
  code(e) {
    V0(e);
    const { gen: t, schema: r, it: n } = e;
    if ((0, oN.alwaysValidSchema)(n, r))
      return;
    const s = t.name("valid");
    e.subschema({ keyword: "metadata", jtdMetadata: !0 }, s), e.ok(s);
  }
};
function V0({ it: e, keyword: t }, r) {
  if (e.jtdMetadata !== r)
    throw new Error(`JTD: "${t}" cannot be used in this schema location`);
}
Ht.checkMetadata = V0;
Ht.default = aN;
Object.defineProperty(En, "__esModule", { value: !0 });
En.hasRef = void 0;
const Em = ft, vs = ae, cN = mr, xm = jt, Sm = qr, lN = Ht, uN = {
  keyword: "ref",
  schemaType: "string",
  code(e) {
    (0, lN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: s, it: i } = e, { schemaEnv: { root: o } } = i, a = t.name("valid");
    s.nullable ? (t.var(a, (0, vs._)`${r} === null`), t.if((0, vs.not)(a), c)) : (t.var(a, !1), c()), e.ok(a);
    function c() {
      var d;
      const g = (d = o.schema.definitions) === null || d === void 0 ? void 0 : d[n];
      if (!g)
        throw new cN.default(i.opts.uriResolver, "", n, `No definition ${n}`);
      yd(g) || !i.opts.inlineRefs ? f(g) : l(g);
    }
    function f(d) {
      const g = Em.compileSchema.call(i.self, new Em.SchemaEnv({ schema: d, root: o, schemaPath: `/definitions/${n}` })), p = (0, Sm.getValidate)(e, g), u = t.const("_errs", xm.default.errors);
      (0, Sm.callRef)(e, p, g, g.$async), t.assign(a, (0, vs._)`${u} === ${xm.default.errors}`);
    }
    function l(d) {
      const g = t.scopeValue("schema", i.opts.code.source === !0 ? { ref: d, code: (0, vs.stringify)(d) } : { ref: d });
      e.subschema({
        schema: d,
        dataTypes: [],
        schemaPath: vs.nil,
        topSchemaRef: g,
        errSchemaPath: `/definitions/${n}`
      }, a);
    }
  }
};
function yd(e) {
  for (const t in e) {
    let r;
    if (t === "ref" || typeof (r = e[t]) == "object" && yd(r))
      return !0;
  }
  return !1;
}
En.hasRef = yd;
En.default = uN;
var gd = {}, Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
const fN = /t|\s/i, dN = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, pN = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i, hN = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function G0(e, t) {
  const r = e.split(fN);
  return r.length === 2 && wm(r[0]) && mN(r[1]) || t && r.length === 1 && wm(r[0]);
}
Ra.default = G0;
function wm(e) {
  const t = dN.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], s = +t[3];
  return n >= 1 && n <= 12 && s >= 1 && (s <= hN[n] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
  n === 2 && s === 29 && (r % 100 === 0 ? r % 400 === 0 : r % 4 === 0));
}
function mN(e) {
  const t = pN.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], s = +t[3], i = +(t[4] || 0), o = +(t[5] || 0);
  return r <= 23 && n <= 59 && s <= 59 || // leap second
  r - i === 23 && n - o === 59 && s === 60;
}
G0.code = 'require("ajv/dist/runtime/timestamp").default';
var qt = {};
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.typeErrorParams = qt.typeErrorMessage = qt.typeError = void 0;
const yN = ae;
function gN(e) {
  return {
    message: (t) => W0(t, e),
    params: (t) => K0(t, e)
  };
}
qt.typeError = gN;
function W0({ parentSchema: e }, t) {
  return e != null && e.nullable ? `must be ${t} or null` : `must be ${t}`;
}
qt.typeErrorMessage = W0;
function K0({ parentSchema: e }, t) {
  return (0, yN._)`{type: ${t}, nullable: ${!!(e != null && e.nullable)}}`;
}
qt.typeErrorParams = K0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intRange = void 0;
  const t = ae, r = Ra, n = re, s = Ht, i = qt;
  e.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10]
  };
  const o = {
    message: (f) => (0, i.typeErrorMessage)(f, f.schema),
    params: (f) => (0, i.typeErrorParams)(f, f.schema)
  };
  function a(f) {
    const { gen: l, data: d, it: g } = f, { timestamp: p, allowDate: u } = g.opts;
    if (p === "date")
      return (0, t._)`${d} instanceof Date `;
    const h = (0, n.useFunc)(l, r.default), b = u ? (0, t._)`, true` : t.nil, m = (0, t._)`typeof ${d} == "string" && ${h}(${d}${b})`;
    return p === "string" ? m : (0, t.or)((0, t._)`${d} instanceof Date`, m);
  }
  const c = {
    keyword: "type",
    schemaType: "string",
    error: o,
    code(f) {
      (0, s.checkMetadata)(f);
      const { data: l, schema: d, parentSchema: g, it: p } = f;
      let u;
      switch (d) {
        case "boolean":
        case "string":
          u = (0, t._)`typeof ${l} == ${d}`;
          break;
        case "timestamp": {
          u = a(f);
          break;
        }
        case "float32":
        case "float64":
          u = (0, t._)`typeof ${l} == "number"`;
          break;
        default: {
          const h = d;
          if (u = (0, t._)`typeof ${l} == "number" && isFinite(${l}) && !(${l} % 1)`, !p.opts.int32range && (h === "int32" || h === "uint32"))
            h === "uint32" && (u = (0, t._)`${u} && ${l} >= 0`);
          else {
            const [b, m] = e.intRange[h];
            u = (0, t._)`${u} && ${l} >= ${b} && ${l} <= ${m}`;
          }
        }
      }
      f.pass(g.nullable ? (0, t.or)((0, t._)`${l} === null`, u) : u);
    }
  };
  e.default = c;
})(gd);
var vd = {}, dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.checkNullableObject = dr.checkNullable = void 0;
const bo = ae;
function J0({ gen: e, data: t, parentSchema: r }, n = bo.nil) {
  const s = e.name("valid");
  return r.nullable ? (e.let(s, (0, bo._)`${t} === null`), n = (0, bo.not)(s)) : e.let(s, !1), [s, n];
}
dr.checkNullable = J0;
function vN(e, t) {
  const [r, n] = J0(e, t);
  return [r, (0, bo._)`${n} && typeof ${e.data} == "object" && !Array.isArray(${e.data})`];
}
dr.checkNullableObject = vN;
Object.defineProperty(vd, "__esModule", { value: !0 });
const Ar = ae, bN = Ht, _N = dr, EN = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Ar._)`{allowedValues: ${e}}`
}, xN = {
  keyword: "enum",
  schemaType: "array",
  error: EN,
  code(e) {
    (0, bN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, schemaValue: s, parentSchema: i, it: o } = e;
    if (n.length === 0)
      throw new Error("enum must have non-empty array");
    if (n.length !== new Set(n).size)
      throw new Error("enum items must be unique");
    let a;
    const c = (0, Ar._)`typeof ${r} == "string"`;
    if (n.length >= o.opts.loopEnum) {
      let l;
      [a, l] = (0, _N.checkNullable)(e, c), t.if(l, f);
    } else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      a = (0, Ar.and)(c, (0, Ar.or)(...n.map((l) => (0, Ar._)`${r} === ${l}`))), i.nullable && (a = (0, Ar.or)((0, Ar._)`${r} === null`, a));
    }
    e.pass(a);
    function f() {
      t.forOf("v", s, (l) => t.if((0, Ar._)`${a} = ${r} === ${l}`, () => t.break()));
    }
  }
};
vd.default = xN;
var bd = {};
Object.defineProperty(bd, "__esModule", { value: !0 });
const SN = re, wN = fe, Rm = ae, RN = Ht, $N = dr, TN = qt, ON = {
  keyword: "elements",
  schemaType: "object",
  error: (0, TN.typeError)("array"),
  code(e) {
    (0, RN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: s } = e;
    if ((0, SN.alwaysValidSchema)(s, n))
      return;
    const [i] = (0, $N.checkNullable)(e);
    t.if((0, Rm.not)(i), () => t.if((0, Rm._)`Array.isArray(${r})`, () => t.assign(i, (0, wN.validateArray)(e)), () => e.error())), e.ok(i);
  }
};
bd.default = ON;
var _d = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateProperties = e.error = void 0;
  const t = fe, r = re, n = ae, s = Ht, i = dr, o = qt;
  var a;
  (function(l) {
    l.Additional = "additional", l.Missing = "missing";
  })(a || (a = {})), e.error = {
    message: (l) => {
      const { params: d } = l;
      return d.propError ? d.propError === a.Additional ? "must NOT have additional properties" : `must have property '${d.missingProperty}'` : (0, o.typeErrorMessage)(l, "object");
    },
    params: (l) => {
      const { params: d } = l;
      return d.propError ? d.propError === a.Additional ? (0, n._)`{error: ${d.propError}, additionalProperty: ${d.additionalProperty}}` : (0, n._)`{error: ${d.propError}, missingProperty: ${d.missingProperty}}` : (0, o.typeErrorParams)(l, "object");
    }
  };
  const c = {
    keyword: "properties",
    schemaType: "object",
    error: e.error,
    code: f
  };
  function f(l) {
    (0, s.checkMetadata)(l);
    const { gen: d, data: g, parentSchema: p, it: u } = l, { additionalProperties: h, nullable: b } = p;
    if (u.jtdDiscriminator && b)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (O())
      throw new Error("JTD: properties and optionalProperties have common members");
    const [m, v] = z("properties"), [y, _] = z("optionalProperties");
    if (v.length === 0 && _.length === 0 && h)
      return;
    const [R, E] = u.jtdDiscriminator === void 0 ? (0, i.checkNullableObject)(l, g) : [d.let("valid", !1), !0];
    d.if(E, () => d.assign(R, !0).block(() => {
      x(v, "properties", !0), x(_, "optionalProperties"), h || M();
    })), l.pass(R);
    function O() {
      const $ = p.properties, S = p.optionalProperties;
      if (!($ && S))
        return !1;
      for (const I in $)
        if (Object.prototype.hasOwnProperty.call(S, I))
          return !0;
      return !1;
    }
    function z($) {
      const S = p[$], I = S ? (0, t.allSchemaProperties)(S) : [];
      if (u.jtdDiscriminator && I.some((j) => j === u.jtdDiscriminator))
        throw new Error(`JTD: discriminator tag used in ${$}`);
      const T = I.filter((j) => !(0, r.alwaysValidSchema)(u, S[j]));
      return [I, T];
    }
    function x($, S, I) {
      const T = d.var("valid");
      for (const P of $)
        d.if((0, t.propertyInData)(d, g, P, u.opts.ownProperties), () => L(P, S, T), () => j(P)), l.ok(T);
      function j(P) {
        I ? (d.assign(T, !1), l.error(!1, { propError: a.Missing, missingProperty: P }, { schemaPath: P })) : d.assign(T, !0);
      }
    }
    function L($, S, I) {
      l.subschema({
        keyword: S,
        schemaProp: $,
        dataProp: $
      }, I);
    }
    function M() {
      d.forIn("key", g, ($) => {
        const S = U($, m, "properties", u.jtdDiscriminator), I = U($, y, "optionalProperties"), T = S === !0 ? I : I === !0 ? S : (0, n.and)(S, I);
        d.if(T, () => {
          u.opts.removeAdditional ? d.code((0, n._)`delete ${g}[${$}]`) : (l.error(!1, { propError: a.Additional, additionalProperty: $ }, { instancePath: $, parentSchema: !0 }), u.opts.allErrors || d.break());
        });
      });
    }
    function U($, S, I, T) {
      let j;
      if (S.length > 8) {
        const P = (0, r.schemaRefOrVal)(u, p[I], I);
        j = (0, n.not)((0, t.isOwnProperty)(d, P, $)), T !== void 0 && (j = (0, n.and)(j, (0, n._)`${$} !== ${T}`));
      } else if (S.length || T !== void 0) {
        const P = T === void 0 ? S : [T].concat(S);
        j = (0, n.and)(...P.map((A) => (0, n._)`${$} !== ${A}`));
      } else
        j = !0;
      return j;
    }
  }
  e.validateProperties = f, e.default = c;
})(_d);
var Ed = {};
Object.defineProperty(Ed, "__esModule", { value: !0 });
const $m = _d, PN = {
  keyword: "optionalProperties",
  schemaType: "object",
  error: $m.error,
  code(e) {
    e.parentSchema.properties || (0, $m.validateProperties)(e);
  }
};
Ed.default = PN;
var xd = {};
Object.defineProperty(xd, "__esModule", { value: !0 });
const en = ae, CN = Ht, IN = dr, Tm = qt, _o = pi, NN = {
  message: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? r.discrError === _o.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in mapping` : (0, Tm.typeErrorMessage)(e, "object");
  },
  params: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? (0, en._)`{error: ${r.discrError}, tag: ${t}, tagValue: ${r.tag}}` : (0, Tm.typeErrorParams)(e, "object");
  }
}, AN = {
  keyword: "discriminator",
  schemaType: "string",
  implements: ["mapping"],
  error: NN,
  code(e) {
    (0, CN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: s } = e, [i, o] = (0, IN.checkNullableObject)(e, r);
    t.if(o), a(), t.elseIf((0, en.not)(i)), e.error(), t.endIf(), e.ok(i);
    function a() {
      const l = t.const("tag", (0, en._)`${r}${(0, en.getProperty)(n)}`);
      t.if((0, en._)`${l} === undefined`), e.error(!1, { discrError: _o.DiscrError.Tag, tag: l }), t.elseIf((0, en._)`typeof ${l} == "string"`), c(l), t.else(), e.error(!1, { discrError: _o.DiscrError.Tag, tag: l }, { instancePath: n }), t.endIf();
    }
    function c(l) {
      t.if(!1);
      for (const d in s.mapping)
        t.elseIf((0, en._)`${l} === ${d}`), t.assign(i, f(d));
      t.else(), e.error(!1, { discrError: _o.DiscrError.Mapping, tag: l }, { instancePath: n, schemaPath: "mapping", parentSchema: !0 }), t.endIf();
    }
    function f(l) {
      const d = t.name("valid");
      return e.subschema({
        keyword: "mapping",
        schemaProp: l,
        jtdDiscriminator: n
      }, d), d;
    }
  }
};
xd.default = AN;
var Sd = {};
Object.defineProperty(Sd, "__esModule", { value: !0 });
const Om = re, Bi = ae, kN = Ht, LN = dr, jN = qt, DN = {
  keyword: "values",
  schemaType: "object",
  error: (0, jN.typeError)("object"),
  code(e) {
    (0, kN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: s } = e, [i, o] = (0, LN.checkNullableObject)(e, r);
    (0, Om.alwaysValidSchema)(s, n) ? t.if((0, Bi.not)((0, Bi.or)(o, i)), () => e.error()) : (t.if(o), t.assign(i, a()), t.elseIf((0, Bi.not)(i)), e.error(), t.endIf()), e.ok(i);
    function a() {
      const c = t.name("valid");
      if (s.allErrors) {
        const l = t.let("valid", !0);
        return f(() => t.assign(l, !1)), l;
      }
      return t.var(c, !0), f(() => t.break()), c;
      function f(l) {
        t.forIn("key", r, (d) => {
          e.subschema({
            keyword: "values",
            dataProp: d,
            dataPropType: Om.Type.Str
          }, c), t.if((0, Bi.not)(c), l);
        });
      }
    }
  }
};
Sd.default = DN;
var wd = {};
Object.defineProperty(wd, "__esModule", { value: !0 });
const FN = fe, MN = {
  keyword: "union",
  schemaType: "array",
  trackErrors: !0,
  code: FN.validateUnion,
  error: { message: "must match a schema in union" }
};
wd.default = MN;
Object.defineProperty(md, "__esModule", { value: !0 });
const zN = En, UN = gd, qN = vd, HN = bd, BN = _d, VN = Ed, GN = xd, WN = Sd, KN = wd, JN = Ht, YN = [
  "definitions",
  zN.default,
  UN.default,
  qN.default,
  HN.default,
  BN.default,
  VN.default,
  GN.default,
  WN.default,
  KN.default,
  JN.default,
  { keyword: "additionalProperties", schemaType: "boolean" },
  { keyword: "nullable", schemaType: "boolean" }
];
md.default = YN;
var Rd = {};
Object.defineProperty(Rd, "__esModule", { value: !0 });
const Rr = (e) => {
  const t = {
    nullable: { type: "boolean" },
    metadata: {
      optionalProperties: {
        union: { elements: { ref: "schema" } }
      },
      additionalProperties: !0
    }
  };
  return e && (t.definitions = { values: { ref: "schema" } }), t;
}, XN = (e) => ({
  optionalProperties: Rr(e)
}), ZN = (e) => ({
  properties: {
    ref: { type: "string" }
  },
  optionalProperties: Rr(e)
}), QN = (e) => ({
  properties: {
    type: {
      enum: [
        "boolean",
        "timestamp",
        "string",
        "float32",
        "float64",
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32"
      ]
    }
  },
  optionalProperties: Rr(e)
}), eA = (e) => ({
  properties: {
    enum: { elements: { type: "string" } }
  },
  optionalProperties: Rr(e)
}), tA = (e) => ({
  properties: {
    elements: { ref: "schema" }
  },
  optionalProperties: Rr(e)
}), Y0 = (e) => ({
  properties: {
    properties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    optionalProperties: { values: { ref: "schema" } },
    additionalProperties: { type: "boolean" },
    ...Rr(e)
  }
}), X0 = (e) => ({
  properties: {
    optionalProperties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    additionalProperties: { type: "boolean" },
    ...Rr(e)
  }
}), rA = (e) => ({
  properties: {
    discriminator: { type: "string" },
    mapping: {
      values: {
        metadata: {
          union: [Y0(!1), X0(!1)]
        }
      }
    }
  },
  optionalProperties: Rr(e)
}), nA = (e) => ({
  properties: {
    values: { ref: "schema" }
  },
  optionalProperties: Rr(e)
}), Pm = (e) => ({
  metadata: {
    union: [
      XN,
      ZN,
      QN,
      eA,
      tA,
      Y0,
      X0,
      rA,
      nA
    ].map((t) => t(e))
  }
}), sA = {
  definitions: {
    schema: Pm(!1)
  },
  ...Pm(!0)
};
Rd.default = sA;
var $d = {}, mi = {};
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.jtdForms = void 0;
mi.jtdForms = [
  "elements",
  "values",
  "discriminator",
  "properties",
  "optionalProperties",
  "enum",
  "type",
  "ref"
];
var Td = {};
Object.defineProperty(Td, "__esModule", { value: !0 });
const Zc = (
  // eslint-disable-next-line no-control-regex, no-misleading-character-class
  /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
), iA = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};
function Z0(e) {
  return Zc.lastIndex = 0, '"' + (Zc.test(e) ? e.replace(Zc, (t) => {
    const r = iA[t];
    return typeof r == "string" ? r : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
  }) : e) + '"';
}
Td.default = Z0;
Z0.code = 'require("ajv/dist/runtime/quote").default';
Object.defineProperty($d, "__esModule", { value: !0 });
const oA = mi, Q0 = ft, ve = ae, aA = mr, Ae = jt, cA = fe, lA = En, uA = re, fA = Td, dA = {
  elements: hA,
  values: mA,
  discriminator: yA,
  properties: Cm,
  optionalProperties: Cm,
  enum: Bs,
  type: gA,
  ref: bA
};
function e_(e, t) {
  const r = Q0.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, o = new ve.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }), a = o.scopeName("serialize"), c = {
    self: this,
    gen: o,
    schema: e.schema,
    schemaEnv: e,
    definitions: t,
    data: Ae.default.data
  };
  let f;
  try {
    this._compilations.add(e), e.serializeName = a, o.func(a, Ae.default.data, !1, () => {
      o.let(Ae.default.json, (0, ve.str)``), yi(c), o.return(Ae.default.json);
    }), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    f = `${o.scopeRefs(Ae.default.scope)}return ${l}`;
    const g = new Function(`${Ae.default.scope}`, f)(this.scope.get());
    this.scope.value(a, { ref: g }), e.serialize = g;
  } catch (l) {
    throw f && this.logger.error("Error compiling serializer, function code:", f), delete e.serialize, delete e.serializeName, l;
  } finally {
    this._compilations.delete(e);
  }
  return e;
}
$d.default = e_;
function yi(e) {
  let t;
  for (const r of oA.jtdForms)
    if (r in e.schema) {
      t = r;
      break;
    }
  pA(e, t ? dA[t] : EA);
}
function pA(e, t) {
  const { gen: r, schema: n, data: s } = e;
  if (!n.nullable)
    return t(e);
  r.if((0, ve._)`${s} === undefined || ${s} === null`, () => r.add(Ae.default.json, (0, ve._)`"null"`), () => t(e));
}
function hA(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(Ae.default.json, (0, ve.str)`[`);
  const s = t.let("first", !0);
  t.forOf("el", n, (i) => {
    Od(e, s), yi({ ...e, schema: r.elements, data: i });
  }), t.add(Ae.default.json, (0, ve.str)`]`);
}
function mA(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(Ae.default.json, (0, ve.str)`{`);
  const s = t.let("first", !0);
  t.forIn("key", n, (i) => t_(e, i, r.values, s)), t.add(Ae.default.json, (0, ve.str)`}`);
}
function t_(e, t, r, n) {
  const { gen: s, data: i } = e;
  Od(e, n), Bs({ ...e, data: t }), s.add(Ae.default.json, (0, ve.str)`:`);
  const o = s.const("value", (0, ve._)`${i}${(0, ve.getProperty)(t)}`);
  yi({ ...e, schema: r, data: o });
}
function yA(e) {
  const { gen: t, schema: r, data: n } = e, { discriminator: s } = r;
  t.add(Ae.default.json, (0, ve.str)`{${JSON.stringify(s)}:`);
  const i = t.const("tag", (0, ve._)`${n}${(0, ve.getProperty)(s)}`);
  Bs({ ...e, data: i }), t.if(!1);
  for (const o in r.mapping) {
    t.elseIf((0, ve._)`${i} === ${o}`);
    const a = r.mapping[o];
    r_({ ...e, schema: a }, s);
  }
  t.endIf(), t.add(Ae.default.json, (0, ve.str)`}`);
}
function Cm(e) {
  const { gen: t } = e;
  t.add(Ae.default.json, (0, ve.str)`{`), r_(e), t.add(Ae.default.json, (0, ve.str)`}`);
}
function r_(e, t) {
  const { gen: r, schema: n, data: s } = e, { properties: i, optionalProperties: o } = n, a = g(i), c = g(o), f = p(a.concat(c));
  let l = !t, d;
  for (const m of a)
    l ? l = !1 : r.add(Ae.default.json, (0, ve.str)`,`), h(m, i[m], u(m));
  l && (d = r.let("first", !0));
  for (const m of c) {
    const v = u(m);
    r.if((0, ve.and)((0, ve._)`${v} !== undefined`, (0, cA.isOwnProperty)(r, s, m)), () => {
      Od(e, d), h(m, o[m], v);
    });
  }
  n.additionalProperties && r.forIn("key", s, (m) => r.if(b(m, f), () => t_(e, m, {}, d)));
  function g(m) {
    return m ? Object.keys(m) : [];
  }
  function p(m) {
    if (t && m.push(t), new Set(m).size !== m.length)
      throw new Error("JTD: properties/optionalProperties/disciminator overlap");
    return m;
  }
  function u(m) {
    return r.const("value", (0, ve._)`${s}${(0, ve.getProperty)(m)}`);
  }
  function h(m, v, y) {
    r.add(Ae.default.json, (0, ve.str)`${JSON.stringify(m)}:`), yi({ ...e, schema: v, data: y });
  }
  function b(m, v) {
    return v.length ? (0, ve.and)(...v.map((y) => (0, ve._)`${m} !== ${y}`)) : !0;
  }
}
function gA(e) {
  const { gen: t, schema: r, data: n } = e;
  switch (r.type) {
    case "boolean":
      t.add(Ae.default.json, (0, ve._)`${n} ? "true" : "false"`);
      break;
    case "string":
      Bs(e);
      break;
    case "timestamp":
      t.if((0, ve._)`${n} instanceof Date`, () => t.add(Ae.default.json, (0, ve._)`'"' + ${n}.toISOString() + '"'`), () => Bs(e));
      break;
    default:
      vA(e);
  }
}
function Bs({ gen: e, data: t }) {
  e.add(Ae.default.json, (0, ve._)`${(0, uA.useFunc)(e, fA.default)}(${t})`);
}
function vA({ gen: e, data: t }) {
  e.add(Ae.default.json, (0, ve._)`"" + ${t}`);
}
function bA(e) {
  const { gen: t, self: r, data: n, definitions: s, schema: i, schemaEnv: o } = e, { ref: a } = i, c = s[a];
  if (!c)
    throw new aA.default(r.opts.uriResolver, "", a, `No definition ${a}`);
  if (!(0, lA.hasRef)(c))
    return yi({ ...e, schema: c });
  const { root: f } = o, l = e_.call(r, new Q0.SchemaEnv({ schema: c, root: f }), s);
  t.add(Ae.default.json, (0, ve._)`${_A(t, l)}(${n})`);
}
function _A(e, t) {
  return t.serialize ? e.scopeValue("serialize", { ref: t.serialize }) : (0, ve._)`${e.scopeValue("wrapper", { ref: t })}.serialize`;
}
function EA({ gen: e, data: t }) {
  e.add(Ae.default.json, (0, ve._)`JSON.stringify(${t})`);
}
function Od({ gen: e }, t) {
  t ? e.if(t, () => e.assign(t, !1), () => e.add(Ae.default.json, (0, ve.str)`,`)) : e.add(Ae.default.json, (0, ve.str)`,`);
}
var Pd = {}, Ur = {};
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.parseJsonString = Ur.parseJsonNumber = Ur.parseJson = void 0;
const xA = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
function yr(e, t) {
  let r;
  yr.message = void 0;
  let n;
  t && (e = e.slice(t));
  try {
    return yr.position = t + e.length, JSON.parse(e);
  } catch (s) {
    if (n = xA.exec(s.message), !n) {
      yr.message = "unexpected end";
      return;
    }
    r = +n[1];
    const i = e[r];
    e = e.slice(0, r), yr.position = t + r;
    try {
      return JSON.parse(e);
    } catch {
      yr.message = `unexpected token ${i}`;
      return;
    }
  }
}
Ur.parseJson = yr;
yr.message = void 0;
yr.position = 0;
yr.code = 'require("ajv/dist/runtime/parseJson").parseJson';
function gr(e, t, r) {
  let n = "", s;
  if (gr.message = void 0, e[t] === "-" && (n += "-", t++), e[t] === "0")
    n += "0", t++;
  else if (!i(r)) {
    o();
    return;
  }
  if (r)
    return gr.position = t, +n;
  if (e[t] === "." && (n += ".", t++, !i())) {
    o();
    return;
  }
  if (s = e[t], (s === "e" || s === "E") && (n += "e", t++, s = e[t], (s === "+" || s === "-") && (n += s, t++), !i())) {
    o();
    return;
  }
  return gr.position = t, +n;
  function i(a) {
    let c = !1;
    for (; s = e[t], s >= "0" && s <= "9" && (a === void 0 || a-- > 0); )
      c = !0, n += s, t++;
    return c;
  }
  function o() {
    gr.position = t, gr.message = t < e.length ? `unexpected token ${e[t]}` : "unexpected end";
  }
}
Ur.parseJsonNumber = gr;
gr.message = void 0;
gr.position = 0;
gr.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
const Im = {
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	",
  '"': '"',
  "/": "/",
  "\\": "\\"
}, SA = 97, wA = 48;
function Fr(e, t) {
  let r = "", n;
  for (Fr.message = void 0; n = e[t++], n !== '"'; )
    if (n === "\\")
      if (n = e[t], n in Im)
        r += Im[n], t++;
      else if (n === "u") {
        t++;
        let i = 4, o = 0;
        for (; i--; ) {
          if (o <<= 4, n = e[t], n === void 0) {
            s("unexpected end");
            return;
          }
          if (n = n.toLowerCase(), n >= "a" && n <= "f")
            o += n.charCodeAt(0) - SA + 10;
          else if (n >= "0" && n <= "9")
            o += n.charCodeAt(0) - wA;
          else {
            s(`unexpected token ${n}`);
            return;
          }
          t++;
        }
        r += String.fromCharCode(o);
      } else {
        s(`unexpected token ${n}`);
        return;
      }
    else if (n === void 0) {
      s("unexpected end");
      return;
    } else if (n.charCodeAt(0) >= 32)
      r += n;
    else {
      s(`unexpected token ${n}`);
      return;
    }
  return Fr.position = t, r;
  function s(i) {
    Fr.position = t, Fr.message = i;
  }
}
Ur.parseJsonString = Fr;
Fr.message = void 0;
Fr.position = 0;
Fr.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
Object.defineProperty(Pd, "__esModule", { value: !0 });
const RA = mi, n_ = ft, oe = ae, $A = mr, me = jt, TA = fe, OA = En, PA = gd, Cd = Ur, s_ = re, CA = Ra, IA = {
  elements: LA,
  values: jA,
  discriminator: FA,
  properties: Nm,
  optionalProperties: Nm,
  enum: zA,
  type: MA,
  ref: UA
};
function i_(e, t) {
  const r = n_.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, o = new oe.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }), a = o.scopeName("parse"), c = {
    self: this,
    gen: o,
    schema: e.schema,
    schemaEnv: e,
    definitions: t,
    data: me.default.data,
    parseName: a,
    char: o.name("c")
  };
  let f;
  try {
    this._compilations.add(e), e.parseName = a, NA(c), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    f = `${o.scopeRefs(me.default.scope)}return ${l}`;
    const g = new Function(`${me.default.scope}`, f)(this.scope.get());
    this.scope.value(a, { ref: g }), e.parse = g;
  } catch (l) {
    throw f && this.logger.error("Error compiling parser, function code:", f), delete e.parse, delete e.parseName, l;
  } finally {
    this._compilations.delete(e);
  }
  return e;
}
Pd.default = i_;
const Eu = (0, oe._)`undefined`;
function NA(e) {
  const { gen: t, parseName: r, char: n } = e;
  t.func(r, (0, oe._)`${me.default.json}, ${me.default.jsonPos}, ${me.default.jsonPart}`, !1, () => {
    t.let(me.default.data), t.let(n), t.assign((0, oe._)`${r}.message`, Eu), t.assign((0, oe._)`${r}.position`, Eu), t.assign(me.default.jsonPos, (0, oe._)`${me.default.jsonPos} || 0`), t.const(me.default.jsonLen, (0, oe._)`${me.default.json}.length`), $a(e), kd(e), t.if(me.default.jsonPart, () => {
      t.assign((0, oe._)`${r}.position`, me.default.jsonPos), t.return(me.default.data);
    }), t.if((0, oe._)`${me.default.jsonPos} === ${me.default.jsonLen}`, () => t.return(me.default.data)), cs(e);
  });
}
function $a(e) {
  let t;
  for (const r of RA.jtdForms)
    if (r in e.schema) {
      t = r;
      break;
    }
  t ? kA(e, IA[t]) : Nd(e);
}
const AA = km(!0, km(!1, cs));
function kA(e, t) {
  const { gen: r, schema: n, data: s } = e;
  if (!n.nullable)
    return t(e);
  Vs(e, "null", t, () => r.assign(s, null));
}
function LA(e) {
  const { gen: t, schema: r, data: n } = e;
  pr(e, "[");
  const s = t.let("i", 0);
  t.assign(n, (0, oe._)`[]`), Id(e, "]", () => {
    const i = t.let("el");
    $a({ ...e, schema: r.elements, data: i }), t.assign((0, oe._)`${n}[${s}++]`, i);
  });
}
function jA(e) {
  const { gen: t, schema: r, data: n } = e;
  pr(e, "{"), t.assign(n, (0, oe._)`{}`), Id(e, "}", () => DA(e, r.values));
}
function Id(e, t, r) {
  o_(e, t, r), pr(e, t);
}
function o_(e, t, r) {
  const { gen: n } = e;
  n.for((0, oe._)`;${me.default.jsonPos}<${me.default.jsonLen} && ${Ta(1)}!==${t};`, () => {
    r(), Vs(e, ",", () => n.break(), s);
  });
  function s() {
    Vs(e, t, () => {
    }, cs);
  }
}
function DA(e, t) {
  const { gen: r } = e, n = r.let("key");
  pn({ ...e, data: n }), pr(e, ":"), c_(e, n, t);
}
function FA(e) {
  const { gen: t, data: r, schema: n } = e, { discriminator: s, mapping: i } = n;
  pr(e, "{"), t.assign(r, (0, oe._)`{}`);
  const o = t.const("pos", me.default.jsonPos), a = t.let("value"), c = t.let("tag");
  o_(e, "}", () => {
    const f = t.let("key");
    pn({ ...e, data: f }), pr(e, ":"), t.if(
      (0, oe._)`${f} === ${s}`,
      () => {
        pn({ ...e, data: c }), t.assign((0, oe._)`${r}[${f}]`, c), t.break();
      },
      () => Nd({ ...e, data: a })
      // can be discarded/skipped
    );
  }), t.assign(me.default.jsonPos, o), t.if((0, oe._)`${c} === undefined`), Er(e, (0, oe.str)`discriminator tag not found`);
  for (const f in i)
    t.elseIf((0, oe._)`${c} === ${f}`), a_({ ...e, schema: i[f] }, s);
  t.else(), Er(e, (0, oe.str)`discriminator value not in schema`), t.endIf();
}
function Nm(e) {
  const { gen: t, data: r } = e;
  pr(e, "{"), t.assign(r, (0, oe._)`{}`), a_(e);
}
function a_(e, t) {
  const { gen: r, schema: n, data: s } = e, { properties: i, optionalProperties: o, additionalProperties: a } = n;
  if (Id(e, "}", () => {
    const c = r.let("key");
    if (pn({ ...e, data: c }), pr(e, ":"), r.if(!1), Am(e, c, i), Am(e, c, o), t) {
      r.elseIf((0, oe._)`${c} === ${t}`);
      const f = r.let("tag");
      pn({ ...e, data: f });
    }
    r.else(), a ? Nd({ ...e, data: (0, oe._)`${s}[${c}]` }) : Er(e, (0, oe.str)`property ${c} not allowed`), r.endIf();
  }), i) {
    const c = (0, TA.hasPropFunc)(r), f = (0, oe.and)(...Object.keys(i).map((l) => (0, oe._)`${c}.call(${s}, ${l})`));
    r.if((0, oe.not)(f), () => Er(e, (0, oe.str)`missing required properties`));
  }
}
function Am(e, t, r = {}) {
  const { gen: n } = e;
  for (const s in r)
    n.elseIf((0, oe._)`${t} === ${s}`), c_(e, t, r[s]);
}
function c_(e, t, r) {
  $a({ ...e, schema: r, data: (0, oe._)`${e.data}[${t}]` });
}
function MA(e) {
  const { gen: t, schema: r, data: n, self: s } = e;
  switch (r.type) {
    case "boolean":
      AA(e);
      break;
    case "string":
      pn(e);
      break;
    case "timestamp": {
      pn(e);
      const i = (0, s_.useFunc)(t, CA.default), { allowDate: o, parseDate: a } = s.opts, c = o ? (0, oe._)`!${i}(${n}, true)` : (0, oe._)`!${i}(${n})`, f = a ? (0, oe.or)(c, (0, oe._)`(${n} = new Date(${n}), false)`, (0, oe._)`isNaN(${n}.valueOf())`) : c;
      t.if(f, () => Er(e, (0, oe.str)`invalid timestamp`));
      break;
    }
    case "float32":
    case "float64":
      Qc(e);
      break;
    default: {
      const i = r.type;
      if (!s.opts.int32range && (i === "int32" || i === "uint32"))
        Qc(e, 16), i === "uint32" && t.if((0, oe._)`${n} < 0`, () => Er(e, (0, oe.str)`integer out of range`));
      else {
        const [o, a, c] = PA.intRange[i];
        Qc(e, c), t.if((0, oe._)`${n} < ${o} || ${n} > ${a}`, () => Er(e, (0, oe.str)`integer out of range`));
      }
    }
  }
}
function pn(e) {
  pr(e, '"'), Ad(e, Cd.parseJsonString);
}
function zA(e) {
  const { gen: t, data: r, schema: n } = e, s = n.enum;
  pr(e, '"'), t.if(!1);
  for (const i of s) {
    const o = JSON.stringify(i).slice(1);
    t.elseIf((0, oe._)`${Ta(o.length)} === ${o}`), t.assign(r, (0, oe.str)`${i}`), t.add(me.default.jsonPos, o.length);
  }
  t.else(), cs(e), t.endIf();
}
function Qc(e, t) {
  const { gen: r } = e;
  kd(e), r.if((0, oe._)`"-0123456789".indexOf(${Ta(1)}) < 0`, () => cs(e), () => Ad(e, Cd.parseJsonNumber, t));
}
function km(e, t) {
  return (r) => {
    const { gen: n, data: s } = r;
    Vs(r, `${e}`, () => t(r), () => n.assign(s, e));
  };
}
function UA(e) {
  const { gen: t, self: r, definitions: n, schema: s, schemaEnv: i } = e, { ref: o } = s, a = n[o];
  if (!a)
    throw new $A.default(r.opts.uriResolver, "", o, `No definition ${o}`);
  if (!(0, OA.hasRef)(a))
    return $a({ ...e, schema: a });
  const { root: c } = i, f = i_.call(r, new n_.SchemaEnv({ schema: a, root: c }), n);
  l_(e, qA(t, f), !0);
}
function qA(e, t) {
  return t.parse ? e.scopeValue("parse", { ref: t.parse }) : (0, oe._)`${e.scopeValue("wrapper", { ref: t })}.parse`;
}
function Nd(e) {
  Ad(e, Cd.parseJson);
}
function Ad(e, t, r) {
  l_(e, (0, s_.useFunc)(e.gen, t), r);
}
function l_(e, t, r) {
  const { gen: n, data: s } = e;
  n.assign(s, (0, oe._)`${t}(${me.default.json}, ${me.default.jsonPos}${r ? (0, oe._)`, ${r}` : oe.nil})`), n.assign(me.default.jsonPos, (0, oe._)`${t}.position`), n.if((0, oe._)`${s} === undefined`, () => Er(e, (0, oe._)`${t}.message`));
}
function pr(e, t) {
  Vs(e, t, cs);
}
function Vs(e, t, r, n) {
  const { gen: s } = e, i = t.length;
  kd(e), s.if((0, oe._)`${Ta(i)} === ${t}`, () => {
    s.add(me.default.jsonPos, i), n == null || n(e);
  }, () => r(e));
}
function kd({ gen: e, char: t }) {
  e.code((0, oe._)`while((${t}=${me.default.json}[${me.default.jsonPos}],${t}===" "||${t}==="\\n"||${t}==="\\r"||${t}==="\\t"))${me.default.jsonPos}++;`);
}
function Ta(e) {
  return e === 1 ? (0, oe._)`${me.default.json}[${me.default.jsonPos}]` : (0, oe._)`${me.default.json}.slice(${me.default.jsonPos}, ${me.default.jsonPos}+${e})`;
}
function cs(e) {
  Er(e, (0, oe._)`"unexpected token " + ${me.default.json}[${me.default.jsonPos}]`);
}
function Er({ gen: e, parseName: t }, r) {
  e.assign((0, oe._)`${t}.message`, r), e.assign((0, oe._)`${t}.position`, me.default.jsonPos), e.return(Eu);
}
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const r = gf, n = md, s = Rd, i = $d, o = Pd, a = "JTD-meta-schema";
  class c extends r.default {
    constructor(u = {}) {
      super({
        ...u,
        jtd: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), this.addVocabulary(n.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema(), this.opts.meta && this.addMetaSchema(s.default, a, !1);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
    compileSerializer(u) {
      const h = this._addSchema(u);
      return h.serialize || this._compileSerializer(h);
    }
    compileParser(u) {
      const h = this._addSchema(u);
      return h.parse || this._compileParser(h);
    }
    _compileSerializer(u) {
      if (i.default.call(this, u, u.schema.definitions || {}), !u.serialize)
        throw new Error("ajv implementation error");
      return u.serialize;
    }
    _compileParser(u) {
      if (o.default.call(this, u, u.schema.definitions || {}), !u.parse)
        throw new Error("ajv implementation error");
      return u.parse;
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var f = Ut;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return f.KeywordCxt;
  } });
  var l = ae;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var d = ss;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var g = mr;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return g.default;
  } });
})(_u, _u.exports);
var u_ = _u.exports;
const HA = Nf;
var f_ = Object.freeze({
  coerceTypes: "array",
  useDefaults: !0,
  removeAdditional: !0,
  uriResolver: HA,
  addUsedSchema: !1,
  // Explicitly set allErrors to `false`.
  // When set to `true`, a DoS attack is possible.
  allErrors: !1
});
const BA = ud.default, VA = u_, Lm = f_;
class GA {
  constructor(t, r) {
    var i;
    r.mode === "JTD" ? this.ajv = new VA(Object.assign({}, Lm, r.customOptions)) : this.ajv = new BA(Object.assign({}, Lm, r.customOptions));
    let n = !0;
    if (r.plugins && r.plugins.length > 0)
      for (const o of r.plugins)
        Array.isArray(o) ? (n = n && o[0].name !== "formatsPlugin", o[0](this.ajv, o[1])) : (n = n && o.name !== "formatsPlugin", o(this.ajv));
    n && I0()(this.ajv), (i = r.onCreate) == null || i.call(r, this.ajv);
    const s = Object.values(t);
    for (const o of s)
      this.ajv.addSchema(o);
  }
  buildValidatorFunction({
    schema: t
    /*, method, url, httpPart */
  }) {
    if (t.$id) {
      const r = this.ajv.getSchema(t.$id);
      if (r)
        return r;
    }
    return this.ajv.compile(t);
  }
}
var WA = GA;
const KA = u_, JA = f_;
class YA {
  constructor(t, r) {
    this.ajv = new KA(Object.assign({}, JA, r));
  }
  buildSerializerFunction({
    schema: t
    /*, method, url, httpStatus */
  }) {
    return this.ajv.compileSerializer(t);
  }
}
var XA = YA, xu = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = jo, n = Kn;
  function s(i, o) {
    if (!i.opts.code.source)
      throw new Error("moduleCode: ajv instance must have code.source option");
    const { _n: a } = i.scope.opts;
    return typeof o == "function" ? f(o.source) : o !== void 0 ? l(o, c) : l(i.schemas, (g) => g.meta ? void 0 : i.compile(g.schema));
    function c(g) {
      const p = i.getSchema(g);
      if (!p)
        throw new Error(`moduleCode: no schema with id ${g}`);
      return p;
    }
    function f(g) {
      const p = {}, u = g == null ? void 0 : g.validateName, h = d(p, g);
      return i.opts.code.esm ? `"use strict";${a}export const validate = ${u};${a}export default ${u};${a}${h}` : `"use strict";${a}module.exports = ${u};${a}module.exports.default = ${u};${a}${h}`;
    }
    function l(g, p) {
      var u;
      const h = {};
      let b = (0, n._)`"use strict";`;
      for (const m in g) {
        const v = p(g[m]);
        if (v) {
          const y = d(h, v.source), _ = i.opts.code.esm ? (0, n._)`export const ${(0, n.getEsmExportName)(m)}` : (0, n._)`exports${(0, n.getProperty)(m)}`;
          b = (0, n._)`${b}${a}${_} = ${(u = v.source) === null || u === void 0 ? void 0 : u.validateName};${a}${y}`;
        }
      }
      return `${b}`;
    }
    function d(g, p) {
      if (!p)
        throw new Error('moduleCode: function does not have "source" property');
      if (m(p.validateName) === r.UsedValueState.Completed)
        return n.nil;
      v(p.validateName, r.UsedValueState.Started);
      const u = i.scope.scopeCode(p.scopeValues, g, b), h = new n._Code(`${u}${a}${p.validateCode}`);
      return p.evaluated ? (0, n._)`${h}${p.validateName}.evaluated = ${p.evaluated};${a}` : h;
      function b(y) {
        var _;
        const R = (_ = y.value) === null || _ === void 0 ? void 0 : _.ref;
        if (y.prefix === "validate" && typeof R == "function")
          return d(g, R.source);
        if ((y.prefix === "root" || y.prefix === "wrapper") && typeof R == "object") {
          const { validate: E, validateName: O } = R;
          if (!O)
            throw new Error("ajv internal error");
          const z = i.opts.code.es5 ? r.varKinds.var : r.varKinds.const, x = (0, n._)`${z} ${y} = {validate: ${O}};`;
          if (m(O) === r.UsedValueState.Started)
            return x;
          const L = d(g, E == null ? void 0 : E.source);
          return (0, n._)`${x}${a}${L}`;
        }
      }
      function m(y) {
        var _;
        return (_ = g[y.prefix]) === null || _ === void 0 ? void 0 : _.get(y);
      }
      function v(y, _) {
        const { prefix: R } = y;
        (g[R] = g[R] || /* @__PURE__ */ new Map()).set(y, _);
      }
    }
  }
  e.exports = t = s, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
})(xu, xu.exports);
var ZA = xu.exports, el, jm;
function QA() {
  if (jm) return el;
  jm = 1;
  const e = d_(), t = ZA.default;
  function r(n = { readMode: !0 }) {
    if (n.readMode === !0 && !n.restoreFunction)
      throw new Error("You must provide a restoreFunction options when readMode ON");
    if (n.readMode !== !0 && !n.storeFunction)
      throw new Error("You must provide a storeFunction options when readMode OFF");
    if (n.readMode === !0)
      return function() {
        return function(o) {
          return n.restoreFunction(o);
        };
      };
    const s = e();
    return function(o, a = {}) {
      (!a.customOptions || !a.customOptions.code) && (a.customOptions = Object.assign({}, a.customOptions, { code: { source: !0 } }));
      const c = s(o, a);
      return function(f) {
        const l = c(f), d = t(c[e.AjvReference].ajv, l);
        return n.storeFunction(f, d), l;
      };
    };
  }
  return el = r, el;
}
var Dm;
function d_() {
  if (Dm) return Wr.exports;
  Dm = 1;
  const e = Symbol.for("fastify.ajv-compiler.reference"), t = WA, r = XA;
  function n(i) {
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    return i && i.jtdSerializer === !0 ? function(f, l) {
      const d = s({}, l);
      if (a.has(d))
        return a.get(d);
      const g = new r(f, l), p = g.buildSerializerFunction.bind(g);
      return a.set(d, p), p;
    } : function(f, l) {
      const d = s(f, l.customOptions);
      if (o.has(d))
        return o.get(d);
      const g = new t(f, l), p = g.buildValidatorFunction.bind(g);
      return o.set(d, p), l.customOptions.code !== void 0 && (p[e] = g), p;
    };
  }
  function s(i, o) {
    const a = JSON.stringify(i), c = JSON.stringify(o);
    return `${a}${c}`;
  }
  return Wr.exports = n, Wr.exports.default = n, Wr.exports.AjvCompiler = n, Wr.exports.AjvReference = e, Wr.exports.StandaloneValidator = QA(), Wr.exports;
}
const { buildSchemas: ek } = ua, tk = iN, rk = d_();
function nk(e, t) {
  var s, i;
  if (e)
    return new Vo(e, t);
  const r = Object.assign({
    buildValidator: null,
    buildSerializer: null
  }, t == null ? void 0 : t.compilersFactory);
  r.buildValidator || (r.buildValidator = rk()), r.buildSerializer || (r.buildSerializer = tk());
  const n = {
    bucket: t && t.bucket || ek,
    compilersFactory: r,
    isCustomValidatorCompiler: typeof ((s = t == null ? void 0 : t.compilersFactory) == null ? void 0 : s.buildValidator) == "function",
    isCustomSerializerCompiler: typeof ((i = t == null ? void 0 : t.compilersFactory) == null ? void 0 : i.buildValidator) == "function"
  };
  return new Vo(void 0, n);
}
let Vo = class {
  constructor(t, r) {
    this.opts = r || (t == null ? void 0 : t.opts), this.addedSchemas = !1, this.compilersFactory = this.opts.compilersFactory, t ? (this.schemaBucket = this.opts.bucket(t.getSchemas()), this.validatorCompiler = t.getValidatorCompiler(), this.serializerCompiler = t.getSerializerCompiler(), this.isCustomValidatorCompiler = t.isCustomValidatorCompiler, this.isCustomSerializerCompiler = t.isCustomSerializerCompiler, this.parent = t) : (this.schemaBucket = this.opts.bucket(), this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || !1, this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || !1);
  }
  // Bucket interface
  add(t) {
    return this.addedSchemas = !0, this.schemaBucket.add(t);
  }
  getSchema(t) {
    return this.schemaBucket.getSchema(t);
  }
  getSchemas() {
    return this.schemaBucket.getSchemas();
  }
  setValidatorCompiler(t) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildValidator: () => t }
    ), this.validatorCompiler = t, this.isCustomValidatorCompiler = !0;
  }
  setSerializerCompiler(t) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildSerializer: () => t }
    ), this.serializerCompiler = t, this.isCustomSerializerCompiler = !0;
  }
  getValidatorCompiler() {
    return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
  }
  getSerializerCompiler() {
    return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
  }
  getSerializerBuilder() {
    return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
  }
  getValidatorBuilder() {
    return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
  }
  /**
   * This method will be called when a validator must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupValidator(t) {
    this.validatorCompiler !== void 0 && !this.addedSchemas || (this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), t.ajv));
  }
  /**
   * This method will be called when a serializer must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupSerializer(t) {
    this.serializerCompiler !== void 0 && !this.addedSchemas || (this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), t.serializerOpts));
  }
};
Vo.buildSchemaController = nk;
var p_ = Vo, h_ = { exports: {} }, Su = { exports: {} };
const sk = "2.0.0", m_ = 256, ik = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, ok = 16, ak = m_ - 6, ck = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Oa = {
  MAX_LENGTH: m_,
  MAX_SAFE_COMPONENT_LENGTH: ok,
  MAX_SAFE_BUILD_LENGTH: ak,
  MAX_SAFE_INTEGER: ik,
  RELEASE_TYPES: ck,
  SEMVER_SPEC_VERSION: sk,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const lk = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Pa = lk;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: n,
    MAX_LENGTH: s
  } = Oa, i = Pa;
  t = e.exports = {};
  const o = t.re = [], a = t.safeRe = [], c = t.src = [], f = t.safeSrc = [], l = t.t = {};
  let d = 0;
  const g = "[a-zA-Z0-9-]", p = [
    ["\\s", 1],
    ["\\d", s],
    [g, n]
  ], u = (b) => {
    for (const [m, v] of p)
      b = b.split(`${m}*`).join(`${m}{0,${v}}`).split(`${m}+`).join(`${m}{1,${v}}`);
    return b;
  }, h = (b, m, v) => {
    const y = u(m), _ = d++;
    i(b, _, m), l[b] = _, c[_] = m, f[_] = y, o[_] = new RegExp(m, v ? "g" : void 0), a[_] = new RegExp(y, v ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${g}*`), h("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${g}+`), h("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), h("FULL", `^${c[l.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), h("LOOSE", `^${c[l.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), h("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), h("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), h("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), h("COERCERTL", c[l.COERCE], !0), h("COERCERTLFULL", c[l.COERCEFULL], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Su, Su.exports);
var gi = Su.exports;
const uk = Object.freeze({ loose: !0 }), fk = Object.freeze({}), dk = (e) => e ? typeof e != "object" ? uk : e : fk;
var Ld = dk;
const Fm = /^[0-9]+$/, y_ = (e, t) => {
  const r = Fm.test(e), n = Fm.test(t);
  return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
}, pk = (e, t) => y_(t, e);
var g_ = {
  compareIdentifiers: y_,
  rcompareIdentifiers: pk
};
const Vi = Pa, { MAX_LENGTH: Mm, MAX_SAFE_INTEGER: Gi } = Oa, { safeRe: zm, safeSrc: Um, t: Wi } = gi, hk = Ld, { compareIdentifiers: Tn } = g_;
let mk = class or {
  constructor(t, r) {
    if (r = hk(r), t instanceof or) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > Mm)
      throw new TypeError(
        `version is longer than ${Mm} characters`
      );
    Vi("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = t.trim().match(r.loose ? zm[Wi.LOOSE] : zm[Wi.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Gi || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Gi || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Gi || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const i = +s;
        if (i >= 0 && i < Gi)
          return i;
      }
      return s;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Vi("SemVer.compare", this.version, this.options, t), !(t instanceof or)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new or(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof or || (t = new or(t, this.options)), Tn(this.major, t.major) || Tn(this.minor, t.minor) || Tn(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof or || (t = new or(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const n = this.prerelease[r], s = t.prerelease[r];
      if (Vi("prerelease compare", r, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Tn(n, s);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof or || (t = new or(t, this.options));
    let r = 0;
    do {
      const n = this.build[r], s = t.build[r];
      if (Vi("build compare", r, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Tn(n, s);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r, n) {
    if (t.startsWith("pre")) {
      if (!r && n === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (r) {
        const s = new RegExp(`^${this.options.loose ? Um[Wi.PRERELEASELOOSE] : Um[Wi.PRERELEASE]}$`), i = `-${r}`.match(s);
        if (!i || i[1] !== r)
          throw new Error(`invalid identifier: ${r}`);
      }
    }
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const s = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let i = this.prerelease.length;
          for (; --i >= 0; )
            typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
          if (i === -1) {
            if (r === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (r) {
          let i = [r, s];
          n === !1 && (i = [r]), Tn(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var St = mk;
const qm = St, yk = (e, t, r = !1) => {
  if (e instanceof qm)
    return e;
  try {
    return new qm(e, t);
  } catch (n) {
    if (!r)
      return null;
    throw n;
  }
};
var ls = yk;
const gk = ls, vk = (e, t) => {
  const r = gk(e, t);
  return r ? r.version : null;
};
var bk = vk;
const _k = ls, Ek = (e, t) => {
  const r = _k(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var xk = Ek;
const Hm = St, Sk = (e, t, r, n, s) => {
  typeof r == "string" && (s = n, n = r, r = void 0);
  try {
    return new Hm(
      e instanceof Hm ? e.version : e,
      r
    ).inc(t, n, s).version;
  } catch {
    return null;
  }
};
var wk = Sk;
const Bm = ls, Rk = (e, t) => {
  const r = Bm(e, null, !0), n = Bm(t, null, !0), s = r.compare(n);
  if (s === 0)
    return null;
  const i = s > 0, o = i ? r : n, a = i ? n : r, c = !!o.prerelease.length;
  if (!!a.prerelease.length && !c) {
    if (!a.patch && !a.minor)
      return "major";
    if (a.compareMain(o) === 0)
      return a.minor && !a.patch ? "minor" : "patch";
  }
  const l = c ? "pre" : "";
  return r.major !== n.major ? l + "major" : r.minor !== n.minor ? l + "minor" : r.patch !== n.patch ? l + "patch" : "prerelease";
};
var $k = Rk;
const Tk = St, Ok = (e, t) => new Tk(e, t).major;
var Pk = Ok;
const Ck = St, Ik = (e, t) => new Ck(e, t).minor;
var Nk = Ik;
const Ak = St, kk = (e, t) => new Ak(e, t).patch;
var Lk = kk;
const jk = ls, Dk = (e, t) => {
  const r = jk(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var Fk = Dk;
const Vm = St, Mk = (e, t, r) => new Vm(e, r).compare(new Vm(t, r));
var Xt = Mk;
const zk = Xt, Uk = (e, t, r) => zk(t, e, r);
var qk = Uk;
const Hk = Xt, Bk = (e, t) => Hk(e, t, !0);
var Vk = Bk;
const Gm = St, Gk = (e, t, r) => {
  const n = new Gm(e, r), s = new Gm(t, r);
  return n.compare(s) || n.compareBuild(s);
};
var jd = Gk;
const Wk = jd, Kk = (e, t) => e.sort((r, n) => Wk(r, n, t));
var Jk = Kk;
const Yk = jd, Xk = (e, t) => e.sort((r, n) => Yk(n, r, t));
var Zk = Xk;
const Qk = Xt, eL = (e, t, r) => Qk(e, t, r) > 0;
var Ca = eL;
const tL = Xt, rL = (e, t, r) => tL(e, t, r) < 0;
var Dd = rL;
const nL = Xt, sL = (e, t, r) => nL(e, t, r) === 0;
var v_ = sL;
const iL = Xt, oL = (e, t, r) => iL(e, t, r) !== 0;
var b_ = oL;
const aL = Xt, cL = (e, t, r) => aL(e, t, r) >= 0;
var Fd = cL;
const lL = Xt, uL = (e, t, r) => lL(e, t, r) <= 0;
var Md = uL;
const fL = v_, dL = b_, pL = Ca, hL = Fd, mL = Dd, yL = Md, gL = (e, t, r, n) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return fL(e, r, n);
    case "!=":
      return dL(e, r, n);
    case ">":
      return pL(e, r, n);
    case ">=":
      return hL(e, r, n);
    case "<":
      return mL(e, r, n);
    case "<=":
      return yL(e, r, n);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var __ = gL;
const vL = St, bL = ls, { safeRe: Ki, t: Ji } = gi, _L = (e, t) => {
  if (e instanceof vL)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
    r = e.match(t.includePrerelease ? Ki[Ji.COERCEFULL] : Ki[Ji.COERCE]);
  else {
    const c = t.includePrerelease ? Ki[Ji.COERCERTLFULL] : Ki[Ji.COERCERTL];
    let f;
    for (; (f = c.exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || f.index + f[0].length !== r.index + r[0].length) && (r = f), c.lastIndex = f.index + f[1].length + f[2].length;
    c.lastIndex = -1;
  }
  if (r === null)
    return null;
  const n = r[2], s = r[3] || "0", i = r[4] || "0", o = t.includePrerelease && r[5] ? `-${r[5]}` : "", a = t.includePrerelease && r[6] ? `+${r[6]}` : "";
  return bL(`${n}.${s}.${i}${o}${a}`, t);
};
var EL = _L;
class xL {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const r = this.map.get(t);
    if (r !== void 0)
      return this.map.delete(t), this.map.set(t, r), r;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, r) {
    if (!this.delete(t) && r !== void 0) {
      if (this.map.size >= this.max) {
        const s = this.map.keys().next().value;
        this.delete(s);
      }
      this.map.set(t, r);
    }
    return this;
  }
}
var SL = xL, tl, Wm;
function Zt() {
  if (Wm) return tl;
  Wm = 1;
  const e = /\s+/g;
  class t {
    constructor(I, T) {
      if (T = s(T), I instanceof t)
        return I.loose === !!T.loose && I.includePrerelease === !!T.includePrerelease ? I : new t(I.raw, T);
      if (I instanceof i)
        return this.raw = I.value, this.set = [[I]], this.formatted = void 0, this;
      if (this.options = T, this.loose = !!T.loose, this.includePrerelease = !!T.includePrerelease, this.raw = I.trim().replace(e, " "), this.set = this.raw.split("||").map((j) => this.parseRange(j.trim())).filter((j) => j.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const j = this.set[0];
        if (this.set = this.set.filter((P) => !h(P[0])), this.set.length === 0)
          this.set = [j];
        else if (this.set.length > 1) {
          for (const P of this.set)
            if (P.length === 1 && b(P[0])) {
              this.set = [P];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let I = 0; I < this.set.length; I++) {
          I > 0 && (this.formatted += "||");
          const T = this.set[I];
          for (let j = 0; j < T.length; j++)
            j > 0 && (this.formatted += " "), this.formatted += T[j].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(I) {
      const j = ((this.options.includePrerelease && p) | (this.options.loose && u)) + ":" + I, P = n.get(j);
      if (P)
        return P;
      const A = this.options.loose, k = A ? c[f.HYPHENRANGELOOSE] : c[f.HYPHENRANGE];
      I = I.replace(k, U(this.options.includePrerelease)), o("hyphen replace", I), I = I.replace(c[f.COMPARATORTRIM], l), o("comparator trim", I), I = I.replace(c[f.TILDETRIM], d), o("tilde trim", I), I = I.replace(c[f.CARETTRIM], g), o("caret trim", I);
      let C = I.split(" ").map((N) => v(N, this.options)).join(" ").split(/\s+/).map((N) => M(N, this.options));
      A && (C = C.filter((N) => (o("loose invalid filter", N, this.options), !!N.match(c[f.COMPARATORLOOSE])))), o("range list", C);
      const D = /* @__PURE__ */ new Map(), F = C.map((N) => new i(N, this.options));
      for (const N of F) {
        if (h(N))
          return [N];
        D.set(N.value, N);
      }
      D.size > 1 && D.has("") && D.delete("");
      const w = [...D.values()];
      return n.set(j, w), w;
    }
    intersects(I, T) {
      if (!(I instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((j) => m(j, T) && I.set.some((P) => m(P, T) && j.every((A) => P.every((k) => A.intersects(k, T)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(I) {
      if (!I)
        return !1;
      if (typeof I == "string")
        try {
          I = new a(I, this.options);
        } catch {
          return !1;
        }
      for (let T = 0; T < this.set.length; T++)
        if ($(this.set[T], I, this.options))
          return !0;
      return !1;
    }
  }
  tl = t;
  const r = SL, n = new r(), s = Ld, i = Ia(), o = Pa, a = St, {
    safeRe: c,
    t: f,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: g
  } = gi, { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: u } = Oa, h = (S) => S.value === "<0.0.0-0", b = (S) => S.value === "", m = (S, I) => {
    let T = !0;
    const j = S.slice();
    let P = j.pop();
    for (; T && j.length; )
      T = j.every((A) => P.intersects(A, I)), P = j.pop();
    return T;
  }, v = (S, I) => (o("comp", S, I), S = E(S, I), o("caret", S), S = _(S, I), o("tildes", S), S = z(S, I), o("xrange", S), S = L(S, I), o("stars", S), S), y = (S) => !S || S.toLowerCase() === "x" || S === "*", _ = (S, I) => S.trim().split(/\s+/).map((T) => R(T, I)).join(" "), R = (S, I) => {
    const T = I.loose ? c[f.TILDELOOSE] : c[f.TILDE];
    return S.replace(T, (j, P, A, k, C) => {
      o("tilde", S, j, P, A, k, C);
      let D;
      return y(P) ? D = "" : y(A) ? D = `>=${P}.0.0 <${+P + 1}.0.0-0` : y(k) ? D = `>=${P}.${A}.0 <${P}.${+A + 1}.0-0` : C ? (o("replaceTilde pr", C), D = `>=${P}.${A}.${k}-${C} <${P}.${+A + 1}.0-0`) : D = `>=${P}.${A}.${k} <${P}.${+A + 1}.0-0`, o("tilde return", D), D;
    });
  }, E = (S, I) => S.trim().split(/\s+/).map((T) => O(T, I)).join(" "), O = (S, I) => {
    o("caret", S, I);
    const T = I.loose ? c[f.CARETLOOSE] : c[f.CARET], j = I.includePrerelease ? "-0" : "";
    return S.replace(T, (P, A, k, C, D) => {
      o("caret", S, P, A, k, C, D);
      let F;
      return y(A) ? F = "" : y(k) ? F = `>=${A}.0.0${j} <${+A + 1}.0.0-0` : y(C) ? A === "0" ? F = `>=${A}.${k}.0${j} <${A}.${+k + 1}.0-0` : F = `>=${A}.${k}.0${j} <${+A + 1}.0.0-0` : D ? (o("replaceCaret pr", D), A === "0" ? k === "0" ? F = `>=${A}.${k}.${C}-${D} <${A}.${k}.${+C + 1}-0` : F = `>=${A}.${k}.${C}-${D} <${A}.${+k + 1}.0-0` : F = `>=${A}.${k}.${C}-${D} <${+A + 1}.0.0-0`) : (o("no pr"), A === "0" ? k === "0" ? F = `>=${A}.${k}.${C}${j} <${A}.${k}.${+C + 1}-0` : F = `>=${A}.${k}.${C}${j} <${A}.${+k + 1}.0-0` : F = `>=${A}.${k}.${C} <${+A + 1}.0.0-0`), o("caret return", F), F;
    });
  }, z = (S, I) => (o("replaceXRanges", S, I), S.split(/\s+/).map((T) => x(T, I)).join(" ")), x = (S, I) => {
    S = S.trim();
    const T = I.loose ? c[f.XRANGELOOSE] : c[f.XRANGE];
    return S.replace(T, (j, P, A, k, C, D) => {
      o("xRange", S, j, P, A, k, C, D);
      const F = y(A), w = F || y(k), N = w || y(C), q = N;
      return P === "=" && q && (P = ""), D = I.includePrerelease ? "-0" : "", F ? P === ">" || P === "<" ? j = "<0.0.0-0" : j = "*" : P && q ? (w && (k = 0), C = 0, P === ">" ? (P = ">=", w ? (A = +A + 1, k = 0, C = 0) : (k = +k + 1, C = 0)) : P === "<=" && (P = "<", w ? A = +A + 1 : k = +k + 1), P === "<" && (D = "-0"), j = `${P + A}.${k}.${C}${D}`) : w ? j = `>=${A}.0.0${D} <${+A + 1}.0.0-0` : N && (j = `>=${A}.${k}.0${D} <${A}.${+k + 1}.0-0`), o("xRange return", j), j;
    });
  }, L = (S, I) => (o("replaceStars", S, I), S.trim().replace(c[f.STAR], "")), M = (S, I) => (o("replaceGTE0", S, I), S.trim().replace(c[I.includePrerelease ? f.GTE0PRE : f.GTE0], "")), U = (S) => (I, T, j, P, A, k, C, D, F, w, N, q) => (y(j) ? T = "" : y(P) ? T = `>=${j}.0.0${S ? "-0" : ""}` : y(A) ? T = `>=${j}.${P}.0${S ? "-0" : ""}` : k ? T = `>=${T}` : T = `>=${T}${S ? "-0" : ""}`, y(F) ? D = "" : y(w) ? D = `<${+F + 1}.0.0-0` : y(N) ? D = `<${F}.${+w + 1}.0-0` : q ? D = `<=${F}.${w}.${N}-${q}` : S ? D = `<${F}.${w}.${+N + 1}-0` : D = `<=${D}`, `${T} ${D}`.trim()), $ = (S, I, T) => {
    for (let j = 0; j < S.length; j++)
      if (!S[j].test(I))
        return !1;
    if (I.prerelease.length && !T.includePrerelease) {
      for (let j = 0; j < S.length; j++)
        if (o(S[j].semver), S[j].semver !== i.ANY && S[j].semver.prerelease.length > 0) {
          const P = S[j].semver;
          if (P.major === I.major && P.minor === I.minor && P.patch === I.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return tl;
}
var rl, Km;
function Ia() {
  if (Km) return rl;
  Km = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, d) {
      if (d = r(d), l instanceof t) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], g = l.match(d);
      if (!g)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = g[1] !== void 0 ? g[1] : "", this.operator === "=" && (this.operator = ""), g[2] ? this.semver = new a(g[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (o("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new a(l, this.options);
        } catch {
          return !1;
        }
      return i(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = r(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || i(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || i(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  rl = t;
  const r = Ld, { safeRe: n, t: s } = gi, i = __, o = Pa, a = St, c = Zt();
  return rl;
}
const wL = Zt(), RL = (e, t, r) => {
  try {
    t = new wL(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var Na = RL;
const $L = Zt(), TL = (e, t) => new $L(e, t).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var OL = TL;
const PL = St, CL = Zt(), IL = (e, t, r) => {
  let n = null, s = null, i = null;
  try {
    i = new CL(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    i.test(o) && (!n || s.compare(o) === -1) && (n = o, s = new PL(n, r));
  }), n;
};
var NL = IL;
const AL = St, kL = Zt(), LL = (e, t, r) => {
  let n = null, s = null, i = null;
  try {
    i = new kL(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    i.test(o) && (!n || s.compare(o) === 1) && (n = o, s = new AL(n, r));
  }), n;
};
var jL = LL;
const nl = St, DL = Zt(), Jm = Ca, FL = (e, t) => {
  e = new DL(e, t);
  let r = new nl("0.0.0");
  if (e.test(r) || (r = new nl("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let n = 0; n < e.set.length; ++n) {
    const s = e.set[n];
    let i = null;
    s.forEach((o) => {
      const a = new nl(o.semver.version);
      switch (o.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
          (!i || Jm(a, i)) && (i = a);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), i && (!r || Jm(r, i)) && (r = i);
  }
  return r && e.test(r) ? r : null;
};
var ML = FL;
const zL = Zt(), UL = (e, t) => {
  try {
    return new zL(e, t).range || "*";
  } catch {
    return null;
  }
};
var qL = UL;
const HL = St, E_ = Ia(), { ANY: BL } = E_, VL = Zt(), GL = Na, Ym = Ca, Xm = Dd, WL = Md, KL = Fd, JL = (e, t, r, n) => {
  e = new HL(e, n), t = new VL(t, n);
  let s, i, o, a, c;
  switch (r) {
    case ">":
      s = Ym, i = WL, o = Xm, a = ">", c = ">=";
      break;
    case "<":
      s = Xm, i = KL, o = Ym, a = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (GL(e, t, n))
    return !1;
  for (let f = 0; f < t.set.length; ++f) {
    const l = t.set[f];
    let d = null, g = null;
    if (l.forEach((p) => {
      p.semver === BL && (p = new E_(">=0.0.0")), d = d || p, g = g || p, s(p.semver, d.semver, n) ? d = p : o(p.semver, g.semver, n) && (g = p);
    }), d.operator === a || d.operator === c || (!g.operator || g.operator === a) && i(e, g.semver))
      return !1;
    if (g.operator === c && o(e, g.semver))
      return !1;
  }
  return !0;
};
var zd = JL;
const YL = zd, XL = (e, t, r) => YL(e, t, ">", r);
var ZL = XL;
const QL = zd, ej = (e, t, r) => QL(e, t, "<", r);
var tj = ej;
const Zm = Zt(), rj = (e, t, r) => (e = new Zm(e, r), t = new Zm(t, r), e.intersects(t, r));
var nj = rj;
const sj = Na, ij = Xt;
var oj = (e, t, r) => {
  const n = [];
  let s = null, i = null;
  const o = e.sort((l, d) => ij(l, d, r));
  for (const l of o)
    sj(l, t, r) ? (i = l, s || (s = l)) : (i && n.push([s, i]), i = null, s = null);
  s && n.push([s, null]);
  const a = [];
  for (const [l, d] of n)
    l === d ? a.push(l) : !d && l === o[0] ? a.push("*") : d ? l === o[0] ? a.push(`<=${d}`) : a.push(`${l} - ${d}`) : a.push(`>=${l}`);
  const c = a.join(" || "), f = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < f.length ? c : t;
};
const Qm = Zt(), Ud = Ia(), { ANY: sl } = Ud, bs = Na, qd = Xt, aj = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new Qm(e, r), t = new Qm(t, r);
  let n = !1;
  e: for (const s of e.set) {
    for (const i of t.set) {
      const o = lj(s, i, r);
      if (n = n || o !== null, o)
        continue e;
    }
    if (n)
      return !1;
  }
  return !0;
}, cj = [new Ud(">=0.0.0-0")], ey = [new Ud(">=0.0.0")], lj = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === sl) {
    if (t.length === 1 && t[0].semver === sl)
      return !0;
    r.includePrerelease ? e = cj : e = ey;
  }
  if (t.length === 1 && t[0].semver === sl) {
    if (r.includePrerelease)
      return !0;
    t = ey;
  }
  const n = /* @__PURE__ */ new Set();
  let s, i;
  for (const p of e)
    p.operator === ">" || p.operator === ">=" ? s = ty(s, p, r) : p.operator === "<" || p.operator === "<=" ? i = ry(i, p, r) : n.add(p.semver);
  if (n.size > 1)
    return null;
  let o;
  if (s && i) {
    if (o = qd(s.semver, i.semver, r), o > 0)
      return null;
    if (o === 0 && (s.operator !== ">=" || i.operator !== "<="))
      return null;
  }
  for (const p of n) {
    if (s && !bs(p, String(s), r) || i && !bs(p, String(i), r))
      return null;
    for (const u of t)
      if (!bs(p, String(u), r))
        return !1;
    return !0;
  }
  let a, c, f, l, d = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1, g = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1;
  d && d.prerelease.length === 1 && i.operator === "<" && d.prerelease[0] === 0 && (d = !1);
  for (const p of t) {
    if (l = l || p.operator === ">" || p.operator === ">=", f = f || p.operator === "<" || p.operator === "<=", s) {
      if (g && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === g.major && p.semver.minor === g.minor && p.semver.patch === g.patch && (g = !1), p.operator === ">" || p.operator === ">=") {
        if (a = ty(s, p, r), a === p && a !== s)
          return !1;
      } else if (s.operator === ">=" && !bs(s.semver, String(p), r))
        return !1;
    }
    if (i) {
      if (d && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === d.major && p.semver.minor === d.minor && p.semver.patch === d.patch && (d = !1), p.operator === "<" || p.operator === "<=") {
        if (c = ry(i, p, r), c === p && c !== i)
          return !1;
      } else if (i.operator === "<=" && !bs(i.semver, String(p), r))
        return !1;
    }
    if (!p.operator && (i || s) && o !== 0)
      return !1;
  }
  return !(s && f && !i && o !== 0 || i && l && !s && o !== 0 || g || d);
}, ty = (e, t, r) => {
  if (!e)
    return t;
  const n = qd(e.semver, t.semver, r);
  return n > 0 ? e : n < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, ry = (e, t, r) => {
  if (!e)
    return t;
  const n = qd(e.semver, t.semver, r);
  return n < 0 ? e : n > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var uj = aj;
const il = gi, ny = Oa, fj = St, sy = g_, dj = ls, pj = bk, hj = xk, mj = wk, yj = $k, gj = Pk, vj = Nk, bj = Lk, _j = Fk, Ej = Xt, xj = qk, Sj = Vk, wj = jd, Rj = Jk, $j = Zk, Tj = Ca, Oj = Dd, Pj = v_, Cj = b_, Ij = Fd, Nj = Md, Aj = __, kj = EL, Lj = Ia(), jj = Zt(), Dj = Na, Fj = OL, Mj = NL, zj = jL, Uj = ML, qj = qL, Hj = zd, Bj = ZL, Vj = tj, Gj = nj, Wj = oj, Kj = uj;
var Jj = {
  parse: dj,
  valid: pj,
  clean: hj,
  inc: mj,
  diff: yj,
  major: gj,
  minor: vj,
  patch: bj,
  prerelease: _j,
  compare: Ej,
  rcompare: xj,
  compareLoose: Sj,
  compareBuild: wj,
  sort: Rj,
  rsort: $j,
  gt: Tj,
  lt: Oj,
  eq: Pj,
  neq: Cj,
  gte: Ij,
  lte: Nj,
  cmp: Aj,
  coerce: kj,
  Comparator: Lj,
  Range: jj,
  satisfies: Dj,
  toComparators: Fj,
  maxSatisfying: Mj,
  minSatisfying: zj,
  minVersion: Uj,
  validRange: qj,
  outside: Hj,
  gtr: Bj,
  ltr: Vj,
  intersects: Gj,
  simplifyRange: Wj,
  subset: Kj,
  SemVer: fj,
  re: il.re,
  src: il.src,
  tokens: il.t,
  SEMVER_SPEC_VERSION: ny.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: ny.RELEASE_TYPES,
  compareIdentifiers: sy.compareIdentifiers,
  rcompareIdentifiers: sy.rcompareIdentifiers
};
(function(e) {
  const t = Jj, r = vn, n = Symbol.for("registered-plugin"), {
    kTestInternals: s
  } = pt, { exist: i, existReply: o, existRequest: a } = Tb, {
    FST_ERR_PLUGIN_VERSION_MISMATCH: c,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: f,
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: l
  } = bt, d = /-(?:rc|pre|alpha).+$/u;
  function g(x) {
    return x[Symbol.for("plugin-meta")];
  }
  function p(x) {
    const L = h(x);
    if (L)
      return L;
    const M = require.cache;
    if (M) {
      const U = Object.keys(M);
      for (let $ = 0; $ < U.length; $++) {
        const S = U[$];
        if (M[S].exports === x)
          return S;
      }
    }
    return x.name ? x.name : null;
  }
  function u(x) {
    return x.toString().split(`
`, 2).map((L) => L.trim()).join(" -- ");
  }
  function h(x) {
    return x[Symbol.for("fastify.display-name")];
  }
  function b(x) {
    return !!x[Symbol.for("skip-override")];
  }
  function m(x) {
    const L = g(x);
    if (!L) return;
    const M = L.dependencies;
    M && (r(Array.isArray(M), "The dependencies should be an array of strings"), M.forEach((U) => {
      r(
        this[n].indexOf(U) > -1,
        `The dependency '${U}' of plugin '${L.name}' is not registered`
      );
    }));
  }
  function v(x) {
    const L = g(x);
    if (!L) return;
    const { decorators: M, name: U } = L;
    M && (M.fastify && _(this, "Fastify", M.fastify, U), M.reply && _(this, "Reply", M.reply, U), M.request && _(this, "Request", M.request, U));
  }
  const y = {
    Fastify: i,
    Request: a,
    Reply: o
  };
  function _(x, L, M, U) {
    r(Array.isArray(M), "The decorators should be an array of strings"), M.forEach(($) => {
      const S = typeof U == "string" ? ` required by '${U}'` : "";
      if (!y[L].call(x, $))
        throw new f($, S, L);
    });
  }
  function R(x) {
    const L = g(x);
    if ((L == null ? void 0 : L.fastify) == null) return;
    const M = L.fastify, U = d.test(this.version);
    if (!(U === !0 && t.gt(this.version, t.coerce(M)) === !0) && M && t.satisfies(this.version, M, { includePrerelease: U }) === !1)
      throw new c(L.name, M, this.version);
  }
  function E(x) {
    const L = g(x);
    if (!L) return;
    const M = L.name;
    if (M)
      return this[n].push(M), M;
  }
  function O(x, L) {
    if (x.constructor.name === "AsyncFunction" && x.length === 3)
      throw new l(L);
  }
  function z(x) {
    const L = E.call(this, x) || p(x);
    return O.call(this, x, L), R.call(this, x), v.call(this, x), m.call(this, x), b(x);
  }
  e.exports = {
    getPluginName: p,
    getFuncPreview: u,
    kRegisteredPlugins: n,
    getDisplayName: h,
    registerPlugin: z
  }, e.exports[s] = {
    shouldSkipOverride: b,
    getMeta: g,
    checkDecorators: v,
    checkDependencies: m
  };
})(h_);
var x_ = h_.exports;
function Yj(e, t) {
  const r = t || Zj();
  return e ? Qj(e, r) : r;
}
function Xj(e, t) {
  return e.genReqId(t);
}
function Zj() {
  let t = 0;
  return function() {
    return t = t + 1 & 2147483647, `req-${t.toString(36)}`;
  };
}
function Qj(e, t) {
  return function(r) {
    return r.headers[e] || t(r);
  };
}
var Hd = {
  getGenReqId: Xj,
  reqIdGenFactory: Yj
}, vi = { exports: {} }, iy = 12, eD = 0, ol = [
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
function tD(e) {
  var t = e.indexOf("%");
  if (t === -1) return e;
  for (var r = e.length, n = "", s = 0, i = 0, o = t, a = iy; t > -1 && t < r; ) {
    var c = oy(e[t + 1], 4), f = oy(e[t + 2], 0), l = c | f, d = ol[l];
    if (a = ol[256 + a + d], i = i << 6 | l & ol[364 + d], a === iy)
      n += e.slice(s, o), n += i <= 65535 ? String.fromCharCode(i) : String.fromCharCode(
        55232 + (i >> 10),
        56320 + (i & 1023)
      ), i = 0, s = t + 3, t = o = e.indexOf("%", s);
    else {
      if (a === eD)
        return null;
      if (t += 3, t < r && e.charCodeAt(t) === 37) continue;
      return null;
    }
  }
  return n + e.slice(s);
}
var rD = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
function oy(e, t) {
  var r = rD[e];
  return r === void 0 ? 255 : r << t;
}
var nD = tD;
const ay = nD, cy = /\+/g, S_ = function() {
};
S_.prototype = /* @__PURE__ */ Object.create(null);
function sD(e) {
  const t = new S_();
  if (typeof e != "string")
    return t;
  let r = e.length, n = "", s = "", i = -1, o = -1, a = !1, c = !1, f = !1, l = !1, d = !1, g = 0;
  for (let p = 0; p < r + 1; p++)
    if (g = p !== r ? e.charCodeAt(p) : 38, g === 38) {
      if (d = o > i, d || (o = p), n = e.slice(i + 1, o), d || n.length > 0) {
        f && (n = n.replace(cy, " ")), a && (n = ay(n) || n), d && (s = e.slice(o + 1, p), l && (s = s.replace(cy, " ")), c && (s = ay(s) || s));
        const u = t[n];
        u === void 0 ? t[n] = s : u.pop ? u.push(s) : t[n] = [u, s];
      }
      s = "", i = p, o = p, a = !1, c = !1, f = !1, l = !1;
    } else g === 61 ? o <= i ? o = p : c = !0 : g === 43 ? o > i ? l = !0 : f = !0 : g === 37 && (o > i ? c = !0 : a = !0);
  return t;
}
var iD = sD;
const nr = Array.from(
  { length: 256 },
  (e, t) => "%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase()
), oD = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  // 80 - 95
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
  // 112 - 127
]);
function aD(e) {
  const t = e.length;
  if (t === 0) return "";
  let r = "", n = 0, s = 0;
  e: for (; s < t; s++) {
    let i = e.charCodeAt(s);
    for (; i < 128; ) {
      if (oD[i] !== 1 && (n < s && (r += e.slice(n, s)), n = s + 1, r += nr[i]), ++s === t) break e;
      i = e.charCodeAt(s);
    }
    if (n < s && (r += e.slice(n, s)), i < 2048) {
      n = s + 1, r += nr[192 | i >> 6] + nr[128 | i & 63];
      continue;
    }
    if (i < 55296 || i >= 57344) {
      n = s + 1, r += nr[224 | i >> 12] + nr[128 | i >> 6 & 63] + nr[128 | i & 63];
      continue;
    }
    if (++s, s >= t)
      throw new Error("URI malformed");
    const o = e.charCodeAt(s) & 1023;
    n = s + 1, i = 65536 + ((i & 1023) << 10 | o), r += nr[240 | i >> 18] + nr[128 | i >> 12 & 63] + nr[128 | i >> 6 & 63] + nr[128 | i & 63];
  }
  return n === 0 ? e : n < t ? r + e.slice(n) : r;
}
var cD = { encodeString: aD };
const { encodeString: wu } = cD;
function ly(e) {
  const t = typeof e;
  return t === "string" ? wu(e) : t === "bigint" ? e.toString() : t === "boolean" ? e ? "true" : "false" : t === "number" && Number.isFinite(e) ? e < 1e21 ? "" + e : wu("" + e) : "";
}
function lD(e) {
  let t = "";
  if (e === null || typeof e != "object")
    return t;
  const r = "&", n = Object.keys(e), s = n.length;
  let i = 0;
  for (let o = 0; o < s; o++) {
    const a = n[o], c = e[a], f = wu(a) + "=";
    if (o && (t += r), Array.isArray(c)) {
      i = c.length;
      for (let l = 0; l < i; l++)
        l && (t += r), t += f, t += ly(c[l]);
    } else
      t += f, t += ly(c);
  }
  return t;
}
var uD = lD;
const w_ = iD, R_ = uD, $_ = {
  parse: w_,
  stringify: R_
};
vi.exports = $_;
vi.exports.default = $_;
vi.exports.parse = w_;
vi.exports.stringify = R_;
var fD = vi.exports, Aa = { exports: {} }, Ru = { exports: {} }, wr = {}, T_ = {};
Object.defineProperty(T_, "__esModule", { value: !0 });
var O_ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.types = void 0, function(t) {
    t[t.ROOT = 0] = "ROOT", t[t.GROUP = 1] = "GROUP", t[t.POSITION = 2] = "POSITION", t[t.SET = 3] = "SET", t[t.RANGE = 4] = "RANGE", t[t.REPETITION = 5] = "REPETITION", t[t.REFERENCE = 6] = "REFERENCE", t[t.CHAR = 7] = "CHAR";
  }(e.types || (e.types = {}));
})(O_);
var P_ = {};
Object.defineProperty(P_, "__esModule", { value: !0 });
(function(e) {
  var t = be && be.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i), Object.defineProperty(n, o, { enumerable: !0, get: function() {
      return s[i];
    } });
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), r = be && be.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && t(s, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(T_, e), r(O_, e), r(P_, e);
})(wr);
var Gs = {}, Yn = {}, nt = {};
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.anyChar = nt.notWhitespace = nt.whitespace = nt.notInts = nt.ints = nt.notWords = nt.words = void 0;
const Re = wr, C_ = () => [{ type: Re.types.RANGE, from: 48, to: 57 }], I_ = () => [
  { type: Re.types.CHAR, value: 95 },
  { type: Re.types.RANGE, from: 97, to: 122 },
  { type: Re.types.RANGE, from: 65, to: 90 },
  { type: Re.types.RANGE, from: 48, to: 57 }
], N_ = () => [
  { type: Re.types.CHAR, value: 9 },
  { type: Re.types.CHAR, value: 10 },
  { type: Re.types.CHAR, value: 11 },
  { type: Re.types.CHAR, value: 12 },
  { type: Re.types.CHAR, value: 13 },
  { type: Re.types.CHAR, value: 32 },
  { type: Re.types.CHAR, value: 160 },
  { type: Re.types.CHAR, value: 5760 },
  { type: Re.types.RANGE, from: 8192, to: 8202 },
  { type: Re.types.CHAR, value: 8232 },
  { type: Re.types.CHAR, value: 8233 },
  { type: Re.types.CHAR, value: 8239 },
  { type: Re.types.CHAR, value: 8287 },
  { type: Re.types.CHAR, value: 12288 },
  { type: Re.types.CHAR, value: 65279 }
], dD = () => [
  { type: Re.types.CHAR, value: 10 },
  { type: Re.types.CHAR, value: 13 },
  { type: Re.types.CHAR, value: 8232 },
  { type: Re.types.CHAR, value: 8233 }
];
nt.words = () => ({ type: Re.types.SET, set: I_(), not: !1 });
nt.notWords = () => ({ type: Re.types.SET, set: I_(), not: !0 });
nt.ints = () => ({ type: Re.types.SET, set: C_(), not: !1 });
nt.notInts = () => ({ type: Re.types.SET, set: C_(), not: !0 });
nt.whitespace = () => ({ type: Re.types.SET, set: N_(), not: !1 });
nt.notWhitespace = () => ({ type: Re.types.SET, set: N_(), not: !0 });
nt.anyChar = () => ({ type: Re.types.SET, set: dD(), not: !0 });
var pD = be && be.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), hD = be && be.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), mD = be && be.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && pD(t, e, r);
  return hD(t, e), t;
};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.tokenizeClass = Yn.strToChars = void 0;
const uy = wr, On = mD(nt), yD = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
Yn.strToChars = (e) => {
  const t = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
  return e.replace(t, (r, n, s, i, o, a, c) => {
    if (s)
      return r;
    let f = n ? 8 : i ? parseInt(i, 16) : o ? parseInt(o, 16) : a ? yD.indexOf(a) : {
      0: 0,
      t: 9,
      n: 10,
      v: 11,
      f: 12,
      r: 13
    }[c], l = String.fromCharCode(f);
    return /[[\]{}^$.|?*+()]/.test(l) ? `\\${l}` : l;
  });
};
Yn.tokenizeClass = (e, t) => {
  var r, n, s, i, o, a, c;
  let f = [], l, d;
  const g = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (l = g.exec(e)) !== null; ) {
    const p = (c = (a = (o = (i = (s = (n = (r = l[1] && On.words()) !== null && r !== void 0 ? r : l[2] && On.ints()) !== null && n !== void 0 ? n : l[3] && On.whitespace()) !== null && s !== void 0 ? s : l[4] && On.notWords()) !== null && i !== void 0 ? i : l[5] && On.notInts()) !== null && o !== void 0 ? o : l[6] && On.notWhitespace()) !== null && a !== void 0 ? a : l[7] && {
      type: uy.types.RANGE,
      from: (l[8] || l[9]).charCodeAt(0),
      to: (d = l[10]).charCodeAt(d.length - 1)
    }) !== null && c !== void 0 ? c : (d = l[16]) && { type: uy.types.CHAR, value: d.charCodeAt(0) };
    if (p)
      f.push(p);
    else
      return [f, g.lastIndex];
  }
  throw new SyntaxError(`Invalid regular expression: /${t}/: Unterminated character class`);
};
var gD = be && be.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), vD = be && be.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), A_ = be && be.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && gD(t, e, r);
  return vD(t, e), t;
};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.tokenizer = void 0;
const fy = A_(Yn), ct = wr, Kr = A_(nt), bD = /^[a-zA-Z_$]$/i, _D = /^[a-zA-Z0-9_$]$/i, dy = /\d/;
Gs.tokenizer = (e) => {
  let t = 0, r, n = { type: ct.types.ROOT, stack: [] }, s = n, i = n.stack, o = [], a = [], c = 0;
  const f = (d) => {
    throw new SyntaxError(`Invalid regular expression: /${e}/: Nothing to repeat at column ${d - 1}`);
  };
  let l = fy.strToChars(e);
  for (; t < l.length; )
    switch (r = l[t++]) {
      case "\\":
        if (t === l.length)
          throw new SyntaxError(`Invalid regular expression: /${e}/: \\ at end of pattern`);
        switch (r = l[t++]) {
          case "b":
            i.push({ type: ct.types.POSITION, value: "b" });
            break;
          case "B":
            i.push({ type: ct.types.POSITION, value: "B" });
            break;
          case "w":
            i.push(Kr.words());
            break;
          case "W":
            i.push(Kr.notWords());
            break;
          case "d":
            i.push(Kr.ints());
            break;
          case "D":
            i.push(Kr.notInts());
            break;
          case "s":
            i.push(Kr.whitespace());
            break;
          case "S":
            i.push(Kr.notWhitespace());
            break;
          default:
            if (dy.test(r)) {
              let d = r;
              for (; t < l.length && dy.test(l[t]); )
                d += l[t++];
              let g = parseInt(d, 10);
              const p = { type: ct.types.REFERENCE, value: g };
              i.push(p), a.push({ reference: p, stack: i, index: i.length - 1 });
            } else
              i.push({ type: ct.types.CHAR, value: r.charCodeAt(0) });
        }
        break;
      case "^":
        i.push({ type: ct.types.POSITION, value: "^" });
        break;
      case "$":
        i.push({ type: ct.types.POSITION, value: "$" });
        break;
      case "[": {
        let d;
        l[t] === "^" ? (d = !0, t++) : d = !1;
        let g = fy.tokenizeClass(l.slice(t), e);
        t += g[1], i.push({
          type: ct.types.SET,
          set: g[0],
          not: d
        });
        break;
      }
      case ".":
        i.push(Kr.anyChar());
        break;
      case "(": {
        let d = {
          type: ct.types.GROUP,
          stack: [],
          remember: !0
        };
        if (l[t] === "?")
          if (r = l[t + 1], t += 2, r === "=")
            d.followedBy = !0, d.remember = !1;
          else if (r === "!")
            d.notFollowedBy = !0, d.remember = !1;
          else if (r === "<") {
            let g = "";
            if (bD.test(l[t]))
              g += l[t], t++;
            else
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            for (; t < l.length && _D.test(l[t]); )
              g += l[t], t++;
            if (!g)
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            if (l[t] !== ">")
              throw new SyntaxError(`Invalid regular expression: /${e}/: Unclosed capture group name, expected '>', found '${l[t]}' at column ${t + 1}`);
            d.name = g, t++;
          } else if (r === ":")
            d.remember = !1;
          else
            throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid group, character '${r}' after '?' at column ${t - 1}`);
        else
          c += 1;
        i.push(d), o.push(s), s = d, i = d.stack;
        break;
      }
      case ")":
        if (o.length === 0)
          throw new SyntaxError(`Invalid regular expression: /${e}/: Unmatched ) at column ${t - 1}`);
        s = o.pop(), i = s.options ? s.options[s.options.length - 1] : s.stack;
        break;
      case "|": {
        s.options || (s.options = [s.stack], delete s.stack);
        let d = [];
        s.options.push(d), i = d;
        break;
      }
      case "{": {
        let d = /^(\d+)(,(\d+)?)?\}/.exec(l.slice(t)), g, p;
        d !== null ? (i.length === 0 && f(t), g = parseInt(d[1], 10), p = d[2] ? d[3] ? parseInt(d[3], 10) : 1 / 0 : g, t += d[0].length, i.push({
          type: ct.types.REPETITION,
          min: g,
          max: p,
          value: i.pop()
        })) : i.push({
          type: ct.types.CHAR,
          value: 123
        });
        break;
      }
      case "?":
        i.length === 0 && f(t), i.push({
          type: ct.types.REPETITION,
          min: 0,
          max: 1,
          value: i.pop()
        });
        break;
      case "+":
        i.length === 0 && f(t), i.push({
          type: ct.types.REPETITION,
          min: 1,
          max: 1 / 0,
          value: i.pop()
        });
        break;
      case "*":
        i.length === 0 && f(t), i.push({
          type: ct.types.REPETITION,
          min: 0,
          max: 1 / 0,
          value: i.pop()
        });
        break;
      default:
        i.push({
          type: ct.types.CHAR,
          value: r.charCodeAt(0)
        });
    }
  if (o.length !== 0)
    throw new SyntaxError(`Invalid regular expression: /${e}/: Unterminated group`);
  return ED(a, c), n;
};
function ED(e, t) {
  for (const r of e.reverse())
    if (t < r.reference.value) {
      r.reference.type = ct.types.CHAR;
      const n = r.reference.value.toString();
      if (r.reference.value = parseInt(n, 8), !/^[0-7]+$/.test(n)) {
        let s = 0;
        for (; n[s] !== "8" && n[s] !== "9"; )
          s += 1;
        if (s === 0 ? (r.reference.value = n.charCodeAt(0), s += 1) : r.reference.value = parseInt(n.slice(0, s), 8), n.length > s) {
          const i = r.stack.splice(r.index + 1);
          for (const o of n.slice(s))
            r.stack.push({
              type: ct.types.CHAR,
              value: o.charCodeAt(0)
            });
          r.stack.push(...i);
        }
      }
    }
}
var $u = {}, Xn = {}, ur = {}, xD = be && be.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), SD = be && be.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), wD = be && be.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && xD(t, e, r);
  return SD(t, e), t;
};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.NOTANYCHAR = ur.WHITESPACE = ur.WORDS = ur.INTS = void 0;
const ka = wD(nt), py = wr;
function La(e) {
  let t = {}, r = 0;
  for (const n of e)
    n.type === py.types.CHAR && (t[n.value] = !0), n.type === py.types.RANGE && (t[`${n.from}-${n.to}`] = !0), r += 1;
  return {
    lookup: () => Object.assign({}, t),
    len: r
  };
}
ur.INTS = La(ka.ints().set);
ur.WORDS = La(ka.words().set);
ur.WHITESPACE = La(ka.whitespace().set);
ur.NOTANYCHAR = La(ka.anyChar().set);
var RD = be && be.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), $D = be && be.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), TD = be && be.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && RD(t, e, r);
  return $D(t, e), t;
};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.writeSetTokens = Xn.setChar = void 0;
const Go = wr, Yi = TD(ur);
function Eo(e) {
  return e === 94 ? "\\^" : e === 92 ? "\\\\" : e === 93 ? "\\]" : e === 45 ? "\\-" : String.fromCharCode(e);
}
Xn.setChar = Eo;
function Xi(e, { lookup: t, len: r }) {
  if (r !== e.length)
    return !1;
  const n = t();
  for (const s of e) {
    if (s.type === Go.types.SET)
      return !1;
    const i = s.type === Go.types.CHAR ? s.value : `${s.from}-${s.to}`;
    if (n[i])
      n[i] = !1;
    else
      return !1;
  }
  return !0;
}
function k_(e, t = !1) {
  if (Xi(e.set, Yi.INTS))
    return e.not ? "\\D" : "\\d";
  if (Xi(e.set, Yi.WORDS))
    return e.not ? "\\W" : "\\w";
  if (e.not && Xi(e.set, Yi.NOTANYCHAR))
    return ".";
  if (Xi(e.set, Yi.WHITESPACE))
    return e.not ? "\\S" : "\\s";
  let r = "";
  for (let s = 0; s < e.set.length; s++) {
    const i = e.set[s];
    r += OD(i);
  }
  const n = `${e.not ? "^" : ""}${r}`;
  return t ? n : `[${n}]`;
}
Xn.writeSetTokens = k_;
function OD(e) {
  return e.type === Go.types.CHAR ? Eo(e.value) : e.type === Go.types.RANGE ? `${Eo(e.from)}-${Eo(e.to)}` : k_(e, !0);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reconstruct = void 0;
  const t = wr, r = Xn, n = (i) => i.map(e.reconstruct).join(""), s = (i) => {
    if ("options" in i)
      return i.options.map(n).join("|");
    if ("stack" in i)
      return n(i.stack);
    throw new Error("options or stack must be Root or Group token");
  };
  e.reconstruct = (i) => {
    switch (i.type) {
      case t.types.ROOT:
        return s(i);
      case t.types.CHAR: {
        const o = String.fromCharCode(i.value);
        return (/[[\\{}$^.|?*+()]/.test(o) ? "\\" : "") + o;
      }
      case t.types.POSITION:
        return i.value === "^" || i.value === "$" ? i.value : `\\${i.value}`;
      case t.types.REFERENCE:
        return `\\${i.value}`;
      case t.types.SET:
        return r.writeSetTokens(i);
      case t.types.GROUP:
        return `(${i.name ? `?<${i.name}>` : i.remember ? "" : i.followedBy ? "?=" : i.notFollowedBy ? "?!" : "?:"}${s(i)})`;
      case t.types.REPETITION: {
        const { min: o, max: a } = i;
        let c;
        return o === 0 && a === 1 ? c = "?" : o === 1 && a === 1 / 0 ? c = "+" : o === 0 && a === 1 / 0 ? c = "*" : a === 1 / 0 ? c = `{${o},}` : o === a ? c = `{${o}}` : c = `{${o},${a}}`, `${e.reconstruct(i.value)}${c}`;
      }
      case t.types.RANGE:
        return `${r.setChar(i.from)}-${r.setChar(i.to)}`;
      default:
        throw new Error(`Invalid token type ${i}`);
    }
  };
})($u);
(function(e, t) {
  var r = be && be.__createBinding || (Object.create ? function(a, c, f, l) {
    l === void 0 && (l = f), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return c[f];
    } });
  } : function(a, c, f, l) {
    l === void 0 && (l = f), a[l] = c[f];
  }), n = be && be.__exportStar || function(a, c) {
    for (var f in a) f !== "default" && !Object.prototype.hasOwnProperty.call(c, f) && r(c, a, f);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.types = void 0;
  const s = wr;
  Object.defineProperty(t, "types", { enumerable: !0, get: function() {
    return s.types;
  } }), n(Gs, t), n($u, t);
  const i = Gs, o = $u;
  n(wr, t), t.default = i.tokenizer, e.exports = i.tokenizer, e.exports.types = s.types, e.exports.reconstruct = o.reconstruct;
})(Ru, Ru.exports);
var PD = Ru.exports;
const L_ = PD, CD = L_.types;
function Bd(e, t) {
  t || (t = {});
  const r = t.limit === void 0 ? 25 : t.limit;
  ID(e) ? e = e.source : typeof e != "string" && (e = String(e));
  try {
    e = L_(e);
  } catch {
    return !1;
  }
  let n = 0;
  return function s(i, o) {
    var d;
    let a, c, f;
    if (i.type === CD.REPETITION && (o++, n++, o > 1 || n > r))
      return !1;
    if (i.options) {
      for (a = 0, f = i.options.length; a < f; a++)
        if (c = s({ stack: i.options[a] }, o), !c) return !1;
    }
    const l = i.stack || ((d = i.value) == null ? void 0 : d.stack);
    if (!l) return !0;
    for (a = 0; a < l.length; a++)
      if (c = s(l[a], o), !c) return !1;
    return !0;
  }(e, 0);
}
function ID(e) {
  return {}.toString.call(e) === "[object RegExp]";
}
Aa.exports = Bd;
Aa.exports.default = Bd;
Aa.exports.safeRegex = Bd;
var ND = Aa.exports, Vd = {
  name: "__fmw_internal_strategy_merged_tree_http_method__",
  storage: function() {
    const e = /* @__PURE__ */ new Map();
    return {
      get: (t) => e.get(t) || null,
      set: (t, r) => {
        e.set(t, r);
      }
    };
  },
  /* c8 ignore next 1 */
  deriveConstraint: (e) => e.method,
  mustMatchWhenDerived: !0
};
const hy = ba, my = Vd, j_ = Symbol("treeData");
function D_(e, t = "") {
  let r = "";
  const n = Object.keys(e);
  for (let s = 0; s < n.length; s++) {
    const i = n[s], o = e[i], a = s === n.length - 1, c = a ? "└── " : "├── ", f = a ? "    " : "│   ", d = (o[j_] || "").replaceAll(`
`, `
` + t + f);
    r += t + c + i + d + `
`, r += D_(o, t + f);
  }
  return r;
}
function AD(e) {
  let t = e.name || "";
  return t = t.replace("bound", "").trim(), t = (t || "anonymous") + "()", t;
}
function F_(e) {
  return Array.isArray(e) ? e.map((t) => F_(t)) : typeof e == "symbol" ? e.toString() : typeof e == "function" ? AD(e) : e;
}
function kD(e, t) {
  if (!t.includeMeta) return {};
  const r = t.buildPrettyMeta(e), n = {};
  let s = t.includeMeta;
  Array.isArray(s) || (s = Reflect.ownKeys(r));
  for (const i of s) {
    if (!Object.prototype.hasOwnProperty.call(r, i)) continue;
    const o = i.toString(), a = r[i];
    if (a != null) {
      const c = JSON.stringify(F_(a));
      n[o] = c;
    }
  }
  return n;
}
function LD(e) {
  let t = "";
  for (const [r, n] of Object.entries(e))
    t += `
• (${r}) ${n}`;
  return t;
}
function jD(e) {
  const t = { ...e.opts.constraints }, r = t[my.name];
  return delete t[my.name], { ...e, method: r, opts: { constraints: t } };
}
function DD(e) {
  let t = ` (${e.method})`;
  const r = e.opts.constraints || {};
  return Object.keys(r).length !== 0 && (t += " " + JSON.stringify(r)), t += LD(e.metaData), t;
}
function FD(e) {
  return e.reduce((t, r) => {
    for (const n of t)
      if (hy(r.opts.constraints, n.opts.constraints) && hy(r.metaData, n.metaData))
        return n.method += ", " + r.method, t;
    return t.push(r), t;
  }, []);
}
function MD(e, t, r) {
  let n = e.routes;
  return r.method === void 0 && (n = n.map(jD)), n = n.map((s) => (s.metaData = kD(s, r), s)), r.method === void 0 && (n = FD(n)), n.map(DD).join(`
${t}`);
}
function xo(e, t, r, n) {
  if ((e.isLeafNode || n.commonPrefix !== !1) && (r = r || "(empty root node)", t = t[r] = {}, e.isLeafNode && (t[j_] = MD(e, r, n)), r = ""), e.staticChildren)
    for (const s of Object.values(e.staticChildren))
      xo(s, t, r + s.prefix, n);
  if (e.parametricChildren)
    for (const s of Object.values(e.parametricChildren)) {
      const i = Array.from(s.nodePaths).join("|");
      xo(s, t, r + i, n);
    }
  e.wildcardChild && xo(e.wildcardChild, t, "*", n);
}
function zD(e, t) {
  const r = {};
  return xo(e, r, e.prefix, t), D_(r);
}
var UD = { prettyPrintTree: zD };
const M_ = function() {
};
M_.prototype = /* @__PURE__ */ Object.create(null);
var qD = {
  NullObject: M_
};
const { NullObject: HD } = qD, BD = Vd;
let VD = class {
  constructor() {
    this.unconstrainedHandler = null, this.constraints = [], this.handlers = [], this.constrainedHandlerStores = null;
  }
  // This is the hot path for node handler finding -- change with care!
  getMatchingHandler(t) {
    return t === void 0 ? this.unconstrainedHandler : this._getHandlerMatchingConstraints(t);
  }
  addHandler(t, r) {
    const n = r.params, s = r.opts.constraints || {}, i = {
      params: n,
      constraints: s,
      handler: r.handler,
      store: r.store || null,
      _createParamsObject: this._compileCreateParamsObject(n)
    }, o = Object.keys(s);
    o.length === 0 && (this.unconstrainedHandler = i);
    for (const c of o)
      this.constraints.includes(c) || (c === "version" ? this.constraints.unshift(c) : this.constraints.push(c));
    const a = o.includes(BD.name);
    if (!a && this.handlers.length >= 31)
      throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
    this.handlers.push(i), this.handlers.sort((c, f) => Object.keys(c.constraints).length - Object.keys(f.constraints).length), a || this._compileGetHandlerMatchingConstraints(t, s);
  }
  _compileCreateParamsObject(t) {
    const r = [];
    r.push("const fn = function _createParamsObject (paramsArray) {"), r.push("const params = new NullObject()");
    for (let n = 0; n < t.length; n++)
      r.push(`params['${t[n]}'] = paramsArray[${n}]`);
    return r.push("return params"), r.push("}"), r.push("return fn"), new Function("NullObject", r.join(`
`))(HD);
  }
  _getHandlerMatchingConstraints() {
    return null;
  }
  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
  // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
  // The store's implementation comes from the strategies provided to the Router.
  _buildConstraintStore(t, r) {
    for (let n = 0; n < this.handlers.length; n++) {
      const i = this.handlers[n].constraints[r];
      if (i !== void 0) {
        let o = t.get(i) || 0;
        o |= 1 << n, t.set(i, o);
      }
    }
  }
  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
  _constrainedIndexBitmask(t) {
    let r = 0;
    for (let n = 0; n < this.handlers.length; n++)
      this.handlers[n].constraints[t] !== void 0 && (r |= 1 << n);
    return ~r;
  }
  // Compile a fast function to match the handlers for this node
  // The function implements a general case multi-constraint matching algorithm.
  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
  _compileGetHandlerMatchingConstraints(t) {
    this.constrainedHandlerStores = {};
    for (const n of this.constraints) {
      const s = t.newStoreForConstraint(n);
      this.constrainedHandlerStores[n] = s, this._buildConstraintStore(s, n);
    }
    const r = [];
    r.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
    for (const n of this.constraints) {
      r.push(`
      mask = ${this._constrainedIndexBitmask(n)}
      value = derivedConstraints.${n}
      `);
      const i = t.strategies[n].mustMatchWhenDerived ? "matches" : "(matches | mask)";
      r.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${n}.get(value) || 0
        candidates &= ${i}
      }
      if (candidates === 0) return null;
      `);
    }
    for (const n in t.strategies)
      t.strategies[n].mustMatchWhenDerived && !this.constraints.includes(n) && r.push(`if (derivedConstraints.${n} !== undefined) return null`);
    r.push("return this.handlers[Math.floor(Math.log2(candidates))]"), this._getHandlerMatchingConstraints = new Function("derivedConstraints", r.join(`
`));
  }
};
var GD = VD;
const WD = GD, ja = {
  STATIC: 0,
  PARAMETRIC: 1,
  WILDCARD: 2
};
class z_ {
  constructor() {
    this.isLeafNode = !1, this.routes = null, this.handlerStorage = null;
  }
  addRoute(t, r) {
    this.routes === null && (this.routes = []), this.handlerStorage === null && (this.handlerStorage = new WD()), this.isLeafNode = !0, this.routes.push(t), this.handlerStorage.addHandler(r, t);
  }
}
class U_ extends z_ {
  constructor() {
    super(), this.staticChildren = {};
  }
  findStaticMatchingChild(t, r) {
    const n = this.staticChildren[t.charAt(r)];
    return n === void 0 || !n.matchPrefix(t, r) ? null : n;
  }
  getStaticChild(t, r = 0) {
    if (t.length === r)
      return this;
    const n = this.findStaticMatchingChild(t, r);
    return n ? n.getStaticChild(t, r + n.prefix.length) : null;
  }
  createStaticChild(t) {
    if (t.length === 0)
      return this;
    let r = this.staticChildren[t.charAt(0)];
    if (r) {
      let s = 1;
      for (; s < r.prefix.length; s++)
        if (t.charCodeAt(s) !== r.prefix.charCodeAt(s)) {
          r = r.split(this, s);
          break;
        }
      return r.createStaticChild(t.slice(s));
    }
    const n = t.charAt(0);
    return this.staticChildren[n] = new q_(t), this.staticChildren[n];
  }
}
let q_ = class H_ extends U_ {
  constructor(t) {
    super(), this.prefix = t, this.wildcardChild = null, this.parametricChildren = [], this.kind = ja.STATIC, this._compilePrefixMatch();
  }
  getParametricChild(t) {
    const r = t && t.source, n = this.parametricChildren.find((s) => (s.regex && s.regex.source) === r);
    return n || null;
  }
  createParametricChild(t, r, n) {
    let s = this.getParametricChild(t);
    return s ? (s.nodePaths.add(n), s) : (s = new KD(t, r, n), this.parametricChildren.push(s), this.parametricChildren.sort((i, o) => i.isRegex ? o.isRegex ? i.staticSuffix === null ? 1 : o.staticSuffix === null ? -1 : o.staticSuffix.endsWith(i.staticSuffix) ? 1 : i.staticSuffix.endsWith(o.staticSuffix) ? -1 : 0 : -1 : 1), s);
  }
  getWildcardChild() {
    return this.wildcardChild;
  }
  createWildcardChild() {
    return this.wildcardChild = this.getWildcardChild() || new JD(), this.wildcardChild;
  }
  split(t, r) {
    const n = this.prefix.slice(0, r), s = this.prefix.slice(r);
    this.prefix = s, this._compilePrefixMatch();
    const i = new H_(n);
    return i.staticChildren[s.charAt(0)] = this, t.staticChildren[n.charAt(0)] = i, i;
  }
  getNextNode(t, r, n, s) {
    let i = this.findStaticMatchingChild(t, r), o = 0;
    if (i === null) {
      if (this.parametricChildren.length === 0)
        return this.wildcardChild;
      i = this.parametricChildren[0], o = 1;
    }
    this.wildcardChild !== null && n.push({
      paramsCount: s,
      brotherPathIndex: r,
      brotherNode: this.wildcardChild
    });
    for (let a = this.parametricChildren.length - 1; a >= o; a--)
      n.push({
        paramsCount: s,
        brotherPathIndex: r,
        brotherNode: this.parametricChildren[a]
      });
    return i;
  }
  _compilePrefixMatch() {
    if (this.prefix.length === 1) {
      this.matchPrefix = () => !0;
      return;
    }
    const t = [];
    for (let r = 1; r < this.prefix.length; r++) {
      const n = this.prefix.charCodeAt(r);
      t.push(`path.charCodeAt(i + ${r}) === ${n}`);
    }
    this.matchPrefix = new Function("path", "i", `return ${t.join(" && ")}`);
  }
};
class KD extends U_ {
  constructor(t, r, n) {
    super(), this.isRegex = !!t, this.regex = t || null, this.staticSuffix = r || null, this.kind = ja.PARAMETRIC, this.nodePaths = /* @__PURE__ */ new Set([n]);
  }
  getNextNode(t, r) {
    return this.findStaticMatchingChild(t, r);
  }
}
class JD extends z_ {
  constructor() {
    super(), this.kind = ja.WILDCARD;
  }
  getNextNode() {
    return null;
  }
}
var YD = { StaticNode: q_, NODE_TYPES: ja };
const XD = vn;
function Ws() {
  if (!(this instanceof Ws))
    return new Ws();
  this.store = /* @__PURE__ */ new Map(), this.maxMajor = 0, this.maxMinors = {}, this.maxPatches = {};
}
Ws.prototype.set = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("Version should be a string");
  let [r, n, s] = e.split(".", 3);
  if (isNaN(r))
    throw new TypeError("Major version must be a numeric value");
  return r = Number(r), n = Number(n) || 0, s = Number(s) || 0, r >= this.maxMajor && (this.maxMajor = r, this.store.set("x", t), this.store.set("*", t), this.store.set("x.x", t), this.store.set("x.x.x", t)), n >= (this.maxMinors[r] || 0) && (this.maxMinors[r] = n, this.store.set(`${r}.x`, t), this.store.set(`${r}.x.x`, t)), s >= (this.maxPatches[`${r}.${n}`] || 0) && (this.maxPatches[`${r}.${n}`] = s, this.store.set(`${r}.${n}.x`, t)), this.store.set(`${r}.${n}.${s}`, t), this;
};
Ws.prototype.get = function(e) {
  return this.store.get(e);
};
var ZD = {
  name: "version",
  mustMatchWhenDerived: !0,
  storage: Ws,
  validate(e) {
    XD(typeof e == "string", "Version should be a string");
  }
};
const QD = vn;
function eF() {
  const e = /* @__PURE__ */ new Map(), t = [];
  return {
    get: (r) => {
      const n = e.get(r);
      if (n)
        return n;
      for (const s of t)
        if (s.host.test(r))
          return s.value;
    },
    set: (r, n) => {
      r instanceof RegExp ? t.push({ host: r, value: n }) : e.set(r, n);
    }
  };
}
var tF = {
  name: "host",
  mustMatchWhenDerived: !1,
  storage: eF,
  validate(e) {
    QD(typeof e == "string" || Object.prototype.toString.call(e) === "[object RegExp]", "Host should be a string or a RegExp");
  }
};
const rF = ZD, nF = tF, al = vn;
let sF = class {
  constructor(t) {
    if (this.strategies = {
      version: rF,
      host: nF
    }, this.strategiesInUse = /* @__PURE__ */ new Set(), this.asyncStrategiesInUse = /* @__PURE__ */ new Set(), t)
      for (const r of Object.values(t))
        this.addConstraintStrategy(r);
  }
  isStrategyUsed(t) {
    return this.strategiesInUse.has(t) || this.asyncStrategiesInUse.has(t);
  }
  hasConstraintStrategy(t) {
    const r = this.strategies[t];
    return r !== void 0 ? r.isCustom || this.isStrategyUsed(t) : !1;
  }
  addConstraintStrategy(t) {
    if (al(typeof t.name == "string" && t.name !== "", "strategy.name is required."), al(t.storage && typeof t.storage == "function", "strategy.storage function is required."), al(t.deriveConstraint && typeof t.deriveConstraint == "function", "strategy.deriveConstraint function is required."), this.strategies[t.name] && this.strategies[t.name].isCustom)
      throw new Error(`There already exists a custom constraint with the name ${t.name}.`);
    if (this.isStrategyUsed(t.name))
      throw new Error(`There already exists a route with ${t.name} constraint.`);
    t.isCustom = !0, t.isAsync = t.deriveConstraint.length === 3, this.strategies[t.name] = t, t.mustMatchWhenDerived && this.noteUsage({ [t.name]: t });
  }
  deriveConstraints(t, r, n) {
    const s = this.deriveSyncConstraints(t, r);
    if (n === void 0)
      return s;
    this.deriveAsyncConstraints(s, t, r, n);
  }
  deriveSyncConstraints(t, r) {
  }
  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
  noteUsage(t) {
    if (t) {
      const r = this.strategiesInUse.size;
      for (const n in t)
        this.strategies[n].isAsync ? this.asyncStrategiesInUse.add(n) : this.strategiesInUse.add(n);
      r !== this.strategiesInUse.size && this._buildDeriveConstraints();
    }
  }
  newStoreForConstraint(t) {
    if (!this.strategies[t])
      throw new Error(`No strategy registered for constraint key ${t}`);
    return this.strategies[t].storage();
  }
  validateConstraints(t) {
    for (const r in t) {
      const n = t[r];
      if (typeof n > "u")
        throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
      const s = this.strategies[r];
      if (!s)
        throw new Error(`No strategy registered for constraint key ${r}`);
      s.validate && s.validate(n);
    }
  }
  deriveAsyncConstraints(t, r, n, s) {
    let i = this.asyncStrategiesInUse.size;
    if (i === 0) {
      s(null, t);
      return;
    }
    t = t || {};
    for (const o of this.asyncStrategiesInUse)
      this.strategies[o].deriveConstraint(r, n, (c, f) => {
        if (c !== null) {
          s(c);
          return;
        }
        t[o] = f, --i === 0 && s(null, t);
      });
  }
  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
  // This allows us to not allocate an object to hold constraint values if no constraints are defined.
  _buildDeriveConstraints() {
    if (this.strategiesInUse.size === 0) return;
    const t = ["return {"];
    for (const r of this.strategiesInUse) {
      const n = this.strategies[r];
      n.isCustom ? t.push(`  ${n.name}: this.strategies.${r}.deriveConstraint(req, ctx),`) : r === "version" ? t.push("   version: req.headers['accept-version'],") : t.push("   host: req.headers.host || req.headers[':authority'],");
    }
    t.push("}"), this.deriveSyncConstraints = new Function("req", "ctx", t.join(`
`)).bind(this);
  }
};
var iF = sF;
const oF = [
  "ACL",
  "BIND",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LINK",
  "LOCK",
  "M-SEARCH",
  "MERGE",
  "MKACTIVITY",
  "MKCALENDAR",
  "MKCOL",
  "MOVE",
  "NOTIFY",
  "OPTIONS",
  "PATCH",
  "POST",
  "PROPFIND",
  "PROPPATCH",
  "PURGE",
  "PUT",
  "QUERY",
  "REBIND",
  "REPORT",
  "SEARCH",
  "SOURCE",
  "SUBSCRIBE",
  "TRACE",
  "UNBIND",
  "UNLINK",
  "UNLOCK",
  "UNSUBSCRIBE"
];
var aF = oF;
function B_(e, t) {
  return e === 50 ? t === 53 ? "%" : t === 51 ? "#" : t === 52 ? "$" : t === 54 ? "&" : t === 66 || t === 98 ? "+" : t === 67 || t === 99 ? "," : t === 70 || t === 102 ? "/" : null : e === 51 ? t === 65 || t === 97 ? ":" : t === 66 || t === 98 ? ";" : t === 68 || t === 100 ? "=" : t === 70 || t === 102 ? "?" : null : e === 52 && t === 48 ? "@" : null;
}
function cF(e, t) {
  let r = !1, n = !1, s = "";
  for (let o = 1; o < e.length; o++) {
    const a = e.charCodeAt(o);
    if (a === 37) {
      const c = e.charCodeAt(o + 1), f = e.charCodeAt(o + 2);
      B_(c, f) === null ? r = !0 : (n = !0, c === 50 && f === 53 && (r = !0, e = e.slice(0, o + 1) + "25" + e.slice(o + 1), o += 2), o += 2);
    } else if (a === 63 || a === 35 || a === 59 && t) {
      s = e.slice(o + 1), e = e.slice(0, o);
      break;
    }
  }
  return { path: r ? decodeURI(e) : e, querystring: s, shouldDecodeParam: n };
}
function lF(e) {
  const t = e.indexOf("%");
  if (t === -1) return e;
  let r = "", n = t;
  for (let s = t; s < e.length; s++)
    if (e.charCodeAt(s) === 37) {
      const i = e.charCodeAt(s + 1), o = e.charCodeAt(s + 2), a = B_(i, o);
      r += e.slice(n, s) + a, n = s + 3;
    }
  return e.slice(0, t) + r + e.slice(n);
}
var uF = { safeDecodeURI: cF, safeDecodeURIComponent: lF };
const Ye = vn, fF = fD, us = ND, Gd = ba, { prettyPrintTree: dF } = UD, { StaticNode: yy, NODE_TYPES: gy } = YD, pF = iF, Bn = aF, cl = Vd, { safeDecodeURI: hF, safeDecodeURIComponent: vy } = uF, V_ = /^https?:\/\/.*?\//, cn = /(\/:[^/()]*?)\?(\/?)/, G_ = /[.*+?^${}()|[\]\\]/g, W_ = /\/\/+/g;
if (!us(V_))
  throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
if (!us(cn))
  throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
if (!us(G_))
  throw new Error("the ESCAPE_REGEXP is not safe, update this module");
if (!us(W_))
  throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
function qe(e) {
  if (!(this instanceof qe))
    return new qe(e);
  e = e || {}, this._opts = e, e.defaultRoute ? (Ye(typeof e.defaultRoute == "function", "The default route must be a function"), this.defaultRoute = e.defaultRoute) : this.defaultRoute = null, e.onBadUrl ? (Ye(typeof e.onBadUrl == "function", "The bad url handler must be a function"), this.onBadUrl = e.onBadUrl) : this.onBadUrl = null, e.buildPrettyMeta ? (Ye(typeof e.buildPrettyMeta == "function", "buildPrettyMeta must be a function"), this.buildPrettyMeta = e.buildPrettyMeta) : this.buildPrettyMeta = mF, e.querystringParser ? (Ye(typeof e.querystringParser == "function", "querystringParser must be a function"), this.querystringParser = e.querystringParser) : this.querystringParser = (t) => t.length === 0 ? {} : fF.parse(t), this.caseSensitive = e.caseSensitive === void 0 ? !0 : e.caseSensitive, this.ignoreTrailingSlash = e.ignoreTrailingSlash || !1, this.ignoreDuplicateSlashes = e.ignoreDuplicateSlashes || !1, this.maxParamLength = e.maxParamLength || 100, this.allowUnsafeRegex = e.allowUnsafeRegex || !1, this.constrainer = new pF(e.constraints), this.useSemicolonDelimiter = e.useSemicolonDelimiter || !1, this.routes = [], this.trees = {};
}
qe.prototype.on = function(t, r, n, s, i) {
  typeof n == "function" && (s !== void 0 && (i = s), s = n, n = {}), Ye(typeof r == "string", "Path should be a string"), Ye(r.length > 0, "The path could not be empty"), Ye(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), Ye(typeof s == "function", "Handler should be a function");
  const o = r.match(cn);
  if (o) {
    Ye(r.length === o.index + o[0].length, "Optional Parameter needs to be the last parameter of the path");
    const f = r.replace(cn, "$1$2"), l = r.replace(cn, "$2") || "/";
    this.on(t, f, n, s, i), this.on(t, l, n, s, i);
    return;
  }
  const a = r;
  this.ignoreDuplicateSlashes && (r = Wd(r)), this.ignoreTrailingSlash && (r = Kd(r));
  const c = Array.isArray(t) ? t : [t];
  for (const f of c)
    Ye(typeof f == "string", "Method should be a string"), Ye(Bn.includes(f), `Method '${f}' is not an http method.`), this._on(f, r, n, s, i, a);
};
qe.prototype._on = function(t, r, n, s, i) {
  let o = {};
  n.constraints !== void 0 && (Ye(typeof n.constraints == "object" && n.constraints !== null, "Constraints should be an object"), Object.keys(n.constraints).length !== 0 && (o = n.constraints)), this.constrainer.validateConstraints(o), this.constrainer.noteUsage(o), this.trees[t] === void 0 && (this.trees[t] = new yy("/"));
  let a = r;
  if (a === "*" && this.trees[t].prefix.length !== 0) {
    const g = this.trees[t];
    this.trees[t] = new yy(""), this.trees[t].staticChildren["/"] = g;
  }
  let c = this.trees[t], f = c.prefix.length;
  const l = [];
  for (let g = 0; g <= a.length; g++) {
    if (a.charCodeAt(g) === 58 && a.charCodeAt(g + 1) === 58) {
      g++;
      continue;
    }
    const p = a.charCodeAt(g) === 58 && a.charCodeAt(g + 1) !== 58, u = a.charCodeAt(g) === 42;
    if (p || u || g === a.length && g !== f) {
      let h = a.slice(f, g);
      this.caseSensitive || (h = h.toLowerCase()), h = h.replaceAll("::", ":"), h = h.replaceAll("%", "%25"), c = c.createStaticChild(h);
    }
    if (p) {
      let h = !1, b = !0, m = "";
      const v = [];
      let y = g + 1;
      for (let _ = y; ; _++) {
        const R = a.charCodeAt(_), E = R === 40, O = R === 45 || R === 46, z = R === 47 || _ === a.length;
        if (E || O || z) {
          const x = a.slice(y, _);
          if (l.push(x), h = h || E || O, E) {
            const U = X_(a, _), $ = a.slice(_, U + 1);
            this.allowUnsafeRegex || Ye(us(new RegExp($)), `The regex '${$}' is not safe!`), v.push(Y_($)), _ = U + 1, b = !0;
          } else
            v.push(b ? "(.*?)" : `(${m}|(?:(?!${m}).)*)`), b = !1;
          const L = _;
          for (; _ < a.length; _++) {
            const U = a.charCodeAt(_);
            if (U === 47) break;
            if (U === 58)
              if (a.charCodeAt(_ + 1) === 58) _++;
              else break;
          }
          let M = a.slice(L, _);
          if (M && (M = M.replaceAll("::", ":"), M = M.replaceAll("%", "%25"), v.push(m = J_(M))), y = _ + 1, z || a.charCodeAt(_) === 47 || _ === a.length) {
            const U = h ? "()" + M : M, $ = a.slice(g, _);
            a = a.slice(0, g + 1) + U + a.slice(_), g += U.length;
            const S = h ? new RegExp("^" + v.join("") + "$") : null;
            c = c.createParametricChild(S, M || null, $), f = g + 1;
            break;
          }
        }
      }
    } else if (u && (l.push("*"), c = c.createWildcardChild(), f = g + 1, g !== a.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (a = a.toLowerCase()), a === "*" && (a = "/*");
  for (const g of this.routes) {
    const p = g.opts.constraints || {};
    if (g.method === t && g.pattern === a && Gd(p, o))
      throw new Error(`Method '${t}' already declared for route '${a}' with constraints '${JSON.stringify(o)}'`);
  }
  const d = { method: t, path: r, pattern: a, params: l, opts: n, handler: s, store: i };
  this.routes.push(d), c.addRoute(d, this.constrainer);
};
qe.prototype.hasRoute = function(t, r, n) {
  return this.findRoute(t, r, n) !== null;
};
qe.prototype.findRoute = function(t, r, n = {}) {
  if (this.trees[t] === void 0)
    return null;
  let s = r, i = this.trees[t], o = i.prefix.length;
  for (let a = 0; a <= s.length; a++) {
    if (s.charCodeAt(a) === 58 && s.charCodeAt(a + 1) === 58) {
      a++;
      continue;
    }
    const c = s.charCodeAt(a) === 58 && s.charCodeAt(a + 1) !== 58, f = s.charCodeAt(a) === 42;
    if (c || f || a === s.length && a !== o) {
      let l = s.slice(o, a);
      if (this.caseSensitive || (l = l.toLowerCase()), l = l.replaceAll("::", ":"), l = l.replaceAll("%", "%25"), i = i.getStaticChild(l), i === null)
        return null;
    }
    if (c) {
      let l = !1, d = !0, g = "";
      const p = [];
      let u = a + 1;
      for (let h = u; ; h++) {
        const b = s.charCodeAt(h), m = b === 40, v = b === 45 || b === 46, y = b === 47 || h === s.length;
        if (m || v || y) {
          if (s.slice(u, h), l = l || m || v, m) {
            const E = X_(s, h), O = s.slice(h, E + 1);
            this.allowUnsafeRegex || Ye(us(new RegExp(O)), `The regex '${O}' is not safe!`), p.push(Y_(O)), h = E + 1, d = !1;
          } else
            p.push(d ? "(.*?)" : `(${g}|(?:(?!${g}).)*)`), d = !1;
          const _ = h;
          for (; h < s.length; h++) {
            const E = s.charCodeAt(h);
            if (E === 47) break;
            if (E === 58)
              if (s.charCodeAt(h + 1) === 58) h++;
              else break;
          }
          let R = s.slice(_, h);
          if (R && (R = R.replaceAll("::", ":"), R = R.replaceAll("%", "%25"), p.push(g = J_(R))), u = h + 1, y || s.charCodeAt(h) === 47 || h === s.length) {
            const E = l ? "()" + R : R, O = s.slice(a, h);
            s = s.slice(0, a + 1) + E + s.slice(h), a += E.length;
            const z = l ? new RegExp("^" + p.join("") + "$") : null;
            if (i = i.getParametricChild(z, R || null, O), i === null)
              return null;
            o = a + 1;
            break;
          }
        }
      }
    } else if (f && (i = i.getWildcardChild(), o = a + 1, a !== s.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (s = s.toLowerCase());
  for (const a of this.routes) {
    const c = a.opts.constraints || {};
    if (a.method === t && a.pattern === s && Gd(c, n))
      return {
        handler: a.handler,
        store: a.store,
        params: a.params
      };
  }
  return null;
};
qe.prototype.hasConstraintStrategy = function(e) {
  return this.constrainer.hasConstraintStrategy(e);
};
qe.prototype.addConstraintStrategy = function(e) {
  this.constrainer.addConstraintStrategy(e), this._rebuild(this.routes);
};
qe.prototype.reset = function() {
  this.trees = {}, this.routes = [];
};
qe.prototype.off = function(t, r, n) {
  Ye(typeof r == "string", "Path should be a string"), Ye(r.length > 0, "The path could not be empty"), Ye(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), Ye(
    typeof n > "u" || typeof n == "object" && !Array.isArray(n) && n !== null,
    "Constraints should be an object or undefined."
  );
  const s = r.match(cn);
  if (s) {
    Ye(r.length === s.index + s[0].length, "Optional Parameter needs to be the last parameter of the path");
    const o = r.replace(cn, "$1$2"), a = r.replace(cn, "$2");
    this.off(t, o, n), this.off(t, a, n);
    return;
  }
  this.ignoreDuplicateSlashes && (r = Wd(r)), this.ignoreTrailingSlash && (r = Kd(r));
  const i = Array.isArray(t) ? t : [t];
  for (const o of i)
    this._off(o, r, n);
};
qe.prototype._off = function(t, r, n) {
  Ye(typeof t == "string", "Method should be a string"), Ye(Bn.includes(t), `Method '${t}' is not an http method.`);
  function s(c) {
    return t !== c.method || r !== c.path;
  }
  function i(c) {
    return s(c) || !Gd(n, c.opts.constraints || {});
  }
  const o = n ? i : s, a = this.routes.filter(o);
  this._rebuild(a);
};
qe.prototype.lookup = function(t, r, n, s) {
  if (typeof n == "function" && (s = n, n = void 0), s === void 0) {
    const i = this.constrainer.deriveConstraints(t, n), o = this.find(t.method, t.url, i);
    return this.callHandler(o, t, r, n);
  }
  this.constrainer.deriveConstraints(t, n, (i, o) => {
    if (i !== null) {
      s(i);
      return;
    }
    try {
      const a = this.find(t.method, t.url, o), c = this.callHandler(a, t, r, n);
      s(null, c);
    } catch (a) {
      s(a);
    }
  });
};
qe.prototype.callHandler = function(t, r, n, s) {
  return t === null ? this._defaultRoute(r, n, s) : s === void 0 ? t.handler(r, n, t.params, t.store, t.searchParams) : t.handler.call(s, r, n, t.params, t.store, t.searchParams);
};
qe.prototype.find = function(t, r, n) {
  let s = this.trees[t];
  if (s === void 0) return null;
  r.charCodeAt(0) !== 47 && (r = r.replace(V_, "/")), this.ignoreDuplicateSlashes && (r = Wd(r));
  let i, o, a;
  try {
    i = hF(r, this.useSemicolonDelimiter), r = i.path, o = i.querystring, a = i.shouldDecodeParam;
  } catch {
    return this._onBadUrl(r);
  }
  this.ignoreTrailingSlash && (r = Kd(r));
  const c = r;
  this.caseSensitive === !1 && (r = r.toLowerCase());
  const f = this.maxParamLength;
  let l = s.prefix.length;
  const d = [], g = r.length, p = [];
  for (; ; ) {
    if (l === g && s.isLeafNode) {
      const m = s.handlerStorage.getMatchingHandler(n);
      if (m !== null)
        return {
          handler: m.handler,
          store: m.store,
          params: m._createParamsObject(d),
          searchParams: this.querystringParser(o)
        };
    }
    let u = s.getNextNode(r, l, p, d.length);
    if (u === null) {
      if (p.length === 0)
        return null;
      const m = p.pop();
      l = m.brotherPathIndex, d.splice(m.paramsCount), u = m.brotherNode;
    }
    if (s = u, s.kind === gy.STATIC) {
      l += s.prefix.length;
      continue;
    }
    if (s.kind === gy.WILDCARD) {
      let m = c.slice(l);
      a && (m = vy(m)), d.push(m), l = g;
      continue;
    }
    let h = c.indexOf("/", l);
    h === -1 && (h = g);
    let b = c.slice(l, h);
    if (a && (b = vy(b)), s.isRegex) {
      const m = s.regex.exec(b);
      if (m === null) continue;
      for (let v = 1; v < m.length; v++) {
        const y = m[v];
        if (y.length > f)
          return null;
        d.push(y);
      }
    } else {
      if (b.length > f)
        return null;
      d.push(b);
    }
    l = h;
  }
};
qe.prototype._rebuild = function(e) {
  this.reset();
  for (const t of e) {
    const { method: r, path: n, opts: s, handler: i, store: o } = t;
    this._on(r, n, s, i, o);
  }
};
qe.prototype._defaultRoute = function(e, t, r) {
  if (this.defaultRoute !== null)
    return r === void 0 ? this.defaultRoute(e, t) : this.defaultRoute.call(r, e, t);
  t.statusCode = 404, t.end();
};
qe.prototype._onBadUrl = function(e) {
  if (this.onBadUrl === null)
    return null;
  const t = this.onBadUrl;
  return {
    handler: (r, n, s) => t(e, r, n),
    params: {},
    store: null
  };
};
qe.prototype.prettyPrint = function(e = {}) {
  const t = e.method;
  e.buildPrettyMeta = this.buildPrettyMeta.bind(this);
  let r = null;
  if (t === void 0) {
    const { version: n, host: s, ...i } = this.constrainer.strategies;
    i[cl.name] = cl;
    const o = new qe({ ...this._opts, constraints: i }), a = this.routes.map((c) => {
      const f = {
        ...c.opts.constraints,
        [cl.name]: c.method
      };
      return { ...c, method: "MERGED", opts: { constraints: f } };
    });
    o._rebuild(a), r = o.trees.MERGED;
  } else
    r = this.trees[t];
  return r == null ? "(empty tree)" : dF(r, e);
};
for (const e in Bn) {
  if (!Bn.hasOwnProperty(e)) continue;
  const t = Bn[e], r = t.toLowerCase();
  qe.prototype[r] = function(n, s, i) {
    return this.on(t, n, s, i);
  };
}
qe.prototype.all = function(e, t, r) {
  this.on(Bn, e, t, r);
};
var K_ = qe;
function J_(e) {
  return e.replace(G_, "\\$&");
}
function Wd(e) {
  return e.indexOf("//") !== -1 ? e.replace(W_, "/") : e;
}
function Kd(e) {
  return e.length > 1 && e.charCodeAt(e.length - 1) === 47 ? e.slice(0, -1) : e;
}
function Y_(e) {
  return e.charCodeAt(1) === 94 && (e = e.slice(0, 1) + e.slice(2)), e.charCodeAt(e.length - 2) === 36 && (e = e.slice(0, e.length - 2) + e.slice(e.length - 1)), e;
}
function X_(e, t) {
  let r = 1;
  for (; t < e.length; ) {
    if (t++, e.charCodeAt(t) === 92) {
      t++;
      continue;
    }
    if (e.charCodeAt(t) === 41 ? r-- : e.charCodeAt(t) === 40 && r++, !r) return t;
  }
  throw new TypeError('Invalid regexp expression in "' + e + '"');
}
function mF(e) {
  return e ? e.store ? Object.assign({}, e.store) : {} : {};
}
function ll(e, t, r, n) {
  if (r === void 0) {
    t.header("content-length", "0"), n(null, null);
    return;
  }
  if (typeof r.resume == "function") {
    r.on("error", (i) => {
      t.log.error({ err: i }, "Error on Stream found for HEAD route");
    }), r.resume(), n(null, null);
    return;
  }
  const s = "" + Buffer.byteLength(r);
  t.header("content-length", s), n(null, null);
}
function yF(e) {
  return e == null ? ll : Array.isArray(e) ? [...e, ll] : [e, ll];
}
var gF = {
  parseHeadOnSendHandlers: yF
};
const vF = K_, bF = pf, by = Kv, { onRequestAbortHookRunner: _F, lifecycleHooks: _y, preParsingHookRunner: EF, onTimeoutHookRunner: xF, onRequestHookRunner: SF } = bn, { normalizeSchema: wF } = ua, { parseHeadOnSendHandlers: RF } = gF, {
  compileSchemasForValidation: $F,
  compileSchemasForSerialization: TF
} = Gv, {
  FST_ERR_SCH_VALIDATION_BUILD: OF,
  FST_ERR_SCH_SERIALIZATION_BUILD: PF,
  FST_ERR_DUPLICATED_ROUTE: CF,
  FST_ERR_INVALID_URL: IF,
  FST_ERR_HOOK_INVALID_HANDLER: Ey,
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: NF,
  FST_ERR_ROUTE_DUPLICATED_HANDLER: AF,
  FST_ERR_ROUTE_HANDLER_NOT_FN: xy,
  FST_ERR_ROUTE_MISSING_HANDLER: kF,
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: LF,
  FST_ERR_ROUTE_METHOD_INVALID: jF,
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: DF,
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: FF,
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: ul
} = bt, {
  kRoutePrefix: MF,
  kSupportedHTTPMethods: Tu,
  kLogLevel: zF,
  kLogSerializers: Sy,
  kHooks: wy,
  kSchemaController: UF,
  kOptions: Ry,
  kReplySerializerDefault: fl,
  kReplyIsError: qF,
  kRequestPayloadStream: HF,
  kDisableRequestLogging: BF,
  kSchemaErrorFormatter: VF,
  kErrorHandler: $y,
  kHasBeenDecorated: Ty,
  kRequestAcceptVersion: dl,
  kRouteByFastify: GF,
  kRouteContext: Oy
} = pt, { buildErrorHandler: WF } = fa, { createChildLogger: KF } = ca, { getGenReqId: JF } = Hd;
function YF(e) {
  const t = vF(e.config);
  let r, n, s, i, o, a, c, f, l, d, g, p, u = !1;
  return {
    /**
     * @param {import('../fastify').FastifyServerOptions} options
     * @param {*} fastifyArgs
     */
    setup(O, z) {
      r = z.avvio, n = z.fourOhFour, s = z.logger, i = z.hasLogger, o = z.setupResponseListeners, a = z.throwIfAlreadyStarted, g = O.exposeHeadRoutes, c = O.disableRequestLogging, f = O.ignoreTrailingSlash, l = O.ignoreDuplicateSlashes, d = Object.hasOwn(O, "return503OnClosing") ? O.return503OnClosing : !0, p = z.keepAliveConnections;
    },
    routing: t.lookup.bind(t),
    // router func to find the right handler to call
    route: R,
    // configure a route in the fastify instance
    hasRoute: y,
    prepareRoute: v,
    routeHandler: E,
    closeRoutes: () => {
      u = !0;
    },
    printRoutes: t.prettyPrint.bind(t),
    addConstraintStrategy: h,
    hasConstraintStrategy: b,
    isAsyncConstraint: m,
    findRoute: _
  };
  function h(O) {
    return a("Cannot add constraint strategy!"), t.addConstraintStrategy(O);
  }
  function b(O) {
    return t.hasConstraintStrategy(O);
  }
  function m() {
    return t.constrainer.asyncStrategiesInUse.size > 0;
  }
  function v({ method: O, url: z, options: x, handler: L, isFastify: M }) {
    if (typeof z != "string")
      throw new IF(typeof z);
    if (!L && typeof x == "function")
      L = x, x = {};
    else if (L && typeof L == "function") {
      if (Object.prototype.toString.call(x) !== "[object Object]")
        throw new NF(O, z);
      if (x.handler)
        throw typeof x.handler == "function" ? new AF(O, z) : new xy(O, z);
    }
    return x = Object.assign({}, x, {
      method: O,
      url: z,
      path: z,
      handler: L || x && x.handler
    }), R.call(this, { options: x, isFastify: M });
  }
  function y({ options: O }) {
    var x;
    const z = ((x = O.method) == null ? void 0 : x.toUpperCase()) ?? "";
    return t.hasRoute(
      z,
      O.url || "",
      O.constraints
    );
  }
  function _(O) {
    const z = t.find(
      O.method,
      O.url || "",
      O.constraints
    );
    return z ? {
      handler: z.handler,
      params: z.params,
      searchParams: z.searchParams
    } : null;
  }
  function R({ options: O, isFastify: z }) {
    a("Cannot add route!");
    const x = { ...O }, L = x.url || x.path || "";
    if (!x.handler)
      throw new kF(x.method, L);
    if (x.errorHandler !== void 0 && typeof x.errorHandler != "function")
      throw new xy(x.method, L);
    Z_(x.bodyLimit);
    const M = x.exposeHeadRoute ?? g;
    let U = !1, $ = !1;
    if (Array.isArray(x.method))
      for (let j = 0; j < x.method.length; ++j)
        x.method[j] = Py.call(this, x.method[j]), Cy.call(this, x.method[j], L, x.schema), U = x.method.includes("GET"), $ = x.method.includes("HEAD");
    else
      x.method = Py.call(this, x.method), Cy.call(this, x.method, L, x.schema), U = x.method === "GET", $ = x.method === "HEAD";
    const S = M && U ? { ...O } : null, I = this[MF];
    if (L === "/" && I.length > 0 && x.method !== "HEAD")
      switch (x.prefixTrailingSlash) {
        case "slash":
          T.call(this, { path: L, isFastify: z });
          break;
        case "no-slash":
          T.call(this, { path: "", isFastify: z });
          break;
        case "both":
        default:
          T.call(this, { path: "", isFastify: z }), f !== !0 && (l !== !0 || !I.endsWith("/")) && T.call(this, { path: L, prefixing: !0, isFastify: z });
      }
    else L[0] === "/" && I.endsWith("/") ? T.call(this, { path: L.slice(1), isFastify: z }) : T.call(this, { path: L, isFastify: z });
    return this;
    function T({ path: j, prefixing: P = !1, isFastify: A = !1 }) {
      const k = I + j;
      if (x.url = k, x.path = k, x.routePath = j, x.prefix = I, x.logLevel = x.logLevel || this[zF], (this[Sy] || x.logSerializers) && (x.logSerializers = Object.assign(Object.create(this[Sy]), x.logSerializers)), x.attachValidation == null && (x.attachValidation = !1), P === !1)
        for (const q of this[wy].onRoute)
          q.call(this, x);
      for (const q of _y)
        if (x && q in x) {
          if (Array.isArray(x[q]))
            for (const K of x[q]) {
              if (typeof K != "function")
                throw new Ey(q, Object.prototype.toString.call(K));
              if (q === "onSend" || q === "preSerialization" || q === "onError" || q === "preParsing") {
                if (K.constructor.name === "AsyncFunction" && K.length === 4)
                  throw new ul();
              } else if (q === "onRequestAbort") {
                if (K.constructor.name === "AsyncFunction" && K.length !== 1)
                  throw new ul();
              } else if (K.constructor.name === "AsyncFunction" && K.length === 3)
                throw new ul();
            }
          else if (x[q] !== void 0 && typeof x[q] != "function")
            throw new Ey(q, Object.prototype.toString.call(x[q]));
        }
      const C = x.constraints || {}, D = {
        ...x.config,
        url: k,
        method: x.method
      }, F = new bF({
        schema: x.schema,
        handler: x.handler.bind(this),
        config: D,
        errorHandler: x.errorHandler,
        childLoggerFactory: x.childLoggerFactory,
        bodyLimit: x.bodyLimit,
        logLevel: x.logLevel,
        logSerializers: x.logSerializers,
        attachValidation: x.attachValidation,
        schemaErrorFormatter: x.schemaErrorFormatter,
        replySerializer: this[fl],
        validatorCompiler: x.validatorCompiler,
        serializerCompiler: x.serializerCompiler,
        exposeHeadRoute: M,
        prefixTrailingSlash: x.prefixTrailingSlash || "both",
        server: this,
        isFastify: A
      }), N = t.findRoute("HEAD", x.url, C) !== null;
      try {
        t.on(x.method, x.url, { constraints: C }, E, F);
      } catch (q) {
        if (!F[GF])
          throw q.message.includes(`Method '${x.method}' already declared for route`) ? new CF(x.method, x.url) : q;
      }
      if (this.after((q, K) => {
        F.errorHandler = x.errorHandler ? WF(this[$y], x.errorHandler) : this[$y], F._parserOptions.limit = x.bodyLimit || null, F.logLevel = x.logLevel, F.logSerializers = x.logSerializers, F.attachValidation = x.attachValidation, F[fl] = this[fl], F.schemaErrorFormatter = x.schemaErrorFormatter || this[VF] || F.schemaErrorFormatter, r.once("preReady", () => {
          for (const V of _y) {
            const Z = this[wy][V].concat(x[V] || []).map((Y) => Y.bind(this));
            F[V] = Z.length ? Z : null;
          }
          for (; !F.Request[Ty] && F.Request.parent; )
            F.Request = F.Request.parent;
          for (; !F.Reply[Ty] && F.Reply.parent; )
            F.Reply = F.Reply.parent;
          if (n.setContext(this, F), x.schema) {
            F.schema = wF(F.schema, this.initialConfig);
            const V = this[UF];
            !x.validatorCompiler && (x.schema.body || x.schema.headers || x.schema.querystring || x.schema.params) && V.setupValidator(this[Ry]);
            try {
              const Z = typeof (x == null ? void 0 : x.validatorCompiler) == "function" || V.isCustomValidatorCompiler;
              $F(F, x.validatorCompiler || V.validatorCompiler, Z);
            } catch (Z) {
              throw new OF(x.method, k, Z.message);
            }
            x.schema.response && !x.serializerCompiler && V.setupSerializer(this[Ry]);
            try {
              TF(F, x.serializerCompiler || V.serializerCompiler);
            } catch (Z) {
              throw new PF(x.method, k, Z.message);
            }
          }
        }), K(q);
      }), M && U && !$ && !N) {
        const q = RF(S.onSend);
        v.call(this, { method: "HEAD", url: j, options: { ...S, onSend: q }, isFastify: !0 });
      }
    }
  }
  function E(O, z, x, L, M) {
    const U = JF(L.server, O), $ = {
      level: L.logLevel
    };
    L.logSerializers && ($.serializers = L.logSerializers);
    const S = KF(L, s, O, U, $);
    if (S[BF] = c, u === !0 && (O.httpVersionMajor !== 2 && z.setHeader("Connection", "close"), d)) {
      const P = {
        "Content-Type": "application/json",
        "Content-Length": "80"
      };
      z.writeHead(503, P), z.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}'), S.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
      return;
    }
    String.prototype.toLowerCase.call(O.headers.connection || "") === "keep-alive" && p.has(O.socket) === !1 && (p.add(O.socket), O.socket.on("close", QF.bind({ keepAliveConnections: p, socket: O.socket }))), O.headers[dl] !== void 0 && (O.headers["accept-version"] = O.headers[dl], O.headers[dl] = void 0);
    const T = new L.Request(U, x, O, M, S, L), j = new L.Reply(z, T, S);
    c === !1 && S.info({ req: T }, "incoming request"), (i === !0 || L.onResponse !== null) && o(j), L.onRequest !== null ? SF(
      L.onRequest,
      T,
      j,
      Iy
    ) : Iy(null, T, j), L.onRequestAbort !== null && O.on("close", () => {
      O.aborted && _F(
        L.onRequestAbort,
        T,
        XF.bind(null, j)
      );
    }), L.onTimeout !== null && (T.raw.socket._meta || T.raw.socket.on("timeout", ZF), T.raw.socket._meta = { context: L, request: T, reply: j });
  }
}
function XF(e, t) {
  t && e.log.error({ err: t }, "onRequestAborted hook failed");
}
function ZF() {
  const { context: e, request: t, reply: r } = this._meta;
  xF(
    e.onTimeout,
    t,
    r,
    e2
  );
}
function Py(e) {
  if (typeof e != "string")
    throw new jF();
  if (e = e.toUpperCase(), !this[Tu].bodyless.has(e) && !this[Tu].bodywith.has(e))
    throw new LF(e);
  return e;
}
function Cy(e, t, r) {
  if (this[Tu].bodyless.has(e) && (r != null && r.body))
    throw new DF(e, t);
}
function Z_(e) {
  if (e !== void 0 && (!Number.isInteger(e) || e <= 0))
    throw new FF(e);
}
function Iy(e, t, r) {
  if (r.sent !== !0) {
    if (e != null) {
      r[qF] = !0, r.send(e);
      return;
    }
    t[HF] = t.raw, t[Oy].preParsing !== null ? EF(t[Oy].preParsing, t, r, by.bind(t.server)) : by.call(t.server, null, t, r);
  }
}
function QF() {
  this.keepAliveConnections.delete(this.socket);
}
function e2() {
}
var t2 = { buildRouting: YF, validateBodyLimitOption: Z_ };
const r2 = K_, Ny = af, Ay = df, n2 = pf, {
  kRoutePrefix: s2,
  kCanSetNotFoundHandler: _s,
  kFourOhFourLevelInstance: Es,
  kFourOhFourContext: sr,
  kHooks: i2,
  kErrorHandler: ky
} = pt, { lifecycleHooks: o2 } = bn, { buildErrorHandler: a2 } = fa, {
  FST_ERR_NOT_FOUND: c2
} = bt, { createChildLogger: Ly } = ca, { getGenReqId: jy } = Hd;
function l2(e) {
  const { logger: t, disableRequestLogging: r } = e, n = r2({ onBadUrl: a(), defaultRoute: d });
  let s = null;
  return { router: n, setNotFoundHandler: f, setContext: c, arrange404: i };
  function i(g) {
    g[Es] = g, g[_s] = !0, n.onBadUrl = n.onBadUrl.bind(g), n.defaultRoute = n.defaultRoute.bind(g);
  }
  function o(g, p) {
    const { url: u, method: h } = g.raw, b = `Route ${h}:${u} not found`;
    r || g.log.info(b), p.code(404).send({
      message: b,
      error: "Not Found",
      statusCode: 404
    });
  }
  function a() {
    return function(p, u, h) {
      const b = this[Es][sr], m = jy(b.server, u), v = Ly(b, t, u, m), y = new Ay(m, null, u, null, v, b), _ = new Ny(h, y, v);
      s(y, _);
    };
  }
  function c(g, p) {
    const u = Object.assign({}, g[sr]);
    u.onSend = p.onSend, p[sr] = u;
  }
  function f(g, p, u, h) {
    this[_s] === void 0 && (this[_s] = !0), this[sr] === void 0 && (this[sr] = null);
    const b = this, m = this[s2] || "/";
    if (this[_s] === !1)
      throw new Error(`Not found handler already set for Fastify instance with prefix: '${m}'`);
    typeof g == "object" && (g.preHandler && (Array.isArray(g.preHandler) ? g.preHandler = g.preHandler.map((v) => v.bind(b)) : g.preHandler = g.preHandler.bind(b)), g.preValidation && (Array.isArray(g.preValidation) ? g.preValidation = g.preValidation.map((v) => v.bind(b)) : g.preValidation = g.preValidation.bind(b))), typeof g == "function" && (p = g, g = void 0), g = g || {}, p ? (this[Es][_s] = !1, p = p.bind(this), s = p) : (p = o, s = o), this.after((v, y) => {
      l.call(this, m, g, p, u, h), y(v);
    });
  }
  function l(g, p, u, h, b) {
    const m = new n2({
      schema: p.schema,
      handler: u,
      config: p.config || {},
      server: this
    });
    if (h.once("preReady", () => {
      const v = this[sr];
      for (const y of o2) {
        const _ = this[i2][y].concat(p[y] || []).map((R) => R.bind(this));
        v[y] = _.length ? _ : null;
      }
      v.errorHandler = p.errorHandler ? a2(this[ky], p.errorHandler) : this[ky];
    }), this[sr] !== null && g === "/") {
      Object.assign(this[sr], m);
      return;
    }
    this[Es][sr] = m, n.all(g + (g.endsWith("/") ? "*" : "/*"), b, m), n.all(g, b, m);
  }
  function d(g, p) {
    const u = this[Es][sr], h = jy(u.server, g), b = Ly(u, t, g, h);
    b.info({ req: g }, "incoming request");
    const m = new Ay(h, null, g, null, b, u), v = new Ny(p, m, b);
    m.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it"), m.log.warn(n.prettyPrint()), v.code(404).send(new c2());
  }
}
var u2 = l2, Da = { exports: {} }, Fa = { exports: {} };
Fa.exports = $e;
Fa.exports.default = $e;
const f2 = { properties: { connectionTimeout: { type: "integer", default: 0 }, keepAliveTimeout: { type: "integer", default: 72e3 }, forceCloseConnections: { oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }] }, maxRequestsPerSocket: { type: "integer", default: 0, nullable: !0 }, requestTimeout: { type: "integer", default: 0 }, bodyLimit: { type: "integer", default: 1048576 }, caseSensitive: { type: "boolean", default: !0 }, allowUnsafeRegex: { type: "boolean", default: !1 }, http2: { type: "boolean" }, https: { if: { not: { oneOf: [{ type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: !1, required: ["allowHTTP1"], properties: { allowHTTP1: { type: "boolean" } } }] } }, then: { setDefaultValue: !0 } }, ignoreTrailingSlash: { type: "boolean", default: !1 }, ignoreDuplicateSlashes: { type: "boolean", default: !1 }, disableRequestLogging: { type: "boolean", default: !1 }, maxParamLength: { type: "integer", default: 100 }, onProtoPoisoning: { type: "string", default: "error" }, onConstructorPoisoning: { type: "string", default: "error" }, pluginTimeout: { type: "integer", default: 1e4 }, requestIdHeader: { anyOf: [{ type: "boolean" }, { type: "string" }], default: !1 }, requestIdLogLabel: { type: "string", default: "reqId" }, http2SessionTimeout: { type: "integer", default: 72e3 }, exposeHeadRoutes: { type: "boolean", default: !0 }, useSemicolonDelimiter: { type: "boolean", default: !1 }, constraints: { type: "object", additionalProperties: { type: "object", required: ["name", "storage", "validate", "deriveConstraint"], additionalProperties: !0, properties: { name: { type: "string" }, storage: {}, validate: {}, deriveConstraint: {} } } } } }, d2 = Object.prototype.hasOwnProperty, p2 = new RegExp("idle", "u");
function $e(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  if (o === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      e.connectionTimeout === void 0 && (e.connectionTimeout = 0), e.keepAliveTimeout === void 0 && (e.keepAliveTimeout = 72e3), e.maxRequestsPerSocket === void 0 && (e.maxRequestsPerSocket = 0), e.requestTimeout === void 0 && (e.requestTimeout = 0), e.bodyLimit === void 0 && (e.bodyLimit = 1048576), e.caseSensitive === void 0 && (e.caseSensitive = !0), e.allowUnsafeRegex === void 0 && (e.allowUnsafeRegex = !1), e.ignoreTrailingSlash === void 0 && (e.ignoreTrailingSlash = !1), e.ignoreDuplicateSlashes === void 0 && (e.ignoreDuplicateSlashes = !1), e.disableRequestLogging === void 0 && (e.disableRequestLogging = !1), e.maxParamLength === void 0 && (e.maxParamLength = 100), e.onProtoPoisoning === void 0 && (e.onProtoPoisoning = "error"), e.onConstructorPoisoning === void 0 && (e.onConstructorPoisoning = "error"), e.pluginTimeout === void 0 && (e.pluginTimeout = 1e4), e.requestIdHeader === void 0 && (e.requestIdHeader = !1), e.requestIdLogLabel === void 0 && (e.requestIdLogLabel = "reqId"), e.http2SessionTimeout === void 0 && (e.http2SessionTimeout = 72e3), e.exposeHeadRoutes === void 0 && (e.exposeHeadRoutes = !0), e.useSemicolonDelimiter === void 0 && (e.useSemicolonDelimiter = !1);
      const u = o;
      for (const h in e)
        d2.call(f2.properties, h) || delete e[h];
      if (u === o) {
        let h = e.connectionTimeout;
        const b = o;
        if (!(typeof h == "number" && !(h % 1) && !isNaN(h) && isFinite(h))) {
          let m = typeof h, v;
          if (v === void 0)
            if (m === "boolean" || h === null || m === "string" && h && h == +h && !(h % 1))
              v = +h;
            else
              return $e.errors = [{ instancePath: t + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
          v !== void 0 && (h = v, e !== void 0 && (e.connectionTimeout = v));
        }
        var a = b === o;
        if (a) {
          let m = e.keepAliveTimeout;
          const v = o;
          if (!(typeof m == "number" && !(m % 1) && !isNaN(m) && isFinite(m))) {
            let _ = typeof m, R;
            if (R === void 0)
              if (_ === "boolean" || m === null || _ === "string" && m && m == +m && !(m % 1))
                R = +m;
              else
                return $e.errors = [{ instancePath: t + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
            R !== void 0 && (m = R, e !== void 0 && (e.keepAliveTimeout = R));
          }
          var a = v === o;
          if (a) {
            if (e.forceCloseConnections !== void 0) {
              let _ = e.forceCloseConnections;
              const R = o, E = o;
              let O = !1, z = null;
              const x = o;
              if (typeof _ != "string") {
                let U = typeof _, $;
                if ($ === void 0)
                  if (U == "number" || U == "boolean")
                    $ = "" + _;
                  else if (_ === null)
                    $ = "";
                  else {
                    const S = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    i === null ? i = [S] : i.push(S), o++;
                  }
                $ !== void 0 && (_ = $, e !== void 0 && (e.forceCloseConnections = $));
              }
              if (o === x && typeof _ == "string" && !p2.test(_)) {
                const U = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                i === null ? i = [U] : i.push(U), o++;
              }
              var c = x === o;
              c && (O = !0, z = 0);
              const L = o;
              if (typeof _ != "boolean") {
                let U;
                if (U === void 0)
                  if (_ === "false" || _ === 0 || _ === null)
                    U = !1;
                  else if (_ === "true" || _ === 1)
                    U = !0;
                  else {
                    const $ = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    i === null ? i = [$] : i.push($), o++;
                  }
                U !== void 0 && (_ = U, e !== void 0 && (e.forceCloseConnections = U));
              }
              var c = L === o;
              if (c && O ? (O = !1, z = [z, 1]) : c && (O = !0, z = 1), O)
                o = E, i !== null && (E ? i.length = E : i = null);
              else {
                const U = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: z }, message: "must match exactly one schema in oneOf" };
                return i === null ? i = [U] : i.push(U), o++, $e.errors = i, !1;
              }
              var a = R === o;
            } else
              var a = !0;
            if (a) {
              let _ = e.maxRequestsPerSocket;
              const R = o;
              if (!(typeof _ == "number" && !(_ % 1) && !isNaN(_) && isFinite(_)) && _ !== null) {
                let O = typeof _, z;
                if (z === void 0)
                  if (O === "boolean" || _ === null || O === "string" && _ && _ == +_ && !(_ % 1))
                    z = +_;
                  else if (_ === "" || _ === 0 || _ === !1)
                    z = null;
                  else
                    return $e.errors = [{ instancePath: t + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                z !== void 0 && (_ = z, e !== void 0 && (e.maxRequestsPerSocket = z));
              }
              var a = R === o;
              if (a) {
                let O = e.requestTimeout;
                const z = o;
                if (!(typeof O == "number" && !(O % 1) && !isNaN(O) && isFinite(O))) {
                  let L = typeof O, M;
                  if (M === void 0)
                    if (L === "boolean" || O === null || L === "string" && O && O == +O && !(O % 1))
                      M = +O;
                    else
                      return $e.errors = [{ instancePath: t + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                  M !== void 0 && (O = M, e !== void 0 && (e.requestTimeout = M));
                }
                var a = z === o;
                if (a) {
                  let L = e.bodyLimit;
                  const M = o;
                  if (!(typeof L == "number" && !(L % 1) && !isNaN(L) && isFinite(L))) {
                    let $ = typeof L, S;
                    if (S === void 0)
                      if ($ === "boolean" || L === null || $ === "string" && L && L == +L && !(L % 1))
                        S = +L;
                      else
                        return $e.errors = [{ instancePath: t + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                    S !== void 0 && (L = S, e !== void 0 && (e.bodyLimit = S));
                  }
                  var a = M === o;
                  if (a) {
                    let $ = e.caseSensitive;
                    const S = o;
                    if (typeof $ != "boolean") {
                      let T;
                      if (T === void 0)
                        if ($ === "false" || $ === 0 || $ === null)
                          T = !1;
                        else if ($ === "true" || $ === 1)
                          T = !0;
                        else
                          return $e.errors = [{ instancePath: t + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                      T !== void 0 && ($ = T, e !== void 0 && (e.caseSensitive = T));
                    }
                    var a = S === o;
                    if (a) {
                      let T = e.allowUnsafeRegex;
                      const j = o;
                      if (typeof T != "boolean") {
                        let A;
                        if (A === void 0)
                          if (T === "false" || T === 0 || T === null)
                            A = !1;
                          else if (T === "true" || T === 1)
                            A = !0;
                          else
                            return $e.errors = [{ instancePath: t + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                        A !== void 0 && (T = A, e !== void 0 && (e.allowUnsafeRegex = A));
                      }
                      var a = j === o;
                      if (a) {
                        if (e.http2 !== void 0) {
                          let A = e.http2;
                          const k = o;
                          if (typeof A != "boolean") {
                            let D;
                            if (D === void 0)
                              if (A === "false" || A === 0 || A === null)
                                D = !1;
                              else if (A === "true" || A === 1)
                                D = !0;
                              else
                                return $e.errors = [{ instancePath: t + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            D !== void 0 && (A = D, e !== void 0 && (e.http2 = D));
                          }
                          var a = k === o;
                        } else
                          var a = !0;
                        if (a) {
                          if (e.https !== void 0) {
                            let A = e.https;
                            const k = o, C = o;
                            let D = !0;
                            const F = o, w = o, N = o, q = o;
                            let K = !1;
                            const V = o;
                            if (typeof A != "boolean") {
                              let J;
                              if (J === void 0)
                                if (A === "false" || A === 0 || A === null)
                                  J = !1;
                                else if (A === "true" || A === 1)
                                  J = !0;
                                else {
                                  const H = {};
                                  i === null ? i = [H] : i.push(H), o++;
                                }
                              J !== void 0 && (A = J, e !== void 0 && (e.https = J));
                            }
                            var f = V === o;
                            f && (K = !0);
                            const Z = o;
                            if (A !== null) {
                              let J;
                              if (J === void 0)
                                if (A === "" || A === 0 || A === !1)
                                  J = null;
                                else {
                                  const H = {};
                                  i === null ? i = [H] : i.push(H), o++;
                                }
                              J !== void 0 && (A = J, e !== void 0 && (e.https = J));
                            }
                            var f = Z === o;
                            if (f && K)
                              K = !1;
                            else {
                              f && (K = !0);
                              const J = o;
                              if (o === J)
                                if (A && typeof A == "object" && !Array.isArray(A))
                                  if (A.allowHTTP1 === void 0) {
                                    const W = {};
                                    i === null ? i = [W] : i.push(W), o++;
                                  } else {
                                    const W = o;
                                    for (const G in A)
                                      G !== "allowHTTP1" && delete A[G];
                                    if (W === o && A.allowHTTP1 !== void 0) {
                                      let G = A.allowHTTP1;
                                      if (typeof G != "boolean") {
                                        let ee;
                                        if (ee === void 0)
                                          if (G === "false" || G === 0 || G === null)
                                            ee = !1;
                                          else if (G === "true" || G === 1)
                                            ee = !0;
                                          else {
                                            const le = {};
                                            i === null ? i = [le] : i.push(le), o++;
                                          }
                                        ee !== void 0 && (G = ee, A !== void 0 && (A.allowHTTP1 = ee));
                                      }
                                    }
                                  }
                                else {
                                  const W = {};
                                  i === null ? i = [W] : i.push(W), o++;
                                }
                              var f = J === o;
                              f && K ? K = !1 : f && (K = !0);
                            }
                            if (K)
                              o = q, i !== null && (q ? i.length = q : i = null);
                            else {
                              const J = {};
                              i === null ? i = [J] : i.push(J), o++;
                            }
                            var l = N === o;
                            if (l) {
                              const J = {};
                              i === null ? i = [J] : i.push(J), o++;
                            } else
                              o = w, i !== null && (w ? i.length = w : i = null);
                            var d = F === o;
                            if (o = C, i !== null && (C ? i.length = C : i = null), d) {
                              const J = o;
                              e.https = !0;
                              var d = J === o;
                              D = d;
                            }
                            if (!D) {
                              const J = { instancePath: t + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                              return i === null ? i = [J] : i.push(J), o++, $e.errors = i, !1;
                            }
                            var a = k === o;
                          } else
                            var a = !0;
                          if (a) {
                            let A = e.ignoreTrailingSlash;
                            const k = o;
                            if (typeof A != "boolean") {
                              let D;
                              if (D === void 0)
                                if (A === "false" || A === 0 || A === null)
                                  D = !1;
                                else if (A === "true" || A === 1)
                                  D = !0;
                                else
                                  return $e.errors = [{ instancePath: t + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              D !== void 0 && (A = D, e !== void 0 && (e.ignoreTrailingSlash = D));
                            }
                            var a = k === o;
                            if (a) {
                              let D = e.ignoreDuplicateSlashes;
                              const F = o;
                              if (typeof D != "boolean") {
                                let N;
                                if (N === void 0)
                                  if (D === "false" || D === 0 || D === null)
                                    N = !1;
                                  else if (D === "true" || D === 1)
                                    N = !0;
                                  else
                                    return $e.errors = [{ instancePath: t + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                N !== void 0 && (D = N, e !== void 0 && (e.ignoreDuplicateSlashes = N));
                              }
                              var a = F === o;
                              if (a) {
                                let N = e.disableRequestLogging;
                                const q = o;
                                if (typeof N != "boolean") {
                                  let V;
                                  if (V === void 0)
                                    if (N === "false" || N === 0 || N === null)
                                      V = !1;
                                    else if (N === "true" || N === 1)
                                      V = !0;
                                    else
                                      return $e.errors = [{ instancePath: t + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  V !== void 0 && (N = V, e !== void 0 && (e.disableRequestLogging = V));
                                }
                                var a = q === o;
                                if (a) {
                                  let V = e.maxParamLength;
                                  const Z = o;
                                  if (!(typeof V == "number" && !(V % 1) && !isNaN(V) && isFinite(V))) {
                                    let J = typeof V, H;
                                    if (H === void 0)
                                      if (J === "boolean" || V === null || J === "string" && V && V == +V && !(V % 1))
                                        H = +V;
                                      else
                                        return $e.errors = [{ instancePath: t + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                    H !== void 0 && (V = H, e !== void 0 && (e.maxParamLength = H));
                                  }
                                  var a = Z === o;
                                  if (a) {
                                    let J = e.onProtoPoisoning;
                                    const H = o;
                                    if (typeof J != "string") {
                                      let G = typeof J, ee;
                                      if (ee === void 0)
                                        if (G == "number" || G == "boolean")
                                          ee = "" + J;
                                        else if (J === null)
                                          ee = "";
                                        else
                                          return $e.errors = [{ instancePath: t + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                      ee !== void 0 && (J = ee, e !== void 0 && (e.onProtoPoisoning = ee));
                                    }
                                    var a = H === o;
                                    if (a) {
                                      let G = e.onConstructorPoisoning;
                                      const ee = o;
                                      if (typeof G != "string") {
                                        let X = typeof G, ce;
                                        if (ce === void 0)
                                          if (X == "number" || X == "boolean")
                                            ce = "" + G;
                                          else if (G === null)
                                            ce = "";
                                          else
                                            return $e.errors = [{ instancePath: t + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                        ce !== void 0 && (G = ce, e !== void 0 && (e.onConstructorPoisoning = ce));
                                      }
                                      var a = ee === o;
                                      if (a) {
                                        let X = e.pluginTimeout;
                                        const ce = o;
                                        if (!(typeof X == "number" && !(X % 1) && !isNaN(X) && isFinite(X))) {
                                          let pe = typeof X, he;
                                          if (he === void 0)
                                            if (pe === "boolean" || X === null || pe === "string" && X && X == +X && !(X % 1))
                                              he = +X;
                                            else
                                              return $e.errors = [{ instancePath: t + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          he !== void 0 && (X = he, e !== void 0 && (e.pluginTimeout = he));
                                        }
                                        var a = ce === o;
                                        if (a) {
                                          let pe = e.requestIdHeader;
                                          const he = o, Ge = o;
                                          let we = !1;
                                          const _t = o;
                                          if (typeof pe != "boolean") {
                                            let Pe;
                                            if (Pe === void 0)
                                              if (pe === "false" || pe === 0 || pe === null)
                                                Pe = !1;
                                              else if (pe === "true" || pe === 1)
                                                Pe = !0;
                                              else {
                                                const Bt = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                i === null ? i = [Bt] : i.push(Bt), o++;
                                              }
                                            Pe !== void 0 && (pe = Pe, e !== void 0 && (e.requestIdHeader = Pe));
                                          }
                                          var g = _t === o;
                                          if (we = we || g, !we) {
                                            const Pe = o;
                                            if (typeof pe != "string") {
                                              let $r = typeof pe, Te;
                                              if (Te === void 0)
                                                if ($r == "number" || $r == "boolean")
                                                  Te = "" + pe;
                                                else if (pe === null)
                                                  Te = "";
                                                else {
                                                  const it = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                  i === null ? i = [it] : i.push(it), o++;
                                                }
                                              Te !== void 0 && (pe = Te, e !== void 0 && (e.requestIdHeader = Te));
                                            }
                                            var g = Pe === o;
                                            we = we || g;
                                          }
                                          if (we)
                                            o = Ge, i !== null && (Ge ? i.length = Ge : i = null);
                                          else {
                                            const Pe = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            return i === null ? i = [Pe] : i.push(Pe), o++, $e.errors = i, !1;
                                          }
                                          var a = he === o;
                                          if (a) {
                                            let Pe = e.requestIdLogLabel;
                                            const Bt = o;
                                            if (typeof Pe != "string") {
                                              let Te = typeof Pe, it;
                                              if (it === void 0)
                                                if (Te == "number" || Te == "boolean")
                                                  it = "" + Pe;
                                                else if (Pe === null)
                                                  it = "";
                                                else
                                                  return $e.errors = [{ instancePath: t + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                              it !== void 0 && (Pe = it, e !== void 0 && (e.requestIdLogLabel = it));
                                            }
                                            var a = Bt === o;
                                            if (a) {
                                              let Te = e.http2SessionTimeout;
                                              const it = o;
                                              if (!(typeof Te == "number" && !(Te % 1) && !isNaN(Te) && isFinite(Te))) {
                                                let Ot = typeof Te, Vt;
                                                if (Vt === void 0)
                                                  if (Ot === "boolean" || Te === null || Ot === "string" && Te && Te == +Te && !(Te % 1))
                                                    Vt = +Te;
                                                  else
                                                    return $e.errors = [{ instancePath: t + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                Vt !== void 0 && (Te = Vt, e !== void 0 && (e.http2SessionTimeout = Vt));
                                              }
                                              var a = it === o;
                                              if (a) {
                                                let Ot = e.exposeHeadRoutes;
                                                const Vt = o;
                                                if (typeof Ot != "boolean") {
                                                  let Qe;
                                                  if (Qe === void 0)
                                                    if (Ot === "false" || Ot === 0 || Ot === null)
                                                      Qe = !1;
                                                    else if (Ot === "true" || Ot === 1)
                                                      Qe = !0;
                                                    else
                                                      return $e.errors = [{ instancePath: t + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                  Qe !== void 0 && (Ot = Qe, e !== void 0 && (e.exposeHeadRoutes = Qe));
                                                }
                                                var a = Vt === o;
                                                if (a) {
                                                  let Qe = e.useSemicolonDelimiter;
                                                  const Xa = o;
                                                  if (typeof Qe != "boolean") {
                                                    let ht;
                                                    if (ht === void 0)
                                                      if (Qe === "false" || Qe === 0 || Qe === null)
                                                        ht = !1;
                                                      else if (Qe === "true" || Qe === 1)
                                                        ht = !0;
                                                      else
                                                        return $e.errors = [{ instancePath: t + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                    ht !== void 0 && (Qe = ht, e !== void 0 && (e.useSemicolonDelimiter = ht));
                                                  }
                                                  var a = Xa === o;
                                                  if (a)
                                                    if (e.constraints !== void 0) {
                                                      let ht = e.constraints;
                                                      const Ti = o;
                                                      if (o === Ti)
                                                        if (ht && typeof ht == "object" && !Array.isArray(ht))
                                                          for (const Sn in ht) {
                                                            let Pt = ht[Sn];
                                                            const Br = o;
                                                            if (o === Br)
                                                              if (Pt && typeof Pt == "object" && !Array.isArray(Pt)) {
                                                                let tr;
                                                                if (Pt.name === void 0 && (tr = "name") || Pt.storage === void 0 && (tr = "storage") || Pt.validate === void 0 && (tr = "validate") || Pt.deriveConstraint === void 0 && (tr = "deriveConstraint"))
                                                                  return $e.errors = [{ instancePath: t + "/constraints/" + Sn.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: tr }, message: "must have required property '" + tr + "'" }], !1;
                                                                if (Pt.name !== void 0) {
                                                                  let Tr = Pt.name;
                                                                  if (typeof Tr != "string") {
                                                                    let ps = typeof Tr, rr;
                                                                    if (rr === void 0)
                                                                      if (ps == "number" || ps == "boolean")
                                                                        rr = "" + Tr;
                                                                      else if (Tr === null)
                                                                        rr = "";
                                                                      else
                                                                        return $e.errors = [{ instancePath: t + "/constraints/" + Sn.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                    rr !== void 0 && (Tr = rr, Pt !== void 0 && (Pt.name = rr));
                                                                  }
                                                                }
                                                              } else
                                                                return $e.errors = [{ instancePath: t + "/constraints/" + Sn.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var p = Br === o;
                                                            if (!p)
                                                              break;
                                                          }
                                                        else
                                                          return $e.errors = [{ instancePath: t + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                      var a = Ti === o;
                                                    } else
                                                      var a = !0;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
      return $e.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
  return $e.errors = i, o === 0;
}
Fa.exports.defaultInitOptions = { connectionTimeout: 0, keepAliveTimeout: 72e3, maxRequestsPerSocket: 0, requestTimeout: 0, bodyLimit: 1048576, caseSensitive: !0, allowUnsafeRegex: !1, disableRequestLogging: !1, ignoreTrailingSlash: !1, ignoreDuplicateSlashes: !1, maxParamLength: 100, onProtoPoisoning: "error", onConstructorPoisoning: "error", pluginTimeout: 1e4, requestIdHeader: !1, requestIdLogLabel: "reqId", http2SessionTimeout: 72e3, exposeHeadRoutes: !0, useSemicolonDelimiter: !1 };
var h2 = Fa.exports;
const So = h2, m2 = ef({ circles: !0, proto: !1 }), { FST_ERR_INIT_OPTS_INVALID: y2 } = bt;
function g2(e) {
  const t = m2(e);
  if (!So(t)) {
    const r = new y2(JSON.stringify(So.errors.map((n) => n.message)));
    throw r.errors = So.errors, r;
  }
  return Jd(t);
}
function Jd(e) {
  const t = Object.getOwnPropertyNames(e);
  for (const r of t) {
    const n = e[r];
    ArrayBuffer.isView(n) && !(n instanceof DataView) || (e[r] = n && typeof n == "object" ? Jd(n) : n);
  }
  return Object.freeze(e);
}
Da.exports = g2;
Da.exports.defaultInitOptions = So.defaultInitOptions;
Da.exports.utils = { deepFreezeObject: Jd };
var v2 = Da.exports;
const {
  kAvvioBoot: b2,
  kChildren: Dy,
  kRoutePrefix: Fy,
  kLogLevel: My,
  kLogSerializers: pl,
  kHooks: hl,
  kSchemaController: Pn,
  kContentTypeParser: zy,
  kReply: Uy,
  kRequest: qy,
  kFourOhFour: _2,
  kPluginNameChain: Hy
} = pt, E2 = af, x2 = df, S2 = p_, w2 = kb, { buildHooks: R2 } = bn, xs = x_;
var $2 = function(t, r, n) {
  const s = xs.registerPlugin.call(t, r), i = xs.getPluginName(r) || xs.getFuncPreview(r);
  if (s)
    return t[Hy].push(i), t;
  const o = Object.create(t);
  t[Dy].push(o), o.ready = t[b2].bind(o), o[Dy] = [], o[Uy] = E2.buildReply(o[Uy]), o[qy] = x2.buildRequest(o[qy]), o[zy] = w2.helpers.buildContentTypeParser(o[zy]), o[hl] = R2(o[hl]), o[Fy] = T2(o[Fy], n.prefix), o[My] = n.logLevel || o[My], o[Pn] = S2.buildSchemaController(t[Pn]), o.getSchema = o[Pn].getSchema.bind(o[Pn]), o.getSchemas = o[Pn].getSchemas.bind(o[Pn]), o[xs.kRegisteredPlugins] = Object.create(o[xs.kRegisteredPlugins]), o[Hy] = [i], (o[pl] || n.logSerializers) && (o[pl] = Object.assign(Object.create(o[pl]), n.logSerializers)), n.prefix && o[_2].arrange404(o);
  for (const a of o[hl].onRegister) a.call(t, o, n);
  return o;
};
function T2(e, t) {
  return t ? (e.endsWith("/") && t[0] === "/" ? t = t.slice(1) : t[0] !== "/" && (t = "/" + t), e + t) : e;
}
var O2 = function() {
  return {
    [Symbol.iterator]: function* () {
    },
    add() {
    },
    delete() {
    },
    has() {
      return !0;
    }
  };
}, Cn = { exports: {} }, Ss = { exports: {} }, ws = {}, By;
function P2() {
  if (By) return ws;
  By = 1, Object.defineProperty(ws, "__esModule", { value: !0 }), ws.parse = o, ws.serialize = f;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, n = /^[\u0020-\u003A\u003D-\u007E]*$/, s = Object.prototype.toString, i = /* @__PURE__ */ (() => {
    const g = function() {
    };
    return g.prototype = /* @__PURE__ */ Object.create(null), g;
  })();
  function o(g, p) {
    const u = new i(), h = g.length;
    if (h < 2)
      return u;
    const b = (p == null ? void 0 : p.decode) || l;
    let m = 0;
    do {
      const v = g.indexOf("=", m);
      if (v === -1)
        break;
      const y = g.indexOf(";", m), _ = y === -1 ? h : y;
      if (v > _) {
        m = g.lastIndexOf(";", v - 1) + 1;
        continue;
      }
      const R = a(g, m, v), E = c(g, v, R), O = g.slice(R, E);
      if (u[O] === void 0) {
        let z = a(g, v + 1, _), x = c(g, _, z);
        const L = b(g.slice(z, x));
        u[O] = L;
      }
      m = _ + 1;
    } while (m < h);
    return u;
  }
  function a(g, p, u) {
    do {
      const h = g.charCodeAt(p);
      if (h !== 32 && h !== 9)
        return p;
    } while (++p < u);
    return u;
  }
  function c(g, p, u) {
    for (; p > u; ) {
      const h = g.charCodeAt(--p);
      if (h !== 32 && h !== 9)
        return p + 1;
    }
    return u;
  }
  function f(g, p, u) {
    const h = (u == null ? void 0 : u.encode) || encodeURIComponent;
    if (!e.test(g))
      throw new TypeError(`argument name is invalid: ${g}`);
    const b = h(p);
    if (!t.test(b))
      throw new TypeError(`argument val is invalid: ${p}`);
    let m = g + "=" + b;
    if (!u)
      return m;
    if (u.maxAge !== void 0) {
      if (!Number.isInteger(u.maxAge))
        throw new TypeError(`option maxAge is invalid: ${u.maxAge}`);
      m += "; Max-Age=" + u.maxAge;
    }
    if (u.domain) {
      if (!r.test(u.domain))
        throw new TypeError(`option domain is invalid: ${u.domain}`);
      m += "; Domain=" + u.domain;
    }
    if (u.path) {
      if (!n.test(u.path))
        throw new TypeError(`option path is invalid: ${u.path}`);
      m += "; Path=" + u.path;
    }
    if (u.expires) {
      if (!d(u.expires) || !Number.isFinite(u.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${u.expires}`);
      m += "; Expires=" + u.expires.toUTCString();
    }
    if (u.httpOnly && (m += "; HttpOnly"), u.secure && (m += "; Secure"), u.partitioned && (m += "; Partitioned"), u.priority)
      switch (typeof u.priority == "string" ? u.priority.toLowerCase() : void 0) {
        case "low":
          m += "; Priority=Low";
          break;
        case "medium":
          m += "; Priority=Medium";
          break;
        case "high":
          m += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${u.priority}`);
      }
    if (u.sameSite)
      switch (typeof u.sameSite == "string" ? u.sameSite.toLowerCase() : u.sameSite) {
        case !0:
        case "strict":
          m += "; SameSite=Strict";
          break;
        case "lax":
          m += "; SameSite=Lax";
          break;
        case "none":
          m += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${u.sameSite}`);
      }
    return m;
  }
  function l(g) {
    if (g.indexOf("%") === -1)
      return g;
    try {
      return decodeURIComponent(g);
    } catch {
      return g;
    }
  }
  function d(g) {
    return s.call(g) === "[object Date]";
  }
  return ws;
}
var ml, Vy;
function C2() {
  if (Vy) return ml;
  Vy = 1;
  const { URL: e } = px, t = "http://localhost";
  return ml = function(n, s) {
    (typeof n == "string" || Object.prototype.toString.call(n) === "[object String]") && n.startsWith("//") && (n = t + n);
    const i = typeof n == "object" ? Object.assign(new e(t), n) : new e(n, t);
    if (typeof s == "string") {
      s = new URLSearchParams(s);
      for (const o of s.keys()) {
        i.searchParams.delete(o);
        for (const a of s.getAll(o))
          i.searchParams.append(o, a);
      }
    } else {
      const o = Object.assign({}, n.query, s);
      for (const a in o) {
        const c = o[a];
        if (Array.isArray(c)) {
          i.searchParams.delete(a);
          for (const f of c)
            i.searchParams.append(a, f);
        } else
          i.searchParams.set(a, c);
      }
    }
    return i;
  }, ml;
}
var Zi = {}, Gy;
function I2() {
  if (Gy) return Zi;
  Gy = 1;
  const { randomUUID: e } = xx, { Readable: t } = ri;
  let r;
  function n(i) {
    return i && typeof i == "object" && typeof i.append == "function" && typeof i.delete == "function" && typeof i.get == "function" && typeof i.getAll == "function" && typeof i.has == "function" && typeof i.set == "function" && i[Symbol.toStringTag] === "FormData";
  }
  function s(i) {
    r = r ?? new TextEncoder();
    const o = `----formdata-${e()}`, a = `--${o}\r
Content-Disposition: form-data`;
    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
    const c = (p) => p.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), f = (p) => p.replace(/\r?\n|\r/g, `\r
`), l = new Uint8Array([13, 10]);
    async function* d() {
      for (const [p, u] of i)
        if (typeof u == "string")
          yield r.encode(`${a}; name="${c(f(p))}"\r
\r
`), yield r.encode(`${f(u)}\r
`);
        else {
          let h = `${a}; name="${c(f(p))}"`;
          u.name && (h += `; filename="${c(u.name)}"`), h += `\r
Content-Type: ${u.type || "application/octet-stream"}\r
\r
`, yield r.encode(h), u.stream ? yield* u.stream() : yield u, yield l;
        }
      yield r.encode(`--${o}--`);
    }
    return {
      stream: t.from(d()),
      contentType: `multipart/form-data; boundary=${o}`
    };
  }
  return Zi.isFormDataLike = n, Zi.formDataToStream = s, Zi;
}
var Wy;
function N2() {
  if (Wy) return Ss.exports;
  Wy = 1;
  const { Readable: e, addAbortSignal: t } = ri, r = yn, n = P2(), s = vn, { createDeprecation: i } = Iv, o = C2(), { isFormDataLike: a, formDataToStream: c } = I2(), { EventEmitter: f } = Qo, l = i({
    name: "FastifyDeprecationLightMyRequest",
    code: "FST_LIGHTMYREQUEST_DEP01",
    message: 'You are accessing "request.connection", use "request.socket" instead.'
  });
  function d(m) {
    return m.port ? m.host : m.hostname + (m.protocol === "https:" ? ":443" : ":80");
  }
  class g extends f {
    constructor(v) {
      super(), this.remoteAddress = v;
    }
  }
  function p(m) {
    return new v(this);
    function v(y) {
      u.call(y, {
        ...m,
        Request: void 0
      }), Object.assign(this, y);
      for (const _ of Object.keys(u.prototype))
        this.constructor.prototype[_] = u.prototype[_];
      return r.inherits(this.constructor, m.Request), this;
    }
  }
  function u(m) {
    e.call(this, {
      autoDestroy: !1
    });
    const v = o(m.url || m.path, m.query);
    this.url = v.pathname + v.search, this.aborted = !1, this.httpVersionMajor = 1, this.httpVersionMinor = 1, this.httpVersion = "1.1", this.method = m.method ? m.method.toUpperCase() : "GET", this.headers = {}, this.rawHeaders = [];
    const y = m.headers || {};
    for (const O in y) {
      const z = O.toLowerCase();
      if ((z === "user-agent" || z === "content-type") && y[O] === void 0) {
        this.headers[z] = void 0;
        continue;
      }
      const x = y[O];
      s(x !== void 0, 'invalid value "undefined" for header ' + O), this.headers[z] = "" + x;
    }
    if ("user-agent" in this.headers || (this.headers["user-agent"] = "lightMyRequest"), this.headers.host = this.headers.host || m.authority || d(v), m.cookies) {
      const { cookies: O } = m, z = Object.keys(O).map((x) => n.serialize(x, O[x]));
      this.headers.cookie && z.unshift(this.headers.cookie), this.headers.cookie = z.join("; ");
    }
    this.socket = new g(m.remoteAddress || "127.0.0.1"), Object.defineProperty(this, "connection", {
      get() {
        return l(), this.socket;
      },
      configurable: !0
    });
    let _ = m.payload || m.body || null, R = _ && typeof _.resume == "function";
    if (a(_)) {
      const O = c(_);
      _ = O.stream, R = !0, this.headers["content-type"] = O.contentType, this.headers["transfer-encoding"] = "chunked";
    }
    _ && typeof _ != "string" && !R && !Buffer.isBuffer(_) && (_ = JSON.stringify(_), "content-type" in this.headers || (this.headers["content-type"] = "application/json")), _ && !R && !Object.hasOwn(this.headers, "content-length") && (this.headers["content-length"] = (Buffer.isBuffer(_) ? _.length : Buffer.byteLength(_)).toString());
    for (const O of Object.keys(this.headers))
      this.rawHeaders.push(O, this.headers[O]);
    this._lightMyRequest = {
      payload: _,
      isDone: !1,
      simulate: m.simulate || {},
      payloadAsStream: m.payloadAsStream,
      signal: m.signal
    };
    const E = m.signal;
    E && t(E, this);
    {
      const O = this._lightMyRequest.payload;
      O != null && O._readableState ? (this._read = h, O.on("error", (z) => {
        this.destroy(z);
      }), O.on("end", () => {
        this.push(null);
      })) : this._read = b;
    }
    return this;
  }
  function h() {
    const m = this._lightMyRequest.payload;
    let v = !0, y = !1, _;
    for (; v && (_ = m.read()); )
      y = !0, v = this.push(_);
    v && !y && this._lightMyRequest.payload.once("readable", this._read.bind(this));
  }
  function b() {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        this._lightMyRequest.simulate.end !== !1 && this.push(null);
        return;
      }
      this._lightMyRequest.isDone = !0, this._lightMyRequest.payload && (this._lightMyRequest.simulate.split ? (this.push(this._lightMyRequest.payload.slice(0, 1)), this.push(this._lightMyRequest.payload.slice(1))) : this.push(this._lightMyRequest.payload)), this._lightMyRequest.simulate.error && this.emit("error", new Error("Simulated")), this._lightMyRequest.simulate.close && this.emit("close"), this._lightMyRequest.simulate.end !== !1 && this.push(null);
    });
  }
  return r.inherits(u, e), r.inherits(p, u), u.prototype.destroy = function(m) {
    this.destroyed || this._lightMyRequest.isDone || (this.destroyed = !0, m && (this._error = !0, process.nextTick(() => this.emit("error", m))), process.nextTick(() => this.emit("close")));
  }, Ss.exports = u, Ss.exports.Request = u, Ss.exports.CustomRequest = p, Ss.exports;
}
var In = { exports: {} }, Ky;
function A2() {
  if (Ky) return In.exports;
  Ky = 1;
  var e = {
    decodeValues: !0,
    map: !1,
    silent: !1
  };
  function t(o) {
    return typeof o == "string" && !!o.trim();
  }
  function r(o, a) {
    var c = o.split(";").filter(t), f = c.shift(), l = n(f), d = l.name, g = l.value;
    a = a ? Object.assign({}, e, a) : e;
    try {
      g = a.decodeValues ? decodeURIComponent(g) : g;
    } catch (u) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + g + "'. Set options.decodeValues to false to disable this feature.",
        u
      );
    }
    var p = {
      name: d,
      value: g
    };
    return c.forEach(function(u) {
      var h = u.split("="), b = h.shift().trimLeft().toLowerCase(), m = h.join("=");
      b === "expires" ? p.expires = new Date(m) : b === "max-age" ? p.maxAge = parseInt(m, 10) : b === "secure" ? p.secure = !0 : b === "httponly" ? p.httpOnly = !0 : b === "samesite" ? p.sameSite = m : b === "partitioned" ? p.partitioned = !0 : p[b] = m;
    }), p;
  }
  function n(o) {
    var a = "", c = "", f = o.split("=");
    return f.length > 1 ? (a = f.shift(), c = f.join("=")) : c = o, { name: a, value: c };
  }
  function s(o, a) {
    if (a = a ? Object.assign({}, e, a) : e, !o)
      return a.map ? {} : [];
    if (o.headers)
      if (typeof o.headers.getSetCookie == "function")
        o = o.headers.getSetCookie();
      else if (o.headers["set-cookie"])
        o = o.headers["set-cookie"];
      else {
        var c = o.headers[Object.keys(o.headers).find(function(l) {
          return l.toLowerCase() === "set-cookie";
        })];
        !c && o.headers.cookie && !a.silent && console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        ), o = c;
      }
    if (Array.isArray(o) || (o = [o]), a.map) {
      var f = {};
      return o.filter(t).reduce(function(l, d) {
        var g = r(d, a);
        return l[g.name] = g, l;
      }, f);
    } else
      return o.filter(t).map(function(l) {
        return r(l, a);
      });
  }
  function i(o) {
    if (Array.isArray(o))
      return o;
    if (typeof o != "string")
      return [];
    var a = [], c = 0, f, l, d, g, p;
    function u() {
      for (; c < o.length && /\s/.test(o.charAt(c)); )
        c += 1;
      return c < o.length;
    }
    function h() {
      return l = o.charAt(c), l !== "=" && l !== ";" && l !== ",";
    }
    for (; c < o.length; ) {
      for (f = c, p = !1; u(); )
        if (l = o.charAt(c), l === ",") {
          for (d = c, c += 1, u(), g = c; c < o.length && h(); )
            c += 1;
          c < o.length && o.charAt(c) === "=" ? (p = !0, c = g, a.push(o.substring(f, d)), f = c) : c = d + 1;
        } else
          c += 1;
      (!p || c >= o.length) && a.push(o.substring(f, o.length));
    }
    return a;
  }
  return In.exports = s, In.exports.parse = s, In.exports.parseString = r, In.exports.splitCookiesString = i, In.exports;
}
var yl, Jy;
function k2() {
  if (Jy) return yl;
  Jy = 1;
  const e = ea, { Writable: t, Readable: r, addAbortSignal: n } = ri, s = yn, i = A2();
  function o(d, g, p) {
    var v;
    if (e.ServerResponse.call(this, d), (v = d._lightMyRequest) != null && v.payloadAsStream) {
      const y = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new r({ read: y }) };
      const _ = d._lightMyRequest.signal;
      _ && n(_, this._lightMyRequest.stream);
    } else
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    this.setHeader("foo", "bar"), this.removeHeader("foo"), this.assignSocket(c()), this._promiseCallback = typeof p == "function";
    let u = !1;
    const h = (y) => {
      if (!u) {
        if (u = !0, this._promiseCallback)
          return process.nextTick(() => g(y));
        process.nextTick(() => g(null, y));
      }
    };
    this._lightMyRequest.onEndSuccess = h;
    let b = !1;
    const m = (y) => {
      if (u) {
        this._lightMyRequest.stream && !b && (y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._lightMyRequest.stream.destroy(y), this._lightMyRequest.stream.on("error", () => {
        }));
        return;
      }
      if (u = !0, y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._promiseCallback)
        return process.nextTick(() => p(y));
      process.nextTick(() => g(y, null));
    };
    this._lightMyRequest.stream ? this.once("finish", () => {
      b = !0, this._lightMyRequest.stream.push(null);
    }) : this.once("finish", () => {
      const y = a(this);
      y.raw.req = d, h(y);
    }), this.connection.once("error", m), this.once("error", m), this.once("close", m);
  }
  s.inherits(o, e.ServerResponse), o.prototype.setTimeout = function(d, g) {
    return this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, d), this.on("timeout", g), this;
  }, o.prototype.writeHead = function() {
    const d = e.ServerResponse.prototype.writeHead.apply(this, arguments);
    return l(this), this._lightMyRequest.stream && this._lightMyRequest.onEndSuccess(a(this)), d;
  }, o.prototype.write = function(d, g, p) {
    return this.timeoutHandle && clearTimeout(this.timeoutHandle), e.ServerResponse.prototype.write.call(this, d, g, p), this._lightMyRequest.stream ? this._lightMyRequest.stream.push(Buffer.from(d, g)) : (this._lightMyRequest.payloadChunks.push(Buffer.from(d, g)), !0);
  }, o.prototype.end = function(d, g, p) {
    d && this.write(d, g), e.ServerResponse.prototype.end.call(this, p), this.emit("finish"), this.destroy();
  }, o.prototype.destroy = function(d) {
    this.destroyed || (this.destroyed = !0, d && process.nextTick(() => this.emit("error", d)), process.nextTick(() => this.emit("close")));
  }, o.prototype.addTrailers = function(d) {
    for (const g in d)
      this._lightMyRequest.trailers[g.toLowerCase().trim()] = d[g].toString().trim();
  };
  function a(d) {
    d._lightMyRequest.headers === null && l(d), f(d);
    const g = {
      raw: {
        res: d
      },
      headers: d._lightMyRequest.headers,
      statusCode: d.statusCode,
      statusMessage: d.statusMessage,
      trailers: {},
      get cookies() {
        return i.parse(this);
      }
    };
    if (g.trailers = d._lightMyRequest.trailers, d._lightMyRequest.payloadChunks) {
      const p = Buffer.concat(d._lightMyRequest.payloadChunks);
      g.rawPayload = p, g.payload = p.toString(), g.body = g.payload, g.json = function() {
        return JSON.parse(g.payload);
      };
    } else
      g.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    return g.stream = function() {
      return d._lightMyRequest.stream ? d._lightMyRequest.stream : r.from(d._lightMyRequest.payloadChunks);
    }, g;
  }
  function c() {
    return new t({
      write(d, g, p) {
        setImmediate(p);
      }
    });
  }
  function f(d) {
    const g = d._lightMyRequest.headers;
    for (const p of Object.keys(g)) {
      const u = g[p];
      Array.isArray(u) ? g[p] = u.map((h) => "" + h) : g[p] = "" + u;
    }
  }
  function l(d) {
    d._lightMyRequest.headers = Object.assign({}, d.getHeaders()), ["Date", "Connection", "Transfer-Encoding"].forEach((g) => {
      var h;
      const p = new RegExp("\\r\\n" + g + ": ([^\\r]*)\\r\\n"), u = (h = d._header) == null ? void 0 : h.match(p);
      u && (d._lightMyRequest.headers[g.toLowerCase()] = u[1]);
    });
  }
  return yl = o, yl;
}
var Qi = { exports: {} }, Yy;
function L2() {
  if (Yy) return Qi.exports;
  Yy = 1, Qi.exports = t, Qi.exports.default = t;
  const e = { properties: { method: { enum: ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] } } };
  function t(r, { instancePath: n = "", parentData: s, parentDataProperty: i, rootData: o = r } = {}) {
    let a = null, c = 0;
    const f = c;
    let l = !1, d = null;
    const g = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let E;
      if (r.url === void 0 && (E = "url")) {
        const O = { instancePath: n, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: E }, message: "must have required property '" + E + "'" };
        a === null ? a = [O] : a.push(O), c++;
      }
    }
    var u = g === c;
    u && (l = !0, d = 0);
    const p = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let E;
      if (r.path === void 0 && (E = "path")) {
        const O = { instancePath: n, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: E }, message: "must have required property '" + E + "'" };
        a === null ? a = [O] : a.push(O), c++;
      }
    }
    var u = p === c;
    if (u && l ? (l = !1, d = [d, 1]) : u && (l = !0, d = 1), l)
      c = f, a !== null && (f ? a.length = f : a = null);
    else {
      const E = { instancePath: n, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: d }, message: "must match exactly one schema in oneOf" };
      return a === null ? a = [E] : a.push(E), c++, t.errors = a, !1;
    }
    if (c === 0)
      if (r && typeof r == "object" && !Array.isArray(r)) {
        if (r.url !== void 0) {
          let E = r.url;
          const O = c, z = c;
          let x = !1, L = null;
          const M = c;
          if (typeof E != "string") {
            let $ = typeof E, S;
            if (S === void 0)
              if ($ == "number" || $ == "boolean")
                S = "" + E;
              else if (E === null)
                S = "";
              else {
                const I = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                a === null ? a = [I] : a.push(I), c++;
              }
            S !== void 0 && (E = S, r !== void 0 && (r.url = S));
          }
          var b = M === c;
          b && (x = !0, L = 0);
          const U = c;
          if (c === U)
            if (E && typeof E == "object" && !Array.isArray(E)) {
              let $;
              if (E.pathname === void 0 && ($ = "pathname")) {
                const S = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: $ }, message: "must have required property '" + $ + "'" };
                a === null ? a = [S] : a.push(S), c++;
              } else {
                if (E.protocol !== void 0) {
                  let S = E.protocol;
                  const I = c;
                  if (typeof S != "string") {
                    let T = typeof S, j;
                    if (j === void 0)
                      if (T == "number" || T == "boolean")
                        j = "" + S;
                      else if (S === null)
                        j = "";
                      else {
                        const P = { instancePath: n + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        a === null ? a = [P] : a.push(P), c++;
                      }
                    j !== void 0 && (S = j, E !== void 0 && (E.protocol = j));
                  }
                  var h = I === c;
                } else
                  var h = !0;
                if (h) {
                  if (E.hostname !== void 0) {
                    let S = E.hostname;
                    const I = c;
                    if (typeof S != "string") {
                      let j = typeof S, P;
                      if (P === void 0)
                        if (j == "number" || j == "boolean")
                          P = "" + S;
                        else if (S === null)
                          P = "";
                        else {
                          const A = { instancePath: n + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [A] : a.push(A), c++;
                        }
                      P !== void 0 && (S = P, E !== void 0 && (E.hostname = P));
                    }
                    var h = I === c;
                  } else
                    var h = !0;
                  if (h)
                    if (E.pathname !== void 0) {
                      let S = E.pathname;
                      const I = c;
                      if (typeof S != "string") {
                        let j = typeof S, P;
                        if (P === void 0)
                          if (j == "number" || j == "boolean")
                            P = "" + S;
                          else if (S === null)
                            P = "";
                          else {
                            const A = { instancePath: n + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [A] : a.push(A), c++;
                          }
                        P !== void 0 && (S = P, E !== void 0 && (E.pathname = P));
                      }
                      var h = I === c;
                    } else
                      var h = !0;
                }
              }
            } else {
              const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              a === null ? a = [$] : a.push($), c++;
            }
          var b = U === c;
          if (b && x ? (x = !1, L = [L, 1]) : b && (x = !0, L = 1), x)
            c = z, a !== null && (z ? a.length = z : a = null);
          else {
            const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: L }, message: "must match exactly one schema in oneOf" };
            return a === null ? a = [$] : a.push($), c++, t.errors = a, !1;
          }
          var m = O === c;
        } else
          var m = !0;
        if (m) {
          if (r.path !== void 0) {
            let E = r.path;
            const O = c, z = c;
            let x = !1, L = null;
            const M = c;
            if (typeof E != "string") {
              let S = typeof E, I;
              if (I === void 0)
                if (S == "number" || S == "boolean")
                  I = "" + E;
                else if (E === null)
                  I = "";
                else {
                  const T = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  a === null ? a = [T] : a.push(T), c++;
                }
              I !== void 0 && (E = I, r !== void 0 && (r.path = I));
            }
            var y = M === c;
            y && (x = !0, L = 0);
            const U = c;
            if (c === U)
              if (E && typeof E == "object" && !Array.isArray(E)) {
                let S;
                if (E.pathname === void 0 && (S = "pathname")) {
                  const I = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: S }, message: "must have required property '" + S + "'" };
                  a === null ? a = [I] : a.push(I), c++;
                } else {
                  if (E.protocol !== void 0) {
                    let I = E.protocol;
                    const T = c;
                    if (typeof I != "string") {
                      let j = typeof I, P;
                      if (P === void 0)
                        if (j == "number" || j == "boolean")
                          P = "" + I;
                        else if (I === null)
                          P = "";
                        else {
                          const A = { instancePath: n + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [A] : a.push(A), c++;
                        }
                      P !== void 0 && (I = P, E !== void 0 && (E.protocol = P));
                    }
                    var v = T === c;
                  } else
                    var v = !0;
                  if (v) {
                    if (E.hostname !== void 0) {
                      let I = E.hostname;
                      const T = c;
                      if (typeof I != "string") {
                        let P = typeof I, A;
                        if (A === void 0)
                          if (P == "number" || P == "boolean")
                            A = "" + I;
                          else if (I === null)
                            A = "";
                          else {
                            const k = { instancePath: n + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [k] : a.push(k), c++;
                          }
                        A !== void 0 && (I = A, E !== void 0 && (E.hostname = A));
                      }
                      var v = T === c;
                    } else
                      var v = !0;
                    if (v)
                      if (E.pathname !== void 0) {
                        let I = E.pathname;
                        const T = c;
                        if (typeof I != "string") {
                          let P = typeof I, A;
                          if (A === void 0)
                            if (P == "number" || P == "boolean")
                              A = "" + I;
                            else if (I === null)
                              A = "";
                            else {
                              const k = { instancePath: n + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              a === null ? a = [k] : a.push(k), c++;
                            }
                          A !== void 0 && (I = A, E !== void 0 && (E.pathname = A));
                        }
                        var v = T === c;
                      } else
                        var v = !0;
                  }
                }
              } else {
                const S = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                a === null ? a = [S] : a.push(S), c++;
              }
            var y = U === c;
            if (y && x ? (x = !1, L = [L, 1]) : y && (x = !0, L = 1), x)
              c = z, a !== null && (z ? a.length = z : a = null);
            else {
              const S = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: L }, message: "must match exactly one schema in oneOf" };
              return a === null ? a = [S] : a.push(S), c++, t.errors = a, !1;
            }
            var m = O === c;
          } else
            var m = !0;
          if (m) {
            if (r.cookies !== void 0) {
              let E = r.cookies;
              const O = c;
              if (c === O && !(E && typeof E == "object" && !Array.isArray(E)))
                return t.errors = [{ instancePath: n + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
              var m = O === c;
            } else
              var m = !0;
            if (m) {
              if (r.headers !== void 0) {
                let E = r.headers;
                const O = c;
                if (c === O && !(E && typeof E == "object" && !Array.isArray(E)))
                  return t.errors = [{ instancePath: n + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                var m = O === c;
              } else
                var m = !0;
              if (m) {
                if (r.query !== void 0) {
                  let E = r.query;
                  const O = c, z = c;
                  let x = !1;
                  const L = c;
                  if (c === L && !(E && typeof E == "object" && !Array.isArray(E))) {
                    const U = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    a === null ? a = [U] : a.push(U), c++;
                  }
                  var _ = L === c;
                  if (x = x || _, !x) {
                    const U = c;
                    if (typeof E != "string") {
                      let S = typeof E, I;
                      if (I === void 0)
                        if (S == "number" || S == "boolean")
                          I = "" + E;
                        else if (E === null)
                          I = "";
                        else {
                          const T = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [T] : a.push(T), c++;
                        }
                      I !== void 0 && (E = I, r !== void 0 && (r.query = I));
                    }
                    var _ = U === c;
                    x = x || _;
                  }
                  if (x)
                    c = z, a !== null && (z ? a.length = z : a = null);
                  else {
                    const U = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    return a === null ? a = [U] : a.push(U), c++, t.errors = a, !1;
                  }
                  var m = O === c;
                } else
                  var m = !0;
                if (m) {
                  if (r.simulate !== void 0) {
                    let E = r.simulate;
                    const O = c;
                    if (c === O)
                      if (E && typeof E == "object" && !Array.isArray(E)) {
                        if (E.end !== void 0) {
                          let x = E.end;
                          const L = c;
                          if (typeof x != "boolean") {
                            let M;
                            if (M === void 0)
                              if (x === "false" || x === 0 || x === null)
                                M = !1;
                              else if (x === "true" || x === 1)
                                M = !0;
                              else
                                return t.errors = [{ instancePath: n + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            M !== void 0 && (x = M, E !== void 0 && (E.end = M));
                          }
                          var R = L === c;
                        } else
                          var R = !0;
                        if (R) {
                          if (E.split !== void 0) {
                            let x = E.split;
                            const L = c;
                            if (typeof x != "boolean") {
                              let U;
                              if (U === void 0)
                                if (x === "false" || x === 0 || x === null)
                                  U = !1;
                                else if (x === "true" || x === 1)
                                  U = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              U !== void 0 && (x = U, E !== void 0 && (E.split = U));
                            }
                            var R = L === c;
                          } else
                            var R = !0;
                          if (R) {
                            if (E.error !== void 0) {
                              let x = E.error;
                              const L = c;
                              if (typeof x != "boolean") {
                                let U;
                                if (U === void 0)
                                  if (x === "false" || x === 0 || x === null)
                                    U = !1;
                                  else if (x === "true" || x === 1)
                                    U = !0;
                                  else
                                    return t.errors = [{ instancePath: n + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                U !== void 0 && (x = U, E !== void 0 && (E.error = U));
                              }
                              var R = L === c;
                            } else
                              var R = !0;
                            if (R)
                              if (E.close !== void 0) {
                                let x = E.close;
                                const L = c;
                                if (typeof x != "boolean") {
                                  let U;
                                  if (U === void 0)
                                    if (x === "false" || x === 0 || x === null)
                                      U = !1;
                                    else if (x === "true" || x === 1)
                                      U = !0;
                                    else
                                      return t.errors = [{ instancePath: n + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  U !== void 0 && (x = U, E !== void 0 && (E.close = U));
                                }
                                var R = L === c;
                              } else
                                var R = !0;
                          }
                        }
                      } else
                        return t.errors = [{ instancePath: n + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                    var m = O === c;
                  } else
                    var m = !0;
                  if (m) {
                    if (r.authority !== void 0) {
                      let E = r.authority;
                      const O = c;
                      if (typeof E != "string") {
                        let x = typeof E, L;
                        if (L === void 0)
                          if (x == "number" || x == "boolean")
                            L = "" + E;
                          else if (E === null)
                            L = "";
                          else
                            return t.errors = [{ instancePath: n + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                        L !== void 0 && (E = L, r !== void 0 && (r.authority = L));
                      }
                      var m = O === c;
                    } else
                      var m = !0;
                    if (m) {
                      if (r.remoteAddress !== void 0) {
                        let E = r.remoteAddress;
                        const O = c;
                        if (typeof E != "string") {
                          let x = typeof E, L;
                          if (L === void 0)
                            if (x == "number" || x == "boolean")
                              L = "" + E;
                            else if (E === null)
                              L = "";
                            else
                              return t.errors = [{ instancePath: n + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                          L !== void 0 && (E = L, r !== void 0 && (r.remoteAddress = L));
                        }
                        var m = O === c;
                      } else
                        var m = !0;
                      if (m) {
                        if (r.method !== void 0) {
                          let E = r.method;
                          const O = c;
                          if (typeof E != "string") {
                            let x = typeof E, L;
                            if (L === void 0)
                              if (x == "number" || x == "boolean")
                                L = "" + E;
                              else if (E === null)
                                L = "";
                              else
                                return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                            L !== void 0 && (E = L, r !== void 0 && (r.method = L));
                          }
                          if (!(E === "ACL" || E === "BIND" || E === "CHECKOUT" || E === "CONNECT" || E === "COPY" || E === "DELETE" || E === "GET" || E === "HEAD" || E === "LINK" || E === "LOCK" || E === "M-SEARCH" || E === "MERGE" || E === "MKACTIVITY" || E === "MKCALENDAR" || E === "MKCOL" || E === "MOVE" || E === "NOTIFY" || E === "OPTIONS" || E === "PATCH" || E === "POST" || E === "PROPFIND" || E === "PROPPATCH" || E === "PURGE" || E === "PUT" || E === "QUERY" || E === "REBIND" || E === "REPORT" || E === "SEARCH" || E === "SOURCE" || E === "SUBSCRIBE" || E === "TRACE" || E === "UNBIND" || E === "UNLINK" || E === "UNLOCK" || E === "UNSUBSCRIBE" || E === "acl" || E === "bind" || E === "checkout" || E === "connect" || E === "copy" || E === "delete" || E === "get" || E === "head" || E === "link" || E === "lock" || E === "m-search" || E === "merge" || E === "mkactivity" || E === "mkcalendar" || E === "mkcol" || E === "move" || E === "notify" || E === "options" || E === "patch" || E === "post" || E === "propfind" || E === "proppatch" || E === "purge" || E === "put" || E === "query" || E === "rebind" || E === "report" || E === "search" || E === "source" || E === "subscribe" || E === "trace" || E === "unbind" || E === "unlink" || E === "unlock" || E === "unsubscribe"))
                            return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: e.properties.method.enum }, message: "must be equal to one of the allowed values" }], !1;
                          var m = O === c;
                        } else
                          var m = !0;
                        if (m)
                          if (r.validate !== void 0) {
                            let E = r.validate;
                            const O = c;
                            if (typeof E != "boolean") {
                              let x;
                              if (x === void 0)
                                if (E === "false" || E === 0 || E === null)
                                  x = !1;
                                else if (E === "true" || E === 1)
                                  x = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              x !== void 0 && (E = x, r !== void 0 && (r.validate = x));
                            }
                            var m = O === c;
                          } else
                            var m = !0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else
        return t.errors = [{ instancePath: n, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    return t.errors = a, c === 0;
  }
  return Qi.exports;
}
var Xy;
function j2() {
  if (Xy) return Cn.exports;
  Xy = 1;
  const e = vn, t = N2(), r = k2(), n = "The dispatch function has already been invoked", s = L2();
  function i(p, u, h) {
    return h === void 0 ? new f(p, u) : c(p, u, h);
  }
  function o(p, u) {
    const h = p._lightMyRequest.payload;
    if (!h || h._readableState || typeof h.resume != "function")
      return u();
    const b = [];
    h.on("data", (m) => b.push(Buffer.from(m))), h.on("end", () => {
      const m = Buffer.concat(b);
      return p.headers["content-length"] = p.headers["content-length"] || "" + m.length, delete p.headers["transfer-encoding"], p._lightMyRequest.payload = m, u();
    }), h.resume();
  }
  function a(p, u, h, b) {
    return h.once("error", function(m) {
      this.destroyed && b.destroy(m);
    }), h.once("close", function() {
      this.destroyed && !this._error && b.destroy();
    }), o(h, () => p.call(u, h, b));
  }
  function c(p, u, h) {
    if (u = typeof u == "string" ? { url: u } : u, u.validate !== !1 && (e(typeof p == "function", "dispatchFunc should be a function"), !s(u)))
      throw new Error(s.errors.map((y) => y.message));
    const b = u.server || {}, m = u.Request ? t.CustomRequest : t;
    if (p.request && p.request.app === p && (Object.setPrototypeOf(Object.getPrototypeOf(p.request), m.prototype), Object.setPrototypeOf(Object.getPrototypeOf(p.response), r.prototype)), typeof h == "function") {
      const v = new m(u), y = new r(v, h);
      return a(p, b, v, y);
    } else
      return new Promise((v, y) => {
        const _ = new m(u), R = new r(_, v, y);
        a(p, b, _, R);
      });
  }
  function f(p, u) {
    typeof u == "string" ? this.option = { url: u } : this.option = Object.assign({}, u), this.dispatch = p, this._hasInvoked = !1, this._promise = null, this.option.autoStart !== !1 && process.nextTick(() => {
      this._hasInvoked || this.end();
    });
  }
  [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ].forEach((p) => {
    f.prototype[p] = function(u) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option.url = u, this.option.method = p.toUpperCase(), this;
    };
  }), [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ].forEach((p) => {
    f.prototype[p] = function(u) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option[p] = u, this;
    };
  }), f.prototype.end = function(p) {
    if (this._hasInvoked === !0 || this._promise)
      throw new Error(n);
    if (this._hasInvoked = !0, typeof p == "function")
      c(this.dispatch, this.option, p);
    else
      return this._promise = c(this.dispatch, this.option), this._promise;
  }, Object.getOwnPropertyNames(Promise.prototype).forEach((p) => {
    p !== "constructor" && (f.prototype[p] = function(...u) {
      if (!this._promise) {
        if (this._hasInvoked === !0)
          throw new Error(n);
        this._hasInvoked = !0, this._promise = c(this.dispatch, this.option);
      }
      return this._promise[p](...u);
    });
  });
  function g(p) {
    var u;
    return p instanceof t || p instanceof r || ((u = p == null ? void 0 : p.constructor) == null ? void 0 : u.name) === "_CustomLMRRequest";
  }
  return Cn.exports = i, Cn.exports.default = i, Cn.exports.inject = i, Cn.exports.isInjection = g, Cn.exports;
}
const D2 = "5.2.2", F2 = TS, eo = ea, M2 = zu;
let Rs;
const {
  kAvvioBoot: $s,
  kChildren: gl,
  kServerBindings: Zy,
  kBodyLimit: z2,
  kSupportedHTTPMethods: Jr,
  kRoutePrefix: Qy,
  kLogLevel: U2,
  kLogSerializers: q2,
  kHooks: vl,
  kSchemaController: Nr,
  kRequestAcceptVersion: H2,
  kReplySerializerDefault: eg,
  kContentTypeParser: B2,
  kReply: V2,
  kRequest: G2,
  kFourOhFour: W2,
  kState: We,
  kOptions: bl,
  kPluginNameChain: Ts,
  kSchemaErrorFormatter: _l,
  kErrorHandler: to,
  kKeepAliveConnections: El,
  kChildLoggerFactory: xl,
  kGenReqId: Sl
} = pt, { createServer: K2 } = Pv, Os = af, ro = df, J2 = pf, Nn = Tb, Yr = kb, tg = p_, { Hooks: Y2, hookRunnerApplication: rg, supportedHooks: Ou } = bn, { createChildLogger: ng, defaultChildLoggerFactory: X2, createLogger: Z2 } = ca, sg = x_, { getGenReqId: ig, reqIdGenFactory: og } = Hd, { buildRouting: Q2, validateBodyLimitOption: eM } = t2, tM = u2, Q_ = v2, rM = $2, nM = O2, {
  appendStackTrace: sM,
  AVVIO_ERRORS_MAP: ag,
  ...sn
} = bt, { defaultInitOptions: Nt } = Q_, {
  FST_ERR_ASYNC_CONSTRAINT: iM,
  FST_ERR_BAD_URL: oM,
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: aM,
  FST_ERR_OPTIONS_NOT_OBJ: cM,
  FST_ERR_QSP_NOT_FN: lM,
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: uM,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: fM,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: dM,
  FST_ERR_INSTANCE_ALREADY_LISTENING: pM,
  FST_ERR_REOPENED_CLOSE_SERVER: hM,
  FST_ERR_ROUTE_REWRITE_NOT_STR: mM,
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: cg,
  FST_ERR_ERROR_HANDLER_NOT_FN: yM,
  FST_ERR_ROUTE_METHOD_INVALID: gM
} = sn, { buildErrorHandler: lg } = fa, ug = M2.channel("fastify.initialization");
function vM(e) {
  const t = {};
  return ["errorHandler", "logLevel", "logSerializers"].concat(Ou).forEach((n) => {
    t[n] = e.store[n];
  }), Object.assign({}, t);
}
function Yd(e) {
  if (e && typeof e != "object")
    throw new cM();
  if (e = Object.assign({}, e), e.querystringParser && typeof e.querystringParser != "function")
    throw new lM(typeof e.querystringParser);
  if (e.schemaController && e.schemaController.bucket && typeof e.schemaController.bucket != "function")
    throw new uM(typeof e.schemaController.bucket);
  eM(e.bodyLimit);
  const t = typeof e.requestIdHeader == "string" && e.requestIdHeader.length !== 0 ? e.requestIdHeader.toLowerCase() : e.requestIdHeader === !0 && "request-id", r = og(t, e.genReqId), n = e.requestIdLogLabel || "reqId", s = e.bodyLimit || Nt.bodyLimit, i = e.disableRequestLogging || !1, o = Object.assign({
    customOptions: {},
    plugins: []
  }, e.ajv), a = e.frameworkErrors;
  if (!o.customOptions || Object.prototype.toString.call(o.customOptions) !== "[object Object]")
    throw new fM(typeof o.customOptions);
  if (!o.plugins || !Array.isArray(o.plugins))
    throw new dM(typeof o.plugins);
  const { logger: c, hasLogger: f } = Z2(e);
  e.connectionTimeout = e.connectionTimeout || Nt.connectionTimeout, e.keepAliveTimeout = e.keepAliveTimeout || Nt.keepAliveTimeout, e.maxRequestsPerSocket = e.maxRequestsPerSocket || Nt.maxRequestsPerSocket, e.requestTimeout = e.requestTimeout || Nt.requestTimeout, e.logger = c, e.requestIdHeader = t, e.requestIdLogLabel = n, e.disableRequestLogging = i, e.ajv = o, e.clientErrorHandler = e.clientErrorHandler || T;
  const l = Q_(e);
  e.exposeHeadRoutes = l.exposeHeadRoutes;
  const d = Q2({
    config: {
      defaultRoute: j,
      onBadUrl: P,
      constraints: e.constraints,
      ignoreTrailingSlash: e.ignoreTrailingSlash || Nt.ignoreTrailingSlash,
      ignoreDuplicateSlashes: e.ignoreDuplicateSlashes || Nt.ignoreDuplicateSlashes,
      maxParamLength: e.maxParamLength || Nt.maxParamLength,
      caseSensitive: e.caseSensitive,
      allowUnsafeRegex: e.allowUnsafeRegex || Nt.allowUnsafeRegex,
      buildPrettyMeta: vM,
      querystringParser: e.querystringParser,
      useSemicolonDelimiter: e.useSemicolonDelimiter ?? Nt.useSemicolonDelimiter
    }
  }), g = tM(e), p = Z(d, e);
  e.http2SessionTimeout = l.http2SessionTimeout;
  const { server: u, listen: h } = K2(e, p), b = typeof u.closeAllConnections == "function", m = typeof u.closeIdleConnections == "function";
  let v = e.forceCloseConnections;
  if (v === "idle" && !m)
    throw new aM();
  typeof v != "boolean" && (v = m ? "idle" : !1);
  const y = !b && v === !0 ? /* @__PURE__ */ new Set() : nM(), _ = Os.setupResponseListeners, R = tg.buildSchemaController(null, e.schemaController), E = {
    // Fastify internals
    [We]: {
      listening: !1,
      closing: !1,
      started: !1,
      ready: !1,
      booting: !1,
      readyPromise: null
    },
    [El]: y,
    [Jr]: {
      bodyless: /* @__PURE__ */ new Set([
        // Standard
        "GET",
        "HEAD",
        "TRACE"
      ]),
      bodywith: /* @__PURE__ */ new Set([
        // Standard
        "DELETE",
        "OPTIONS",
        "PATCH",
        "PUT",
        "POST"
      ])
    },
    [bl]: e,
    [gl]: [],
    [Zy]: [],
    [z2]: s,
    [Qy]: "",
    [U2]: "",
    [q2]: null,
    [vl]: new Y2(),
    [Nr]: R,
    [_l]: null,
    [to]: lg(),
    [xl]: X2,
    [eg]: null,
    [B2]: new Yr(
      s,
      e.onProtoPoisoning || Nt.onProtoPoisoning,
      e.onConstructorPoisoning || Nt.onConstructorPoisoning
    ),
    [V2]: Os.buildReply(Os),
    [G2]: ro.buildRequest(ro, e.trustProxy),
    [W2]: g,
    [sg.kRegisteredPlugins]: [],
    [Ts]: ["fastify"],
    [$s]: null,
    [Sl]: r,
    // routing method
    routing: p,
    // routes shorthand methods
    delete: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "DELETE", url: W, options: G, handler: ee });
    },
    get: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "GET", url: W, options: G, handler: ee });
    },
    head: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "HEAD", url: W, options: G, handler: ee });
    },
    trace: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "TRACE", url: W, options: G, handler: ee });
    },
    patch: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "PATCH", url: W, options: G, handler: ee });
    },
    post: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "POST", url: W, options: G, handler: ee });
    },
    put: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "PUT", url: W, options: G, handler: ee });
    },
    options: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "OPTIONS", url: W, options: G, handler: ee });
    },
    all: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: this.supportedMethods, url: W, options: G, handler: ee });
    },
    // extended route
    route: function(W) {
      return d.route.call(this, { options: W });
    },
    hasRoute: function(W) {
      return d.hasRoute.call(this, { options: W });
    },
    findRoute: function(W) {
      return d.findRoute(W);
    },
    // expose logger instance
    log: c,
    // type provider
    withTypeProvider: $,
    // hooks
    addHook: S,
    // schemas
    addSchema: I,
    getSchema: R.getSchema.bind(R),
    getSchemas: R.getSchemas.bind(R),
    setValidatorCompiler: C,
    setSerializerCompiler: F,
    setSchemaController: w,
    setReplySerializer: N,
    setSchemaErrorFormatter: D,
    // set generated request id
    setGenReqId: Y,
    // custom parsers
    addContentTypeParser: Yr.helpers.addContentTypeParser,
    hasContentTypeParser: Yr.helpers.hasContentTypeParser,
    getDefaultJsonParser: Yr.defaultParsers.getDefaultJsonParser,
    defaultTextParser: Yr.defaultParsers.defaultTextParser,
    removeContentTypeParser: Yr.helpers.removeContentTypeParser,
    removeAllContentTypeParsers: Yr.helpers.removeAllContentTypeParsers,
    // Fastify architecture methods (initialized by Avvio)
    register: null,
    after: null,
    ready: null,
    onClose: null,
    close: null,
    printPlugins: null,
    hasPlugin: function(H) {
      return this[sg.kRegisteredPlugins].includes(H) || this[Ts].includes(H);
    },
    // http server
    listen: h,
    server: u,
    addresses: function() {
      const H = this[Zy].map((W) => W.address());
      return H.push(this.server.address()), H.filter((W) => W);
    },
    // extend fastify objects
    decorate: Nn.add,
    hasDecorator: Nn.exist,
    decorateReply: Nn.decorateReply,
    decorateRequest: Nn.decorateRequest,
    hasRequestDecorator: Nn.existRequest,
    hasReplyDecorator: Nn.existReply,
    addHttpMethod: J,
    // fake http injection
    inject: M,
    // pretty print of the registered routes
    printRoutes: V,
    // custom error handling
    setNotFoundHandler: k,
    setErrorHandler: q,
    // child logger
    setChildLoggerFactory: K,
    // Set fastify initial configuration options read-only object
    initialConfig: l,
    // constraint strategies
    addConstraintStrategy: d.addConstraintStrategy.bind(d),
    hasConstraintStrategy: d.hasConstraintStrategy.bind(d)
  };
  Object.defineProperties(E, {
    listeningOrigin: {
      get() {
        const H = this.addresses().slice(-1).pop();
        if (typeof H == "string")
          return H;
        const W = H.family === "IPv6" ? `[${H.address}]` : H.address;
        return `${this[bl].https ? "https" : "http"}://${W}:${H.port}`;
      }
    },
    pluginName: {
      configurable: !0,
      get() {
        return this[Ts].length > 1 ? this[Ts].join(" -> ") : this[Ts][0];
      }
    },
    prefix: {
      configurable: !0,
      get() {
        return this[Qy];
      }
    },
    validatorCompiler: {
      configurable: !0,
      get() {
        return this[Nr].getValidatorCompiler();
      }
    },
    serializerCompiler: {
      configurable: !0,
      get() {
        return this[Nr].getSerializerCompiler();
      }
    },
    childLoggerFactory: {
      configurable: !0,
      get() {
        return this[xl];
      }
    },
    version: {
      configurable: !0,
      get() {
        return D2;
      }
    },
    errorHandler: {
      configurable: !0,
      get() {
        return this[to].func;
      }
    },
    genReqId: {
      configurable: !0,
      get() {
        return this[Sl];
      }
    },
    supportedMethods: {
      configurable: !1,
      get() {
        return [
          ...this[Jr].bodyless,
          ...this[Jr].bodywith
        ];
      }
    }
  }), e.schemaErrorFormatter && (fg(e.schemaErrorFormatter), E[_l] = e.schemaErrorFormatter.bind(E));
  const O = Number(e.pluginTimeout), z = F2(E, {
    autostart: !1,
    timeout: isNaN(O) === !1 ? O : Nt.pluginTimeout,
    expose: {
      use: "register"
    }
  });
  z.override = rM, z.on("start", () => E[We].started = !0), E[$s] = E.ready, E.ready = U, E.printPlugins = z.prettyPrint.bind(z), z.once("preReady", () => {
    E.onClose((H, W) => {
      E[We].closing = !0, d.closeRoutes(), rg("preClose", E[$s], E, function() {
        if (E[We].listening) {
          if (v === "idle")
            H.server.closeIdleConnections();
          else if (b && v)
            H.server.closeAllConnections();
          else if (v === !0)
            for (const G of E[El])
              G.destroy(), E[El].delete(G);
        }
        !e.serverFactory || E[We].listening ? H.server.close(function(G) {
          G && G.code !== "ERR_SERVER_NOT_RUNNING" ? W(null) : W();
        }) : process.nextTick(W, null);
      });
    });
  });
  const x = new J2({
    server: E,
    config: {}
  });
  return E.setNotFoundHandler(), g.arrange404(E), d.setup(e, {
    avvio: z,
    fourOhFour: g,
    logger: c,
    hasLogger: f,
    setupResponseListeners: _,
    throwIfAlreadyStarted: L,
    keepAliveConnections: y
  }), u.on("clientError", e.clientErrorHandler.bind(E)), ug.hasSubscribers && ug.publish({ fastify: E }), "asyncDispose" in Symbol && (E[Symbol.asyncDispose] = function() {
    return E.close();
  }), E;
  function L(H) {
    if (E[We].started) throw new pM(H);
  }
  function M(H, W) {
    if (Rs === void 0 && (Rs = j2()), E[We].started) {
      if (E[We].closing) {
        const G = new hM();
        if (W) {
          W(G);
          return;
        } else
          return Promise.reject(G);
      }
      return Rs(p, H, W);
    }
    if (W)
      this.ready((G) => {
        G ? W(G, null) : Rs(p, H, W);
      });
    else
      return Rs((G, ee) => {
        this.ready(function(le) {
          if (le) {
            ee.emit("error", le);
            return;
          }
          p(G, ee);
        });
      }, H);
  }
  function U(H) {
    if (this[We].readyPromise !== null) {
      if (H != null) {
        this[We].readyPromise.then(() => H(null, E), H);
        return;
      }
      return this[We].readyPromise;
    }
    let W, G;
    if (process.nextTick(ee), this[We].readyPromise = new Promise(function(X, ce) {
      W = X, G = ce;
    }), H)
      this[We].readyPromise.then(() => H(null, E), H);
    else
      return this[We].readyPromise;
    function ee() {
      E[$s]((X, ce) => {
        X || E[We].started || E[We].ready || E[We].booting ? le(X) : (E[We].booting = !0, rg("onReady", E[$s], E, le)), ce();
      });
    }
    function le(X) {
      if (X = X != null && ag[X.code] != null ? sM(X, new ag[X.code](X.message)) : X, X)
        return G(X);
      W(E), E[We].booting = !1, E[We].ready = !0, E[We].promise = null;
    }
  }
  function $() {
    return this;
  }
  function S(H, W) {
    if (L('Cannot call "addHook"!'), W == null)
      throw new sn.FST_ERR_HOOK_INVALID_HANDLER(H, W);
    if (H === "onSend" || H === "preSerialization" || H === "onError" || H === "preParsing") {
      if (W.constructor.name === "AsyncFunction" && W.length === 4)
        throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (H === "onReady" || H === "onListen") {
      if (W.constructor.name === "AsyncFunction" && W.length !== 0)
        throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (H === "onRequestAbort") {
      if (W.constructor.name === "AsyncFunction" && W.length !== 1)
        throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (W.constructor.name === "AsyncFunction" && W.length === 3)
      throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    return H === "onClose" ? this.onClose(W.bind(this)) : H === "onReady" || H === "onListen" || H === "onRoute" ? this[vl].add(H, W) : this.after((ee, le) => {
      G.call(this, H, W), le(ee);
    }), this;
    function G(ee, le) {
      this[vl].add(ee, le), this[gl].forEach((X) => G.call(X, ee, le));
    }
  }
  function I(H) {
    return L('Cannot call "addSchema"!'), this[Nr].add(H), this[gl].forEach((W) => W.addSchema(H)), this;
  }
  function T(H, W) {
    if (H.code === "ECONNRESET" || W.destroyed)
      return;
    let G, ee, le, X;
    H.code === "ERR_HTTP_REQUEST_TIMEOUT" ? (ee = "408", le = eo.STATUS_CODES[ee], G = `{"error":"${le}","message":"Client Timeout","statusCode":408}`, X = "timeout") : H.code === "HPE_HEADER_OVERFLOW" ? (ee = "431", le = eo.STATUS_CODES[ee], G = `{"error":"${le}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`, X = "header_overflow") : (ee = "400", le = eo.STATUS_CODES[ee], G = `{"error":"${le}","message":"Client Error","statusCode":400}`, X = "error"), this.log.trace({ err: H }, `client ${X}`), W.writable && W.write(`HTTP/1.1 ${ee} ${le}\r
Content-Length: ${G.length}\r
Content-Type: application/json\r
\r
${G}`), W.destroy(H);
  }
  function j(H, W) {
    H.headers["accept-version"] !== void 0 && (H.headers[H2] = H.headers["accept-version"], H.headers["accept-version"] = void 0), g.router.lookup(H, W);
  }
  function P(H, W, G) {
    if (a) {
      const le = ig(x.server, W), X = ng(x, c, W, le), ce = new ro(le, null, W, null, X, x), _e = new Os(G, ce, X);
      return i === !1 && X.info({ req: ce }, "incoming request"), a(new oM(H), ce, _e);
    }
    const ee = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${H}' is not a valid url component","statusCode":400}`;
    G.writeHead(400, {
      "Content-Type": "application/json",
      "Content-Length": ee.length
    }), G.end(ee);
  }
  function A(H, W, G) {
    if (H !== !1)
      return function(le) {
        if (le) {
          if (a) {
            const ce = ig(x.server, W), _e = ng(x, c, W, ce), pe = new ro(ce, null, W, null, _e, x), he = new Os(G, pe, _e);
            return i === !1 && _e.info({ req: pe }, "incoming request"), a(new iM(), pe, he);
          }
          const X = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          G.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": X.length
          }), G.end(X);
        }
      };
  }
  function k(H, W) {
    return L('Cannot call "setNotFoundHandler"!'), g.setNotFoundHandler.call(this, H, W, z, d.routeHandler), this;
  }
  function C(H) {
    return L('Cannot call "setValidatorCompiler"!'), this[Nr].setValidatorCompiler(H), this;
  }
  function D(H) {
    return L('Cannot call "setSchemaErrorFormatter"!'), fg(H), this[_l] = H.bind(this), this;
  }
  function F(H) {
    return L('Cannot call "setSerializerCompiler"!'), this[Nr].setSerializerCompiler(H), this;
  }
  function w(H) {
    L('Cannot call "setSchemaController"!');
    const W = this[Nr], G = tg.buildSchemaController(W, Object.assign({}, W.opts, H));
    return this[Nr] = G, this.getSchema = G.getSchema.bind(G), this.getSchemas = G.getSchemas.bind(G), this;
  }
  function N(H) {
    return L('Cannot call "setReplySerializer"!'), this[eg] = H, this;
  }
  function q(H) {
    if (L('Cannot call "setErrorHandler"!'), typeof H != "function")
      throw new yM();
    return this[to] = lg(this[to], H.bind(this)), this;
  }
  function K(H) {
    return L('Cannot call "setChildLoggerFactory"!'), this[xl] = H, this;
  }
  function V(H = {}) {
    return H.includeMeta = H.includeHooks ? H.includeMeta ? Ou.concat(H.includeMeta) : Ou : H.includeMeta, d.printRoutes(H);
  }
  function Z(H, { rewriteUrl: W, logger: G }) {
    let ee;
    return function(X, ce) {
      if (ee === void 0 && (ee = H.isAsyncConstraint()), W) {
        X.originalUrl = X.url;
        const _e = W.call(E, X);
        if (typeof _e == "string")
          X.url = _e;
        else {
          const pe = new mM(X.url, typeof _e);
          X.destroy(pe);
        }
      }
      H.routing(X, ce, A(ee, X, ce));
    };
  }
  function Y(H) {
    return L('Cannot call "setGenReqId"!'), this[Sl] = og(this[bl].requestIdHeader, H), this;
  }
  function J(H, { hasBody: W = !1 } = {}) {
    if (typeof H != "string" || eo.METHODS.indexOf(H) === -1)
      throw new gM();
    W === !0 ? (this[Jr].bodywith.add(H), this[Jr].bodyless.delete(H)) : (this[Jr].bodywith.delete(H), this[Jr].bodyless.add(H));
    const G = H.toLowerCase();
    return this.hasDecorator(G) || this.decorate(G, function(ee, le, X) {
      return d.prepareRoute.call(this, { method: H, url: ee, options: le, handler: X });
    }), this;
  }
}
function fg(e) {
  if (typeof e != "function")
    throw new cg(typeof e);
  if (e.constructor.name === "AsyncFunction")
    throw new cg("AsyncFunction");
}
ii.exports = Yd;
ii.exports.errorCodes = sn;
ii.exports.fastify = Yd;
ii.exports.default = Yd;
var bM = ii.exports;
const _M = /* @__PURE__ */ si(bM);
function eE(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: EM } = Object.prototype, { getPrototypeOf: Xd } = Object, Ma = /* @__PURE__ */ ((e) => (t) => {
  const r = EM.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Qt = (e) => (e = e.toLowerCase(), (t) => Ma(t) === e), za = (e) => (t) => typeof t === e, { isArray: fs } = Array, Ks = za("undefined");
function xM(e) {
  return e !== null && !Ks(e) && e.constructor !== null && !Ks(e.constructor) && Lt(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const tE = Qt("ArrayBuffer");
function SM(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && tE(e.buffer), t;
}
const wM = za("string"), Lt = za("function"), rE = za("number"), Ua = (e) => e !== null && typeof e == "object", RM = (e) => e === !0 || e === !1, wo = (e) => {
  if (Ma(e) !== "object")
    return !1;
  const t = Xd(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, $M = Qt("Date"), TM = Qt("File"), OM = Qt("Blob"), PM = Qt("FileList"), CM = (e) => Ua(e) && Lt(e.pipe), IM = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Lt(e.append) && ((t = Ma(e)) === "formdata" || // detect form-data instance
  t === "object" && Lt(e.toString) && e.toString() === "[object FormData]"));
}, NM = Qt("URLSearchParams"), [AM, kM, LM, jM] = ["ReadableStream", "Request", "Response", "Headers"].map(Qt), DM = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function bi(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, s;
  if (typeof e != "object" && (e = [e]), fs(e))
    for (n = 0, s = e.length; n < s; n++)
      t.call(null, e[n], n, e);
  else {
    const i = r ? Object.getOwnPropertyNames(e) : Object.keys(e), o = i.length;
    let a;
    for (n = 0; n < o; n++)
      a = i[n], t.call(null, e[a], a, e);
  }
}
function nE(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, s;
  for (; n-- > 0; )
    if (s = r[n], t === s.toLowerCase())
      return s;
  return null;
}
const an = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, sE = (e) => !Ks(e) && e !== an;
function Pu() {
  const { caseless: e } = sE(this) && this || {}, t = {}, r = (n, s) => {
    const i = e && nE(t, s) || s;
    wo(t[i]) && wo(n) ? t[i] = Pu(t[i], n) : wo(n) ? t[i] = Pu({}, n) : fs(n) ? t[i] = n.slice() : t[i] = n;
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && bi(arguments[n], r);
  return t;
}
const FM = (e, t, r, { allOwnKeys: n } = {}) => (bi(t, (s, i) => {
  r && Lt(s) ? e[i] = eE(s, r) : e[i] = s;
}, { allOwnKeys: n }), e), MM = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), zM = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, UM = (e, t, r, n) => {
  let s, i, o;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (s = Object.getOwnPropertyNames(e), i = s.length; i-- > 0; )
      o = s[i], (!n || n(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = r !== !1 && Xd(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, qM = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, HM = (e) => {
  if (!e) return null;
  if (fs(e)) return e;
  let t = e.length;
  if (!rE(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, BM = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Xd(Uint8Array)), VM = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const i = s.value;
    t.call(e, i[0], i[1]);
  }
}, GM = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, WM = Qt("HTMLFormElement"), KM = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, s) {
    return n.toUpperCase() + s;
  }
), dg = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), JM = Qt("RegExp"), iE = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  bi(r, (s, i) => {
    let o;
    (o = t(s, i, e)) !== !1 && (n[i] = o || s);
  }), Object.defineProperties(e, n);
}, YM = (e) => {
  iE(e, (t, r) => {
    if (Lt(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (Lt(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, XM = (e, t) => {
  const r = {}, n = (s) => {
    s.forEach((i) => {
      r[i] = !0;
    });
  };
  return fs(e) ? n(e) : n(String(e).split(t)), r;
}, ZM = () => {
}, QM = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function ez(e) {
  return !!(e && Lt(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const tz = (e) => {
  const t = new Array(10), r = (n, s) => {
    if (Ua(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[s] = n;
        const i = fs(n) ? [] : {};
        return bi(n, (o, a) => {
          const c = r(o, s + 1);
          !Ks(c) && (i[a] = c);
        }), t[s] = void 0, i;
      }
    }
    return n;
  };
  return r(e, 0);
}, rz = Qt("AsyncFunction"), nz = (e) => e && (Ua(e) || Lt(e)) && Lt(e.then) && Lt(e.catch), oE = ((e, t) => e ? setImmediate : t ? ((r, n) => (an.addEventListener("message", ({ source: s, data: i }) => {
  s === an && i === r && n.length && n.shift()();
}, !1), (s) => {
  n.push(s), an.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Lt(an.postMessage)
), sz = typeof queueMicrotask < "u" ? queueMicrotask.bind(an) : typeof process < "u" && process.nextTick || oE, B = {
  isArray: fs,
  isArrayBuffer: tE,
  isBuffer: xM,
  isFormData: IM,
  isArrayBufferView: SM,
  isString: wM,
  isNumber: rE,
  isBoolean: RM,
  isObject: Ua,
  isPlainObject: wo,
  isReadableStream: AM,
  isRequest: kM,
  isResponse: LM,
  isHeaders: jM,
  isUndefined: Ks,
  isDate: $M,
  isFile: TM,
  isBlob: OM,
  isRegExp: JM,
  isFunction: Lt,
  isStream: CM,
  isURLSearchParams: NM,
  isTypedArray: BM,
  isFileList: PM,
  forEach: bi,
  merge: Pu,
  extend: FM,
  trim: DM,
  stripBOM: MM,
  inherits: zM,
  toFlatObject: UM,
  kindOf: Ma,
  kindOfTest: Qt,
  endsWith: qM,
  toArray: HM,
  forEachEntry: VM,
  matchAll: GM,
  isHTMLForm: WM,
  hasOwnProperty: dg,
  hasOwnProp: dg,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: iE,
  freezeMethods: YM,
  toObjectSet: XM,
  toCamelCase: KM,
  noop: ZM,
  toFiniteNumber: QM,
  findKey: nE,
  global: an,
  isContextDefined: sE,
  isSpecCompliantForm: ez,
  toJSONObject: tz,
  isAsyncFn: rz,
  isThenable: nz,
  setImmediate: oE,
  asap: sz
};
function se(e, t, r, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), s && (this.response = s, this.status = s.status ? s.status : null);
}
B.inherits(se, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: B.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const aE = se.prototype, cE = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  cE[e] = { value: e };
});
Object.defineProperties(se, cE);
Object.defineProperty(aE, "isAxiosError", { value: !0 });
se.from = (e, t, r, n, s, i) => {
  const o = Object.create(aE);
  return B.toFlatObject(e, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), se.call(o, e.message, t, r, n, s), o.cause = e, o.name = e.name, i && Object.assign(o, i), o;
};
var lE = zt.Stream, iz = gn, oz = er;
function er() {
  this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
}
iz.inherits(er, lE);
er.create = function(e, t) {
  var r = new this();
  t = t || {};
  for (var n in t)
    r[n] = t[n];
  r.source = e;
  var s = e.emit;
  return e.emit = function() {
    return r._handleEmit(arguments), s.apply(e, arguments);
  }, e.on("error", function() {
  }), r.pauseStream && e.pause(), r;
};
Object.defineProperty(er.prototype, "readable", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.source.readable;
  }
});
er.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
er.prototype.resume = function() {
  this._released || this.release(), this.source.resume();
};
er.prototype.pause = function() {
  this.source.pause();
};
er.prototype.release = function() {
  this._released = !0, this._bufferedEvents.forEach((function(e) {
    this.emit.apply(this, e);
  }).bind(this)), this._bufferedEvents = [];
};
er.prototype.pipe = function() {
  var e = lE.prototype.pipe.apply(this, arguments);
  return this.resume(), e;
};
er.prototype._handleEmit = function(e) {
  if (this._released) {
    this.emit.apply(this, e);
    return;
  }
  e[0] === "data" && (this.dataSize += e[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(e);
};
er.prototype._checkIfMaxDataSizeExceeded = function() {
  if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
    this._maxDataSizeExceeded = !0;
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(e));
  }
};
var az = gn, uE = zt.Stream, pg = oz, cz = He;
function He() {
  this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
}
az.inherits(He, uE);
He.create = function(e) {
  var t = new this();
  e = e || {};
  for (var r in e)
    t[r] = e[r];
  return t;
};
He.isStreamLike = function(e) {
  return typeof e != "function" && typeof e != "string" && typeof e != "boolean" && typeof e != "number" && !Buffer.isBuffer(e);
};
He.prototype.append = function(e) {
  var t = He.isStreamLike(e);
  if (t) {
    if (!(e instanceof pg)) {
      var r = pg.create(e, {
        maxDataSize: 1 / 0,
        pauseStream: this.pauseStreams
      });
      e.on("data", this._checkDataSize.bind(this)), e = r;
    }
    this._handleErrors(e), this.pauseStreams && e.pause();
  }
  return this._streams.push(e), this;
};
He.prototype.pipe = function(e, t) {
  return uE.prototype.pipe.call(this, e, t), this.resume(), e;
};
He.prototype._getNext = function() {
  if (this._currentStream = null, this._insideLoop) {
    this._pendingNext = !0;
    return;
  }
  this._insideLoop = !0;
  try {
    do
      this._pendingNext = !1, this._realGetNext();
    while (this._pendingNext);
  } finally {
    this._insideLoop = !1;
  }
};
He.prototype._realGetNext = function() {
  var e = this._streams.shift();
  if (typeof e > "u") {
    this.end();
    return;
  }
  if (typeof e != "function") {
    this._pipeNext(e);
    return;
  }
  var t = e;
  t((function(r) {
    var n = He.isStreamLike(r);
    n && (r.on("data", this._checkDataSize.bind(this)), this._handleErrors(r)), this._pipeNext(r);
  }).bind(this));
};
He.prototype._pipeNext = function(e) {
  this._currentStream = e;
  var t = He.isStreamLike(e);
  if (t) {
    e.on("end", this._getNext.bind(this)), e.pipe(this, { end: !1 });
    return;
  }
  var r = e;
  this.write(r), this._getNext();
};
He.prototype._handleErrors = function(e) {
  var t = this;
  e.on("error", function(r) {
    t._emitError(r);
  });
};
He.prototype.write = function(e) {
  this.emit("data", e);
};
He.prototype.pause = function() {
  this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
};
He.prototype.resume = function() {
  this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
};
He.prototype.end = function() {
  this._reset(), this.emit("end");
};
He.prototype.destroy = function() {
  this._reset(), this.emit("close");
};
He.prototype._reset = function() {
  this.writable = !1, this._streams = [], this._currentStream = null;
};
He.prototype._checkDataSize = function() {
  if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(e));
  }
};
He.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var e = this;
  this._streams.forEach(function(t) {
    t.dataSize && (e.dataSize += t.dataSize);
  }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
};
He.prototype._emitError = function(e) {
  this._reset(), this.emit("error", e);
};
var fE = {};
const lz = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: !0
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: !0
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: !0
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: !1
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/calendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: !0
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: !0
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: !0
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: !0
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/csvm+json": {
    source: "iana",
    compressible: !0
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: !0
  },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: !0
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: !0
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: !1
  },
  "application/edifact": {
    source: "iana",
    compressible: !1
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/elm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: !0
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fido.trusted-apps+json": {
    compressible: !0
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: !1
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: !0
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: !0
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: !0
  },
  "application/jrd+json": {
    source: "iana",
    compressible: !0
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: !1
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: !0
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: !0
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: !1
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: !1
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: !0
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: !0,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: !0
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: !0
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: !0
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sarif+json": {
    source: "iana",
    compressible: !0
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/scim+json": {
    source: "iana",
    compressible: !0
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: !0
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: !0
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: !0
  },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: !0
  },
  "application/taxii+json": {
    source: "iana",
    compressible: !0
  },
  "application/td+json": {
    source: "iana",
    compressible: !0
  },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: !0
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: !0,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: !1,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+json": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: !1,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-outlook": {
    compressible: !1,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: !0
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: !0
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: !1,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: !1
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: !0,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: !0
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: !1
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: !0,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: !0,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: !0,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: !0,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: !0,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: !0,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: !0,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: !0
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: !0
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: !1,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: !1
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: !1,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: !1
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: !1
  },
  "audio/vorbis": {
    source: "iana",
    compressible: !1
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: !1,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: !1,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: !1,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: !1
  },
  "image/png": {
    source: "iana",
    compressible: !1,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: !0,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: !1
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: !1
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: !0
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: !1
  },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: !1
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: !1
  },
  "multipart/form-data": {
    source: "iana",
    compressible: !1
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: !1
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: !1
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: !0
  },
  "text/cmd": {
    compressible: !0
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: !0
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: !0,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: !0,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: !0,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: !0
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: !0
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: !0,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: !0,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: !0,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: !0,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: !0,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: !0
  },
  "x-shader/x-vertex": {
    compressible: !0
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var uz = lz;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(e) {
  var t = uz, r = $t.extname, n = /^\s*([^;\s]*)(?:;|\s|$)/, s = /^text\//i;
  e.charset = i, e.charsets = { lookup: i }, e.contentType = o, e.extension = a, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = c, e.types = /* @__PURE__ */ Object.create(null), f(e.extensions, e.types);
  function i(l) {
    if (!l || typeof l != "string")
      return !1;
    var d = n.exec(l), g = d && t[d[1].toLowerCase()];
    return g && g.charset ? g.charset : d && s.test(d[1]) ? "UTF-8" : !1;
  }
  function o(l) {
    if (!l || typeof l != "string")
      return !1;
    var d = l.indexOf("/") === -1 ? e.lookup(l) : l;
    if (!d)
      return !1;
    if (d.indexOf("charset") === -1) {
      var g = e.charset(d);
      g && (d += "; charset=" + g.toLowerCase());
    }
    return d;
  }
  function a(l) {
    if (!l || typeof l != "string")
      return !1;
    var d = n.exec(l), g = d && e.extensions[d[1].toLowerCase()];
    return !g || !g.length ? !1 : g[0];
  }
  function c(l) {
    if (!l || typeof l != "string")
      return !1;
    var d = r("x." + l).toLowerCase().substr(1);
    return d && e.types[d] || !1;
  }
  function f(l, d) {
    var g = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function(u) {
      var h = t[u], b = h.extensions;
      if (!(!b || !b.length)) {
        l[u] = b;
        for (var m = 0; m < b.length; m++) {
          var v = b[m];
          if (d[v]) {
            var y = g.indexOf(t[d[v]].source), _ = g.indexOf(h.source);
            if (d[v] !== "application/octet-stream" && (y > _ || y === _ && d[v].substr(0, 12) === "application/"))
              continue;
          }
          d[v] = u;
        }
      }
    });
  }
})(fE);
var fz = dz;
function dz(e) {
  var t = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  t ? t(e) : setTimeout(e, 0);
}
var hg = fz, dE = pz;
function pz(e) {
  var t = !1;
  return hg(function() {
    t = !0;
  }), function(n, s) {
    t ? e(n, s) : hg(function() {
      e(n, s);
    });
  };
}
var pE = hz;
function hz(e) {
  Object.keys(e.jobs).forEach(mz.bind(e)), e.jobs = {};
}
function mz(e) {
  typeof this.jobs[e] == "function" && this.jobs[e]();
}
var mg = dE, yz = pE, hE = gz;
function gz(e, t, r, n) {
  var s = r.keyedList ? r.keyedList[r.index] : r.index;
  r.jobs[s] = vz(t, s, e[s], function(i, o) {
    s in r.jobs && (delete r.jobs[s], i ? yz(r) : r.results[s] = o, n(i, r.results));
  });
}
function vz(e, t, r, n) {
  var s;
  return e.length == 2 ? s = e(r, mg(n)) : s = e(r, t, mg(n)), s;
}
var mE = bz;
function bz(e, t) {
  var r = !Array.isArray(e), n = {
    index: 0,
    keyedList: r || t ? Object.keys(e) : null,
    jobs: {},
    results: r ? {} : [],
    size: r ? Object.keys(e).length : e.length
  };
  return t && n.keyedList.sort(r ? t : function(s, i) {
    return t(e[s], e[i]);
  }), n;
}
var _z = pE, Ez = dE, yE = xz;
function xz(e) {
  Object.keys(this.jobs).length && (this.index = this.size, _z(this), Ez(e)(null, this.results));
}
var Sz = hE, wz = mE, Rz = yE, $z = Tz;
function Tz(e, t, r) {
  for (var n = wz(e); n.index < (n.keyedList || e).length; )
    Sz(e, t, n, function(s, i) {
      if (s) {
        r(s, i);
        return;
      }
      if (Object.keys(n.jobs).length === 0) {
        r(null, n.results);
        return;
      }
    }), n.index++;
  return Rz.bind(n, r);
}
var qa = { exports: {} }, yg = hE, Oz = mE, Pz = yE;
qa.exports = Cz;
qa.exports.ascending = gE;
qa.exports.descending = Iz;
function Cz(e, t, r, n) {
  var s = Oz(e, r);
  return yg(e, t, s, function i(o, a) {
    if (o) {
      n(o, a);
      return;
    }
    if (s.index++, s.index < (s.keyedList || e).length) {
      yg(e, t, s, i);
      return;
    }
    n(null, s.results);
  }), Pz.bind(s, n);
}
function gE(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Iz(e, t) {
  return -1 * gE(e, t);
}
var vE = qa.exports, Nz = vE, Az = kz;
function kz(e, t, r) {
  return Nz(e, t, null, r);
}
var Lz = {
  parallel: $z,
  serial: Az,
  serialOrdered: vE
}, bE = Object, jz = Error, Dz = EvalError, Fz = RangeError, Mz = ReferenceError, zz = SyntaxError, Zd = TypeError, Uz = URIError, qz = Math.abs, Hz = Math.floor, Bz = Math.max, Vz = Math.min, Gz = Math.pow, Wz = Math.round, Kz = Number.isNaN || function(t) {
  return t !== t;
}, Jz = Kz, Yz = function(t) {
  return Jz(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, Xz = Object.getOwnPropertyDescriptor, Ro = Xz;
if (Ro)
  try {
    Ro([], "length");
  } catch {
    Ro = null;
  }
var _E = Ro, $o = Object.defineProperty || !1;
if ($o)
  try {
    $o({}, "a", { value: 1 });
  } catch {
    $o = !1;
  }
var Zz = $o, wl, gg;
function EE() {
  return gg || (gg = 1, wl = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = Symbol("test"), n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var s = 42;
    t[r] = s;
    for (var i in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(t);
    if (o.length !== 1 || o[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (a.value !== s || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), wl;
}
var Rl, vg;
function Qz() {
  if (vg) return Rl;
  vg = 1;
  var e = typeof Symbol < "u" && Symbol, t = EE();
  return Rl = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Rl;
}
var $l, bg;
function xE() {
  return bg || (bg = 1, $l = typeof Reflect < "u" && Reflect.getPrototypeOf || null), $l;
}
var Tl, _g;
function SE() {
  if (_g) return Tl;
  _g = 1;
  var e = bE;
  return Tl = e.getPrototypeOf || null, Tl;
}
var Ol, Eg;
function eU() {
  if (Eg) return Ol;
  Eg = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", s = function(c, f) {
    for (var l = [], d = 0; d < c.length; d += 1)
      l[d] = c[d];
    for (var g = 0; g < f.length; g += 1)
      l[g + c.length] = f[g];
    return l;
  }, i = function(c, f) {
    for (var l = [], d = f, g = 0; d < c.length; d += 1, g += 1)
      l[g] = c[d];
    return l;
  }, o = function(a, c) {
    for (var f = "", l = 0; l < a.length; l += 1)
      f += a[l], l + 1 < a.length && (f += c);
    return f;
  };
  return Ol = function(c) {
    var f = this;
    if (typeof f != "function" || t.apply(f) !== n)
      throw new TypeError(e + f);
    for (var l = i(arguments, 1), d, g = function() {
      if (this instanceof d) {
        var m = f.apply(
          this,
          s(l, arguments)
        );
        return Object(m) === m ? m : this;
      }
      return f.apply(
        c,
        s(l, arguments)
      );
    }, p = r(0, f.length - l.length), u = [], h = 0; h < p; h++)
      u[h] = "$" + h;
    if (d = Function("binder", "return function (" + o(u, ",") + "){ return binder.apply(this,arguments); }")(g), f.prototype) {
      var b = function() {
      };
      b.prototype = f.prototype, d.prototype = new b(), b.prototype = null;
    }
    return d;
  }, Ol;
}
var Pl, xg;
function Ha() {
  if (xg) return Pl;
  xg = 1;
  var e = eU();
  return Pl = Function.prototype.bind || e, Pl;
}
var Cl, Sg;
function Qd() {
  return Sg || (Sg = 1, Cl = Function.prototype.call), Cl;
}
var Il, wg;
function wE() {
  return wg || (wg = 1, Il = Function.prototype.apply), Il;
}
var Nl, Rg;
function tU() {
  return Rg || (Rg = 1, Nl = typeof Reflect < "u" && Reflect && Reflect.apply), Nl;
}
var Al, $g;
function rU() {
  if ($g) return Al;
  $g = 1;
  var e = Ha(), t = wE(), r = Qd(), n = tU();
  return Al = n || e.call(r, t), Al;
}
var kl, Tg;
function nU() {
  if (Tg) return kl;
  Tg = 1;
  var e = Ha(), t = Zd, r = Qd(), n = rU();
  return kl = function(i) {
    if (i.length < 1 || typeof i[0] != "function")
      throw new t("a function is required");
    return n(e, r, i);
  }, kl;
}
var Ll, Og;
function sU() {
  if (Og) return Ll;
  Og = 1;
  var e = nU(), t = _E, r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), s = Object, i = s.getPrototypeOf;
  return Ll = n && typeof n.get == "function" ? e([n.get]) : typeof i == "function" ? (
    /** @type {import('./get')} */
    function(a) {
      return i(a == null ? a : s(a));
    }
  ) : !1, Ll;
}
var jl, Pg;
function iU() {
  if (Pg) return jl;
  Pg = 1;
  var e = xE(), t = SE(), r = sU();
  return jl = e ? function(s) {
    return e(s);
  } : t ? function(s) {
    if (!s || typeof s != "object" && typeof s != "function")
      throw new TypeError("getProto: not an object");
    return t(s);
  } : r ? function(s) {
    return r(s);
  } : null, jl;
}
var Dl, Cg;
function RE() {
  if (Cg) return Dl;
  Cg = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = Ha();
  return Dl = r.call(e, t), Dl;
}
var ge, oU = bE, aU = jz, cU = Dz, lU = Fz, uU = Mz, Zn = zz, Vn = Zd, fU = Uz, dU = qz, pU = Hz, hU = Bz, mU = Vz, yU = Gz, gU = Wz, vU = Yz, $E = Function, Fl = function(e) {
  try {
    return $E('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Js = _E, bU = Zz, Ml = function() {
  throw new Vn();
}, _U = Js ? function() {
  try {
    return arguments.callee, Ml;
  } catch {
    try {
      return Js(arguments, "callee").get;
    } catch {
      return Ml;
    }
  }
}() : Ml, An = Qz()(), rt = iU(), EU = SE(), xU = xE(), TE = wE(), _i = Qd(), Ln = {}, SU = typeof Uint8Array > "u" || !rt ? ge : rt(Uint8Array), ln = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? ge : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ge : ArrayBuffer,
  "%ArrayIteratorPrototype%": An && rt ? rt([][Symbol.iterator]()) : ge,
  "%AsyncFromSyncIteratorPrototype%": ge,
  "%AsyncFunction%": Ln,
  "%AsyncGenerator%": Ln,
  "%AsyncGeneratorFunction%": Ln,
  "%AsyncIteratorPrototype%": Ln,
  "%Atomics%": typeof Atomics > "u" ? ge : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ge : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ge : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ge : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ge : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": aU,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": cU,
  "%Float16Array%": typeof Float16Array > "u" ? ge : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? ge : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ge : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ge : FinalizationRegistry,
  "%Function%": $E,
  "%GeneratorFunction%": Ln,
  "%Int8Array%": typeof Int8Array > "u" ? ge : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ge : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ge : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": An && rt ? rt(rt([][Symbol.iterator]())) : ge,
  "%JSON%": typeof JSON == "object" ? JSON : ge,
  "%Map%": typeof Map > "u" ? ge : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !An || !rt ? ge : rt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": oU,
  "%Object.getOwnPropertyDescriptor%": Js,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ge : Promise,
  "%Proxy%": typeof Proxy > "u" ? ge : Proxy,
  "%RangeError%": lU,
  "%ReferenceError%": uU,
  "%Reflect%": typeof Reflect > "u" ? ge : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ge : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !An || !rt ? ge : rt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ge : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": An && rt ? rt(""[Symbol.iterator]()) : ge,
  "%Symbol%": An ? Symbol : ge,
  "%SyntaxError%": Zn,
  "%ThrowTypeError%": _U,
  "%TypedArray%": SU,
  "%TypeError%": Vn,
  "%Uint8Array%": typeof Uint8Array > "u" ? ge : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ge : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ge : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ge : Uint32Array,
  "%URIError%": fU,
  "%WeakMap%": typeof WeakMap > "u" ? ge : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ge : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ge : WeakSet,
  "%Function.prototype.call%": _i,
  "%Function.prototype.apply%": TE,
  "%Object.defineProperty%": bU,
  "%Object.getPrototypeOf%": EU,
  "%Math.abs%": dU,
  "%Math.floor%": pU,
  "%Math.max%": hU,
  "%Math.min%": mU,
  "%Math.pow%": yU,
  "%Math.round%": gU,
  "%Math.sign%": vU,
  "%Reflect.getPrototypeOf%": xU
};
if (rt)
  try {
    null.error;
  } catch (e) {
    var wU = rt(rt(e));
    ln["%Error.prototype%"] = wU;
  }
var RU = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Fl("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Fl("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Fl("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var n = e("%AsyncGeneratorFunction%");
    n && (r = n.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var s = e("%AsyncGenerator%");
    s && rt && (r = rt(s.prototype));
  }
  return ln[t] = r, r;
}, Ig = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Ei = Ha(), Wo = RE(), $U = Ei.call(_i, Array.prototype.concat), TU = Ei.call(TE, Array.prototype.splice), Ng = Ei.call(_i, String.prototype.replace), Ko = Ei.call(_i, String.prototype.slice), OU = Ei.call(_i, RegExp.prototype.exec), PU = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, CU = /\\(\\)?/g, IU = function(t) {
  var r = Ko(t, 0, 1), n = Ko(t, -1);
  if (r === "%" && n !== "%")
    throw new Zn("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && r !== "%")
    throw new Zn("invalid intrinsic syntax, expected opening `%`");
  var s = [];
  return Ng(t, PU, function(i, o, a, c) {
    s[s.length] = a ? Ng(c, CU, "$1") : o || i;
  }), s;
}, NU = function(t, r) {
  var n = t, s;
  if (Wo(Ig, n) && (s = Ig[n], n = "%" + s[0] + "%"), Wo(ln, n)) {
    var i = ln[n];
    if (i === Ln && (i = RU(n)), typeof i > "u" && !r)
      throw new Vn("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: s,
      name: n,
      value: i
    };
  }
  throw new Zn("intrinsic " + t + " does not exist!");
}, AU = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Vn("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Vn('"allowMissing" argument must be a boolean');
  if (OU(/^%?[^%]*%?$/, t) === null)
    throw new Zn("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = IU(t), s = n.length > 0 ? n[0] : "", i = NU("%" + s + "%", r), o = i.name, a = i.value, c = !1, f = i.alias;
  f && (s = f[0], TU(n, $U([0, 1], f)));
  for (var l = 1, d = !0; l < n.length; l += 1) {
    var g = n[l], p = Ko(g, 0, 1), u = Ko(g, -1);
    if ((p === '"' || p === "'" || p === "`" || u === '"' || u === "'" || u === "`") && p !== u)
      throw new Zn("property names with quotes must have matching quotes");
    if ((g === "constructor" || !d) && (c = !0), s += "." + g, o = "%" + s + "%", Wo(ln, o))
      a = ln[o];
    else if (a != null) {
      if (!(g in a)) {
        if (!r)
          throw new Vn("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Js && l + 1 >= n.length) {
        var h = Js(a, g);
        d = !!h, d && "get" in h && !("originalValue" in h.get) ? a = h.get : a = a[g];
      } else
        d = Wo(a, g), a = a[g];
      d && !c && (ln[o] = a);
    }
  }
  return a;
}, zl, Ag;
function kU() {
  if (Ag) return zl;
  Ag = 1;
  var e = EE();
  return zl = function() {
    return e() && !!Symbol.toStringTag;
  }, zl;
}
var LU = AU, kg = LU("%Object.defineProperty%", !0), jU = kU()(), DU = RE(), FU = Zd, no = jU ? Symbol.toStringTag : null, MU = function(t, r) {
  var n = arguments.length > 2 && !!arguments[2] && arguments[2].force, s = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof n < "u" && typeof n != "boolean" || typeof s < "u" && typeof s != "boolean")
    throw new FU("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  no && (n || !DU(t, no)) && (kg ? kg(t, no, {
    configurable: !s,
    enumerable: !1,
    value: r,
    writable: !1
  }) : t[no] = r);
}, zU = function(e, t) {
  return Object.keys(t).forEach(function(r) {
    e[r] = e[r] || t[r];
  }), e;
}, ep = cz, UU = gn, Ul = $t, qU = qu, HU = Hu, BU = ni.parse, VU = gt, GU = zt.Stream, ql = fE, WU = Lz, KU = MU, Cu = zU, JU = xe;
UU.inherits(xe, ep);
function xe(e) {
  if (!(this instanceof xe))
    return new xe(e);
  this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], ep.call(this), e = e || {};
  for (var t in e)
    this[t] = e[t];
}
xe.LINE_BREAK = `\r
`;
xe.DEFAULT_CONTENT_TYPE = "application/octet-stream";
xe.prototype.append = function(e, t, r) {
  r = r || {}, typeof r == "string" && (r = { filename: r });
  var n = ep.prototype.append.bind(this);
  if (typeof t == "number" && (t = "" + t), Array.isArray(t)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var s = this._multiPartHeader(e, t, r), i = this._multiPartFooter();
  n(s), n(t), n(i), this._trackLength(s, t, r);
};
xe.prototype._trackLength = function(e, t, r) {
  var n = 0;
  r.knownLength != null ? n += +r.knownLength : Buffer.isBuffer(t) ? n = t.length : typeof t == "string" && (n = Buffer.byteLength(t)), this._valueLength += n, this._overheadLength += Buffer.byteLength(e) + xe.LINE_BREAK.length, !(!t || !t.path && !(t.readable && Object.prototype.hasOwnProperty.call(t, "httpVersion")) && !(t instanceof GU)) && (r.knownLength || this._valuesToMeasure.push(t));
};
xe.prototype._lengthRetriever = function(e, t) {
  Object.prototype.hasOwnProperty.call(e, "fd") ? e.end != null && e.end != 1 / 0 && e.start != null ? t(null, e.end + 1 - (e.start ? e.start : 0)) : VU.stat(e.path, function(r, n) {
    var s;
    if (r) {
      t(r);
      return;
    }
    s = n.size - (e.start ? e.start : 0), t(null, s);
  }) : Object.prototype.hasOwnProperty.call(e, "httpVersion") ? t(null, +e.headers["content-length"]) : Object.prototype.hasOwnProperty.call(e, "httpModule") ? (e.on("response", function(r) {
    e.pause(), t(null, +r.headers["content-length"]);
  }), e.resume()) : t("Unknown stream");
};
xe.prototype._multiPartHeader = function(e, t, r) {
  if (typeof r.header == "string")
    return r.header;
  var n = this._getContentDisposition(t, r), s = this._getContentType(t, r), i = "", o = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + e + '"'].concat(n || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(s || [])
  };
  typeof r.header == "object" && Cu(o, r.header);
  var a;
  for (var c in o)
    if (Object.prototype.hasOwnProperty.call(o, c)) {
      if (a = o[c], a == null)
        continue;
      Array.isArray(a) || (a = [a]), a.length && (i += c + ": " + a.join("; ") + xe.LINE_BREAK);
    }
  return "--" + this.getBoundary() + xe.LINE_BREAK + i + xe.LINE_BREAK;
};
xe.prototype._getContentDisposition = function(e, t) {
  var r, n;
  return typeof t.filepath == "string" ? r = Ul.normalize(t.filepath).replace(/\\/g, "/") : t.filename || e.name || e.path ? r = Ul.basename(t.filename || e.name || e.path) : e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = Ul.basename(e.client._httpMessage.path || "")), r && (n = 'filename="' + r + '"'), n;
};
xe.prototype._getContentType = function(e, t) {
  var r = t.contentType;
  return !r && e.name && (r = ql.lookup(e.name)), !r && e.path && (r = ql.lookup(e.path)), !r && e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = e.headers["content-type"]), !r && (t.filepath || t.filename) && (r = ql.lookup(t.filepath || t.filename)), !r && typeof e == "object" && (r = xe.DEFAULT_CONTENT_TYPE), r;
};
xe.prototype._multiPartFooter = function() {
  return (function(e) {
    var t = xe.LINE_BREAK, r = this._streams.length === 0;
    r && (t += this._lastBoundary()), e(t);
  }).bind(this);
};
xe.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + xe.LINE_BREAK;
};
xe.prototype.getHeaders = function(e) {
  var t, r = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (r[t.toLowerCase()] = e[t]);
  return r;
};
xe.prototype.setBoundary = function(e) {
  this._boundary = e;
};
xe.prototype.getBoundary = function() {
  return this._boundary || this._generateBoundary(), this._boundary;
};
xe.prototype.getBuffer = function() {
  for (var e = new Buffer.alloc(0), t = this.getBoundary(), r = 0, n = this._streams.length; r < n; r++)
    typeof this._streams[r] != "function" && (Buffer.isBuffer(this._streams[r]) ? e = Buffer.concat([e, this._streams[r]]) : e = Buffer.concat([e, Buffer.from(this._streams[r])]), (typeof this._streams[r] != "string" || this._streams[r].substring(2, t.length + 2) !== t) && (e = Buffer.concat([e, Buffer.from(xe.LINE_BREAK)])));
  return Buffer.concat([e, Buffer.from(this._lastBoundary())]);
};
xe.prototype._generateBoundary = function() {
  for (var e = "--------------------------", t = 0; t < 24; t++)
    e += Math.floor(Math.random() * 10).toString(16);
  this._boundary = e;
};
xe.prototype.getLengthSync = function() {
  var e = this._overheadLength + this._valueLength;
  return this._streams.length && (e += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), e;
};
xe.prototype.hasKnownLength = function() {
  var e = !0;
  return this._valuesToMeasure.length && (e = !1), e;
};
xe.prototype.getLength = function(e) {
  var t = this._overheadLength + this._valueLength;
  if (this._streams.length && (t += this._lastBoundary().length), !this._valuesToMeasure.length) {
    process.nextTick(e.bind(this, null, t));
    return;
  }
  WU.parallel(this._valuesToMeasure, this._lengthRetriever, function(r, n) {
    if (r) {
      e(r);
      return;
    }
    n.forEach(function(s) {
      t += s;
    }), e(null, t);
  });
};
xe.prototype.submit = function(e, t) {
  var r, n, s = { method: "post" };
  return typeof e == "string" ? (e = BU(e), n = Cu({
    port: e.port,
    path: e.pathname,
    host: e.hostname,
    protocol: e.protocol
  }, s)) : (n = Cu(e, s), n.port || (n.port = n.protocol == "https:" ? 443 : 80)), n.headers = this.getHeaders(e.headers), n.protocol == "https:" ? r = HU.request(n) : r = qU.request(n), this.getLength((function(i, o) {
    if (i && i !== "Unknown stream") {
      this._error(i);
      return;
    }
    if (o && r.setHeader("Content-Length", o), this.pipe(r), t) {
      var a, c = function(f, l) {
        return r.removeListener("error", c), r.removeListener("response", a), t.call(this, f, l);
      };
      a = c.bind(this, null), r.on("error", c), r.on("response", a);
    }
  }).bind(this)), r;
};
xe.prototype._error = function(e) {
  this.error || (this.error = e, this.pause(), this.emit("error", e));
};
xe.prototype.toString = function() {
  return "[object FormData]";
};
KU(xe, "FormData");
const OE = /* @__PURE__ */ si(JU);
function Iu(e) {
  return B.isPlainObject(e) || B.isArray(e);
}
function PE(e) {
  return B.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Lg(e, t, r) {
  return e ? e.concat(t).map(function(s, i) {
    return s = PE(s), !r && i ? "[" + s + "]" : s;
  }).join(r ? "." : "") : t;
}
function YU(e) {
  return B.isArray(e) && !e.some(Iu);
}
const XU = B.toFlatObject(B, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Ba(e, t, r) {
  if (!B.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (OE || FormData)(), r = B.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, b) {
    return !B.isUndefined(b[h]);
  });
  const n = r.metaTokens, s = r.visitor || l, i = r.dots, o = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && B.isSpecCompliantForm(t);
  if (!B.isFunction(s))
    throw new TypeError("visitor must be a function");
  function f(u) {
    if (u === null) return "";
    if (B.isDate(u))
      return u.toISOString();
    if (!c && B.isBlob(u))
      throw new se("Blob is not supported. Use a Buffer instead.");
    return B.isArrayBuffer(u) || B.isTypedArray(u) ? c && typeof Blob == "function" ? new Blob([u]) : Buffer.from(u) : u;
  }
  function l(u, h, b) {
    let m = u;
    if (u && !b && typeof u == "object") {
      if (B.endsWith(h, "{}"))
        h = n ? h : h.slice(0, -2), u = JSON.stringify(u);
      else if (B.isArray(u) && YU(u) || (B.isFileList(u) || B.endsWith(h, "[]")) && (m = B.toArray(u)))
        return h = PE(h), m.forEach(function(y, _) {
          !(B.isUndefined(y) || y === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Lg([h], _, i) : o === null ? h : h + "[]",
            f(y)
          );
        }), !1;
    }
    return Iu(u) ? !0 : (t.append(Lg(b, h, i), f(u)), !1);
  }
  const d = [], g = Object.assign(XU, {
    defaultVisitor: l,
    convertValue: f,
    isVisitable: Iu
  });
  function p(u, h) {
    if (!B.isUndefined(u)) {
      if (d.indexOf(u) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      d.push(u), B.forEach(u, function(m, v) {
        (!(B.isUndefined(m) || m === null) && s.call(
          t,
          m,
          B.isString(v) ? v.trim() : v,
          h,
          g
        )) === !0 && p(m, h ? h.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!B.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function jg(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function CE(e, t) {
  this._pairs = [], e && Ba(e, this, t);
}
const IE = CE.prototype;
IE.append = function(t, r) {
  this._pairs.push([t, r]);
};
IE.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, jg);
  } : jg;
  return this._pairs.map(function(s) {
    return r(s[0]) + "=" + r(s[1]);
  }, "").join("&");
};
function ZU(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function tp(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || ZU;
  B.isFunction(r) && (r = {
    serialize: r
  });
  const s = r && r.serialize;
  let i;
  if (s ? i = s(t, r) : i = B.isURLSearchParams(t) ? t.toString() : new CE(t, r).toString(n), i) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
class Dg {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    B.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const rp = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, QU = ni.URLSearchParams, Hl = "abcdefghijklmnopqrstuvwxyz", Fg = "0123456789", NE = {
  DIGIT: Fg,
  ALPHA: Hl,
  ALPHA_DIGIT: Hl + Hl.toUpperCase() + Fg
}, eq = (e = 16, t = NE.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t, s = new Uint32Array(e);
  bv.randomFillSync(s);
  for (let i = 0; i < e; i++)
    r += t[s[i] % n];
  return r;
}, tq = {
  isNode: !0,
  classes: {
    URLSearchParams: QU,
    FormData: OE,
    Blob: typeof Blob < "u" && Blob || null
  },
  ALPHABET: NE,
  generateString: eq,
  protocols: ["http", "https", "file", "data"]
}, np = typeof window < "u" && typeof document < "u", Nu = typeof navigator == "object" && navigator || void 0, rq = np && (!Nu || ["ReactNative", "NativeScript", "NS"].indexOf(Nu.product) < 0), nq = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", sq = np && window.location.href || "http://localhost", iq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: np,
  hasStandardBrowserEnv: rq,
  hasStandardBrowserWebWorkerEnv: nq,
  navigator: Nu,
  origin: sq
}, Symbol.toStringTag, { value: "Module" })), ze = {
  ...iq,
  ...tq
};
function oq(e, t) {
  return Ba(e, new ze.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, s, i) {
      return ze.isNode && B.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function aq(e) {
  return B.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function cq(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const s = r.length;
  let i;
  for (n = 0; n < s; n++)
    i = r[n], t[i] = e[i];
  return t;
}
function AE(e) {
  function t(r, n, s, i) {
    let o = r[i++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), c = i >= r.length;
    return o = !o && B.isArray(s) ? s.length : o, c ? (B.hasOwnProp(s, o) ? s[o] = [s[o], n] : s[o] = n, !a) : ((!s[o] || !B.isObject(s[o])) && (s[o] = []), t(r, n, s[o], i) && B.isArray(s[o]) && (s[o] = cq(s[o])), !a);
  }
  if (B.isFormData(e) && B.isFunction(e.entries)) {
    const r = {};
    return B.forEachEntry(e, (n, s) => {
      t(aq(n), s, r, 0);
    }), r;
  }
  return null;
}
function lq(e, t, r) {
  if (B.isString(e))
    try {
      return (t || JSON.parse)(e), B.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
const xi = {
  transitional: rp,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", s = n.indexOf("application/json") > -1, i = B.isObject(t);
    if (i && B.isHTMLForm(t) && (t = new FormData(t)), B.isFormData(t))
      return s ? JSON.stringify(AE(t)) : t;
    if (B.isArrayBuffer(t) || B.isBuffer(t) || B.isStream(t) || B.isFile(t) || B.isBlob(t) || B.isReadableStream(t))
      return t;
    if (B.isArrayBufferView(t))
      return t.buffer;
    if (B.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (i) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return oq(t, this.formSerializer).toString();
      if ((a = B.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Ba(
          a ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return i || s ? (r.setContentType("application/json", !1), lq(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || xi.transitional, n = r && r.forcedJSONParsing, s = this.responseType === "json";
    if (B.isResponse(t) || B.isReadableStream(t))
      return t;
    if (t && B.isString(t) && (n && !this.responseType || s)) {
      const o = !(r && r.silentJSONParsing) && s;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? se.from(a, se.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ze.classes.FormData,
    Blob: ze.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
B.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  xi.headers[e] = {};
});
const uq = B.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), fq = (e) => {
  const t = {};
  let r, n, s;
  return e && e.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), r = o.substring(0, s).trim().toLowerCase(), n = o.substring(s + 1).trim(), !(!r || t[r] && uq[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, Mg = Symbol("internals");
function Ps(e) {
  return e && String(e).trim().toLowerCase();
}
function To(e) {
  return e === !1 || e == null ? e : B.isArray(e) ? e.map(To) : String(e);
}
function dq(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const pq = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Bl(e, t, r, n, s) {
  if (B.isFunction(n))
    return n.call(this, t, r);
  if (s && (t = r), !!B.isString(t)) {
    if (B.isString(n))
      return t.indexOf(n) !== -1;
    if (B.isRegExp(n))
      return n.test(t);
  }
}
function hq(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function mq(e, t) {
  const r = B.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(s, i, o) {
        return this[n].call(this, t, s, i, o);
      },
      configurable: !0
    });
  });
}
let dt = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const s = this;
    function i(a, c, f) {
      const l = Ps(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = B.findKey(s, l);
      (!d || s[d] === void 0 || f === !0 || f === void 0 && s[d] !== !1) && (s[d || c] = To(a));
    }
    const o = (a, c) => B.forEach(a, (f, l) => i(f, l, c));
    if (B.isPlainObject(t) || t instanceof this.constructor)
      o(t, r);
    else if (B.isString(t) && (t = t.trim()) && !pq(t))
      o(fq(t), r);
    else if (B.isHeaders(t))
      for (const [a, c] of t.entries())
        i(c, a, n);
    else
      t != null && i(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = Ps(t), t) {
      const n = B.findKey(this, t);
      if (n) {
        const s = this[n];
        if (!r)
          return s;
        if (r === !0)
          return dq(s);
        if (B.isFunction(r))
          return r.call(this, s, n);
        if (B.isRegExp(r))
          return r.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = Ps(t), t) {
      const n = B.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || Bl(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let s = !1;
    function i(o) {
      if (o = Ps(o), o) {
        const a = B.findKey(n, o);
        a && (!r || Bl(n, n[a], a, r)) && (delete n[a], s = !0);
      }
    }
    return B.isArray(t) ? t.forEach(i) : i(t), s;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, s = !1;
    for (; n--; ) {
      const i = r[n];
      (!t || Bl(this, this[i], i, t, !0)) && (delete this[i], s = !0);
    }
    return s;
  }
  normalize(t) {
    const r = this, n = {};
    return B.forEach(this, (s, i) => {
      const o = B.findKey(n, i);
      if (o) {
        r[o] = To(s), delete r[i];
        return;
      }
      const a = t ? hq(i) : String(i).trim();
      a !== i && delete r[i], r[a] = To(s), n[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return B.forEach(this, (n, s) => {
      n != null && n !== !1 && (r[s] = t && B.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(t) {
    const n = (this[Mg] = this[Mg] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function i(o) {
      const a = Ps(o);
      n[a] || (mq(s, o), n[a] = !0);
    }
    return B.isArray(t) ? t.forEach(i) : i(t), this;
  }
};
dt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
B.reduceDescriptors(dt.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
B.freezeMethods(dt);
function Vl(e, t) {
  const r = this || xi, n = t || r, s = dt.from(n.headers);
  let i = n.data;
  return B.forEach(e, function(a) {
    i = a.call(r, i, s.normalize(), t ? t.status : void 0);
  }), s.normalize(), i;
}
function kE(e) {
  return !!(e && e.__CANCEL__);
}
function Hr(e, t, r) {
  se.call(this, e ?? "canceled", se.ERR_CANCELED, t, r), this.name = "CanceledError";
}
B.inherits(Hr, se, {
  __CANCEL__: !0
});
function Fn(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new se(
    "Request failed with status code " + r.status,
    [se.ERR_BAD_REQUEST, se.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function yq(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function gq(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function sp(e, t, r) {
  let n = !yq(t);
  return e && (n || r == !1) ? gq(e, t) : t;
}
var LE = {}, vq = ni.parse, bq = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
}, _q = String.prototype.endsWith || function(e) {
  return e.length <= this.length && this.indexOf(e, this.length - e.length) !== -1;
};
function Eq(e) {
  var t = typeof e == "string" ? vq(e) : e || {}, r = t.protocol, n = t.host, s = t.port;
  if (typeof n != "string" || !n || typeof r != "string" || (r = r.split(":", 1)[0], n = n.replace(/:\d*$/, ""), s = parseInt(s) || bq[r] || 0, !xq(n, s)))
    return "";
  var i = Mn("npm_config_" + r + "_proxy") || Mn(r + "_proxy") || Mn("npm_config_proxy") || Mn("all_proxy");
  return i && i.indexOf("://") === -1 && (i = r + "://" + i), i;
}
function xq(e, t) {
  var r = (Mn("npm_config_no_proxy") || Mn("no_proxy")).toLowerCase();
  return r ? r === "*" ? !1 : r.split(/[,\s]/).every(function(n) {
    if (!n)
      return !0;
    var s = n.match(/^(.+):(\d+)$/), i = s ? s[1] : n, o = s ? parseInt(s[2]) : 0;
    return o && o !== t ? !0 : /^[.*]/.test(i) ? (i.charAt(0) === "*" && (i = i.slice(1)), !_q.call(e, i)) : e !== i;
  }) : !0;
}
function Mn(e) {
  return process.env[e.toLowerCase()] || process.env[e.toUpperCase()] || "";
}
LE.getProxyForUrl = Eq;
var ip = { exports: {} }, so = { exports: {} }, io = { exports: {} }, Gl, zg;
function Sq() {
  if (zg) return Gl;
  zg = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, s = n * 7, i = n * 365.25;
  Gl = function(l, d) {
    d = d || {};
    var g = typeof l;
    if (g === "string" && l.length > 0)
      return o(l);
    if (g === "number" && isFinite(l))
      return d.long ? c(l) : a(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function o(l) {
    if (l = String(l), !(l.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (d) {
        var g = parseFloat(d[1]), p = (d[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return g * i;
          case "weeks":
          case "week":
          case "w":
            return g * s;
          case "days":
          case "day":
          case "d":
            return g * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return g * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return g * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return g * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return g;
          default:
            return;
        }
      }
    }
  }
  function a(l) {
    var d = Math.abs(l);
    return d >= n ? Math.round(l / n) + "d" : d >= r ? Math.round(l / r) + "h" : d >= t ? Math.round(l / t) + "m" : d >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function c(l) {
    var d = Math.abs(l);
    return d >= n ? f(l, d, n, "day") : d >= r ? f(l, d, r, "hour") : d >= t ? f(l, d, t, "minute") : d >= e ? f(l, d, e, "second") : l + " ms";
  }
  function f(l, d, g, p) {
    var u = d >= g * 1.5;
    return Math.round(l / g) + " " + p + (u ? "s" : "");
  }
  return Gl;
}
var Wl, Ug;
function jE() {
  if (Ug) return Wl;
  Ug = 1;
  function e(t) {
    n.debug = n, n.default = n, n.coerce = f, n.disable = a, n.enable = i, n.enabled = c, n.humanize = Sq(), n.destroy = l, Object.keys(t).forEach((d) => {
      n[d] = t[d];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(d) {
      let g = 0;
      for (let p = 0; p < d.length; p++)
        g = (g << 5) - g + d.charCodeAt(p), g |= 0;
      return n.colors[Math.abs(g) % n.colors.length];
    }
    n.selectColor = r;
    function n(d) {
      let g, p = null, u, h;
      function b(...m) {
        if (!b.enabled)
          return;
        const v = b, y = Number(/* @__PURE__ */ new Date()), _ = y - (g || y);
        v.diff = _, v.prev = g, v.curr = y, g = y, m[0] = n.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
        let R = 0;
        m[0] = m[0].replace(/%([a-zA-Z%])/g, (O, z) => {
          if (O === "%%")
            return "%";
          R++;
          const x = n.formatters[z];
          if (typeof x == "function") {
            const L = m[R];
            O = x.call(v, L), m.splice(R, 1), R--;
          }
          return O;
        }), n.formatArgs.call(v, m), (v.log || n.log).apply(v, m);
      }
      return b.namespace = d, b.useColors = n.useColors(), b.color = n.selectColor(d), b.extend = s, b.destroy = n.destroy, Object.defineProperty(b, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (u !== n.namespaces && (u = n.namespaces, h = n.enabled(d)), h),
        set: (m) => {
          p = m;
        }
      }), typeof n.init == "function" && n.init(b), b;
    }
    function s(d, g) {
      const p = n(this.namespace + (typeof g > "u" ? ":" : g) + d);
      return p.log = this.log, p;
    }
    function i(d) {
      n.save(d), n.namespaces = d, n.names = [], n.skips = [];
      const g = (typeof d == "string" ? d : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const p of g)
        p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
    }
    function o(d, g) {
      let p = 0, u = 0, h = -1, b = 0;
      for (; p < d.length; )
        if (u < g.length && (g[u] === d[p] || g[u] === "*"))
          g[u] === "*" ? (h = u, b = p, u++) : (p++, u++);
        else if (h !== -1)
          u = h + 1, b++, p = b;
        else
          return !1;
      for (; u < g.length && g[u] === "*"; )
        u++;
      return u === g.length;
    }
    function a() {
      const d = [
        ...n.names,
        ...n.skips.map((g) => "-" + g)
      ].join(",");
      return n.enable(""), d;
    }
    function c(d) {
      for (const g of n.skips)
        if (o(d, g))
          return !1;
      for (const g of n.names)
        if (o(d, g))
          return !0;
      return !1;
    }
    function f(d) {
      return d instanceof Error ? d.stack || d.message : d;
    }
    function l() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
  return Wl = e, Wl;
}
var qg;
function wq() {
  return qg || (qg = 1, function(e, t) {
    t.formatArgs = n, t.save = s, t.load = i, t.useColors = r, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
      let c = !1;
      return () => {
        c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let c;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (c = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(c[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(c) {
      if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const f = "color: " + this.color;
      c.splice(1, 0, f, "color: inherit");
      let l = 0, d = 0;
      c[0].replace(/%[a-zA-Z%]/g, (g) => {
        g !== "%%" && (l++, g === "%c" && (d = l));
      }), c.splice(d, 0, f);
    }
    t.log = console.debug || console.log || (() => {
    });
    function s(c) {
      try {
        c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function i() {
      let c;
      try {
        c = t.storage.getItem("debug");
      } catch {
      }
      return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = jE()(t);
    const { formatters: a } = e.exports;
    a.j = function(c) {
      try {
        return JSON.stringify(c);
      } catch (f) {
        return "[UnexpectedJSONParseError]: " + f.message;
      }
    };
  }(io, io.exports)), io.exports;
}
var oo = { exports: {} }, Kl, Hg;
function Rq() {
  return Hg || (Hg = 1, Kl = (e, t = process.argv) => {
    const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), s = t.indexOf("--");
    return n !== -1 && (s === -1 || n < s);
  }), Kl;
}
var Jl, Bg;
function $q() {
  if (Bg) return Jl;
  Bg = 1;
  const e = wx, t = _v, r = Rq(), { env: n } = process;
  let s;
  r("no-color") || r("no-colors") || r("color=false") || r("color=never") ? s = 0 : (r("color") || r("colors") || r("color=true") || r("color=always")) && (s = 1), "FORCE_COLOR" in n && (n.FORCE_COLOR === "true" ? s = 1 : n.FORCE_COLOR === "false" ? s = 0 : s = n.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(n.FORCE_COLOR, 10), 3));
  function i(c) {
    return c === 0 ? !1 : {
      level: c,
      hasBasic: !0,
      has256: c >= 2,
      has16m: c >= 3
    };
  }
  function o(c, f) {
    if (s === 0)
      return 0;
    if (r("color=16m") || r("color=full") || r("color=truecolor"))
      return 3;
    if (r("color=256"))
      return 2;
    if (c && !f && s === void 0)
      return 0;
    const l = s || 0;
    if (n.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const d = e.release().split(".");
      return Number(d[0]) >= 10 && Number(d[2]) >= 10586 ? Number(d[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in n)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((d) => d in n) || n.CI_NAME === "codeship" ? 1 : l;
    if ("TEAMCITY_VERSION" in n)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0;
    if (n.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in n) {
      const d = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (n.TERM_PROGRAM) {
        case "iTerm.app":
          return d >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(n.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(n.TERM) || "COLORTERM" in n ? 1 : l;
  }
  function a(c) {
    const f = o(c, c && c.isTTY);
    return i(f);
  }
  return Jl = {
    supportsColor: a,
    stdout: i(o(!0, t.isatty(1))),
    stderr: i(o(!0, t.isatty(2)))
  }, Jl;
}
var Vg;
function Tq() {
  return Vg || (Vg = 1, function(e, t) {
    const r = _v, n = gn;
    t.init = l, t.log = a, t.formatArgs = i, t.save = c, t.load = f, t.useColors = s, t.destroy = n.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), t.colors = [6, 2, 3, 4, 5, 1];
    try {
      const g = $q();
      g && (g.stderr || g).level >= 2 && (t.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    t.inspectOpts = Object.keys(process.env).filter((g) => /^debug_/i.test(g)).reduce((g, p) => {
      const u = p.substring(6).toLowerCase().replace(/_([a-z])/g, (b, m) => m.toUpperCase());
      let h = process.env[p];
      return /^(yes|on|true|enabled)$/i.test(h) ? h = !0 : /^(no|off|false|disabled)$/i.test(h) ? h = !1 : h === "null" ? h = null : h = Number(h), g[u] = h, g;
    }, {});
    function s() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : r.isatty(process.stderr.fd);
    }
    function i(g) {
      const { namespace: p, useColors: u } = this;
      if (u) {
        const h = this.color, b = "\x1B[3" + (h < 8 ? h : "8;5;" + h), m = `  ${b};1m${p} \x1B[0m`;
        g[0] = m + g[0].split(`
`).join(`
` + m), g.push(b + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        g[0] = o() + p + " " + g[0];
    }
    function o() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function a(...g) {
      return process.stderr.write(n.formatWithOptions(t.inspectOpts, ...g) + `
`);
    }
    function c(g) {
      g ? process.env.DEBUG = g : delete process.env.DEBUG;
    }
    function f() {
      return process.env.DEBUG;
    }
    function l(g) {
      g.inspectOpts = {};
      const p = Object.keys(t.inspectOpts);
      for (let u = 0; u < p.length; u++)
        g.inspectOpts[p[u]] = t.inspectOpts[p[u]];
    }
    e.exports = jE()(t);
    const { formatters: d } = e.exports;
    d.o = function(g) {
      return this.inspectOpts.colors = this.useColors, n.inspect(g, this.inspectOpts).split(`
`).map((p) => p.trim()).join(" ");
    }, d.O = function(g) {
      return this.inspectOpts.colors = this.useColors, n.inspect(g, this.inspectOpts);
    };
  }(oo, oo.exports)), oo.exports;
}
var Gg;
function Oq() {
  return Gg || (Gg = 1, typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? so.exports = wq() : so.exports = Tq()), so.exports;
}
var Cs, Pq = function() {
  if (!Cs) {
    try {
      Cs = Oq()("follow-redirects");
    } catch {
    }
    typeof Cs != "function" && (Cs = function() {
    });
  }
  Cs.apply(null, arguments);
}, Si = ni, Ys = Si.URL, Cq = qu, Iq = Hu, op = zt.Writable, ap = Uu, DE = Pq;
(function() {
  var t = typeof process < "u", r = typeof window < "u" && typeof document < "u", n = hn(Error.captureStackTrace);
  !t && (r || !n) && console.warn("The follow-redirects package should be excluded from browser builds.");
})();
var cp = !1;
try {
  ap(new Ys(""));
} catch (e) {
  cp = e.code === "ERR_INVALID_URL";
}
var Nq = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
], lp = ["abort", "aborted", "connect", "error", "socket", "timeout"], up = /* @__PURE__ */ Object.create(null);
lp.forEach(function(e) {
  up[e] = function(t, r, n) {
    this._redirectable.emit(e, t, r, n);
  };
});
var Au = wi(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
), ku = wi(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
), Aq = wi(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  ku
), kq = wi(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
), Lq = wi(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
), jq = op.prototype.destroy || ME;
function Tt(e, t) {
  op.call(this), this._sanitizeOptions(e), this._options = e, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], t && this.on("response", t);
  var r = this;
  this._onNativeResponse = function(n) {
    try {
      r._processResponse(n);
    } catch (s) {
      r.emit("error", s instanceof ku ? s : new ku({ cause: s }));
    }
  }, this._performRequest();
}
Tt.prototype = Object.create(op.prototype);
Tt.prototype.abort = function() {
  dp(this._currentRequest), this._currentRequest.abort(), this.emit("abort");
};
Tt.prototype.destroy = function(e) {
  return dp(this._currentRequest, e), jq.call(this, e), this;
};
Tt.prototype.write = function(e, t, r) {
  if (this._ending)
    throw new Lq();
  if (!un(e) && !Mq(e))
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  if (hn(t) && (r = t, t = null), e.length === 0) {
    r && r();
    return;
  }
  this._requestBodyLength + e.length <= this._options.maxBodyLength ? (this._requestBodyLength += e.length, this._requestBodyBuffers.push({ data: e, encoding: t }), this._currentRequest.write(e, t, r)) : (this.emit("error", new kq()), this.abort());
};
Tt.prototype.end = function(e, t, r) {
  if (hn(e) ? (r = e, e = t = null) : hn(t) && (r = t, t = null), !e)
    this._ended = this._ending = !0, this._currentRequest.end(null, null, r);
  else {
    var n = this, s = this._currentRequest;
    this.write(e, t, function() {
      n._ended = !0, s.end(null, null, r);
    }), this._ending = !0;
  }
};
Tt.prototype.setHeader = function(e, t) {
  this._options.headers[e] = t, this._currentRequest.setHeader(e, t);
};
Tt.prototype.removeHeader = function(e) {
  delete this._options.headers[e], this._currentRequest.removeHeader(e);
};
Tt.prototype.setTimeout = function(e, t) {
  var r = this;
  function n(o) {
    o.setTimeout(e), o.removeListener("timeout", o.destroy), o.addListener("timeout", o.destroy);
  }
  function s(o) {
    r._timeout && clearTimeout(r._timeout), r._timeout = setTimeout(function() {
      r.emit("timeout"), i();
    }, e), n(o);
  }
  function i() {
    r._timeout && (clearTimeout(r._timeout), r._timeout = null), r.removeListener("abort", i), r.removeListener("error", i), r.removeListener("response", i), r.removeListener("close", i), t && r.removeListener("timeout", t), r.socket || r._currentRequest.removeListener("socket", s);
  }
  return t && this.on("timeout", t), this.socket ? s(this.socket) : this._currentRequest.once("socket", s), this.on("socket", n), this.on("abort", i), this.on("error", i), this.on("response", i), this.on("close", i), this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(e) {
  Tt.prototype[e] = function(t, r) {
    return this._currentRequest[e](t, r);
  };
});
["aborted", "connection", "socket"].forEach(function(e) {
  Object.defineProperty(Tt.prototype, e, {
    get: function() {
      return this._currentRequest[e];
    }
  });
});
Tt.prototype._sanitizeOptions = function(e) {
  if (e.headers || (e.headers = {}), e.host && (e.hostname || (e.hostname = e.host), delete e.host), !e.pathname && e.path) {
    var t = e.path.indexOf("?");
    t < 0 ? e.pathname = e.path : (e.pathname = e.path.substring(0, t), e.search = e.path.substring(t));
  }
};
Tt.prototype._performRequest = function() {
  var e = this._options.protocol, t = this._options.nativeProtocols[e];
  if (!t)
    throw new TypeError("Unsupported protocol " + e);
  if (this._options.agents) {
    var r = e.slice(0, -1);
    this._options.agent = this._options.agents[r];
  }
  var n = this._currentRequest = t.request(this._options, this._onNativeResponse);
  n._redirectable = this;
  for (var s of lp)
    n.on(s, up[s]);
  if (this._currentUrl = /^\//.test(this._options.path) ? Si.format(this._options) : (
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path
  ), this._isRedirect) {
    var i = 0, o = this, a = this._requestBodyBuffers;
    (function c(f) {
      if (n === o._currentRequest)
        if (f)
          o.emit("error", f);
        else if (i < a.length) {
          var l = a[i++];
          n.finished || n.write(l.data, l.encoding, c);
        } else o._ended && n.end();
    })();
  }
};
Tt.prototype._processResponse = function(e) {
  var t = e.statusCode;
  this._options.trackRedirects && this._redirects.push({
    url: this._currentUrl,
    headers: e.headers,
    statusCode: t
  });
  var r = e.headers.location;
  if (!r || this._options.followRedirects === !1 || t < 300 || t >= 400) {
    e.responseUrl = this._currentUrl, e.redirects = this._redirects, this.emit("response", e), this._requestBodyBuffers = [];
    return;
  }
  if (dp(this._currentRequest), e.destroy(), ++this._redirectCount > this._options.maxRedirects)
    throw new Aq();
  var n, s = this._options.beforeRedirect;
  s && (n = Object.assign({
    // The Host header was set by nativeProtocol.request
    Host: e.req.getHeader("host")
  }, this._options.headers));
  var i = this._options.method;
  ((t === 301 || t === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource […]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) […]
  t === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], Yl(/^content-/i, this._options.headers));
  var o = Yl(/^host$/i, this._options.headers), a = fp(this._currentUrl), c = o || a.host, f = /^\w+:/.test(r) ? this._currentUrl : Si.format(Object.assign(a, { host: c })), l = Dq(r, f);
  if (DE("redirecting to", l.href), this._isRedirect = !0, Lu(l, this._options), (l.protocol !== a.protocol && l.protocol !== "https:" || l.host !== c && !Fq(l.host, c)) && Yl(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers), hn(s)) {
    var d = {
      headers: e.headers,
      statusCode: t
    }, g = {
      url: f,
      method: i,
      headers: n
    };
    s(this._options, d, g), this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function FE(e) {
  var t = {
    maxRedirects: 21,
    maxBodyLength: 10485760
  }, r = {};
  return Object.keys(e).forEach(function(n) {
    var s = n + ":", i = r[s] = e[n], o = t[n] = Object.create(i);
    function a(f, l, d) {
      return zq(f) ? f = Lu(f) : un(f) ? f = Lu(fp(f)) : (d = l, l = zE(f), f = { protocol: s }), hn(l) && (d = l, l = null), l = Object.assign({
        maxRedirects: t.maxRedirects,
        maxBodyLength: t.maxBodyLength
      }, f, l), l.nativeProtocols = r, !un(l.host) && !un(l.hostname) && (l.hostname = "::1"), ap.equal(l.protocol, s, "protocol mismatch"), DE("options", l), new Tt(l, d);
    }
    function c(f, l, d) {
      var g = o.request(f, l, d);
      return g.end(), g;
    }
    Object.defineProperties(o, {
      request: { value: a, configurable: !0, enumerable: !0, writable: !0 },
      get: { value: c, configurable: !0, enumerable: !0, writable: !0 }
    });
  }), t;
}
function ME() {
}
function fp(e) {
  var t;
  if (cp)
    t = new Ys(e);
  else if (t = zE(Si.parse(e)), !un(t.protocol))
    throw new Au({ input: e });
  return t;
}
function Dq(e, t) {
  return cp ? new Ys(e, t) : fp(Si.resolve(t, e));
}
function zE(e) {
  if (/^\[/.test(e.hostname) && !/^\[[:0-9a-f]+\]$/i.test(e.hostname))
    throw new Au({ input: e.href || e });
  if (/^\[/.test(e.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(e.host))
    throw new Au({ input: e.href || e });
  return e;
}
function Lu(e, t) {
  var r = t || {};
  for (var n of Nq)
    r[n] = e[n];
  return r.hostname.startsWith("[") && (r.hostname = r.hostname.slice(1, -1)), r.port !== "" && (r.port = Number(r.port)), r.path = r.search ? r.pathname + r.search : r.pathname, r;
}
function Yl(e, t) {
  var r;
  for (var n in t)
    e.test(n) && (r = t[n], delete t[n]);
  return r === null || typeof r > "u" ? void 0 : String(r).trim();
}
function wi(e, t, r) {
  function n(s) {
    hn(Error.captureStackTrace) && Error.captureStackTrace(this, this.constructor), Object.assign(this, s || {}), this.code = e, this.message = this.cause ? t + ": " + this.cause.message : t;
  }
  return n.prototype = new (r || Error)(), Object.defineProperties(n.prototype, {
    constructor: {
      value: n,
      enumerable: !1
    },
    name: {
      value: "Error [" + e + "]",
      enumerable: !1
    }
  }), n;
}
function dp(e, t) {
  for (var r of lp)
    e.removeListener(r, up[r]);
  e.on("error", ME), e.destroy(t);
}
function Fq(e, t) {
  ap(un(e) && un(t));
  var r = e.length - t.length - 1;
  return r > 0 && e[r] === "." && e.endsWith(t);
}
function un(e) {
  return typeof e == "string" || e instanceof String;
}
function hn(e) {
  return typeof e == "function";
}
function Mq(e) {
  return typeof e == "object" && "length" in e;
}
function zq(e) {
  return Ys && e instanceof Ys;
}
ip.exports = FE({ http: Cq, https: Iq });
ip.exports.wrap = FE;
var Uq = ip.exports;
const qq = /* @__PURE__ */ si(Uq), Jo = "1.8.4";
function UE(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
const Hq = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function Bq(e, t, r) {
  const n = r && r.Blob || ze.classes.Blob, s = UE(e);
  if (t === void 0 && n && (t = !0), s === "data") {
    e = s.length ? e.slice(s.length + 1) : e;
    const i = Hq.exec(e);
    if (!i)
      throw new se("Invalid URL", se.ERR_INVALID_URL);
    const o = i[1], a = i[2], c = i[3], f = Buffer.from(decodeURIComponent(c), a ? "base64" : "utf8");
    if (t) {
      if (!n)
        throw new se("Blob is not supported", se.ERR_NOT_SUPPORT);
      return new n([f], { type: o });
    }
    return f;
  }
  throw new se("Unsupported protocol " + s, se.ERR_NOT_SUPPORT);
}
const Xl = Symbol("internals");
class Wg extends zt.Transform {
  constructor(t) {
    t = B.toFlatObject(t, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (n, s) => !B.isUndefined(s[n])), super({
      readableHighWaterMark: t.chunkSize
    });
    const r = this[Xl] = {
      timeWindow: t.timeWindow,
      chunkSize: t.chunkSize,
      maxRate: t.maxRate,
      minChunkSize: t.minChunkSize,
      bytesSeen: 0,
      isCaptured: !1,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (n) => {
      n === "progress" && (r.isCaptured || (r.isCaptured = !0));
    });
  }
  _read(t) {
    const r = this[Xl];
    return r.onReadCallback && r.onReadCallback(), super._read(t);
  }
  _transform(t, r, n) {
    const s = this[Xl], i = s.maxRate, o = this.readableHighWaterMark, a = s.timeWindow, c = 1e3 / a, f = i / c, l = s.minChunkSize !== !1 ? Math.max(s.minChunkSize, f * 0.01) : 0, d = (p, u) => {
      const h = Buffer.byteLength(p);
      s.bytesSeen += h, s.bytes += h, s.isCaptured && this.emit("progress", s.bytesSeen), this.push(p) ? process.nextTick(u) : s.onReadCallback = () => {
        s.onReadCallback = null, process.nextTick(u);
      };
    }, g = (p, u) => {
      const h = Buffer.byteLength(p);
      let b = null, m = o, v, y = 0;
      if (i) {
        const _ = Date.now();
        (!s.ts || (y = _ - s.ts) >= a) && (s.ts = _, v = f - s.bytes, s.bytes = v < 0 ? -v : 0, y = 0), v = f - s.bytes;
      }
      if (i) {
        if (v <= 0)
          return setTimeout(() => {
            u(null, p);
          }, a - y);
        v < m && (m = v);
      }
      m && h > m && h - m > l && (b = p.subarray(m), p = p.subarray(0, m)), d(p, b ? () => {
        process.nextTick(u, null, b);
      } : u);
    };
    g(t, function p(u, h) {
      if (u)
        return n(u);
      h ? g(h, p) : n(null);
    });
  }
}
const { asyncIterator: Kg } = Symbol, qE = async function* (e) {
  e.stream ? yield* e.stream() : e.arrayBuffer ? yield await e.arrayBuffer() : e[Kg] ? yield* e[Kg]() : yield e;
}, Vq = ze.ALPHABET.ALPHA_DIGIT + "-_", Xs = typeof TextEncoder == "function" ? new TextEncoder() : new gn.TextEncoder(), Mr = `\r
`, Gq = Xs.encode(Mr), Wq = 2;
class Kq {
  constructor(t, r) {
    const { escapeName: n } = this.constructor, s = B.isString(r);
    let i = `Content-Disposition: form-data; name="${n(t)}"${!s && r.name ? `; filename="${n(r.name)}"` : ""}${Mr}`;
    s ? r = Xs.encode(String(r).replace(/\r?\n|\r\n?/g, Mr)) : i += `Content-Type: ${r.type || "application/octet-stream"}${Mr}`, this.headers = Xs.encode(i + Mr), this.contentLength = s ? r.byteLength : r.size, this.size = this.headers.byteLength + this.contentLength + Wq, this.name = t, this.value = r;
  }
  async *encode() {
    yield this.headers;
    const { value: t } = this;
    B.isTypedArray(t) ? yield t : yield* qE(t), yield Gq;
  }
  static escapeName(t) {
    return String(t).replace(/[\r\n"]/g, (r) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[r]);
  }
}
const Jq = (e, t, r) => {
  const {
    tag: n = "form-data-boundary",
    size: s = 25,
    boundary: i = n + "-" + ze.generateString(s, Vq)
  } = r || {};
  if (!B.isFormData(e))
    throw TypeError("FormData instance required");
  if (i.length < 1 || i.length > 70)
    throw Error("boundary must be 10-70 characters long");
  const o = Xs.encode("--" + i + Mr), a = Xs.encode("--" + i + "--" + Mr + Mr);
  let c = a.byteLength;
  const f = Array.from(e.entries()).map(([d, g]) => {
    const p = new Kq(d, g);
    return c += p.size, p;
  });
  c += o.byteLength * f.length, c = B.toFiniteNumber(c);
  const l = {
    "Content-Type": `multipart/form-data; boundary=${i}`
  };
  return Number.isFinite(c) && (l["Content-Length"] = c), t && t(l), Sx.from(async function* () {
    for (const d of f)
      yield o, yield* d.encode();
    yield a;
  }());
};
class Yq extends zt.Transform {
  __transform(t, r, n) {
    this.push(t), n();
  }
  _transform(t, r, n) {
    if (t.length !== 0 && (this._transform = this.__transform, t[0] !== 120)) {
      const s = Buffer.alloc(2);
      s[0] = 120, s[1] = 156, this.push(s, r);
    }
    this.__transform(t, r, n);
  }
}
const Xq = (e, t) => B.isAsyncFn(e) ? function(...r) {
  const n = r.pop();
  e.apply(this, r).then((s) => {
    try {
      t ? n(null, ...t(s)) : n(null, s);
    } catch (i) {
      n(i);
    }
  }, n);
} : e;
function Zq(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let s = 0, i = 0, o;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const f = Date.now(), l = n[i];
    o || (o = f), r[s] = c, n[s] = f;
    let d = i, g = 0;
    for (; d !== s; )
      g += r[d++], d = d % e;
    if (s = (s + 1) % e, s === i && (i = (i + 1) % e), f - o < t)
      return;
    const p = l && f - l;
    return p ? Math.round(g * 1e3 / p) : void 0;
  };
}
function Qq(e, t) {
  let r = 0, n = 1e3 / t, s, i;
  const o = (f, l = Date.now()) => {
    r = l, s = null, i && (clearTimeout(i), i = null), e.apply(null, f);
  };
  return [(...f) => {
    const l = Date.now(), d = l - r;
    d >= n ? o(f, l) : (s = f, i || (i = setTimeout(() => {
      i = null, o(s);
    }, n - d)));
  }, () => s && o(s)];
}
const Qn = (e, t, r = 3) => {
  let n = 0;
  const s = Zq(50, 250);
  return Qq((i) => {
    const o = i.loaded, a = i.lengthComputable ? i.total : void 0, c = o - n, f = s(c), l = o <= a;
    n = o;
    const d = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
      rate: f || void 0,
      estimated: f && a && l ? (a - o) / f : void 0,
      event: i,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(d);
  }, r);
}, Yo = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
}, Xo = (e) => (...t) => B.asap(() => e(...t)), Jg = {
  flush: fr.constants.Z_SYNC_FLUSH,
  finishFlush: fr.constants.Z_SYNC_FLUSH
}, eH = {
  flush: fr.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: fr.constants.BROTLI_OPERATION_FLUSH
}, Yg = B.isFunction(fr.createBrotliDecompress), { http: tH, https: rH } = qq, nH = /https:?/, Xg = ze.protocols.map((e) => e + ":"), Zg = (e, [t, r]) => (e.on("end", r).on("error", r), t);
function sH(e, t) {
  e.beforeRedirects.proxy && e.beforeRedirects.proxy(e), e.beforeRedirects.config && e.beforeRedirects.config(e, t);
}
function HE(e, t, r) {
  let n = t;
  if (!n && n !== !1) {
    const s = LE.getProxyForUrl(r);
    s && (n = new URL(s));
  }
  if (n) {
    if (n.username && (n.auth = (n.username || "") + ":" + (n.password || "")), n.auth) {
      (n.auth.username || n.auth.password) && (n.auth = (n.auth.username || "") + ":" + (n.auth.password || ""));
      const i = Buffer.from(n.auth, "utf8").toString("base64");
      e.headers["Proxy-Authorization"] = "Basic " + i;
    }
    e.headers.host = e.hostname + (e.port ? ":" + e.port : "");
    const s = n.hostname || n.host;
    e.hostname = s, e.host = s, e.port = n.port, e.path = r, n.protocol && (e.protocol = n.protocol.includes(":") ? n.protocol : `${n.protocol}:`);
  }
  e.beforeRedirects.proxy = function(i) {
    HE(i, t, i.href);
  };
}
const iH = typeof process < "u" && B.kindOf(process) === "process", oH = (e) => new Promise((t, r) => {
  let n, s;
  const i = (c, f) => {
    s || (s = !0, n && n(c, f));
  }, o = (c) => {
    i(c), t(c);
  }, a = (c) => {
    i(c, !0), r(c);
  };
  e(o, a, (c) => n = c).catch(a);
}), aH = ({ address: e, family: t }) => {
  if (!B.isString(e))
    throw TypeError("address must be a string");
  return {
    address: e,
    family: t || (e.indexOf(".") < 0 ? 6 : 4)
  };
}, Qg = (e, t) => aH(B.isObject(e) ? e : { address: e, family: t }), cH = iH && function(t) {
  return oH(async function(n, s, i) {
    let { data: o, lookup: a, family: c } = t;
    const { responseType: f, responseEncoding: l } = t, d = t.method.toUpperCase();
    let g, p = !1, u;
    if (a) {
      const j = Xq(a, (P) => B.isArray(P) ? P : [P]);
      a = (P, A, k) => {
        j(P, A, (C, D, F) => {
          if (C)
            return k(C);
          const w = B.isArray(D) ? D.map((N) => Qg(N)) : [Qg(D, F)];
          A.all ? k(C, w) : k(C, w[0].address, w[0].family);
        });
      };
    }
    const h = new vx(), b = () => {
      t.cancelToken && t.cancelToken.unsubscribe(m), t.signal && t.signal.removeEventListener("abort", m), h.removeAllListeners();
    };
    i((j, P) => {
      g = !0, P && (p = !0, b());
    });
    function m(j) {
      h.emit("abort", !j || j.type ? new Hr(null, t, u) : j);
    }
    h.once("abort", s), (t.cancelToken || t.signal) && (t.cancelToken && t.cancelToken.subscribe(m), t.signal && (t.signal.aborted ? m() : t.signal.addEventListener("abort", m)));
    const v = sp(t.baseURL, t.url, t.allowAbsoluteUrls), y = new URL(v, ze.hasBrowserEnv ? ze.origin : void 0), _ = y.protocol || Xg[0];
    if (_ === "data:") {
      let j;
      if (d !== "GET")
        return Fn(n, s, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: t
        });
      try {
        j = Bq(t.url, f === "blob", {
          Blob: t.env && t.env.Blob
        });
      } catch (P) {
        throw se.from(P, se.ERR_BAD_REQUEST, t);
      }
      return f === "text" ? (j = j.toString(l), (!l || l === "utf8") && (j = B.stripBOM(j))) : f === "stream" && (j = zt.Readable.from(j)), Fn(n, s, {
        data: j,
        status: 200,
        statusText: "OK",
        headers: new dt(),
        config: t
      });
    }
    if (Xg.indexOf(_) === -1)
      return s(new se(
        "Unsupported protocol " + _,
        se.ERR_BAD_REQUEST,
        t
      ));
    const R = dt.from(t.headers).normalize();
    R.set("User-Agent", "axios/" + Jo, !1);
    const { onUploadProgress: E, onDownloadProgress: O } = t, z = t.maxRate;
    let x, L;
    if (B.isSpecCompliantForm(o)) {
      const j = R.getContentType(/boundary=([-_\w\d]{10,70})/i);
      o = Jq(o, (P) => {
        R.set(P);
      }, {
        tag: `axios-${Jo}-boundary`,
        boundary: j && j[1] || void 0
      });
    } else if (B.isFormData(o) && B.isFunction(o.getHeaders)) {
      if (R.set(o.getHeaders()), !R.hasContentLength())
        try {
          const j = await gn.promisify(o.getLength).call(o);
          Number.isFinite(j) && j >= 0 && R.setContentLength(j);
        } catch {
        }
    } else if (B.isBlob(o) || B.isFile(o))
      o.size && R.setContentType(o.type || "application/octet-stream"), R.setContentLength(o.size || 0), o = zt.Readable.from(qE(o));
    else if (o && !B.isStream(o)) {
      if (!Buffer.isBuffer(o)) if (B.isArrayBuffer(o))
        o = Buffer.from(new Uint8Array(o));
      else if (B.isString(o))
        o = Buffer.from(o, "utf-8");
      else
        return s(new se(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          se.ERR_BAD_REQUEST,
          t
        ));
      if (R.setContentLength(o.length, !1), t.maxBodyLength > -1 && o.length > t.maxBodyLength)
        return s(new se(
          "Request body larger than maxBodyLength limit",
          se.ERR_BAD_REQUEST,
          t
        ));
    }
    const M = B.toFiniteNumber(R.getContentLength());
    B.isArray(z) ? (x = z[0], L = z[1]) : x = L = z, o && (E || x) && (B.isStream(o) || (o = zt.Readable.from(o, { objectMode: !1 })), o = zt.pipeline([o, new Wg({
      maxRate: B.toFiniteNumber(x)
    })], B.noop), E && o.on("progress", Zg(
      o,
      Yo(
        M,
        Qn(Xo(E), !1, 3)
      )
    )));
    let U;
    if (t.auth) {
      const j = t.auth.username || "", P = t.auth.password || "";
      U = j + ":" + P;
    }
    if (!U && y.username) {
      const j = y.username, P = y.password;
      U = j + ":" + P;
    }
    U && R.delete("authorization");
    let $;
    try {
      $ = tp(
        y.pathname + y.search,
        t.params,
        t.paramsSerializer
      ).replace(/^\?/, "");
    } catch (j) {
      const P = new Error(j.message);
      return P.config = t, P.url = t.url, P.exists = !0, s(P);
    }
    R.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (Yg ? ", br" : ""),
      !1
    );
    const S = {
      path: $,
      method: d,
      headers: R.toJSON(),
      agents: { http: t.httpAgent, https: t.httpsAgent },
      auth: U,
      protocol: _,
      family: c,
      beforeRedirect: sH,
      beforeRedirects: {}
    };
    !B.isUndefined(a) && (S.lookup = a), t.socketPath ? S.socketPath = t.socketPath : (S.hostname = y.hostname.startsWith("[") ? y.hostname.slice(1, -1) : y.hostname, S.port = y.port, HE(S, t.proxy, _ + "//" + y.hostname + (y.port ? ":" + y.port : "") + S.path));
    let I;
    const T = nH.test(S.protocol);
    if (S.agent = T ? t.httpsAgent : t.httpAgent, t.transport ? I = t.transport : t.maxRedirects === 0 ? I = T ? Hu : qu : (t.maxRedirects && (S.maxRedirects = t.maxRedirects), t.beforeRedirect && (S.beforeRedirects.config = t.beforeRedirect), I = T ? rH : tH), t.maxBodyLength > -1 ? S.maxBodyLength = t.maxBodyLength : S.maxBodyLength = 1 / 0, t.insecureHTTPParser && (S.insecureHTTPParser = t.insecureHTTPParser), u = I.request(S, function(P) {
      if (u.destroyed) return;
      const A = [P], k = +P.headers["content-length"];
      if (O || L) {
        const N = new Wg({
          maxRate: B.toFiniteNumber(L)
        });
        O && N.on("progress", Zg(
          N,
          Yo(
            k,
            Qn(Xo(O), !0, 3)
          )
        )), A.push(N);
      }
      let C = P;
      const D = P.req || u;
      if (t.decompress !== !1 && P.headers["content-encoding"])
        switch ((d === "HEAD" || P.statusCode === 204) && delete P.headers["content-encoding"], (P.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            A.push(fr.createUnzip(Jg)), delete P.headers["content-encoding"];
            break;
          case "deflate":
            A.push(new Yq()), A.push(fr.createUnzip(Jg)), delete P.headers["content-encoding"];
            break;
          case "br":
            Yg && (A.push(fr.createBrotliDecompress(eH)), delete P.headers["content-encoding"]);
        }
      C = A.length > 1 ? zt.pipeline(A, B.noop) : A[0];
      const F = zt.finished(C, () => {
        F(), b();
      }), w = {
        status: P.statusCode,
        statusText: P.statusMessage,
        headers: new dt(P.headers),
        config: t,
        request: D
      };
      if (f === "stream")
        w.data = C, Fn(n, s, w);
      else {
        const N = [];
        let q = 0;
        C.on("data", function(V) {
          N.push(V), q += V.length, t.maxContentLength > -1 && q > t.maxContentLength && (p = !0, C.destroy(), s(new se(
            "maxContentLength size of " + t.maxContentLength + " exceeded",
            se.ERR_BAD_RESPONSE,
            t,
            D
          )));
        }), C.on("aborted", function() {
          if (p)
            return;
          const V = new se(
            "stream has been aborted",
            se.ERR_BAD_RESPONSE,
            t,
            D
          );
          C.destroy(V), s(V);
        }), C.on("error", function(V) {
          u.destroyed || s(se.from(V, null, t, D));
        }), C.on("end", function() {
          try {
            let V = N.length === 1 ? N[0] : Buffer.concat(N);
            f !== "arraybuffer" && (V = V.toString(l), (!l || l === "utf8") && (V = B.stripBOM(V))), w.data = V;
          } catch (V) {
            return s(se.from(V, null, t, w.request, w));
          }
          Fn(n, s, w);
        });
      }
      h.once("abort", (N) => {
        C.destroyed || (C.emit("error", N), C.destroy());
      });
    }), h.once("abort", (j) => {
      s(j), u.destroy(j);
    }), u.on("error", function(P) {
      s(se.from(P, null, t, u));
    }), u.on("socket", function(P) {
      P.setKeepAlive(!0, 1e3 * 60);
    }), t.timeout) {
      const j = parseInt(t.timeout, 10);
      if (Number.isNaN(j)) {
        s(new se(
          "error trying to parse `config.timeout` to int",
          se.ERR_BAD_OPTION_VALUE,
          t,
          u
        ));
        return;
      }
      u.setTimeout(j, function() {
        if (g) return;
        let A = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
        const k = t.transitional || rp;
        t.timeoutErrorMessage && (A = t.timeoutErrorMessage), s(new se(
          A,
          k.clarifyTimeoutError ? se.ETIMEDOUT : se.ECONNABORTED,
          t,
          u
        )), m();
      });
    }
    if (B.isStream(o)) {
      let j = !1, P = !1;
      o.on("end", () => {
        j = !0;
      }), o.once("error", (A) => {
        P = !0, u.destroy(A);
      }), o.on("close", () => {
        !j && !P && m(new Hr("Request stream has been aborted", t, u));
      }), o.pipe(u);
    } else
      u.end(o);
  });
}, lH = ze.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (r) => (r = new URL(r, ze.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(
  new URL(ze.origin),
  ze.navigator && /(msie|trident)/i.test(ze.navigator.userAgent)
) : () => !0, uH = ze.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, s, i) {
      const o = [e + "=" + encodeURIComponent(t)];
      B.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), B.isString(n) && o.push("path=" + n), B.isString(s) && o.push("domain=" + s), i === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
), ev = (e) => e instanceof dt ? { ...e } : e;
function mn(e, t) {
  t = t || {};
  const r = {};
  function n(f, l, d, g) {
    return B.isPlainObject(f) && B.isPlainObject(l) ? B.merge.call({ caseless: g }, f, l) : B.isPlainObject(l) ? B.merge({}, l) : B.isArray(l) ? l.slice() : l;
  }
  function s(f, l, d, g) {
    if (B.isUndefined(l)) {
      if (!B.isUndefined(f))
        return n(void 0, f, d, g);
    } else return n(f, l, d, g);
  }
  function i(f, l) {
    if (!B.isUndefined(l))
      return n(void 0, l);
  }
  function o(f, l) {
    if (B.isUndefined(l)) {
      if (!B.isUndefined(f))
        return n(void 0, f);
    } else return n(void 0, l);
  }
  function a(f, l, d) {
    if (d in t)
      return n(f, l);
    if (d in e)
      return n(void 0, f);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (f, l, d) => s(ev(f), ev(l), d, !0)
  };
  return B.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const d = c[l] || s, g = d(e[l], t[l], l);
    B.isUndefined(g) && d !== a || (r[l] = g);
  }), r;
}
const BE = (e) => {
  const t = mn({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: a } = t;
  t.headers = o = dt.from(o), t.url = tp(sp(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (B.isFormData(r)) {
    if (ze.hasStandardBrowserEnv || ze.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [f, ...l] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      o.setContentType([f || "multipart/form-data", ...l].join("; "));
    }
  }
  if (ze.hasStandardBrowserEnv && (n && B.isFunction(n) && (n = n(t)), n || n !== !1 && lH(t.url))) {
    const f = s && i && uH.read(i);
    f && o.set(s, f);
  }
  return t;
}, fH = typeof XMLHttpRequest < "u", dH = fH && function(e) {
  return new Promise(function(r, n) {
    const s = BE(e);
    let i = s.data;
    const o = dt.from(s.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: f } = s, l, d, g, p, u;
    function h() {
      p && p(), u && u(), s.cancelToken && s.cancelToken.unsubscribe(l), s.signal && s.signal.removeEventListener("abort", l);
    }
    let b = new XMLHttpRequest();
    b.open(s.method.toUpperCase(), s.url, !0), b.timeout = s.timeout;
    function m() {
      if (!b)
        return;
      const y = dt.from(
        "getAllResponseHeaders" in b && b.getAllResponseHeaders()
      ), R = {
        data: !a || a === "text" || a === "json" ? b.responseText : b.response,
        status: b.status,
        statusText: b.statusText,
        headers: y,
        config: e,
        request: b
      };
      Fn(function(O) {
        r(O), h();
      }, function(O) {
        n(O), h();
      }, R), b = null;
    }
    "onloadend" in b ? b.onloadend = m : b.onreadystatechange = function() {
      !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(m);
    }, b.onabort = function() {
      b && (n(new se("Request aborted", se.ECONNABORTED, e, b)), b = null);
    }, b.onerror = function() {
      n(new se("Network Error", se.ERR_NETWORK, e, b)), b = null;
    }, b.ontimeout = function() {
      let _ = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const R = s.transitional || rp;
      s.timeoutErrorMessage && (_ = s.timeoutErrorMessage), n(new se(
        _,
        R.clarifyTimeoutError ? se.ETIMEDOUT : se.ECONNABORTED,
        e,
        b
      )), b = null;
    }, i === void 0 && o.setContentType(null), "setRequestHeader" in b && B.forEach(o.toJSON(), function(_, R) {
      b.setRequestHeader(R, _);
    }), B.isUndefined(s.withCredentials) || (b.withCredentials = !!s.withCredentials), a && a !== "json" && (b.responseType = s.responseType), f && ([g, u] = Qn(f, !0), b.addEventListener("progress", g)), c && b.upload && ([d, p] = Qn(c), b.upload.addEventListener("progress", d), b.upload.addEventListener("loadend", p)), (s.cancelToken || s.signal) && (l = (y) => {
      b && (n(!y || y.type ? new Hr(null, e, b) : y), b.abort(), b = null);
    }, s.cancelToken && s.cancelToken.subscribe(l), s.signal && (s.signal.aborted ? l() : s.signal.addEventListener("abort", l)));
    const v = UE(s.url);
    if (v && ze.protocols.indexOf(v) === -1) {
      n(new se("Unsupported protocol " + v + ":", se.ERR_BAD_REQUEST, e));
      return;
    }
    b.send(i || null);
  });
}, pH = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), s;
    const i = function(f) {
      if (!s) {
        s = !0, a();
        const l = f instanceof Error ? f : this.reason;
        n.abort(l instanceof se ? l : new Hr(l instanceof Error ? l.message : l));
      }
    };
    let o = t && setTimeout(() => {
      o = null, i(new se(`timeout ${t} of ms exceeded`, se.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(i) : f.removeEventListener("abort", i);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", i));
    const { signal: c } = n;
    return c.unsubscribe = () => B.asap(a), c;
  }
}, hH = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, s;
  for (; n < r; )
    s = n + t, yield e.slice(n, s), n = s;
}, mH = async function* (e, t) {
  for await (const r of yH(e))
    yield* hH(r, t);
}, yH = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
}, tv = (e, t, r, n) => {
  const s = mH(e, t);
  let i = 0, o, a = (c) => {
    o || (o = !0, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: f, value: l } = await s.next();
        if (f) {
          a(), c.close();
          return;
        }
        let d = l.byteLength;
        if (r) {
          let g = i += d;
          r(g);
        }
        c.enqueue(new Uint8Array(l));
      } catch (f) {
        throw a(f), f;
      }
    },
    cancel(c) {
      return a(c), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, Va = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", VE = Va && typeof ReadableStream == "function", gH = Va && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), GE = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, vH = VE && GE(() => {
  let e = !1;
  const t = new Request(ze.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), rv = 64 * 1024, ju = VE && GE(() => B.isReadableStream(new Response("").body)), Zo = {
  stream: ju && ((e) => e.body)
};
Va && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Zo[t] && (Zo[t] = B.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new se(`Response type '${t}' is not supported`, se.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const bH = async (e) => {
  if (e == null)
    return 0;
  if (B.isBlob(e))
    return e.size;
  if (B.isSpecCompliantForm(e))
    return (await new Request(ze.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (B.isArrayBufferView(e) || B.isArrayBuffer(e))
    return e.byteLength;
  if (B.isURLSearchParams(e) && (e = e + ""), B.isString(e))
    return (await gH(e)).byteLength;
}, _H = async (e, t) => {
  const r = B.toFiniteNumber(e.getContentLength());
  return r ?? bH(t);
}, EH = Va && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: s,
    cancelToken: i,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: f,
    headers: l,
    withCredentials: d = "same-origin",
    fetchOptions: g
  } = BE(e);
  f = f ? (f + "").toLowerCase() : "text";
  let p = pH([s, i && i.toAbortSignal()], o), u;
  const h = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let b;
  try {
    if (c && vH && r !== "get" && r !== "head" && (b = await _H(l, n)) !== 0) {
      let R = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), E;
      if (B.isFormData(n) && (E = R.headers.get("content-type")) && l.setContentType(E), R.body) {
        const [O, z] = Yo(
          b,
          Qn(Xo(c))
        );
        n = tv(R.body, rv, O, z);
      }
    }
    B.isString(d) || (d = d ? "include" : "omit");
    const m = "credentials" in Request.prototype;
    u = new Request(t, {
      ...g,
      signal: p,
      method: r.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: m ? d : void 0
    });
    let v = await fetch(u);
    const y = ju && (f === "stream" || f === "response");
    if (ju && (a || y && h)) {
      const R = {};
      ["status", "statusText", "headers"].forEach((x) => {
        R[x] = v[x];
      });
      const E = B.toFiniteNumber(v.headers.get("content-length")), [O, z] = a && Yo(
        E,
        Qn(Xo(a), !0)
      ) || [];
      v = new Response(
        tv(v.body, rv, O, () => {
          z && z(), h && h();
        }),
        R
      );
    }
    f = f || "text";
    let _ = await Zo[B.findKey(Zo, f) || "text"](v, e);
    return !y && h && h(), await new Promise((R, E) => {
      Fn(R, E, {
        data: _,
        headers: dt.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: e,
        request: u
      });
    });
  } catch (m) {
    throw h && h(), m && m.name === "TypeError" && /fetch/i.test(m.message) ? Object.assign(
      new se("Network Error", se.ERR_NETWORK, e, u),
      {
        cause: m.cause || m
      }
    ) : se.from(m, m && m.code, e, u);
  }
}), Du = {
  http: cH,
  xhr: dH,
  fetch: EH
};
B.forEach(Du, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const nv = (e) => `- ${e}`, xH = (e) => B.isFunction(e) || e === null || e === !1, WE = {
  getAdapter: (e) => {
    e = B.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const s = {};
    for (let i = 0; i < t; i++) {
      r = e[i];
      let o;
      if (n = r, !xH(r) && (n = Du[(o = String(r)).toLowerCase()], n === void 0))
        throw new se(`Unknown adapter '${o}'`);
      if (n)
        break;
      s[o || "#" + i] = n;
    }
    if (!n) {
      const i = Object.entries(s).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? i.length > 1 ? `since :
` + i.map(nv).join(`
`) : " " + nv(i[0]) : "as no adapter specified";
      throw new se(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: Du
};
function Zl(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Hr(null, e);
}
function sv(e) {
  return Zl(e), e.headers = dt.from(e.headers), e.data = Vl.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), WE.getAdapter(e.adapter || xi.adapter)(e).then(function(n) {
    return Zl(e), n.data = Vl.call(
      e,
      e.transformResponse,
      n
    ), n.headers = dt.from(n.headers), n;
  }, function(n) {
    return kE(n) || (Zl(e), n && n.response && (n.response.data = Vl.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = dt.from(n.response.headers))), Promise.reject(n);
  });
}
const Ga = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Ga[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const iv = {};
Ga.transitional = function(t, r, n) {
  function s(i, o) {
    return "[Axios v" + Jo + "] Transitional option '" + i + "'" + o + (n ? ". " + n : "");
  }
  return (i, o, a) => {
    if (t === !1)
      throw new se(
        s(o, " has been removed" + (r ? " in " + r : "")),
        se.ERR_DEPRECATED
      );
    return r && !iv[o] && (iv[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(i, o, a) : !0;
  };
};
Ga.spelling = function(t) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function SH(e, t, r) {
  if (typeof e != "object")
    throw new se("options must be an object", se.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let s = n.length;
  for (; s-- > 0; ) {
    const i = n[s], o = t[i];
    if (o) {
      const a = e[i], c = a === void 0 || o(a, i, e);
      if (c !== !0)
        throw new se("option " + i + " must be " + c, se.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new se("Unknown option " + i, se.ERR_BAD_OPTION);
  }
}
const Oo = {
  assertOptions: SH,
  validators: Ga
}, ir = Oo.validators;
let fn = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Dg(),
      response: new Dg()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const i = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? i && !String(n.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + i) : n.stack = i;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = mn(this.defaults, r);
    const { transitional: n, paramsSerializer: s, headers: i } = r;
    n !== void 0 && Oo.assertOptions(n, {
      silentJSONParsing: ir.transitional(ir.boolean),
      forcedJSONParsing: ir.transitional(ir.boolean),
      clarifyTimeoutError: ir.transitional(ir.boolean)
    }, !1), s != null && (B.isFunction(s) ? r.paramsSerializer = {
      serialize: s
    } : Oo.assertOptions(s, {
      encode: ir.function,
      serialize: ir.function
    }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Oo.assertOptions(r, {
      baseUrl: ir.spelling("baseURL"),
      withXsrfToken: ir.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = i && B.merge(
      i.common,
      i[r.method]
    );
    i && B.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (u) => {
        delete i[u];
      }
    ), r.headers = dt.concat(o, i);
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(h) {
      typeof h.runWhen == "function" && h.runWhen(r) === !1 || (c = c && h.synchronous, a.unshift(h.fulfilled, h.rejected));
    });
    const f = [];
    this.interceptors.response.forEach(function(h) {
      f.push(h.fulfilled, h.rejected);
    });
    let l, d = 0, g;
    if (!c) {
      const u = [sv.bind(this), void 0];
      for (u.unshift.apply(u, a), u.push.apply(u, f), g = u.length, l = Promise.resolve(r); d < g; )
        l = l.then(u[d++], u[d++]);
      return l;
    }
    g = a.length;
    let p = r;
    for (d = 0; d < g; ) {
      const u = a[d++], h = a[d++];
      try {
        p = u(p);
      } catch (b) {
        h.call(this, b);
        break;
      }
    }
    try {
      l = sv.call(this, p);
    } catch (u) {
      return Promise.reject(u);
    }
    for (d = 0, g = f.length; d < g; )
      l = l.then(f[d++], f[d++]);
    return l;
  }
  getUri(t) {
    t = mn(this.defaults, t);
    const r = sp(t.baseURL, t.url, t.allowAbsoluteUrls);
    return tp(r, t.params, t.paramsSerializer);
  }
};
B.forEach(["delete", "get", "head", "options"], function(t) {
  fn.prototype[t] = function(r, n) {
    return this.request(mn(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
B.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(i, o, a) {
      return this.request(mn(a || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: o
      }));
    };
  }
  fn.prototype[t] = r(), fn.prototype[t + "Form"] = r(!0);
});
let wH = class KE {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(i) {
      r = i;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners) return;
      let i = n._listeners.length;
      for (; i-- > 0; )
        n._listeners[i](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let i;
      const o = new Promise((a) => {
        n.subscribe(a), i = a;
      }).then(s);
      return o.cancel = function() {
        n.unsubscribe(i);
      }, o;
    }, t(function(i, o, a) {
      n.reason || (n.reason = new Hr(i, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new KE(function(s) {
        t = s;
      }),
      cancel: t
    };
  }
};
function RH(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function $H(e) {
  return B.isObject(e) && e.isAxiosError === !0;
}
const Fu = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Fu).forEach(([e, t]) => {
  Fu[t] = e;
});
function JE(e) {
  const t = new fn(e), r = eE(fn.prototype.request, t);
  return B.extend(r, fn.prototype, t, { allOwnKeys: !0 }), B.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(s) {
    return JE(mn(e, s));
  }, r;
}
const Be = JE(xi);
Be.Axios = fn;
Be.CanceledError = Hr;
Be.CancelToken = wH;
Be.isCancel = kE;
Be.VERSION = Jo;
Be.toFormData = Ba;
Be.AxiosError = se;
Be.Cancel = Be.CanceledError;
Be.all = function(t) {
  return Promise.all(t);
};
Be.spread = RH;
Be.isAxiosError = $H;
Be.mergeConfig = mn;
Be.AxiosHeaders = dt;
Be.formToJSON = (e) => AE(B.isHTMLForm(e) ? new FormData(e) : e);
Be.getAdapter = WE.getAdapter;
Be.HttpStatusCode = Fu;
Be.default = Be;
const {
  Axios: X3,
  AxiosError: Z3,
  CanceledError: Q3,
  isCancel: e4,
  CancelToken: t4,
  VERSION: r4,
  all: n4,
  Cancel: s4,
  isAxiosError: i4,
  spread: o4,
  toFormData: a4,
  AxiosHeaders: c4,
  HttpStatusCode: l4,
  formToJSON: u4,
  getAdapter: f4,
  mergeConfig: d4
} = Be;
var YE = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(be, function() {
    var r = 1e3, n = 6e4, s = 36e5, i = "millisecond", o = "second", a = "minute", c = "hour", f = "day", l = "week", d = "month", g = "quarter", p = "year", u = "date", h = "Invalid Date", b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(S) {
      var I = ["th", "st", "nd", "rd"], T = S % 100;
      return "[" + S + (I[(T - 20) % 10] || I[T] || I[0]) + "]";
    } }, y = function(S, I, T) {
      var j = String(S);
      return !j || j.length >= I ? S : "" + Array(I + 1 - j.length).join(T) + S;
    }, _ = { s: y, z: function(S) {
      var I = -S.utcOffset(), T = Math.abs(I), j = Math.floor(T / 60), P = T % 60;
      return (I <= 0 ? "+" : "-") + y(j, 2, "0") + ":" + y(P, 2, "0");
    }, m: function S(I, T) {
      if (I.date() < T.date()) return -S(T, I);
      var j = 12 * (T.year() - I.year()) + (T.month() - I.month()), P = I.clone().add(j, d), A = T - P < 0, k = I.clone().add(j + (A ? -1 : 1), d);
      return +(-(j + (T - P) / (A ? P - k : k - P)) || 0);
    }, a: function(S) {
      return S < 0 ? Math.ceil(S) || 0 : Math.floor(S);
    }, p: function(S) {
      return { M: d, y: p, w: l, d: f, D: u, h: c, m: a, s: o, ms: i, Q: g }[S] || String(S || "").toLowerCase().replace(/s$/, "");
    }, u: function(S) {
      return S === void 0;
    } }, R = "en", E = {};
    E[R] = v;
    var O = "$isDayjsObject", z = function(S) {
      return S instanceof U || !(!S || !S[O]);
    }, x = function S(I, T, j) {
      var P;
      if (!I) return R;
      if (typeof I == "string") {
        var A = I.toLowerCase();
        E[A] && (P = A), T && (E[A] = T, P = A);
        var k = I.split("-");
        if (!P && k.length > 1) return S(k[0]);
      } else {
        var C = I.name;
        E[C] = I, P = C;
      }
      return !j && P && (R = P), P || !j && R;
    }, L = function(S, I) {
      if (z(S)) return S.clone();
      var T = typeof I == "object" ? I : {};
      return T.date = S, T.args = arguments, new U(T);
    }, M = _;
    M.l = x, M.i = z, M.w = function(S, I) {
      return L(S, { locale: I.$L, utc: I.$u, x: I.$x, $offset: I.$offset });
    };
    var U = function() {
      function S(T) {
        this.$L = x(T.locale, null, !0), this.parse(T), this.$x = this.$x || T.x || {}, this[O] = !0;
      }
      var I = S.prototype;
      return I.parse = function(T) {
        this.$d = function(j) {
          var P = j.date, A = j.utc;
          if (P === null) return /* @__PURE__ */ new Date(NaN);
          if (M.u(P)) return /* @__PURE__ */ new Date();
          if (P instanceof Date) return new Date(P);
          if (typeof P == "string" && !/Z$/i.test(P)) {
            var k = P.match(b);
            if (k) {
              var C = k[2] - 1 || 0, D = (k[7] || "0").substring(0, 3);
              return A ? new Date(Date.UTC(k[1], C, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, D)) : new Date(k[1], C, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, D);
            }
          }
          return new Date(P);
        }(T), this.init();
      }, I.init = function() {
        var T = this.$d;
        this.$y = T.getFullYear(), this.$M = T.getMonth(), this.$D = T.getDate(), this.$W = T.getDay(), this.$H = T.getHours(), this.$m = T.getMinutes(), this.$s = T.getSeconds(), this.$ms = T.getMilliseconds();
      }, I.$utils = function() {
        return M;
      }, I.isValid = function() {
        return this.$d.toString() !== h;
      }, I.isSame = function(T, j) {
        var P = L(T);
        return this.startOf(j) <= P && P <= this.endOf(j);
      }, I.isAfter = function(T, j) {
        return L(T) < this.startOf(j);
      }, I.isBefore = function(T, j) {
        return this.endOf(j) < L(T);
      }, I.$g = function(T, j, P) {
        return M.u(T) ? this[j] : this.set(P, T);
      }, I.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, I.valueOf = function() {
        return this.$d.getTime();
      }, I.startOf = function(T, j) {
        var P = this, A = !!M.u(j) || j, k = M.p(T), C = function(Z, Y) {
          var J = M.w(P.$u ? Date.UTC(P.$y, Y, Z) : new Date(P.$y, Y, Z), P);
          return A ? J : J.endOf(f);
        }, D = function(Z, Y) {
          return M.w(P.toDate()[Z].apply(P.toDate("s"), (A ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Y)), P);
        }, F = this.$W, w = this.$M, N = this.$D, q = "set" + (this.$u ? "UTC" : "");
        switch (k) {
          case p:
            return A ? C(1, 0) : C(31, 11);
          case d:
            return A ? C(1, w) : C(0, w + 1);
          case l:
            var K = this.$locale().weekStart || 0, V = (F < K ? F + 7 : F) - K;
            return C(A ? N - V : N + (6 - V), w);
          case f:
          case u:
            return D(q + "Hours", 0);
          case c:
            return D(q + "Minutes", 1);
          case a:
            return D(q + "Seconds", 2);
          case o:
            return D(q + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, I.endOf = function(T) {
        return this.startOf(T, !1);
      }, I.$set = function(T, j) {
        var P, A = M.p(T), k = "set" + (this.$u ? "UTC" : ""), C = (P = {}, P[f] = k + "Date", P[u] = k + "Date", P[d] = k + "Month", P[p] = k + "FullYear", P[c] = k + "Hours", P[a] = k + "Minutes", P[o] = k + "Seconds", P[i] = k + "Milliseconds", P)[A], D = A === f ? this.$D + (j - this.$W) : j;
        if (A === d || A === p) {
          var F = this.clone().set(u, 1);
          F.$d[C](D), F.init(), this.$d = F.set(u, Math.min(this.$D, F.daysInMonth())).$d;
        } else C && this.$d[C](D);
        return this.init(), this;
      }, I.set = function(T, j) {
        return this.clone().$set(T, j);
      }, I.get = function(T) {
        return this[M.p(T)]();
      }, I.add = function(T, j) {
        var P, A = this;
        T = Number(T);
        var k = M.p(j), C = function(w) {
          var N = L(A);
          return M.w(N.date(N.date() + Math.round(w * T)), A);
        };
        if (k === d) return this.set(d, this.$M + T);
        if (k === p) return this.set(p, this.$y + T);
        if (k === f) return C(1);
        if (k === l) return C(7);
        var D = (P = {}, P[a] = n, P[c] = s, P[o] = r, P)[k] || 1, F = this.$d.getTime() + T * D;
        return M.w(F, this);
      }, I.subtract = function(T, j) {
        return this.add(-1 * T, j);
      }, I.format = function(T) {
        var j = this, P = this.$locale();
        if (!this.isValid()) return P.invalidDate || h;
        var A = T || "YYYY-MM-DDTHH:mm:ssZ", k = M.z(this), C = this.$H, D = this.$m, F = this.$M, w = P.weekdays, N = P.months, q = P.meridiem, K = function(Y, J, H, W) {
          return Y && (Y[J] || Y(j, A)) || H[J].slice(0, W);
        }, V = function(Y) {
          return M.s(C % 12 || 12, Y, "0");
        }, Z = q || function(Y, J, H) {
          var W = Y < 12 ? "AM" : "PM";
          return H ? W.toLowerCase() : W;
        };
        return A.replace(m, function(Y, J) {
          return J || function(H) {
            switch (H) {
              case "YY":
                return String(j.$y).slice(-2);
              case "YYYY":
                return M.s(j.$y, 4, "0");
              case "M":
                return F + 1;
              case "MM":
                return M.s(F + 1, 2, "0");
              case "MMM":
                return K(P.monthsShort, F, N, 3);
              case "MMMM":
                return K(N, F);
              case "D":
                return j.$D;
              case "DD":
                return M.s(j.$D, 2, "0");
              case "d":
                return String(j.$W);
              case "dd":
                return K(P.weekdaysMin, j.$W, w, 2);
              case "ddd":
                return K(P.weekdaysShort, j.$W, w, 3);
              case "dddd":
                return w[j.$W];
              case "H":
                return String(C);
              case "HH":
                return M.s(C, 2, "0");
              case "h":
                return V(1);
              case "hh":
                return V(2);
              case "a":
                return Z(C, D, !0);
              case "A":
                return Z(C, D, !1);
              case "m":
                return String(D);
              case "mm":
                return M.s(D, 2, "0");
              case "s":
                return String(j.$s);
              case "ss":
                return M.s(j.$s, 2, "0");
              case "SSS":
                return M.s(j.$ms, 3, "0");
              case "Z":
                return k;
            }
            return null;
          }(Y) || k.replace(":", "");
        });
      }, I.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, I.diff = function(T, j, P) {
        var A, k = this, C = M.p(j), D = L(T), F = (D.utcOffset() - this.utcOffset()) * n, w = this - D, N = function() {
          return M.m(k, D);
        };
        switch (C) {
          case p:
            A = N() / 12;
            break;
          case d:
            A = N();
            break;
          case g:
            A = N() / 3;
            break;
          case l:
            A = (w - F) / 6048e5;
            break;
          case f:
            A = (w - F) / 864e5;
            break;
          case c:
            A = w / s;
            break;
          case a:
            A = w / n;
            break;
          case o:
            A = w / r;
            break;
          default:
            A = w;
        }
        return P ? A : M.a(A);
      }, I.daysInMonth = function() {
        return this.endOf(d).$D;
      }, I.$locale = function() {
        return E[this.$L];
      }, I.locale = function(T, j) {
        if (!T) return this.$L;
        var P = this.clone(), A = x(T, j, !0);
        return A && (P.$L = A), P;
      }, I.clone = function() {
        return M.w(this.$d, this);
      }, I.toDate = function() {
        return new Date(this.valueOf());
      }, I.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, I.toISOString = function() {
        return this.$d.toISOString();
      }, I.toString = function() {
        return this.$d.toUTCString();
      }, S;
    }(), $ = U.prototype;
    return L.prototype = $, [["$ms", i], ["$s", o], ["$m", a], ["$H", c], ["$W", f], ["$M", d], ["$y", p], ["$D", u]].forEach(function(S) {
      $[S[1]] = function(I) {
        return this.$g(I, S[0], S[1]);
      };
    }), L.extend = function(S, I) {
      return S.$i || (S(I, U, L), S.$i = !0), L;
    }, L.locale = x, L.isDayjs = z, L.unix = function(S) {
      return L(1e3 * S);
    }, L.en = E[R], L.Ls = E, L.p = {}, L;
  });
})(YE);
var TH = YE.exports;
const OH = /* @__PURE__ */ si(TH);
var ds = { exports: {} }, XE = {
  /* The local file header */
  LOCHDR: 30,
  // LOC header size
  LOCSIG: 67324752,
  // "PK\003\004"
  LOCVER: 4,
  // version needed to extract
  LOCFLG: 6,
  // general purpose bit flag
  LOCHOW: 8,
  // compression method
  LOCTIM: 10,
  // modification time (2 bytes time, 2 bytes date)
  LOCCRC: 14,
  // uncompressed file crc-32 value
  LOCSIZ: 18,
  // compressed size
  LOCLEN: 22,
  // uncompressed size
  LOCNAM: 26,
  // filename length
  LOCEXT: 28,
  // extra field length
  /* The Data descriptor */
  EXTSIG: 134695760,
  // "PK\007\008"
  EXTHDR: 16,
  // EXT header size
  EXTCRC: 4,
  // uncompressed file crc-32 value
  EXTSIZ: 8,
  // compressed size
  EXTLEN: 12,
  // uncompressed size
  /* The central directory file header */
  CENHDR: 46,
  // CEN header size
  CENSIG: 33639248,
  // "PK\001\002"
  CENVEM: 4,
  // version made by
  CENVER: 6,
  // version needed to extract
  CENFLG: 8,
  // encrypt, decrypt flags
  CENHOW: 10,
  // compression method
  CENTIM: 12,
  // modification time (2 bytes time, 2 bytes date)
  CENCRC: 16,
  // uncompressed file crc-32 value
  CENSIZ: 20,
  // compressed size
  CENLEN: 24,
  // uncompressed size
  CENNAM: 28,
  // filename length
  CENEXT: 30,
  // extra field length
  CENCOM: 32,
  // file comment length
  CENDSK: 34,
  // volume number start
  CENATT: 36,
  // internal file attributes
  CENATX: 38,
  // external file attributes (host system dependent)
  CENOFF: 42,
  // LOC header offset
  /* The entries in the end of central directory */
  ENDHDR: 22,
  // END header size
  ENDSIG: 101010256,
  // "PK\005\006"
  ENDSUB: 8,
  // number of entries on this disk
  ENDTOT: 10,
  // total number of entries
  ENDSIZ: 12,
  // central directory size in bytes
  ENDOFF: 16,
  // offset of first CEN header
  ENDCOM: 20,
  // zip file comment length
  END64HDR: 20,
  // zip64 END header size
  END64SIG: 117853008,
  // zip64 Locator signature, "PK\006\007"
  END64START: 4,
  // number of the disk with the start of the zip64
  END64OFF: 8,
  // relative offset of the zip64 end of central directory
  END64NUMDISKS: 16,
  // total number of disks
  ZIP64SIG: 101075792,
  // zip64 signature, "PK\006\006"
  ZIP64HDR: 56,
  // zip64 record minimum size
  ZIP64LEAD: 12,
  // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
  ZIP64SIZE: 4,
  // zip64 size of the central directory record
  ZIP64VEM: 12,
  // zip64 version made by
  ZIP64VER: 14,
  // zip64 version needed to extract
  ZIP64DSK: 16,
  // zip64 number of this disk
  ZIP64DSKDIR: 20,
  // number of the disk with the start of the record directory
  ZIP64SUB: 24,
  // number of entries on this disk
  ZIP64TOT: 32,
  // total number of entries
  ZIP64SIZB: 40,
  // zip64 central directory size in bytes
  ZIP64OFF: 48,
  // offset of start of central directory with respect to the starting disk number
  ZIP64EXTRA: 56,
  // extensible data sector
  /* Compression methods */
  STORED: 0,
  // no compression
  SHRUNK: 1,
  // shrunk
  REDUCED1: 2,
  // reduced with compression factor 1
  REDUCED2: 3,
  // reduced with compression factor 2
  REDUCED3: 4,
  // reduced with compression factor 3
  REDUCED4: 5,
  // reduced with compression factor 4
  IMPLODED: 6,
  // imploded
  // 7 reserved for Tokenizing compression algorithm
  DEFLATED: 8,
  // deflated
  ENHANCED_DEFLATED: 9,
  // enhanced deflated
  PKWARE: 10,
  // PKWare DCL imploded
  // 11 reserved by PKWARE
  BZIP2: 12,
  //  compressed using BZIP2
  // 13 reserved by PKWARE
  LZMA: 14,
  // LZMA
  // 15-17 reserved by PKWARE
  IBM_TERSE: 18,
  // compressed using IBM TERSE
  IBM_LZ77: 19,
  // IBM LZ77 z
  AES_ENCRYPT: 99,
  // WinZIP AES encryption method
  /* General purpose bit flag */
  // values can obtained with expression 2**bitnr
  FLG_ENC: 1,
  // Bit 0: encrypted file
  FLG_COMP1: 2,
  // Bit 1, compression option
  FLG_COMP2: 4,
  // Bit 2, compression option
  FLG_DESC: 8,
  // Bit 3, data descriptor
  FLG_ENH: 16,
  // Bit 4, enhanced deflating
  FLG_PATCH: 32,
  // Bit 5, indicates that the file is compressed patched data.
  FLG_STR: 64,
  // Bit 6, strong encryption (patented)
  // Bits 7-10: Currently unused.
  FLG_EFS: 2048,
  // Bit 11: Language encoding flag (EFS)
  // Bit 12: Reserved by PKWARE for enhanced compression.
  // Bit 13: encrypted the Central Directory (patented).
  // Bits 14-15: Reserved by PKWARE.
  FLG_MSK: 4096,
  // mask header values
  /* Load type */
  FILE: 2,
  BUFFER: 1,
  NONE: 0,
  /* 4.5 Extensible data fields */
  EF_ID: 0,
  EF_SIZE: 2,
  /* Header IDs */
  ID_ZIP64: 1,
  ID_AVINFO: 7,
  ID_PFS: 8,
  ID_OS2: 9,
  ID_NTFS: 10,
  ID_OPENVMS: 12,
  ID_UNIX: 13,
  ID_FORK: 14,
  ID_PATCH: 15,
  ID_X509_PKCS7: 20,
  ID_X509_CERTID_F: 21,
  ID_X509_CERTID_C: 22,
  ID_STRONGENC: 23,
  ID_RECORD_MGT: 24,
  ID_X509_PKCS7_RL: 25,
  ID_IBM1: 101,
  ID_IBM2: 102,
  ID_POSZIP: 18064,
  EF_ZIP64_OR_32: 4294967295,
  EF_ZIP64_OR_16: 65535,
  EF_ZIP64_SUNCOMP: 0,
  EF_ZIP64_SCOMP: 8,
  EF_ZIP64_RHO: 16,
  EF_ZIP64_DSN: 24
}, Wa = {};
(function(e) {
  const t = {
    /* Header error messages */
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",
    /* Descriptor */
    DESCRIPTOR_NOT_EXIST: "No descriptor present",
    DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
    DESCRIPTOR_FAULTY: "Descriptor data is malformed",
    /* ZipEntry error messages*/
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed {0}",
    FILE_IN_THE_WAY: "There is a file in the way: {0}",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",
    /* Inflater error messages */
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
    /* ADM-ZIP error messages */
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: 'File not found: "{0}"',
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
    INVALID_PASS_PARAM: "Incompatible password parameter",
    WRONG_PASSWORD: "Wrong Password",
    /* ADM-ZIP */
    COMMENT_TOO_LONG: "Comment is too long",
    // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)
    EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
  };
  function r(n) {
    return function(...s) {
      return s.length && (n = n.replace(/\{(\d)\}/g, (i, o) => s[o] || "")), new Error("ADM-ZIP: " + n);
    };
  }
  for (const n of Object.keys(t))
    e[n] = r(t[n]);
})(Wa);
const PH = gt, et = $t, ov = XE, CH = Wa, IH = typeof process == "object" && process.platform === "win32", av = (e) => typeof e == "object" && e !== null, ZE = new Uint32Array(256).map((e, t) => {
  for (let r = 0; r < 8; r++)
    t & 1 ? t = 3988292384 ^ t >>> 1 : t >>>= 1;
  return t >>> 0;
});
function Ve(e) {
  this.sep = et.sep, this.fs = PH, av(e) && av(e.fs) && typeof e.fs.statSync == "function" && (this.fs = e.fs);
}
var NH = Ve;
Ve.prototype.makeDir = function(e) {
  const t = this;
  function r(n) {
    let s = n.split(t.sep)[0];
    n.split(t.sep).forEach(function(i) {
      if (!(!i || i.substr(-1, 1) === ":")) {
        s += t.sep + i;
        var o;
        try {
          o = t.fs.statSync(s);
        } catch {
          t.fs.mkdirSync(s);
        }
        if (o && o.isFile()) throw CH.FILE_IN_THE_WAY(`"${s}"`);
      }
    });
  }
  r(e);
};
Ve.prototype.writeFileTo = function(e, t, r, n) {
  const s = this;
  if (s.fs.existsSync(e)) {
    if (!r) return !1;
    var i = s.fs.statSync(e);
    if (i.isDirectory())
      return !1;
  }
  var o = et.dirname(e);
  s.fs.existsSync(o) || s.makeDir(o);
  var a;
  try {
    a = s.fs.openSync(e, "w", 438);
  } catch {
    s.fs.chmodSync(e, 438), a = s.fs.openSync(e, "w", 438);
  }
  if (a)
    try {
      s.fs.writeSync(a, t, 0, t.length, 0);
    } finally {
      s.fs.closeSync(a);
    }
  return s.fs.chmodSync(e, n || 438), !0;
};
Ve.prototype.writeFileToAsync = function(e, t, r, n, s) {
  typeof n == "function" && (s = n, n = void 0);
  const i = this;
  i.fs.exists(e, function(o) {
    if (o && !r) return s(!1);
    i.fs.stat(e, function(a, c) {
      if (o && c.isDirectory())
        return s(!1);
      var f = et.dirname(e);
      i.fs.exists(f, function(l) {
        l || i.makeDir(f), i.fs.open(e, "w", 438, function(d, g) {
          d ? i.fs.chmod(e, 438, function() {
            i.fs.open(e, "w", 438, function(p, u) {
              i.fs.write(u, t, 0, t.length, 0, function() {
                i.fs.close(u, function() {
                  i.fs.chmod(e, n || 438, function() {
                    s(!0);
                  });
                });
              });
            });
          }) : g ? i.fs.write(g, t, 0, t.length, 0, function() {
            i.fs.close(g, function() {
              i.fs.chmod(e, n || 438, function() {
                s(!0);
              });
            });
          }) : i.fs.chmod(e, n || 438, function() {
            s(!0);
          });
        });
      });
    });
  });
};
Ve.prototype.findFiles = function(e) {
  const t = this;
  function r(n, s, i) {
    let o = [];
    return t.fs.readdirSync(n).forEach(function(a) {
      const c = et.join(n, a), f = t.fs.statSync(c);
      o.push(et.normalize(c) + (f.isDirectory() ? t.sep : "")), f.isDirectory() && i && (o = o.concat(r(c, s, i)));
    }), o;
  }
  return r(e, void 0, !0);
};
Ve.prototype.findFilesAsync = function(e, t) {
  const r = this;
  let n = [];
  r.fs.readdir(e, function(s, i) {
    if (s) return t(s);
    let o = i.length;
    if (!o) return t(null, n);
    i.forEach(function(a) {
      a = et.join(e, a), r.fs.stat(a, function(c, f) {
        if (c) return t(c);
        f && (n.push(et.normalize(a) + (f.isDirectory() ? r.sep : "")), f.isDirectory() ? r.findFilesAsync(a, function(l, d) {
          if (l) return t(l);
          n = n.concat(d), --o || t(null, n);
        }) : --o || t(null, n));
      });
    });
  });
};
Ve.prototype.getAttributes = function() {
};
Ve.prototype.setAttributes = function() {
};
Ve.crc32update = function(e, t) {
  return ZE[(e ^ t) & 255] ^ e >>> 8;
};
Ve.crc32 = function(e) {
  typeof e == "string" && (e = Buffer.from(e, "utf8"));
  let t = e.length, r = -1;
  for (let n = 0; n < t; ) r = Ve.crc32update(r, e[n++]);
  return ~r >>> 0;
};
Ve.methodToString = function(e) {
  switch (e) {
    case ov.STORED:
      return "STORED (" + e + ")";
    case ov.DEFLATED:
      return "DEFLATED (" + e + ")";
    default:
      return "UNSUPPORTED (" + e + ")";
  }
};
Ve.canonical = function(e) {
  if (!e) return "";
  const t = et.posix.normalize("/" + e.split("\\").join("/"));
  return et.join(".", t);
};
Ve.zipnamefix = function(e) {
  if (!e) return "";
  const t = et.posix.normalize("/" + e.split("\\").join("/"));
  return et.posix.join(".", t);
};
Ve.findLast = function(e, t) {
  if (!Array.isArray(e)) throw new TypeError("arr is not array");
  const r = e.length >>> 0;
  for (let n = r - 1; n >= 0; n--)
    if (t(e[n], n, e))
      return e[n];
};
Ve.sanitize = function(e, t) {
  e = et.resolve(et.normalize(e));
  for (var r = t.split("/"), n = 0, s = r.length; n < s; n++) {
    var i = et.normalize(et.join(e, r.slice(n, s).join(et.sep)));
    if (i.indexOf(e) === 0)
      return i;
  }
  return et.normalize(et.join(e, et.basename(t)));
};
Ve.toBuffer = function(t, r) {
  return Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? Buffer.from(t) : typeof t == "string" ? r(t) : Buffer.alloc(0);
};
Ve.readBigUInt64LE = function(e, t) {
  var r = Buffer.from(e.slice(t, t + 8));
  return r.swap64(), parseInt(`0x${r.toString("hex")}`);
};
Ve.fromDOS2Date = function(e) {
  return new Date((e >> 25 & 127) + 1980, Math.max((e >> 21 & 15) - 1, 0), Math.max(e >> 16 & 31, 1), e >> 11 & 31, e >> 5 & 63, (e & 31) << 1);
};
Ve.fromDate2DOS = function(e) {
  let t = 0, r = 0;
  return e.getFullYear() > 1979 && (t = (e.getFullYear() - 1980 & 127) << 9 | e.getMonth() + 1 << 5 | e.getDate(), r = e.getHours() << 11 | e.getMinutes() << 5 | e.getSeconds() >> 1), t << 16 | r;
};
Ve.isWin = IH;
Ve.crcTable = ZE;
const AH = $t;
var kH = function(e, { fs: t }) {
  var r = e || "", n = i(), s = null;
  function i() {
    return {
      directory: !1,
      readonly: !1,
      hidden: !1,
      executable: !1,
      mtime: 0,
      atime: 0
    };
  }
  return r && t.existsSync(r) ? (s = t.statSync(r), n.directory = s.isDirectory(), n.mtime = s.mtime, n.atime = s.atime, n.executable = (73 & s.mode) !== 0, n.readonly = (128 & s.mode) === 0, n.hidden = AH.basename(r)[0] === ".") : console.warn("Invalid path: " + r), {
    get directory() {
      return n.directory;
    },
    get readOnly() {
      return n.readonly;
    },
    get hidden() {
      return n.hidden;
    },
    get mtime() {
      return n.mtime;
    },
    get atime() {
      return n.atime;
    },
    get executable() {
      return n.executable;
    },
    decodeAttributes: function() {
    },
    encodeAttributes: function() {
    },
    toJSON: function() {
      return {
        path: r,
        isDirectory: n.directory,
        isReadOnly: n.readonly,
        isHidden: n.hidden,
        isExecutable: n.executable,
        mTime: n.mtime,
        aTime: n.atime
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
}, LH = {
  efs: !0,
  encode: (e) => Buffer.from(e, "utf8"),
  decode: (e) => e.toString("utf8")
};
ds.exports = NH;
ds.exports.Constants = XE;
ds.exports.Errors = Wa;
ds.exports.FileAttr = kH;
ds.exports.decoder = LH;
var Ri = ds.exports, Ka = {}, kr = Ri, ne = kr.Constants, jH = function() {
  var e = 20, t = 10, r = 0, n = 0, s = 0, i = 0, o = 0, a = 0, c = 0, f = 0, l = 0, d = 0, g = 0, p = 0, u = 0;
  e |= kr.isWin ? 2560 : 768, r |= ne.FLG_EFS;
  const h = {
    extraLen: 0
  }, b = (v) => Math.max(0, v) >>> 0, m = (v) => Math.max(0, v) & 255;
  return s = kr.fromDate2DOS(/* @__PURE__ */ new Date()), {
    get made() {
      return e;
    },
    set made(v) {
      e = v;
    },
    get version() {
      return t;
    },
    set version(v) {
      t = v;
    },
    get flags() {
      return r;
    },
    set flags(v) {
      r = v;
    },
    get flags_efs() {
      return (r & ne.FLG_EFS) > 0;
    },
    set flags_efs(v) {
      v ? r |= ne.FLG_EFS : r &= ~ne.FLG_EFS;
    },
    get flags_desc() {
      return (r & ne.FLG_DESC) > 0;
    },
    set flags_desc(v) {
      v ? r |= ne.FLG_DESC : r &= ~ne.FLG_DESC;
    },
    get method() {
      return n;
    },
    set method(v) {
      switch (v) {
        case ne.STORED:
          this.version = 10;
        case ne.DEFLATED:
        default:
          this.version = 20;
      }
      n = v;
    },
    get time() {
      return kr.fromDOS2Date(this.timeval);
    },
    set time(v) {
      this.timeval = kr.fromDate2DOS(v);
    },
    get timeval() {
      return s;
    },
    set timeval(v) {
      s = b(v);
    },
    get timeHighByte() {
      return m(s >>> 8);
    },
    get crc() {
      return i;
    },
    set crc(v) {
      i = b(v);
    },
    get compressedSize() {
      return o;
    },
    set compressedSize(v) {
      o = b(v);
    },
    get size() {
      return a;
    },
    set size(v) {
      a = b(v);
    },
    get fileNameLength() {
      return c;
    },
    set fileNameLength(v) {
      c = v;
    },
    get extraLength() {
      return f;
    },
    set extraLength(v) {
      f = v;
    },
    get extraLocalLength() {
      return h.extraLen;
    },
    set extraLocalLength(v) {
      h.extraLen = v;
    },
    get commentLength() {
      return l;
    },
    set commentLength(v) {
      l = v;
    },
    get diskNumStart() {
      return d;
    },
    set diskNumStart(v) {
      d = b(v);
    },
    get inAttr() {
      return g;
    },
    set inAttr(v) {
      g = b(v);
    },
    get attr() {
      return p;
    },
    set attr(v) {
      p = b(v);
    },
    // get Unix file permissions
    get fileAttr() {
      return (p || 0) >> 16 & 4095;
    },
    get offset() {
      return u;
    },
    set offset(v) {
      u = b(v);
    },
    get encrypted() {
      return (r & ne.FLG_ENC) === ne.FLG_ENC;
    },
    get centralHeaderSize() {
      return ne.CENHDR + c + f + l;
    },
    get realDataOffset() {
      return u + ne.LOCHDR + h.fnameLen + h.extraLen;
    },
    get localHeader() {
      return h;
    },
    loadLocalHeaderFromBinary: function(v) {
      var y = v.slice(u, u + ne.LOCHDR);
      if (y.readUInt32LE(0) !== ne.LOCSIG)
        throw kr.Errors.INVALID_LOC();
      h.version = y.readUInt16LE(ne.LOCVER), h.flags = y.readUInt16LE(ne.LOCFLG), h.method = y.readUInt16LE(ne.LOCHOW), h.time = y.readUInt32LE(ne.LOCTIM), h.crc = y.readUInt32LE(ne.LOCCRC), h.compressedSize = y.readUInt32LE(ne.LOCSIZ), h.size = y.readUInt32LE(ne.LOCLEN), h.fnameLen = y.readUInt16LE(ne.LOCNAM), h.extraLen = y.readUInt16LE(ne.LOCEXT);
      const _ = u + ne.LOCHDR + h.fnameLen, R = _ + h.extraLen;
      return v.slice(_, R);
    },
    loadFromBinary: function(v) {
      if (v.length !== ne.CENHDR || v.readUInt32LE(0) !== ne.CENSIG)
        throw kr.Errors.INVALID_CEN();
      e = v.readUInt16LE(ne.CENVEM), t = v.readUInt16LE(ne.CENVER), r = v.readUInt16LE(ne.CENFLG), n = v.readUInt16LE(ne.CENHOW), s = v.readUInt32LE(ne.CENTIM), i = v.readUInt32LE(ne.CENCRC), o = v.readUInt32LE(ne.CENSIZ), a = v.readUInt32LE(ne.CENLEN), c = v.readUInt16LE(ne.CENNAM), f = v.readUInt16LE(ne.CENEXT), l = v.readUInt16LE(ne.CENCOM), d = v.readUInt16LE(ne.CENDSK), g = v.readUInt16LE(ne.CENATT), p = v.readUInt32LE(ne.CENATX), u = v.readUInt32LE(ne.CENOFF);
    },
    localHeaderToBinary: function() {
      var v = Buffer.alloc(ne.LOCHDR);
      return v.writeUInt32LE(ne.LOCSIG, 0), v.writeUInt16LE(t, ne.LOCVER), v.writeUInt16LE(r, ne.LOCFLG), v.writeUInt16LE(n, ne.LOCHOW), v.writeUInt32LE(s, ne.LOCTIM), v.writeUInt32LE(i, ne.LOCCRC), v.writeUInt32LE(o, ne.LOCSIZ), v.writeUInt32LE(a, ne.LOCLEN), v.writeUInt16LE(c, ne.LOCNAM), v.writeUInt16LE(h.extraLen, ne.LOCEXT), v;
    },
    centralHeaderToBinary: function() {
      var v = Buffer.alloc(ne.CENHDR + c + f + l);
      return v.writeUInt32LE(ne.CENSIG, 0), v.writeUInt16LE(e, ne.CENVEM), v.writeUInt16LE(t, ne.CENVER), v.writeUInt16LE(r, ne.CENFLG), v.writeUInt16LE(n, ne.CENHOW), v.writeUInt32LE(s, ne.CENTIM), v.writeUInt32LE(i, ne.CENCRC), v.writeUInt32LE(o, ne.CENSIZ), v.writeUInt32LE(a, ne.CENLEN), v.writeUInt16LE(c, ne.CENNAM), v.writeUInt16LE(f, ne.CENEXT), v.writeUInt16LE(l, ne.CENCOM), v.writeUInt16LE(d, ne.CENDSK), v.writeUInt16LE(g, ne.CENATT), v.writeUInt32LE(p, ne.CENATX), v.writeUInt32LE(u, ne.CENOFF), v;
    },
    toJSON: function() {
      const v = function(y) {
        return y + " bytes";
      };
      return {
        made: e,
        version: t,
        flags: r,
        method: kr.methodToString(n),
        time: this.time,
        crc: "0x" + i.toString(16).toUpperCase(),
        compressedSize: v(o),
        size: v(a),
        fileNameLength: v(c),
        extraLength: v(f),
        commentLength: v(l),
        diskNumStart: d,
        inAttr: g,
        attr: p,
        offset: u,
        centralHeaderSize: v(ne.CENHDR + c + f + l)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
}, jn = Ri, je = jn.Constants, DH = function() {
  var e = 0, t = 0, r = 0, n = 0, s = 0;
  return {
    get diskEntries() {
      return e;
    },
    set diskEntries(i) {
      e = t = i;
    },
    get totalEntries() {
      return t;
    },
    set totalEntries(i) {
      t = e = i;
    },
    get size() {
      return r;
    },
    set size(i) {
      r = i;
    },
    get offset() {
      return n;
    },
    set offset(i) {
      n = i;
    },
    get commentLength() {
      return s;
    },
    set commentLength(i) {
      s = i;
    },
    get mainHeaderSize() {
      return je.ENDHDR + s;
    },
    loadFromBinary: function(i) {
      if ((i.length !== je.ENDHDR || i.readUInt32LE(0) !== je.ENDSIG) && (i.length < je.ZIP64HDR || i.readUInt32LE(0) !== je.ZIP64SIG))
        throw jn.Errors.INVALID_END();
      i.readUInt32LE(0) === je.ENDSIG ? (e = i.readUInt16LE(je.ENDSUB), t = i.readUInt16LE(je.ENDTOT), r = i.readUInt32LE(je.ENDSIZ), n = i.readUInt32LE(je.ENDOFF), s = i.readUInt16LE(je.ENDCOM)) : (e = jn.readBigUInt64LE(i, je.ZIP64SUB), t = jn.readBigUInt64LE(i, je.ZIP64TOT), r = jn.readBigUInt64LE(i, je.ZIP64SIZE), n = jn.readBigUInt64LE(i, je.ZIP64OFF), s = 0);
    },
    toBinary: function() {
      var i = Buffer.alloc(je.ENDHDR + s);
      return i.writeUInt32LE(je.ENDSIG, 0), i.writeUInt32LE(0, 4), i.writeUInt16LE(e, je.ENDSUB), i.writeUInt16LE(t, je.ENDTOT), i.writeUInt32LE(r, je.ENDSIZ), i.writeUInt32LE(n, je.ENDOFF), i.writeUInt16LE(s, je.ENDCOM), i.fill(" ", je.ENDHDR), i;
    },
    toJSON: function() {
      const i = function(o, a) {
        let c = o.toString(16).toUpperCase();
        for (; c.length < a; ) c = "0" + c;
        return "0x" + c;
      };
      return {
        diskEntries: e,
        totalEntries: t,
        size: r + " bytes",
        offset: i(n, 4),
        commentLength: s
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
Ka.EntryHeader = jH;
Ka.MainHeader = DH;
var Ja = {}, FH = function(e) {
  var t = fr, r = { chunkSize: (parseInt(e.length / 1024) + 1) * 1024 };
  return {
    deflate: function() {
      return t.deflateRawSync(e, r);
    },
    deflateAsync: function(n) {
      var s = t.createDeflateRaw(r), i = [], o = 0;
      s.on("data", function(a) {
        i.push(a), o += a.length;
      }), s.on("end", function() {
        var a = Buffer.alloc(o), c = 0;
        a.fill(0);
        for (var f = 0; f < i.length; f++) {
          var l = i[f];
          l.copy(a, c), c += l.length;
        }
        n && n(a);
      }), s.end(e);
    }
  };
};
const MH = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
var zH = function(e, t) {
  var r = fr;
  const n = MH >= 15 && t > 0 ? { maxOutputLength: t } : {};
  return {
    inflate: function() {
      return r.inflateRawSync(e, n);
    },
    inflateAsync: function(s) {
      var i = r.createInflateRaw(n), o = [], a = 0;
      i.on("data", function(c) {
        o.push(c), a += c.length;
      }), i.on("end", function() {
        var c = Buffer.alloc(a), f = 0;
        c.fill(0);
        for (var l = 0; l < o.length; l++) {
          var d = o[l];
          d.copy(c, f), f += d.length;
        }
        s && s(c);
      }), i.end(e);
    }
  };
};
const { randomFillSync: cv } = bv, UH = Wa, qH = new Uint32Array(256).map((e, t) => {
  for (let r = 0; r < 8; r++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t >>>= 1;
  return t >>> 0;
}), QE = (e, t) => Math.imul(e, t) >>> 0, lv = (e, t) => qH[(e ^ t) & 255] ^ e >>> 8, Zs = () => typeof cv == "function" ? cv(Buffer.alloc(12)) : Zs.node();
Zs.node = () => {
  const e = Buffer.alloc(12), t = e.length;
  for (let r = 0; r < t; r++) e[r] = Math.random() * 256 & 255;
  return e;
};
const Po = {
  genSalt: Zs
};
function Ya(e) {
  const t = Buffer.isBuffer(e) ? e : Buffer.from(e);
  this.keys = new Uint32Array([305419896, 591751049, 878082192]);
  for (let r = 0; r < t.length; r++)
    this.updateKeys(t[r]);
}
Ya.prototype.updateKeys = function(e) {
  const t = this.keys;
  return t[0] = lv(t[0], e), t[1] += t[0] & 255, t[1] = QE(t[1], 134775813) + 1, t[2] = lv(t[2], t[1] >>> 24), e;
};
Ya.prototype.next = function() {
  const e = (this.keys[2] | 2) >>> 0;
  return QE(e, e ^ 1) >> 8 & 255;
};
function HH(e) {
  const t = new Ya(e);
  return function(r) {
    const n = Buffer.alloc(r.length);
    let s = 0;
    for (let i of r)
      n[s++] = t.updateKeys(i ^ t.next());
    return n;
  };
}
function BH(e) {
  const t = new Ya(e);
  return function(r, n, s = 0) {
    n || (n = Buffer.alloc(r.length));
    for (let i of r) {
      const o = t.next();
      n[s++] = i ^ o, t.updateKeys(i);
    }
    return n;
  };
}
function VH(e, t, r) {
  if (!e || !Buffer.isBuffer(e) || e.length < 12)
    return Buffer.alloc(0);
  const n = HH(r), s = n(e.slice(0, 12)), i = (t.flags & 8) === 8 ? t.timeHighByte : t.crc >>> 24;
  if (s[11] !== i)
    throw UH.WRONG_PASSWORD();
  return n(e.slice(12));
}
function GH(e) {
  Buffer.isBuffer(e) && e.length >= 12 ? Po.genSalt = function() {
    return e.slice(0, 12);
  } : e === "node" ? Po.genSalt = Zs.node : Po.genSalt = Zs;
}
function WH(e, t, r, n = !1) {
  e == null && (e = Buffer.alloc(0)), Buffer.isBuffer(e) || (e = Buffer.from(e.toString()));
  const s = BH(r), i = Po.genSalt();
  i[11] = t.crc >>> 24 & 255, n && (i[10] = t.crc >>> 16 & 255);
  const o = Buffer.alloc(e.length + 12);
  return s(i, o), s(e, o, 12);
}
var KH = { decrypt: VH, encrypt: WH, _salter: GH };
Ja.Deflater = FH;
Ja.Inflater = zH;
Ja.ZipCrypto = KH;
var Oe = Ri, JH = Ka, Fe = Oe.Constants, Ql = Ja, ex = function(e, t) {
  var r = new JH.EntryHeader(), n = Buffer.alloc(0), s = Buffer.alloc(0), i = !1, o = null, a = Buffer.alloc(0), c = Buffer.alloc(0), f = !0;
  const l = e, d = typeof l.decoder == "object" ? l.decoder : Oe.decoder;
  f = d.hasOwnProperty("efs") ? d.efs : !1;
  function g() {
    return !t || !(t instanceof Uint8Array) ? Buffer.alloc(0) : (c = r.loadLocalHeaderFromBinary(t), t.slice(r.realDataOffset, r.realDataOffset + r.compressedSize));
  }
  function p(y) {
    if (r.flags_desc) {
      const _ = {}, R = r.realDataOffset + r.compressedSize;
      if (t.readUInt32LE(R) == Fe.LOCSIG || t.readUInt32LE(R) == Fe.CENSIG)
        throw Oe.Errors.DESCRIPTOR_NOT_EXIST();
      if (t.readUInt32LE(R) == Fe.EXTSIG)
        _.crc = t.readUInt32LE(R + Fe.EXTCRC), _.compressedSize = t.readUInt32LE(R + Fe.EXTSIZ), _.size = t.readUInt32LE(R + Fe.EXTLEN);
      else if (t.readUInt16LE(R + 12) === 19280)
        _.crc = t.readUInt32LE(R + Fe.EXTCRC - 4), _.compressedSize = t.readUInt32LE(R + Fe.EXTSIZ - 4), _.size = t.readUInt32LE(R + Fe.EXTLEN - 4);
      else
        throw Oe.Errors.DESCRIPTOR_UNKNOWN();
      if (_.compressedSize !== r.compressedSize || _.size !== r.size || _.crc !== r.crc)
        throw Oe.Errors.DESCRIPTOR_FAULTY();
      if (Oe.crc32(y) !== _.crc)
        return !1;
    } else if (Oe.crc32(y) !== r.localHeader.crc)
      return !1;
    return !0;
  }
  function u(y, _, R) {
    if (typeof _ > "u" && typeof y == "string" && (R = y, y = void 0), i)
      return y && _ && _(Buffer.alloc(0), Oe.Errors.DIRECTORY_CONTENT_ERROR()), Buffer.alloc(0);
    var E = g();
    if (E.length === 0)
      return y && _ && _(E), E;
    if (r.encrypted) {
      if (typeof R != "string" && !Buffer.isBuffer(R))
        throw Oe.Errors.INVALID_PASS_PARAM();
      E = Ql.ZipCrypto.decrypt(E, r, R);
    }
    var O = Buffer.alloc(r.size);
    switch (r.method) {
      case Oe.Constants.STORED:
        if (E.copy(O), p(O))
          return y && _ && _(O), O;
        throw y && _ && _(O, Oe.Errors.BAD_CRC()), Oe.Errors.BAD_CRC();
      case Oe.Constants.DEFLATED:
        var z = new Ql.Inflater(E, r.size);
        if (y)
          z.inflateAsync(function(x) {
            x.copy(x, 0), _ && (p(x) ? _(x) : _(x, Oe.Errors.BAD_CRC()));
          });
        else {
          if (z.inflate(O).copy(O, 0), !p(O))
            throw Oe.Errors.BAD_CRC(`"${d.decode(n)}"`);
          return O;
        }
        break;
      default:
        throw y && _ && _(Buffer.alloc(0), Oe.Errors.UNKNOWN_METHOD()), Oe.Errors.UNKNOWN_METHOD();
    }
  }
  function h(y, _) {
    if ((!o || !o.length) && Buffer.isBuffer(t))
      return y && _ && _(g()), g();
    if (o.length && !i) {
      var R;
      switch (r.method) {
        case Oe.Constants.STORED:
          return r.compressedSize = r.size, R = Buffer.alloc(o.length), o.copy(R), y && _ && _(R), R;
        default:
        case Oe.Constants.DEFLATED:
          var E = new Ql.Deflater(o);
          if (y)
            E.deflateAsync(function(z) {
              R = Buffer.alloc(z.length), r.compressedSize = z.length, z.copy(R), _ && _(R);
            });
          else {
            var O = E.deflate();
            return r.compressedSize = O.length, O;
          }
          E = null;
          break;
      }
    } else if (y && _)
      _(Buffer.alloc(0));
    else
      return Buffer.alloc(0);
  }
  function b(y, _) {
    return (y.readUInt32LE(_ + 4) << 4) + y.readUInt32LE(_);
  }
  function m(y) {
    try {
      for (var _ = 0, R, E, O; _ + 4 < y.length; )
        R = y.readUInt16LE(_), _ += 2, E = y.readUInt16LE(_), _ += 2, O = y.slice(_, _ + E), _ += E, Fe.ID_ZIP64 === R && v(O);
    } catch {
      throw Oe.Errors.EXTRA_FIELD_PARSE_ERROR();
    }
  }
  function v(y) {
    var _, R, E, O;
    y.length >= Fe.EF_ZIP64_SCOMP && (_ = b(y, Fe.EF_ZIP64_SUNCOMP), r.size === Fe.EF_ZIP64_OR_32 && (r.size = _)), y.length >= Fe.EF_ZIP64_RHO && (R = b(y, Fe.EF_ZIP64_SCOMP), r.compressedSize === Fe.EF_ZIP64_OR_32 && (r.compressedSize = R)), y.length >= Fe.EF_ZIP64_DSN && (E = b(y, Fe.EF_ZIP64_RHO), r.offset === Fe.EF_ZIP64_OR_32 && (r.offset = E)), y.length >= Fe.EF_ZIP64_DSN + 4 && (O = y.readUInt32LE(Fe.EF_ZIP64_DSN), r.diskNumStart === Fe.EF_ZIP64_OR_16 && (r.diskNumStart = O));
  }
  return {
    get entryName() {
      return d.decode(n);
    },
    get rawEntryName() {
      return n;
    },
    set entryName(y) {
      n = Oe.toBuffer(y, d.encode);
      var _ = n[n.length - 1];
      i = _ === 47 || _ === 92, r.fileNameLength = n.length;
    },
    get efs() {
      return typeof f == "function" ? f(this.entryName) : f;
    },
    get extra() {
      return a;
    },
    set extra(y) {
      a = y, r.extraLength = y.length, m(y);
    },
    get comment() {
      return d.decode(s);
    },
    set comment(y) {
      if (s = Oe.toBuffer(y, d.encode), r.commentLength = s.length, s.length > 65535) throw Oe.Errors.COMMENT_TOO_LONG();
    },
    get name() {
      var y = d.decode(n);
      return i ? y.substr(y.length - 1).split("/").pop() : y.split("/").pop();
    },
    get isDirectory() {
      return i;
    },
    getCompressedData: function() {
      return h(!1, null);
    },
    getCompressedDataAsync: function(y) {
      h(!0, y);
    },
    setData: function(y) {
      o = Oe.toBuffer(y, Oe.decoder.encode), !i && o.length ? (r.size = o.length, r.method = Oe.Constants.DEFLATED, r.crc = Oe.crc32(y), r.changed = !0) : r.method = Oe.Constants.STORED;
    },
    getData: function(y) {
      return r.changed ? o : u(!1, null, y);
    },
    getDataAsync: function(y, _) {
      r.changed ? y(o) : u(!0, y, _);
    },
    set attr(y) {
      r.attr = y;
    },
    get attr() {
      return r.attr;
    },
    set header(y) {
      r.loadFromBinary(y);
    },
    get header() {
      return r;
    },
    packCentralHeader: function() {
      r.flags_efs = this.efs, r.extraLength = a.length;
      var y = r.centralHeaderToBinary(), _ = Oe.Constants.CENHDR;
      return n.copy(y, _), _ += n.length, a.copy(y, _), _ += r.extraLength, s.copy(y, _), y;
    },
    packLocalHeader: function() {
      let y = 0;
      r.flags_efs = this.efs, r.extraLocalLength = c.length;
      const _ = r.localHeaderToBinary(), R = Buffer.alloc(_.length + n.length + r.extraLocalLength);
      return _.copy(R, y), y += _.length, n.copy(R, y), y += n.length, c.copy(R, y), y += c.length, R;
    },
    toJSON: function() {
      const y = function(_) {
        return "<" + (_ && _.length + " bytes buffer" || "null") + ">";
      };
      return {
        entryName: this.entryName,
        name: this.name,
        comment: this.comment,
        isDirectory: this.isDirectory,
        header: r.toJSON(),
        compressedData: y(t),
        data: y(o)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
const uv = ex, YH = Ka, ot = Ri;
var XH = function(e, t) {
  var r = [], n = {}, s = Buffer.alloc(0), i = new YH.MainHeader(), o = !1;
  const a = /* @__PURE__ */ new Set(), c = t, { noSort: f, decoder: l } = c;
  e ? p(c.readEntries) : o = !0;
  function d() {
    const h = /* @__PURE__ */ new Set();
    for (const b of Object.keys(n)) {
      const m = b.split("/");
      if (m.pop(), !!m.length)
        for (let v = 0; v < m.length; v++) {
          const y = m.slice(0, v + 1).join("/") + "/";
          h.add(y);
        }
    }
    for (const b of h)
      if (!(b in n)) {
        const m = new uv(c);
        m.entryName = b, m.attr = 16, m.temporary = !0, r.push(m), n[m.entryName] = m, a.add(m);
      }
  }
  function g() {
    if (o = !0, n = {}, i.diskEntries > (e.length - i.offset) / ot.Constants.CENHDR)
      throw ot.Errors.DISK_ENTRY_TOO_LARGE();
    r = new Array(i.diskEntries);
    for (var h = i.offset, b = 0; b < r.length; b++) {
      var m = h, v = new uv(c, e);
      v.header = e.slice(m, m += ot.Constants.CENHDR), v.entryName = e.slice(m, m += v.header.fileNameLength), v.header.extraLength && (v.extra = e.slice(m, m += v.header.extraLength)), v.header.commentLength && (v.comment = e.slice(m, m + v.header.commentLength)), h += v.header.centralHeaderSize, r[b] = v, n[v.entryName] = v;
    }
    a.clear(), d();
  }
  function p(h) {
    var b = e.length - ot.Constants.ENDHDR, m = Math.max(0, b - 65535), v = m, y = e.length, _ = -1, R = 0;
    for ((typeof c.trailingSpace == "boolean" ? c.trailingSpace : !1) && (m = 0), b; b >= v; b--)
      if (e[b] === 80) {
        if (e.readUInt32LE(b) === ot.Constants.ENDSIG) {
          _ = b, R = b, y = b + ot.Constants.ENDHDR, v = b - ot.Constants.END64HDR;
          continue;
        }
        if (e.readUInt32LE(b) === ot.Constants.END64SIG) {
          v = m;
          continue;
        }
        if (e.readUInt32LE(b) === ot.Constants.ZIP64SIG) {
          _ = b, y = b + ot.readBigUInt64LE(e, b + ot.Constants.ZIP64SIZE) + ot.Constants.ZIP64LEAD;
          break;
        }
      }
    if (_ == -1) throw ot.Errors.INVALID_FORMAT();
    i.loadFromBinary(e.slice(_, y)), i.commentLength && (s = e.slice(R + ot.Constants.ENDHDR)), h && g();
  }
  function u() {
    r.length > 1 && !f && r.sort((h, b) => h.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
  }
  return {
    /**
     * Returns an array of ZipEntry objects existent in the current opened archive
     * @return Array
     */
    get entries() {
      return o || g(), r.filter((h) => !a.has(h));
    },
    /**
     * Archive comment
     * @return {String}
     */
    get comment() {
      return l.decode(s);
    },
    set comment(h) {
      s = ot.toBuffer(h, l.encode), i.commentLength = s.length;
    },
    getEntryCount: function() {
      return o ? r.length : i.diskEntries;
    },
    forEach: function(h) {
      this.entries.forEach(h);
    },
    /**
     * Returns a reference to the entry with the given name or null if entry is inexistent
     *
     * @param entryName
     * @return ZipEntry
     */
    getEntry: function(h) {
      return o || g(), n[h] || null;
    },
    /**
     * Adds the given entry to the entry list
     *
     * @param entry
     */
    setEntry: function(h) {
      o || g(), r.push(h), n[h.entryName] = h, i.totalEntries = r.length;
    },
    /**
     * Removes the file with the given name from the entry list.
     *
     * If the entry is a directory, then all nested files and directories will be removed
     * @param entryName
     * @returns {void}
     */
    deleteFile: function(h, b = !0) {
      o || g();
      const m = n[h];
      this.getEntryChildren(m, b).map((y) => y.entryName).forEach(this.deleteEntry);
    },
    /**
     * Removes the entry with the given name from the entry list.
     *
     * @param {string} entryName
     * @returns {void}
     */
    deleteEntry: function(h) {
      o || g();
      const b = n[h], m = r.indexOf(b);
      m >= 0 && (r.splice(m, 1), delete n[h], i.totalEntries = r.length);
    },
    /**
     *  Iterates and returns all nested files and directories of the given entry
     *
     * @param entry
     * @return Array
     */
    getEntryChildren: function(h, b = !0) {
      if (o || g(), typeof h == "object")
        if (h.isDirectory && b) {
          const m = [], v = h.entryName;
          for (const y of r)
            y.entryName.startsWith(v) && m.push(y);
          return m;
        } else
          return [h];
      return [];
    },
    /**
     *  How many child elements entry has
     *
     * @param {ZipEntry} entry
     * @return {integer}
     */
    getChildCount: function(h) {
      if (h && h.isDirectory) {
        const b = this.getEntryChildren(h);
        return b.includes(h) ? b.length - 1 : b.length;
      }
      return 0;
    },
    /**
     * Returns the zip file
     *
     * @return Buffer
     */
    compressToBuffer: function() {
      o || g(), u();
      const h = [], b = [];
      let m = 0, v = 0;
      i.size = 0, i.offset = 0;
      let y = 0;
      for (const E of this.entries) {
        const O = E.getCompressedData();
        E.header.offset = v;
        const z = E.packLocalHeader(), x = z.length + O.length;
        v += x, h.push(z), h.push(O);
        const L = E.packCentralHeader();
        b.push(L), i.size += L.length, m += x + L.length, y++;
      }
      m += i.mainHeaderSize, i.offset = v, i.totalEntries = y, v = 0;
      const _ = Buffer.alloc(m);
      for (const E of h)
        E.copy(_, v), v += E.length;
      for (const E of b)
        E.copy(_, v), v += E.length;
      const R = i.toBinary();
      return s && s.copy(R, ot.Constants.ENDHDR), R.copy(_, v), e = _, o = !1, _;
    },
    toAsyncBuffer: function(h, b, m, v) {
      try {
        o || g(), u();
        const y = [], _ = [];
        let R = 0, E = 0, O = 0;
        i.size = 0, i.offset = 0;
        const z = function(x) {
          if (x.length > 0) {
            const L = x.shift(), M = L.entryName + L.extra.toString();
            m && m(M), L.getCompressedDataAsync(function(U) {
              v && v(M), L.header.offset = E;
              const $ = L.packLocalHeader(), S = $.length + U.length;
              E += S, y.push($), y.push(U);
              const I = L.packCentralHeader();
              _.push(I), i.size += I.length, R += S + I.length, O++, z(x);
            });
          } else {
            R += i.mainHeaderSize, i.offset = E, i.totalEntries = O, E = 0;
            const L = Buffer.alloc(R);
            y.forEach(function(U) {
              U.copy(L, E), E += U.length;
            }), _.forEach(function(U) {
              U.copy(L, E), E += U.length;
            });
            const M = i.toBinary();
            s && s.copy(M, ot.Constants.ENDHDR), M.copy(L, E), e = L, o = !1, h(L);
          }
        };
        z(Array.from(this.entries));
      } catch (y) {
        b(y);
      }
    }
  };
};
const De = Ri, Me = $t, ZH = ex, QH = XH, Xr = (...e) => De.findLast(e, (t) => typeof t == "boolean"), fv = (...e) => De.findLast(e, (t) => typeof t == "string"), e3 = (...e) => De.findLast(e, (t) => typeof t == "function"), t3 = {
  // option "noSort" : if true it disables files sorting
  noSort: !1,
  // read entries during load (initial loading may be slower)
  readEntries: !1,
  // default method is none
  method: De.Constants.NONE,
  // file system
  fs: null
};
var r3 = function(e, t) {
  let r = null;
  const n = Object.assign(/* @__PURE__ */ Object.create(null), t3);
  e && typeof e == "object" && (e instanceof Uint8Array || (Object.assign(n, e), e = n.input ? n.input : void 0, n.input && delete n.input), Buffer.isBuffer(e) && (r = e, n.method = De.Constants.BUFFER, e = void 0)), Object.assign(n, t);
  const s = new De(n);
  if ((typeof n.decoder != "object" || typeof n.decoder.encode != "function" || typeof n.decoder.decode != "function") && (n.decoder = De.decoder), e && typeof e == "string")
    if (s.fs.existsSync(e))
      n.method = De.Constants.FILE, n.filename = e, r = s.fs.readFileSync(e);
    else
      throw De.Errors.INVALID_FILENAME();
  const i = new QH(r, n), { canonical: o, sanitize: a, zipnamefix: c } = De;
  function f(p) {
    if (p && i) {
      var u;
      if (typeof p == "string" && (u = i.getEntry(Me.posix.normalize(p))), typeof p == "object" && typeof p.entryName < "u" && typeof p.header < "u" && (u = i.getEntry(p.entryName)), u)
        return u;
    }
    return null;
  }
  function l(p) {
    const { join: u, normalize: h, sep: b } = Me.posix;
    return u(".", h(b + p.split("\\").join(b) + b));
  }
  function d(p) {
    return p instanceof RegExp ? /* @__PURE__ */ function(u) {
      return function(h) {
        return u.test(h);
      };
    }(p) : typeof p != "function" ? () => !0 : p;
  }
  const g = (p, u) => {
    let h = u.slice(-1);
    return h = h === s.sep ? s.sep : "", Me.relative(p, u) + h;
  };
  return {
    /**
     * Extracts the given entry from the archive and returns the content as a Buffer object
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {Buffer|string} [pass] - password
     * @return Buffer or Null in case of error
     */
    readFile: function(p, u) {
      var h = f(p);
      return h && h.getData(u) || null;
    },
    /**
     * Returns how many child elements has on entry (directories) on files it is always 0
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @returns {integer}
     */
    childCount: function(p) {
      const u = f(p);
      if (u)
        return i.getChildCount(u);
    },
    /**
     * Asynchronous readFile
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     *
     * @return Buffer or Null in case of error
     */
    readFileAsync: function(p, u) {
      var h = f(p);
      h ? h.getDataAsync(u) : u(null, "getEntry failed for:" + p);
    },
    /**
     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
     * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry
     * @param {string} encoding - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsText: function(p, u) {
      var h = f(p);
      if (h) {
        var b = h.getData();
        if (b && b.length)
          return b.toString(u || "utf8");
      }
      return "";
    },
    /**
     * Asynchronous readAsText
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsTextAsync: function(p, u, h) {
      var b = f(p);
      b ? b.getDataAsync(function(m, v) {
        if (v) {
          u(m, v);
          return;
        }
        m && m.length ? u(m.toString(h || "utf8")) : u("");
      }) : u("");
    },
    /**
     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteFile: function(p, u = !0) {
      var h = f(p);
      h && i.deleteFile(h.entryName, u);
    },
    /**
     * Remove the entry from the file or directory without affecting any nested entries
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteEntry: function(p) {
      var u = f(p);
      u && i.deleteEntry(u.entryName);
    },
    /**
     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
     *
     * @param {string} comment
     */
    addZipComment: function(p) {
      i.comment = p;
    },
    /**
     * Returns the zip comment
     *
     * @return String
     */
    getZipComment: function() {
      return i.comment || "";
    },
    /**
     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
     * The comment cannot exceed 65535 characters in length
     *
     * @param {ZipEntry} entry
     * @param {string} comment
     */
    addZipEntryComment: function(p, u) {
      var h = f(p);
      h && (h.comment = u);
    },
    /**
     * Returns the comment of the specified entry
     *
     * @param {ZipEntry} entry
     * @return String
     */
    getZipEntryComment: function(p) {
      var u = f(p);
      return u && u.comment || "";
    },
    /**
     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
     *
     * @param {ZipEntry} entry
     * @param {Buffer} content
     */
    updateFile: function(p, u) {
      var h = f(p);
      h && h.setData(u);
    },
    /**
     * Adds a file from the disk to the archive
     *
     * @param {string} localPath File to add to zip
     * @param {string} [zipPath] Optional path inside the zip
     * @param {string} [zipName] Optional name for the file
     * @param {string} [comment] Optional file comment
     */
    addLocalFile: function(p, u, h, b) {
      if (s.fs.existsSync(p)) {
        u = u ? l(u) : "";
        const m = Me.win32.basename(Me.win32.normalize(p));
        u += h || m;
        const v = s.fs.statSync(p), y = v.isFile() ? s.fs.readFileSync(p) : Buffer.alloc(0);
        v.isDirectory() && (u += s.sep), this.addFile(u, y, b, v);
      } else
        throw De.Errors.FILE_NOT_FOUND(p);
    },
    /**
     * Callback for showing if everything was done.
     *
     * @callback doneCallback
     * @param {Error} err - Error object
     * @param {boolean} done - was request fully completed
     */
    /**
     * Adds a file from the disk to the archive
     *
     * @param {(object|string)} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the file.
     * @param {string} [options.comment] - Optional file comment.
     * @param {string} [options.zipPath] - Optional path inside the zip
     * @param {string} [options.zipName] - Optional name for the file
     * @param {doneCallback} callback - The callback that handles the response.
     */
    addLocalFileAsync: function(p, u) {
      p = typeof p == "object" ? p : { localPath: p };
      const h = Me.resolve(p.localPath), { comment: b } = p;
      let { zipPath: m, zipName: v } = p;
      const y = this;
      s.fs.stat(h, function(_, R) {
        if (_) return u(_, !1);
        m = m ? l(m) : "";
        const E = Me.win32.basename(Me.win32.normalize(h));
        if (m += v || E, R.isFile())
          s.fs.readFile(h, function(O, z) {
            return O ? u(O, !1) : (y.addFile(m, z, b, R), setImmediate(u, void 0, !0));
          });
        else if (R.isDirectory())
          return m += s.sep, y.addFile(m, Buffer.alloc(0), b, R), setImmediate(u, void 0, !0);
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - local path to the folder
     * @param {string} [zipPath] - optional path inside zip
     * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.
     */
    addLocalFolder: function(p, u, h) {
      if (h = d(h), u = u ? l(u) : "", p = Me.normalize(p), s.fs.existsSync(p)) {
        const b = s.findFiles(p), m = this;
        if (b.length)
          for (const v of b) {
            const y = Me.join(u, g(p, v));
            h(y) && m.addLocalFile(v, Me.dirname(y));
          }
      } else
        throw De.Errors.FILE_NOT_FOUND(p);
    },
    /**
     * Asynchronous addLocalFolder
     * @param {string} localPath
     * @param {callback} callback
     * @param {string} [zipPath] optional path inside zip
     * @param {RegExp|function} [filter] optional RegExp or Function if files match will
     *               be included.
     */
    addLocalFolderAsync: function(p, u, h, b) {
      b = d(b), h = h ? l(h) : "", p = Me.normalize(p);
      var m = this;
      s.fs.open(p, "r", function(v) {
        if (v && v.code === "ENOENT")
          u(void 0, De.Errors.FILE_NOT_FOUND(p));
        else if (v)
          u(void 0, v);
        else {
          var y = s.findFiles(p), _ = -1, R = function() {
            if (_ += 1, _ < y.length) {
              var E = y[_], O = g(p, E).split("\\").join("/");
              O = O.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, ""), b(O) ? s.fs.stat(E, function(z, x) {
                z && u(void 0, z), x.isFile() ? s.fs.readFile(E, function(L, M) {
                  L ? u(void 0, L) : (m.addFile(h + O, M, "", x), R());
                }) : (m.addFile(h + O + "/", Buffer.alloc(0), "", x), R());
              }) : process.nextTick(() => {
                R();
              });
            } else
              u(!0, void 0);
          };
          R();
        }
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {object | string} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the folder.
     * @param {string} [options.zipPath] - optional path inside zip.
     * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [options.namefix] - optional function to help fix filename
     * @param {doneCallback} callback - The callback that handles the response.
     *
     */
    addLocalFolderAsync2: function(p, u) {
      const h = this;
      p = typeof p == "object" ? p : { localPath: p }, localPath = Me.resolve(l(p.localPath));
      let { zipPath: b, filter: m, namefix: v } = p;
      m instanceof RegExp ? m = /* @__PURE__ */ function(R) {
        return function(E) {
          return R.test(E);
        };
      }(m) : typeof m != "function" && (m = function() {
        return !0;
      }), b = b ? l(b) : "", v == "latin1" && (v = (R) => R.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "")), typeof v != "function" && (v = (R) => R);
      const y = (R) => Me.join(b, v(g(localPath, R))), _ = (R) => Me.win32.basename(Me.win32.normalize(v(R)));
      s.fs.open(localPath, "r", function(R) {
        R && R.code === "ENOENT" ? u(void 0, De.Errors.FILE_NOT_FOUND(localPath)) : R ? u(void 0, R) : s.findFilesAsync(localPath, function(E, O) {
          if (E) return u(E);
          O = O.filter((z) => m(y(z))), O.length || u(void 0, !1), setImmediate(
            O.reverse().reduce(function(z, x) {
              return function(L, M) {
                if (L || M === !1) return setImmediate(z, L, !1);
                h.addLocalFileAsync(
                  {
                    localPath: x,
                    zipPath: Me.dirname(y(x)),
                    zipName: _(x)
                  },
                  z
                );
              };
            }, u)
          );
        });
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - path where files will be extracted
     * @param {object} props - optional properties
     * @param {string} [props.zipPath] - optional path inside zip
     * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [props.namefix] - optional function to help fix filename
     */
    addLocalFolderPromise: function(p, u) {
      return new Promise((h, b) => {
        this.addLocalFolderAsync2(Object.assign({ localPath: p }, u), (m, v) => {
          m && b(m), v && h(this);
        });
      });
    },
    /**
     * Allows you to create a entry (file or directory) in the zip file.
     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
     * Comment and attributes are optional
     *
     * @param {string} entryName
     * @param {Buffer | string} content - file content as buffer or utf8 coded string
     * @param {string} [comment] - file comment
     * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object
     */
    addFile: function(p, u, h, b) {
      p = c(p);
      let m = f(p);
      const v = m != null;
      v || (m = new ZH(n), m.entryName = p), m.comment = h || "";
      const y = typeof b == "object" && b instanceof s.fs.Stats;
      y && (m.header.time = b.mtime);
      var _ = m.isDirectory ? 16 : 0;
      let R = m.isDirectory ? 16384 : 32768;
      return y ? R |= 4095 & b.mode : typeof b == "number" ? R |= 4095 & b : R |= m.isDirectory ? 493 : 420, _ = (_ | R << 16) >>> 0, m.attr = _, m.setData(u), v || i.setEntry(m), m;
    },
    /**
     * Returns an array of ZipEntry objects representing the files and folders inside the archive
     *
     * @param {string} [password]
     * @returns Array
     */
    getEntries: function(p) {
      return i.password = p, i ? i.entries : [];
    },
    /**
     * Returns a ZipEntry object representing the file or folder specified by ``name``.
     *
     * @param {string} name
     * @return ZipEntry
     */
    getEntry: function(p) {
      return f(p);
    },
    getEntryCount: function() {
      return i.getEntryCount();
    },
    forEach: function(p) {
      return i.forEach(p);
    },
    /**
     * Extracts the given entry to the given targetPath
     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
     *
     * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry
     * @param {string} targetPath - Target folder where to write the file
     * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE
     * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.
     * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.
     * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)
     *
     * @return Boolean
     */
    extractEntryTo: function(p, u, h, b, m, v) {
      b = Xr(!1, b), m = Xr(!1, m), h = Xr(!0, h), v = fv(m, v);
      var y = f(p);
      if (!y)
        throw De.Errors.NO_ENTRY();
      var _ = o(y.entryName), R = a(u, v && !y.isDirectory ? v : h ? _ : Me.basename(_));
      if (y.isDirectory) {
        var E = i.getEntryChildren(y);
        return E.forEach(function(x) {
          if (x.isDirectory) return;
          var L = x.getData();
          if (!L)
            throw De.Errors.CANT_EXTRACT_FILE();
          var M = o(x.entryName), U = a(u, h ? M : Me.basename(M));
          const $ = m ? x.header.fileAttr : void 0;
          s.writeFileTo(U, L, b, $);
        }), !0;
      }
      var O = y.getData(i.password);
      if (!O) throw De.Errors.CANT_EXTRACT_FILE();
      if (s.fs.existsSync(R) && !b)
        throw De.Errors.CANT_OVERRIDE();
      const z = m ? p.header.fileAttr : void 0;
      return s.writeFileTo(R, O, b, z), !0;
    },
    /**
     * Test the archive
     * @param {string} [pass]
     */
    test: function(p) {
      if (!i)
        return !1;
      for (var u in i.entries)
        try {
          if (u.isDirectory)
            continue;
          var h = i.entries[u].getData(p);
          if (!h)
            return !1;
        } catch {
          return !1;
        }
      return !0;
    },
    /**
     * Extracts the entire archive to the given location
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {string|Buffer} [pass] password
     */
    extractAllTo: function(p, u, h, b) {
      if (h = Xr(!1, h), b = fv(h, b), u = Xr(!1, u), !i) throw De.Errors.NO_ZIP();
      i.entries.forEach(function(m) {
        var v = a(p, o(m.entryName));
        if (m.isDirectory) {
          s.makeDir(v);
          return;
        }
        var y = m.getData(b);
        if (!y)
          throw De.Errors.CANT_EXTRACT_FILE();
        const _ = h ? m.header.fileAttr : void 0;
        s.writeFileTo(v, y, u, _);
        try {
          s.fs.utimesSync(v, m.header.time, m.header.time);
        } catch {
          throw De.Errors.CANT_EXTRACT_FILE();
        }
      });
    },
    /**
     * Asynchronous extractAllTo
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.
     */
    extractAllToAsync: function(p, u, h, b) {
      if (b = e3(u, h, b), h = Xr(!1, h), u = Xr(!1, u), !b)
        return new Promise((R, E) => {
          this.extractAllToAsync(p, u, h, function(O) {
            O ? E(O) : R(this);
          });
        });
      if (!i) {
        b(De.Errors.NO_ZIP());
        return;
      }
      p = Me.resolve(p);
      const m = (R) => a(p, Me.normalize(o(R.entryName))), v = (R, E) => new Error(R + ': "' + E + '"'), y = [], _ = [];
      i.entries.forEach((R) => {
        R.isDirectory ? y.push(R) : _.push(R);
      });
      for (const R of y) {
        const E = m(R), O = h ? R.header.fileAttr : void 0;
        try {
          s.makeDir(E), O && s.fs.chmodSync(E, O), s.fs.utimesSync(E, R.header.time, R.header.time);
        } catch {
          b(v("Unable to create folder", E));
        }
      }
      _.reverse().reduce(function(R, E) {
        return function(O) {
          if (O)
            R(O);
          else {
            const z = Me.normalize(o(E.entryName)), x = a(p, z);
            E.getDataAsync(function(L, M) {
              if (M)
                R(M);
              else if (!L)
                R(De.Errors.CANT_EXTRACT_FILE());
              else {
                const U = h ? E.header.fileAttr : void 0;
                s.writeFileToAsync(x, L, u, U, function($) {
                  $ || R(v("Unable to write file", x)), s.fs.utimes(x, E.header.time, E.header.time, function(S) {
                    S ? R(v("Unable to set times", x)) : R();
                  });
                });
              }
            });
          }
        };
      }, b)();
    },
    /**
     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
     *
     * @param {string} targetFileName
     * @param {function} callback
     */
    writeZip: function(p, u) {
      if (arguments.length === 1 && typeof p == "function" && (u = p, p = ""), !p && n.filename && (p = n.filename), !!p) {
        var h = i.compressToBuffer();
        if (h) {
          var b = s.writeFileTo(p, h, !0);
          typeof u == "function" && u(b ? null : new Error("failed"), "");
        }
      }
    },
    /**
             *
             * @param {string} targetFileName
             * @param {object} [props]
             * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.
             * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.
    
             * @returns {Promise<void>}
             */
    writeZipPromise: function(p, u) {
      const { overwrite: h, perm: b } = Object.assign({ overwrite: !0 }, u);
      return new Promise((m, v) => {
        !p && n.filename && (p = n.filename), p || v("ADM-ZIP: ZIP File Name Missing"), this.toBufferPromise().then((y) => {
          const _ = (R) => R ? m(R) : v("ADM-ZIP: Wasn't able to write zip file");
          s.writeFileToAsync(p, y, h, b, _);
        }, v);
      });
    },
    /**
     * @returns {Promise<Buffer>} A promise to the Buffer.
     */
    toBufferPromise: function() {
      return new Promise((p, u) => {
        i.toAsyncBuffer(p, u);
      });
    },
    /**
     * Returns the content of the entire zip file as a Buffer object
     *
     * @prop {function} [onSuccess]
     * @prop {function} [onFail]
     * @prop {function} [onItemStart]
     * @prop {function} [onItemEnd]
     * @returns {Buffer}
     */
    toBuffer: function(p, u, h, b) {
      return typeof p == "function" ? (i.toAsyncBuffer(p, u, h, b), null) : i.compressToBuffer();
    }
  };
};
const n3 = /* @__PURE__ */ si(r3);
function s3(e) {
  try {
    let t;
    process.platform === "win32" ? t = `netstat -ano | findstr :${e}` : t = `lsof -i :${e} | awk 'NR>1 {print $2}'`;
    const r = ao(t, { encoding: "utf8" }).trim();
    if (!r) return null;
    let n;
    if (process.platform === "win32") {
      const s = /\s+(\d+)\s*$/;
      n = r.split(`
`).map((i) => {
        const o = i.match(s);
        return o ? parseInt(o[1], 10) : NaN;
      }).filter((i) => !isNaN(i));
    } else
      n = r.split(`
`).map((s) => parseInt(s.trim(), 10)).filter((s) => !isNaN(s));
    return [...new Set(n)];
  } catch {
    return null;
  }
}
function eu(e) {
  const t = s3(e);
  return !!(t && t.length > 0);
}
const tx = mx(import.meta.url), i3 = tx("koffi"), o3 = tx("node-cron");
class a3 {
  constructor(t) {
    Se(this, "Wcf_directory");
    Se(this, "wcfconfigPath");
    Se(this, "wcfConfig");
    Se(this, "windown");
    Se(this, "server");
    Se(this, "WxInitSDK");
    Se(this, "WxDestroySDK");
    Se(this, "scheduleJobs");
    //   上报配置文件
    Se(this, "reportConfig", () => {
      this.windown.webContents.send("wcf:config", this.wcfConfig);
    });
    //   写入配置文件
    Se(this, "writeConfig", (t) => {
      this.wcfConfig = t, gt.writeFileSync(this.wcfconfigPath, JSON.stringify(t, null, 4));
    });
    //   发送日志
    Se(this, "sendLog", (t, r) => {
      this.windown.webContents.send("wcf:log", { message: t, level: r || "INFO", timestamp: OH().format("YYYY-MM-DD HH:mm:ss.SSS ") });
    });
    //   检测WCF是否有更新
    Se(this, "checkUpdate", async () => {
      const t = $t.join(this.Wcf_directory, "config.json");
      if (gt.existsSync(t)) {
        const n = JSON.parse(gt.readFileSync(t, "utf-8")).version.replace("v", "").split(".").join("") || "0", s = await this.getWCFVersion(), i = (s == null ? void 0 : s.version.replace("v", "").split(".").join("")) || "0";
        if (Number(n) < Number(i))
          return { status: !0, version: (s == null ? void 0 : s.version) || "" };
      }
      return { staus: !1, version: this.wcfConfig.version };
    });
    //   检测WCF是否存在
    Se(this, "checkWCF", () => {
      const t = $t.join(this.Wcf_directory, "sdk.dll");
      return !!gt.existsSync(t);
    });
    // 获取WCF版本信息
    Se(this, "getWCFVersion", async () => {
      const t = "https://api.github.com/repos/lich0821/WeChatFerry/releases/latest";
      try {
        const r = await Be.get(t, {
          responseType: "json",
          validateStatus: (n) => n < 500
        });
        return !r || !r.data || !r.data.assets || r.data.assets.length === 0 ? (this.sendLog("Failed to retrieve valid data from GitHub API.", "ERROR"), r.data.message && this.sendLog(r.data.message, "ERROR"), { version: "", download_url: "" }) : {
          version: r.data.tag_name,
          download_url: r.data.assets[0].browser_download_url
        };
      } catch (r) {
        return this.sendLog(`获取WCF版本信息失败:${r == null ? void 0 : r.message}`, "ERROR"), null;
      }
    });
    //   下载最新版的WCF
    Se(this, "downloadWCF", async () => {
      this.sendLog("开始下载最新版本的WCF", "INFO");
      let t = "";
      try {
        const r = await this.getWCFVersion();
        this.sendLog(`✅获取WCF最新版本信息成功:${r == null ? void 0 : r.version}`, "SUCCESS"), this.wcfConfig.version = (r == null ? void 0 : r.version) || "";
        const s = (this.wcfConfig.proxy_url ? this.wcfConfig.proxy_url + "/" : "") + (r == null ? void 0 : r.download_url) || "";
        this.sendLog(`✅获取WCF最新版本下载地址成功:${s}`, "SUCCESS");
        const i = $t.basename(s);
        if (t = $t.join(this.Wcf_directory, i), gt.existsSync(t))
          return await this.unzipFile(t);
        const o = gt.createWriteStream(t);
        return (await Be({
          method: "get",
          url: s,
          responseType: "stream"
        })).data.pipe(o), await new Promise((c, f) => {
          o.on("finish", async () => {
            this.sendLog("✅WCF下载完成", "SUCCESS"), this.writeConfig(this.wcfConfig);
            const l = await this.unzipFile(t);
            c(l);
          }), o.on("error", f);
        });
      } catch (r) {
        return this.sendLog(`下载WCF失败:${r.message}`, "ERROR"), gt.unlinkSync(t), !1;
      }
    });
    // 注入Dll
    Se(this, "InjectWCF", async () => {
      if (process.platform !== "win32") {
        this.sendLog("当前系统不支持WCF注入", "ERROR");
        return;
      }
      this.checkWCF() || (this.sendLog("WCF核心不存在，即将自动下载", "WARN"), await this.downloadWCF());
      const r = await this.checkWCFIsRun();
      if (!r.wcf_run && r.portOcc)
        return this.sendLog(`当前端口已被占用:${this.wcfConfig.port}请修改系统设置端口，避免启动失败！`, "WARN"), !1;
      this.sendLog("开始注入WCF", "INFO");
      const n = $t.join(this.Wcf_directory, "sdk.dll"), s = i3.load(n);
      return this.WxInitSDK = s.func("int WxInitSDK(bool, int)", "stdcall"), this.WxDestroySDK = s.func("WxDestroySDK", "void", []), !0;
    });
    // 启动WCF
    Se(this, "startWCF", async () => {
      var t;
      try {
        const r = await this.InjectWCF();
        if (!r) return r;
        const n = (t = this.WxInitSDK) == null ? void 0 : t.call(this, this.wcfConfig.debug, this.wcfConfig.port);
        if (n !== 0) {
          this.sendLog(`WCF启动失败：${n}`, "ERROR");
          return;
        }
        return this.sendLog(`✅WCF启动成功:tcp://0.0.0.0:${this.wcfConfig.port}发起连接`, "SUCCESS"), this.checkWCFIsRun(), !0;
      } catch (r) {
        this.sendLog(`启动WCF失败:${r.message}`, "ERROR");
      }
    });
    // 更新WCFdLL
    Se(this, "updateWCF", async () => {
      var r;
      (await this.checkWCFIsRun()).wcf_run && ((r = this.WxDestroySDK) == null || r.call(this), this.sendLog("WCF已关闭", "INFO")), await this.downloadWCF(), await this.startWCF();
    });
    // 重启WCF
    Se(this, "restartWCF", async () => {
      var r;
      (await this.checkWCFIsRun()).wcf_run && ((r = this.WxDestroySDK) == null || r.call(this), this.sendLog("WCF已关闭", "INFO")), await this.startWCF();
    });
    // 关闭WCF
    Se(this, "closeWCF", async () => {
      this.WxDestroySDK ? (this.WxDestroySDK(), this.sendLog("WCF已关闭", "INFO")) : this.sendLog("WCF未运行", "INFO"), this.checkWCFIsRun();
    });
    // 修改WCF配置文件
    Se(this, "modifyWCFConfig", async (t, r) => {
      this.wcfConfig = { ...this.wcfConfig, ...r }, this.writeConfig(this.wcfConfig), this.reportConfig();
    });
    // 获取配置文件
    Se(this, "getWCFConfig", async () => this.wcfConfig);
    //   检测WCF是否在运行
    Se(this, "checkWCFIsRun", async () => {
      const t = {
        portOcc: eu(this.wcfConfig.port),
        wcf_run: eu(this.wcfConfig.port) && !!this.WxInitSDK,
        http: !!(this.server && eu(this.wcfConfig.httpPort))
      };
      return this.windown.webContents.send("wcf:startEvent", t), t;
    });
    // 重置WCF环境
    Se(this, "resetWCF", async () => {
      this.sendLog("开始重置WCF环境", "INFO"), await this.KillPort(this.wcfConfig.port), await this.KillPort(+this.wcfConfig.port + 1);
    });
    Se(this, "KillPort", async (t) => {
      try {
        const r = await this.getPidsByPort(t);
        if (r.length == 0) {
          this.sendLog(`当前端口:${t}没有被占用`, "INFO");
          return;
        }
        this.sendLog(`成功检测${t}端口对应的PID:${r},即将终止相关PID进程`, "INFO"), r.forEach((n) => {
          const s = this.killProcessByPid(n);
          this.sendLog(`${s.success ? "✅" : ""}${s.message}`, s.success ? "SUCCESS" : "ERROR");
        });
      } catch (r) {
        this.sendLog(`重置WCF环境失败:${r.message}`, "ERROR");
      }
    });
    // 开启http服务
    Se(this, "startWcfServer", async () => {
      try {
        const t = _M({ trustProxy: !0 });
        t.get("/", async () => ({ code: 0, ...this.wcfConfig })), t.get("/start-wcf", async () => await this.startWCF() ? { code: 0, message: "WCF启动成功" } : { code: 1, message: "WCF启动失败,详情请看软件日志区域" }), t.get("/close-wcf", async () => (await this.closeWCF(), { code: 0, message: "WCF关闭成功" })), t.addHook("onSend", async (r, n, s) => {
          this.sendLog(`HTTP LOG: Method: ${r.method}、Url: ${r.url}、ClientIp:${r.ip}、Response:${s}`, "INFO");
        }), await t.listen({ host: "0.0.0.0", port: this.wcfConfig.httpPort }), this.sendLog(`✅ HTTP SERVER IS START:0.0.0.0:${this.wcfConfig.httpPort}`, "SUCCESS"), this.server = t, this.checkWCFIsRun();
      } catch (t) {
        this.sendLog(t.message, "ERROR");
      }
    });
    // 关闭http服务
    Se(this, "closeWcfServer", async () => {
      this.server && (await this.server.close(), this.sendLog("Http Server Is Close", "INFO")), this.checkWCFIsRun();
    });
    // 注册定时任务
    Se(this, "registerSchedule", (t, r) => {
      const n = o3.schedule(t, r);
      this.scheduleJobs.push(n), n.start();
    });
    // 清空定时任务
    Se(this, "clearSchedule", () => {
      this.scheduleJobs.map((t) => {
        t.stop();
      }), this.scheduleJobs.length = 0;
    });
    // 检测端口对应的pid
    Se(this, "getPidsByPort", async (t) => {
      try {
        const n = ao(`netstat -ano | findstr :${t}`, { encoding: "utf-8" }).split(`
`).filter((i) => i.includes(`:${t}`));
        return n.length === 0 ? [] : n.map((i) => {
          const o = i.trim().split(/\s+/).pop();
          return Number(o);
        });
      } catch {
        return [];
      }
    });
    Se(this, "killProcessByPid", (t) => {
      try {
        return ao(`taskkill /PID ${t} /F`, { stdio: "ignore" }), { success: !0, message: `✅ 成功终止 PID ${t} 的进程` };
      } catch {
        return { success: !1, message: `❌ 无法终止 PID ${t}，可能不存在或已退出,请打开任务管理器核对` };
      }
    });
    // 唤醒微信
    Se(this, "wakeUpWeChat", () => {
      try {
        if (process.platform === "win32")
          ao("start weixin://");
        else if (process.platform === "darwin")
          open("open weixin://");
        else {
          this.sendLog("❌ 当前系统不支持微信协议唤醒", "ERROR");
          return;
        }
        console.log("✅ 微信客户端已唤醒");
      } catch (t) {
        this.sendLog(`❌ 无法唤醒微信:${t.message}`, "ERROR");
      }
    });
    this.windown = t, this.server = null, this.Wcf_directory = $t.join(zs.getPath("documents"), "WCFApp"), this.wcfconfigPath = $t.join(this.Wcf_directory, "config.json"), this.WxInitSDK = null, this.WxDestroySDK = null, gt.existsSync(this.Wcf_directory) || gt.mkdirSync(this.Wcf_directory, { recursive: !0 });
    const r = {
      port: 10086,
      debug: !1,
      proxy_url: "",
      version: "",
      httpPort: 9200,
      cronCheck: 12
    };
    if (gt.existsSync(this.wcfconfigPath)) {
      const n = JSON.parse(gt.readFileSync(this.wcfconfigPath, "utf-8"));
      this.wcfConfig = { ...r, ...n };
    } else
      this.wcfConfig = r;
    this.writeConfig(this.wcfConfig), this.scheduleJobs = [];
  }
  //   解压文件
  async unzipFile(t, r = this.Wcf_directory) {
    try {
      this.sendLog("开始解压文件", "INFO");
      const n = new n3(t);
      return await new Promise((s, i) => {
        n.extractAllToAsync(r, !0, (o) => {
          o ? i(o) : (this.sendLog("✅解压文件完成", "SUCCESS"), gt.unlinkSync(t), s(!0));
        });
      });
    } catch (n) {
      return this.sendLog(`解压文件失败: ${n}`, "ERROR"), gt.unlinkSync(t), !1;
    }
  }
}
const rx = vr.dirname(hx(import.meta.url));
process.env.APP_ROOT = vr.join(rx, "..");
const Mu = process.env.VITE_DEV_SERVER_URL, p4 = vr.join(process.env.APP_ROOT, "dist-electron"), nx = vr.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Mu ? vr.join(process.env.APP_ROOT, "public") : nx;
let Je, Ee = null;
function dv(e) {
  const r = (process.memoryUsage().rss / 1024 / 1024).toFixed(1);
  e == null || e.webContents.send("memory-usage", r);
}
function sx() {
  Je = new mv({
    width: 1200,
    height: 800,
    minWidth: 1200,
    minHeight: 800,
    icon: vr.join(process.env.VITE_PUBLIC, "logo.png"),
    webPreferences: {
      preload: vr.join(rx, "preload.mjs")
    }
  }), Ee = new a3(Je), Je.webContents.on("did-finish-load", () => {
    dv(Je), Ee == null || Ee.registerSchedule("*/2 * * * *", () => {
      dv(Je);
    }), Ee == null || Ee.registerSchedule("0 */12 * * *", async () => {
      const e = await (Ee == null ? void 0 : Ee.checkUpdate());
      Je == null || Je.webContents.send("wcf:checkUpdateNotiy", e);
    }), Je == null || Je.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString()), Ee == null || Ee.reportConfig();
  }), Mu ? (Je.loadURL(Mu), Je.webContents.openDevTools()) : Je.loadFile(vr.join(nx, "index.html")), Ct.handle("wcf:checkUpdate", Ee.checkUpdate), Ct.handle("wcf:checkWCF", Ee.checkWCF), Ct.handle("wcf:downloadWCF", Ee.downloadWCF), Ct.handle("wcf:chekWcfIsRun", Ee.checkWCFIsRun), Ct.handle("wcf:startWcfHttpServer", Ee.startWcfServer), Ct.handle("wcf:closeWcfHttpServer", Ee.closeWcfServer), Ct.handle("wcf:updateConfig", Ee.modifyWCFConfig), Ct.handle("wcf:config", Ee.getWCFConfig), Ct.handle("wcf:restartWcf", Ee.restartWCF), Ct.handle("wcf:closeWcf", Ee.closeWCF), Ct.handle("wcf:startWCF", Ee.startWCF), Ct.handle("wcf:resetWcf", Ee.resetWCF), Ct.handle("open:url", (e, t) => {
    dx.openExternal(t);
  });
}
const c3 = hv.buildFromTemplate([]);
hv.setApplicationMenu(c3);
zs.on("window-all-closed", () => {
  process.platform !== "darwin" && (zs.quit(), Ee == null || Ee.closeWcfServer(), Ee == null || Ee.clearSchedule(), Ee == null || Ee.closeWCF(), Je = null, Ee = null);
});
zs.on("activate", () => {
  mv.getAllWindows().length === 0 && sx();
});
process.on("uncaughtException", (e) => {
  Je == null || Je.webContents.send("unhandledRejection", e.message);
});
process.on("unhandledRejection", (e) => {
  Je == null || Je.webContents.send("unhandledRejection", e.message);
});
zs.whenReady().then(sx);
export {
  p4 as MAIN_DIST,
  nx as RENDERER_DIST,
  Mu as VITE_DEV_SERVER_URL
};
