var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _schemas, _derefSchemas, _insertRefSymbol, _allowEqualDuplicates, _cloneSchemaWithoutRefs, _RefResolver_instances, parseSchemaRef_fn, addDerefSchema_fn, resolveRef_fn, insertSchemaBySchemaId_fn, insertSchemaByAnchor_fn, insertDerefSchemaBySchemaId_fn, insertDerefSchemaByAnchor_fn, _a;
import require$$1$6, { app, Tray, Menu, dialog, BrowserWindow, ipcMain, shell, globalShortcut } from "electron";
import require$$0$a, { fileURLToPath } from "node:url";
import { createRequire } from "node:module";
import require$$0$3 from "node:events";
import require$$0$2 from "node:util";
import require$$0$4 from "node:http";
import require$$1$1 from "node:diagnostics_channel";
import require$$1 from "node:https";
import require$$2 from "node:dns";
import require$$3$1 from "node:os";
import require$$0$7 from "node:stream";
import fs$k from "fs";
import require$$1$3, { EventEmitter as EventEmitter$1 } from "events";
import require$$1$2 from "util";
import path$n from "path";
import require$$5 from "assert";
import require$$2$1 from "worker_threads";
import require$$0$6 from "module";
import path$o from "node:path";
import require$$0$5 from "url";
import require$$7 from "buffer";
import require$$0$8 from "node:async_hooks";
import require$$0$9 from "node:assert";
import require$$0$b from "node:crypto";
import stream, { Readable as Readable$1 } from "stream";
import require$$3$2 from "http";
import require$$4 from "https";
import require$$0$c from "crypto";
import require$$1$4 from "tty";
import require$$2$2 from "os";
import zlib from "zlib";
import require$$1$7, { execSync } from "child_process";
import require$$0$d from "constants";
import require$$1$5 from "string_decoder";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var fastify$1 = { exports: {} };
var queue$1 = { exports: {} };
function reusify$1(Constructor) {
  var head = new Constructor();
  var tail = head;
  function get2() {
    var current = head;
    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }
    current.next = null;
    return current;
  }
  function release(obj) {
    tail.next = obj;
    tail = obj;
  }
  return {
    get: get2,
    release
  };
}
var reusify_1 = reusify$1;
var reusify = reusify_1;
function fastqueue(context2, worker, _concurrency) {
  if (typeof context2 === "function") {
    _concurrency = worker;
    worker = context2;
    context2 = null;
  }
  if (!(_concurrency >= 1)) {
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  }
  var cache = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler2 = null;
  var self2 = {
    push,
    drain: noop$7,
    saturated: noop$7,
    pause,
    paused: false,
    get concurrency() {
      return _concurrency;
    },
    set concurrency(value) {
      if (!(value >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      _concurrency = value;
      if (self2.paused) return;
      for (; queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    },
    running,
    resume,
    idle,
    length,
    getQueue,
    unshift,
    empty: noop$7,
    kill,
    killAndDrain,
    error: error2
  };
  return self2;
  function running() {
    return _running;
  }
  function pause() {
    self2.paused = true;
  }
  function length() {
    var current = queueHead;
    var counter = 0;
    while (current) {
      current = current.next;
      counter++;
    }
    return counter;
  }
  function getQueue() {
    var current = queueHead;
    var tasks = [];
    while (current) {
      tasks.push(current.value);
      current = current.next;
    }
    return tasks;
  }
  function resume() {
    if (!self2.paused) return;
    self2.paused = false;
    if (queueHead === null) {
      _running++;
      release();
      return;
    }
    for (; queueHead && _running < _concurrency; ) {
      _running++;
      release();
    }
  }
  function idle() {
    return _running === 0 && self2.length() === 0;
  }
  function push(value, done) {
    var current = cache.get();
    current.context = context2;
    current.release = release;
    current.value = value;
    current.callback = done || noop$7;
    current.errorHandler = errorHandler2;
    if (_running >= _concurrency || self2.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context2, current.value, current.worked);
    }
  }
  function unshift(value, done) {
    var current = cache.get();
    current.context = context2;
    current.release = release;
    current.value = value;
    current.callback = done || noop$7;
    current.errorHandler = errorHandler2;
    if (_running >= _concurrency || self2.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context2, current.value, current.worked);
    }
  }
  function release(holder) {
    if (holder) {
      cache.release(holder);
    }
    var next = queueHead;
    if (next && _running <= _concurrency) {
      if (!self2.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context2, next.value, next.worked);
        if (queueTail === null) {
          self2.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self2.drain();
    }
  }
  function kill() {
    queueHead = null;
    queueTail = null;
    self2.drain = noop$7;
  }
  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self2.drain();
    self2.drain = noop$7;
  }
  function error2(handler) {
    errorHandler2 = handler;
  }
}
function noop$7() {
}
function Task() {
  this.value = null;
  this.callback = noop$7;
  this.next = null;
  this.release = noop$7;
  this.context = null;
  this.errorHandler = null;
  var self2 = this;
  this.worked = function worked(err2, result) {
    var callback = self2.callback;
    var errorHandler2 = self2.errorHandler;
    var val = self2.value;
    self2.value = null;
    self2.callback = noop$7;
    if (self2.errorHandler) {
      errorHandler2(err2, val);
    }
    callback.call(self2.context, err2, result);
    self2.release(self2);
  };
}
function queueAsPromised(context2, worker, _concurrency) {
  if (typeof context2 === "function") {
    _concurrency = worker;
    worker = context2;
    context2 = null;
  }
  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function(res2) {
      cb(null, res2);
    }, cb);
  }
  var queue = fastqueue(context2, asyncWrapper, _concurrency);
  var pushCb = queue.push;
  var unshiftCb = queue.unshift;
  queue.push = push;
  queue.unshift = unshift;
  queue.drained = drained;
  return queue;
  function push(value) {
    var p = new Promise(function(resolve2, reject) {
      pushCb(value, function(err2, result) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve2(result);
      });
    });
    p.catch(noop$7);
    return p;
  }
  function unshift(value) {
    var p = new Promise(function(resolve2, reject) {
      unshiftCb(value, function(err2, result) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve2(result);
      });
    });
    p.catch(noop$7);
    return p;
  }
  function drained() {
    var p = new Promise(function(resolve2) {
      process.nextTick(function() {
        if (queue.idle()) {
          resolve2();
        } else {
          var previousDrain = queue.drain;
          queue.drain = function() {
            if (typeof previousDrain === "function") previousDrain();
            resolve2();
            queue.drain = previousDrain;
          };
        }
      });
    });
    return p;
  }
}
queue$1.exports = fastqueue;
queue$1.exports.promise = queueAsPromised;
var queueExports = queue$1.exports;
var error$n = { exports: {} };
const { format: format$4 } = require$$0$2;
function toString$3() {
  return `${this.name} [${this.code}]: ${this.message}`;
}
function createError$2(code2, message, statusCode = 500, Base = Error, captureStackTrace = createError$2.captureStackTrace) {
  if (!code2) throw new Error("Fastify error code must not be empty");
  if (!message) throw new Error("Fastify error message must not be empty");
  code2 = code2.toUpperCase();
  !statusCode && (statusCode = void 0);
  function FastifyError(...args) {
    if (!new.target) {
      return new FastifyError(...args);
    }
    this.code = code2;
    this.name = "FastifyError";
    this.statusCode = statusCode;
    const lastElement = args.length - 1;
    if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
      this.cause = args.pop().cause;
    }
    this.message = format$4(message, ...args);
    Error.stackTraceLimit && captureStackTrace && Error.captureStackTrace(this, FastifyError);
  }
  FastifyError.prototype = Object.create(Base.prototype, {
    constructor: {
      value: FastifyError,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  FastifyError.prototype[Symbol.toStringTag] = "Error";
  FastifyError.prototype.toString = toString$3;
  return FastifyError;
}
createError$2.captureStackTrace = true;
error$n.exports = createError$2;
error$n.exports.default = createError$2;
error$n.exports.createError = createError$2;
var errorExports = error$n.exports;
const { createError: createError$1 } = errorExports;
var errors$5 = {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: createError$1(
    "AVV_ERR_EXPOSE_ALREADY_DEFINED",
    "'%s' is already defined, specify an expose option for '%s'"
  ),
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError$1(
    "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
    "'%s' is already defined"
  ),
  AVV_ERR_CALLBACK_NOT_FN: createError$1(
    "AVV_ERR_CALLBACK_NOT_FN",
    "Callback for '%s' hook is not a function. Received: '%s'"
  ),
  AVV_ERR_PLUGIN_NOT_VALID: createError$1(
    "AVV_ERR_PLUGIN_NOT_VALID",
    "Plugin must be a function or a promise. Received: '%s'"
  ),
  AVV_ERR_ROOT_PLG_BOOTED: createError$1(
    "AVV_ERR_ROOT_PLG_BOOTED",
    "Root plugin has already booted"
  ),
  AVV_ERR_PARENT_PLG_LOADED: createError$1(
    "AVV_ERR_PARENT_PLG_LOADED",
    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
  ),
  AVV_ERR_READY_TIMEOUT: createError$1(
    "AVV_ERR_READY_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError$1(
    "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  )
};
const kAvvio$2 = Symbol("avvio.Boot");
const kIsOnCloseHandler$1 = Symbol("isOnCloseHandler");
const kThenifyDoNotWrap$1 = Symbol("avvio.ThenifyDoNotWrap");
const kUntrackNode$1 = Symbol("avvio.TimeTree.untrackNode");
const kTrackNode$1 = Symbol("avvio.TimeTree.trackNode");
const kGetParent$1 = Symbol("avvio.TimeTree.getParent");
const kGetNode$1 = Symbol("avvio.TimeTree.getNode");
const kAddNode$1 = Symbol("avvio.TimeTree.addNode");
const kPluginMeta$1 = Symbol.for("plugin-meta");
var symbols$2 = {
  kAvvio: kAvvio$2,
  kIsOnCloseHandler: kIsOnCloseHandler$1,
  kThenifyDoNotWrap: kThenifyDoNotWrap$1,
  kUntrackNode: kUntrackNode$1,
  kTrackNode: kTrackNode$1,
  kGetParent: kGetParent$1,
  kGetNode: kGetNode$1,
  kAddNode: kAddNode$1,
  kPluginMeta: kPluginMeta$1
};
const {
  kUntrackNode,
  kTrackNode,
  kGetParent,
  kGetNode,
  kAddNode
} = symbols$2;
let TimeTree$1 = class TimeTree {
  constructor() {
    this.root = null;
    this.tableId = /* @__PURE__ */ new Map();
    this.tableLabel = /* @__PURE__ */ new Map();
  }
  /**
   * @param {TimeTreeNode} node
   */
  [kTrackNode](node2) {
    this.tableId.set(node2.id, node2);
    if (this.tableLabel.has(node2.label)) {
      this.tableLabel.get(node2.label).push(node2);
    } else {
      this.tableLabel.set(node2.label, [node2]);
    }
  }
  /**
   * @param {TimeTreeNode} node
   */
  [kUntrackNode](node2) {
    this.tableId.delete(node2.id);
    const labelNode = this.tableLabel.get(node2.label);
    labelNode.pop();
    if (labelNode.length === 0) {
      this.tableLabel.delete(node2.label);
    }
  }
  /**
   * @param {string} parent
   * @returns {TimeTreeNode}
   */
  [kGetParent](parent) {
    if (parent === null) {
      return null;
    } else if (this.tableLabel.has(parent)) {
      const parentNode = this.tableLabel.get(parent);
      return parentNode[parentNode.length - 1];
    } else {
      return null;
    }
  }
  /**
   *
   * @param {string} nodeId
   * @returns {TimeTreeNode}
   */
  [kGetNode](nodeId) {
    return this.tableId.get(nodeId);
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number} start
   * @returns {TimeTreeNode["id"]}
   */
  [kAddNode](parent, label, start) {
    const parentNode = this[kGetParent](parent);
    const isRoot = parentNode === null;
    if (isRoot) {
      this.root = {
        parent: null,
        id: "root",
        label,
        nodes: [],
        start,
        stop: null,
        diff: -1
      };
      this[kTrackNode](this.root);
      return this.root.id;
    }
    const nodeId = `${label}-${Math.random()}`;
    const childNode = {
      parent,
      id: nodeId,
      label,
      nodes: [],
      start,
      stop: null,
      diff: -1
    };
    parentNode.nodes.push(childNode);
    this[kTrackNode](childNode);
    return nodeId;
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number|undefined} start
   * @returns {TimeTreeNode["id"]}
   */
  start(parent, label, start = Date.now()) {
    return this[kAddNode](parent, label, start);
  }
  /**
   * @param {string} nodeId
   * @param {number|undefined} stop
   */
  stop(nodeId, stop = Date.now()) {
    const node2 = this[kGetNode](nodeId);
    if (node2) {
      node2.stop = stop;
      node2.diff = node2.stop - node2.start || 0;
      this[kUntrackNode](node2);
    }
  }
  /**
   * @returns {TimeTreeNode}
   */
  toJSON() {
    return Object.assign({}, this.root);
  }
  /**
   * @returns {string}
   */
  prettyPrint() {
    return prettyPrintTimeTree(this.toJSON());
  }
};
function prettyPrintTimeTree(obj, prefix = "") {
  let result = prefix;
  const nodesCount = obj.nodes.length;
  const lastIndex = nodesCount - 1;
  result += `${obj.label} ${obj.diff} ms
`;
  for (let i = 0; i < nodesCount; ++i) {
    const node2 = obj.nodes[i];
    const prefix_ = prefix + (i === lastIndex ? "  " : "│ ");
    result += prefix;
    result += i === lastIndex ? "└─" : "├─";
    result += node2.nodes.length === 0 ? "─ " : "┬ ";
    result += prettyPrintTimeTree(node2, prefix_).slice(prefix.length + 2);
  }
  return result;
}
var timeTree = {
  TimeTree: TimeTree$1
};
const { debuglog } = require$$0$2;
const debug$9 = debuglog("avvio");
var debug_1$3 = {
  debug: debug$9
};
function createPromise$1() {
  const obj = {
    resolve: null,
    reject: null,
    promise: null
  };
  obj.promise = new Promise((resolve2, reject) => {
    obj.resolve = resolve2;
    obj.reject = reject;
  });
  return obj;
}
var createPromise_1 = {
  createPromise: createPromise$1
};
const { kPluginMeta } = symbols$2;
function getPluginName$1(plugin2, options) {
  if (plugin2[kPluginMeta] && plugin2[kPluginMeta].name) {
    return plugin2[kPluginMeta].name;
  }
  if (options && options.name) {
    return options.name;
  }
  if (plugin2.name) {
    return plugin2.name;
  } else {
    return plugin2.toString().split("\n").slice(0, 2).map((s) => s.trim()).join(" -- ");
  }
}
var getPluginName_1 = {
  getPluginName: getPluginName$1
};
function isPromiseLike$3(maybePromiseLike) {
  return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
}
var isPromiseLike_1 = {
  isPromiseLike: isPromiseLike$3
};
const { EventEmitter } = require$$0$3;
const { inherits: inherits$2 } = require$$0$2;
const { debug: debug$8 } = debug_1$3;
const { createPromise } = createPromise_1;
const { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = errors$5;
const { getPluginName } = getPluginName_1;
const { isPromiseLike: isPromiseLike$2 } = isPromiseLike_1;
function Plugin$1(queue, func, options, isAfter, timeout) {
  this.queue = queue;
  this.func = func;
  this.options = options;
  this.isAfter = isAfter;
  this.timeout = timeout;
  this.started = false;
  this.name = getPluginName(func, options);
  this.queue.pause();
  this._error = null;
  this.loaded = false;
  this._promise = null;
  this.startTime = null;
}
inherits$2(Plugin$1, EventEmitter);
Plugin$1.prototype.exec = function(server2, callback) {
  debug$8("exec", this.name);
  this.server = server2;
  const func = this.func;
  const name = this.name;
  let completed = false;
  this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
  let timer = null;
  const done = (execErr) => {
    if (completed) {
      debug$8("loading complete", name);
      return;
    }
    this._error = execErr;
    if (execErr) {
      debug$8("exec errored", name);
    } else {
      debug$8("exec completed", name);
    }
    completed = true;
    if (timer) {
      clearTimeout(timer);
    }
    callback(execErr);
  };
  if (this.timeout > 0) {
    debug$8("setting up timeout", name, this.timeout);
    timer = setTimeout(function() {
      debug$8("timed out", name);
      timer = null;
      const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
      readyTimeoutErr.fn = func;
      done(readyTimeoutErr);
    }, this.timeout);
  }
  this.started = true;
  this.startTime = Date.now();
  this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
  const maybePromiseLike = func(this.server, this.options, done);
  if (isPromiseLike$2(maybePromiseLike)) {
    debug$8("exec: resolving promise", name);
    maybePromiseLike.then(
      () => process.nextTick(done),
      (e) => process.nextTick(done, e)
    );
  } else if (func.length < 3) {
    done();
  }
};
Plugin$1.prototype.loadedSoFar = function() {
  debug$8("loadedSoFar", this.name);
  if (this.loaded) {
    return Promise.resolve();
  }
  const setup = () => {
    this.server.after((afterErr, callback) => {
      this._error = afterErr;
      this.queue.pause();
      if (this._promise) {
        if (afterErr) {
          debug$8("rejecting promise", this.name, afterErr);
          this._promise.reject(afterErr);
        } else {
          debug$8("resolving promise", this.name);
          this._promise.resolve();
        }
        this._promise = null;
      }
      process.nextTick(callback, afterErr);
    });
    this.queue.resume();
  };
  let res2;
  if (!this._promise) {
    this._promise = createPromise();
    res2 = this._promise.promise;
    if (!this.server) {
      this.on("start", setup);
    } else {
      setup();
    }
  } else {
    res2 = Promise.resolve();
  }
  return res2;
};
Plugin$1.prototype.enqueue = function(plugin2, callback) {
  debug$8("enqueue", this.name, plugin2.name);
  this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
  this.queue.push(plugin2, callback);
};
Plugin$1.prototype.finish = function(err2, callback) {
  debug$8("finish", this.name, err2);
  const done = () => {
    if (this.loaded) {
      return;
    }
    debug$8("loaded", this.name);
    this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
    this.loaded = true;
    callback(err2);
  };
  if (err2) {
    if (this._promise) {
      this._promise.reject(err2);
      this._promise = null;
    }
    done();
    return;
  }
  const check = () => {
    debug$8("check", this.name, this.queue.length(), this.queue.running(), this._promise);
    if (this.queue.length() === 0 && this.queue.running() === 0) {
      if (this._promise) {
        const wrap2 = () => {
          debug$8("wrap");
          queueMicrotask(check);
        };
        this._promise.resolve();
        this._promise.promise.then(wrap2, wrap2);
        this._promise = null;
      } else {
        done();
      }
    } else {
      debug$8("delayed", this.name);
      this.queue.drain = () => {
        debug$8("drain", this.name);
        this.queue.drain = noop$6;
        queueMicrotask(check);
      };
    }
  };
  queueMicrotask(check);
  this.queue.resume();
};
function noop$6() {
}
var plugin = {
  Plugin: Plugin$1
};
const { AVV_ERR_PLUGIN_NOT_VALID } = errors$5;
function validatePlugin$1(maybePlugin) {
  if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
    if (Array.isArray(maybePlugin)) {
      throw new AVV_ERR_PLUGIN_NOT_VALID("array");
    } else if (maybePlugin === null) {
      throw new AVV_ERR_PLUGIN_NOT_VALID("null");
    } else {
      throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
    }
  }
}
var validatePlugin_1 = {
  validatePlugin: validatePlugin$1
};
function isBundledOrTypescriptPlugin$1(maybeBundledOrTypescriptPlugin) {
  return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
}
var isBundledOrTypescriptPlugin_1 = {
  isBundledOrTypescriptPlugin: isBundledOrTypescriptPlugin$1
};
const { debug: debug$7 } = debug_1$3;
const { kThenifyDoNotWrap } = symbols$2;
function thenify$1() {
  if (this.booted) {
    debug$7("thenify returning undefined because we are already booted");
    return;
  }
  if (this[kThenifyDoNotWrap]) {
    this[kThenifyDoNotWrap] = false;
    return;
  }
  debug$7("thenify");
  return (resolve2, reject) => {
    const p = this._loadRegistered();
    return p.then(() => {
      this[kThenifyDoNotWrap] = true;
      return resolve2(this._server);
    }, reject);
  };
}
var thenify_1 = {
  thenify: thenify$1
};
const { isPromiseLike: isPromiseLike$1 } = isPromiseLike_1;
const { kAvvio: kAvvio$1 } = symbols$2;
function executeWithThenable$1(func, args, callback) {
  const result = func.apply(func, args);
  if (isPromiseLike$1(result) && !result[kAvvio$1]) {
    result.then(() => process.nextTick(callback), (error2) => process.nextTick(callback, error2));
  } else if (callback) {
    process.nextTick(callback);
  }
}
var executeWithThenable_1 = {
  executeWithThenable: executeWithThenable$1
};
const fastq = queueExports;
const EE = require$$0$3.EventEmitter;
const inherits$1 = require$$0$2.inherits;
const {
  AVV_ERR_EXPOSE_ALREADY_DEFINED,
  AVV_ERR_CALLBACK_NOT_FN,
  AVV_ERR_ROOT_PLG_BOOTED,
  AVV_ERR_READY_TIMEOUT,
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
} = errors$5;
const {
  kAvvio,
  kIsOnCloseHandler
} = symbols$2;
const { TimeTree: TimeTree2 } = timeTree;
const { Plugin } = plugin;
const { debug: debug$6 } = debug_1$3;
const { validatePlugin } = validatePlugin_1;
const { isBundledOrTypescriptPlugin } = isBundledOrTypescriptPlugin_1;
const { isPromiseLike } = isPromiseLike_1;
const { thenify } = thenify_1;
const { executeWithThenable } = executeWithThenable_1;
function Boot(server2, opts, done) {
  if (typeof server2 === "function" && arguments.length === 1) {
    done = server2;
    opts = {};
    server2 = null;
  }
  if (typeof opts === "function") {
    done = opts;
    opts = {};
  }
  opts = opts || {};
  opts.autostart = opts.autostart !== false;
  opts.timeout = Number(opts.timeout) || 0;
  opts.expose = opts.expose || {};
  if (!new.target) {
    return new Boot(server2, opts, done);
  }
  this._server = server2 || this;
  this._opts = opts;
  if (server2) {
    this._expose();
  }
  this._current = [];
  this._error = null;
  this._lastUsed = null;
  this.setMaxListeners(0);
  if (done) {
    this.once("start", done);
  }
  this.started = false;
  this.booted = false;
  this.pluginTree = new TimeTree2();
  this._readyQ = fastq(this, callWithCbOrNextTick, 1);
  this._readyQ.pause();
  this._readyQ.drain = () => {
    this.emit("start");
    this._readyQ.drain = noop$5;
  };
  this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
  this._closeQ.pause();
  this._closeQ.drain = () => {
    this.emit("close");
    this._closeQ.drain = noop$5;
  };
  this._doStart = null;
  const instance = this;
  this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root2(server3, opts2, done2) {
    instance._doStart = done2;
    opts2.autostart && instance.start();
  }, opts, false, 0);
  this._trackPluginLoading(this._root);
  this._loadPlugin(this._root, (err2) => {
    debug$6("root plugin ready");
    try {
      this.emit("preReady");
      this._root = null;
    } catch (preReadyError) {
      err2 = err2 || this._error || preReadyError;
    }
    if (err2) {
      this._error = err2;
      if (this._readyQ.length() === 0) {
        throw err2;
      }
    } else {
      this.booted = true;
    }
    this._readyQ.resume();
  });
}
inherits$1(Boot, EE);
Boot.prototype.start = function() {
  this.started = true;
  process.nextTick(this._doStart);
  return this;
};
Boot.prototype.override = function(server2, func, opts) {
  return server2;
};
Boot.prototype[kAvvio] = true;
Boot.prototype.use = function(plugin2, opts) {
  this._lastUsed = this._addPlugin(plugin2, opts, false);
  return this;
};
Boot.prototype._loadRegistered = function() {
  const plugin2 = this._current[0];
  const weNeedToStart = !this.started && !this.booted;
  if (weNeedToStart) {
    process.nextTick(() => this._root.queue.resume());
  }
  if (!plugin2) {
    return Promise.resolve();
  }
  return plugin2.loadedSoFar();
};
Object.defineProperty(Boot.prototype, "then", { get: thenify });
Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
  if (isBundledOrTypescriptPlugin(pluginFn)) {
    pluginFn = pluginFn.default;
  }
  validatePlugin(pluginFn);
  opts = opts || {};
  if (this.booted) {
    throw new AVV_ERR_ROOT_PLG_BOOTED();
  }
  const current = this._current[0];
  let timeout = this._opts.timeout;
  if (!current.loaded && current.timeout > 0) {
    const delta = Date.now() - current.startTime;
    timeout = current.timeout - (delta + 3);
  }
  const plugin2 = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
  this._trackPluginLoading(plugin2);
  if (current.loaded) {
    throw new Error(plugin2.name, current.name);
  }
  current.enqueue(plugin2, (err2) => {
    err2 && (this._error = err2);
  });
  return plugin2;
};
Boot.prototype._expose = function _expose() {
  const instance = this;
  const server2 = instance._server;
  const {
    use: useKey = "use",
    after: afterKey = "after",
    ready: readyKey = "ready",
    onClose: onCloseKey = "onClose",
    close: closeKey = "close"
  } = this._opts.expose;
  if (server2[useKey]) {
    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
  }
  server2[useKey] = function(fn, opts) {
    instance.use(fn, opts);
    return this;
  };
  if (server2[afterKey]) {
    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
  }
  server2[afterKey] = function(func) {
    if (typeof func !== "function") {
      return instance._loadRegistered();
    }
    instance.after(encapsulateThreeParam(func, this));
    return this;
  };
  if (server2[readyKey]) {
    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
  }
  server2[readyKey] = function(func) {
    if (func && typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
    }
    return instance.ready(func ? encapsulateThreeParam(func, this) : void 0);
  };
  if (server2[onCloseKey]) {
    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
  }
  server2[onCloseKey] = function(func) {
    if (typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
    }
    instance.onClose(encapsulateTwoParam(func, this));
    return this;
  };
  if (server2[closeKey]) {
    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
  }
  server2[closeKey] = function(func) {
    if (func && typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
    }
    if (func) {
      instance.close(encapsulateThreeParam(func, this));
      return this;
    }
    return instance.close();
  };
  if (server2.then) {
    throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
  }
  Object.defineProperty(server2, "then", { get: thenify.bind(instance) });
  server2[kAvvio] = true;
};
Boot.prototype.after = function(func) {
  if (!func) {
    return this._loadRegistered();
  }
  this._addPlugin(_after.bind(this), {}, true);
  function _after(s, opts, done) {
    callWithCbOrNextTick.call(this, func, done);
  }
  return this;
};
Boot.prototype.onClose = function(func) {
  if (typeof func !== "function") {
    throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
  }
  func[kIsOnCloseHandler] = true;
  this._closeQ.unshift(func, (err2) => {
    err2 && (this._error = err2);
  });
  return this;
};
Boot.prototype.close = function(func) {
  let promise;
  if (func) {
    if (typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
    }
  } else {
    promise = new Promise(function(resolve2, reject) {
      func = function(err2) {
        if (err2) {
          return reject(err2);
        }
        resolve2();
      };
    });
  }
  this.ready(() => {
    this._error = null;
    this._closeQ.push(func);
    process.nextTick(this._closeQ.resume.bind(this._closeQ));
  });
  return promise;
};
Boot.prototype.ready = function(func) {
  if (func) {
    if (typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
    }
    this._readyQ.push(func);
    queueMicrotask(this.start.bind(this));
    return;
  }
  return new Promise((resolve2, reject) => {
    this._readyQ.push(readyPromiseCB);
    this.start();
    const relativeContext = this._current[0].server;
    function readyPromiseCB(err2, context2, done) {
      if (err2) {
        reject(err2);
      } else {
        resolve2(relativeContext);
      }
      process.nextTick(done);
    }
  });
};
Boot.prototype._trackPluginLoading = function(plugin2) {
  var _a2;
  const parentName = ((_a2 = this._current[0]) == null ? void 0 : _a2.name) || null;
  plugin2.once("start", (serverName, funcName, time2) => {
    const nodeId = this.pluginTree.start(parentName || null, funcName, time2);
    plugin2.once("loaded", (serverName2, funcName2, time3) => {
      this.pluginTree.stop(nodeId, time3);
    });
  });
};
Boot.prototype.prettyPrint = function() {
  return this.pluginTree.prettyPrint();
};
Boot.prototype.toJSON = function() {
  return this.pluginTree.toJSON();
};
Boot.prototype._loadPlugin = function(plugin2, callback) {
  const instance = this;
  if (isPromiseLike(plugin2.func)) {
    plugin2.func.then((fn) => {
      if (typeof fn.default === "function") {
        fn = fn.default;
      }
      plugin2.func = fn;
      this._loadPlugin(plugin2, callback);
    }, callback);
    return;
  }
  const last = instance._current[0];
  instance._current.unshift(plugin2);
  if (instance._error && !plugin2.isAfter) {
    debug$6("skipping loading of plugin as instance errored and it is not an after", plugin2.name);
    process.nextTick(execCallback);
    return;
  }
  let server2 = last && last.server || instance._server;
  if (!plugin2.isAfter) {
    try {
      server2 = instance.override(server2, plugin2.func, plugin2.options);
    } catch (overrideErr) {
      debug$6("override errored", plugin2.name);
      return execCallback(overrideErr);
    }
  }
  plugin2.exec(server2, execCallback);
  function execCallback(err2) {
    plugin2.finish(err2, (err3) => {
      instance._current.shift();
      callback(err3);
    });
  }
};
Boot.prototype._loadPluginNextTick = function(plugin2, callback) {
  process.nextTick(this._loadPlugin.bind(this), plugin2, callback);
};
function noop$5() {
}
function callWithCbOrNextTick(func, cb) {
  const context2 = this._server;
  const err2 = this._error;
  this._error = null;
  if (func.length === 0) {
    this._error = err2;
    executeWithThenable(func, [], cb);
  } else if (func.length === 1) {
    executeWithThenable(func, [err2], cb);
  } else {
    if (this._opts.timeout === 0) {
      const wrapCb = (err3) => {
        this._error = err3;
        cb(this._error);
      };
      if (func.length === 2) {
        func(err2, wrapCb);
      } else {
        func(err2, context2, wrapCb);
      }
    } else {
      timeoutCall.call(this, func, err2, context2, cb);
    }
  }
}
function timeoutCall(func, rootErr, context2, cb) {
  const name = func.unwrappedName ?? func.name;
  debug$6("setting up ready timeout", name, this._opts.timeout);
  let timer = setTimeout(() => {
    debug$6("timed out", name);
    timer = null;
    const toutErr = new AVV_ERR_READY_TIMEOUT(name);
    toutErr.fn = func;
    this._error = toutErr;
    cb(toutErr);
  }, this._opts.timeout);
  if (func.length === 2) {
    func(rootErr, timeoutCb.bind(this));
  } else {
    func(rootErr, context2, timeoutCb.bind(this));
  }
  function timeoutCb(err2) {
    if (timer) {
      clearTimeout(timer);
      this._error = err2;
      cb(this._error);
    }
  }
}
function closeWithCbOrNextTick(func, cb) {
  const context2 = this._server;
  const isOnCloseHandler = func[kIsOnCloseHandler];
  if (func.length === 0 || func.length === 1) {
    let promise;
    if (isOnCloseHandler) {
      promise = func(context2);
    } else {
      promise = func(this._error);
    }
    if (promise && typeof promise.then === "function") {
      debug$6("resolving close/onClose promise");
      promise.then(
        () => process.nextTick(cb),
        (e) => process.nextTick(cb, e)
      );
    } else {
      process.nextTick(cb);
    }
  } else if (func.length === 2) {
    if (isOnCloseHandler) {
      func(context2, cb);
    } else {
      func(this._error, cb);
    }
  } else {
    if (isOnCloseHandler) {
      func(context2, cb);
    } else {
      func(this._error, context2, cb);
    }
  }
}
function encapsulateTwoParam(func, that) {
  return _encapsulateTwoParam.bind(that);
  function _encapsulateTwoParam(context2, cb) {
    let res2;
    if (func.length === 0) {
      res2 = func();
      if (res2 && res2.then) {
        res2.then(function() {
          process.nextTick(cb);
        }, cb);
      } else {
        process.nextTick(cb);
      }
    } else if (func.length === 1) {
      res2 = func(this);
      if (res2 && res2.then) {
        res2.then(function() {
          process.nextTick(cb);
        }, cb);
      } else {
        process.nextTick(cb);
      }
    } else {
      func(this, cb);
    }
  }
}
function encapsulateThreeParam(func, that) {
  const wrapped = _encapsulateThreeParam.bind(that);
  wrapped.unwrappedName = func.name;
  return wrapped;
  function _encapsulateThreeParam(err2, cb) {
    let res2;
    if (!func) {
      process.nextTick(cb);
    } else if (func.length === 0) {
      res2 = func();
      if (res2 && res2.then) {
        res2.then(function() {
          process.nextTick(cb, err2);
        }, cb);
      } else {
        process.nextTick(cb, err2);
      }
    } else if (func.length === 1) {
      res2 = func(err2);
      if (res2 && res2.then) {
        res2.then(function() {
          process.nextTick(cb);
        }, cb);
      } else {
        process.nextTick(cb);
      }
    } else if (func.length === 2) {
      func(err2, cb);
    } else {
      func(err2, this, cb);
    }
  }
}
var boot = Boot;
const keys = {
  kAvvioBoot: Symbol("fastify.avvioBoot"),
  kChildren: Symbol("fastify.children"),
  kServerBindings: Symbol("fastify.serverBindings"),
  kBodyLimit: Symbol("fastify.bodyLimit"),
  kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
  kRoutePrefix: Symbol("fastify.routePrefix"),
  kLogLevel: Symbol("fastify.logLevel"),
  kLogSerializers: Symbol("fastify.logSerializers"),
  kHooks: Symbol("fastify.hooks"),
  kContentTypeParser: Symbol("fastify.contentTypeParser"),
  kState: Symbol("fastify.state"),
  kOptions: Symbol("fastify.options"),
  kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
  kPluginNameChain: Symbol("fastify.pluginNameChain"),
  kRouteContext: Symbol("fastify.context"),
  kGenReqId: Symbol("fastify.genReqId"),
  // Schema
  kSchemaController: Symbol("fastify.schemaController"),
  kSchemaHeaders: Symbol("headers-schema"),
  kSchemaParams: Symbol("params-schema"),
  kSchemaQuerystring: Symbol("querystring-schema"),
  kSchemaBody: Symbol("body-schema"),
  kSchemaResponse: Symbol("response-schema"),
  kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
  kSchemaVisited: Symbol("fastify.schemas.visited"),
  // Request
  kRequest: Symbol("fastify.Request"),
  kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
  kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
  kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
  kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
  // 404
  kFourOhFour: Symbol("fastify.404"),
  kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
  kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
  kFourOhFourContext: Symbol("fastify.404ContextKey"),
  kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
  // Reply
  kReply: Symbol("fastify.Reply"),
  kReplySerializer: Symbol("fastify.reply.serializer"),
  kReplyIsError: Symbol("fastify.reply.isError"),
  kReplyHeaders: Symbol("fastify.reply.headers"),
  kReplyTrailers: Symbol("fastify.reply.trailers"),
  kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
  kReplyHijacked: Symbol("fastify.reply.hijacked"),
  kReplyStartTime: Symbol("fastify.reply.startTime"),
  kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
  kReplyEndTime: Symbol("fastify.reply.endTime"),
  kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
  kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
  kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
  kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
  kTestInternals: Symbol("fastify.testInternals"),
  kErrorHandler: Symbol("fastify.errorHandler"),
  kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
  kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
  kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
  kRouteByFastify: Symbol("fastify.routeByFastify")
};
var symbols$1 = keys;
var server = {};
var processWarning = { exports: {} };
const { format: format$3 } = require$$0$2;
function createDeprecation(params) {
  return createWarning$1({ ...params, name: "DeprecationWarning" });
}
function createWarning$1({ name, code: code2, message, unlimited = false } = {}) {
  if (!name) throw new Error("Warning name must not be empty");
  if (!code2) throw new Error("Warning code must not be empty");
  if (!message) throw new Error("Warning message must not be empty");
  if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
  code2 = code2.toUpperCase();
  let warningContainer = {
    [name]: function(a, b, c) {
      if (warning.emitted === true && warning.unlimited !== true) {
        return;
      }
      warning.emitted = true;
      process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
    }
  };
  if (unlimited) {
    warningContainer = {
      [name]: function(a, b, c) {
        warning.emitted = true;
        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
      }
    };
  }
  const warning = warningContainer[name];
  warning.emitted = false;
  warning.message = message;
  warning.unlimited = unlimited;
  warning.code = code2;
  warning.format = function(a, b, c) {
    let formatted;
    if (a && b && c) {
      formatted = format$3(message, a, b, c);
    } else if (a && b) {
      formatted = format$3(message, a, b);
    } else if (a) {
      formatted = format$3(message, a);
    } else {
      formatted = message;
    }
    return formatted;
  };
  return warning;
}
const out$1 = { createWarning: createWarning$1, createDeprecation };
processWarning.exports = out$1;
processWarning.exports.default = out$1;
processWarning.exports.processWarning = out$1;
var processWarningExports = processWarning.exports;
const { createWarning } = processWarningExports;
const FSTWRN001$1 = createWarning({
  name: "FastifyWarning",
  code: "FSTWRN001",
  message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
  unlimited: true
});
const FSTWRN003$1 = createWarning({
  name: "FastifyWarning",
  code: "FSTWRN003",
  message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
  unlimited: true
});
const FSTSEC001 = createWarning({
  name: "FastifySecurity",
  code: "FSTSEC001",
  message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
  unlimited: true
});
var warnings = {
  FSTWRN001: FSTWRN001$1,
  FSTWRN003: FSTWRN003$1,
  FSTSEC001
};
var errors$4 = { exports: {} };
const createError = errorExports;
const codes = {
  /**
   * Basic
   */
  FST_ERR_NOT_FOUND: createError(
    "FST_ERR_NOT_FOUND",
    "Not Found",
    404
  ),
  FST_ERR_OPTIONS_NOT_OBJ: createError(
    "FST_ERR_OPTIONS_NOT_OBJ",
    "Options must be an object",
    500,
    TypeError
  ),
  FST_ERR_QSP_NOT_FN: createError(
    "FST_ERR_QSP_NOT_FN",
    "querystringParser option should be a function, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError(
    "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
    "schemaController.bucket option should be a function, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError(
    "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
    "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
    500,
    TypeError
  ),
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError(
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
    "ajv.customOptions option should be an object, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError(
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
    "ajv.plugins option should be an array, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_VALIDATION: createError(
    "FST_ERR_VALIDATION",
    "%s",
    400
  ),
  FST_ERR_LISTEN_OPTIONS_INVALID: createError(
    "FST_ERR_LISTEN_OPTIONS_INVALID",
    "Invalid listen options: '%s'",
    500,
    TypeError
  ),
  FST_ERR_ERROR_HANDLER_NOT_FN: createError(
    "FST_ERR_ERROR_HANDLER_NOT_FN",
    "Error Handler must be a function",
    500,
    TypeError
  ),
  /**
   * ContentTypeParser
  */
  FST_ERR_CTP_ALREADY_PRESENT: createError(
    "FST_ERR_CTP_ALREADY_PRESENT",
    "Content type parser '%s' already present."
  ),
  FST_ERR_CTP_INVALID_TYPE: createError(
    "FST_ERR_CTP_INVALID_TYPE",
    "The content type should be a string or a RegExp",
    500,
    TypeError
  ),
  FST_ERR_CTP_EMPTY_TYPE: createError(
    "FST_ERR_CTP_EMPTY_TYPE",
    "The content type cannot be an empty string",
    500,
    TypeError
  ),
  FST_ERR_CTP_INVALID_HANDLER: createError(
    "FST_ERR_CTP_INVALID_HANDLER",
    "The content type handler should be a function",
    500,
    TypeError
  ),
  FST_ERR_CTP_INVALID_PARSE_TYPE: createError(
    "FST_ERR_CTP_INVALID_PARSE_TYPE",
    "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
    500,
    TypeError
  ),
  FST_ERR_CTP_BODY_TOO_LARGE: createError(
    "FST_ERR_CTP_BODY_TOO_LARGE",
    "Request body is too large",
    413,
    RangeError
  ),
  FST_ERR_CTP_INVALID_MEDIA_TYPE: createError(
    "FST_ERR_CTP_INVALID_MEDIA_TYPE",
    "Unsupported Media Type: %s",
    415
  ),
  FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError(
    "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
    "Request body size did not match Content-Length",
    400,
    RangeError
  ),
  FST_ERR_CTP_EMPTY_JSON_BODY: createError(
    "FST_ERR_CTP_EMPTY_JSON_BODY",
    "Body cannot be empty when content-type is set to 'application/json'",
    400
  ),
  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError(
    "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
    'Cannot call "%s" when fastify instance is already started!',
    400
  ),
  /**
   * decorate
  */
  FST_ERR_DEC_ALREADY_PRESENT: createError(
    "FST_ERR_DEC_ALREADY_PRESENT",
    "The decorator '%s' has already been added!"
  ),
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError(
    "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
    "The dependencies of decorator '%s' must be of type Array.",
    500,
    TypeError
  ),
  FST_ERR_DEC_MISSING_DEPENDENCY: createError(
    "FST_ERR_DEC_MISSING_DEPENDENCY",
    "The decorator is missing dependency '%s'."
  ),
  FST_ERR_DEC_AFTER_START: createError(
    "FST_ERR_DEC_AFTER_START",
    "The decorator '%s' has been added after start!"
  ),
  FST_ERR_DEC_REFERENCE_TYPE: createError(
    "FST_ERR_DEC_REFERENCE_TYPE",
    "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
  ),
  /**
   * hooks
  */
  FST_ERR_HOOK_INVALID_TYPE: createError(
    "FST_ERR_HOOK_INVALID_TYPE",
    "The hook name must be a string",
    500,
    TypeError
  ),
  FST_ERR_HOOK_INVALID_HANDLER: createError(
    "FST_ERR_HOOK_INVALID_HANDLER",
    "%s hook should be a function, instead got %s",
    500,
    TypeError
  ),
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError(
    "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
    "Async function has too many arguments. Async hooks should not use the 'done' argument.",
    500,
    TypeError
  ),
  FST_ERR_HOOK_NOT_SUPPORTED: createError(
    "FST_ERR_HOOK_NOT_SUPPORTED",
    "%s hook not supported!",
    500,
    TypeError
  ),
  /**
   * Middlewares
   */
  FST_ERR_MISSING_MIDDLEWARE: createError(
    "FST_ERR_MISSING_MIDDLEWARE",
    "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
    500
  ),
  FST_ERR_HOOK_TIMEOUT: createError(
    "FST_ERR_HOOK_TIMEOUT",
    "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  /**
   * logger
  */
  FST_ERR_LOG_INVALID_DESTINATION: createError(
    "FST_ERR_LOG_INVALID_DESTINATION",
    "Cannot specify both logger.stream and logger.file options"
  ),
  FST_ERR_LOG_INVALID_LOGGER: createError(
    "FST_ERR_LOG_INVALID_LOGGER",
    "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
    500,
    TypeError
  ),
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError(
    "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
    "loggerInstance only accepts a logger instance.",
    500,
    TypeError
  ),
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError(
    "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
    "logger options only accepts a configuration object.",
    500,
    TypeError
  ),
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError(
    "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
    "You cannot provide both logger and loggerInstance. Please provide only one.",
    500,
    TypeError
  ),
  /**
   * reply
  */
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError(
    "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
    "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
    500,
    TypeError
  ),
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError(
    "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
    "Response.body is already consumed."
  ),
  FST_ERR_REP_READABLE_STREAM_LOCKED: createError(
    "FST_ERR_REP_READABLE_STREAM_LOCKED",
    "ReadableStream was locked. You should call releaseLock() method on reader before sending."
  ),
  FST_ERR_REP_ALREADY_SENT: createError(
    "FST_ERR_REP_ALREADY_SENT",
    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
  ),
  FST_ERR_REP_SENT_VALUE: createError(
    "FST_ERR_REP_SENT_VALUE",
    "The only possible value for reply.sent is true.",
    500,
    TypeError
  ),
  FST_ERR_SEND_INSIDE_ONERR: createError(
    "FST_ERR_SEND_INSIDE_ONERR",
    "You cannot use `send` inside the `onError` hook"
  ),
  FST_ERR_SEND_UNDEFINED_ERR: createError(
    "FST_ERR_SEND_UNDEFINED_ERR",
    "Undefined error has occurred"
  ),
  FST_ERR_BAD_STATUS_CODE: createError(
    "FST_ERR_BAD_STATUS_CODE",
    "Called reply with an invalid status code: %s"
  ),
  FST_ERR_BAD_TRAILER_NAME: createError(
    "FST_ERR_BAD_TRAILER_NAME",
    "Called reply.trailer with an invalid header name: %s"
  ),
  FST_ERR_BAD_TRAILER_VALUE: createError(
    "FST_ERR_BAD_TRAILER_VALUE",
    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
  ),
  FST_ERR_FAILED_ERROR_SERIALIZATION: createError(
    "FST_ERR_FAILED_ERROR_SERIALIZATION",
    "Failed to serialize an error. Error: %s. Original error: %s"
  ),
  FST_ERR_MISSING_SERIALIZATION_FN: createError(
    "FST_ERR_MISSING_SERIALIZATION_FN",
    'Missing serialization function. Key "%s"'
  ),
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError(
    "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
    'Missing serialization function. Key "%s:%s"'
  ),
  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError(
    "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
    'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
  ),
  /**
   * schemas
  */
  FST_ERR_SCH_MISSING_ID: createError(
    "FST_ERR_SCH_MISSING_ID",
    "Missing schema $id property"
  ),
  FST_ERR_SCH_ALREADY_PRESENT: createError(
    "FST_ERR_SCH_ALREADY_PRESENT",
    "Schema with id '%s' already declared!"
  ),
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError(
    "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
    "Schema is missing for the content type '%s'"
  ),
  FST_ERR_SCH_DUPLICATE: createError(
    "FST_ERR_SCH_DUPLICATE",
    "Schema with '%s' already present!"
  ),
  FST_ERR_SCH_VALIDATION_BUILD: createError(
    "FST_ERR_SCH_VALIDATION_BUILD",
    "Failed building the validation schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_SERIALIZATION_BUILD: createError(
    "FST_ERR_SCH_SERIALIZATION_BUILD",
    "Failed building the serialization schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError(
    "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
    'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
  ),
  /**
   * http2
   */
  FST_ERR_HTTP2_INVALID_VERSION: createError(
    "FST_ERR_HTTP2_INVALID_VERSION",
    "HTTP2 is available only from node >= 8.8.1"
  ),
  /**
   * initialConfig
   */
  FST_ERR_INIT_OPTS_INVALID: createError(
    "FST_ERR_INIT_OPTS_INVALID",
    "Invalid initialization options: '%s'"
  ),
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError(
    "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
    "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
  ),
  /**
   * router
   */
  FST_ERR_DUPLICATED_ROUTE: createError(
    "FST_ERR_DUPLICATED_ROUTE",
    "Method '%s' already declared for route '%s'"
  ),
  FST_ERR_BAD_URL: createError(
    "FST_ERR_BAD_URL",
    "'%s' is not a valid url component",
    400,
    URIError
  ),
  FST_ERR_ASYNC_CONSTRAINT: createError(
    "FST_ERR_ASYNC_CONSTRAINT",
    "Unexpected error from async constraint",
    500
  ),
  FST_ERR_INVALID_URL: createError(
    "FST_ERR_INVALID_URL",
    "URL must be a string. Received '%s'",
    400,
    TypeError
  ),
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError(
    "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
    'Options for "%s:%s" route must be an object',
    500,
    TypeError
  ),
  FST_ERR_ROUTE_DUPLICATED_HANDLER: createError(
    "FST_ERR_ROUTE_DUPLICATED_HANDLER",
    'Duplicate handler for "%s:%s" route is not allowed!',
    500
  ),
  FST_ERR_ROUTE_HANDLER_NOT_FN: createError(
    "FST_ERR_ROUTE_HANDLER_NOT_FN",
    "Error Handler for %s:%s route, if defined, must be a function",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_MISSING_HANDLER: createError(
    "FST_ERR_ROUTE_MISSING_HANDLER",
    'Missing handler function for "%s:%s" route.',
    500
  ),
  FST_ERR_ROUTE_METHOD_INVALID: createError(
    "FST_ERR_ROUTE_METHOD_INVALID",
    "Provided method is invalid!",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError(
    "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
    "%s method is not supported.",
    500
  ),
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError(
    "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
    "Body validation schema for %s:%s route is not supported!",
    500
  ),
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError(
    "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
    "'bodyLimit' option must be an integer > 0. Got '%s'",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_REWRITE_NOT_STR: createError(
    "FST_ERR_ROUTE_REWRITE_NOT_STR",
    'Rewrite url for "%s" needs to be of type "string" but received "%s"',
    500,
    TypeError
  ),
  /**
   *  again listen when close server
   */
  FST_ERR_REOPENED_CLOSE_SERVER: createError(
    "FST_ERR_REOPENED_CLOSE_SERVER",
    "Fastify has already been closed and cannot be reopened"
  ),
  FST_ERR_REOPENED_SERVER: createError(
    "FST_ERR_REOPENED_SERVER",
    "Fastify is already listening"
  ),
  FST_ERR_INSTANCE_ALREADY_LISTENING: createError(
    "FST_ERR_INSTANCE_ALREADY_LISTENING",
    "Fastify instance is already listening. %s"
  ),
  /**
   * plugin
   */
  FST_ERR_PLUGIN_VERSION_MISMATCH: createError(
    "FST_ERR_PLUGIN_VERSION_MISMATCH",
    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
  ),
  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError(
    "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
    "The decorator '%s'%s is not present in %s"
  ),
  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError(
    "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
    "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
    500,
    TypeError
  ),
  /**
   *  Avvio Errors
   */
  FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError(
    "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
    "fastify-plugin: %s",
    500,
    TypeError
  ),
  FST_ERR_PLUGIN_NOT_VALID: createError(
    "FST_ERR_PLUGIN_NOT_VALID",
    "fastify-plugin: %s"
  ),
  FST_ERR_ROOT_PLG_BOOTED: createError(
    "FST_ERR_ROOT_PLG_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PARENT_PLUGIN_BOOTED: createError(
    "FST_ERR_PARENT_PLUGIN_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PLUGIN_TIMEOUT: createError(
    "FST_ERR_PLUGIN_TIMEOUT",
    "fastify-plugin: %s"
  )
};
function appendStackTrace$2(oldErr, newErr) {
  newErr.cause = oldErr;
  return newErr;
}
errors$4.exports = codes;
errors$4.exports.appendStackTrace = appendStackTrace$2;
errors$4.exports.AVVIO_ERRORS_MAP = {
  AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
  AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
  AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
  AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
  AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
};
var errorsExports = errors$4.exports;
const applicationHooks = [
  "onRoute",
  "onRegister",
  "onReady",
  "onListen",
  "preClose",
  "onClose"
];
const lifecycleHooks$2 = [
  "onTimeout",
  "onRequest",
  "preParsing",
  "preValidation",
  "preSerialization",
  "preHandler",
  "onSend",
  "onResponse",
  "onError",
  "onRequestAbort"
];
const supportedHooks$1 = lifecycleHooks$2.concat(applicationHooks);
const {
  FST_ERR_HOOK_INVALID_TYPE,
  FST_ERR_HOOK_INVALID_HANDLER: FST_ERR_HOOK_INVALID_HANDLER$1,
  FST_ERR_SEND_UNDEFINED_ERR,
  FST_ERR_HOOK_TIMEOUT,
  FST_ERR_HOOK_NOT_SUPPORTED,
  AVVIO_ERRORS_MAP: AVVIO_ERRORS_MAP$1,
  appendStackTrace: appendStackTrace$1
} = errorsExports;
const {
  kChildren: kChildren$2,
  kHooks: kHooks$4,
  kRequestPayloadStream: kRequestPayloadStream$1
} = symbols$1;
function Hooks$1() {
  this.onRequest = [];
  this.preParsing = [];
  this.preValidation = [];
  this.preSerialization = [];
  this.preHandler = [];
  this.onResponse = [];
  this.onSend = [];
  this.onError = [];
  this.onRoute = [];
  this.onRegister = [];
  this.onReady = [];
  this.onListen = [];
  this.onTimeout = [];
  this.onRequestAbort = [];
  this.preClose = [];
}
Hooks$1.prototype = /* @__PURE__ */ Object.create(null);
Hooks$1.prototype.validate = function(hook, fn) {
  if (typeof hook !== "string") throw new FST_ERR_HOOK_INVALID_TYPE();
  if (Array.isArray(this[hook]) === false) {
    throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
  }
  if (typeof fn !== "function") throw new FST_ERR_HOOK_INVALID_HANDLER$1(hook, Object.prototype.toString.call(fn));
};
Hooks$1.prototype.add = function(hook, fn) {
  this.validate(hook, fn);
  this[hook].push(fn);
};
function buildHooks$1(h) {
  const hooks2 = new Hooks$1();
  hooks2.onRequest = h.onRequest.slice();
  hooks2.preParsing = h.preParsing.slice();
  hooks2.preValidation = h.preValidation.slice();
  hooks2.preSerialization = h.preSerialization.slice();
  hooks2.preHandler = h.preHandler.slice();
  hooks2.onSend = h.onSend.slice();
  hooks2.onResponse = h.onResponse.slice();
  hooks2.onError = h.onError.slice();
  hooks2.onRoute = h.onRoute.slice();
  hooks2.onRegister = h.onRegister.slice();
  hooks2.onTimeout = h.onTimeout.slice();
  hooks2.onRequestAbort = h.onRequestAbort.slice();
  hooks2.onReady = [];
  hooks2.onListen = [];
  hooks2.preClose = [];
  return hooks2;
}
function hookRunnerApplication$1(hookName, boot2, server2, cb) {
  const hooks2 = server2[kHooks$4][hookName];
  let i = 0;
  let c = 0;
  next();
  function exit(err2) {
    var _a2;
    const hookFnName = (_a2 = hooks2[i - 1]) == null ? void 0 : _a2.name;
    const hookFnFragment = hookFnName ? ` "${hookFnName}"` : "";
    if (err2) {
      if (err2.code === "AVV_ERR_READY_TIMEOUT") {
        err2 = appendStackTrace$1(err2, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
      } else {
        err2 = AVVIO_ERRORS_MAP$1[err2.code] != null ? appendStackTrace$1(err2, new AVVIO_ERRORS_MAP$1[err2.code](err2.message)) : err2;
      }
      cb(err2);
      return;
    }
    cb();
  }
  function next(err2) {
    if (err2) {
      exit(err2);
      return;
    }
    if (i === hooks2.length && c === server2[kChildren$2].length) {
      if (i === 0 && c === 0) {
        exit();
      } else {
        boot2(function manageTimeout(err3, done) {
          exit(err3);
          done(err3);
        });
      }
      return;
    }
    if (i === hooks2.length && c < server2[kChildren$2].length) {
      const child = server2[kChildren$2][c++];
      hookRunnerApplication$1(hookName, boot2, child, next);
      return;
    }
    boot2(wrap2(hooks2[i++], server2));
    next();
  }
  function wrap2(fn, server3) {
    return function(err2, done) {
      if (err2) {
        done(err2);
        return;
      }
      if (fn.length === 1) {
        try {
          fn.call(server3, done);
        } catch (error2) {
          done(error2);
        }
        return;
      }
      try {
        const ret = fn.call(server3);
        if (ret && typeof ret.then === "function") {
          ret.then(done, done);
          return;
        }
      } catch (error2) {
        err2 = error2;
      }
      done(err2);
    };
  }
}
function onListenHookRunner$1(server2) {
  const hooks2 = server2[kHooks$4].onListen;
  const hooksLen = hooks2.length;
  let i = 0;
  let c = 0;
  next();
  function next(err2) {
    err2 && server2.log.error(err2);
    if (i === hooksLen) {
      while (c < server2[kChildren$2].length) {
        const child = server2[kChildren$2][c++];
        onListenHookRunner$1(child);
      }
      return;
    }
    wrap2(hooks2[i++], server2, next);
  }
  async function wrap2(fn, server3, done) {
    if (fn.length === 1) {
      try {
        fn.call(server3, done);
      } catch (e) {
        done(e);
      }
      return;
    }
    try {
      const ret = fn.call(server3);
      if (ret && typeof ret.then === "function") {
        ret.then(done, done);
        return;
      }
      done();
    } catch (error2) {
      done(error2);
    }
  }
}
function hookRunnerGenerator(iterator) {
  return function hookRunner(functions, request2, reply2, cb) {
    let i = 0;
    function next(err2) {
      if (err2 || i === functions.length) {
        cb(err2, request2, reply2);
        return;
      }
      let result;
      try {
        result = iterator(functions[i++], request2, reply2, next);
      } catch (error2) {
        cb(error2, request2, reply2);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve() {
      next();
    }
    function handleReject(err2) {
      if (!err2) {
        err2 = new FST_ERR_SEND_UNDEFINED_ERR();
      }
      cb(err2, request2, reply2);
    }
    next();
  };
}
function onResponseHookIterator(fn, request2, reply2, next) {
  return fn(request2, reply2, next);
}
const onResponseHookRunner$1 = hookRunnerGenerator(onResponseHookIterator);
const preValidationHookRunner = hookRunnerGenerator(hookIterator);
const preHandlerHookRunner$1 = hookRunnerGenerator(hookIterator);
const onTimeoutHookRunner$1 = hookRunnerGenerator(hookIterator);
const onRequestHookRunner$1 = hookRunnerGenerator(hookIterator);
function onSendHookRunner$1(functions, request2, reply2, payload, cb) {
  let i = 0;
  function next(err2, newPayload) {
    if (err2) {
      cb(err2, request2, reply2, payload);
      return;
    }
    if (newPayload !== void 0) {
      payload = newPayload;
    }
    if (i === functions.length) {
      cb(null, request2, reply2, payload);
      return;
    }
    let result;
    try {
      result = functions[i++](request2, reply2, payload, next);
    } catch (error2) {
      cb(error2, request2, reply2);
      return;
    }
    if (result && typeof result.then === "function") {
      result.then(handleResolve, handleReject);
    }
  }
  function handleResolve(newPayload) {
    next(null, newPayload);
  }
  function handleReject(err2) {
    if (!err2) {
      err2 = new FST_ERR_SEND_UNDEFINED_ERR();
    }
    cb(err2, request2, reply2, payload);
  }
  next();
}
const preSerializationHookRunner$1 = onSendHookRunner$1;
function preParsingHookRunner$1(functions, request2, reply2, cb) {
  let i = 0;
  function next(err2, newPayload) {
    if (reply2.sent) {
      return;
    }
    if (newPayload !== void 0) {
      request2[kRequestPayloadStream$1] = newPayload;
    }
    if (err2 || i === functions.length) {
      cb(err2, request2, reply2);
      return;
    }
    let result;
    try {
      result = functions[i++](request2, reply2, request2[kRequestPayloadStream$1], next);
    } catch (error2) {
      cb(error2, request2, reply2);
      return;
    }
    if (result && typeof result.then === "function") {
      result.then(handleResolve, handleReject);
    }
  }
  function handleResolve(newPayload) {
    next(null, newPayload);
  }
  function handleReject(err2) {
    if (!err2) {
      err2 = new FST_ERR_SEND_UNDEFINED_ERR();
    }
    cb(err2, request2, reply2);
  }
  next();
}
function onRequestAbortHookRunner$1(functions, request2, cb) {
  let i = 0;
  function next(err2) {
    if (err2 || i === functions.length) {
      cb(err2, request2);
      return;
    }
    let result;
    try {
      result = functions[i++](request2, next);
    } catch (error2) {
      cb(error2, request2);
      return;
    }
    if (result && typeof result.then === "function") {
      result.then(handleResolve, handleReject);
    }
  }
  function handleResolve() {
    next();
  }
  function handleReject(err2) {
    if (!err2) {
      err2 = new FST_ERR_SEND_UNDEFINED_ERR();
    }
    cb(err2, request2);
  }
  next();
}
function hookIterator(fn, request2, reply2, next) {
  if (reply2.sent === true) return void 0;
  return fn(request2, reply2, next);
}
var hooks = {
  Hooks: Hooks$1,
  buildHooks: buildHooks$1,
  preParsingHookRunner: preParsingHookRunner$1,
  onResponseHookRunner: onResponseHookRunner$1,
  onSendHookRunner: onSendHookRunner$1,
  preSerializationHookRunner: preSerializationHookRunner$1,
  onRequestAbortHookRunner: onRequestAbortHookRunner$1,
  hookRunnerApplication: hookRunnerApplication$1,
  onListenHookRunner: onListenHookRunner$1,
  preHandlerHookRunner: preHandlerHookRunner$1,
  preValidationHookRunner,
  onRequestHookRunner: onRequestHookRunner$1,
  onTimeoutHookRunner: onTimeoutHookRunner$1,
  lifecycleHooks: lifecycleHooks$2,
  supportedHooks: supportedHooks$1
};
const http$4 = require$$0$4;
const https$3 = require$$1;
const dns = require$$2;
const os$1 = require$$3$1;
const { kState: kState$2, kOptions: kOptions$5, kServerBindings: kServerBindings$1 } = symbols$1;
const { FSTWRN003 } = warnings;
const { onListenHookRunner } = hooks;
const {
  FST_ERR_HTTP2_INVALID_VERSION,
  FST_ERR_REOPENED_CLOSE_SERVER: FST_ERR_REOPENED_CLOSE_SERVER$1,
  FST_ERR_REOPENED_SERVER,
  FST_ERR_LISTEN_OPTIONS_INVALID
} = errorsExports;
server.createServer = createServer$1;
function defaultResolveServerListeningText(address) {
  return `Server listening at ${address}`;
}
function createServer$1(options, httpHandler) {
  const server2 = getServerInstance(options, httpHandler);
  function listen(listenOptions = { port: 0, host: "localhost" }, cb = void 0) {
    if (typeof cb === "function") {
      if (cb.constructor.name === "AsyncFunction") {
        FSTWRN003("listen method");
      }
      listenOptions.cb = cb;
    }
    if (listenOptions.signal) {
      if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
        throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
      }
      if (listenOptions.signal.aborted) {
        this.close();
      } else {
        const onAborted = () => {
          this.close();
        };
        listenOptions.signal.addEventListener("abort", onAborted, { once: true });
      }
    }
    let host;
    if (listenOptions.path == null) {
      host = listenOptions.host ?? "localhost";
    } else {
      host = listenOptions.host;
    }
    if (!Object.hasOwn(listenOptions, "host") || listenOptions.host == null) {
      listenOptions.host = host;
    }
    if (host === "localhost") {
      listenOptions.cb = (err2, address) => {
        if (err2) {
          cb(err2, address);
          return;
        }
        multipleBindings.call(this, server2, httpHandler, options, listenOptions, () => {
          this[kState$2].listening = true;
          cb(null, address);
          onListenHookRunner(this);
        });
      };
    } else {
      listenOptions.cb = (err2, address) => {
        if (err2) {
          cb(err2, address);
          return;
        }
        this[kState$2].listening = true;
        cb(null, address);
        onListenHookRunner(this);
      };
    }
    if (cb === void 0) {
      const listening = listenPromise.call(this, server2, listenOptions);
      return listening.then((address) => {
        return new Promise((resolve2, reject) => {
          if (host === "localhost") {
            multipleBindings.call(this, server2, httpHandler, options, listenOptions, () => {
              this[kState$2].listening = true;
              resolve2(address);
              onListenHookRunner(this);
            });
          } else {
            resolve2(address);
            onListenHookRunner(this);
          }
        });
      });
    }
    this.ready(listenCallback.call(this, server2, listenOptions));
  }
  return { server: server2, listen };
}
function multipleBindings(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
  this[kState$2].listening = false;
  dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
    if (dnsErr) {
      onListen();
      return;
    }
    const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
    let binding = 0;
    let bound = 0;
    if (!isMainServerListening) {
      const primaryAddress = mainServer.address();
      for (const adr of addresses) {
        if (adr.address !== primaryAddress.address) {
          binding++;
          const secondaryOpts = Object.assign({}, listenOptions, {
            host: adr.address,
            port: primaryAddress.port,
            cb: (_ignoreErr) => {
              bound++;
              if (!_ignoreErr) {
                this[kServerBindings$1].push(secondaryServer);
              }
              if (bound === binding) {
                onListen();
              }
            }
          });
          const secondaryServer = getServerInstance(serverOpts, httpHandler);
          const closeSecondary = () => {
            secondaryServer.close(() => {
            });
            if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections === true) {
              secondaryServer.closeAllConnections();
            }
          };
          secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
          mainServer.on("unref", closeSecondary);
          mainServer.on("close", closeSecondary);
          mainServer.on("error", closeSecondary);
          this[kState$2].listening = false;
          listenCallback.call(this, secondaryServer, secondaryOpts)();
        }
      }
    }
    if (binding === 0) {
      onListen();
      return;
    }
    const originUnref = mainServer.unref;
    mainServer.unref = function() {
      originUnref.call(mainServer);
      mainServer.emit("unref");
    };
  });
}
function listenCallback(server2, listenOptions) {
  const wrap2 = (err2) => {
    server2.removeListener("error", wrap2);
    server2.removeListener("listening", wrap2);
    if (!err2) {
      const address = logServerAddress.call(this, server2, listenOptions.listenTextResolver || defaultResolveServerListeningText);
      listenOptions.cb(null, address);
    } else {
      this[kState$2].listening = false;
      listenOptions.cb(err2, null);
    }
  };
  return (err2) => {
    if (err2 != null) return listenOptions.cb(err2);
    if (this[kState$2].listening && this[kState$2].closing) {
      return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER$1(), null);
    } else if (this[kState$2].listening) {
      return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null);
    }
    server2.once("error", wrap2);
    if (!this[kState$2].closing) {
      server2.once("listening", wrap2);
      server2.listen(listenOptions);
      this[kState$2].listening = true;
    }
  };
}
function listenPromise(server2, listenOptions) {
  if (this[kState$2].listening && this[kState$2].closing) {
    return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER$1());
  } else if (this[kState$2].listening) {
    return Promise.reject(new FST_ERR_REOPENED_SERVER());
  }
  return this.ready().then(() => {
    let errEventHandler;
    let listeningEventHandler;
    function cleanup() {
      server2.removeListener("error", errEventHandler);
      server2.removeListener("listening", listeningEventHandler);
    }
    const errEvent = new Promise((resolve2, reject) => {
      errEventHandler = (err2) => {
        cleanup();
        this[kState$2].listening = false;
        reject(err2);
      };
      server2.once("error", errEventHandler);
    });
    const listeningEvent = new Promise((resolve2, reject) => {
      listeningEventHandler = () => {
        cleanup();
        this[kState$2].listening = true;
        resolve2(logServerAddress.call(this, server2, listenOptions.listenTextResolver || defaultResolveServerListeningText));
      };
      server2.once("listening", listeningEventHandler);
    });
    server2.listen(listenOptions);
    return Promise.race([
      errEvent,
      // e.g invalid port range error is always emitted before the server listening
      listeningEvent
    ]);
  });
}
function getServerInstance(options, httpHandler) {
  let server2 = null;
  const httpsOptions = options.https === true ? {} : options.https;
  if (options.serverFactory) {
    server2 = options.serverFactory(httpHandler, options);
  } else if (options.http2) {
    if (typeof httpsOptions === "object") {
      server2 = http2().createSecureServer(httpsOptions, httpHandler);
    } else {
      server2 = http2().createServer(httpHandler);
    }
    server2.on("session", sessionTimeout(options.http2SessionTimeout));
  } else {
    if (httpsOptions) {
      server2 = https$3.createServer(httpsOptions, httpHandler);
    } else {
      server2 = http$4.createServer(options.http, httpHandler);
    }
    server2.keepAliveTimeout = options.keepAliveTimeout;
    server2.requestTimeout = options.requestTimeout;
    if (options.maxRequestsPerSocket > 0) {
      server2.maxRequestsPerSocket = options.maxRequestsPerSocket;
    }
  }
  if (!options.serverFactory) {
    server2.setTimeout(options.connectionTimeout);
  }
  return server2;
}
function getAddresses(address) {
  if (address.address === "0.0.0.0") {
    return Object.values(os$1.networkInterfaces()).flatMap((iface) => {
      return iface.filter((iface2) => iface2.family === "IPv4");
    }).sort((iface) => {
      return iface.internal ? -1 : 1;
    }).map((iface) => {
      return iface.address;
    });
  }
  return [address.address];
}
function logServerAddress(server2, listenTextResolver) {
  let addresses;
  const isUnixSocket = typeof server2.address() === "string";
  if (!isUnixSocket) {
    if (server2.address().address.indexOf(":") === -1) {
      addresses = getAddresses(server2.address()).map((address) => address + ":" + server2.address().port);
    } else {
      addresses = ["[" + server2.address().address + "]:" + server2.address().port];
    }
    addresses = addresses.map((address) => "http" + (this[kOptions$5].https ? "s" : "") + "://" + address);
  } else {
    addresses = [server2.address()];
  }
  for (const address of addresses) {
    this.log.info(listenTextResolver(address));
  }
  return addresses[0];
}
function http2() {
  try {
    return require("node:http2");
  } catch (err2) {
    throw new FST_ERR_HTTP2_INVALID_VERSION();
  }
}
function sessionTimeout(timeout) {
  return function(session) {
    session.setTimeout(timeout, close);
  };
}
function close() {
  this.close();
}
var reply = { exports: {} };
var handleRequest$1 = { exports: {} };
const {
  kSchemaHeaders: headersSchema,
  kSchemaParams: paramsSchema,
  kSchemaQuerystring: querystringSchema,
  kSchemaBody: bodySchema,
  kSchemaResponse: responseSchema
} = symbols$1;
const scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;
const {
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
} = errorsExports;
const { FSTWRN001 } = warnings;
function compileSchemasForSerialization$1(context2, compile2) {
  if (!context2.schema || !context2.schema.response) {
    return;
  }
  const { method, url: url2 } = context2.config || {};
  context2[responseSchema] = Object.keys(context2.schema.response).reduce(function(acc, statusCode) {
    const schema2 = context2.schema.response[statusCode];
    statusCode = statusCode.toLowerCase();
    if (!scChecker.test(statusCode)) {
      throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX();
    }
    if (schema2.content) {
      const contentTypesSchemas = {};
      for (const mediaName of Object.keys(schema2.content)) {
        const contentSchema = schema2.content[mediaName].schema;
        contentTypesSchemas[mediaName] = compile2({
          schema: contentSchema,
          url: url2,
          method,
          httpStatus: statusCode,
          contentType: mediaName
        });
      }
      acc[statusCode] = contentTypesSchemas;
    } else {
      acc[statusCode] = compile2({
        schema: schema2,
        url: url2,
        method,
        httpStatus: statusCode
      });
    }
    return acc;
  }, {});
}
function compileSchemasForValidation$1(context2, compile2, isCustom) {
  const { schema: schema2 } = context2;
  if (!schema2) {
    return;
  }
  const { method, url: url2 } = context2.config || {};
  const headers2 = schema2.headers;
  if (headers2 && (isCustom || Object.getPrototypeOf(headers2) !== Object.prototype)) {
    context2[headersSchema] = compile2({ schema: headers2, method, url: url2, httpPart: "headers" });
  } else if (headers2) {
    const headersSchemaLowerCase = {};
    Object.keys(headers2).forEach((k) => {
      headersSchemaLowerCase[k] = headers2[k];
    });
    if (headersSchemaLowerCase.required instanceof Array) {
      headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
    }
    if (headers2.properties) {
      headersSchemaLowerCase.properties = {};
      Object.keys(headers2.properties).forEach((k) => {
        headersSchemaLowerCase.properties[k.toLowerCase()] = headers2.properties[k];
      });
    }
    context2[headersSchema] = compile2({ schema: headersSchemaLowerCase, method, url: url2, httpPart: "headers" });
  } else if (Object.hasOwn(schema2, "headers")) {
    FSTWRN001("headers", method, url2);
  }
  if (schema2.body) {
    const contentProperty = schema2.body.content;
    if (contentProperty) {
      const contentTypeSchemas = {};
      for (const contentType of Object.keys(contentProperty)) {
        const contentSchema = contentProperty[contentType].schema;
        contentTypeSchemas[contentType] = compile2({ schema: contentSchema, method, url: url2, httpPart: "body", contentType });
      }
      context2[bodySchema] = contentTypeSchemas;
    } else {
      context2[bodySchema] = compile2({ schema: schema2.body, method, url: url2, httpPart: "body" });
    }
  } else if (Object.hasOwn(schema2, "body")) {
    FSTWRN001("body", method, url2);
  }
  if (schema2.querystring) {
    context2[querystringSchema] = compile2({ schema: schema2.querystring, method, url: url2, httpPart: "querystring" });
  } else if (Object.hasOwn(schema2, "querystring")) {
    FSTWRN001("querystring", method, url2);
  }
  if (schema2.params) {
    context2[paramsSchema] = compile2({ schema: schema2.params, method, url: url2, httpPart: "params" });
  } else if (Object.hasOwn(schema2, "params")) {
    FSTWRN001("params", method, url2);
  }
}
function validateParam(validatorFunction, request2, paramName) {
  const isUndefined2 = request2[paramName] === void 0;
  const ret = validatorFunction && validatorFunction(isUndefined2 ? null : request2[paramName]);
  if (ret && typeof ret.then === "function") {
    return ret.then((res2) => {
      return answer(res2);
    }).catch((err2) => {
      return err2;
    });
  }
  return answer(ret);
  function answer(ret2) {
    if (ret2 === false) return validatorFunction.errors;
    if (ret2 && ret2.error) return ret2.error;
    if (ret2 && ret2.value) request2[paramName] = ret2.value;
    return false;
  }
}
function validate$3(context2, request2, execution) {
  var _a2;
  const runExecution = execution === void 0;
  if (runExecution || !execution.skipParams) {
    const params = validateParam(context2[paramsSchema], request2, "params");
    if (params) {
      if (typeof params.then !== "function") {
        return wrapValidationError(params, "params", context2.schemaErrorFormatter);
      } else {
        return validateAsyncParams(params, context2, request2);
      }
    }
  }
  if (runExecution || !execution.skipBody) {
    let validatorFunction = null;
    if (typeof context2[bodySchema] === "function") {
      validatorFunction = context2[bodySchema];
    } else if (context2[bodySchema]) {
      const contentType = (_a2 = request2.headers["content-type"]) == null ? void 0 : _a2.split(";", 1)[0];
      const contentSchema = context2[bodySchema][contentType];
      if (contentSchema) {
        validatorFunction = contentSchema;
      }
    }
    const body = validateParam(validatorFunction, request2, "body");
    if (body) {
      if (typeof body.then !== "function") {
        return wrapValidationError(body, "body", context2.schemaErrorFormatter);
      } else {
        return validateAsyncBody(body, context2, request2);
      }
    }
  }
  if (runExecution || !execution.skipQuery) {
    const query = validateParam(context2[querystringSchema], request2, "query");
    if (query) {
      if (typeof query.then !== "function") {
        return wrapValidationError(query, "querystring", context2.schemaErrorFormatter);
      } else {
        return validateAsyncQuery(query, context2, request2);
      }
    }
  }
  const headers2 = validateParam(context2[headersSchema], request2, "headers");
  if (headers2) {
    if (typeof headers2.then !== "function") {
      return wrapValidationError(headers2, "headers", context2.schemaErrorFormatter);
    } else {
      return validateAsyncHeaders(headers2, context2);
    }
  }
  return false;
}
function validateAsyncParams(validatePromise, context2, request2) {
  return validatePromise.then((paramsResult) => {
    if (paramsResult) {
      return wrapValidationError(paramsResult, "params", context2.schemaErrorFormatter);
    }
    return validate$3(context2, request2, { skipParams: true });
  });
}
function validateAsyncBody(validatePromise, context2, request2) {
  return validatePromise.then((bodyResult) => {
    if (bodyResult) {
      return wrapValidationError(bodyResult, "body", context2.schemaErrorFormatter);
    }
    return validate$3(context2, request2, { skipParams: true, skipBody: true });
  });
}
function validateAsyncQuery(validatePromise, context2, request2) {
  return validatePromise.then((queryResult) => {
    if (queryResult) {
      return wrapValidationError(queryResult, "querystring", context2.schemaErrorFormatter);
    }
    return validate$3(context2, request2, { skipParams: true, skipBody: true, skipQuery: true });
  });
}
function validateAsyncHeaders(validatePromise, context2, request2) {
  return validatePromise.then((headersResult) => {
    if (headersResult) {
      return wrapValidationError(headersResult, "headers", context2.schemaErrorFormatter);
    }
    return false;
  });
}
function wrapValidationError(result, dataVar, schemaErrorFormatter) {
  if (result instanceof Error) {
    result.statusCode = result.statusCode || 400;
    result.code = result.code || "FST_ERR_VALIDATION";
    result.validationContext = result.validationContext || dataVar;
    return result;
  }
  const error2 = schemaErrorFormatter(result, dataVar);
  error2.statusCode = error2.statusCode || 400;
  error2.code = error2.code || "FST_ERR_VALIDATION";
  error2.validation = result;
  error2.validationContext = dataVar;
  return error2;
}
var validation$2 = {
  compileSchemasForValidation: compileSchemasForValidation$1,
  compileSchemasForSerialization: compileSchemasForSerialization$1,
  validate: validate$3
};
const {
  kReplyIsError: kReplyIsError$2,
  kReplyHijacked: kReplyHijacked$1
} = symbols$1;
const diagnostics$1 = require$$1$1;
const channels = diagnostics$1.tracingChannel("fastify.request.handler");
function wrapThenable$1(thenable, reply2, store) {
  if (store) store.async = true;
  thenable.then(function(payload) {
    if (reply2[kReplyHijacked$1] === true) {
      return;
    }
    if (store) {
      channels.asyncStart.publish(store);
    }
    try {
      if (payload !== void 0 || //
      reply2.sent === false && //
      reply2.raw.headersSent === false && reply2.request.raw.aborted === false && reply2.request.socket && !reply2.request.socket.destroyed) {
        try {
          reply2.send(payload);
        } catch (err2) {
          reply2[kReplyIsError$2] = true;
          reply2.send(err2);
        }
      }
    } finally {
      if (store) {
        channels.asyncEnd.publish(store);
      }
    }
  }, function(err2) {
    if (store) {
      store.error = err2;
      channels.error.publish(store);
      channels.asyncStart.publish(store);
    }
    try {
      if (reply2.sent === true) {
        reply2.log.error({ err: err2 }, "Promise errored, but reply.sent = true was set");
        return;
      }
      reply2[kReplyIsError$2] = true;
      reply2.send(err2);
    } catch (err3) {
      reply2.send(err3);
    } finally {
      if (store) {
        channels.asyncEnd.publish(store);
      }
    }
  });
}
var wrapThenable_1 = wrapThenable$1;
(function(module) {
  const diagnostics2 = require$$1$1;
  const { validate: validateSchema } = validation$2;
  const { preValidationHookRunner: preValidationHookRunner2, preHandlerHookRunner: preHandlerHookRunner2 } = hooks;
  const wrapThenable2 = wrapThenable_1;
  const {
    kReplyIsError: kReplyIsError2,
    kRouteContext: kRouteContext2,
    kFourOhFourContext: kFourOhFourContext2,
    kSupportedHTTPMethods: kSupportedHTTPMethods2
  } = symbols$1;
  const channels2 = diagnostics2.tracingChannel("fastify.request.handler");
  function handleRequest2(err2, request2, reply2) {
    if (reply2.sent === true) return;
    if (err2 != null) {
      reply2[kReplyIsError2] = true;
      reply2.send(err2);
      return;
    }
    const method = request2.raw.method;
    const headers2 = request2.headers;
    const context2 = request2[kRouteContext2];
    if (this[kSupportedHTTPMethods2].bodyless.has(method)) {
      handler(request2, reply2);
      return;
    }
    if (this[kSupportedHTTPMethods2].bodywith.has(method)) {
      const contentType = headers2["content-type"];
      const contentLength = headers2["content-length"];
      const transferEncoding = headers2["transfer-encoding"];
      if (contentType === void 0) {
        if ((contentLength === void 0 || contentLength === "0") && transferEncoding === void 0) {
          handler(request2, reply2);
        } else {
          context2.contentTypeParser.run("", handler, request2, reply2);
        }
      } else {
        if (contentLength === void 0 && transferEncoding === void 0 && method === "OPTIONS") {
          handler(request2, reply2);
          return;
        }
        context2.contentTypeParser.run(contentType, handler, request2, reply2);
      }
      return;
    }
    handler(request2, reply2);
  }
  function handler(request2, reply2) {
    try {
      if (request2[kRouteContext2].preValidation !== null) {
        preValidationHookRunner2(
          request2[kRouteContext2].preValidation,
          request2,
          reply2,
          preValidationCallback
        );
      } else {
        preValidationCallback(null, request2, reply2);
      }
    } catch (err2) {
      preValidationCallback(err2, request2, reply2);
    }
  }
  function preValidationCallback(err2, request2, reply2) {
    if (reply2.sent === true) return;
    if (err2 != null) {
      reply2[kReplyIsError2] = true;
      reply2.send(err2);
      return;
    }
    const validationErr = validateSchema(reply2[kRouteContext2], request2);
    const isAsync = validationErr && typeof validationErr.then === "function" || false;
    if (isAsync) {
      const cb = validationCompleted.bind(null, request2, reply2);
      validationErr.then(cb, cb);
    } else {
      validationCompleted(request2, reply2, validationErr);
    }
  }
  function validationCompleted(request2, reply2, validationErr) {
    if (validationErr) {
      if (reply2[kRouteContext2].attachValidation === false) {
        reply2.send(validationErr);
        return;
      }
      reply2.request.validationError = validationErr;
    }
    if (request2[kRouteContext2].preHandler !== null) {
      preHandlerHookRunner2(
        request2[kRouteContext2].preHandler,
        request2,
        reply2,
        preHandlerCallback
      );
    } else {
      preHandlerCallback(null, request2, reply2);
    }
  }
  function preHandlerCallback(err2, request2, reply2) {
    if (reply2.sent) return;
    const context2 = request2[kRouteContext2];
    if (!channels2.hasSubscribers || context2[kFourOhFourContext2] === null) {
      preHandlerCallbackInner(err2, request2, reply2);
    } else {
      const store = {
        request: request2,
        reply: reply2,
        async: false,
        route: {
          url: context2.config.url,
          method: context2.config.method
        }
      };
      channels2.start.runStores(store, preHandlerCallbackInner, void 0, err2, request2, reply2, store);
    }
  }
  function preHandlerCallbackInner(err2, request2, reply2, store) {
    const context2 = request2[kRouteContext2];
    try {
      if (err2 != null) {
        reply2[kReplyIsError2] = true;
        reply2.send(err2);
        if (store) {
          store.error = err2;
          channels2.error.publish(store);
        }
        return;
      }
      let result;
      try {
        result = context2.handler(request2, reply2);
      } catch (err3) {
        if (store) {
          store.error = err3;
          channels2.error.publish(store);
        }
        reply2[kReplyIsError2] = true;
        reply2.send(err3);
        return;
      }
      if (result !== void 0) {
        if (result !== null && typeof result.then === "function") {
          wrapThenable2(result, reply2, store);
        } else {
          reply2.send(result);
        }
      }
    } finally {
      if (store) channels2.end.publish(store);
    }
  }
  module.exports = handleRequest2;
  module.exports[Symbol.for("internals")] = { handler, preHandlerCallback };
})(handleRequest$1);
var handleRequestExports = handleRequest$1.exports;
var abstractLogging = { exports: {} };
abstractLogging.exports;
var hasRequiredAbstractLogging;
function requireAbstractLogging() {
  if (hasRequiredAbstractLogging) return abstractLogging.exports;
  hasRequiredAbstractLogging = 1;
  (function(module) {
    function noop2() {
    }
    const proto2 = {
      fatal: noop2,
      error: noop2,
      warn: noop2,
      info: noop2,
      debug: noop2,
      trace: noop2
    };
    Object.defineProperty(module, "exports", {
      get() {
        return Object.create(proto2);
      }
    });
  })(abstractLogging);
  return abstractLogging.exports;
}
var pino = { exports: {} };
var errHelpers;
var hasRequiredErrHelpers;
function requireErrHelpers() {
  if (hasRequiredErrHelpers) return errHelpers;
  hasRequiredErrHelpers = 1;
  const isErrorLike = (err2) => {
    return err2 && typeof err2.message === "string";
  };
  const getErrorCause = (err2) => {
    if (!err2) return;
    const cause = err2.cause;
    if (typeof cause === "function") {
      const causeResult = err2.cause();
      return isErrorLike(causeResult) ? causeResult : void 0;
    } else {
      return isErrorLike(cause) ? cause : void 0;
    }
  };
  const _stackWithCauses = (err2, seen) => {
    if (!isErrorLike(err2)) return "";
    const stack = err2.stack || "";
    if (seen.has(err2)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  const stackWithCauses = (err2) => _stackWithCauses(err2, /* @__PURE__ */ new Set());
  const _messageWithCauses = (err2, seen, skip2) => {
    if (!isErrorLike(err2)) return "";
    const message = skip2 ? "" : err2.message || "";
    if (seen.has(err2)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      const skipIfVErrorStyleCause = typeof err2.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  const messageWithCauses = (err2) => _messageWithCauses(err2, /* @__PURE__ */ new Set());
  errHelpers = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
  return errHelpers;
}
var errProto;
var hasRequiredErrProto;
function requireErrProto() {
  if (hasRequiredErrProto) return errProto;
  hasRequiredErrProto = 1;
  const seen = Symbol("circular-ref-tag");
  const rawSymbol = Symbol("pino-raw-err-ref");
  const pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    message: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    stack: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  errProto = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
  return errProto;
}
var err;
var hasRequiredErr;
function requireErr() {
  if (hasRequiredErr) return err;
  hasRequiredErr = 1;
  err = errSerializer;
  const { messageWithCauses, stackWithCauses, isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString: toString4 } = Object.prototype;
  function errSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString4.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = messageWithCauses(err2);
    _err.stack = stackWithCauses(err2);
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errSerializer(err3));
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return err;
}
var errWithCause;
var hasRequiredErrWithCause;
function requireErrWithCause() {
  if (hasRequiredErrWithCause) return errWithCause;
  hasRequiredErrWithCause = 1;
  errWithCause = errWithCauseSerializer;
  const { isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString: toString4 } = Object.prototype;
  function errWithCauseSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString4.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = err2.message;
    _err.stack = err2.stack;
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errWithCauseSerializer(err3));
    }
    if (isErrorLike(err2.cause) && !Object.prototype.hasOwnProperty.call(err2.cause, seen)) {
      _err.cause = errWithCauseSerializer(err2.cause);
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return errWithCause;
}
var req;
var hasRequiredReq;
function requireReq() {
  if (hasRequiredReq) return req;
  hasRequiredReq = 1;
  req = {
    mapHttpRequest,
    reqSerializer
  };
  const rawSymbol = Symbol("pino-raw-req-ref");
  const pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function reqSerializer(req2) {
    const connection = req2.info || req2.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req2.id === "function" ? req2.id() : req2.id || (req2.info ? req2.info.id : void 0);
    _req.method = req2.method;
    if (req2.originalUrl) {
      _req.url = req2.originalUrl;
    } else {
      const path2 = req2.path;
      _req.url = typeof path2 === "string" ? path2 : req2.url ? req2.url.path || req2.url : void 0;
    }
    if (req2.query) {
      _req.query = req2.query;
    }
    if (req2.params) {
      _req.params = req2.params;
    }
    _req.headers = req2.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req2.raw || req2;
    return _req;
  }
  function mapHttpRequest(req2) {
    return {
      req: reqSerializer(req2)
    };
  }
  return req;
}
var res;
var hasRequiredRes;
function requireRes() {
  if (hasRequiredRes) return res;
  hasRequiredRes = 1;
  res = {
    mapHttpResponse,
    resSerializer
  };
  const rawSymbol = Symbol("pino-raw-res-ref");
  const pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function resSerializer(res2) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res2.headersSent ? res2.statusCode : null;
    _res.headers = res2.getHeaders ? res2.getHeaders() : res2._headers;
    _res.raw = res2;
    return _res;
  }
  function mapHttpResponse(res2) {
    return {
      res: resSerializer(res2)
    };
  }
  return res;
}
var pinoStdSerializers;
var hasRequiredPinoStdSerializers;
function requirePinoStdSerializers() {
  if (hasRequiredPinoStdSerializers) return pinoStdSerializers;
  hasRequiredPinoStdSerializers = 1;
  const errSerializer = requireErr();
  const errWithCauseSerializer = requireErrWithCause();
  const reqSerializers = requireReq();
  const resSerializers = requireRes();
  pinoStdSerializers = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer) return customSerializer;
      return function wrapErrSerializer(err2) {
        return customSerializer(errSerializer(err2));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
      return function wrappedReqSerializer(req2) {
        return customSerializer(reqSerializers.reqSerializer(req2));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer) return customSerializer;
      return function wrappedResSerializer(res2) {
        return customSerializer(resSerializers.resSerializer(res2));
      };
    }
  };
  return pinoStdSerializers;
}
var caller;
var hasRequiredCaller;
function requireCaller() {
  if (hasRequiredCaller) return caller;
  hasRequiredCaller = 1;
  function noOpPrepareStackTrace(_, stack) {
    return stack;
  }
  caller = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return void 0;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
  return caller;
}
var validator_1;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator_1;
  hasRequiredValidator = 1;
  validator_1 = validator2;
  function validator2(opts = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH = (s) => `fast-redact – Invalid path (${s})`
    } = opts;
    return function validate2({ paths }) {
      paths.forEach((s) => {
        if (typeof s !== "string") {
          throw Error(ERR_PATHS_MUST_BE_STRINGS());
        }
        try {
          if (/〇/.test(s)) throw Error();
          const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "〇").replace(/\.\*/g, ".〇").replace(/\[\*\]/g, "[〇]");
          if (/\n|\r|;/.test(expr)) throw Error();
          if (/\/\*/.test(expr)) throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const 〇 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
        } catch (e) {
          throw Error(ERR_INVALID_PATH(s));
        }
      });
    };
  }
  return validator_1;
}
var rx;
var hasRequiredRx;
function requireRx() {
  if (hasRequiredRx) return rx;
  hasRequiredRx = 1;
  rx = /[^.[\]]+|\[((?:.)*?)\]/g;
  return rx;
}
var parse_1$2;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1$2;
  hasRequiredParse = 1;
  const rx2 = requireRx();
  parse_1$2 = parse2;
  function parse2({ paths }) {
    const wildcards = [];
    var wcLen = 0;
    const secret = paths.reduce(function(o, strPath, ix) {
      var path2 = strPath.match(rx2).map((p) => p.replace(/'|"|`/g, ""));
      const leadingBracket = strPath[0] === "[";
      path2 = path2.map((p) => {
        if (p[0] === "[") return p.substr(1, p.length - 2);
        else return p;
      });
      const star = path2.indexOf("*");
      if (star > -1) {
        const before = path2.slice(0, star);
        const beforeStr = before.join(".");
        const after = path2.slice(star + 1, path2.length);
        const nested = after.length > 0;
        wcLen++;
        wildcards.push({
          before,
          beforeStr,
          after,
          nested
        });
      } else {
        o[strPath] = {
          path: path2,
          val: void 0,
          precensored: false,
          circle: "",
          escPath: JSON.stringify(strPath),
          leadingBracket
        };
      }
      return o;
    }, {});
    return { wildcards, wcLen, secret };
  }
  return parse_1$2;
}
var redactor_1;
var hasRequiredRedactor;
function requireRedactor() {
  if (hasRequiredRedactor) return redactor_1;
  hasRequiredRedactor = 1;
  const rx2 = requireRx();
  redactor_1 = redactor;
  function redactor({ secret, serialize: serialize2, wcLen, strict, isCensorFct, censorFctTakesPath }, state2) {
    const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize2)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize2)}
  `).bind(state2);
    redact.state = state2;
    if (serialize2 === false) {
      redact.restore = (o) => state2.restore(o);
    }
    return redact;
  }
  function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
    return Object.keys(secret).map((path2) => {
      const { escPath, leadingBracket, path: arrPath } = secret[path2];
      const skip2 = leadingBracket ? 1 : 0;
      const delim = leadingBracket ? "" : ".";
      const hops = [];
      var match;
      while ((match = rx2.exec(path2)) !== null) {
        const [, ix] = match;
        const { index, input } = match;
        if (index > skip2) hops.push(input.substring(0, index - (ix ? 0 : 1)));
      }
      var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
      if (existence.length === 0) existence += `o${delim}${path2} != null`;
      else existence += ` && o${delim}${path2} != null`;
      const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
      const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
      return `
      if (${existence}) {
        const val = o${delim}${path2}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path2} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
    }).join("\n");
  }
  function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
    return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
  }
  function resultTmpl(serialize2) {
    return serialize2 === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
  function strictImpl(strict, serialize2) {
    return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize2 === false ? `return o` : `return this.serialize(o)`;
  }
  return redactor_1;
}
var modifiers;
var hasRequiredModifiers;
function requireModifiers() {
  if (hasRequiredModifiers) return modifiers;
  hasRequiredModifiers = 1;
  modifiers = {
    groupRedact,
    groupRestore,
    nestedRedact,
    nestedRestore
  };
  function groupRestore({ keys: keys2, values: values2, target }) {
    if (target == null || typeof target === "string") return;
    const length = keys2.length;
    for (var i = 0; i < length; i++) {
      const k = keys2[i];
      target[k] = values2[i];
    }
  }
  function groupRedact(o, path2, censor, isCensorFct, censorFctTakesPath) {
    const target = get2(o, path2);
    if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
    const keys2 = Object.keys(target);
    const keysLength = keys2.length;
    const pathLength = path2.length;
    const pathWithKey = censorFctTakesPath ? [...path2] : void 0;
    const values2 = new Array(keysLength);
    for (var i = 0; i < keysLength; i++) {
      const key = keys2[i];
      values2[i] = target[key];
      if (censorFctTakesPath) {
        pathWithKey[pathLength] = key;
        target[key] = censor(target[key], pathWithKey);
      } else if (isCensorFct) {
        target[key] = censor(target[key]);
      } else {
        target[key] = censor;
      }
    }
    return { keys: keys2, values: values2, target, flat: true };
  }
  function nestedRestore(instructions) {
    for (let i = 0; i < instructions.length; i++) {
      const { target, path: path2, value } = instructions[i];
      let current = target;
      for (let i2 = path2.length - 1; i2 > 0; i2--) {
        current = current[path2[i2]];
      }
      current[path2[0]] = value;
    }
  }
  function nestedRedact(store, o, path2, ns, censor, isCensorFct, censorFctTakesPath) {
    const target = get2(o, path2);
    if (target == null) return;
    const keys2 = Object.keys(target);
    const keysLength = keys2.length;
    for (var i = 0; i < keysLength; i++) {
      const key = keys2[i];
      specialSet(store, target, key, path2, ns, censor, isCensorFct, censorFctTakesPath);
    }
    return store;
  }
  function has2(obj, prop) {
    return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
  }
  function specialSet(store, o, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath) {
    const afterPathLen = afterPath.length;
    const lastPathIndex = afterPathLen - 1;
    const originalKey = k;
    var i = -1;
    var n;
    var nv;
    var ov;
    var wc = null;
    var kIsWc;
    var wcov;
    var consecutive = false;
    var level = 0;
    var depth = 0;
    var redactPathCurrent = tree();
    ov = n = o[k];
    if (typeof n !== "object") return;
    while (n != null && ++i < afterPathLen) {
      depth += 1;
      k = afterPath[i];
      if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
        break;
      }
      if (k === "*") {
        if (wc === "*") {
          consecutive = true;
        }
        wc = k;
        if (i !== lastPathIndex) {
          continue;
        }
      }
      if (wc) {
        const wcKeys = Object.keys(n);
        for (var j = 0; j < wcKeys.length; j++) {
          const wck = wcKeys[j];
          wcov = n[wck];
          kIsWc = k === "*";
          if (consecutive) {
            redactPathCurrent = node2(redactPathCurrent, wck, depth);
            level = i;
            ov = iterateNthLevel(wcov, level - 1, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
          } else {
            if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
              if (kIsWc) {
                ov = wcov;
              } else {
                ov = wcov[k];
              }
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
              if (kIsWc) {
                const rv = restoreInstr(node2(redactPathCurrent, wck, depth), ov, o[originalKey]);
                store.push(rv);
                n[wck] = nv;
              } else {
                if (wcov[k] === nv) ;
                else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) {
                  redactPathCurrent = node2(redactPathCurrent, wck, depth);
                } else {
                  redactPathCurrent = node2(redactPathCurrent, wck, depth);
                  const rv = restoreInstr(node2(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                  store.push(rv);
                  wcov[k] = nv;
                }
              }
            }
          }
        }
        wc = null;
      } else {
        ov = n[k];
        redactPathCurrent = node2(redactPathCurrent, k, depth);
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
        if (has2(n, k) && nv === ov || nv === void 0 && censor !== void 0) ;
        else {
          const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
          store.push(rv);
          n[k] = nv;
        }
        n = n[k];
      }
      if (typeof n !== "object") break;
    }
  }
  function get2(o, p) {
    var i = -1;
    var l = p.length;
    var n = o;
    while (n != null && ++i < l) {
      n = n[p[i]];
    }
    return n;
  }
  function iterateNthLevel(wcov, level, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
    if (level === 0) {
      if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
        if (kIsWc) {
          ov = wcov;
        } else {
          ov = wcov[k];
        }
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
        if (kIsWc) {
          const rv = restoreInstr(redactPathCurrent, ov, parent);
          store.push(rv);
          n[wck] = nv;
        } else {
          if (wcov[k] === nv) ;
          else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) ;
          else {
            const rv = restoreInstr(node2(redactPathCurrent, k, depth + 1), ov, parent);
            store.push(rv);
            wcov[k] = nv;
          }
        }
      }
    }
    for (const key in wcov) {
      if (typeof wcov[key] === "object") {
        redactPathCurrent = node2(redactPathCurrent, key, depth);
        iterateNthLevel(wcov[key], level - 1, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
      }
    }
  }
  function tree() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
  function node2(parent, key, depth) {
    if (parent.depth === depth) {
      return node2(parent.parent, key, depth);
    }
    var child = {
      parent,
      key,
      depth,
      children: []
    };
    parent.children.push(child);
    return child;
  }
  function restoreInstr(node3, value, target) {
    let current = node3;
    const path2 = [];
    do {
      path2.push(current.key);
      current = current.parent;
    } while (current.parent != null);
    return { path: path2, value, target };
  }
  return modifiers;
}
var restorer_1;
var hasRequiredRestorer;
function requireRestorer() {
  if (hasRequiredRestorer) return restorer_1;
  hasRequiredRestorer = 1;
  const { groupRestore, nestedRestore } = requireModifiers();
  restorer_1 = restorer;
  function restorer() {
    return function compileRestore() {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
      const { secret, wcLen } = this;
      const paths = Object.keys(secret);
      const resetters = resetTmpl(secret, paths);
      const hasWildcards = wcLen > 0;
      const state2 = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
      this.restore = Function(
        "o",
        restoreTmpl(resetters, paths, hasWildcards)
      ).bind(state2);
      this.restore.state = state2;
    };
  }
  function resetTmpl(secret, paths) {
    return paths.map((path2) => {
      const { circle, escPath, leadingBracket } = secret[path2];
      const delim = leadingBracket ? "" : ".";
      const reset2 = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path2} = secret[${escPath}].val`;
      const clear = `secret[${escPath}].val = undefined`;
      return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset2} } catch (e) {}
        ${clear}
      }
    `;
    }).join("");
  }
  function restoreTmpl(resetters, paths, hasWildcards) {
    const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
    return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
  }
  return restorer_1;
}
var state_1$1;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state_1$1;
  hasRequiredState = 1;
  state_1$1 = state2;
  function state2(o) {
    const {
      secret,
      censor,
      compileRestore,
      serialize: serialize2,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    } = o;
    const builder = [{ secret, censor, compileRestore }];
    if (serialize2 !== false) builder.push({ serialize: serialize2 });
    if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
    return Object.assign(...builder);
  }
  return state_1$1;
}
var fastRedact_1;
var hasRequiredFastRedact;
function requireFastRedact() {
  if (hasRequiredFastRedact) return fastRedact_1;
  hasRequiredFastRedact = 1;
  const validator2 = requireValidator();
  const parse2 = requireParse();
  const redactor = requireRedactor();
  const restorer = requireRestorer();
  const { groupRedact, nestedRedact } = requireModifiers();
  const state2 = requireState();
  const rx2 = requireRx();
  const validate2 = validator2();
  const noop2 = (o) => o;
  noop2.restore = noop2;
  const DEFAULT_CENSOR = "[REDACTED]";
  fastRedact.rx = rx2;
  fastRedact.validator = validator2;
  fastRedact_1 = fastRedact;
  function fastRedact(opts = {}) {
    const paths = Array.from(new Set(opts.paths || []));
    const serialize2 = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
    const remove2 = opts.remove;
    if (remove2 === true && serialize2 !== JSON.stringify) {
      throw Error("fast-redact – remove option may only be set when serializer is JSON.stringify");
    }
    const censor = remove2 === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
    const isCensorFct = typeof censor === "function";
    const censorFctTakesPath = isCensorFct && censor.length > 1;
    if (paths.length === 0) return serialize2 || noop2;
    validate2({ paths, serialize: serialize2, censor });
    const { wildcards, wcLen, secret } = parse2({ paths, censor });
    const compileRestore = restorer();
    const strict = "strict" in opts ? opts.strict : true;
    return redactor({ secret, wcLen, serialize: serialize2, strict, isCensorFct, censorFctTakesPath }, state2({
      secret,
      censor,
      compileRestore,
      serialize: serialize2,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    }));
  }
  return fastRedact_1;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  const setLevelSym = Symbol("pino.setLevel");
  const getLevelSym = Symbol("pino.getLevel");
  const levelValSym = Symbol("pino.levelVal");
  const levelCompSym = Symbol("pino.levelComp");
  const useLevelLabelsSym = Symbol("pino.useLevelLabels");
  const useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  const mixinSym = Symbol("pino.mixin");
  const lsCacheSym = Symbol("pino.lsCache");
  const chindingsSym = Symbol("pino.chindings");
  const asJsonSym = Symbol("pino.asJson");
  const writeSym = Symbol("pino.write");
  const redactFmtSym = Symbol("pino.redactFmt");
  const timeSym = Symbol("pino.time");
  const timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  const streamSym = Symbol("pino.stream");
  const stringifySym = Symbol("pino.stringify");
  const stringifySafeSym = Symbol("pino.stringifySafe");
  const stringifiersSym = Symbol("pino.stringifiers");
  const endSym = Symbol("pino.end");
  const formatOptsSym = Symbol("pino.formatOpts");
  const messageKeySym = Symbol("pino.messageKey");
  const errorKeySym = Symbol("pino.errorKey");
  const nestedKeySym = Symbol("pino.nestedKey");
  const nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  const mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  const msgPrefixSym = Symbol("pino.msgPrefix");
  const wildcardFirstSym = Symbol("pino.wildcardFirst");
  const serializersSym = Symbol.for("pino.serializers");
  const formattersSym = Symbol.for("pino.formatters");
  const hooksSym = Symbol.for("pino.hooks");
  const needsMetadataGsym = Symbol.for("pino.metadata");
  symbols = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
  return symbols;
}
var redaction_1;
var hasRequiredRedaction;
function requireRedaction() {
  if (hasRequiredRedaction) return redaction_1;
  hasRequiredRedaction = 1;
  const fastRedact = requireFastRedact();
  const { redactFmtSym, wildcardFirstSym } = requireSymbols();
  const { rx: rx2, validator: validator2 } = fastRedact;
  const validate2 = validator2({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino – redacted paths must be strings",
    ERR_INVALID_PATH: (s) => `pino – redact paths array contains an invalid path (${s})`
  });
  const CENSOR = "[Redacted]";
  const strict = false;
  function redaction(opts, serialize2) {
    const { paths, censor } = handle(opts);
    const shape = paths.reduce((o, str2) => {
      rx2.lastIndex = 0;
      const first = rx2.exec(str2);
      const next = rx2.exec(str2);
      let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o[ns] = null;
        return o;
      }
      if (o[ns] === null) {
        return o;
      }
      const { index } = next;
      const nextPath = `${str2.substr(index, str2.length - 1)}`;
      o[ns] = o[ns] || [];
      if (ns !== wildcardFirstSym && o[ns].length === 0) {
        o[ns].push(...o[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o).forEach(function(k) {
          if (o[k]) {
            o[k].push(nextPath);
          }
        });
      }
      o[ns].push(nextPath);
      return o;
    }, {});
    const result = {
      [redactFmtSym]: fastRedact({ paths, censor, serialize: serialize2, strict })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize2(censor(...args)) : serialize2(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
      if (shape[k] === null) {
        o[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path2) => {
          return censor(value, [k, ...path2]);
        } : censor;
        o[k] = fastRedact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize: serialize2,
          strict
        });
      }
      return o;
    }, result);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      validate2(opts);
      return opts;
    }
    let { paths, censor = CENSOR, remove: remove2 } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino – redact must contain an array of strings");
    }
    if (remove2 === true) censor = void 0;
    validate2({ paths, censor });
    return { paths, censor };
  }
  redaction_1 = redaction;
  return redaction_1;
}
var time;
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime) return time;
  hasRequiredTime = 1;
  const nullTime = () => "";
  const epochTime = () => `,"time":${Date.now()}`;
  const unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
  const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  time = { nullTime, epochTime, unixTime, isoTime };
  return time;
}
var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function tryStringify(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = format2;
  function format2(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === "object" && f !== null) {
      var len = args.length + offset;
      if (len === 1) return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index = 1; index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args.length;
    if (argLen === 0) return f;
    var str2 = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0; i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          case 111:
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === void 0) break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            var type2 = typeof args[a];
            if (type2 === "string") {
              str2 += "'" + args[a] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type2 === "function") {
              str2 += args[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str2 += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += String(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str2 += f.slice(lastPos);
    }
    return str2;
  }
  return quickFormatUnescaped;
}
var atomicSleep = { exports: {} };
var hasRequiredAtomicSleep;
function requireAtomicSleep() {
  if (hasRequiredAtomicSleep) return atomicSleep.exports;
  hasRequiredAtomicSleep = 1;
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms2) {
      const valid2 = ms2 > 0 && ms2 < Infinity;
      if (valid2 === false) {
        if (typeof ms2 !== "number" && typeof ms2 !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms2));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    atomicSleep.exports = sleep;
  } else {
    let sleep = function(ms2) {
      const valid2 = ms2 > 0 && ms2 < Infinity;
      if (valid2 === false) {
        if (typeof ms2 !== "number" && typeof ms2 !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
    };
    atomicSleep.exports = sleep;
  }
  return atomicSleep.exports;
}
var sonicBoom;
var hasRequiredSonicBoom;
function requireSonicBoom() {
  if (hasRequiredSonicBoom) return sonicBoom;
  hasRequiredSonicBoom = 1;
  const fs2 = fs$k;
  const EventEmitter2 = require$$1$3;
  const inherits2 = require$$1$2.inherits;
  const path2 = path$n;
  const sleep = requireAtomicSleep();
  const assert2 = require$$5;
  const BUSY_WRITE_TIMEOUT = 100;
  const kEmptyBuffer = Buffer.allocUnsafe(0);
  const MAX_WRITE = 16 * 1024;
  const kContentModeBuffer = "buffer";
  const kContentModeUtf8 = "utf8";
  const [major2, minor2] = (process.versions.node || "0.0").split(".").map(Number);
  const kCopyBuffer = major2 >= 22 && minor2 >= 7;
  function openFile(file2, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err2, fd) {
      if (err2) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err2);
            }
          });
        } else {
          sonic.emit("error", err2);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file2;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir) fs2.mkdirSync(path2.dirname(file2), { recursive: true });
        const fd = fs2.openSync(file2, flags, mode);
        fileOpened(null, fd);
      } catch (err2) {
        fileOpened(err2);
        throw err2;
      }
    } else if (sonic.mkdir) {
      fs2.mkdir(path2.dirname(file2), { recursive: true }, (err2) => {
        if (err2) return fileOpened(err2);
        fs2.open(file2, flags, mode, fileOpened);
      });
    } else {
      fs2.open(file2, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append: append2 = true, mkdir: mkdir2, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = void 0;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append2 || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir2 || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err2, n) => {
      if (err2) {
        if ((err2.code === "EAGAIN" || err2.code === "EBUSY") && this.retryEAGAIN(err2, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(void 0, 0);
            } catch (err3) {
              this.release(err3);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err2);
        }
        return;
      }
      this.emit("write", n);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n2 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err3) {
          this.release(err3);
          return;
        }
      }
      if (this._fsync) {
        fs2.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
      n = Buffer.from(writingBuf).subarray(0, n).toString().length;
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.slice(n);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners) return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  inherits2(SonicBoom, EventEmitter2);
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs2.fsync(this.fd, (err2) => {
            this._flushPending = false;
            cb(err2);
          });
        } catch (err2) {
          cb(err2);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err2) => {
      this._flushPending = false;
      cb(err2);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error2 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error2);
        return;
      }
      throw error2;
    }
    if (this.minLength <= 0) {
      cb == null ? void 0 : cb();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error2 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error2);
        return;
      }
      throw error2;
    }
    if (this.minLength <= 0) {
      cb == null ? void 0 : cb();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  SonicBoom.prototype.reopen = function(file2) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file2);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file2) {
      this.file = file2;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs2.close(fd, (err2) => {
          if (err2) {
            return this.emit("error", err2);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n = fs2.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs2.fsyncSync(this.fd);
    } catch {
    }
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n = fs2.writeSync(this.fd, buf);
        buf = buf.subarray(n);
        this._len = Math.max(this._len - n, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      fs2.write(this.fd, this._writingBuf, "utf8", release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs2.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== void 0) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert2(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs2.fsync(sonic.fd, closeWrapped);
    } catch {
    }
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs2.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err2) {
      if (err2) {
        sonic.emit("error", err2);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  sonicBoom = SonicBoom;
  return sonicBoom;
}
var onExitLeakFree;
var hasRequiredOnExitLeakFree;
function requireOnExitLeakFree() {
  if (hasRequiredOnExitLeakFree) return onExitLeakFree;
  hasRequiredOnExitLeakFree = 1;
  const refs = {
    exit: [],
    beforeExit: []
  };
  const functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  let registry;
  function ensureRegistry() {
    if (registry === void 0) {
      registry = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry = void 0;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref2 of refs[event]) {
      const obj = ref2.deref();
      const fn = ref2.fn;
      if (obj !== void 0) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref2) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref2);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn) {
    if (obj === void 0) {
      throw new Error("the object can't be undefined");
    }
    install(event);
    const ref2 = new WeakRef(obj);
    ref2.fn = fn;
    ensureRegistry();
    registry.register(obj, ref2);
    refs[event].push(ref2);
  }
  function register(obj, fn) {
    _register("exit", obj, fn);
  }
  function registerBeforeExit(obj, fn) {
    _register("beforeExit", obj, fn);
  }
  function unregister(obj) {
    if (registry === void 0) {
      return;
    }
    registry.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref2) => {
        const _obj = ref2.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  onExitLeakFree = {
    register,
    registerBeforeExit,
    unregister
  };
  return onExitLeakFree;
}
const version$1 = "3.1.0";
const require$$0$1 = {
  version: version$1
};
var wait_1;
var hasRequiredWait;
function requireWait() {
  if (hasRequiredWait) return wait_1;
  hasRequiredWait = 1;
  const MAX_TIMEOUT = 1e3;
  function wait(state2, index, expected, timeout, done) {
    const max2 = Date.now() + timeout;
    let current = Atomics.load(state2, index);
    if (current === expected) {
      done(null, "ok");
      return;
    }
    let prior = current;
    const check = (backoff) => {
      if (Date.now() > max2) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current;
          current = Atomics.load(state2, index);
          if (current === prior) {
            check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          } else {
            if (current === expected) done(null, "ok");
            else done(null, "not-equal");
          }
        }, backoff);
      }
    };
    check(1);
  }
  function waitDiff(state2, index, expected, timeout, done) {
    const max2 = Date.now() + timeout;
    let current = Atomics.load(state2, index);
    if (current !== expected) {
      done(null, "ok");
      return;
    }
    const check = (backoff) => {
      if (Date.now() > max2) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current = Atomics.load(state2, index);
          if (current !== expected) {
            done(null, "ok");
          } else {
            check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          }
        }, backoff);
      }
    };
    check(1);
  }
  wait_1 = { wait, waitDiff };
  return wait_1;
}
var indexes;
var hasRequiredIndexes;
function requireIndexes() {
  if (hasRequiredIndexes) return indexes;
  hasRequiredIndexes = 1;
  const WRITE_INDEX = 4;
  const READ_INDEX = 8;
  indexes = {
    WRITE_INDEX,
    READ_INDEX
  };
  return indexes;
}
var threadStream;
var hasRequiredThreadStream;
function requireThreadStream() {
  if (hasRequiredThreadStream) return threadStream;
  hasRequiredThreadStream = 1;
  const { version: version2 } = require$$0$1;
  const { EventEmitter: EventEmitter2 } = require$$1$3;
  const { Worker } = require$$2$1;
  const { join } = path$n;
  const { pathToFileURL } = require$$0$5;
  const { wait } = requireWait();
  const {
    WRITE_INDEX,
    READ_INDEX
  } = requireIndexes();
  const buffer = require$$7;
  const assert2 = require$$5;
  const kImpl = Symbol("kImpl");
  const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }
  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  const FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : commonjsGlobal.FinalizationRegistry || FakeFinalizationRegistry;
  const WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : commonjsGlobal.WeakRef || FakeWeakRef;
  const registry = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });
  function createWorker(stream2, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream2[kImpl].dataBuf,
        stateBuf: stream2[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version2
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream2);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry.register(stream2, worker);
    return worker;
  }
  function drain(stream2) {
    assert2(!stream2[kImpl].sync);
    if (stream2[kImpl].needDrain) {
      stream2[kImpl].needDrain = false;
      stream2.emit("drain");
    }
  }
  function nextFlush(stream2) {
    const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    let leftover = stream2[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream2[kImpl].buf.length === 0) {
        stream2[kImpl].flushing = false;
        if (stream2[kImpl].ending) {
          end(stream2);
        } else if (stream2[kImpl].needDrain) {
          process.nextTick(drain, stream2);
        }
        return;
      }
      let toWrite = stream2[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, nextFlush.bind(null, stream2));
      } else {
        stream2.flush(() => {
          if (stream2.destroyed) {
            return;
          }
          Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream2[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream2[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
          write(stream2, toWrite, nextFlush.bind(null, stream2));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream2[kImpl].buf.length === 0) {
        return;
      }
      stream2.flush(() => {
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream2);
      });
    } else {
      destroy2(stream2, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream2 = this.stream.deref();
    if (stream2 === void 0) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream2);
        stream2.flush(() => {
          stream2[kImpl].ready = true;
          stream2.emit("ready");
        });
        break;
      case "ERROR":
        destroy2(stream2, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream2.emit(msg.name, ...msg.args);
        } else {
          stream2.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy2(stream2, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code2) {
    const stream2 = this.stream.deref();
    if (stream2 === void 0) {
      return;
    }
    registry.unregister(stream2);
    stream2.worker.exited = true;
    stream2.worker.off("exit", onWorkerExit);
    destroy2(stream2, code2 !== 0 ? new Error("the worker thread exited") : null);
  }
  class ThreadStream extends EventEmitter2 {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message, transferList) => {
        this.worker.postMessage(message, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error2(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error2(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err2) {
          destroy2(this, err2);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err2) {
          destroy2(this, err2);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err2, res2) => {
        if (err2) {
          destroy2(this, err2);
          process.nextTick(cb, err2);
          return;
        }
        if (res2 === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  function error2(stream2, err2) {
    setImmediate(() => {
      stream2.emit("error", err2);
    });
  }
  function destroy2(stream2, err2) {
    if (stream2[kImpl].destroyed) {
      return;
    }
    stream2[kImpl].destroyed = true;
    if (err2) {
      stream2[kImpl].errored = err2;
      error2(stream2, err2);
    }
    if (!stream2.worker.exited) {
      stream2.worker.terminate().catch(() => {
      }).then(() => {
        stream2[kImpl].closed = true;
        stream2.emit("close");
      });
    } else {
      setImmediate(() => {
        stream2[kImpl].closed = true;
        stream2.emit("close");
      });
    }
  }
  function write(stream2, data, cb) {
    const current = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream2[kImpl].data.write(data, current);
    Atomics.store(stream2[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream2) {
    if (stream2[kImpl].ended || !stream2[kImpl].ending || stream2[kImpl].flushing) {
      return;
    }
    stream2[kImpl].ended = true;
    try {
      stream2.flushSync();
      let readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
      Atomics.store(stream2[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1e3);
        readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy2(stream2, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy2(stream2, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream2[kImpl].finished = true;
        stream2.emit("finish");
      });
    } catch (err2) {
      destroy2(stream2, err2);
    }
  }
  function writeSync(stream2) {
    const cb = () => {
      if (stream2[kImpl].ending) {
        end(stream2);
      } else if (stream2[kImpl].needDrain) {
        process.nextTick(drain, stream2);
      }
    };
    stream2[kImpl].flushing = false;
    while (stream2[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
      let leftover = stream2[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream2);
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream2[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, cb);
      } else {
        flushSync(stream2);
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream2[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream2[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, cb);
      }
    }
  }
  function flushSync(stream2) {
    if (stream2[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1e3);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  threadStream = ThreadStream;
  return threadStream;
}
var transport_1;
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return transport_1;
  hasRequiredTransport = 1;
  const { createRequire: createRequire2 } = require$$0$6;
  const getCallers = requireCaller();
  const { join, isAbsolute, sep } = path$o;
  const sleep = requireAtomicSleep();
  const onExit = requireOnExitLeakFree();
  const ThreadStream = requireThreadStream();
  function setupOnExit(stream2) {
    onExit.register(stream2, autoEnd);
    onExit.registerBeforeExit(stream2, flush);
    stream2.on("close", function() {
      onExit.unregister(stream2);
    });
  }
  function buildStream(filename, workerData, workerOpts, sync) {
    const stream2 = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream2.on("ready", onReady);
    stream2.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream2.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream2);
      }
    }
    function onExit2() {
      if (stream2.closed) {
        return;
      }
      stream2.flushSync();
      sleep(100);
      stream2.end();
    }
    return stream2;
  }
  function autoEnd(stream2) {
    stream2.ref();
    stream2.flushSync();
    stream2.end();
    stream2.once("close", function() {
      stream2.unref();
    });
  }
  function flush(stream2) {
    stream2.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline, targets, levels: levels2, dedupe, worker = {}, caller: caller2 = getCallers(), sync = false } = fullOptions;
    const options = {
      ...fullOptions.options
    };
    const callers = typeof caller2 === "string" ? [caller2] : caller2;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t2) => {
          return {
            ...t2,
            level: dest.level,
            // duplicate the pipeline `level` property defined in the upper level
            target: fixTarget(t2.target)
          };
        });
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options.pipelines = [pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels2) {
      options.levels = levels2;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options, worker, sync);
    function fixTarget(origin2) {
      origin2 = bundlerOverrides[origin2] || origin2;
      if (isAbsolute(origin2) || origin2.indexOf("file://") === 0) {
        return origin2;
      }
      if (origin2 === "pino/file") {
        return join(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context2 = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire2(context2).resolve(origin2);
          break;
        } catch (err2) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin2}"`);
      }
      return fixTarget2;
    }
  }
  transport_1 = transport;
  return transport_1;
}
var tools;
var hasRequiredTools;
function requireTools() {
  if (hasRequiredTools) return tools;
  hasRequiredTools = 1;
  const format2 = requireQuickFormatUnescaped();
  const { mapHttpRequest, mapHttpResponse } = requirePinoStdSerializers();
  const SonicBoom = requireSonicBoom();
  const onExit = requireOnExitLeakFree();
  const {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = requireSymbols();
  const { isMainThread } = require$$2$1;
  const transport = requireTransport();
  function noop2() {
  }
  function genLog(level, hook) {
    if (!hook) return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o, ...n) {
      if (typeof o === "object") {
        let msg = o;
        if (o !== null) {
          if (o.method && o.headers && o.socket) {
            o = mapHttpRequest(o);
          } else if (typeof o.setHeader === "function") {
            o = mapHttpResponse(o);
          }
        }
        let formatParams;
        if (msg === null && n.length === 0) {
          formatParams = [null];
        } else {
          msg = n.shift();
          formatParams = n;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o, format2(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o === void 0 ? n.shift() : o;
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format2(msg, n, this[formatOptsSym]), level);
      }
    }
  }
  function asString(str2) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l = str2.length;
    if (l > 100) {
      return JSON.stringify(str2);
    }
    for (var i = 0; i < l && point >= 32; i++) {
      point = str2.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str2.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str2;
    } else {
      result += str2.slice(last);
    }
    return point < 32 ? JSON.stringify(str2) : '"' + result + '"';
  }
  function asJson(obj, msg, num, time2) {
    const stringify22 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time2;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          case "boolean":
            if (stringifier) value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify22)(value, stringifySafe);
        }
        if (value === void 0) continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== void 0) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        case "boolean":
          if (stringifier) value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify22)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify22 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid2 = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
      if (valid2 === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify22)(value, stringifySafe);
        if (value === void 0) continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  }
  function hasBeenTampered(stream2) {
    return stream2.write !== stream2.constructor.prototype.write;
  }
  const hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function buildSafeSonicBoom(opts) {
    const stream2 = new SonicBoom(opts);
    stream2.on("error", filterBrokenPipe);
    if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
      onExit.register(stream2, autoEnd);
      stream2.on("close", function() {
        onExit.unregister(stream2);
      });
    }
    return stream2;
    function filterBrokenPipe(err2) {
      if (err2.code === "EPIPE") {
        stream2.write = noop2;
        stream2.end = noop2;
        stream2.flushSync = noop2;
        stream2.destroy = noop2;
        return;
      }
      stream2.removeListener("error", filterBrokenPipe);
      stream2.emit("error", err2);
    }
  }
  function autoEnd(stream2, eventName) {
    if (stream2.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream2.flush();
      stream2.on("drain", function() {
        stream2.end();
      });
    } else {
      stream2.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions2) {
    return function normalizeArgs(instance, caller2, opts = {}, stream2) {
      if (typeof opts === "string") {
        stream2 = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream2 === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream2 = buildSafeSonicBoom({ dest: stream2 });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream2 = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream2 = transport({ caller: caller2, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions2, opts);
      opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false) opts.level = "silent";
      if (!onChild) opts.onChild = noop2;
      if (!stream2) {
        if (!hasBeenTampered(process.stdout)) {
          stream2 = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream2 = process.stdout;
        }
      }
      return { opts, stream: stream2 };
    };
  }
  function stringify2(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify22 = stringifySafeFn || this[stringifySafeSym];
        return stringify22(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log) {
    return {
      level,
      bindings,
      log
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === void 0) {
      return 1;
    }
    return destination;
  }
  tools = {
    noop: noop2,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify: stringify2,
    buildFormatters,
    normalizeDestFileDescriptor
  };
  return tools;
}
var constants$4;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$4;
  hasRequiredConstants = 1;
  const DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  const SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  constants$4 = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
  return constants$4;
}
var levels;
var hasRequiredLevels;
function requireLevels() {
  if (hasRequiredLevels) return levels;
  hasRequiredLevels = 1;
  const {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = requireSymbols();
  const { noop: noop2, genLog } = requireTools();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants();
  const levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream2 = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream2.flushSync === "function") {
          try {
            stream2.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
    o[DEFAULT_LEVELS[k]] = k;
    return o;
  }, {});
  const initialLsCache = Object.keys(nums).reduce((o, k) => {
    o[k] = '{"level":' + Number(k);
    return o;
  }, {});
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values: values2 } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === void 0) throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values2[level] === void 0) throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values2[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values2) {
      if (levelComparison(values2[key], levelVal) === false) {
        this[key] = noop2;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values2[key], hook);
    }
    this.emit(
      "level-change",
      level,
      levelVal,
      labels[preLevelVal],
      preLevelVal,
      this
    );
  }
  function getLevel(level) {
    const { levels: levels2, levelVal } = this;
    return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values: values2 } = this.levels;
    const logLevelVal = values2[logLevel];
    return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
      o[customLevels[k]] = k;
      return o;
    }, {}) : null;
    const labels = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      useOnlyCustomLevels ? null : nums,
      customNums
    );
    const values2 = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    return { labels, values: values2 };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values2 = [].concat(
        Object.keys(customLevels || {}).map((key) => customLevels[key]),
        useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
        Infinity
      );
      if (!values2.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels2, customLevels) {
    const { labels, values: values2 } = levels2;
    for (const k in customLevels) {
      if (k in values2) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  levels = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
  return levels;
}
var meta;
var hasRequiredMeta;
function requireMeta() {
  if (hasRequiredMeta) return meta;
  hasRequiredMeta = 1;
  meta = { version: "9.6.0" };
  return meta;
}
var proto;
var hasRequiredProto;
function requireProto() {
  if (hasRequiredProto) return proto;
  hasRequiredProto = 1;
  const { EventEmitter: EventEmitter2 } = require$$0$3;
  const {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    parsedChindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = requireSymbols();
  const {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = requireLevels();
  const {
    asChindings,
    asJson,
    buildFormatters,
    stringify: stringify2
  } = requireTools();
  const {
    version: version2
  } = requireMeta();
  const redaction = requireRedaction();
  const constructor = class Pino {
  };
  const prototype2 = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version: version2,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n) {
      throw Error("levelVal is read-only");
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype2, EventEmitter2.prototype);
  proto = function() {
    return Object.create(prototype2);
  };
  const resetChildingsFormatter = (bindings2) => bindings2;
  function child(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    options = options || {};
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = /* @__PURE__ */ Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0; i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0; bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log } = options.formatters;
      instance[formattersSym] = buildFormatters(
        level || formatters.level,
        chindings || resetChildingsFormatter,
        log || formatters.log
      );
    } else {
      instance[formattersSym] = buildFormatters(
        formatters.level,
        resetChildingsFormatter,
        formatters.log
      );
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify2);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify2;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    const childLevel = options.level || this.level;
    instance[setLevelSym](childLevel);
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
    delete this[parsedChindingsSym];
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t2 = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === void 0 || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === void 0) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t2);
    const stream2 = this[streamSym];
    if (stream2[needsMetadataGsym] === true) {
      stream2.lastLevel = num;
      stream2.lastObj = obj;
      stream2.lastMsg = msg;
      stream2.lastTime = t2.slice(this[timeSliceIndexSym]);
      stream2.lastLogger = this;
    }
    stream2.write(streamWriteHook ? streamWriteHook(s) : s);
  }
  function noop2() {
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream2 = this[streamSym];
    if (typeof stream2.flush === "function") {
      stream2.flush(cb || noop2);
    } else if (cb) cb();
  }
  return proto;
}
var safeStableStringify = { exports: {} };
var hasRequiredSafeStableStringify;
function requireSafeStableStringify() {
  if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
  hasRequiredSafeStableStringify = 1;
  (function(module, exports) {
    const { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    const stringify2 = configure();
    stringify2.configure = configure;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports.stringify = stringify2;
    exports.configure = configure;
    module.exports = stringify2;
    const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str2) {
      if (str2.length < 5e3 && !strEscapeSequencesRegExp.test(str2)) {
        return `"${str2}"`;
      }
      return JSON.stringify(str2);
    }
    function sort2(array, comparator2) {
      if (array.length > 200 || comparator2) {
        return array.sort(comparator2);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res2 = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res2 += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res2;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty2.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty2.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty2.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator2 = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys2 = sort2(keys2, comparator2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res2 = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res3 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res3 += tmp2 !== void 0 ? tmp2 : "null";
                res3 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res3 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res3 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res3 += `
${originalIndentation}`;
              stack.pop();
              return `[${res3}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res2 = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, join, maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys2 = sort2(keys2, comparator2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, ",", maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys2 = sort2(keys2, comparator2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify3(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify3;
    }
  })(safeStableStringify, safeStableStringify.exports);
  return safeStableStringify.exports;
}
var multistream_1;
var hasRequiredMultistream;
function requireMultistream() {
  if (hasRequiredMultistream) return multistream_1;
  hasRequiredMultistream = 1;
  const metadata2 = Symbol.for("pino.metadata");
  const { DEFAULT_LEVELS } = requireConstants();
  const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  function multistream(streamsArray, opts) {
    let counter = 0;
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res2 = {
      write,
      add,
      emit,
      flushSync,
      end,
      minLevel: 0,
      streams: [],
      clone: clone2,
      [metadata2]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res2);
    } else {
      add.call(res2, streamsArray);
    }
    streamsArray = null;
    return res2;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream2;
      for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream2 = dest.stream;
          if (stream2[metadata2]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream2.lastLevel = level;
            stream2.lastTime = lastTime;
            stream2.lastMsg = lastMsg;
            stream2.lastObj = lastObj;
            stream2.lastLogger = lastLogger;
          }
          stream2.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit(...args) {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.emit === "function") {
          stream2.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.flushSync === "function") {
          stream2.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res2;
      }
      const isStream2 = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream2) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: void 0,
        id: counter++
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res2;
    }
    function end() {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.flushSync === "function") {
          stream2.flushSync();
        }
        stream2.end();
      }
    }
    function clone2(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0; i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        minLevel: level,
        streams,
        clone: clone2,
        emit,
        flushSync,
        [metadata2]: true
      };
    }
  }
  function compareByLevel(a, b) {
    return a.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  }
  function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  }
  multistream_1 = multistream;
  return multistream_1;
}
var hasRequiredPino;
function requirePino() {
  if (hasRequiredPino) return pino.exports;
  hasRequiredPino = 1;
  const os2 = require$$3$1;
  const stdSerializers = requirePinoStdSerializers();
  const caller2 = requireCaller();
  const redaction = requireRedaction();
  const time2 = requireTime();
  const proto2 = requireProto();
  const symbols2 = requireSymbols();
  const { configure } = requireSafeStableStringify();
  const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = requireLevels();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants();
  const {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify: stringify2,
    normalizeDestFileDescriptor,
    noop: noop2
  } = requireTools();
  const { version: version2 } = requireMeta();
  const {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols2;
  const { epochTime, nullTime } = time2;
  const { pid } = process;
  const hostname = os2.hostname();
  const defaultErrorSerializer = stdSerializers.err;
  const defaultOptions2 = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number) {
        return { level: number };
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
    timestamp: epochTime,
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  const normalize2 = createArgsNormalizer(defaultOptions2);
  const serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
  function pino$1(...args) {
    const instance = {};
    const { opts, stream: stream2 } = normalize2(instance, caller2(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp: timestamp2,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks: hooks2,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(
      formatters.level,
      formatters.bindings,
      formatters.log
    );
    const stringifyFn = stringify2.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify2,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === void 0) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time3 = timestamp2 instanceof Function ? timestamp2 : timestamp2 ? epochTime : nullTime;
    const timeSliceIndex = time3().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels2 = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream2.emit === "function") {
      stream2.emit("message", { code: "PINO_CONFIG", config: { levels: levels2, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels: levels2,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream2,
      [timeSym]: time3,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify2,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      // protect against injection
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks2,
      silent: noop2,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto2());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  pino.exports = pino$1;
  pino.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  pino.exports.transport = requireTransport();
  pino.exports.multistream = requireMultistream();
  pino.exports.levels = mappings();
  pino.exports.stdSerializers = serializers;
  pino.exports.stdTimeFunctions = Object.assign({}, time2);
  pino.exports.symbols = symbols2;
  pino.exports.version = version2;
  pino.exports.default = pino$1;
  pino.exports.pino = pino$1;
  return pino.exports;
}
var loggerPino;
var hasRequiredLoggerPino;
function requireLoggerPino() {
  if (hasRequiredLoggerPino) return loggerPino;
  hasRequiredLoggerPino = 1;
  const pino2 = requirePino();
  const { serializersSym } = pino2.symbols;
  const {
    FST_ERR_LOG_INVALID_DESTINATION
  } = errorsExports;
  function createPinoLogger(opts) {
    if (opts.stream && opts.file) {
      throw new FST_ERR_LOG_INVALID_DESTINATION();
    } else if (opts.file) {
      opts.stream = pino2.destination(opts.file);
      delete opts.file;
    }
    const prevLogger = opts.logger;
    const prevGenReqId = opts.genReqId;
    let logger = null;
    if (prevLogger) {
      opts.logger = void 0;
      opts.genReqId = void 0;
      if (prevLogger[serializersSym]) {
        opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
      }
      logger = prevLogger.child({}, opts);
      opts.logger = prevLogger;
      opts.genReqId = prevGenReqId;
    } else {
      logger = pino2(opts, opts.stream);
    }
    return logger;
  }
  const serializers = {
    req: function asReqValue(req2) {
      return {
        method: req2.method,
        url: req2.url,
        version: req2.headers && req2.headers["accept-version"],
        host: req2.host,
        remoteAddress: req2.ip,
        remotePort: req2.socket ? req2.socket.remotePort : void 0
      };
    },
    err: pino2.stdSerializers.err,
    res: function asResValue(reply2) {
      return {
        statusCode: reply2.statusCode
      };
    }
  };
  loggerPino = {
    serializers,
    createPinoLogger
  };
  return loggerPino;
}
const {
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
  FST_ERR_LOG_INVALID_LOGGER_CONFIG,
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
  FST_ERR_LOG_INVALID_LOGGER
} = errorsExports;
function createChildLogger$3(context2, logger, req2, reqId, loggerOpts) {
  const loggerBindings = {
    [context2.requestIdLogLabel]: reqId
  };
  const child = context2.childLoggerFactory.call(context2.server, logger, loggerBindings, loggerOpts || {}, req2);
  if (context2.childLoggerFactory !== defaultChildLoggerFactory$1) {
    validateLogger(child, true);
  }
  return child;
}
function defaultChildLoggerFactory$1(logger, bindings, opts) {
  return logger.child(bindings, opts);
}
function validateLogger(logger, strict) {
  const methods2 = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
  const missingMethods = logger ? methods2.filter((method) => !logger[method] || typeof logger[method] !== "function") : methods2;
  if (!missingMethods.length) {
    return true;
  } else if (missingMethods.length === methods2.length && !strict) {
    return false;
  } else {
    throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
  }
}
function createLogger$1(options) {
  if (options.logger && options.loggerInstance) {
    throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED();
  }
  if (!options.loggerInstance && !options.logger) {
    const nullLogger = requireAbstractLogging();
    const logger2 = nullLogger;
    logger2.child = () => logger2;
    return { logger: logger2, hasLogger: false };
  }
  const { createPinoLogger, serializers } = requireLoggerPino();
  if (validateLogger(options.loggerInstance)) {
    const logger2 = createPinoLogger({
      logger: options.loggerInstance,
      serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
    });
    return { logger: logger2, hasLogger: true };
  }
  if (validateLogger(options.logger)) {
    throw FST_ERR_LOG_INVALID_LOGGER_CONFIG();
  }
  if (options.loggerInstance) {
    throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE();
  }
  const localLoggerOptions = {};
  if (Object.prototype.toString.call(options.logger) === "[object Object]") {
    Reflect.ownKeys(options.logger).forEach((prop) => {
      Object.defineProperty(localLoggerOptions, prop, {
        value: options.logger[prop],
        writable: true,
        enumerable: true,
        configurable: true
      });
    });
  }
  localLoggerOptions.level = localLoggerOptions.level || "info";
  localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
  options.logger = localLoggerOptions;
  const logger = createPinoLogger(options.logger);
  return { logger, hasLogger: true };
}
function now$1() {
  const ts = process.hrtime();
  return ts[0] * 1e3 + ts[1] / 1e6;
}
var loggerFactory = {
  createChildLogger: createChildLogger$3,
  defaultChildLoggerFactory: defaultChildLoggerFactory$1,
  createLogger: createLogger$1,
  now: now$1
};
var rfdc_1 = rfdc;
function copyBuffer(cur) {
  if (cur instanceof Buffer) {
    return Buffer.from(cur);
  }
  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
}
function rfdc(opts) {
  opts = opts || {};
  if (opts.circles) return rfdcCircles(opts);
  const constructorHandlers = /* @__PURE__ */ new Map();
  constructorHandlers.set(Date, (o) => new Date(o));
  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
  if (opts.constructorHandlers) {
    for (const handler2 of opts.constructorHandlers) {
      constructorHandlers.set(handler2[0], handler2[1]);
    }
  }
  let handler = null;
  return opts.proto ? cloneProto : clone2;
  function cloneArray(a, fn) {
    const keys2 = Object.keys(a);
    const a2 = new Array(keys2.length);
    for (let i = 0; i < keys2.length; i++) {
      const k = keys2[i];
      const cur = a[k];
      if (typeof cur !== "object" || cur === null) {
        a2[k] = cur;
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        a2[k] = handler(cur, fn);
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur);
      } else {
        a2[k] = fn(cur);
      }
    }
    return a2;
  }
  function clone2(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, clone2);
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, clone2);
    }
    const o2 = {};
    for (const k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue;
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, clone2);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        o2[k] = clone2(cur);
      }
    }
    return o2;
  }
  function cloneProto(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, cloneProto);
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, cloneProto);
    }
    const o2 = {};
    for (const k in o) {
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, cloneProto);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        o2[k] = cloneProto(cur);
      }
    }
    return o2;
  }
}
function rfdcCircles(opts) {
  const refs = [];
  const refsNew = [];
  const constructorHandlers = /* @__PURE__ */ new Map();
  constructorHandlers.set(Date, (o) => new Date(o));
  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
  if (opts.constructorHandlers) {
    for (const handler2 of opts.constructorHandlers) {
      constructorHandlers.set(handler2[0], handler2[1]);
    }
  }
  let handler = null;
  return opts.proto ? cloneProto : clone2;
  function cloneArray(a, fn) {
    const keys2 = Object.keys(a);
    const a2 = new Array(keys2.length);
    for (let i = 0; i < keys2.length; i++) {
      const k = keys2[i];
      const cur = a[k];
      if (typeof cur !== "object" || cur === null) {
        a2[k] = cur;
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        a2[k] = handler(cur, fn);
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur);
      } else {
        const index = refs.indexOf(cur);
        if (index !== -1) {
          a2[k] = refsNew[index];
        } else {
          a2[k] = fn(cur);
        }
      }
    }
    return a2;
  }
  function clone2(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, clone2);
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, clone2);
    }
    const o2 = {};
    refs.push(o);
    refsNew.push(o2);
    for (const k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue;
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, clone2);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        const i = refs.indexOf(cur);
        if (i !== -1) {
          o2[k] = refsNew[i];
        } else {
          o2[k] = clone2(cur);
        }
      }
    }
    refs.pop();
    refsNew.pop();
    return o2;
  }
  function cloneProto(o) {
    if (typeof o !== "object" || o === null) return o;
    if (Array.isArray(o)) return cloneArray(o, cloneProto);
    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
      return handler(o, cloneProto);
    }
    const o2 = {};
    refs.push(o);
    refsNew.push(o2);
    for (const k in o) {
      const cur = o[k];
      if (typeof cur !== "object" || cur === null) {
        o2[k] = cur;
      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
        o2[k] = handler(cur, cloneProto);
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        const i = refs.indexOf(cur);
        if (i !== -1) {
          o2[k] = refsNew[i];
        } else {
          o2[k] = cloneProto(cur);
        }
      }
    }
    refs.pop();
    refsNew.pop();
    return o2;
  }
}
const fastClone = rfdc_1({ circles: false, proto: true });
const { kSchemaVisited, kSchemaResponse: kSchemaResponse$1 } = symbols$1;
const kFluentSchema = Symbol.for("fluent-schema-object");
const {
  FST_ERR_SCH_MISSING_ID,
  FST_ERR_SCH_ALREADY_PRESENT,
  FST_ERR_SCH_DUPLICATE,
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA
} = errorsExports;
const SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
function Schemas(initStore) {
  this.store = initStore || {};
}
Schemas.prototype.add = function(inputSchema) {
  const schema2 = fastClone(
    inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema
  );
  const id2 = schema2.$id;
  if (!id2) {
    throw new FST_ERR_SCH_MISSING_ID();
  }
  if (this.store[id2]) {
    throw new FST_ERR_SCH_ALREADY_PRESENT(id2);
  }
  this.store[id2] = schema2;
};
Schemas.prototype.getSchemas = function() {
  return Object.assign({}, this.store);
};
Schemas.prototype.getSchema = function(schemaId) {
  return this.store[schemaId];
};
function isCustomSchemaPrototype(schema2) {
  return typeof schema2 === "object" && Object.getPrototypeOf(schema2) !== Object.prototype;
}
function normalizeSchema$1(routeSchemas, serverOptions) {
  if (routeSchemas[kSchemaVisited]) {
    return routeSchemas;
  }
  if (routeSchemas.query) {
    if (routeSchemas.querystring) {
      throw new FST_ERR_SCH_DUPLICATE("querystring");
    }
    routeSchemas.querystring = routeSchemas.query;
  }
  generateFluentSchema(routeSchemas);
  for (const key of SCHEMAS_SOURCE) {
    const schema2 = routeSchemas[key];
    if (schema2 && !isCustomSchemaPrototype(schema2)) {
      if (key === "body" && schema2.content) {
        const contentProperty = schema2.content;
        const keys2 = Object.keys(contentProperty);
        for (let i = 0; i < keys2.length; i++) {
          const contentType = keys2[i];
          const contentSchema = contentProperty[contentType].schema;
          if (!contentSchema) {
            throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType);
          }
        }
        continue;
      }
    }
  }
  if (routeSchemas.response) {
    const httpCodes = Object.keys(routeSchemas.response);
    for (const code2 of httpCodes) {
      if (isCustomSchemaPrototype(routeSchemas.response[code2])) {
        continue;
      }
      const contentProperty = routeSchemas.response[code2].content;
      if (contentProperty) {
        const keys2 = Object.keys(contentProperty);
        for (let i = 0; i < keys2.length; i++) {
          const mediaName = keys2[i];
          if (!contentProperty[mediaName].schema) {
            throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
          }
        }
      }
    }
  }
  routeSchemas[kSchemaVisited] = true;
  return routeSchemas;
}
function generateFluentSchema(schema2) {
  for (const key of SCHEMAS_SOURCE) {
    if (schema2[key] && (schema2[key].isFluentSchema || schema2[key][kFluentSchema])) {
      schema2[key] = schema2[key].valueOf();
    }
  }
  if (schema2.response) {
    const httpCodes = Object.keys(schema2.response);
    for (const code2 of httpCodes) {
      if (schema2.response[code2].isFluentSchema || schema2.response[code2][kFluentSchema]) {
        schema2.response[code2] = schema2.response[code2].valueOf();
      }
    }
  }
}
function getSchemaSerializer$2(context2, statusCode, contentType) {
  const responseSchemaDef = context2[kSchemaResponse$1];
  if (!responseSchemaDef) {
    return false;
  }
  if (responseSchemaDef[statusCode]) {
    if (responseSchemaDef[statusCode].constructor === Object && contentType) {
      const mediaName = contentType.split(";", 1)[0];
      if (responseSchemaDef[statusCode][mediaName]) {
        return responseSchemaDef[statusCode][mediaName];
      }
      if (responseSchemaDef[statusCode]["*/*"]) {
        return responseSchemaDef[statusCode]["*/*"];
      }
      return false;
    }
    return responseSchemaDef[statusCode];
  }
  const fallbackStatusCode = (statusCode + "")[0] + "xx";
  if (responseSchemaDef[fallbackStatusCode]) {
    if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
      const mediaName = contentType.split(";", 1)[0];
      if (responseSchemaDef[fallbackStatusCode][mediaName]) {
        return responseSchemaDef[fallbackStatusCode][mediaName];
      }
      if (responseSchemaDef[fallbackStatusCode]["*/*"]) {
        return responseSchemaDef[fallbackStatusCode]["*/*"];
      }
      return false;
    }
    return responseSchemaDef[fallbackStatusCode];
  }
  if (responseSchemaDef.default) {
    if (responseSchemaDef.default.constructor === Object && contentType) {
      const mediaName = contentType.split(";", 1)[0];
      if (responseSchemaDef.default[mediaName]) {
        return responseSchemaDef.default[mediaName];
      }
      if (responseSchemaDef.default["*/*"]) {
        return responseSchemaDef.default["*/*"];
      }
      return false;
    }
    return responseSchemaDef.default;
  }
  return false;
}
var schemas = {
  buildSchemas(initStore) {
    return new Schemas(initStore);
  },
  getSchemaSerializer: getSchemaSerializer$2,
  normalizeSchema: normalizeSchema$1
};
const STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
var serializer$1 = class Serializer {
  constructor(options) {
    switch (options && options.rounding) {
      case "floor":
        this.parseInteger = Math.floor;
        break;
      case "ceil":
        this.parseInteger = Math.ceil;
        break;
      case "round":
        this.parseInteger = Math.round;
        break;
      case "trunc":
      default:
        this.parseInteger = Math.trunc;
        break;
    }
    this._options = options;
  }
  asInteger(i) {
    if (Number.isInteger(i)) {
      return "" + i;
    } else if (typeof i === "bigint") {
      return i.toString();
    }
    const integer = this.parseInteger(i);
    if (integer === Infinity || integer === -Infinity || integer !== integer) {
      throw new Error(`The value "${i}" cannot be converted to an integer.`);
    }
    return "" + integer;
  }
  asNumber(i) {
    const num = Number(i);
    if (num !== num) {
      throw new Error(`The value "${i}" cannot be converted to a number.`);
    } else if (num === Infinity || num === -Infinity) {
      return "null";
    } else {
      return "" + num;
    }
  }
  asBoolean(bool2) {
    return bool2 && "true" || "false";
  }
  asDateTime(date) {
    if (date === null) return '""';
    if (date instanceof Date) {
      return '"' + date.toISOString() + '"';
    }
    if (typeof date === "string") {
      return '"' + date + '"';
    }
    throw new Error(`The value "${date}" cannot be converted to a date-time.`);
  }
  asDate(date) {
    if (date === null) return '""';
    if (date instanceof Date) {
      return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
    }
    if (typeof date === "string") {
      return '"' + date + '"';
    }
    throw new Error(`The value "${date}" cannot be converted to a date.`);
  }
  asTime(date) {
    if (date === null) return '""';
    if (date instanceof Date) {
      return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
    }
    if (typeof date === "string") {
      return '"' + date + '"';
    }
    throw new Error(`The value "${date}" cannot be converted to a time.`);
  }
  asString(str2) {
    const len = str2.length;
    if (len < 42) {
      let result = "";
      let last = -1;
      let point = 255;
      for (let i = 0; i < len; i++) {
        point = str2.charCodeAt(i);
        if (point === 34 || // '"'
        point === 92) {
          last === -1 && (last = 0);
          result += str2.slice(last, i) + "\\";
          last = i;
        } else if (point < 32 || point >= 55296 && point <= 57343) {
          return JSON.stringify(str2);
        }
      }
      return last === -1 && '"' + str2 + '"' || '"' + result + str2.slice(last) + '"';
    } else if (len < 5e3 && STR_ESCAPE.test(str2) === false) {
      return '"' + str2 + '"';
    } else {
      return JSON.stringify(str2);
    }
  }
  asUnsafeString(str2) {
    return '"' + str2 + '"';
  }
  getState() {
    return this._options;
  }
  static restoreFromState(state2) {
    return new Serializer(state2);
  }
};
const Serializer$1 = serializer$1;
const serializerState = { "mode": "standalone" };
const serializer = Serializer$1.restoreFromState(serializerState);
const validator$2 = null;
var errorSerializer = function anonymous(validator2, serializer2) {
  const JSON_STR_BEGIN_OBJECT = "{";
  const JSON_STR_END_OBJECT = "}";
  const JSON_STR_COMMA = ",";
  const JSON_STR_QUOTE = '"';
  const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
  const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
  function anonymous0(input) {
    const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
    if (obj === null) return JSON_STR_EMPTY_OBJECT;
    let value;
    let json2 = JSON_STR_BEGIN_OBJECT;
    let addComma2 = false;
    value = obj["statusCode"];
    if (value !== void 0) {
      !addComma2 && (addComma2 = true) || (json2 += JSON_STR_COMMA);
      json2 += '"statusCode":';
      json2 += serializer2.asNumber(value);
    }
    value = obj["code"];
    if (value !== void 0) {
      !addComma2 && (addComma2 = true) || (json2 += JSON_STR_COMMA);
      json2 += '"code":';
      if (typeof value !== "string") {
        if (value === null) {
          json2 += JSON_STR_EMPTY_STRING;
        } else if (value instanceof Date) {
          json2 += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
        } else if (value instanceof RegExp) {
          json2 += serializer2.asString(value.source);
        } else {
          json2 += serializer2.asString(value.toString());
        }
      } else {
        json2 += serializer2.asString(value);
      }
    }
    value = obj["error"];
    if (value !== void 0) {
      !addComma2 && (addComma2 = true) || (json2 += JSON_STR_COMMA);
      json2 += '"error":';
      if (typeof value !== "string") {
        if (value === null) {
          json2 += JSON_STR_EMPTY_STRING;
        } else if (value instanceof Date) {
          json2 += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
        } else if (value instanceof RegExp) {
          json2 += serializer2.asString(value.source);
        } else {
          json2 += serializer2.asString(value.toString());
        }
      } else {
        json2 += serializer2.asString(value);
      }
    }
    value = obj["message"];
    if (value !== void 0) {
      !addComma2 && (addComma2 = true) || (json2 += JSON_STR_COMMA);
      json2 += '"message":';
      if (typeof value !== "string") {
        if (value === null) {
          json2 += JSON_STR_EMPTY_STRING;
        } else if (value instanceof Date) {
          json2 += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
        } else if (value instanceof RegExp) {
          json2 += serializer2.asString(value.source);
        } else {
          json2 += serializer2.asString(value.toString());
        }
      } else {
        json2 += serializer2.asString(value);
      }
    }
    return json2 + JSON_STR_END_OBJECT;
  }
  const main2 = anonymous0;
  return main2;
}(validator$2, serializer);
const statusCodes = require$$0$4.STATUS_CODES;
const wrapThenable = wrapThenable_1;
const {
  kReplyHeaders: kReplyHeaders$1,
  kReplyNextErrorHandler: kReplyNextErrorHandler$1,
  kReplyIsRunningOnErrorHook: kReplyIsRunningOnErrorHook$1,
  kReplyHasStatusCode: kReplyHasStatusCode$1,
  kRouteContext: kRouteContext$3,
  kDisableRequestLogging: kDisableRequestLogging$2
} = symbols$1;
const {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: FST_ERR_REP_INVALID_PAYLOAD_TYPE$1,
  FST_ERR_FAILED_ERROR_SERIALIZATION
} = errorsExports;
const { getSchemaSerializer: getSchemaSerializer$1 } = schemas;
const serializeError = errorSerializer;
const rootErrorHandler = {
  func: defaultErrorHandler,
  toJSON() {
    return this.func.name.toString() + "()";
  }
};
function handleError$2(reply2, error2, cb) {
  reply2[kReplyIsRunningOnErrorHook$1] = false;
  const context2 = reply2[kRouteContext$3];
  if (reply2[kReplyNextErrorHandler$1] === false) {
    fallbackErrorHandler(error2, reply2, function(reply3, payload) {
      try {
        reply3.raw.writeHead(reply3.raw.statusCode, reply3[kReplyHeaders$1]);
      } catch (error3) {
        if (!reply3.log[kDisableRequestLogging$2]) {
          reply3.log.warn(
            { req: reply3.request, res: reply3, err: error3 },
            error3 && error3.message
          );
        }
        reply3.raw.writeHead(reply3.raw.statusCode);
      }
      reply3.raw.end(payload);
    });
    return;
  }
  const errorHandler2 = reply2[kReplyNextErrorHandler$1] || context2.errorHandler;
  reply2[kReplyNextErrorHandler$1] = Object.getPrototypeOf(errorHandler2);
  delete reply2[kReplyHeaders$1]["content-type"];
  delete reply2[kReplyHeaders$1]["content-length"];
  const func = errorHandler2.func;
  if (!func) {
    reply2[kReplyNextErrorHandler$1] = false;
    fallbackErrorHandler(error2, reply2, cb);
    return;
  }
  try {
    const result = func(error2, reply2.request, reply2);
    if (result !== void 0) {
      if (result !== null && typeof result.then === "function") {
        wrapThenable(result, reply2);
      } else {
        reply2.send(result);
      }
    }
  } catch (err2) {
    reply2.send(err2);
  }
}
function defaultErrorHandler(error2, request2, reply2) {
  setErrorHeaders(error2, reply2);
  if (!reply2[kReplyHasStatusCode$1] || reply2.statusCode === 200) {
    const statusCode = error2.statusCode || error2.status;
    reply2.code(statusCode >= 400 ? statusCode : 500);
  }
  if (reply2.statusCode < 500) {
    if (!reply2.log[kDisableRequestLogging$2]) {
      reply2.log.info(
        { res: reply2, err: error2 },
        error2 && error2.message
      );
    }
  } else {
    if (!reply2.log[kDisableRequestLogging$2]) {
      reply2.log.error(
        { req: request2, res: reply2, err: error2 },
        error2 && error2.message
      );
    }
  }
  reply2.send(error2);
}
function fallbackErrorHandler(error2, reply2, cb) {
  const res2 = reply2.raw;
  const statusCode = reply2.statusCode;
  reply2[kReplyHeaders$1]["content-type"] = reply2[kReplyHeaders$1]["content-type"] ?? "application/json; charset=utf-8";
  let payload;
  try {
    const serializerFn = getSchemaSerializer$1(reply2[kRouteContext$3], statusCode, reply2[kReplyHeaders$1]["content-type"]);
    if (serializerFn === false) {
      payload = serializeError({
        error: statusCodes[statusCode + ""],
        code: error2.code,
        message: error2.message,
        statusCode
      });
    } else {
      payload = serializerFn(Object.create(error2, {
        error: { value: statusCodes[statusCode + ""] },
        message: { value: error2.message },
        statusCode: { value: statusCode }
      }));
    }
  } catch (err2) {
    if (!reply2.log[kDisableRequestLogging$2]) {
      reply2.log.error({ err: err2, statusCode: res2.statusCode }, "The serializer for the given status code failed");
    }
    reply2.code(500);
    payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err2.message, error2.message));
  }
  if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
    payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE$1(typeof payload));
  }
  reply2[kReplyHeaders$1]["content-length"] = "" + Buffer.byteLength(payload);
  cb(reply2, payload);
}
function buildErrorHandler$3(parent = rootErrorHandler, func) {
  if (!func) {
    return parent;
  }
  const errorHandler2 = Object.create(parent);
  errorHandler2.func = func;
  return errorHandler2;
}
function setErrorHeaders(error2, reply2) {
  const res2 = reply2.raw;
  let statusCode = res2.statusCode;
  statusCode = statusCode >= 400 ? statusCode : 500;
  if (error2 != null) {
    if (error2.headers !== void 0) {
      reply2.headers(error2.headers);
    }
    if (error2.status >= 400) {
      statusCode = error2.status;
    } else if (error2.statusCode >= 400) {
      statusCode = error2.statusCode;
    }
  }
  res2.statusCode = statusCode;
}
var errorHandler = {
  buildErrorHandler: buildErrorHandler$3,
  handleError: handleError$2
};
const eos = require$$0$7.finished;
const Readable = require$$0$7.Readable;
const {
  kFourOhFourContext: kFourOhFourContext$2,
  kReplyErrorHandlerCalled,
  kReplyHijacked,
  kReplyStartTime,
  kReplyEndTime,
  kReplySerializer,
  kReplySerializerDefault: kReplySerializerDefault$3,
  kReplyIsError: kReplyIsError$1,
  kReplyHeaders,
  kReplyTrailers,
  kReplyHasStatusCode,
  kReplyIsRunningOnErrorHook,
  kReplyNextErrorHandler,
  kDisableRequestLogging: kDisableRequestLogging$1,
  kSchemaResponse,
  kReplyCacheSerializeFns: kReplyCacheSerializeFns$1,
  kSchemaController: kSchemaController$4,
  kOptions: kOptions$4,
  kRouteContext: kRouteContext$2
} = symbols$1;
const {
  onSendHookRunner,
  onResponseHookRunner,
  preHandlerHookRunner,
  preSerializationHookRunner
} = hooks;
const internals = handleRequestExports[Symbol.for("internals")];
const loggerUtils = loggerFactory;
const now = loggerUtils.now;
const { handleError: handleError$1 } = errorHandler;
const { getSchemaSerializer } = schemas;
const CONTENT_TYPE = {
  JSON: "application/json; charset=utf-8",
  PLAIN: "text/plain; charset=utf-8",
  OCTET: "application/octet-stream"
};
const {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE,
  FST_ERR_REP_RESPONSE_BODY_CONSUMED,
  FST_ERR_REP_READABLE_STREAM_LOCKED,
  FST_ERR_REP_ALREADY_SENT,
  FST_ERR_SEND_INSIDE_ONERR,
  FST_ERR_BAD_STATUS_CODE,
  FST_ERR_BAD_TRAILER_NAME,
  FST_ERR_BAD_TRAILER_VALUE,
  FST_ERR_MISSING_SERIALIZATION_FN,
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN
} = errorsExports;
const toString$2 = Object.prototype.toString;
function Reply$3(res2, request2, log) {
  this.raw = res2;
  this[kReplySerializer] = null;
  this[kReplyErrorHandlerCalled] = false;
  this[kReplyIsError$1] = false;
  this[kReplyIsRunningOnErrorHook] = false;
  this.request = request2;
  this[kReplyHeaders] = {};
  this[kReplyTrailers] = null;
  this[kReplyHasStatusCode] = false;
  this[kReplyStartTime] = void 0;
  this.log = log;
}
Reply$3.props = [];
Object.defineProperties(Reply$3.prototype, {
  [kRouteContext$2]: {
    get() {
      return this.request[kRouteContext$2];
    }
  },
  elapsedTime: {
    get() {
      if (this[kReplyStartTime] === void 0) {
        return 0;
      }
      return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
    }
  },
  server: {
    get() {
      return this.request[kRouteContext$2].server;
    }
  },
  sent: {
    enumerable: true,
    get() {
      return (this[kReplyHijacked] || this.raw.writableEnded) === true;
    }
  },
  statusCode: {
    get() {
      return this.raw.statusCode;
    },
    set(value) {
      this.code(value);
    }
  },
  routeOptions: {
    get() {
      return this.request.routeOptions;
    }
  }
});
Reply$3.prototype.writeEarlyHints = function(hints, callback) {
  this.raw.writeEarlyHints(hints, callback);
  return this;
};
Reply$3.prototype.hijack = function() {
  this[kReplyHijacked] = true;
  return this;
};
Reply$3.prototype.send = function(payload) {
  if (this[kReplyIsRunningOnErrorHook] === true) {
    throw new FST_ERR_SEND_INSIDE_ONERR();
  }
  if (this.sent) {
    this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
    return this;
  }
  if (payload instanceof Error || this[kReplyIsError$1] === true) {
    this[kReplyIsError$1] = false;
    onErrorHook(this, payload, onSendHook);
    return this;
  }
  if (payload === void 0) {
    onSendHook(this, payload);
    return this;
  }
  const contentType = this.getHeader("content-type");
  const hasContentType = contentType !== void 0;
  if (payload !== null) {
    if (
      // node:stream
      typeof payload.pipe === "function" || // node:stream/web
      typeof payload.getReader === "function" || // Response
      toString$2.call(payload) === "[object Response]"
    ) {
      onSendHook(this, payload);
      return this;
    }
    if ((payload == null ? void 0 : payload.buffer) instanceof ArrayBuffer) {
      if (hasContentType === false) {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
      }
      const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
      onSendHook(this, payloadToSend);
      return this;
    }
    if (hasContentType === false && typeof payload === "string") {
      this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
      onSendHook(this, payload);
      return this;
    }
  }
  if (this[kReplySerializer] !== null) {
    if (typeof payload !== "string") {
      preSerializationHook(this, payload);
      return this;
    } else {
      payload = this[kReplySerializer](payload);
    }
  } else if (hasContentType === false || contentType.indexOf("json") > -1) {
    if (hasContentType === false) {
      this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
    } else {
      if (contentType.indexOf("charset") === -1) {
        const customContentType = contentType.trim();
        if (customContentType.endsWith(";")) {
          this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
        } else {
          this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
        }
      }
    }
    if (typeof payload !== "string") {
      preSerializationHook(this, payload);
      return this;
    }
  }
  onSendHook(this, payload);
  return this;
};
Reply$3.prototype.getHeader = function(key) {
  key = key.toLowerCase();
  const res2 = this.raw;
  let value = this[kReplyHeaders][key];
  if (value === void 0 && res2.hasHeader(key)) {
    value = res2.getHeader(key);
  }
  return value;
};
Reply$3.prototype.getHeaders = function() {
  return {
    ...this.raw.getHeaders(),
    ...this[kReplyHeaders]
  };
};
Reply$3.prototype.hasHeader = function(key) {
  key = key.toLowerCase();
  return this[kReplyHeaders][key] !== void 0 || this.raw.hasHeader(key);
};
Reply$3.prototype.removeHeader = function(key) {
  delete this[kReplyHeaders][key.toLowerCase()];
  return this;
};
Reply$3.prototype.header = function(key, value = "") {
  key = key.toLowerCase();
  if (this[kReplyHeaders][key] && key === "set-cookie") {
    if (typeof this[kReplyHeaders][key] === "string") {
      this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
    }
    if (Array.isArray(value)) {
      Array.prototype.push.apply(this[kReplyHeaders][key], value);
    } else {
      this[kReplyHeaders][key].push(value);
    }
  } else {
    this[kReplyHeaders][key] = value;
  }
  return this;
};
Reply$3.prototype.headers = function(headers2) {
  const keys2 = Object.keys(headers2);
  for (let i = 0; i !== keys2.length; ++i) {
    const key = keys2[i];
    this.header(key, headers2[key]);
  }
  return this;
};
const INVALID_TRAILERS = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "content-length",
  "host",
  "cache-control",
  "max-forwards",
  "te",
  "authorization",
  "set-cookie",
  "content-encoding",
  "content-type",
  "content-range",
  "trailer"
]);
Reply$3.prototype.trailer = function(key, fn) {
  key = key.toLowerCase();
  if (INVALID_TRAILERS.has(key)) {
    throw new FST_ERR_BAD_TRAILER_NAME(key);
  }
  if (typeof fn !== "function") {
    throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
  }
  if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
  this[kReplyTrailers][key] = fn;
  return this;
};
Reply$3.prototype.hasTrailer = function(key) {
  var _a2;
  return ((_a2 = this[kReplyTrailers]) == null ? void 0 : _a2[key.toLowerCase()]) !== void 0;
};
Reply$3.prototype.removeTrailer = function(key) {
  if (this[kReplyTrailers] === null) return this;
  this[kReplyTrailers][key.toLowerCase()] = void 0;
  return this;
};
Reply$3.prototype.code = function(code2) {
  const intValue = Number(code2);
  if (isNaN(intValue) || intValue < 100 || intValue > 599) {
    throw new FST_ERR_BAD_STATUS_CODE(code2 || String(code2));
  }
  this.raw.statusCode = intValue;
  this[kReplyHasStatusCode] = true;
  return this;
};
Reply$3.prototype.status = Reply$3.prototype.code;
Reply$3.prototype.getSerializationFunction = function(schemaOrStatus, contentType) {
  var _a2, _b, _c, _d;
  let serialize2;
  if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
    if (typeof contentType === "string") {
      serialize2 = (_b = (_a2 = this[kRouteContext$2][kSchemaResponse]) == null ? void 0 : _a2[schemaOrStatus]) == null ? void 0 : _b[contentType];
    } else {
      serialize2 = (_c = this[kRouteContext$2][kSchemaResponse]) == null ? void 0 : _c[schemaOrStatus];
    }
  } else if (typeof schemaOrStatus === "object") {
    serialize2 = (_d = this[kRouteContext$2][kReplyCacheSerializeFns$1]) == null ? void 0 : _d.get(schemaOrStatus);
  }
  return serialize2;
};
Reply$3.prototype.compileSerializationSchema = function(schema2, httpStatus = null, contentType = null) {
  var _a2;
  const { request: request2 } = this;
  const { method, url: url2 } = request2;
  if ((_a2 = this[kRouteContext$2][kReplyCacheSerializeFns$1]) == null ? void 0 : _a2.has(schema2)) {
    return this[kRouteContext$2][kReplyCacheSerializeFns$1].get(schema2);
  }
  const serializerCompiler2 = this[kRouteContext$2].serializerCompiler || this.server[kSchemaController$4].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
  // nor set
  (this.server[kSchemaController$4].setupSerializer(this.server[kOptions$4]) || this.server[kSchemaController$4].serializerCompiler);
  const serializeFn = serializerCompiler2({
    schema: schema2,
    method,
    url: url2,
    httpStatus,
    contentType
  });
  if (this[kRouteContext$2][kReplyCacheSerializeFns$1] == null) {
    this[kRouteContext$2][kReplyCacheSerializeFns$1] = /* @__PURE__ */ new WeakMap();
  }
  this[kRouteContext$2][kReplyCacheSerializeFns$1].set(schema2, serializeFn);
  return serializeFn;
};
Reply$3.prototype.serializeInput = function(input, schema2, httpStatus, contentType) {
  var _a2, _b, _c, _d;
  const possibleContentType = httpStatus;
  let serialize2;
  httpStatus = typeof schema2 === "string" || typeof schema2 === "number" ? schema2 : httpStatus;
  contentType = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType;
  if (httpStatus != null) {
    if (contentType != null) {
      serialize2 = (_b = (_a2 = this[kRouteContext$2][kSchemaResponse]) == null ? void 0 : _a2[httpStatus]) == null ? void 0 : _b[contentType];
    } else {
      serialize2 = (_c = this[kRouteContext$2][kSchemaResponse]) == null ? void 0 : _c[httpStatus];
    }
    if (serialize2 == null) {
      if (contentType) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType);
      throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
    }
  } else {
    if ((_d = this[kRouteContext$2][kReplyCacheSerializeFns$1]) == null ? void 0 : _d.has(schema2)) {
      serialize2 = this[kRouteContext$2][kReplyCacheSerializeFns$1].get(schema2);
    } else {
      serialize2 = this.compileSerializationSchema(schema2, httpStatus, contentType);
    }
  }
  return serialize2(input);
};
Reply$3.prototype.serialize = function(payload) {
  if (this[kReplySerializer] !== null) {
    return this[kReplySerializer](payload);
  } else {
    if (this[kRouteContext$2] && this[kRouteContext$2][kReplySerializerDefault$3]) {
      return this[kRouteContext$2][kReplySerializerDefault$3](payload, this.raw.statusCode);
    } else {
      return serialize$2(this[kRouteContext$2], payload, this.raw.statusCode);
    }
  }
};
Reply$3.prototype.serializer = function(fn) {
  this[kReplySerializer] = fn;
  return this;
};
Reply$3.prototype.type = function(type2) {
  this[kReplyHeaders]["content-type"] = type2;
  return this;
};
Reply$3.prototype.redirect = function(url2, code2) {
  if (!code2) {
    code2 = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
  }
  return this.header("location", url2).code(code2).send();
};
Reply$3.prototype.callNotFound = function() {
  notFound(this);
  return this;
};
Reply$3.prototype.then = function(fulfilled, rejected) {
  if (this.sent) {
    fulfilled();
    return;
  }
  eos(this.raw, (err2) => {
    if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      if (rejected) {
        rejected(err2);
      } else {
        this.log && this.log.warn("unhandled rejection on reply.then");
      }
    } else {
      fulfilled();
    }
  });
};
function preSerializationHook(reply2, payload) {
  if (reply2[kRouteContext$2].preSerialization !== null) {
    preSerializationHookRunner(
      reply2[kRouteContext$2].preSerialization,
      reply2.request,
      reply2,
      payload,
      preSerializationHookEnd
    );
  } else {
    preSerializationHookEnd(null, reply2.request, reply2, payload);
  }
}
function preSerializationHookEnd(err2, request2, reply2, payload) {
  if (err2 != null) {
    onErrorHook(reply2, err2);
    return;
  }
  try {
    if (reply2[kReplySerializer] !== null) {
      payload = reply2[kReplySerializer](payload);
    } else if (reply2[kRouteContext$2] && reply2[kRouteContext$2][kReplySerializerDefault$3]) {
      payload = reply2[kRouteContext$2][kReplySerializerDefault$3](payload, reply2.raw.statusCode);
    } else {
      payload = serialize$2(reply2[kRouteContext$2], payload, reply2.raw.statusCode, reply2[kReplyHeaders]["content-type"]);
    }
  } catch (e) {
    wrapSerializationError(e, reply2);
    onErrorHook(reply2, e);
    return;
  }
  onSendHook(reply2, payload);
}
function wrapSerializationError(error2, reply2) {
  error2.serialization = reply2[kRouteContext$2].config;
}
function onSendHook(reply2, payload) {
  if (reply2[kRouteContext$2].onSend !== null) {
    onSendHookRunner(
      reply2[kRouteContext$2].onSend,
      reply2.request,
      reply2,
      payload,
      wrapOnSendEnd
    );
  } else {
    onSendEnd(reply2, payload);
  }
}
function wrapOnSendEnd(err2, request2, reply2, payload) {
  if (err2 != null) {
    onErrorHook(reply2, err2);
  } else {
    onSendEnd(reply2, payload);
  }
}
function safeWriteHead(reply2, statusCode) {
  const res2 = reply2.raw;
  try {
    res2.writeHead(statusCode, reply2[kReplyHeaders]);
  } catch (err2) {
    if (err2.code === "ERR_HTTP_HEADERS_SENT") {
      reply2.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply2.request.raw.url}" (${reply2.request.raw.method}) route?`);
    }
    throw err2;
  }
}
function onSendEnd(reply2, payload) {
  const res2 = reply2.raw;
  const req2 = reply2.request;
  if (reply2[kReplyTrailers] !== null) {
    const trailerHeaders = Object.keys(reply2[kReplyTrailers]);
    let header = "";
    for (const trailerName of trailerHeaders) {
      if (typeof reply2[kReplyTrailers][trailerName] !== "function") continue;
      header += " ";
      header += trailerName;
    }
    reply2.header("Transfer-Encoding", "chunked");
    reply2.header("Trailer", header.trim());
  }
  if (toString$2.call(payload) === "[object Response]") {
    if (typeof payload.status === "number") {
      reply2.code(payload.status);
    }
    if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
      for (const [headerName, headerValue] of payload.headers) {
        reply2.header(headerName, headerValue);
      }
    }
    if (payload.body !== null) {
      if (payload.bodyUsed) {
        throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED();
      }
    }
    payload = payload.body;
  }
  const statusCode = res2.statusCode;
  if (payload === void 0 || payload === null) {
    if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req2.method !== "HEAD" && reply2[kReplyTrailers] === null) {
      reply2[kReplyHeaders]["content-length"] = "0";
    }
    safeWriteHead(reply2, statusCode);
    sendTrailer(payload, res2, reply2);
    return;
  }
  if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
    reply2.removeHeader("content-type");
    reply2.removeHeader("content-length");
    safeWriteHead(reply2, statusCode);
    sendTrailer(void 0, res2, reply2);
    if (typeof payload.resume === "function") {
      payload.on("error", noop$4);
      payload.resume();
    }
    return;
  }
  if (typeof payload.pipe === "function") {
    sendStream(payload, res2, reply2);
    return;
  }
  if (typeof payload.getReader === "function") {
    sendWebStream(payload, res2, reply2);
    return;
  }
  if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
    throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
  }
  if (reply2[kReplyTrailers] === null) {
    const contentLength = reply2[kReplyHeaders]["content-length"];
    if (!contentLength || req2.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
      reply2[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
    }
  }
  safeWriteHead(reply2, statusCode);
  res2.write(payload);
  sendTrailer(payload, res2, reply2);
}
function logStreamError(logger, err2, res2) {
  if (err2.code === "ERR_STREAM_PREMATURE_CLOSE") {
    if (!logger[kDisableRequestLogging$1]) {
      logger.info({ res: res2 }, "stream closed prematurely");
    }
  } else {
    logger.warn({ err: err2 }, "response terminated with an error with headers already sent");
  }
}
function sendWebStream(payload, res2, reply2) {
  if (payload.locked) {
    throw FST_ERR_REP_READABLE_STREAM_LOCKED();
  }
  const nodeStream = Readable.fromWeb(payload);
  sendStream(nodeStream, res2, reply2);
}
function sendStream(payload, res2, reply2) {
  let sourceOpen = true;
  let errorLogged = false;
  sendStreamTrailer(payload, res2, reply2);
  eos(payload, { readable: true, writable: false }, function(err2) {
    sourceOpen = false;
    if (err2 != null) {
      if (res2.headersSent || reply2.request.raw.aborted === true) {
        if (!errorLogged) {
          errorLogged = true;
          logStreamError(reply2.log, err2, reply2);
        }
        res2.destroy();
      } else {
        onErrorHook(reply2, err2);
      }
    }
  });
  eos(res2, function(err2) {
    if (sourceOpen) {
      if (err2 != null && res2.headersSent && !errorLogged) {
        errorLogged = true;
        logStreamError(reply2.log, err2, res2);
      }
      if (typeof payload.destroy === "function") {
        payload.destroy();
      } else if (typeof payload.close === "function") {
        payload.close(noop$4);
      } else if (typeof payload.abort === "function") {
        payload.abort();
      } else {
        reply2.log.warn("stream payload does not end properly");
      }
    }
  });
  if (!res2.headersSent) {
    for (const key in reply2[kReplyHeaders]) {
      res2.setHeader(key, reply2[kReplyHeaders][key]);
    }
  } else {
    reply2.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
  }
  payload.pipe(res2);
}
function sendTrailer(payload, res2, reply2) {
  if (reply2[kReplyTrailers] === null) {
    res2.end(null, null, null);
    return;
  }
  const trailerHeaders = Object.keys(reply2[kReplyTrailers]);
  const trailers = {};
  let handled = 0;
  let skipped = true;
  function send() {
    if (handled === 0) {
      res2.addTrailers(trailers);
      res2.end(null, null, null);
    }
  }
  for (const trailerName of trailerHeaders) {
    let cb = function(err2, value) {
      handled++;
      if (err2) reply2.log.debug(err2);
      else trailers[trailerName] = value;
      process.nextTick(send);
    };
    if (typeof reply2[kReplyTrailers][trailerName] !== "function") continue;
    skipped = false;
    handled--;
    const result = reply2[kReplyTrailers][trailerName](reply2, payload, cb);
    if (typeof result === "object" && typeof result.then === "function") {
      result.then((v) => cb(null, v), cb);
    }
  }
  if (skipped) res2.end(null, null, null);
}
function sendStreamTrailer(payload, res2, reply2) {
  if (reply2[kReplyTrailers] === null) return;
  payload.on("end", () => sendTrailer(null, res2, reply2));
}
function onErrorHook(reply2, error2, cb) {
  if (reply2[kRouteContext$2].onError !== null && !reply2[kReplyNextErrorHandler]) {
    reply2[kReplyIsRunningOnErrorHook] = true;
    onSendHookRunner(
      reply2[kRouteContext$2].onError,
      reply2.request,
      reply2,
      error2,
      () => handleError$1(reply2, error2, cb)
    );
  } else {
    handleError$1(reply2, error2, cb);
  }
}
function setupResponseListeners(reply2) {
  reply2[kReplyStartTime] = now();
  const onResFinished = (err2) => {
    reply2[kReplyEndTime] = now();
    reply2.raw.removeListener("finish", onResFinished);
    reply2.raw.removeListener("error", onResFinished);
    const ctx = reply2[kRouteContext$2];
    if (ctx && ctx.onResponse !== null) {
      onResponseHookRunner(
        ctx.onResponse,
        reply2.request,
        reply2,
        onResponseCallback
      );
    } else {
      onResponseCallback(err2, reply2.request, reply2);
    }
  };
  reply2.raw.on("finish", onResFinished);
  reply2.raw.on("error", onResFinished);
}
function onResponseCallback(err2, request2, reply2) {
  if (reply2.log[kDisableRequestLogging$1]) {
    return;
  }
  const responseTime = reply2.elapsedTime;
  if (err2 != null) {
    reply2.log.error({
      res: reply2,
      err: err2,
      responseTime
    }, "request errored");
    return;
  }
  reply2.log.info({
    res: reply2,
    responseTime
  }, "request completed");
}
function buildReply(R) {
  const props = R.props.slice();
  function _Reply(res2, request2, log) {
    this.raw = res2;
    this[kReplyIsError$1] = false;
    this[kReplyErrorHandlerCalled] = false;
    this[kReplyHijacked] = false;
    this[kReplySerializer] = null;
    this.request = request2;
    this[kReplyHeaders] = {};
    this[kReplyTrailers] = null;
    this[kReplyStartTime] = void 0;
    this[kReplyEndTime] = void 0;
    this.log = log;
    let prop;
    for (let i = 0; i < props.length; i++) {
      prop = props[i];
      this[prop.key] = prop.value;
    }
  }
  Object.setPrototypeOf(_Reply.prototype, R.prototype);
  Object.setPrototypeOf(_Reply, R);
  _Reply.parent = R;
  _Reply.props = props;
  return _Reply;
}
function notFound(reply2) {
  if (reply2[kRouteContext$2][kFourOhFourContext$2] === null) {
    reply2.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
    reply2.code(404).send("404 Not Found");
    return;
  }
  reply2.request[kRouteContext$2] = reply2[kRouteContext$2][kFourOhFourContext$2];
  if (reply2[kRouteContext$2].preHandler !== null) {
    preHandlerHookRunner(
      reply2[kRouteContext$2].preHandler,
      reply2.request,
      reply2,
      internals.preHandlerCallback
    );
  } else {
    internals.preHandlerCallback(null, reply2.request, reply2);
  }
}
function serialize$2(context2, data, statusCode, contentType) {
  const fnSerialize = getSchemaSerializer(context2, statusCode, contentType);
  if (fnSerialize) {
    return fnSerialize(data);
  }
  return JSON.stringify(data);
}
function noop$4() {
}
reply.exports = Reply$3;
reply.exports.buildReply = buildReply;
reply.exports.setupResponseListeners = setupResponseListeners;
var replyExports = reply.exports;
var request$1 = { exports: {} };
var proxyAddr$1 = { exports: {} };
var forwarded$2 = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
function forwarded$1(req2) {
  if (!req2) {
    throw new TypeError("argument req is required");
  }
  const header = req2.headers["x-forwarded-for"];
  const socketAddr = req2.socket.remoteAddress;
  if (!header || typeof header !== "string") {
    return [socketAddr];
  } else if (header.indexOf(",") === -1) {
    const remote = header.trim();
    return remote.length ? [socketAddr, remote] : [socketAddr];
  } else {
    return parse$d(header, socketAddr);
  }
}
function parse$d(header, socketAddr) {
  const result = [socketAddr];
  let end = header.length;
  let start = end;
  let char;
  let i;
  for (i = end - 1; i >= 0; --i) {
    char = header[i];
    if (char === " ") {
      start === end && (start = end = i);
    } else if (char === ",") {
      start !== end && result.push(header.slice(start, end));
      start = end = i;
    } else {
      start = i;
    }
  }
  start !== end && result.push(header.substring(start, end));
  return result;
}
forwarded$2.exports = forwarded$1;
forwarded$2.exports.default = forwarded$1;
forwarded$2.exports.forwarded = forwarded$1;
var forwardedExports = forwarded$2.exports;
var ipaddr$1 = { exports: {} };
(function(module) {
  (function(root2) {
    const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    const ipv4Regexes = {
      fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
      longValue: new RegExp(`^${ipv4Part}$`, "i")
    };
    const octalRegex = new RegExp(`^0[0-7]+$`, "i");
    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
    const zoneIndex = "%[0-9a-z]{1,}";
    const ipv6Part = "(?:[0-9a-f]+::?)+";
    const ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
      transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
    };
    function expandIPv6(string, parts) {
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      let colonCount = 0;
      let lastColon = -1;
      let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
      let replacement, replacementCount;
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        const ref2 = string.split(":");
        const results = [];
        for (let i = 0; i < ref2.length; i++) {
          results.push(parseInt(ref2[i], 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    }
    function matchCIDR(first, second, partSize, cidrBits) {
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      let part = 0;
      let shift;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    }
    function parseIntAuto(string) {
      if (hexRegex.test(string)) {
        return parseInt(string, 16);
      }
      if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
        if (octalRegex.test(string)) {
          return parseInt(string, 8);
        }
        throw new Error(`ipaddr: cannot parse ${string} as octal`);
      }
      return parseInt(string, 10);
    }
    function padPart(part, length) {
      while (part.length < length) {
        part = `0${part}`;
      }
      return part;
    }
    const ipaddr2 = {};
    ipaddr2.IPv4 = function() {
      function IPv4(octets) {
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        let i, octet;
        for (i = 0; i < octets.length; i++) {
          octet = octets[i];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        // RFC3171
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        // RFC3927
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        // RFC5735
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        // RFC6598
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        // RFC1918
        "private": [
          [new IPv4([10, 0, 0, 0]), 8],
          [new IPv4([172, 16, 0, 0]), 12],
          [new IPv4([192, 168, 0, 0]), 16]
        ],
        // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
        reserved: [
          [new IPv4([192, 0, 0, 0]), 24],
          [new IPv4([192, 0, 2, 0]), 24],
          [new IPv4([192, 88, 99, 0]), 24],
          [new IPv4([198, 18, 0, 0]), 15],
          [new IPv4([198, 51, 100, 0]), 24],
          [new IPv4([203, 0, 113, 0]), 24],
          [new IPv4([240, 0, 0, 0]), 4]
        ],
        // RFC7534, RFC7535
        as112: [
          [new IPv4([192, 175, 48, 0]), 24],
          [new IPv4([192, 31, 196, 0]), 24]
        ],
        // RFC7450
        amt: [
          [new IPv4([192, 52, 193, 0]), 24]
        ]
      };
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.match = function(other, cidrRange) {
        let ref2;
        if (cidrRange === void 0) {
          ref2 = other;
          other = ref2[0];
          cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let i, octet, zeros;
        for (i = 3; i >= 0; i -= 1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      IPv4.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      return IPv4;
    }();
    ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
      try {
        const cidr = this.parseCIDR(string);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.isIPv4 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr2.IPv4.isValid = function(string) {
      try {
        new this(this.parser(string));
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidCIDR = function(string) {
      try {
        this.parseCIDR(string);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
      let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.parse = function(string) {
      const parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      }
      return new this(parts);
    };
    ipaddr2.IPv4.parseCIDR = function(string) {
      let match;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        const maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          const parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr2.IPv4.parser = function(string) {
      let match, part, value;
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          const ref2 = match.slice(1, 6);
          const results = [];
          for (let i = 0; i < ref2.length; i++) {
            part = ref2[i];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          const results = [];
          let shift;
          for (shift = 0; shift <= 24; shift += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else if (match = string.match(ipv4Regexes.twoOctet)) {
        return function() {
          const ref2 = match.slice(1, 4);
          const results = [];
          value = parseIntAuto(ref2[1]);
          if (value > 16777215 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref2[0]));
          results.push(value >> 16 & 255);
          results.push(value >> 8 & 255);
          results.push(value & 255);
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.threeOctet)) {
        return function() {
          const ref2 = match.slice(1, 5);
          const results = [];
          value = parseIntAuto(ref2[2]);
          if (value > 65535 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref2[0]));
          results.push(parseIntAuto(ref2[1]));
          results.push(value >> 8 & 255);
          results.push(value & 255);
          return results;
        }();
      } else {
        return null;
      }
    };
    ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      const octets = [0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.IPv6 = function() {
      function IPv6(parts, zoneId) {
        let i, part;
        if (parts.length === 16) {
          this.parts = [];
          for (i = 0; i <= 14; i += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        for (i = 0; i < this.parts.length; i++) {
          part = this.parts[i];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.SpecialRanges = {
        // RFC4291, here and after
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        // RFC6666
        discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        // RFC6145
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        // RFC6052
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        // RFC3056
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        // RFC6052, RFC6146
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        // RFC5180
        benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        // RFC7450
        amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          // RFC3849
          [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          // RFC2928
          [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.match = function(other, cidrRange) {
        let ref2;
        if (cidrRange === void 0) {
          ref2 = other;
          other = ref2[0];
          cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let part, zeros;
        for (let i = 7; i >= 0; i -= 1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      IPv6.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.toByteArray = function() {
        let part;
        const bytes = [];
        const ref2 = this.parts;
        for (let i = 0; i < ref2.length; i++) {
          part = ref2[i];
          bytes.push(part >> 8);
          bytes.push(part & 255);
        }
        return bytes;
      };
      IPv6.prototype.toFixedLengthString = function() {
        const addr = (function() {
          const results = [];
          for (let i = 0; i < this.parts.length; i++) {
            results.push(padPart(this.parts[i].toString(16), 4));
          }
          return results;
        }).call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        const ref2 = this.parts.slice(-2);
        const high = ref2[0];
        const low = ref2[1];
        return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.toNormalizedString = function() {
        const addr = (function() {
          const results = [];
          for (let i = 0; i < this.parts.length; i++) {
            results.push(this.parts[i].toString(16));
          }
          return results;
        }).call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toRFC5952String = function() {
        const regex = /((^|:)(0(:|$)){2,})/g;
        const string = this.toNormalizedString();
        let bestMatchIndex = 0;
        let bestMatchLength = -1;
        let match;
        while (match = regex.exec(string)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
      };
      IPv6.prototype.toString = function() {
        return this.toRFC5952String();
      };
      return IPv6;
    }();
    ipaddr2.IPv6.broadcastAddressFromCIDR = function(string) {
      try {
        const cidr = this.parseCIDR(string);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i = 0;
        while (i < 16) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr2.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr2.IPv6.isValid = function(string) {
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        const addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr2.IPv6.isValidCIDR = function(string) {
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        this.parseCIDR(string);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr2.IPv6.networkAddressFromCIDR = function(string) {
      let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 16) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr2.IPv6.parse = function(string) {
      const addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr2.IPv6.parseCIDR = function(string) {
      let maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr2.IPv6.parser = function(string) {
      let addr, i, match, octet, octets, zoneId;
      if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
        return this.parser(`::ffff:${match[1]}`);
      }
      if (ipv6Regexes.native.test(string)) {
        return expandIPv6(string, 8);
      }
      if (match = string.match(ipv6Regexes.transitional)) {
        zoneId = match[6] || "";
        addr = match[1];
        if (!match[1].endsWith("::")) {
          addr = addr.slice(0, -1);
        }
        addr = expandIPv6(addr + zoneId, 6);
        if (addr.parts) {
          octets = [
            parseInt(match[2]),
            parseInt(match[3]),
            parseInt(match[4]),
            parseInt(match[5])
          ];
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 128) {
        throw new Error("ipaddr: invalid IPv6 prefix length");
      }
      const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 16) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.fromByteArray = function(bytes) {
      const length = bytes.length;
      if (length === 4) {
        return new ipaddr2.IPv4(bytes);
      } else if (length === 16) {
        return new ipaddr2.IPv6(bytes);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr2.isValid = function(string) {
      return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
    };
    ipaddr2.isValidCIDR = function(string) {
      return ipaddr2.IPv6.isValidCIDR(string) || ipaddr2.IPv4.isValidCIDR(string);
    };
    ipaddr2.parse = function(string) {
      if (ipaddr2.IPv6.isValid(string)) {
        return ipaddr2.IPv6.parse(string);
      } else if (ipaddr2.IPv4.isValid(string)) {
        return ipaddr2.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr2.parseCIDR = function(string) {
      try {
        return ipaddr2.IPv6.parseCIDR(string);
      } catch (e) {
        try {
          return ipaddr2.IPv4.parseCIDR(string);
        } catch (e2) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr2.process = function(string) {
      const addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
    ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
      let i, rangeName, rangeSubnets, subnet;
      if (defaultName === void 0 || defaultName === null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (i = 0; i < rangeSubnets.length; i++) {
            subnet = rangeSubnets[i];
            if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    if (module.exports) {
      module.exports = ipaddr2;
    } else {
      root2.ipaddr = ipaddr2;
    }
  })(commonjsGlobal);
})(ipaddr$1);
var ipaddrExports = ipaddr$1.exports;
/*!
 * proxy-addr
 * Copyright(c) 2021 Fastify collaborators
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
proxyAddr$1.exports = proxyaddr;
proxyAddr$1.exports.default = proxyaddr;
proxyAddr$1.exports.proxyaddr = proxyaddr;
proxyAddr$1.exports.all = alladdrs;
proxyAddr$1.exports.compile = compile$1;
const forwarded = forwardedExports;
const ipaddr = ipaddrExports;
const DIGIT_REGEXP = /^\d+$/u;
const isip = ipaddr.isValid;
const parseip = ipaddr.parse;
const IP_RANGES = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function alladdrs(req2, trust) {
  const addrs = forwarded(req2);
  if (!trust) {
    return addrs;
  }
  if (typeof trust !== "function") {
    trust = compile$1(trust);
  }
  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue;
    addrs.length = i + 1;
  }
  return addrs;
}
function compile$1(val) {
  if (!val) {
    throw new TypeError("argument is required");
  }
  let trust;
  if (typeof val === "string") {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError("unsupported trust argument");
  }
  for (var i = 0; i < trust.length; i++) {
    val = trust[i];
    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue;
    }
    val = IP_RANGES[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }
  return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
  const rangeSubnets = new Array(arr.length);
  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }
  return rangeSubnets;
}
function compileTrust(rangeSubnets) {
  const len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
  const pos = note.lastIndexOf("/");
  const str2 = pos !== -1 ? note.substring(0, pos) : note;
  if (!isip(str2)) {
    throw new TypeError("invalid IP address: " + str2);
  }
  let ip = parseip(str2);
  if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
    ip = ip.toIPv4Address();
  }
  const max2 = ip.kind() === "ipv6" ? 128 : 32;
  let range2 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
  if (range2 === null) {
    range2 = max2;
  } else if (DIGIT_REGEXP.test(range2)) {
    range2 = parseInt(range2, 10);
  } else if (ip.kind() === "ipv4" && isip(range2)) {
    range2 = parseNetmask(range2);
  } else {
    range2 = null;
  }
  if (range2 <= 0 || range2 > max2) {
    throw new TypeError("invalid range on address: " + note);
  }
  return [ip, range2];
}
function parseNetmask(netmask) {
  const ip = parseip(netmask);
  const kind = ip.kind();
  return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
}
function proxyaddr(req2, trust) {
  if (!req2) {
    throw new TypeError("req argument is required");
  }
  if (!trust) {
    throw new TypeError("trust argument is required");
  }
  const addrs = alladdrs(req2, trust);
  const addr = addrs[addrs.length - 1];
  return addr;
}
function trustNone() {
  return false;
}
function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr)) return false;
    const ip = parseip(addr);
    let ipconv;
    const kind = ip.kind();
    for (var i = 0; i < subnets.length; i++) {
      const subnet = subnets[i];
      const subnetip = subnet[0];
      const subnetkind = subnetip.kind();
      const subnetrange = subnet[1];
      let trusted = ip;
      if (kind !== subnetkind) {
        if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
          continue;
        }
        if (!ipconv) {
          ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        trusted = ipconv;
      }
      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }
    return false;
  };
}
function trustSingle(subnet) {
  const subnetip = subnet[0];
  const subnetkind = subnetip.kind();
  const subnetisipv4 = subnetkind === "ipv4";
  const subnetrange = subnet[1];
  return function trust(addr) {
    if (!isip(addr)) return false;
    let ip = parseip(addr);
    const kind = ip.kind();
    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        return false;
      }
      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
    }
    return ip.match(subnetip, subnetrange);
  };
}
var proxyAddrExports = proxyAddr$1.exports;
const proxyAddr = proxyAddrExports;
const {
  kHasBeenDecorated: kHasBeenDecorated$2,
  kSchemaBody,
  kSchemaHeaders,
  kSchemaParams,
  kSchemaQuerystring,
  kSchemaController: kSchemaController$3,
  kOptions: kOptions$3,
  kRequestCacheValidateFns: kRequestCacheValidateFns$1,
  kRouteContext: kRouteContext$1,
  kRequestOriginalUrl
} = symbols$1;
const { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION } = errorsExports;
const HTTP_PART_SYMBOL_MAP = {
  body: kSchemaBody,
  headers: kSchemaHeaders,
  params: kSchemaParams,
  querystring: kSchemaQuerystring,
  query: kSchemaQuerystring
};
function Request$4(id2, params, req2, query, log, context2) {
  this.id = id2;
  this[kRouteContext$1] = context2;
  this.params = params;
  this.raw = req2;
  this.query = query;
  this.log = log;
  this.body = void 0;
}
Request$4.props = [];
function getTrustProxyFn(tp) {
  if (typeof tp === "function") {
    return tp;
  }
  if (tp === true) {
    return null;
  }
  if (typeof tp === "number") {
    return function(a, i) {
      return i < tp;
    };
  }
  if (typeof tp === "string") {
    const values2 = tp.split(",").map((it) => it.trim());
    return proxyAddr.compile(values2);
  }
  return proxyAddr.compile(tp);
}
function buildRequest(R, trustProxy) {
  if (trustProxy) {
    return buildRequestWithTrustProxy(R, trustProxy);
  }
  return buildRegularRequest(R);
}
function buildRegularRequest(R) {
  const props = R.props.slice();
  function _Request(id2, params, req2, query, log, context2) {
    this.id = id2;
    this[kRouteContext$1] = context2;
    this.params = params;
    this.raw = req2;
    this.query = query;
    this.log = log;
    this.body = void 0;
    let prop;
    for (let i = 0; i < props.length; i++) {
      prop = props[i];
      this[prop.key] = prop.value;
    }
  }
  Object.setPrototypeOf(_Request.prototype, R.prototype);
  Object.setPrototypeOf(_Request, R);
  _Request.props = props;
  _Request.parent = R;
  return _Request;
}
function getLastEntryInMultiHeaderValue(headerValue) {
  const lastIndex = headerValue.lastIndexOf(",");
  return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
}
function buildRequestWithTrustProxy(R, trustProxy) {
  const _Request = buildRegularRequest(R);
  const proxyFn = getTrustProxyFn(trustProxy);
  _Request[kHasBeenDecorated$2] = true;
  Object.defineProperties(_Request.prototype, {
    ip: {
      get() {
        const addrs = proxyAddr.all(this.raw, proxyFn);
        return addrs[addrs.length - 1];
      }
    },
    ips: {
      get() {
        return proxyAddr.all(this.raw, proxyFn);
      }
    },
    host: {
      get() {
        if (this.ip !== void 0 && this.headers["x-forwarded-host"]) {
          return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
        }
        return this.headers.host ?? this.headers[":authority"] ?? "";
      }
    },
    protocol: {
      get() {
        if (this.headers["x-forwarded-proto"]) {
          return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
        }
        if (this.socket) {
          return this.socket.encrypted ? "https" : "http";
        }
      }
    }
  });
  return _Request;
}
Object.defineProperties(Request$4.prototype, {
  server: {
    get() {
      return this[kRouteContext$1].server;
    }
  },
  url: {
    get() {
      return this.raw.url;
    }
  },
  originalUrl: {
    get() {
      if (!this[kRequestOriginalUrl]) {
        this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
      }
      return this[kRequestOriginalUrl];
    }
  },
  method: {
    get() {
      return this.raw.method;
    }
  },
  routeOptions: {
    get() {
      var _a2, _b;
      const context2 = this[kRouteContext$1];
      const routeLimit = context2._parserOptions.limit;
      const serverLimit = context2.server.initialConfig.bodyLimit;
      const version2 = context2.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0;
      const options = {
        method: (_a2 = context2.config) == null ? void 0 : _a2.method,
        url: (_b = context2.config) == null ? void 0 : _b.url,
        bodyLimit: routeLimit || serverLimit,
        attachValidation: context2.attachValidation,
        logLevel: context2.logLevel,
        exposeHeadRoute: context2.exposeHeadRoute,
        prefixTrailingSlash: context2.prefixTrailingSlash,
        handler: context2.handler,
        version: version2
      };
      Object.defineProperties(options, {
        config: {
          get: () => context2.config
        },
        schema: {
          get: () => context2.schema
        }
      });
      return Object.freeze(options);
    }
  },
  is404: {
    get() {
      var _a2;
      return ((_a2 = this[kRouteContext$1].config) == null ? void 0 : _a2.url) === void 0;
    }
  },
  socket: {
    get() {
      return this.raw.socket;
    }
  },
  ip: {
    get() {
      if (this.socket) {
        return this.socket.remoteAddress;
      }
    }
  },
  host: {
    get() {
      return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
    }
  },
  hostname: {
    get() {
      return this.host.split(":", 1)[0];
    }
  },
  port: {
    get() {
      const portFromHost = parseInt(this.host.split(":").slice(-1)[0]);
      if (!isNaN(portFromHost)) {
        return portFromHost;
      }
      const host = this.headers.host ?? this.headers[":authority"] ?? "";
      const portFromHeader = parseInt(host.split(":").slice(-1)[0]);
      if (!isNaN(portFromHeader)) {
        return portFromHeader;
      }
      return null;
    }
  },
  protocol: {
    get() {
      if (this.socket) {
        return this.socket.encrypted ? "https" : "http";
      }
    }
  },
  headers: {
    get() {
      if (this.additionalHeaders) {
        return Object.assign({}, this.raw.headers, this.additionalHeaders);
      }
      return this.raw.headers;
    },
    set(headers2) {
      this.additionalHeaders = headers2;
    }
  },
  getValidationFunction: {
    value: function(httpPartOrSchema) {
      var _a2;
      if (typeof httpPartOrSchema === "string") {
        const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
        return this[kRouteContext$1][symbol];
      } else if (typeof httpPartOrSchema === "object") {
        return (_a2 = this[kRouteContext$1][kRequestCacheValidateFns$1]) == null ? void 0 : _a2.get(httpPartOrSchema);
      }
    }
  },
  compileValidationSchema: {
    value: function(schema2, httpPart = null) {
      var _a2;
      const { method, url: url2 } = this;
      if ((_a2 = this[kRouteContext$1][kRequestCacheValidateFns$1]) == null ? void 0 : _a2.has(schema2)) {
        return this[kRouteContext$1][kRequestCacheValidateFns$1].get(schema2);
      }
      const validatorCompiler2 = this[kRouteContext$1].validatorCompiler || this.server[kSchemaController$3].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
      // nor set
      (this.server[kSchemaController$3].setupValidator(this.server[kOptions$3]) || this.server[kSchemaController$3].validatorCompiler);
      const validateFn = validatorCompiler2({
        schema: schema2,
        method,
        url: url2,
        httpPart
      });
      if (this[kRouteContext$1][kRequestCacheValidateFns$1] == null) {
        this[kRouteContext$1][kRequestCacheValidateFns$1] = /* @__PURE__ */ new WeakMap();
      }
      this[kRouteContext$1][kRequestCacheValidateFns$1].set(schema2, validateFn);
      return validateFn;
    }
  },
  validateInput: {
    value: function(input, schema2, httpPart) {
      var _a2;
      httpPart = typeof schema2 === "string" ? schema2 : httpPart;
      const symbol = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
      let validate2;
      if (symbol) {
        validate2 = this[kRouteContext$1][symbol];
      }
      if (validate2 == null && (schema2 == null || typeof schema2 !== "object" || Array.isArray(schema2))) {
        throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
      }
      if (validate2 == null) {
        if ((_a2 = this[kRouteContext$1][kRequestCacheValidateFns$1]) == null ? void 0 : _a2.has(schema2)) {
          validate2 = this[kRouteContext$1][kRequestCacheValidateFns$1].get(schema2);
        } else {
          validate2 = this.compileValidationSchema(schema2, httpPart);
        }
      }
      return validate2(input);
    }
  }
});
request$1.exports = Request$4;
request$1.exports.buildRequest = buildRequest;
var requestExports = request$1.exports;
const {
  kFourOhFourContext: kFourOhFourContext$1,
  kReplySerializerDefault: kReplySerializerDefault$2,
  kSchemaErrorFormatter: kSchemaErrorFormatter$2,
  kErrorHandler: kErrorHandler$3,
  kChildLoggerFactory: kChildLoggerFactory$1,
  kOptions: kOptions$2,
  kReply: kReply$3,
  kRequest: kRequest$3,
  kBodyLimit: kBodyLimit$1,
  kLogLevel: kLogLevel$3,
  kContentTypeParser: kContentTypeParser$2,
  kRouteByFastify: kRouteByFastify$1,
  kRequestCacheValidateFns,
  kReplyCacheSerializeFns
} = symbols$1;
function Context$3({
  schema: schema2,
  handler,
  config: config2,
  requestIdLogLabel,
  childLoggerFactory,
  errorHandler: errorHandler2,
  bodyLimit,
  logLevel,
  logSerializers,
  attachValidation,
  validatorCompiler: validatorCompiler2,
  serializerCompiler: serializerCompiler2,
  replySerializer,
  schemaErrorFormatter,
  exposeHeadRoute,
  prefixTrailingSlash,
  server: server2,
  isFastify
}) {
  this.schema = schema2;
  this.handler = handler;
  this.Reply = server2[kReply$3];
  this.Request = server2[kRequest$3];
  this.contentTypeParser = server2[kContentTypeParser$2];
  this.onRequest = null;
  this.onSend = null;
  this.onError = null;
  this.onTimeout = null;
  this.preHandler = null;
  this.onResponse = null;
  this.preSerialization = null;
  this.onRequestAbort = null;
  this.config = config2;
  this.errorHandler = errorHandler2 || server2[kErrorHandler$3];
  this.requestIdLogLabel = requestIdLogLabel || server2[kOptions$2].requestIdLogLabel;
  this.childLoggerFactory = childLoggerFactory || server2[kChildLoggerFactory$1];
  this._middie = null;
  this._parserOptions = {
    limit: bodyLimit || server2[kBodyLimit$1]
  };
  this.exposeHeadRoute = exposeHeadRoute;
  this.prefixTrailingSlash = prefixTrailingSlash;
  this.logLevel = logLevel || server2[kLogLevel$3];
  this.logSerializers = logSerializers;
  this[kFourOhFourContext$1] = null;
  this.attachValidation = attachValidation;
  this[kReplySerializerDefault$2] = replySerializer;
  this.schemaErrorFormatter = schemaErrorFormatter || server2[kSchemaErrorFormatter$2] || defaultSchemaErrorFormatter;
  this[kRouteByFastify$1] = isFastify;
  this[kRequestCacheValidateFns] = null;
  this[kReplyCacheSerializeFns] = null;
  this.validatorCompiler = validatorCompiler2 || null;
  this.serializerCompiler = serializerCompiler2 || null;
  this.server = server2;
}
function defaultSchemaErrorFormatter(errors2, dataVar) {
  let text = "";
  const separator = ", ";
  for (let i = 0; i !== errors2.length; ++i) {
    const e = errors2[i];
    text += dataVar + (e.instancePath || "") + " " + e.message + separator;
  }
  return new Error(text.slice(0, -separator.length));
}
var context = Context$3;
const {
  kReply: kReply$2,
  kRequest: kRequest$2,
  kState: kState$1,
  kHasBeenDecorated: kHasBeenDecorated$1
} = symbols$1;
const {
  FST_ERR_DEC_ALREADY_PRESENT,
  FST_ERR_DEC_MISSING_DEPENDENCY,
  FST_ERR_DEC_AFTER_START,
  FST_ERR_DEC_REFERENCE_TYPE,
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE
} = errorsExports;
function decorate(instance, name, fn, dependencies2) {
  if (Object.hasOwn(instance, name)) {
    throw new FST_ERR_DEC_ALREADY_PRESENT(name);
  }
  checkDependencies(instance, name, dependencies2);
  if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
    Object.defineProperty(instance, name, {
      get: fn.getter,
      set: fn.setter
    });
  } else {
    instance[name] = fn;
  }
}
function decorateConstructor(konstructor, name, fn, dependencies2) {
  const instance = konstructor.prototype;
  if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
    throw new FST_ERR_DEC_ALREADY_PRESENT(name);
  }
  konstructor[kHasBeenDecorated$1] = true;
  checkDependencies(konstructor, name, dependencies2);
  if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
    Object.defineProperty(instance, name, {
      get: fn.getter,
      set: fn.setter
    });
  } else if (typeof fn === "function") {
    instance[name] = fn;
  } else {
    konstructor.props.push({ key: name, value: fn });
  }
}
function checkReferenceType(name, fn) {
  if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
    throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn);
  }
}
function decorateFastify(name, fn, dependencies2) {
  assertNotStarted(this, name);
  decorate(this, name, fn, dependencies2);
  return this;
}
function checkExistence(instance, name) {
  if (name) {
    return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
  }
  return instance in this;
}
function hasKey(fn, name) {
  if (fn.props) {
    return fn.props.find(({ key }) => key === name);
  }
  return false;
}
function checkRequestExistence(name) {
  if (name && hasKey(this[kRequest$2], name)) return true;
  return checkExistence(this[kRequest$2].prototype, name);
}
function checkReplyExistence(name) {
  if (name && hasKey(this[kReply$2], name)) return true;
  return checkExistence(this[kReply$2].prototype, name);
}
function checkDependencies(instance, name, deps) {
  if (deps === void 0 || deps === null) {
    return;
  }
  if (!Array.isArray(deps)) {
    throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
  }
  for (let i = 0; i !== deps.length; ++i) {
    if (!checkExistence(instance, deps[i])) {
      throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
    }
  }
}
function decorateReply(name, fn, dependencies2) {
  assertNotStarted(this, name);
  checkReferenceType(name, fn);
  decorateConstructor(this[kReply$2], name, fn, dependencies2);
  return this;
}
function decorateRequest(name, fn, dependencies2) {
  assertNotStarted(this, name);
  checkReferenceType(name, fn);
  decorateConstructor(this[kRequest$2], name, fn, dependencies2);
  return this;
}
function assertNotStarted(instance, name) {
  if (instance[kState$1].started) {
    throw new FST_ERR_DEC_AFTER_START(name);
  }
}
var decorate_1 = {
  add: decorateFastify,
  exist: checkExistence,
  existRequest: checkRequestExistence,
  existReply: checkReplyExistence,
  decorateReply,
  decorateRequest
};
var contentTypeParser = { exports: {} };
var toadCache = {};
/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */
class FifoMap {
  constructor(max2 = 1e3, ttlInMsecs = 0) {
    if (isNaN(max2) || max2 < 0) {
      throw new Error("Invalid max value");
    }
    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
      throw new Error("Invalid ttl value");
    }
    this.first = null;
    this.items = /* @__PURE__ */ new Map();
    this.last = null;
    this.max = max2;
    this.ttl = ttlInMsecs;
  }
  get size() {
    return this.items.size;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map();
    this.first = null;
    this.last = null;
  }
  delete(key) {
    if (this.items.has(key)) {
      const deletedItem = this.items.get(key);
      this.items.delete(key);
      if (deletedItem.prev !== null) {
        deletedItem.prev.next = deletedItem.next;
      }
      if (deletedItem.next !== null) {
        deletedItem.next.prev = deletedItem.prev;
      }
      if (this.first === deletedItem) {
        this.first = deletedItem.next;
      }
      if (this.last === deletedItem) {
        this.last = deletedItem.prev;
      }
    }
  }
  deleteMany(keys2) {
    for (var i = 0; i < keys2.length; i++) {
      this.delete(keys2[i]);
    }
  }
  evict() {
    if (this.size > 0) {
      const item = this.first;
      this.items.delete(item.key);
      if (this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
  }
  expiresAt(key) {
    if (this.items.has(key)) {
      return this.items.get(key).expiry;
    }
  }
  get(key) {
    if (this.items.has(key)) {
      const item = this.items.get(key);
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key);
        return;
      }
      return item.value;
    }
  }
  getMany(keys2) {
    const result = [];
    for (var i = 0; i < keys2.length; i++) {
      result.push(this.get(keys2[i]));
    }
    return result;
  }
  keys() {
    return this.items.keys();
  }
  set(key, value) {
    if (this.items.has(key)) {
      const item2 = this.items.get(key);
      item2.value = value;
      item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      return;
    }
    if (this.max > 0 && this.size === this.max) {
      this.evict();
    }
    const item = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key,
      prev: this.last,
      next: null,
      value
    };
    this.items.set(key, item);
    if (this.size === 1) {
      this.first = item;
    } else {
      this.last.next = item;
    }
    this.last = item;
  }
}
class LruMap {
  constructor(max2 = 1e3, ttlInMsecs = 0) {
    if (isNaN(max2) || max2 < 0) {
      throw new Error("Invalid max value");
    }
    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
      throw new Error("Invalid ttl value");
    }
    this.first = null;
    this.items = /* @__PURE__ */ new Map();
    this.last = null;
    this.max = max2;
    this.ttl = ttlInMsecs;
  }
  get size() {
    return this.items.size;
  }
  bumpLru(item) {
    if (this.last === item) {
      return;
    }
    const last = this.last;
    const next = item.next;
    const prev = item.prev;
    if (this.first === item) {
      this.first = next;
    }
    item.next = null;
    item.prev = last;
    last.next = item;
    if (prev !== null) {
      prev.next = next;
    }
    if (next !== null) {
      next.prev = prev;
    }
    this.last = item;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map();
    this.first = null;
    this.last = null;
  }
  delete(key) {
    if (this.items.has(key)) {
      const item = this.items.get(key);
      this.items.delete(key);
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      if (this.last === item) {
        this.last = item.prev;
      }
    }
  }
  deleteMany(keys2) {
    for (var i = 0; i < keys2.length; i++) {
      this.delete(keys2[i]);
    }
  }
  evict() {
    if (this.size > 0) {
      const item = this.first;
      this.items.delete(item.key);
      if (this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
  }
  expiresAt(key) {
    if (this.items.has(key)) {
      return this.items.get(key).expiry;
    }
  }
  get(key) {
    if (this.items.has(key)) {
      const item = this.items.get(key);
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key);
        return;
      }
      this.bumpLru(item);
      return item.value;
    }
  }
  getMany(keys2) {
    const result = [];
    for (var i = 0; i < keys2.length; i++) {
      result.push(this.get(keys2[i]));
    }
    return result;
  }
  keys() {
    return this.items.keys();
  }
  set(key, value) {
    if (this.items.has(key)) {
      const item2 = this.items.get(key);
      item2.value = value;
      item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      if (this.last !== item2) {
        this.bumpLru(item2);
      }
      return;
    }
    if (this.max > 0 && this.size === this.max) {
      this.evict();
    }
    const item = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key,
      prev: this.last,
      next: null,
      value
    };
    this.items.set(key, item);
    if (this.size === 1) {
      this.first = item;
    } else {
      this.last.next = item;
    }
    this.last = item;
  }
}
class LruObject {
  constructor(max2 = 1e3, ttlInMsecs = 0) {
    if (isNaN(max2) || max2 < 0) {
      throw new Error("Invalid max value");
    }
    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
      throw new Error("Invalid ttl value");
    }
    this.first = null;
    this.items = /* @__PURE__ */ Object.create(null);
    this.last = null;
    this.size = 0;
    this.max = max2;
    this.ttl = ttlInMsecs;
  }
  bumpLru(item) {
    if (this.last === item) {
      return;
    }
    const last = this.last;
    const next = item.next;
    const prev = item.prev;
    if (this.first === item) {
      this.first = next;
    }
    item.next = null;
    item.prev = last;
    last.next = item;
    if (prev !== null) {
      prev.next = next;
    }
    if (next !== null) {
      next.prev = prev;
    }
    this.last = item;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null);
    this.first = null;
    this.last = null;
    this.size = 0;
  }
  delete(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item = this.items[key];
      delete this.items[key];
      this.size--;
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      if (this.last === item) {
        this.last = item.prev;
      }
    }
  }
  deleteMany(keys2) {
    for (var i = 0; i < keys2.length; i++) {
      this.delete(keys2[i]);
    }
  }
  evict() {
    if (this.size > 0) {
      const item = this.first;
      delete this.items[item.key];
      if (--this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
  }
  expiresAt(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      return this.items[key].expiry;
    }
  }
  get(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item = this.items[key];
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key);
        return;
      }
      this.bumpLru(item);
      return item.value;
    }
  }
  getMany(keys2) {
    const result = [];
    for (var i = 0; i < keys2.length; i++) {
      result.push(this.get(keys2[i]));
    }
    return result;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(key, value) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item2 = this.items[key];
      item2.value = value;
      item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      if (this.last !== item2) {
        this.bumpLru(item2);
      }
      return;
    }
    if (this.max > 0 && this.size === this.max) {
      this.evict();
    }
    const item = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key,
      prev: this.last,
      next: null,
      value
    };
    this.items[key] = item;
    if (++this.size === 1) {
      this.first = item;
    } else {
      this.last.next = item;
    }
    this.last = item;
  }
}
class HitStatisticsRecord {
  constructor() {
    this.records = {};
  }
  initForCache(cacheId, currentTimeStamp) {
    this.records[cacheId] = {
      [currentTimeStamp]: {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      }
    };
  }
  resetForCache(cacheId) {
    for (let key of Object.keys(this.records[cacheId])) {
      this.records[cacheId][key] = {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      };
    }
  }
  getStatistics() {
    return this.records;
  }
}
function getTimestamp(date) {
  return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
}
class HitStatistics {
  constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
    this.cacheId = cacheId;
    this.statisticTtlInHours = statisticTtlInHours;
    this.collectionStart = /* @__PURE__ */ new Date();
    this.currentTimeStamp = getTimestamp(this.collectionStart);
    this.records = globalStatisticsRecord || new HitStatisticsRecord();
    this.records.initForCache(this.cacheId, this.currentTimeStamp);
  }
  get currentRecord() {
    if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
      this.records.records[this.cacheId][this.currentTimeStamp] = {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        sets: 0,
        invalidateOne: 0,
        invalidateAll: 0
      };
    }
    return this.records.records[this.cacheId][this.currentTimeStamp];
  }
  hoursPassed() {
    return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
  }
  addHit() {
    this.archiveIfNeeded();
    this.currentRecord.hits++;
  }
  addFalsyHit() {
    this.archiveIfNeeded();
    this.currentRecord.falsyHits++;
  }
  addEmptyHit() {
    this.archiveIfNeeded();
    this.currentRecord.emptyHits++;
  }
  addMiss() {
    this.archiveIfNeeded();
    this.currentRecord.misses++;
  }
  addEviction() {
    this.archiveIfNeeded();
    this.currentRecord.evictions++;
  }
  setCacheSize(currentSize) {
    this.archiveIfNeeded();
    this.currentRecord.cacheSize = currentSize;
  }
  addExpiration() {
    this.archiveIfNeeded();
    this.currentRecord.expirations++;
  }
  addSet() {
    this.archiveIfNeeded();
    this.currentRecord.sets++;
  }
  addInvalidateOne() {
    this.archiveIfNeeded();
    this.currentRecord.invalidateOne++;
  }
  addInvalidateAll() {
    this.archiveIfNeeded();
    this.currentRecord.invalidateAll++;
  }
  getStatistics() {
    return this.records.getStatistics();
  }
  archiveIfNeeded() {
    if (this.hoursPassed() >= this.statisticTtlInHours) {
      this.collectionStart = /* @__PURE__ */ new Date();
      this.currentTimeStamp = getTimestamp(this.collectionStart);
      this.records.initForCache(this.cacheId, this.currentTimeStamp);
    }
  }
}
class LruObjectHitStatistics extends LruObject {
  constructor(max2, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
    super(max2 || 1e3, ttlInMsecs || 0);
    if (!cacheId) {
      throw new Error("Cache id is mandatory");
    }
    this.hitStatistics = new HitStatistics(
      cacheId,
      statisticTtlInHours !== void 0 ? statisticTtlInHours : 24,
      globalStatisticsRecord
    );
  }
  getStatistics() {
    return this.hitStatistics.getStatistics();
  }
  set(key, value) {
    super.set(key, value);
    this.hitStatistics.addSet();
    this.hitStatistics.setCacheSize(this.size);
  }
  evict() {
    super.evict();
    this.hitStatistics.addEviction();
    this.hitStatistics.setCacheSize(this.size);
  }
  delete(key, isExpiration = false) {
    super.delete(key);
    if (!isExpiration) {
      this.hitStatistics.addInvalidateOne();
    }
    this.hitStatistics.setCacheSize(this.size);
  }
  clear() {
    super.clear();
    this.hitStatistics.addInvalidateAll();
    this.hitStatistics.setCacheSize(this.size);
  }
  get(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item = this.items[key];
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key, true);
        this.hitStatistics.addExpiration();
        return;
      }
      this.bumpLru(item);
      if (!item.value) {
        this.hitStatistics.addFalsyHit();
      }
      if (item.value === void 0 || item.value === null || item.value === "") {
        this.hitStatistics.addEmptyHit();
      }
      this.hitStatistics.addHit();
      return item.value;
    }
    this.hitStatistics.addMiss();
  }
}
class FifoObject {
  constructor(max2 = 1e3, ttlInMsecs = 0) {
    if (isNaN(max2) || max2 < 0) {
      throw new Error("Invalid max value");
    }
    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
      throw new Error("Invalid ttl value");
    }
    this.first = null;
    this.items = /* @__PURE__ */ Object.create(null);
    this.last = null;
    this.size = 0;
    this.max = max2;
    this.ttl = ttlInMsecs;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null);
    this.first = null;
    this.last = null;
    this.size = 0;
  }
  delete(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const deletedItem = this.items[key];
      delete this.items[key];
      this.size--;
      if (deletedItem.prev !== null) {
        deletedItem.prev.next = deletedItem.next;
      }
      if (deletedItem.next !== null) {
        deletedItem.next.prev = deletedItem.prev;
      }
      if (this.first === deletedItem) {
        this.first = deletedItem.next;
      }
      if (this.last === deletedItem) {
        this.last = deletedItem.prev;
      }
    }
  }
  deleteMany(keys2) {
    for (var i = 0; i < keys2.length; i++) {
      this.delete(keys2[i]);
    }
  }
  evict() {
    if (this.size > 0) {
      const item = this.first;
      delete this.items[item.key];
      if (--this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
  }
  expiresAt(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      return this.items[key].expiry;
    }
  }
  get(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item = this.items[key];
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key);
        return;
      }
      return item.value;
    }
  }
  getMany(keys2) {
    const result = [];
    for (var i = 0; i < keys2.length; i++) {
      result.push(this.get(keys2[i]));
    }
    return result;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(key, value) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item2 = this.items[key];
      item2.value = value;
      item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      return;
    }
    if (this.max > 0 && this.size === this.max) {
      this.evict();
    }
    const item = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key,
      prev: this.last,
      next: null,
      value
    };
    this.items[key] = item;
    if (++this.size === 1) {
      this.first = item;
    } else {
      this.last.next = item;
    }
    this.last = item;
  }
}
toadCache.Fifo = FifoObject;
toadCache.FifoMap = FifoMap;
toadCache.FifoObject = FifoObject;
toadCache.HitStatisticsRecord = HitStatisticsRecord;
toadCache.Lru = LruObject;
toadCache.LruHitStatistics = LruObjectHitStatistics;
toadCache.LruMap = LruMap;
toadCache.LruObject = LruObject;
toadCache.LruObjectHitStatistics = LruObjectHitStatistics;
var secureJsonParse = { exports: {} };
const hasBuffer = typeof Buffer !== "undefined";
const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function _parse(text, reviver, options) {
  if (options == null) {
    if (reviver !== null && typeof reviver === "object") {
      options = reviver;
      reviver = void 0;
    }
  }
  if (hasBuffer && Buffer.isBuffer(text)) {
    text = text.toString();
  }
  if (text && text.charCodeAt(0) === 65279) {
    text = text.slice(1);
  }
  const obj = JSON.parse(text, reviver);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  const protoAction = options && options.protoAction || "error";
  const constructorAction = options && options.constructorAction || "error";
  if (protoAction === "ignore" && constructorAction === "ignore") {
    return obj;
  }
  if (protoAction !== "ignore" && constructorAction !== "ignore") {
    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
      return obj;
    }
  } else if (protoAction !== "ignore" && constructorAction === "ignore") {
    if (suspectProtoRx.test(text) === false) {
      return obj;
    }
  } else {
    if (suspectConstructorRx.test(text) === false) {
      return obj;
    }
  }
  return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
}
function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node2 of nodes) {
      if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node2, "__proto__")) {
        if (safe === true) {
          return null;
        } else if (protoAction === "error") {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        delete node2.__proto__;
      }
      if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node2, "constructor") && Object.prototype.hasOwnProperty.call(node2.constructor, "prototype")) {
        if (safe === true) {
          return null;
        } else if (constructorAction === "error") {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        delete node2.constructor;
      }
      for (const key in node2) {
        const value = node2[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function parse$c(text, reviver, options) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text, reviver, options);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function safeParse(text, reviver) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text, reviver, { safe: true });
  } catch (_e) {
    return null;
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
secureJsonParse.exports = parse$c;
secureJsonParse.exports.default = parse$c;
secureJsonParse.exports.parse = parse$c;
secureJsonParse.exports.safeParse = safeParse;
secureJsonParse.exports.scan = filter;
var secureJsonParseExports = secureJsonParse.exports;
(function(module) {
  const { AsyncResource } = require$$0$8;
  const { FifoMap: Fifo } = toadCache;
  const { parse: secureJsonParse2 } = secureJsonParseExports;
  const {
    kDefaultJsonParse,
    kContentTypeParser: kContentTypeParser2,
    kBodyLimit: kBodyLimit2,
    kRequestPayloadStream: kRequestPayloadStream2,
    kState: kState2,
    kTestInternals,
    kReplyIsError: kReplyIsError2,
    kRouteContext: kRouteContext2
  } = symbols$1;
  const {
    FST_ERR_CTP_INVALID_TYPE,
    FST_ERR_CTP_EMPTY_TYPE,
    FST_ERR_CTP_ALREADY_PRESENT,
    FST_ERR_CTP_INVALID_HANDLER,
    FST_ERR_CTP_INVALID_PARSE_TYPE,
    FST_ERR_CTP_BODY_TOO_LARGE,
    FST_ERR_CTP_INVALID_MEDIA_TYPE,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH,
    FST_ERR_CTP_EMPTY_JSON_BODY,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED
  } = errorsExports;
  const { FSTSEC001: FSTSEC0012 } = warnings;
  function ContentTypeParser2(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
    this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
    this.customParsers = /* @__PURE__ */ new Map();
    this.customParsers.set("application/json", new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
    this.customParsers.set("text/plain", new Parser(true, false, bodyLimit, defaultPlainTextParser));
    this.parserList = ["application/json", "text/plain"];
    this.parserRegExpList = [];
    this.cache = new Fifo(100);
  }
  ContentTypeParser2.prototype.add = function(contentType, opts, parserFn) {
    const contentTypeIsString = typeof contentType === "string";
    if (contentTypeIsString) {
      contentType = contentType.trim().toLowerCase();
      if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE();
    } else if (!(contentType instanceof RegExp)) {
      throw new FST_ERR_CTP_INVALID_TYPE();
    }
    if (typeof parserFn !== "function") {
      throw new FST_ERR_CTP_INVALID_HANDLER();
    }
    if (this.existingParser(contentType)) {
      throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
    }
    if (opts.parseAs !== void 0) {
      if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
        throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
      }
    }
    const parser = new Parser(
      opts.parseAs === "string",
      opts.parseAs === "buffer",
      opts.bodyLimit,
      parserFn
    );
    if (contentType === "*") {
      this.customParsers.set("", parser);
    } else {
      if (contentTypeIsString) {
        this.parserList.unshift(contentType);
        this.customParsers.set(contentType, parser);
      } else {
        validateRegExp(contentType);
        this.parserRegExpList.unshift(contentType);
        this.customParsers.set(contentType.toString(), parser);
      }
    }
  };
  ContentTypeParser2.prototype.hasParser = function(contentType) {
    if (typeof contentType === "string") {
      contentType = contentType.trim().toLowerCase();
    } else {
      if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
      contentType = contentType.toString();
    }
    return this.customParsers.has(contentType);
  };
  ContentTypeParser2.prototype.existingParser = function(contentType) {
    if (contentType === "application/json" && this.customParsers.has(contentType)) {
      return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse];
    }
    if (contentType === "text/plain" && this.customParsers.has(contentType)) {
      return this.customParsers.get(contentType).fn !== defaultPlainTextParser;
    }
    return this.hasParser(contentType);
  };
  ContentTypeParser2.prototype.getParser = function(contentType) {
    let parser = this.customParsers.get(contentType);
    if (parser !== void 0) return parser;
    parser = this.cache.get(contentType);
    if (parser !== void 0) return parser;
    const caseInsensitiveContentType = contentType.toLowerCase();
    for (let i = 0; i !== this.parserList.length; ++i) {
      const parserListItem = this.parserList[i];
      if (caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem && (caseInsensitiveContentType.length === parserListItem.length || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32)) {
        parser = this.customParsers.get(parserListItem);
        this.cache.set(contentType, parser);
        return parser;
      }
    }
    for (let j = 0; j !== this.parserRegExpList.length; ++j) {
      const parserRegExp = this.parserRegExpList[j];
      if (parserRegExp.test(contentType)) {
        parser = this.customParsers.get(parserRegExp.toString());
        this.cache.set(contentType, parser);
        return parser;
      }
    }
    return this.customParsers.get("");
  };
  ContentTypeParser2.prototype.removeAll = function() {
    this.customParsers = /* @__PURE__ */ new Map();
    this.parserRegExpList = [];
    this.parserList = [];
    this.cache = new Fifo(100);
  };
  ContentTypeParser2.prototype.remove = function(contentType) {
    let parsers;
    if (typeof contentType === "string") {
      contentType = contentType.trim().toLowerCase();
      parsers = this.parserList;
    } else {
      if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
      contentType = contentType.toString();
      parsers = this.parserRegExpList;
    }
    const removed = this.customParsers.delete(contentType);
    const idx = parsers.findIndex((ct) => ct.toString() === contentType);
    if (idx > -1) {
      parsers.splice(idx, 1);
    }
    return removed || idx > -1;
  };
  ContentTypeParser2.prototype.run = function(contentType, handler, request2, reply2) {
    const parser = this.getParser(contentType);
    if (parser === void 0) {
      if (request2.is404) {
        handler(request2, reply2);
      } else {
        reply2.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || void 0));
      }
      return;
    }
    const resource = new AsyncResource("content-type-parser:run", request2);
    if (parser.asString === true || parser.asBuffer === true) {
      rawBody(
        request2,
        reply2,
        reply2[kRouteContext2]._parserOptions,
        parser,
        done
      );
    } else {
      const result = parser.fn(request2, request2[kRequestPayloadStream2], done);
      if (result && typeof result.then === "function") {
        result.then((body) => done(null, body), done);
      }
    }
    function done(error2, body) {
      resource.runInAsyncScope(() => {
        resource.emitDestroy();
        if (error2) {
          reply2[kReplyIsError2] = true;
          reply2.send(error2);
        } else {
          request2.body = body;
          handler(request2, reply2);
        }
      });
    }
  };
  function rawBody(request2, reply2, options, parser, done) {
    const asString = parser.asString;
    const limit2 = options.limit === null ? parser.bodyLimit : options.limit;
    const contentLength = Number(request2.headers["content-length"]);
    if (contentLength > limit2) {
      reply2.header("connection", "close");
      reply2.send(new FST_ERR_CTP_BODY_TOO_LARGE());
      return;
    }
    let receivedLength = 0;
    let body = asString === true ? "" : [];
    const payload = request2[kRequestPayloadStream2] || request2.raw;
    if (asString === true) {
      payload.setEncoding("utf8");
    }
    payload.on("data", onData);
    payload.on("end", onEnd);
    payload.on("error", onEnd);
    payload.resume();
    function onData(chunk) {
      receivedLength += chunk.length;
      const { receivedEncodedLength = 0 } = payload;
      if (receivedLength > limit2 || receivedEncodedLength > limit2) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        reply2.send(new FST_ERR_CTP_BODY_TOO_LARGE());
        return;
      }
      if (asString === true) {
        body += chunk;
      } else {
        body.push(chunk);
      }
    }
    function onEnd(err2) {
      payload.removeListener("data", onData);
      payload.removeListener("end", onEnd);
      payload.removeListener("error", onEnd);
      if (err2 !== void 0) {
        if (!(typeof err2.statusCode === "number" && err2.statusCode >= 400)) {
          err2.statusCode = 400;
        }
        reply2[kReplyIsError2] = true;
        reply2.code(err2.statusCode).send(err2);
        return;
      }
      if (asString === true) {
        receivedLength = Buffer.byteLength(body);
      }
      if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
        reply2.header("connection", "close");
        reply2.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
        return;
      }
      if (asString === false) {
        body = Buffer.concat(body);
      }
      const result = parser.fn(request2, body, done);
      if (result && typeof result.then === "function") {
        result.then((body2) => done(null, body2), done);
      }
    }
  }
  function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
    return defaultJsonParser;
    function defaultJsonParser(req2, body, done) {
      if (body.length === 0) {
        done(new FST_ERR_CTP_EMPTY_JSON_BODY(), void 0);
        return;
      }
      try {
        done(null, secureJsonParse2(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning }));
      } catch (err2) {
        err2.statusCode = 400;
        done(err2, void 0);
      }
    }
  }
  function defaultPlainTextParser(req2, body, done) {
    done(null, body);
  }
  function Parser(asString, asBuffer, bodyLimit, fn) {
    this.asString = asString;
    this.asBuffer = asBuffer;
    this.bodyLimit = bodyLimit;
    this.fn = fn;
  }
  function buildContentTypeParser(c) {
    const contentTypeParser2 = new ContentTypeParser2();
    contentTypeParser2[kDefaultJsonParse] = c[kDefaultJsonParse];
    contentTypeParser2.customParsers = new Map(c.customParsers.entries());
    contentTypeParser2.parserList = c.parserList.slice();
    contentTypeParser2.parserRegExpList = c.parserRegExpList.slice();
    return contentTypeParser2;
  }
  function addContentTypeParser(contentType, opts, parser) {
    if (this[kState2].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
    }
    if (typeof opts === "function") {
      parser = opts;
      opts = {};
    }
    if (!opts) opts = {};
    if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit2];
    if (Array.isArray(contentType)) {
      contentType.forEach((type2) => this[kContentTypeParser2].add(type2, opts, parser));
    } else {
      this[kContentTypeParser2].add(contentType, opts, parser);
    }
    return this;
  }
  function hasContentTypeParser(contentType) {
    return this[kContentTypeParser2].hasParser(contentType);
  }
  function removeContentTypeParser(contentType) {
    if (this[kState2].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
    }
    if (Array.isArray(contentType)) {
      for (const type2 of contentType) {
        this[kContentTypeParser2].remove(type2);
      }
    } else {
      this[kContentTypeParser2].remove(contentType);
    }
  }
  function removeAllContentTypeParsers() {
    if (this[kState2].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
    }
    this[kContentTypeParser2].removeAll();
  }
  function validateRegExp(regexp) {
    if (regexp.source[0] !== "^" && regexp.source.includes(";?") === false) {
      FSTSEC0012(regexp.source);
    }
  }
  module.exports = ContentTypeParser2;
  module.exports.helpers = {
    buildContentTypeParser,
    addContentTypeParser,
    hasContentTypeParser,
    removeContentTypeParser,
    removeAllContentTypeParsers
  };
  module.exports.defaultParsers = {
    getDefaultJsonParser,
    defaultTextParser: defaultPlainTextParser
  };
  module.exports[kTestInternals] = { rawBody };
})(contentTypeParser);
var contentTypeParserExports = contentTypeParser.exports;
var fastJsonStringifyCompiler = { exports: {} };
var standalone$3 = {};
var fastJsonStringify$1 = { exports: {} };
var dist$3 = {};
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!bar.has(tmp)) return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}
dist$3.dequal = dequal;
const { dequal: deepEqual$4 } = dist$3;
const jsonSchemaRefSymbol = Symbol.for("json-schema-ref");
let RefResolver$1 = (_a = class {
  constructor(opts = {}) {
    __privateAdd(this, _RefResolver_instances);
    __privateAdd(this, _schemas);
    __privateAdd(this, _derefSchemas);
    __privateAdd(this, _insertRefSymbol);
    __privateAdd(this, _allowEqualDuplicates);
    __privateAdd(this, _cloneSchemaWithoutRefs);
    __privateSet(this, _schemas, {});
    __privateSet(this, _derefSchemas, {});
    __privateSet(this, _insertRefSymbol, opts.insertRefSymbol ?? false);
    __privateSet(this, _allowEqualDuplicates, opts.allowEqualDuplicates ?? true);
    __privateSet(this, _cloneSchemaWithoutRefs, opts.cloneSchemaWithoutRefs ?? false);
  }
  addSchema(schema2, rootSchemaId, isRootSchema = true) {
    if (isRootSchema) {
      if (schema2.$id !== void 0 && schema2.$id.charAt(0) !== "#") {
        rootSchemaId = schema2.$id;
      } else {
        __privateMethod(this, _RefResolver_instances, insertSchemaBySchemaId_fn).call(this, schema2, rootSchemaId);
      }
    }
    const schemaId = schema2.$id;
    if (schemaId !== void 0 && typeof schemaId === "string") {
      if (schemaId.charAt(0) === "#") {
        __privateMethod(this, _RefResolver_instances, insertSchemaByAnchor_fn).call(this, schema2, rootSchemaId, schemaId);
      } else {
        __privateMethod(this, _RefResolver_instances, insertSchemaBySchemaId_fn).call(this, schema2, schemaId);
        rootSchemaId = schemaId;
      }
    }
    const ref2 = schema2.$ref;
    if (ref2 !== void 0 && typeof ref2 === "string") {
      const { refSchemaId, refJsonPointer } = __privateMethod(this, _RefResolver_instances, parseSchemaRef_fn).call(this, ref2, rootSchemaId);
      __privateGet(this, _schemas)[rootSchemaId].refs.push({
        schemaId: refSchemaId,
        jsonPointer: refJsonPointer
      });
    }
    for (const key in schema2) {
      if (typeof schema2[key] === "object" && schema2[key] !== null) {
        this.addSchema(schema2[key], rootSchemaId, false);
      }
    }
  }
  getSchema(schemaId, jsonPointer = "#") {
    const schema2 = __privateGet(this, _schemas)[schemaId];
    if (schema2 === void 0) {
      throw new Error(
        `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
      );
    }
    if (schema2.anchors[jsonPointer] !== void 0) {
      return schema2.anchors[jsonPointer];
    }
    return getDataByJSONPointer(schema2.schema, jsonPointer);
  }
  hasSchema(schemaId) {
    return __privateGet(this, _schemas)[schemaId] !== void 0;
  }
  getSchemaRefs(schemaId) {
    const schema2 = __privateGet(this, _schemas)[schemaId];
    if (schema2 === void 0) {
      throw new Error(`Schema with id "${schemaId}" is not found.`);
    }
    return schema2.refs;
  }
  getSchemaDependencies(schemaId, dependencies2 = {}) {
    const schema2 = __privateGet(this, _schemas)[schemaId];
    for (const ref2 of schema2.refs) {
      const dependencySchemaId = ref2.schemaId;
      if (dependencySchemaId === schemaId || dependencies2[dependencySchemaId] !== void 0) continue;
      dependencies2[dependencySchemaId] = this.getSchema(dependencySchemaId);
      this.getSchemaDependencies(dependencySchemaId, dependencies2);
    }
    return dependencies2;
  }
  derefSchema(schemaId) {
    if (__privateGet(this, _derefSchemas)[schemaId] !== void 0) return;
    const schema2 = __privateGet(this, _schemas)[schemaId];
    if (schema2 === void 0) {
      throw new Error(`Schema with id "${schemaId}" is not found.`);
    }
    if (!__privateGet(this, _cloneSchemaWithoutRefs) && schema2.refs.length === 0) {
      __privateGet(this, _derefSchemas)[schemaId] = {
        schema: schema2.schema,
        anchors: schema2.anchors
      };
    }
    const refs = [];
    __privateMethod(this, _RefResolver_instances, addDerefSchema_fn).call(this, schema2.schema, schemaId, true, refs);
    const dependencies2 = this.getSchemaDependencies(schemaId);
    for (const schemaId2 in dependencies2) {
      const schema3 = dependencies2[schemaId2];
      __privateMethod(this, _RefResolver_instances, addDerefSchema_fn).call(this, schema3, schemaId2, true, refs);
    }
    for (const ref2 of refs) {
      const {
        refSchemaId,
        refJsonPointer
      } = __privateMethod(this, _RefResolver_instances, parseSchemaRef_fn).call(this, ref2.ref, ref2.sourceSchemaId);
      const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
      if (targetSchema === null) {
        throw new Error(
          `Cannot resolve ref "${ref2.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
        );
      }
      ref2.targetSchema = targetSchema;
      ref2.targetSchemaId = refSchemaId;
    }
    for (const ref2 of refs) {
      __privateMethod(this, _RefResolver_instances, resolveRef_fn).call(this, ref2, refs);
    }
  }
  getDerefSchema(schemaId, jsonPointer = "#") {
    let derefSchema = __privateGet(this, _derefSchemas)[schemaId];
    if (derefSchema === void 0) {
      this.derefSchema(schemaId);
      derefSchema = __privateGet(this, _derefSchemas)[schemaId];
    }
    if (derefSchema.anchors[jsonPointer] !== void 0) {
      return derefSchema.anchors[jsonPointer];
    }
    return getDataByJSONPointer(derefSchema.schema, jsonPointer);
  }
}, _schemas = new WeakMap(), _derefSchemas = new WeakMap(), _insertRefSymbol = new WeakMap(), _allowEqualDuplicates = new WeakMap(), _cloneSchemaWithoutRefs = new WeakMap(), _RefResolver_instances = new WeakSet(), parseSchemaRef_fn = function(ref2, schemaId) {
  const sharpIndex = ref2.indexOf("#");
  if (sharpIndex === -1) {
    return { refSchemaId: ref2, refJsonPointer: "#" };
  }
  if (sharpIndex === 0) {
    return { refSchemaId: schemaId, refJsonPointer: ref2 };
  }
  return {
    refSchemaId: ref2.slice(0, sharpIndex),
    refJsonPointer: ref2.slice(sharpIndex)
  };
}, addDerefSchema_fn = function(schema2, rootSchemaId, isRootSchema, refs = []) {
  const derefSchema = Array.isArray(schema2) ? [...schema2] : { ...schema2 };
  if (isRootSchema) {
    if (schema2.$id !== void 0 && schema2.$id.charAt(0) !== "#") {
      rootSchemaId = schema2.$id;
    } else {
      __privateMethod(this, _RefResolver_instances, insertDerefSchemaBySchemaId_fn).call(this, derefSchema, rootSchemaId);
    }
  }
  const schemaId = derefSchema.$id;
  if (schemaId !== void 0 && typeof schemaId === "string") {
    if (schemaId.charAt(0) === "#") {
      __privateMethod(this, _RefResolver_instances, insertDerefSchemaByAnchor_fn).call(this, derefSchema, rootSchemaId, schemaId);
    } else {
      __privateMethod(this, _RefResolver_instances, insertDerefSchemaBySchemaId_fn).call(this, derefSchema, schemaId);
      rootSchemaId = schemaId;
    }
  }
  if (derefSchema.$ref !== void 0) {
    refs.push({
      ref: derefSchema.$ref,
      sourceSchemaId: rootSchemaId,
      sourceSchema: derefSchema
    });
  }
  for (const key in derefSchema) {
    const value = derefSchema[key];
    if (typeof value === "object" && value !== null) {
      derefSchema[key] = __privateMethod(this, _RefResolver_instances, addDerefSchema_fn).call(this, value, rootSchemaId, false, refs);
    }
  }
  return derefSchema;
}, resolveRef_fn = function(ref2, refs) {
  const { sourceSchema, targetSchema } = ref2;
  if (!sourceSchema.$ref) return;
  if (__privateGet(this, _insertRefSymbol)) {
    sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
  }
  delete sourceSchema.$ref;
  if (targetSchema.$ref) {
    const targetSchemaRef = refs.find((ref3) => ref3.sourceSchema === targetSchema);
    __privateMethod(this, _RefResolver_instances, resolveRef_fn).call(this, targetSchemaRef, refs);
  }
  for (const key in targetSchema) {
    if (key === "$id") continue;
    if (sourceSchema[key] !== void 0) {
      if (deepEqual$4(sourceSchema[key], targetSchema[key])) continue;
      throw new Error(
        `Cannot resolve ref "${ref2.ref}". Property "${key}" already exists in schema "${ref2.sourceSchemaId}".`
      );
    }
    sourceSchema[key] = targetSchema[key];
  }
  ref2.isResolved = true;
}, insertSchemaBySchemaId_fn = function(schema2, schemaId) {
  const foundSchema = __privateGet(this, _schemas)[schemaId];
  if (foundSchema !== void 0) {
    if (__privateGet(this, _allowEqualDuplicates) && deepEqual$4(schema2, foundSchema.schema)) return;
    throw new Error(`There is already another schema with id "${schemaId}".`);
  }
  __privateGet(this, _schemas)[schemaId] = { schema: schema2, anchors: {}, refs: [] };
}, insertSchemaByAnchor_fn = function(schema2, schemaId, anchor) {
  const { anchors } = __privateGet(this, _schemas)[schemaId];
  if (anchors[anchor] !== void 0) {
    throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`);
  }
  anchors[anchor] = schema2;
}, insertDerefSchemaBySchemaId_fn = function(schema2, schemaId) {
  const foundSchema = __privateGet(this, _derefSchemas)[schemaId];
  if (foundSchema !== void 0) return;
  __privateGet(this, _derefSchemas)[schemaId] = { schema: schema2, anchors: {} };
}, insertDerefSchemaByAnchor_fn = function(schema2, schemaId, anchor) {
  const { anchors } = __privateGet(this, _derefSchemas)[schemaId];
  anchors[anchor] = schema2;
}, _a);
function getDataByJSONPointer(data, jsonPointer) {
  const parts = jsonPointer.split("/");
  let current = data;
  for (const part of parts) {
    if (part === "" || part === "#") continue;
    if (typeof current !== "object" || current === null) {
      return null;
    }
    current = current[part];
  }
  return current ?? null;
}
var jsonSchemaRefResolver = { RefResolver: RefResolver$1 };
var ajv = { exports: {} };
var core$3 = {};
var validate$2 = {};
var boolSchema = {};
var errors$3 = {};
var codegen = {};
var code$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a2;
      return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a2;
      return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports._ = _;
  const plus = new _Code("+");
  function str2(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str2;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res2 = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res2 !== void 0) {
          expr.splice(i - 1, 3, res2);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx2) {
    return new _Code(rx2.toString());
  }
  exports.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a2, _b;
      if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a2;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values2 = this._values) {
      return this._reduceValues(values2, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values2 = this._values, usedValues, getCode) {
      return this._reduceValues(values2, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values2, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values2) {
        const vs = values2[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode2 extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode2 {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode2 {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a2;
      this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async2) {
      super();
      this.name = name;
      this.args = args;
      this.async = async2;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode2 {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a2, _b;
      super.optimizeNodes();
      (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a2, _b;
      super.optimizeNames(names2, constants2);
      (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node2, forBody) {
      this._blockNode(node2);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node2 = new Return();
      this._blockNode(node2);
      this.code(value);
      if (node2.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node2 = new Try();
      this._blockNode(node2);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node2.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node2.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async2, funcBody) {
      this._blockNode(new Func(name, args, async2));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node2) {
      this._currNode.nodes.push(node2);
      return this;
    }
    _blockNode(node2) {
      this._currNode.nodes.push(node2);
      this._nodes.push(node2);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node2) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node2;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node2) {
      const ns = this._nodes;
      ns[ns.length - 1] = node2;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par(x)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
  }
})(codegen);
var util$9 = {};
Object.defineProperty(util$9, "__esModule", { value: true });
util$9.checkStrictMode = util$9.getErrorPath = util$9.Type = util$9.useFunc = util$9.setEvaluated = util$9.evaluatedPropsToName = util$9.mergeEvaluated = util$9.eachItem = util$9.unescapeJsonPointer = util$9.escapeJsonPointer = util$9.escapeFragment = util$9.unescapeFragment = util$9.schemaRefOrVal = util$9.schemaHasRulesButRef = util$9.schemaHasRules = util$9.checkUnknownRules = util$9.alwaysValidSchema = util$9.toHash = void 0;
const codegen_1$E = codegen;
const code_1$e = code$1;
function toHash(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util$9.toHash = toHash;
function alwaysValidSchema(it, schema2) {
  if (typeof schema2 == "boolean")
    return schema2;
  if (Object.keys(schema2).length === 0)
    return true;
  checkUnknownRules(it, schema2);
  return !schemaHasRules(schema2, it.self.RULES.all);
}
util$9.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema2 = it.schema) {
  const { opts, self: self2 } = it;
  if (!opts.strictSchema)
    return;
  if (typeof schema2 === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema2) {
    if (!rules2[key])
      checkStrictMode(it, `unknown keyword: "${key}"`);
  }
}
util$9.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema2, rules2) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (rules2[key])
      return true;
  return false;
}
util$9.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema2, RULES) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util$9.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
  if (!$data) {
    if (typeof schema2 == "number" || typeof schema2 == "boolean")
      return schema2;
    if (typeof schema2 == "string")
      return (0, codegen_1$E._)`${schema2}`;
  }
  return (0, codegen_1$E._)`${topSchemaRef}${schemaPath}${(0, codegen_1$E.getProperty)(keyword2)}`;
}
util$9.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str2) {
  return unescapeJsonPointer(decodeURIComponent(str2));
}
util$9.unescapeFragment = unescapeFragment;
function escapeFragment(str2) {
  return encodeURIComponent(escapeJsonPointer(str2));
}
util$9.escapeFragment = escapeFragment;
function escapeJsonPointer(str2) {
  if (typeof str2 == "number")
    return `${str2}`;
  return str2.replace(/~/g, "~0").replace(/\//g, "~1");
}
util$9.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str2) {
  return str2.replace(/~1/g, "/").replace(/~0/g, "~");
}
util$9.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
  if (Array.isArray(xs)) {
    for (const x of xs)
      f(x);
  } else {
    f(xs);
  }
}
util$9.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from, to, toName) => {
    const res2 = to === void 0 ? from : to instanceof codegen_1$E.Name ? (from instanceof codegen_1$E.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$E.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
    return toName === codegen_1$E.Name && !(res2 instanceof codegen_1$E.Name) ? resultToName(gen, res2) : res2;
  };
}
util$9.mergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$E._)`${to} !== true && ${from} !== undefined`, () => {
      gen.if((0, codegen_1$E._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$E._)`${to} || {}`).code((0, codegen_1$E._)`Object.assign(${to}, ${from})`));
    }),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$E._)`${to} !== true`, () => {
      if (from === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$E._)`${to} || {}`);
        setEvaluated(gen, to, from);
      }
    }),
    mergeValues: (from, to) => from === true ? true : { ...from, ...to },
    resultToName: evaluatedPropsToName
  }),
  items: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$E._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$E._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$E._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$E._)`${to} > ${from} ? ${to} : ${from}`)),
    mergeValues: (from, to) => from === true ? true : Math.max(from, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$E._)`{}`);
  if (ps !== void 0)
    setEvaluated(gen, props, ps);
  return props;
}
util$9.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
  Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$E._)`${props}${(0, codegen_1$E.getProperty)(p)}`, true));
}
util$9.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets[f.code] || (snippets[f.code] = new code_1$e._Code(f.code))
  });
}
util$9.useFunc = useFunc;
var Type$f;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type$f || (util$9.Type = Type$f = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$E.Name) {
    const isNumber2 = dataPropType === Type$f.Num;
    return jsPropertySyntax ? isNumber2 ? (0, codegen_1$E._)`"[" + ${dataProp} + "]"` : (0, codegen_1$E._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1$E._)`"/" + ${dataProp}` : (0, codegen_1$E._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$E.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util$9.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it.self.logger.warn(msg);
}
util$9.checkStrictMode = checkStrictMode;
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$D = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$D.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$D.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$D.Name("instancePath"),
  parentData: new codegen_1$D.Name("parentData"),
  parentDataProperty: new codegen_1$D.Name("parentDataProperty"),
  rootData: new codegen_1$D.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$D.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$D.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$D.Name("errors"),
  // counter of validation errors
  this: new codegen_1$D.Name("this"),
  // "globals"
  self: new codegen_1$D.Name("self"),
  scope: new codegen_1$D.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$D.Name("json"),
  jsonPos: new codegen_1$D.Name("jsonPos"),
  jsonLen: new codegen_1$D.Name("jsonLen"),
  jsonPart: new codegen_1$D.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util$9;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err2 = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err2, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err2}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err2}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_12._)`${err2}.schemaPath`, (0, codegen_12.str)`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_12._)`${err2}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err2}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err2 = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err2}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err2})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors$3);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors$3;
const codegen_1$C = codegen;
const names_1$9 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$9.default.data);
  } else {
    gen.assign((0, codegen_1$C._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a2;
  return schema2[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors$3;
const codegen_1$B = codegen;
const util_1$C = util$9;
var DataType;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema2) {
  const types2 = getJSONTypes(schema2.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema2.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema2.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema2.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types2) {
  const { gen, data, opts } = it;
  const coerceTo = coerceToTypes(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData(it, types2, coerceTo);
      else
        reportTypeError(it);
    });
  }
  return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData(it, types2, coerceTo) {
  const { gen, data, opts } = it;
  const dataType2 = gen.let("dataType", (0, codegen_1$B._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$B._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$B._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$B._)`${data}[0]`).assign(dataType2, (0, codegen_1$B._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$B._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError(it);
  gen.endIf();
  gen.if((0, codegen_1$B._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData(it, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$B._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$B._)`"" + ${data}`).elseIf((0, codegen_1$B._)`${data} === null`).assign(coerced, (0, codegen_1$B._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$B._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$B._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$B._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$B._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$B._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$B._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$B._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$B._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$B._)`[${data}]`);
    }
  }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$B._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$B._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
  const EQ = correct === DataType.Correct ? codegen_1$B.operators.EQ : codegen_1$B.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$B._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$B._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$B._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$B._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$B._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType.Correct ? cond : (0, codegen_1$B.not)(cond);
  function numCond(_cond = codegen_1$B.nil) {
    return (0, codegen_1$B.and)((0, codegen_1$B._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$B._)`isFinite(${data})` : codegen_1$B.nil);
  }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$C.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$B._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$B._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$B.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$B.and)(cond, checkDataType(t2, data, strictNums, correct));
  return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError$1 = {
  message: ({ schema: schema2 }) => `must be ${schema2}`,
  params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? (0, codegen_1$B._)`{type: ${schema2}}` : (0, codegen_1$B._)`{type: ${schemaValue}}`
};
function reportTypeError(it) {
  const cxt = getTypeErrorContext(it);
  (0, errors_1$2.reportError)(cxt, typeError$1);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
  const { gen, data, schema: schema2 } = it;
  const schemaCode = (0, util_1$C.schemaRefOrVal)(it, schema2, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema2.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema2,
    params: {},
    it
  };
}
var defaults$2 = {};
Object.defineProperty(defaults$2, "__esModule", { value: true });
defaults$2.assignDefaults = void 0;
const codegen_1$A = codegen;
const util_1$B = util$9;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults$2.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$A._)`${data}${(0, codegen_1$A.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$B.checkStrictMode)(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$A._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$A._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$A._)`${childData} = ${(0, codegen_1$A.stringify)(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$z = codegen;
const util_1$A = util$9;
const names_1$8 = names$1;
const util_2$1 = util$9;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$z._)`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$z.or)(...properties2.map((prop) => (0, codegen_1$z.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$z._)`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$z._)`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return (0, codegen_1$z._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$z._)`${data}${(0, codegen_1$z.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$z._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$z._)`${data}${(0, codegen_1$z.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$z.or)(cond, (0, codegen_1$z.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$A.alwaysValidSchema)(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context2, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$z._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$8.default.instancePath, (0, codegen_1$z.strConcat)(names_1$8.default.instancePath, errorPath)],
    [names_1$8.default.parentData, it.parentData],
    [names_1$8.default.parentDataProperty, it.parentDataProperty],
    [names_1$8.default.rootData, names_1$8.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$8.default.dynamicAnchors, names_1$8.default.dynamicAnchors]);
  const args = (0, codegen_1$z._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context2 !== codegen_1$z.nil ? (0, codegen_1$z._)`${func}.call(${context2}, ${args})` : (0, codegen_1$z._)`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$z._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u2 = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx2 = regExp(pattern2, u2);
  return gen.scopeValue("pattern", {
    key: rx2.toString(),
    ref: rx2,
    code: (0, codegen_1$z._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$z._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$A.Type.Num
      }, valid2);
      gen.if((0, codegen_1$z.not)(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => (0, util_1$A.alwaysValidSchema)(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$z._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$z.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$y = codegen;
const names_1$7 = names$1;
const code_1$d = code;
const errors_1$1 = errors$3;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$y.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a2;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$y._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1$y._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$y._)`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$y._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$y.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$y._)`await ` : codegen_1$y.nil) {
    const passCxt = it.opts.passContext ? names_1$7.default.this : names_1$7.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$y._)`${_await}${(0, code_1$d.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a3;
    gen.if((0, codegen_1$y.not)((_a3 = def2.valid) !== null && _a3 !== void 0 ? _a3 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$y._)`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$y._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$7.default.vErrors, (0, codegen_1$y._)`${names_1$7.default.vErrors} === null ? ${errs} : ${names_1$7.default.vErrors}.concat(${errs})`).assign(names_1$7.default.errors, (0, codegen_1$y._)`${names_1$7.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$y.stringify)(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$x = codegen;
const util_1$z = util$9;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$x._)`${it.schemaPath}${(0, codegen_1$x.getProperty)(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$x._)`${it.schemaPath}${(0, codegen_1$x.getProperty)(keyword2)}${(0, codegen_1$x.getProperty)(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1$z.escapeFragment)(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it;
    const nextData = gen.let("data", (0, codegen_1$x._)`${it.data}${(0, codegen_1$x.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$x.str)`${errorPath}${(0, util_1$z.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$x._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$x.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$2 = {};
var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor) return false;
    var length, i, keys2;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i])) return false;
      return true;
    }
    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (!equal(a[key], b[key])) return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str2) {
  return str2.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$2, "__esModule", { value: true });
resolve$2.getSchemaRefs = resolve$2.resolveUrl = resolve$2.normalizeId = resolve$2._getFullPath = resolve$2.getFullPath = resolve$2.inlineRef = void 0;
const util_1$y = util$9;
const equal$3 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef$1(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$2.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef$1(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef$1))
      return true;
    if (typeof sch == "object" && hasRef$1(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      (0, util_1$y.eachItem)(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(resolver, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId(id2);
  const p = resolver.parse(id2);
  return _getFullPath(resolver, p);
}
resolve$2.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
  const serialized = resolver.serialize(p);
  return serialized.split("#")[0] + "#";
}
resolve$2._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$2.normalizeId = normalizeId;
function resolveUrl$1(resolver, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver.resolve(baseId, id2);
}
resolve$2.resolveUrl = resolveUrl$1;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2, baseId) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema2[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$3(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$2.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate$2, "__esModule", { value: true });
validate$2.getData = validate$2.KeywordCxt = validate$2.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults$2;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$w = codegen;
const names_1$6 = names$1;
const resolve_1$2 = resolve$2;
const util_1$x = util$9;
const errors_1 = errors$3;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
validate$2.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$w._)`${names_1$6.default.data}, ${names_1$6.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$w._)`"use strict"; ${funcSourceUrl(schema2, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$w._)`${names_1$6.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$w._)`{${names_1$6.default.instancePath}="", ${names_1$6.default.parentData}, ${names_1$6.default.parentDataProperty}, ${names_1$6.default.rootData}=${names_1$6.default.data}${opts.dynamicRef ? (0, codegen_1$w._)`, ${names_1$6.default.dynamicAnchors}={}` : codegen_1$w.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$6.default.valCxt, () => {
    gen.var(names_1$6.default.instancePath, (0, codegen_1$w._)`${names_1$6.default.valCxt}.${names_1$6.default.instancePath}`);
    gen.var(names_1$6.default.parentData, (0, codegen_1$w._)`${names_1$6.default.valCxt}.${names_1$6.default.parentData}`);
    gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$w._)`${names_1$6.default.valCxt}.${names_1$6.default.parentDataProperty}`);
    gen.var(names_1$6.default.rootData, (0, codegen_1$w._)`${names_1$6.default.valCxt}.${names_1$6.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$w._)`${names_1$6.default.valCxt}.${names_1$6.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$6.default.instancePath, (0, codegen_1$w._)`""`);
    gen.var(names_1$6.default.parentData, (0, codegen_1$w._)`undefined`);
    gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$w._)`undefined`);
    gen.var(names_1$6.default.rootData, names_1$6.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$w._)`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts, gen } = it;
  validateFunction(it, () => {
    if (opts.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$6.default.vErrors, null);
    gen.let(names_1$6.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", (0, codegen_1$w._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$w._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$w._)`${it.evaluated}.props`, (0, codegen_1$w._)`undefined`));
  gen.if((0, codegen_1$w._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$w._)`${it.evaluated}.items`, (0, codegen_1$w._)`undefined`));
}
function funcSourceUrl(schema2, opts) {
  const schId = typeof schema2 == "object" && schema2[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$w._)`/*# sourceURL=${schId} */` : codegen_1$w.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts } = it;
  if (opts.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$6.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, (0, codegen_1$w._)`${errsCount} === ${names_1$6.default.errors}`);
}
function checkKeywords(it) {
  (0, util_1$x.checkUnknownRules)(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts, self: self2 } = it;
  if (schema2.$ref && opts.ignoreKeywordsWithRef && (0, util_1$x.schemaHasRulesButRef)(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts } = it;
  if (schema2.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$x.checkStrictMode)(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = (0, resolve_1$2.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts }) {
  const msg = schema2.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$w._)`${names_1$6.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$w.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$w._)`${names_1$6.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$w._)`${names_1$6.default.errors} === 0`, () => gen.return(names_1$6.default.data), () => gen.throw((0, codegen_1$w._)`new ${ValidationError2}(${names_1$6.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$w._)`${validateName}.errors`, names_1$6.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it);
    gen.return((0, codegen_1$w._)`${names_1$6.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$w.Name)
    gen.assign((0, codegen_1$w._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$w.Name)
    gen.assign((0, codegen_1$w._)`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$x.schemaHasRulesButRef)(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema2, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$w._)`${names_1$6.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it, types2);
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes(it, withTypes) {
  const ts = [];
  for (const t2 of it.dataTypes) {
    if (includesType(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it.dataTypes = ts;
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$x.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$x.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$6.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$w.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$w.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$w._)`${schemaCode} !== undefined && (${(0, codegen_1$w.or)(this.invalid$data(), condition)})`);
  }
  error(append2, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append2, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append2, errorPaths);
  }
  _error(append2, errorPaths) {
    (append2 ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$w.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$w.nil, $dataValid = codegen_1$w.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$w.or)((0, codegen_1$w._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$w.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$w.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return (0, codegen_1$w.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$w.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$w._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$w.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$w._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$w.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$x.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$x.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$w.Name));
      return true;
    }
  }
}
validate$2.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$6.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$6.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$w._)`${data}${(0, codegen_1$w.getProperty)((0, util_1$x.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$w._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate$2.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$2;
class MissingRefError extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$v = codegen;
const validation_error_1 = validation_error;
const names_1$5 = names$1;
const resolve_1 = resolve$2;
const util_1$w = util$9;
const validate_1$1 = validate$2;
class SchemaEnv {
  constructor(env) {
    var _a2;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env.schema == "object")
      schema2 = env.schema;
    this.schema = env.schema;
    this.schemaId = env.schemaId;
    this.root = env.root || this;
    this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema2 === null || schema2 === void 0 ? void 0 : schema2[env.schemaId || "$id"]);
    this.schemaPath = env.schemaPath;
    this.localRefs = env.localRefs;
    this.meta = env.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$v.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$v._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$5.default.data,
    parentData: names_1$5.default.parentData,
    parentDataProperty: names_1$5.default.parentDataProperty,
    dataNames: [names_1$5.default.data],
    dataPathArr: [codegen_1$v.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$v.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$v.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$v._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$5.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$5.default.self}`, `${names_1$5.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$v.Name ? void 0 : props,
        items: items2 instanceof codegen_1$v.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$v.Name,
        dynamicItems: items2 instanceof codegen_1$v.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$v.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef$1(root2, baseId, ref2) {
  var _a2;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root2.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$1.call(this, root2, ref2);
  if (_sch === void 0) {
    const schema2 = (_a2 = root2.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  if (_sch === void 0)
    return;
  return root2.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef$1;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$1(root2, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root2, ref2);
}
function resolveSchema(root2, ref2) {
  const p = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root2.baseId, void 0);
  if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root2);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root2, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root: root2 }) {
  var _a2;
  if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 === "boolean")
      return;
    const partSchema = schema2[(0, util_1$w.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema2 = partSchema;
    const schId = typeof schema2 === "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env;
  if (typeof schema2 != "boolean" && schema2.$ref && !(0, util_1$w.schemaHasRulesButRef)(schema2, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema2.$ref);
    env = resolveSchema.call(this, root2, $ref);
  }
  const { schemaId } = this.opts;
  env = env || new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  if (env.schema !== env.root.schema)
    return env;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$4 = "object";
const required$1 = [
  "$data"
];
const properties$3 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$4,
  required: required$1,
  properties: properties$3,
  additionalProperties: additionalProperties$1
};
var uri$2 = {};
var fastUri$3 = { exports: {} };
const HEX$2 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var scopedChars = {
  HEX: HEX$2
};
const { HEX: HEX$1 } = scopedChars;
const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
function normalizeIPv4$1(host) {
  if (findToken(host, ".") < 3) {
    return { host, isIPV4: false };
  }
  const matches = host.match(IPV4_REG) || [];
  const [address] = matches;
  if (address) {
    return { host: stripLeadingZeros(address, "."), isIPV4: true };
  } else {
    return { host, isIPV4: false };
  }
}
function stringArrayToHexStripped(input, keepZero = false) {
  let acc = "";
  let strip = true;
  for (const c of input) {
    if (HEX$1[c] === void 0) return void 0;
    if (c !== "0" && strip === true) strip = false;
    if (!strip) acc += c;
  }
  if (keepZero && acc.length === 0) acc = "0";
  return acc;
}
function getIPV6(input) {
  let tokenCount = 0;
  const output = { error: false, address: "", zone: "" };
  const address = [];
  const buffer = [];
  let isZone = false;
  let endipv6Encountered = false;
  let endIpv6 = false;
  function consume() {
    if (buffer.length) {
      if (isZone === false) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== void 0) {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
      }
      buffer.length = 0;
    }
    return true;
  }
  for (let i = 0; i < input.length; i++) {
    const cursor = input[i];
    if (cursor === "[" || cursor === "]") {
      continue;
    }
    if (cursor === ":") {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume()) {
        break;
      }
      tokenCount++;
      address.push(":");
      if (tokenCount > 7) {
        output.error = true;
        break;
      }
      if (i - 1 >= 0 && input[i - 1] === ":") {
        endipv6Encountered = true;
      }
      continue;
    } else if (cursor === "%") {
      if (!consume()) {
        break;
      }
      isZone = true;
    } else {
      buffer.push(cursor);
      continue;
    }
  }
  if (buffer.length) {
    if (isZone) {
      output.zone = buffer.join("");
    } else if (endIpv6) {
      address.push(buffer.join(""));
    } else {
      address.push(stringArrayToHexStripped(buffer));
    }
  }
  output.address = address.join("");
  return output;
}
function normalizeIPv6$1(host) {
  if (findToken(host, ":") < 2) {
    return { host, isIPV6: false };
  }
  const ipv6 = getIPV6(host);
  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += "%" + ipv6.zone;
      escapedHost += "%25" + ipv6.zone;
    }
    return { host: newHost, escapedHost, isIPV6: true };
  } else {
    return { host, isIPV6: false };
  }
}
function stripLeadingZeros(str2, token) {
  let out2 = "";
  let skip2 = true;
  const l = str2.length;
  for (let i = 0; i < l; i++) {
    const c = str2[i];
    if (c === "0" && skip2) {
      if (i + 1 <= l && str2[i + 1] === token || i + 1 === l) {
        out2 += c;
        skip2 = false;
      }
    } else {
      if (c === token) {
        skip2 = true;
      } else {
        skip2 = false;
      }
      out2 += c;
    }
  }
  return out2;
}
function findToken(str2, token) {
  let ind = 0;
  for (let i = 0; i < str2.length; i++) {
    if (str2[i] === token) ind++;
  }
  return ind;
}
const RDS1 = /^\.\.?\//u;
const RDS2 = /^\/\.(?:\/|$)/u;
const RDS3 = /^\/\.\.(?:\/|$)/u;
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
function removeDotSegments$1(input) {
  const output = [];
  while (input.length) {
    if (input.match(RDS1)) {
      input = input.replace(RDS1, "");
    } else if (input.match(RDS2)) {
      input = input.replace(RDS2, "/");
    } else if (input.match(RDS3)) {
      input = input.replace(RDS3, "/");
      output.pop();
    } else if (input === "." || input === "..") {
      input = "";
    } else {
      const im = input.match(RDS5);
      if (im) {
        const s = im[0];
        input = input.slice(s.length);
        output.push(s);
      } else {
        throw new Error("Unexpected dot segment condition");
      }
    }
  }
  return output.join("");
}
function normalizeComponentEncoding$1(components, esc) {
  const func = esc !== true ? escape : unescape;
  if (components.scheme !== void 0) {
    components.scheme = func(components.scheme);
  }
  if (components.userinfo !== void 0) {
    components.userinfo = func(components.userinfo);
  }
  if (components.host !== void 0) {
    components.host = func(components.host);
  }
  if (components.path !== void 0) {
    components.path = func(components.path);
  }
  if (components.query !== void 0) {
    components.query = func(components.query);
  }
  if (components.fragment !== void 0) {
    components.fragment = func(components.fragment);
  }
  return components;
}
function recomposeAuthority$1(components) {
  const uriTokens = [];
  if (components.userinfo !== void 0) {
    uriTokens.push(components.userinfo);
    uriTokens.push("@");
  }
  if (components.host !== void 0) {
    let host = unescape(components.host);
    const ipV4res = normalizeIPv4$1(host);
    if (ipV4res.isIPV4) {
      host = ipV4res.host;
    } else {
      const ipV6res = normalizeIPv6$1(ipV4res.host);
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`;
      } else {
        host = components.host;
      }
    }
    uriTokens.push(host);
  }
  if (typeof components.port === "number" || typeof components.port === "string") {
    uriTokens.push(":");
    uriTokens.push(String(components.port));
  }
  return uriTokens.length ? uriTokens.join("") : void 0;
}
var utils$5 = {
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  normalizeIPv4: normalizeIPv4$1,
  normalizeIPv6: normalizeIPv6$1
};
const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function isSecure(wsComponents) {
  return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
function httpParse(components) {
  if (!components.host) {
    components.error = components.error || "HTTP URIs must have a host.";
  }
  return components;
}
function httpSerialize(components) {
  const secure = String(components.scheme).toLowerCase() === "https";
  if (components.port === (secure ? 443 : 80) || components.port === "") {
    components.port = void 0;
  }
  if (!components.path) {
    components.path = "/";
  }
  return components;
}
function wsParse(wsComponents) {
  wsComponents.secure = isSecure(wsComponents);
  wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
  wsComponents.path = void 0;
  wsComponents.query = void 0;
  return wsComponents;
}
function wsSerialize(wsComponents) {
  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
    wsComponents.port = void 0;
  }
  if (typeof wsComponents.secure === "boolean") {
    wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
    wsComponents.secure = void 0;
  }
  if (wsComponents.resourceName) {
    const [path2, query] = wsComponents.resourceName.split("?");
    wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
    wsComponents.query = query;
    wsComponents.resourceName = void 0;
  }
  wsComponents.fragment = void 0;
  return wsComponents;
}
function urnParse(urnComponents, options) {
  if (!urnComponents.path) {
    urnComponents.error = "URN can not be parsed";
    return urnComponents;
  }
  const matches = urnComponents.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponents.scheme || "urn";
    urnComponents.nid = matches[1].toLowerCase();
    urnComponents.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
    const schemeHandler = SCHEMES$1[urnScheme];
    urnComponents.path = void 0;
    if (schemeHandler) {
      urnComponents = schemeHandler.parse(urnComponents, options);
    }
  } else {
    urnComponents.error = urnComponents.error || "URN can not be parsed.";
  }
  return urnComponents;
}
function urnSerialize(urnComponents, options) {
  const scheme = options.scheme || urnComponents.scheme || "urn";
  const nid = urnComponents.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = SCHEMES$1[urnScheme];
  if (schemeHandler) {
    urnComponents = schemeHandler.serialize(urnComponents, options);
  }
  const uriComponents = urnComponents;
  const nss = urnComponents.nss;
  uriComponents.path = `${nid || options.nid}:${nss}`;
  options.skipEscape = true;
  return uriComponents;
}
function urnuuidParse(urnComponents, options) {
  const uuidComponents = urnComponents;
  uuidComponents.uuid = uuidComponents.nss;
  uuidComponents.nss = void 0;
  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
    uuidComponents.error = uuidComponents.error || "UUID is not valid.";
  }
  return uuidComponents;
}
function urnuuidSerialize(uuidComponents) {
  const urnComponents = uuidComponents;
  urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
  return urnComponents;
}
const http$3 = {
  scheme: "http",
  domainHost: true,
  parse: httpParse,
  serialize: httpSerialize
};
const https$2 = {
  scheme: "https",
  domainHost: http$3.domainHost,
  parse: httpParse,
  serialize: httpSerialize
};
const ws = {
  scheme: "ws",
  domainHost: true,
  parse: wsParse,
  serialize: wsSerialize
};
const wss = {
  scheme: "wss",
  domainHost: ws.domainHost,
  parse: ws.parse,
  serialize: ws.serialize
};
const urn = {
  scheme: "urn",
  parse: urnParse,
  serialize: urnSerialize,
  skipNormalize: true
};
const urnuuid = {
  scheme: "urn:uuid",
  parse: urnuuidParse,
  serialize: urnuuidSerialize,
  skipNormalize: true
};
const SCHEMES$1 = {
  http: http$3,
  https: https$2,
  ws,
  wss,
  urn,
  "urn:uuid": urnuuid
};
var schemes = SCHEMES$1;
const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = utils$5;
const SCHEMES = schemes;
function normalize(uri2, options) {
  if (typeof uri2 === "string") {
    uri2 = serialize$1(parse$b(uri2, options), options);
  } else if (typeof uri2 === "object") {
    uri2 = parse$b(serialize$1(uri2, options), options);
  }
  return uri2;
}
function resolve(baseURI, relativeURI, options) {
  const schemelessOptions = Object.assign({ scheme: "null" }, options);
  const resolved = resolveComponents(parse$b(baseURI, schemelessOptions), parse$b(relativeURI, schemelessOptions), schemelessOptions, true);
  return serialize$1(resolved, { ...schemelessOptions, skipEscape: true });
}
function resolveComponents(base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse$b(serialize$1(base, options), options);
    relative = parse$b(serialize$1(relative, options), options);
  }
  options = options || {};
  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || "");
    target.query = relative.query;
  } else {
    if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== void 0) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path.charAt(0) === "/") {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
            target.path = "/" + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }
  target.fragment = relative.fragment;
  return target;
}
function equal$2(uriA, uriB, options) {
  if (typeof uriA === "string") {
    uriA = unescape(uriA);
    uriA = serialize$1(normalizeComponentEncoding(parse$b(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === "object") {
    uriA = serialize$1(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }
  if (typeof uriB === "string") {
    uriB = unescape(uriB);
    uriB = serialize$1(normalizeComponentEncoding(parse$b(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === "object") {
    uriB = serialize$1(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }
  return uriA.toLowerCase() === uriB.toLowerCase();
}
function serialize$1(cmpts, opts) {
  const components = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ""
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];
  const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
  if (components.path !== void 0) {
    if (!options.skipEscape) {
      components.path = escape(components.path);
      if (components.scheme !== void 0) {
        components.path = components.path.split("%3A").join(":");
      }
    } else {
      components.path = unescape(components.path);
    }
  }
  if (options.reference !== "suffix" && components.scheme) {
    uriTokens.push(components.scheme, ":");
  }
  const authority = recomposeAuthority(components);
  if (authority !== void 0) {
    if (options.reference !== "suffix") {
      uriTokens.push("//");
    }
    uriTokens.push(authority);
    if (components.path && components.path.charAt(0) !== "/") {
      uriTokens.push("/");
    }
  }
  if (components.path !== void 0) {
    let s = components.path;
    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s = removeDotSegments(s);
    }
    if (authority === void 0) {
      s = s.replace(/^\/\//u, "/%2F");
    }
    uriTokens.push(s);
  }
  if (components.query !== void 0) {
    uriTokens.push("?", components.query);
  }
  if (components.fragment !== void 0) {
    uriTokens.push("#", components.fragment);
  }
  return uriTokens.join("");
}
const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
function nonSimpleDomain(value) {
  let code2 = 0;
  for (let i = 0, len = value.length; i < len; ++i) {
    code2 = value.charCodeAt(i);
    if (code2 > 126 || hexLookUp[code2]) {
      return true;
    }
  }
  return false;
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function parse$b(uri2, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  };
  const gotEncoding = uri2.indexOf("%") !== -1;
  let isIP = false;
  if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
  const matches = uri2.match(URI_PARSE);
  if (matches) {
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || "";
    parsed.query = matches[7];
    parsed.fragment = matches[8];
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = normalizeIPv4(parsed.host);
      if (ipv4result.isIPV4 === false) {
        const ipv6result = normalizeIPv6(ipv4result.host);
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        parsed.host = ipv4result.host;
        isIP = true;
      }
    }
    if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
      parsed.reference = "same-document";
    } else if (parsed.scheme === void 0) {
      parsed.reference = "relative";
    } else if (parsed.fragment === void 0) {
      parsed.reference = "absolute";
    } else {
      parsed.reference = "uri";
    }
    if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
      parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
    }
    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
        }
      }
    }
    if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
      if (gotEncoding && parsed.scheme !== void 0) {
        parsed.scheme = unescape(parsed.scheme);
      }
      if (gotEncoding && parsed.host !== void 0) {
        parsed.host = unescape(parsed.host);
      }
      if (parsed.path) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || "URI can not be parsed.";
  }
  return parsed;
}
const fastUri$2 = {
  SCHEMES,
  normalize,
  resolve,
  resolveComponents,
  equal: equal$2,
  serialize: serialize$1,
  parse: parse$b
};
fastUri$3.exports = fastUri$2;
fastUri$3.exports.default = fastUri$2;
fastUri$3.exports.fastUri = fastUri$2;
var fastUriExports = fastUri$3.exports;
Object.defineProperty(uri$2, "__esModule", { value: true });
const uri$1 = fastUriExports;
uri$1.code = 'require("ajv/dist/runtime/uri").default';
uri$2.default = uri$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate$2;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_12 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$2;
  const dataType_12 = dataType;
  const util_12 = util$9;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$2;
  const defaultRegExp = (str2, flags) => new RegExp(str2, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv2 {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta: meta2, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta2 && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta: meta2, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta2) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta2);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta2);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas2, regex) {
      for (const keyRef in schemas2) {
        const sch = schemas2[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas2[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas2[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2, baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta: meta2, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv2.ValidationError = validation_error_12.default;
  Ajv2.MissingRefError = ref_error_12.default;
  exports.default = Ajv2;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a2;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$3);
var draft7 = {};
var core$2 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$A = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$A;
var ref$2 = {};
Object.defineProperty(ref$2, "__esModule", { value: true });
ref$2.callRef = ref$2.getValidate = void 0;
const ref_error_1$4 = ref_error;
const code_1$c = code;
const codegen_1$u = codegen;
const names_1$4 = names$1;
const compile_1$2 = compile;
const util_1$v = util$9;
const def$z = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
    const { root: root2 } = env;
    if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
      return callRootRef();
    const schOrEnv = compile_1$2.resolveRef.call(self2, root2, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$4.default(it.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$2.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env === root2)
        return callRef(cxt, validateName, env, env.$async);
      const rootName = gen.scopeValue("root", { ref: root2 });
      return callRef(cxt, (0, codegen_1$u._)`${rootName}.validate`, root2, root2.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$u.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$u.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$u._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref$2.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env, opts } = it;
  const passCxt = opts.passContext ? names_1$4.default.this : codegen_1$u.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$u._)`await ${(0, code_1$c.callValidateCode)(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if((0, codegen_1$u._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$c.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source) {
    const errs = (0, codegen_1$u._)`${source}.errors`;
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$u._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$4.default.errors, (0, codegen_1$u._)`${names_1$4.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source) {
    var _a2;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$v.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$u._)`${source}.evaluated.props`);
        it.props = util_1$v.mergeEvaluated.props(gen, props, it.props, codegen_1$u.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$v.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$u._)`${source}.evaluated.items`);
        it.items = util_1$v.mergeEvaluated.items(gen, items2, it.items, codegen_1$u.Name);
      }
    }
  }
}
ref$2.callRef = callRef;
ref$2.default = def$z;
Object.defineProperty(core$2, "__esModule", { value: true });
const id_1 = id;
const ref_1$4 = ref$2;
const core$1 = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1$4.default
];
core$2.default = core$1;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$t = codegen;
const ops = codegen_1$t.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$m = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$t.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$t._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$y = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$m,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$t._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$y;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$s = codegen;
const error$l = {
  message: ({ schemaCode }) => (0, codegen_1$s.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$s._)`{multipleOf: ${schemaCode}}`
};
const def$x = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$l,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res2 = gen.let("res");
    const invalid = prec ? (0, codegen_1$s._)`Math.abs(Math.round(${res2}) - ${res2}) > 1e-${prec}` : (0, codegen_1$s._)`${res2} !== parseInt(${res2})`;
    cxt.fail$data((0, codegen_1$s._)`(${schemaCode} === 0 || (${res2} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$x;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str2) {
  const len = str2.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str2.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str2.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$r = codegen;
const util_1$u = util$9;
const ucs2length_1 = ucs2length$1;
const error$k = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$r.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$r._)`{limit: ${schemaCode}}`
};
const def$w = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$k,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$r.operators.GT : codegen_1$r.operators.LT;
    const len = it.opts.unicode === false ? (0, codegen_1$r._)`${data}.length` : (0, codegen_1$r._)`${(0, util_1$u.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$r._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$w;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$b = code;
const codegen_1$q = codegen;
const error$j = {
  message: ({ schemaCode }) => (0, codegen_1$q.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$q._)`{pattern: ${schemaCode}}`
};
const def$v = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$j,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$q._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1$b.usePattern)(cxt, schema2);
    cxt.fail$data((0, codegen_1$q._)`!${regExp}.test(${data})`);
  }
};
pattern.default = def$v;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$p = codegen;
const error$i = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$p.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$p._)`{limit: ${schemaCode}}`
};
const def$u = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$p.operators.GT : codegen_1$p.operators.LT;
    cxt.fail$data((0, codegen_1$p._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$u;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$a = code;
const codegen_1$o = codegen;
const util_1$t = util$9;
const error$h = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$o.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$o._)`{missingProperty: ${missingProperty}}`
};
const def$t = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$t.checkStrictMode)(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$o.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          (0, code_1$a.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$a.checkMissingProp)(cxt, schema2, missing));
        (0, code_1$a.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$a.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$a.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$o.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$o.nil);
    }
  }
};
required.default = def$t;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$n = codegen;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$n.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$n._)`{limit: ${schemaCode}}`
};
const def$s = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$n.operators.GT : codegen_1$n.operators.LT;
    cxt.fail$data((0, codegen_1$n._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$s;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$m = codegen;
const util_1$s = util$9;
const equal_1$2 = equal$1;
const error$f = {
  message: ({ params: { i, j } }) => (0, codegen_1$m.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => (0, codegen_1$m._)`{i: ${i}, j: ${j}}`
};
const def$r = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$f,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$m._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$m._)`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$m._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$m._)`{}`);
      gen.for((0, codegen_1$m._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$m._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$m._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$m._)`typeof ${item} == "string"`, (0, codegen_1$m._)`${item} += "_"`);
        gen.if((0, codegen_1$m._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, (0, codegen_1$m._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$m._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = (0, util_1$s.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$m._)`;${i}--;`, () => gen.for((0, codegen_1$m._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$m._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$r;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$l = codegen;
const util_1$r = util$9;
const equal_1$1 = equal$1;
const error$e = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$l._)`{allowedValue: ${schemaCode}}`
};
const def$q = {
  keyword: "const",
  $data: true,
  error: error$e,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data((0, codegen_1$l._)`!${(0, util_1$r.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$l._)`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$q;
var _enum$1 = {};
Object.defineProperty(_enum$1, "__esModule", { value: true });
const codegen_1$k = codegen;
const util_1$q = util$9;
const equal_1 = equal$1;
const error$d = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$k._)`{allowedValues: ${schemaCode}}`
};
const def$p = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$q.useFunc)(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$k.or)(...schema2.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$k._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema2[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$k._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$k._)`${data} === ${sch}`;
    }
  }
};
_enum$1.default = def$p;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1$1 = _enum$1;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1$1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$j = codegen;
const util_1$p = util$9;
const error$c = {
  message: ({ params: { len } }) => (0, codegen_1$j.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$j._)`{limit: ${len}}`
};
const def$o = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$c,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$p.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", (0, codegen_1$j._)`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$j._)`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !(0, util_1$p.alwaysValidSchema)(it, schema2)) {
    const valid2 = gen.var("valid", (0, codegen_1$j._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$j.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$p.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if((0, codegen_1$j.not)(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$o;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$i = codegen;
const util_1$o = util$9;
const code_1$9 = code;
const def$n = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if ((0, util_1$o.alwaysValidSchema)(it, schema2))
      return;
    cxt.ok((0, code_1$9.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$o.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$i._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$o.alwaysValidSchema)(it, sch))
      return;
    gen.if((0, codegen_1$i._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$o.checkStrictMode)(it, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$n;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$m = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$m;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$h = codegen;
const util_1$n = util$9;
const code_1$8 = code;
const additionalItems_1$1 = additionalItems;
const error$b = {
  message: ({ params: { len } }) => (0, codegen_1$h.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$h._)`{limit: ${len}}`
};
const def$l = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$b,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if ((0, util_1$n.alwaysValidSchema)(it, schema2))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$8.validateArray)(cxt));
  }
};
items2020.default = def$l;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$g = codegen;
const util_1$m = util$9;
const error$a = {
  message: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1$g.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1$g.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
  params: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1$g._)`{minContains: ${min2}}` : (0, codegen_1$g._)`{minContains: ${min2}, maxContains: ${max2}}`
};
const def$k = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$a,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min2;
    let max2;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min2 = minContains === void 0 ? 1 : minContains;
      max2 = maxContains;
    } else {
      min2 = 1;
    }
    const len = gen.const("len", (0, codegen_1$g._)`${data}.length`);
    cxt.setParams({ min: min2, max: max2 });
    if (max2 === void 0 && min2 === 0) {
      (0, util_1$m.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max2 !== void 0 && min2 > max2) {
      (0, util_1$m.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$m.alwaysValidSchema)(it, schema2)) {
      let cond = (0, codegen_1$g._)`${len} >= ${min2}`;
      if (max2 !== void 0)
        cond = (0, codegen_1$g._)`${cond} && ${len} <= ${max2}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max2 === void 0 && min2 === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min2 === 0) {
      gen.let(valid2, true);
      if (max2 !== void 0)
        gen.if((0, codegen_1$g._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$m.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$g._)`${count}++`);
      if (max2 === void 0) {
        gen.if((0, codegen_1$g._)`${count} >= ${min2}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$g._)`${count} > ${max2}`, () => gen.assign(valid2, false).break());
        if (min2 === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$g._)`${count} >= ${min2}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$k;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util$9;
  const code_12 = code;
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$f = codegen;
const util_1$l = util$9;
const error$9 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$f._)`{propertyName: ${params.propertyName}}`
};
const def$j = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$9,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if ((0, util_1$l.alwaysValidSchema)(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$f.not)(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$j;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$e = codegen;
const names_1$3 = names$1;
const util_1$k = util$9;
const error$8 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$e._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$i = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$8,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$k.alwaysValidSchema)(it, schema2))
      return;
    const props = (0, code_1$7.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$7.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$e._)`${errsCount} === ${names_1$3.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$k.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1$7.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$e.or)(...props.map((p) => (0, codegen_1$e._)`${key} === ${p}`));
      } else {
        definedProp = codegen_1$e.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$e.or)(definedProp, ...patProps.map((p) => (0, codegen_1$e._)`${(0, code_1$7.usePattern)(cxt, p)}.test(${key})`));
      }
      return (0, codegen_1$e.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$e._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !(0, util_1$k.alwaysValidSchema)(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$e.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$e.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$k.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$i;
var properties$2 = {};
Object.defineProperty(properties$2, "__esModule", { value: true });
const validate_1 = validate$2;
const code_1$6 = code;
const util_1$j = util$9;
const additionalProperties_1$1 = additionalProperties;
const def$h = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$6.allSchemaProperties)(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$j.mergeEvaluated.props(gen, (0, util_1$j.toHash)(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !(0, util_1$j.alwaysValidSchema)(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$6.propertyInData)(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$2.default = def$h;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$5 = code;
const codegen_1$d = codegen;
const util_1$i = util$9;
const util_2 = util$9;
const def$g = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts } = it;
    const patterns = (0, code_1$5.allSchemaProperties)(schema2);
    const alwaysValidPatterns = patterns.filter((p) => (0, util_1$i.alwaysValidSchema)(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$d.Name)) {
      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$i.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$d._)`${(0, code_1$5.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$d._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if((0, codegen_1$d.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$g;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$h = util$9;
const def$f = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if ((0, util_1$h.alwaysValidSchema)(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$f;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1$4 = code;
const def$e = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1$4.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$e;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$g = util$9;
const error$7 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$c._)`{passingSchemas: ${params.passing}}`
};
const def$d = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$7,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$g.alwaysValidSchema)(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$c._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$c._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$c.Name);
        });
      });
    }
  }
};
oneOf.default = def$d;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$f = util$9;
const def$c = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i) => {
      if ((0, util_1$f.alwaysValidSchema)(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$c;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util$9;
const error$6 = {
  message: ({ params }) => (0, codegen_1$b.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$b._)`{failingKeyword: ${params.ifClause}}`
};
const def$b = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$e.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$b.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$b._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !(0, util_1$e.alwaysValidSchema)(it, schema2);
}
_if.default = def$b;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$d = util$9;
const def$a = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      (0, util_1$d.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$a;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1$2 = properties$2;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1$2.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$a = codegen;
const error$5 = {
  message: ({ schemaCode }) => (0, codegen_1$a.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$a._)`{format: ${schemaCode}}`
};
const def$9 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$5,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$a._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$a._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$a._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$a._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$a._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$a.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$a.nil;
        return (0, codegen_1$a._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$a._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$a._)`${format2}(${data})`;
        const validData = (0, codegen_1$a._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$a._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$a.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$a._)`${opts.code.formats}${(0, codegen_1$a.getProperty)(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$a._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$a._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$a._)`${fmtRef}(${data})` : (0, codegen_1$a._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$9;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata$1 = {};
Object.defineProperty(metadata$1, "__esModule", { value: true });
metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
metadata$1.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata$1.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$2;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1$6 = metadata$1;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1$6.metadataVocabulary,
  metadata_1$6.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator$1 = {};
var types$5 = {};
Object.defineProperty(types$5, "__esModule", { value: true });
types$5.DiscrError = void 0;
var DiscrError;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError || (types$5.DiscrError = DiscrError = {}));
Object.defineProperty(discriminator$1, "__esModule", { value: true });
const codegen_1$9 = codegen;
const types_1$e = types$5;
const compile_1$1 = compile;
const ref_error_1$3 = ref_error;
const util_1$c = util$9;
const error$4 = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1$e.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$9._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def$8 = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: error$4,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1$9._)`${data}${(0, codegen_1$9.getProperty)(tagName)}`);
    gen.if((0, codegen_1$9._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1$e.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1$9._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1$e.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1$9.Name);
      return _valid;
    }
    function getMapping() {
      var _a2;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$c.schemaHasRulesButRef)(sch, it.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1$1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
          if (sch instanceof compile_1$1.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1$3.default(it.opts.uriResolver, it.baseId, ref2);
        }
        const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator$1.default = def$8;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$3 = [
  "object",
  "boolean"
];
const properties$1 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type: type$3,
  properties: properties$1,
  "default": true
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
  const core_12 = core$3;
  const draft7_1 = draft7;
  const discriminator_12 = discriminator$1;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv2 extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_12.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports.Ajv = Ajv2;
  module.exports = exports = Ajv2;
  module.exports.Ajv = Ajv2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv2;
  var validate_12 = validate$2;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
var dist$2 = { exports: {} };
var formats = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(getTime(true), compareTime),
    "date-time": fmtDef(getDateTime(true), compareDateTime),
    "iso-time": fmtDef(getTime(), compareIsoTime),
    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str2) {
    const matches = DATE2.exec(str2);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS2[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function getTime(strictTimeZone) {
    return function time2(str2) {
      const matches = TIME2.exec(str2);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min2 = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr <= 23 && min2 <= 59 && sec < 60)
        return true;
      const utcMin = min2 - tzM * tzSign;
      const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  }
  function compareTime(s1, s2) {
    if (!(s1 && s2))
      return void 0;
    const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
    const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
    if (!(t1 && t2))
      return void 0;
    return t1 - t2;
  }
  function compareIsoTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME2.exec(t1);
    const a2 = TIME2.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3];
    t2 = a2[1] + a2[2] + a2[3];
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function getDateTime(strictTimeZone) {
    const time2 = getTime(strictTimeZone);
    return function date_time(str2) {
      const dateTime = str2.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time2(dateTime[1]);
    };
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const d1 = new Date(dt1).valueOf();
    const d2 = new Date(dt2).valueOf();
    if (!(d1 && d2))
      return void 0;
    return d1 - d2;
  }
  function compareIsoDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res2 = compareDate(d1, d2);
    if (res2 === void 0)
      return void 0;
    return res2 || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str2) {
    return NOT_URI_FRAGMENT.test(str2) && URI.test(str2);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str2) {
    BYTE.lastIndex = 0;
    return BYTE.test(str2);
  }
  const MIN_INT32 = -2147483648;
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str2) {
    if (Z_ANCHOR.test(str2))
      return false;
    try {
      new RegExp(str2);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
var hasRequiredLimit;
function requireLimit() {
  if (hasRequiredLimit) return limit;
  hasRequiredLimit = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    const ajv_1 = ajvExports;
    const codegen_12 = codegen;
    const ops2 = codegen_12.operators;
    const KWDs2 = {
      formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
      formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
    };
    const error2 = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_12.str)`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_12._)`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs2),
      type: "string",
      schemaType: "string",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_12._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_12.or)((0, codegen_12._)`typeof ${fmt} != "object"`, (0, codegen_12._)`${fmt} instanceof RegExp`, (0, codegen_12._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self2.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_12._)`${opts.code.formats}${(0, codegen_12.getProperty)(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_12._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const formatLimitPlugin = (ajv2) => {
      ajv2.addKeyword(exports.formatLimitDefinition);
      return ajv2;
    };
    exports.default = formatLimitPlugin;
  })(limit);
  return limit;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$2.exports;
  hasRequiredDist$1 = 1;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const formats_1 = formats;
    const limit_1 = requireLimit();
    const codegen_12 = codegen;
    const fullName = new codegen_12.Name("fullFormats");
    const fastName = new codegen_12.Name("fastFormats");
    const formatsPlugin = (ajv2, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv2, opts, formats_1.fullFormats, fullName);
        return ajv2;
      }
      const [formats3, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv2, list, formats3, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv2);
      return ajv2;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats3 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats3[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv2, list, fs2, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = (0, codegen_12._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv2.addFormat(f, fs2[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  })(dist$2, dist$2.exports);
  return dist$2.exports;
}
const Ajv$1 = ajvExports;
const fastUri$1 = fastUriExports;
const ajvFormats = requireDist$1();
const clone$2 = rfdc_1({ proto: true });
let Validator$1 = class Validator {
  constructor(ajvOptions) {
    this.ajv = new Ajv$1({
      ...ajvOptions,
      strictSchema: false,
      validateSchema: false,
      allowUnionTypes: true,
      uriResolver: fastUri$1
    });
    ajvFormats(this.ajv);
    this.ajv.addKeyword({
      keyword: "fjs_type",
      type: "object",
      errors: false,
      validate: (_type, date) => {
        return date instanceof Date;
      }
    });
    this._ajvSchemas = {};
    this._ajvOptions = ajvOptions || {};
  }
  addSchema(schema2, schemaName) {
    let schemaKey = schema2.$id || schemaName;
    if (schema2.$id !== void 0 && schema2.$id[0] === "#") {
      schemaKey = schemaName + schema2.$id;
    }
    if (this.ajv.refs[schemaKey] === void 0 && this.ajv.schemas[schemaKey] === void 0) {
      const ajvSchema = clone$2(schema2);
      this.convertSchemaToAjvFormat(ajvSchema);
      this.ajv.addSchema(ajvSchema, schemaKey);
      this._ajvSchemas[schemaKey] = schema2;
    }
  }
  validate(schemaRef, data) {
    return this.ajv.validate(schemaRef, data);
  }
  // Ajv does not support js date format. In order to properly validate objects containing a date,
  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
  // (see https://github.com/fastify/fast-json-stringify/pull/441)
  convertSchemaToAjvFormat(schema2) {
    if (schema2 === null) return;
    if (schema2.type === "string") {
      schema2.fjs_type = "string";
      schema2.type = ["string", "object"];
    } else if (Array.isArray(schema2.type) && schema2.type.includes("string") && !schema2.type.includes("object")) {
      schema2.fjs_type = "string";
      schema2.type.push("object");
    }
    for (const property in schema2) {
      if (typeof schema2[property] === "object") {
        this.convertSchemaToAjvFormat(schema2[property]);
      }
    }
  }
  getState() {
    return {
      ajvOptions: this._ajvOptions,
      ajvSchemas: this._ajvSchemas
    };
  }
  static restoreFromState(state2) {
    const validator2 = new Validator(state2.ajvOptions);
    for (const [id2, ajvSchema] of Object.entries(state2.ajvSchemas)) {
      validator2.ajv.addSchema(ajvSchema, id2);
    }
    return validator2;
  }
};
var validator$1 = Validator$1;
let Location$1 = class Location {
  constructor(schema2, schemaId, jsonPointer = "#") {
    this.schema = schema2;
    this.schemaId = schemaId;
    this.jsonPointer = jsonPointer;
  }
  getPropertyLocation(propertyName) {
    const propertyLocation = new Location(
      this.schema[propertyName],
      this.schemaId,
      this.jsonPointer + "/" + propertyName
    );
    return propertyLocation;
  }
  getSchemaRef() {
    return this.schemaId + this.jsonPointer;
  }
};
var location = Location$1;
var schemaValidator = { exports: {} };
schemaValidator.exports = validate10$1;
schemaValidator.exports.default = validate10$1;
const schema11$1 = { "type": ["object", "boolean"] };
const schema20 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
const formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
const formats2 = formats.fullFormats.uri;
const formats6 = formats.fullFormats.regex;
function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
    validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
    return false;
  }
  {
    if (typeof data == "number" && isFinite(data)) {
      if (data < 0 || isNaN(data)) {
        validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
        return false;
      }
    }
  }
  validate11.errors = vErrors;
  return errors2 === 0;
}
const root1 = { validate: validate10$1 };
function validate13(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (errors2 === 0) {
    if (Array.isArray(data)) {
      if (data.length < 1) {
        validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
        return false;
      } else {
        var valid0 = true;
        const len0 = data.length;
        for (let i0 = 0; i0 < len0; i0++) {
          const _errs1 = errors2;
          if (!root1.validate(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
            vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
            errors2 = vErrors.length;
          }
          var valid0 = _errs1 === errors2;
          if (!valid0) {
            break;
          }
        }
      }
    } else {
      validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
      return false;
    }
  }
  validate13.errors = vErrors;
  return errors2 === 0;
}
const func0 = equal$1.default;
function validate10$1(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
    validate10$1.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11$1.type }, message: "must be object,boolean" }];
    return false;
  }
  if (errors2 === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.$id !== void 0) {
        let data0 = data.$id;
        const _errs1 = errors2;
        if (errors2 === _errs1) {
          if (errors2 === _errs1) {
            if (typeof data0 === "string") {
              if (!formats0.test(data0)) {
                validate10$1.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                return false;
              }
            } else {
              validate10$1.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
          }
        }
        var valid0 = _errs1 === errors2;
      } else {
        var valid0 = true;
      }
      if (valid0) {
        if (data.$schema !== void 0) {
          let data1 = data.$schema;
          const _errs3 = errors2;
          if (errors2 === _errs3) {
            if (errors2 === _errs3) {
              if (typeof data1 === "string") {
                if (!formats2(data1)) {
                  validate10$1.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }];
                  return false;
                }
              } else {
                validate10$1.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
            }
          }
          var valid0 = _errs3 === errors2;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.$ref !== void 0) {
            let data2 = data.$ref;
            const _errs5 = errors2;
            if (errors2 === _errs5) {
              if (errors2 === _errs5) {
                if (typeof data2 === "string") {
                  if (!formats0.test(data2)) {
                    validate10$1.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                    return false;
                  }
                } else {
                  validate10$1.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs5 === errors2;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.$comment !== void 0) {
              const _errs7 = errors2;
              if (typeof data.$comment !== "string") {
                validate10$1.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
              var valid0 = _errs7 === errors2;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.title !== void 0) {
                const _errs9 = errors2;
                if (typeof data.title !== "string") {
                  validate10$1.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs9 === errors2;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.description !== void 0) {
                  const _errs11 = errors2;
                  if (typeof data.description !== "string") {
                    validate10$1.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs11 === errors2;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.readOnly !== void 0) {
                    const _errs13 = errors2;
                    if (typeof data.readOnly !== "boolean") {
                      validate10$1.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                      return false;
                    }
                    var valid0 = _errs13 === errors2;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.examples !== void 0) {
                      const _errs15 = errors2;
                      if (errors2 === _errs15) {
                        if (!Array.isArray(data.examples)) {
                          validate10$1.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                          return false;
                        }
                      }
                      var valid0 = _errs15 === errors2;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.multipleOf !== void 0) {
                        let data8 = data.multipleOf;
                        const _errs17 = errors2;
                        if (errors2 === _errs17) {
                          if (typeof data8 == "number" && isFinite(data8)) {
                            if (data8 <= 0 || isNaN(data8)) {
                              validate10$1.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                              return false;
                            }
                          } else {
                            validate10$1.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                            return false;
                          }
                        }
                        var valid0 = _errs17 === errors2;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.maximum !== void 0) {
                          let data9 = data.maximum;
                          const _errs19 = errors2;
                          if (!(typeof data9 == "number" && isFinite(data9))) {
                            validate10$1.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                            return false;
                          }
                          var valid0 = _errs19 === errors2;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.exclusiveMaximum !== void 0) {
                            let data10 = data.exclusiveMaximum;
                            const _errs21 = errors2;
                            if (!(typeof data10 == "number" && isFinite(data10))) {
                              validate10$1.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                            var valid0 = _errs21 === errors2;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.minimum !== void 0) {
                              let data11 = data.minimum;
                              const _errs23 = errors2;
                              if (!(typeof data11 == "number" && isFinite(data11))) {
                                validate10$1.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs23 === errors2;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.exclusiveMinimum !== void 0) {
                                let data12 = data.exclusiveMinimum;
                                const _errs25 = errors2;
                                if (!(typeof data12 == "number" && isFinite(data12))) {
                                  validate10$1.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs25 === errors2;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data.maxLength !== void 0) {
                                  let data13 = data.maxLength;
                                  const _errs27 = errors2;
                                  const _errs28 = errors2;
                                  if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                    validate10$1.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                    return false;
                                  }
                                  if (errors2 === _errs28) {
                                    if (typeof data13 == "number" && isFinite(data13)) {
                                      if (data13 < 0 || isNaN(data13)) {
                                        validate10$1.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                        return false;
                                      }
                                    }
                                  }
                                  var valid0 = _errs27 === errors2;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data.minLength !== void 0) {
                                    const _errs30 = errors2;
                                    if (!validate11(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
                                      vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                      errors2 = vErrors.length;
                                    }
                                    var valid0 = _errs30 === errors2;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data.pattern !== void 0) {
                                      let data15 = data.pattern;
                                      const _errs31 = errors2;
                                      if (errors2 === _errs31) {
                                        if (errors2 === _errs31) {
                                          if (typeof data15 === "string") {
                                            if (!formats6(data15)) {
                                              validate10$1.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }];
                                              return false;
                                            }
                                          } else {
                                            validate10$1.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                      }
                                      var valid0 = _errs31 === errors2;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data.additionalItems !== void 0) {
                                        const _errs33 = errors2;
                                        if (!validate10$1(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
                                          vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                          errors2 = vErrors.length;
                                        }
                                        var valid0 = _errs33 === errors2;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data.items !== void 0) {
                                          let data17 = data.items;
                                          const _errs34 = errors2;
                                          const _errs35 = errors2;
                                          let valid2 = false;
                                          const _errs36 = errors2;
                                          if (!validate10$1(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                            vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                            errors2 = vErrors.length;
                                          }
                                          var _valid0 = _errs36 === errors2;
                                          valid2 = valid2 || _valid0;
                                          if (!valid2) {
                                            const _errs37 = errors2;
                                            if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                              errors2 = vErrors.length;
                                            }
                                            var _valid0 = _errs37 === errors2;
                                            valid2 = valid2 || _valid0;
                                          }
                                          if (!valid2) {
                                            const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            if (vErrors === null) {
                                              vErrors = [err0];
                                            } else {
                                              vErrors.push(err0);
                                            }
                                            errors2++;
                                            validate10$1.errors = vErrors;
                                            return false;
                                          } else {
                                            errors2 = _errs35;
                                            if (vErrors !== null) {
                                              if (_errs35) {
                                                vErrors.length = _errs35;
                                              } else {
                                                vErrors = null;
                                              }
                                            }
                                          }
                                          var valid0 = _errs34 === errors2;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data.maxItems !== void 0) {
                                            let data18 = data.maxItems;
                                            const _errs38 = errors2;
                                            const _errs39 = errors2;
                                            if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                              validate10$1.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                              return false;
                                            }
                                            if (errors2 === _errs39) {
                                              if (typeof data18 == "number" && isFinite(data18)) {
                                                if (data18 < 0 || isNaN(data18)) {
                                                  validate10$1.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                  return false;
                                                }
                                              }
                                            }
                                            var valid0 = _errs38 === errors2;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data.minItems !== void 0) {
                                              const _errs41 = errors2;
                                              if (!validate11(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
                                                vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                errors2 = vErrors.length;
                                              }
                                              var valid0 = _errs41 === errors2;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data.uniqueItems !== void 0) {
                                                const _errs42 = errors2;
                                                if (typeof data.uniqueItems !== "boolean") {
                                                  validate10$1.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                  return false;
                                                }
                                                var valid0 = _errs42 === errors2;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data.contains !== void 0) {
                                                  const _errs44 = errors2;
                                                  if (!validate10$1(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
                                                    vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                    errors2 = vErrors.length;
                                                  }
                                                  var valid0 = _errs44 === errors2;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data.maxProperties !== void 0) {
                                                    let data22 = data.maxProperties;
                                                    const _errs45 = errors2;
                                                    const _errs46 = errors2;
                                                    if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                      validate10$1.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                      return false;
                                                    }
                                                    if (errors2 === _errs46) {
                                                      if (typeof data22 == "number" && isFinite(data22)) {
                                                        if (data22 < 0 || isNaN(data22)) {
                                                          validate10$1.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                          return false;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs45 === errors2;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data.minProperties !== void 0) {
                                                      const _errs48 = errors2;
                                                      if (!validate11(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
                                                        vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                        errors2 = vErrors.length;
                                                      }
                                                      var valid0 = _errs48 === errors2;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.required !== void 0) {
                                                        let data24 = data.required;
                                                        const _errs49 = errors2;
                                                        const _errs50 = errors2;
                                                        if (errors2 === _errs50) {
                                                          if (Array.isArray(data24)) {
                                                            var valid6 = true;
                                                            const len0 = data24.length;
                                                            for (let i0 = 0; i0 < len0; i0++) {
                                                              const _errs52 = errors2;
                                                              if (typeof data24[i0] !== "string") {
                                                                validate10$1.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                return false;
                                                              }
                                                              var valid6 = _errs52 === errors2;
                                                              if (!valid6) {
                                                                break;
                                                              }
                                                            }
                                                            if (valid6) {
                                                              let i1 = data24.length;
                                                              let j0;
                                                              if (i1 > 1) {
                                                                const indices0 = {};
                                                                for (; i1--; ) {
                                                                  let item0 = data24[i1];
                                                                  if (typeof item0 !== "string") {
                                                                    continue;
                                                                  }
                                                                  if (typeof indices0[item0] == "number") {
                                                                    j0 = indices0[item0];
                                                                    validate10$1.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                    return false;
                                                                  }
                                                                  indices0[item0] = i1;
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            validate10$1.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid0 = _errs49 === errors2;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.additionalProperties !== void 0) {
                                                          const _errs54 = errors2;
                                                          if (!validate10$1(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
                                                            vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                            errors2 = vErrors.length;
                                                          }
                                                          var valid0 = _errs54 === errors2;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.definitions !== void 0) {
                                                            let data27 = data.definitions;
                                                            const _errs55 = errors2;
                                                            if (errors2 === _errs55) {
                                                              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                for (const key0 in data27) {
                                                                  const _errs58 = errors2;
                                                                  if (!validate10$1(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                    vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                    errors2 = vErrors.length;
                                                                  }
                                                                  var valid8 = _errs58 === errors2;
                                                                  if (!valid8) {
                                                                    break;
                                                                  }
                                                                }
                                                              } else {
                                                                validate10$1.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs55 === errors2;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data.properties !== void 0) {
                                                              let data29 = data.properties;
                                                              const _errs59 = errors2;
                                                              if (errors2 === _errs59) {
                                                                if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                  for (const key1 in data29) {
                                                                    const _errs62 = errors2;
                                                                    if (!validate10$1(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                      vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                      errors2 = vErrors.length;
                                                                    }
                                                                    var valid9 = _errs62 === errors2;
                                                                    if (!valid9) {
                                                                      break;
                                                                    }
                                                                  }
                                                                } else {
                                                                  validate10$1.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid0 = _errs59 === errors2;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data.patternProperties !== void 0) {
                                                                let data31 = data.patternProperties;
                                                                const _errs63 = errors2;
                                                                if (errors2 === _errs63) {
                                                                  if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                    for (const key2 in data31) {
                                                                      const _errs65 = errors2;
                                                                      if (errors2 === _errs65) {
                                                                        if (typeof key2 === "string") {
                                                                          if (!formats6(key2)) {
                                                                            const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: key2 };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err1];
                                                                            } else {
                                                                              vErrors.push(err1);
                                                                            }
                                                                            errors2++;
                                                                          }
                                                                        }
                                                                      }
                                                                      var valid10 = _errs65 === errors2;
                                                                      if (!valid10) {
                                                                        const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                        if (vErrors === null) {
                                                                          vErrors = [err2];
                                                                        } else {
                                                                          vErrors.push(err2);
                                                                        }
                                                                        errors2++;
                                                                        validate10$1.errors = vErrors;
                                                                        return false;
                                                                      }
                                                                    }
                                                                    if (valid10) {
                                                                      for (const key3 in data31) {
                                                                        const _errs67 = errors2;
                                                                        if (!validate10$1(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                          vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                          errors2 = vErrors.length;
                                                                        }
                                                                        var valid11 = _errs67 === errors2;
                                                                        if (!valid11) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10$1.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs63 === errors2;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data.dependencies !== void 0) {
                                                                  let data33 = data.dependencies;
                                                                  const _errs68 = errors2;
                                                                  if (errors2 === _errs68) {
                                                                    if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                      for (const key4 in data33) {
                                                                        let data34 = data33[key4];
                                                                        const _errs71 = errors2;
                                                                        const _errs72 = errors2;
                                                                        let valid13 = false;
                                                                        const _errs73 = errors2;
                                                                        if (!validate10$1(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                          vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                          errors2 = vErrors.length;
                                                                        }
                                                                        var _valid1 = _errs73 === errors2;
                                                                        valid13 = valid13 || _valid1;
                                                                        if (!valid13) {
                                                                          const _errs74 = errors2;
                                                                          const _errs75 = errors2;
                                                                          if (errors2 === _errs75) {
                                                                            if (Array.isArray(data34)) {
                                                                              var valid15 = true;
                                                                              const len1 = data34.length;
                                                                              for (let i2 = 0; i2 < len1; i2++) {
                                                                                const _errs77 = errors2;
                                                                                if (typeof data34[i2] !== "string") {
                                                                                  const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err3];
                                                                                  } else {
                                                                                    vErrors.push(err3);
                                                                                  }
                                                                                  errors2++;
                                                                                }
                                                                                var valid15 = _errs77 === errors2;
                                                                                if (!valid15) {
                                                                                  break;
                                                                                }
                                                                              }
                                                                              if (valid15) {
                                                                                let i3 = data34.length;
                                                                                let j1;
                                                                                if (i3 > 1) {
                                                                                  const indices1 = {};
                                                                                  for (; i3--; ) {
                                                                                    let item1 = data34[i3];
                                                                                    if (typeof item1 !== "string") {
                                                                                      continue;
                                                                                    }
                                                                                    if (typeof indices1[item1] == "number") {
                                                                                      j1 = indices1[item1];
                                                                                      const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err4];
                                                                                      } else {
                                                                                        vErrors.push(err4);
                                                                                      }
                                                                                      errors2++;
                                                                                      break;
                                                                                    }
                                                                                    indices1[item1] = i3;
                                                                                  }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err5];
                                                                              } else {
                                                                                vErrors.push(err5);
                                                                              }
                                                                              errors2++;
                                                                            }
                                                                          }
                                                                          var _valid1 = _errs74 === errors2;
                                                                          valid13 = valid13 || _valid1;
                                                                        }
                                                                        if (!valid13) {
                                                                          const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err6];
                                                                          } else {
                                                                            vErrors.push(err6);
                                                                          }
                                                                          errors2++;
                                                                          validate10$1.errors = vErrors;
                                                                          return false;
                                                                        } else {
                                                                          errors2 = _errs72;
                                                                          if (vErrors !== null) {
                                                                            if (_errs72) {
                                                                              vErrors.length = _errs72;
                                                                            } else {
                                                                              vErrors = null;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid12 = _errs71 === errors2;
                                                                        if (!valid12) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10$1.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs68 === errors2;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data.propertyNames !== void 0) {
                                                                    const _errs79 = errors2;
                                                                    if (!validate10$1(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
                                                                      vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                      errors2 = vErrors.length;
                                                                    }
                                                                    var valid0 = _errs79 === errors2;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data.enum !== void 0) {
                                                                      let data37 = data.enum;
                                                                      const _errs80 = errors2;
                                                                      if (errors2 === _errs80) {
                                                                        if (Array.isArray(data37)) {
                                                                          if (data37.length < 1) {
                                                                            validate10$1.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                            return false;
                                                                          } else {
                                                                            let i4 = data37.length;
                                                                            let j2;
                                                                            if (i4 > 1) {
                                                                              for (; i4--; ) {
                                                                                for (j2 = i4; j2--; ) {
                                                                                  if (func0(data37[i4], data37[j2])) {
                                                                                    validate10$1.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                    return false;
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        } else {
                                                                          validate10$1.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      var valid0 = _errs80 === errors2;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data.type !== void 0) {
                                                                        let data38 = data.type;
                                                                        const _errs82 = errors2;
                                                                        const _errs83 = errors2;
                                                                        let valid18 = false;
                                                                        const _errs84 = errors2;
                                                                        if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                          const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err7];
                                                                          } else {
                                                                            vErrors.push(err7);
                                                                          }
                                                                          errors2++;
                                                                        }
                                                                        var _valid2 = _errs84 === errors2;
                                                                        valid18 = valid18 || _valid2;
                                                                        if (!valid18) {
                                                                          const _errs86 = errors2;
                                                                          if (errors2 === _errs86) {
                                                                            if (Array.isArray(data38)) {
                                                                              if (data38.length < 1) {
                                                                                const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err8];
                                                                                } else {
                                                                                  vErrors.push(err8);
                                                                                }
                                                                                errors2++;
                                                                              } else {
                                                                                var valid20 = true;
                                                                                const len2 = data38.length;
                                                                                for (let i5 = 0; i5 < len2; i5++) {
                                                                                  let data39 = data38[i5];
                                                                                  const _errs88 = errors2;
                                                                                  if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                    const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err9];
                                                                                    } else {
                                                                                      vErrors.push(err9);
                                                                                    }
                                                                                    errors2++;
                                                                                  }
                                                                                  var valid20 = _errs88 === errors2;
                                                                                  if (!valid20) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                if (valid20) {
                                                                                  let i6 = data38.length;
                                                                                  let j3;
                                                                                  if (i6 > 1) {
                                                                                    outer1:
                                                                                      for (; i6--; ) {
                                                                                        for (j3 = i6; j3--; ) {
                                                                                          if (func0(data38[i6], data38[j3])) {
                                                                                            const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                            if (vErrors === null) {
                                                                                              vErrors = [err10];
                                                                                            } else {
                                                                                              vErrors.push(err10);
                                                                                            }
                                                                                            errors2++;
                                                                                            break outer1;
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                  }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err11];
                                                                              } else {
                                                                                vErrors.push(err11);
                                                                              }
                                                                              errors2++;
                                                                            }
                                                                          }
                                                                          var _valid2 = _errs86 === errors2;
                                                                          valid18 = valid18 || _valid2;
                                                                        }
                                                                        if (!valid18) {
                                                                          const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err12];
                                                                          } else {
                                                                            vErrors.push(err12);
                                                                          }
                                                                          errors2++;
                                                                          validate10$1.errors = vErrors;
                                                                          return false;
                                                                        } else {
                                                                          errors2 = _errs83;
                                                                          if (vErrors !== null) {
                                                                            if (_errs83) {
                                                                              vErrors.length = _errs83;
                                                                            } else {
                                                                              vErrors = null;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid0 = _errs82 === errors2;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data.format !== void 0) {
                                                                          const _errs90 = errors2;
                                                                          if (typeof data.format !== "string") {
                                                                            validate10$1.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                            return false;
                                                                          }
                                                                          var valid0 = _errs90 === errors2;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data.contentMediaType !== void 0) {
                                                                            const _errs92 = errors2;
                                                                            if (typeof data.contentMediaType !== "string") {
                                                                              validate10$1.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                            var valid0 = _errs92 === errors2;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data.contentEncoding !== void 0) {
                                                                              const _errs94 = errors2;
                                                                              if (typeof data.contentEncoding !== "string") {
                                                                                validate10$1.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs94 === errors2;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data.if !== void 0) {
                                                                                const _errs96 = errors2;
                                                                                if (!validate10$1(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
                                                                                  vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                                  errors2 = vErrors.length;
                                                                                }
                                                                                var valid0 = _errs96 === errors2;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data.then !== void 0) {
                                                                                  const _errs97 = errors2;
                                                                                  if (!validate10$1(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
                                                                                    vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                                    errors2 = vErrors.length;
                                                                                  }
                                                                                  var valid0 = _errs97 === errors2;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data.else !== void 0) {
                                                                                    const _errs98 = errors2;
                                                                                    if (!validate10$1(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                                      errors2 = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs98 === errors2;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data.allOf !== void 0) {
                                                                                      const _errs99 = errors2;
                                                                                      if (!validate13(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
                                                                                        vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                        errors2 = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs99 === errors2;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data.anyOf !== void 0) {
                                                                                        const _errs100 = errors2;
                                                                                        if (!validate13(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
                                                                                          vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                          errors2 = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs100 === errors2;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data.oneOf !== void 0) {
                                                                                          const _errs101 = errors2;
                                                                                          if (!validate13(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors2 = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs101 === errors2;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data.not !== void 0) {
                                                                                            const _errs102 = errors2;
                                                                                            if (!validate10$1(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
                                                                                              vErrors = vErrors === null ? validate10$1.errors : vErrors.concat(validate10$1.errors);
                                                                                              errors2 = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs102 === errors2;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  validate10$1.errors = vErrors;
  return errors2 === 0;
}
var schemaValidatorExports = schemaValidator.exports;
let MergeError$1 = class MergeError extends Error {
  constructor(keyword2, schemas2) {
    super();
    this.name = "JsonSchemaMergeError";
    this.code = "JSON_SCHEMA_MERGE_ERROR";
    this.message = `Failed to merge "${keyword2}" keyword schemas.`;
    this.schemas = schemas2;
  }
};
class ResolverNotFoundError extends Error {
  constructor(keyword2, schemas2) {
    super();
    this.name = "JsonSchemaMergeError";
    this.code = "JSON_SCHEMA_MERGE_ERROR";
    this.message = `Resolver for "${keyword2}" keyword not found.`;
    this.schemas = schemas2;
  }
}
class InvalidOnConflictOptionError extends Error {
  constructor(onConflict) {
    super();
    this.name = "JsonSchemaMergeError";
    this.code = "JSON_SCHEMA_MERGE_ERROR";
    this.message = `Invalid "onConflict" option: "${onConflict}".`;
  }
}
var errors$2 = {
  MergeError: MergeError$1,
  ResolverNotFoundError,
  InvalidOnConflictOptionError
};
const { dequal: deepEqual$3 } = dist$3;
const { MergeError: MergeError2 } = errors$2;
function _arraysIntersection(arrays) {
  let intersection = arrays[0];
  for (let i = 1; i < arrays.length; i++) {
    intersection = intersection.filter(
      (value) => arrays[i].includes(value)
    );
  }
  return intersection;
}
function arraysIntersection(keyword2, values2, mergedSchema) {
  const intersection = _arraysIntersection(values2);
  if (intersection.length === 0) {
    throw new MergeError2(keyword2, values2);
  }
  mergedSchema[keyword2] = intersection;
}
function hybridArraysIntersection(keyword2, values2, mergedSchema) {
  for (let i = 0; i < values2.length; i++) {
    if (!Array.isArray(values2[i])) {
      values2[i] = [values2[i]];
    }
  }
  const intersection = _arraysIntersection(values2);
  if (intersection.length === 0) {
    throw new MergeError2(keyword2, values2);
  }
  if (intersection.length === 1) {
    mergedSchema[keyword2] = intersection[0];
  } else {
    mergedSchema[keyword2] = intersection;
  }
}
function arraysUnion(keyword2, values2, mergedSchema) {
  const union2 = [];
  for (const array of values2) {
    for (const value of array) {
      if (!union2.includes(value)) {
        union2.push(value);
      }
    }
  }
  mergedSchema[keyword2] = union2;
}
function minNumber(keyword2, values2, mergedSchema) {
  mergedSchema[keyword2] = Math.min(...values2);
}
function maxNumber(keyword2, values2, mergedSchema) {
  mergedSchema[keyword2] = Math.max(...values2);
}
function commonMultiple(keyword2, values2, mergedSchema) {
  const gcd = (a, b) => !b ? a : gcd(b, a % b);
  const lcm = (a, b) => a * b / gcd(a, b);
  let scale = 1;
  for (const value of values2) {
    while (value * scale % 1 !== 0) {
      scale *= 10;
    }
  }
  let multiple = values2[0] * scale;
  for (const value of values2) {
    multiple = lcm(multiple, value * scale);
  }
  mergedSchema[keyword2] = multiple / scale;
}
function allEqual(keyword2, values2, mergedSchema) {
  const firstValue = values2[0];
  for (let i = 1; i < values2.length; i++) {
    if (!deepEqual$3(values2[i], firstValue)) {
      throw new MergeError2(keyword2, values2);
    }
  }
  mergedSchema[keyword2] = firstValue;
}
function skip() {
}
function booleanAnd(keyword2, values2, mergedSchema) {
  for (const value of values2) {
    if (value === false) {
      mergedSchema[keyword2] = false;
      return;
    }
  }
  mergedSchema[keyword2] = true;
}
function booleanOr(keyword2, values2, mergedSchema) {
  for (const value of values2) {
    if (value === true) {
      mergedSchema[keyword2] = true;
      return;
    }
  }
  mergedSchema[keyword2] = false;
}
var resolvers$2 = {
  arraysIntersection,
  hybridArraysIntersection,
  arraysUnion,
  minNumber,
  maxNumber,
  commonMultiple,
  allEqual,
  booleanAnd,
  booleanOr,
  skip
};
const { dequal: deepEqual$2 } = dist$3;
const resolvers$1 = resolvers$2;
const errors$1 = errors$2;
const keywordsResolvers = {
  $id: resolvers$1.skip,
  type: resolvers$1.hybridArraysIntersection,
  enum: resolvers$1.arraysIntersection,
  minLength: resolvers$1.maxNumber,
  maxLength: resolvers$1.minNumber,
  minimum: resolvers$1.maxNumber,
  maximum: resolvers$1.minNumber,
  multipleOf: resolvers$1.commonMultiple,
  exclusiveMinimum: resolvers$1.maxNumber,
  exclusiveMaximum: resolvers$1.minNumber,
  minItems: resolvers$1.maxNumber,
  maxItems: resolvers$1.minNumber,
  maxProperties: resolvers$1.minNumber,
  minProperties: resolvers$1.maxNumber,
  const: resolvers$1.allEqual,
  default: resolvers$1.allEqual,
  format: resolvers$1.allEqual,
  required: resolvers$1.arraysUnion,
  properties: mergeProperties,
  patternProperties: mergeObjects,
  additionalProperties: mergeSchemasResolver,
  items: mergeItems,
  additionalItems: mergeAdditionalItems,
  definitions: mergeObjects,
  $defs: mergeObjects,
  nullable: resolvers$1.booleanAnd,
  oneOf: mergeOneOf,
  anyOf: mergeOneOf,
  allOf: resolvers$1.arraysUnion,
  not: mergeSchemasResolver,
  if: mergeIfThenElseSchemas,
  then: resolvers$1.skip,
  else: resolvers$1.skip,
  dependencies: mergeDependencies,
  dependentRequired: mergeDependencies,
  dependentSchemas: mergeObjects,
  propertyNames: mergeSchemasResolver,
  uniqueItems: resolvers$1.booleanOr,
  contains: mergeSchemasResolver
};
function mergeSchemasResolver(keyword2, values2, mergedSchema, _schemas2, options) {
  mergedSchema[keyword2] = _mergeSchemas$1(values2, options);
}
function cartesianProduct(arrays) {
  let result = [[]];
  for (const array of arrays) {
    const temp = [];
    for (const x of result) {
      for (const y of array) {
        temp.push([...x, y]);
      }
    }
    result = temp;
  }
  return result;
}
function mergeOneOf(keyword2, values2, mergedSchema, _schemas2, options) {
  if (values2.length === 1) {
    mergedSchema[keyword2] = values2[0];
    return;
  }
  const product = cartesianProduct(values2);
  const mergedOneOf = [];
  for (const combination of product) {
    try {
      const mergedSchema2 = _mergeSchemas$1(combination, options);
      if (mergedSchema2 !== void 0) {
        mergedOneOf.push(mergedSchema2);
      }
    } catch (error2) {
      if (error2 instanceof errors$1.MergeError) continue;
      throw error2;
    }
  }
  mergedSchema[keyword2] = mergedOneOf;
}
function getSchemaForItem(schema2, index) {
  const { items: items2, additionalItems: additionalItems2 } = schema2;
  if (Array.isArray(items2)) {
    if (index < items2.length) {
      return items2[index];
    }
    return additionalItems2;
  }
  if (items2 !== void 0) {
    return items2;
  }
  return additionalItems2;
}
function mergeItems(keyword2, values2, mergedSchema, schemas2, options) {
  let maxArrayItemsLength = 0;
  for (const itemsSchema of values2) {
    if (Array.isArray(itemsSchema)) {
      maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
    }
  }
  if (maxArrayItemsLength === 0) {
    mergedSchema[keyword2] = _mergeSchemas$1(values2, options);
    return;
  }
  const mergedItemsSchemas = [];
  for (let i = 0; i < maxArrayItemsLength; i++) {
    const indexItemSchemas = [];
    for (const schema2 of schemas2) {
      const itemSchema = getSchemaForItem(schema2, i);
      if (itemSchema !== void 0) {
        indexItemSchemas.push(itemSchema);
      }
    }
    mergedItemsSchemas[i] = _mergeSchemas$1(indexItemSchemas, options);
  }
  mergedSchema[keyword2] = mergedItemsSchemas;
}
function mergeAdditionalItems(keyword2, values2, mergedSchema, schemas2, options) {
  let hasArrayItems = false;
  for (const schema2 of schemas2) {
    if (Array.isArray(schema2.items)) {
      hasArrayItems = true;
      break;
    }
  }
  if (!hasArrayItems) {
    mergedSchema[keyword2] = _mergeSchemas$1(values2, options);
    return;
  }
  const mergedAdditionalItemsSchemas = [];
  for (const schema2 of schemas2) {
    let additionalItemsSchema = schema2.additionalItems;
    if (additionalItemsSchema === void 0 && !Array.isArray(schema2.items)) {
      additionalItemsSchema = schema2.items;
    }
    if (additionalItemsSchema !== void 0) {
      mergedAdditionalItemsSchemas.push(additionalItemsSchema);
    }
  }
  mergedSchema[keyword2] = _mergeSchemas$1(mergedAdditionalItemsSchemas, options);
}
function getSchemaForProperty(schema2, propertyName) {
  const { properties: properties2, patternProperties: patternProperties2, additionalProperties: additionalProperties2 } = schema2;
  if ((properties2 == null ? void 0 : properties2[propertyName]) !== void 0) {
    return properties2[propertyName];
  }
  for (const pattern2 of Object.keys(patternProperties2 ?? {})) {
    const regexp = new RegExp(pattern2);
    if (regexp.test(propertyName)) {
      return patternProperties2[pattern2];
    }
  }
  return additionalProperties2;
}
function mergeProperties(keyword2, _values, mergedSchema, schemas2, options) {
  const foundProperties = {};
  for (const currentSchema of schemas2) {
    const properties2 = currentSchema.properties ?? {};
    for (const propertyName of Object.keys(properties2)) {
      if (foundProperties[propertyName] !== void 0) continue;
      const propertySchema = properties2[propertyName];
      foundProperties[propertyName] = [propertySchema];
      for (const anotherSchema of schemas2) {
        if (currentSchema === anotherSchema) continue;
        const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
        if (propertySchema2 !== void 0) {
          foundProperties[propertyName].push(propertySchema2);
        }
      }
    }
  }
  const mergedProperties = {};
  for (const property of Object.keys(foundProperties)) {
    const propertySchemas = foundProperties[property];
    mergedProperties[property] = _mergeSchemas$1(propertySchemas, options);
  }
  mergedSchema[keyword2] = mergedProperties;
}
function mergeObjects(keyword2, values2, mergedSchema, _schemas2, options) {
  const objectsProperties = {};
  for (const properties2 of values2) {
    for (const propertyName of Object.keys(properties2)) {
      if (objectsProperties[propertyName] === void 0) {
        objectsProperties[propertyName] = [];
      }
      objectsProperties[propertyName].push(properties2[propertyName]);
    }
  }
  const mergedProperties = {};
  for (const propertyName of Object.keys(objectsProperties)) {
    const propertySchemas = objectsProperties[propertyName];
    const mergedPropertySchema = _mergeSchemas$1(propertySchemas, options);
    mergedProperties[propertyName] = mergedPropertySchema;
  }
  mergedSchema[keyword2] = mergedProperties;
}
function mergeIfThenElseSchemas(_keyword, _values, mergedSchema, schemas2, options) {
  for (let i = 0; i < schemas2.length; i++) {
    const subSchema = {
      if: schemas2[i].if,
      then: schemas2[i].then,
      else: schemas2[i].else
    };
    if (subSchema.if === void 0) continue;
    if (mergedSchema.if === void 0) {
      mergedSchema.if = subSchema.if;
      if (subSchema.then !== void 0) {
        mergedSchema.then = subSchema.then;
      }
      if (subSchema.else !== void 0) {
        mergedSchema.else = subSchema.else;
      }
      continue;
    }
    if (mergedSchema.then !== void 0) {
      mergedSchema.then = _mergeSchemas$1([mergedSchema.then, subSchema], options);
    }
    if (mergedSchema.else !== void 0) {
      mergedSchema.else = _mergeSchemas$1([mergedSchema.else, subSchema], options);
    }
  }
}
function mergeDependencies(keyword2, values2, mergedSchema) {
  const mergedDependencies = {};
  for (const dependencies2 of values2) {
    for (const propertyName of Object.keys(dependencies2)) {
      if (mergedDependencies[propertyName] === void 0) {
        mergedDependencies[propertyName] = [];
      }
      const mergedPropertyDependencies = mergedDependencies[propertyName];
      for (const propertyDependency of dependencies2[propertyName]) {
        if (!mergedPropertyDependencies.includes(propertyDependency)) {
          mergedPropertyDependencies.push(propertyDependency);
        }
      }
    }
  }
  mergedSchema[keyword2] = mergedDependencies;
}
function _mergeSchemas$1(schemas2, options) {
  if (schemas2.length === 0) return {};
  if (schemas2.length === 1) return schemas2[0];
  const mergedSchema = {};
  const keywords = {};
  let allSchemasAreTrue = true;
  for (const schema2 of schemas2) {
    if (schema2 === false) return false;
    if (schema2 === true) continue;
    allSchemasAreTrue = false;
    for (const keyword2 of Object.keys(schema2)) {
      if (keywords[keyword2] === void 0) {
        keywords[keyword2] = [];
      }
      keywords[keyword2].push(schema2[keyword2]);
    }
  }
  if (allSchemasAreTrue) return true;
  for (const keyword2 of Object.keys(keywords)) {
    const keywordValues = keywords[keyword2];
    const resolver = options.resolvers[keyword2] ?? options.defaultResolver;
    resolver(keyword2, keywordValues, mergedSchema, schemas2, options);
  }
  return mergedSchema;
}
function defaultResolver(keyword2, values2, mergedSchema, _schemas2, options) {
  const onConflict = options.onConflict ?? "throw";
  if (values2.length === 1 || onConflict === "first") {
    mergedSchema[keyword2] = values2[0];
    return;
  }
  let allValuesEqual = true;
  for (let i = 1; i < values2.length; i++) {
    if (!deepEqual$2(values2[i], values2[0])) {
      allValuesEqual = false;
      break;
    }
  }
  if (allValuesEqual) {
    mergedSchema[keyword2] = values2[0];
    return;
  }
  if (onConflict === "throw") {
    throw new errors$1.ResolverNotFoundError(keyword2, values2);
  }
  if (onConflict === "skip") {
    return;
  }
  throw new errors$1.InvalidOnConflictOptionError(onConflict);
}
function mergeSchemas$2(schemas2, options = {}) {
  if (options.defaultResolver === void 0) {
    options.defaultResolver = defaultResolver;
  }
  options.resolvers = { ...keywordsResolvers, ...options.resolvers };
  const mergedSchema = _mergeSchemas$1(schemas2, options);
  return mergedSchema;
}
var mergeJsonSchemas = { mergeSchemas: mergeSchemas$2, ...errors$1 };
const { mergeSchemas: _mergeSchemas } = mergeJsonSchemas;
function mergeSchemas$1(schemas2) {
  return _mergeSchemas(schemas2, { onConflict: "skip" });
}
var mergeSchemas_1 = mergeSchemas$1;
var standalone$2 = { exports: {} };
var hasRequiredStandalone$1;
function requireStandalone$1() {
  if (hasRequiredStandalone$1) return standalone$2.exports;
  hasRequiredStandalone$1 = 1;
  function buildStandaloneCode(contextFunc, context2, serializer2, validator2) {
    let ajvDependencyCode = "";
    if (context2.validatorSchemasIds.size > 0) {
      ajvDependencyCode += "const Validator = require('fast-json-stringify/lib/validator')\n";
      ajvDependencyCode += `const validatorState = ${JSON.stringify(validator2.getState())}
`;
      ajvDependencyCode += "const validator = Validator.restoreFromState(validatorState)\n";
    } else {
      ajvDependencyCode += "const validator = null\n";
    }
    const { schema: schema2, ...serializerState2 } = serializer2.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState2)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
  }
  standalone$2.exports = buildStandaloneCode;
  standalone$2.exports.dependencies = {
    Serializer: serializer$1,
    Validator: validator$1
  };
  return standalone$2.exports;
}
const { RefResolver } = jsonSchemaRefResolver;
const Serializer2 = serializer$1;
const Validator2 = validator$1;
const Location2 = location;
const validate$1 = schemaValidatorExports;
const mergeSchemas = mergeSchemas_1;
const SINGLE_TICK = /'/g;
let largeArraySize = 2e4;
let largeArrayMechanism = "default";
const validRoundingMethods = [
  "floor",
  "ceil",
  "round",
  "trunc"
];
const validLargeArrayMechanisms = [
  "default",
  "json-stringify"
];
let schemaIdCounter = 0;
function isValidSchema(schema2, name) {
  if (!validate$1(schema2)) {
    if (name) {
      name = `"${name}" `;
    } else {
      name = "";
    }
    const first = validate$1.errors[0];
    const err2 = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
    err2.errors = isValidSchema.errors;
    throw err2;
  }
}
function resolveRef(context2, location2) {
  const ref2 = location2.schema.$ref;
  let hashIndex = ref2.indexOf("#");
  if (hashIndex === -1) {
    hashIndex = ref2.length;
  }
  const schemaId = ref2.slice(0, hashIndex) || location2.schemaId;
  const jsonPointer = ref2.slice(hashIndex) || "#";
  const schema2 = context2.refResolver.getSchema(schemaId, jsonPointer);
  if (schema2 === null) {
    throw new Error(`Cannot find reference "${ref2}"`);
  }
  const newLocation = new Location2(schema2, schemaId, jsonPointer);
  if (schema2.$ref !== void 0) {
    return resolveRef(context2, newLocation);
  }
  return newLocation;
}
function getMergedLocation(context2, mergedSchemaId) {
  const mergedSchema = context2.refResolver.getSchema(mergedSchemaId, "#");
  return new Location2(mergedSchema, mergedSchemaId, "#");
}
function getSchemaId(schema2, rootSchemaId) {
  if (schema2.$id && schema2.$id.charAt(0) !== "#") {
    return schema2.$id;
  }
  return rootSchemaId;
}
function build(schema2, options) {
  isValidSchema(schema2);
  options = options || {};
  const context2 = {
    functions: [],
    functionsCounter: 0,
    functionsNamesBySchema: /* @__PURE__ */ new Map(),
    options,
    refResolver: new RefResolver(),
    rootSchemaId: schema2.$id || `__fjs_root_${schemaIdCounter++}`,
    validatorSchemasIds: /* @__PURE__ */ new Set(),
    mergedSchemasIds: /* @__PURE__ */ new Map()
  };
  const schemaId = getSchemaId(schema2, context2.rootSchemaId);
  if (!context2.refResolver.hasSchema(schemaId)) {
    context2.refResolver.addSchema(schema2, context2.rootSchemaId);
  }
  if (options.schema) {
    for (const key in options.schema) {
      const schema3 = options.schema[key];
      const schemaId2 = getSchemaId(schema3, key);
      if (!context2.refResolver.hasSchema(schemaId2)) {
        isValidSchema(schema3, key);
        context2.refResolver.addSchema(schema3, key);
      }
    }
  }
  if (options.rounding) {
    if (!validRoundingMethods.includes(options.rounding)) {
      throw new Error(`Unsupported integer rounding method ${options.rounding}`);
    }
  }
  if (options.largeArrayMechanism) {
    if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
      largeArrayMechanism = options.largeArrayMechanism;
    } else {
      throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
    }
  }
  if (options.largeArraySize) {
    if (typeof options.largeArraySize === "string" && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
      largeArraySize = Number.parseInt(options.largeArraySize, 10);
    } else if (typeof options.largeArraySize === "number" && Number.isInteger(options.largeArraySize)) {
      largeArraySize = options.largeArraySize;
    } else if (typeof options.largeArraySize === "bigint") {
      largeArraySize = Number(options.largeArraySize);
    } else {
      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
    }
  }
  const location2 = new Location2(schema2, context2.rootSchemaId);
  const code2 = buildValue(context2, location2, "input");
  let contextFunctionCode = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
  if (code2 === "json += anonymous0(input)") {
    contextFunctionCode += `
    ${context2.functions.join("\n")}
    const main = anonymous0
    return main
    `;
  } else {
    contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code2}
      return json
    }
    ${context2.functions.join("\n")}
    return main
    `;
  }
  const serializer2 = new Serializer2(options);
  const validator2 = new Validator2(options.ajv);
  for (const schemaId2 of context2.validatorSchemasIds) {
    const schema3 = context2.refResolver.getSchema(schemaId2);
    validator2.addSchema(schema3, schemaId2);
    const dependencies2 = context2.refResolver.getSchemaDependencies(schemaId2);
    for (const [schemaId3, schema4] of Object.entries(dependencies2)) {
      validator2.addSchema(schema4, schemaId3);
    }
  }
  if (options.debugMode) {
    options.mode = "debug";
  }
  if (options.mode === "debug") {
    return {
      validator: validator2,
      serializer: serializer2,
      code: `validator
serializer
${contextFunctionCode}`,
      ajv: validator2.ajv
    };
  }
  const contextFunc = new Function("validator", "serializer", contextFunctionCode);
  if (options.mode === "standalone") {
    const buildStandaloneCode = requireStandalone$1();
    return buildStandaloneCode(contextFunc, context2, serializer2, validator2);
  }
  return contextFunc(validator2, serializer2);
}
const objectKeywords = [
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "maxProperties",
  "minProperties",
  "dependencies"
];
const arrayKeywords = [
  "items",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "contains"
];
const stringKeywords = [
  "maxLength",
  "minLength",
  "pattern"
];
const numberKeywords = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum"
];
function inferTypeByKeyword(schema2) {
  for (const keyword2 of objectKeywords) {
    if (keyword2 in schema2) return "object";
  }
  for (const keyword2 of arrayKeywords) {
    if (keyword2 in schema2) return "array";
  }
  for (const keyword2 of stringKeywords) {
    if (keyword2 in schema2) return "string";
  }
  for (const keyword2 of numberKeywords) {
    if (keyword2 in schema2) return "number";
  }
  return schema2.type;
}
function buildExtraObjectPropertiesSerializer(context2, location2, addComma2) {
  const schema2 = location2.schema;
  const propertiesKeys = Object.keys(schema2.properties || {});
  let code2 = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
  const patternPropertiesLocation = location2.getPropertyLocation("patternProperties");
  const patternPropertiesSchema = patternPropertiesLocation.schema;
  if (patternPropertiesSchema !== void 0) {
    for (const propertyKey in patternPropertiesSchema) {
      const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
      code2 += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma2}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${buildValue(context2, propertyLocation, "value")}
          continue
        }
      `;
    }
  }
  const additionalPropertiesLocation = location2.getPropertyLocation("additionalProperties");
  const additionalPropertiesSchema = additionalPropertiesLocation.schema;
  if (additionalPropertiesSchema !== void 0) {
    if (additionalPropertiesSchema === true) {
      code2 += `
        ${addComma2}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
    } else {
      const propertyLocation = location2.getPropertyLocation("additionalProperties");
      code2 += `
        ${addComma2}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${buildValue(context2, propertyLocation, "value")}
      `;
    }
  }
  code2 += `
    }
  `;
  return code2;
}
function buildInnerObject(context2, location2) {
  const schema2 = location2.schema;
  const propertiesLocation = location2.getPropertyLocation("properties");
  const requiredProperties = schema2.required || [];
  const propertiesKeys = Object.keys(schema2.properties || {}).sort(
    (key1, key2) => {
      const required1 = requiredProperties.includes(key1);
      const required2 = requiredProperties.includes(key2);
      return required1 === required2 ? 0 : required1 ? -1 : 1;
    }
  );
  const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);
  let code2 = "let value\n";
  for (const key of requiredProperties) {
    if (!propertiesKeys.includes(key)) {
      const sanitizedKey = JSON.stringify(key);
      code2 += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
`;
    }
  }
  code2 += "let json = JSON_STR_BEGIN_OBJECT\n";
  let addComma2 = "";
  if (!hasRequiredProperties) {
    code2 += "let addComma = false\n";
    addComma2 = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)";
  }
  for (const key of propertiesKeys) {
    let propertyLocation = propertiesLocation.getPropertyLocation(key);
    if (propertyLocation.schema.$ref) {
      propertyLocation = resolveRef(context2, propertyLocation);
    }
    const sanitizedKey = JSON.stringify(key);
    const defaultValue = propertyLocation.schema.default;
    const isRequired = requiredProperties.includes(key);
    code2 += `
      value = obj[${sanitizedKey}]
      if (value !== undefined) {
        ${addComma2}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context2, propertyLocation, "value")}
      }`;
    if (defaultValue !== void 0) {
      code2 += ` else {
        ${addComma2}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
    } else if (isRequired) {
      code2 += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
      }
      `;
    } else {
      code2 += "\n";
    }
    if (hasRequiredProperties) {
      addComma2 = "json += ','";
    }
  }
  if (schema2.patternProperties || schema2.additionalProperties) {
    code2 += buildExtraObjectPropertiesSerializer(context2, location2, addComma2);
  }
  code2 += `
    return json + JSON_STR_END_OBJECT
  `;
  return code2;
}
function mergeLocations(context2, mergedSchemaId, mergedLocations) {
  for (let i = 0; i < mergedLocations.length; i++) {
    const location2 = mergedLocations[i];
    const schema2 = location2.schema;
    if (schema2.$ref) {
      mergedLocations[i] = resolveRef(context2, location2);
    }
  }
  const mergedSchemas = [];
  for (const location2 of mergedLocations) {
    const schema2 = cloneOriginSchema(context2, location2.schema, location2.schemaId);
    delete schema2.$id;
    mergedSchemas.push(schema2);
  }
  const mergedSchema = mergeSchemas(mergedSchemas);
  const mergedLocation = new Location2(mergedSchema, mergedSchemaId);
  context2.refResolver.addSchema(mergedSchema, mergedSchemaId);
  return mergedLocation;
}
function cloneOriginSchema(context2, schema2, schemaId) {
  const clonedSchema = Array.isArray(schema2) ? [] : {};
  if (schema2.$id !== void 0 && schema2.$id.charAt(0) !== "#") {
    schemaId = schema2.$id;
  }
  const mergedSchemaRef = context2.mergedSchemasIds.get(schema2);
  if (mergedSchemaRef) {
    context2.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
  }
  for (const key in schema2) {
    let value = schema2[key];
    if (key === "$ref" && typeof value === "string" && value.charAt(0) === "#") {
      value = schemaId + value;
    }
    if (typeof value === "object" && value !== null) {
      value = cloneOriginSchema(context2, value, schemaId);
    }
    clonedSchema[key] = value;
  }
  return clonedSchema;
}
function toJSON(variableName) {
  return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
}
function buildObject(context2, location2) {
  const schema2 = location2.schema;
  if (context2.functionsNamesBySchema.has(schema2)) {
    return context2.functionsNamesBySchema.get(schema2);
  }
  const functionName = generateFuncName(context2);
  context2.functionsNamesBySchema.set(schema2, functionName);
  let schemaRef = location2.getSchemaRef();
  if (schemaRef.startsWith(context2.rootSchemaId)) {
    schemaRef = schemaRef.replace(context2.rootSchemaId, "");
  }
  let functionCode = `
  `;
  const nullable2 = schema2.nullable === true;
  functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON("input")}
      ${!nullable2 ? "if (obj === null) return JSON_STR_EMPTY_OBJECT" : ""}

      ${buildInnerObject(context2, location2)}
    }
  `;
  context2.functions.push(functionCode);
  return functionName;
}
function buildArray(context2, location2) {
  const schema2 = location2.schema;
  let itemsLocation = location2.getPropertyLocation("items");
  itemsLocation.schema = itemsLocation.schema || {};
  if (itemsLocation.schema.$ref) {
    itemsLocation = resolveRef(context2, itemsLocation);
  }
  const itemsSchema = itemsLocation.schema;
  if (context2.functionsNamesBySchema.has(schema2)) {
    return context2.functionsNamesBySchema.get(schema2);
  }
  const functionName = generateFuncName(context2);
  context2.functionsNamesBySchema.set(schema2, functionName);
  let schemaRef = location2.getSchemaRef();
  if (schemaRef.startsWith(context2.rootSchemaId)) {
    schemaRef = schemaRef.replace(context2.rootSchemaId, "");
  }
  let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;
  const nullable2 = schema2.nullable === true;
  functionCode += `
    ${!nullable2 ? "if (obj === null) return JSON_STR_EMPTY_ARRAY" : ""}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
  if (!schema2.additionalItems && Array.isArray(itemsSchema)) {
    functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
  }
  if (largeArrayMechanism === "json-stringify") {
    functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)
`;
  }
  functionCode += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `;
  if (Array.isArray(itemsSchema)) {
    for (let i = 0; i < itemsSchema.length; i++) {
      const item = itemsSchema[i];
      functionCode += `value = obj[${i}]`;
      const tmpRes = buildValue(context2, itemsLocation.getPropertyLocation(i), "value");
      functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type)}) {
            ${tmpRes}
            if (${i} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
    }
    if (schema2.additionalItems) {
      functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`;
    }
  } else {
    const code2 = buildValue(context2, itemsLocation, "obj[i]");
    functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        ${code2}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
  }
  functionCode += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`;
  context2.functions.push(functionCode);
  return functionName;
}
function buildArrayTypeCondition(type2, accessor) {
  let condition;
  switch (type2) {
    case "null":
      condition = "value === null";
      break;
    case "string":
      condition = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
      break;
    case "integer":
      condition = "Number.isInteger(value)";
      break;
    case "number":
      condition = "Number.isFinite(value)";
      break;
    case "boolean":
      condition = "typeof value === 'boolean'";
      break;
    case "object":
      condition = "value && typeof value === 'object' && value.constructor === Object";
      break;
    case "array":
      condition = "Array.isArray(value)";
      break;
    default:
      if (Array.isArray(type2)) {
        const conditions = type2.map((subType) => {
          return buildArrayTypeCondition(subType);
        });
        condition = `(${conditions.join(" || ")})`;
      }
  }
  return condition;
}
function generateFuncName(context2) {
  return "anonymous" + context2.functionsCounter++;
}
function buildMultiTypeSerializer(context2, location2, input) {
  const schema2 = location2.schema;
  const types2 = schema2.type.sort((t1) => t1 === "null" ? -1 : 1);
  let code2 = "";
  types2.forEach((type2, index) => {
    location2.schema = { ...location2.schema, type: type2 };
    const nestedResult = buildSingleTypeSerializer(context2, location2, input);
    const statement = index === 0 ? "if" : "else if";
    switch (type2) {
      case "null":
        code2 += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
        break;
      case "string": {
        code2 += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
        break;
      }
      case "array": {
        code2 += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
        break;
      }
      case "integer": {
        code2 += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
        break;
      }
      default: {
        code2 += `
          ${statement}(typeof ${input} === "${type2}" || ${input} === null)
            ${nestedResult}
        `;
        break;
      }
    }
  });
  let schemaRef = location2.getSchemaRef();
  if (schemaRef.startsWith(context2.rootSchemaId)) {
    schemaRef = schemaRef.replace(context2.rootSchemaId, "");
  }
  code2 += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
  return code2;
}
function buildSingleTypeSerializer(context2, location2, input) {
  const schema2 = location2.schema;
  switch (schema2.type) {
    case "null":
      return "json += JSON_STR_NULL";
    case "string": {
      if (schema2.format === "date-time") {
        return `json += serializer.asDateTime(${input})`;
      } else if (schema2.format === "date") {
        return `json += serializer.asDate(${input})`;
      } else if (schema2.format === "time") {
        return `json += serializer.asTime(${input})`;
      } else if (schema2.format === "unsafe") {
        return `json += serializer.asUnsafeString(${input})`;
      } else {
        return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += serializer.asString(${input}.source)
          } else {
            json += serializer.asString(${input}.toString())
          }
        } else {
          json += serializer.asString(${input})
        }
        `;
      }
    }
    case "integer":
      return `json += serializer.asInteger(${input})`;
    case "number":
      return `json += serializer.asNumber(${input})`;
    case "boolean":
      return `json += serializer.asBoolean(${input})`;
    case "object": {
      const funcName = buildObject(context2, location2);
      return `json += ${funcName}(${input})`;
    }
    case "array": {
      const funcName = buildArray(context2, location2);
      return `json += ${funcName}(${input})`;
    }
    case void 0:
      return `json += JSON.stringify(${input})`;
    default:
      throw new Error(`${schema2.type} unsupported`);
  }
}
function buildConstSerializer(location2, input) {
  const schema2 = location2.schema;
  const type2 = schema2.type;
  const hasNullType = Array.isArray(type2) && type2.includes("null");
  let code2 = "";
  if (hasNullType) {
    code2 += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
  }
  code2 += `json += '${JSON.stringify(schema2.const).replace(SINGLE_TICK, "\\'")}'`;
  if (hasNullType) {
    code2 += `
      }
    `;
  }
  return code2;
}
function buildAllOf(context2, location2, input) {
  const schema2 = location2.schema;
  let mergedSchemaId = context2.mergedSchemasIds.get(schema2);
  if (mergedSchemaId) {
    const mergedLocation2 = getMergedLocation(context2, mergedSchemaId);
    return buildValue(context2, mergedLocation2, input);
  }
  mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
  context2.mergedSchemasIds.set(schema2, mergedSchemaId);
  const { allOf: allOf2, ...schemaWithoutAllOf } = location2.schema;
  const locations = [
    new Location2(
      schemaWithoutAllOf,
      location2.schemaId,
      location2.jsonPointer
    )
  ];
  const allOfsLocation = location2.getPropertyLocation("allOf");
  for (let i = 0; i < allOf2.length; i++) {
    locations.push(allOfsLocation.getPropertyLocation(i));
  }
  const mergedLocation = mergeLocations(context2, mergedSchemaId, locations);
  return buildValue(context2, mergedLocation, input);
}
function buildOneOf(context2, location2, input) {
  context2.validatorSchemasIds.add(location2.schemaId);
  const schema2 = location2.schema;
  const type2 = schema2.anyOf ? "anyOf" : "oneOf";
  const { [type2]: oneOfs, ...schemaWithoutAnyOf } = location2.schema;
  const locationWithoutOneOf = new Location2(
    schemaWithoutAnyOf,
    location2.schemaId,
    location2.jsonPointer
  );
  const oneOfsLocation = location2.getPropertyLocation(type2);
  let code2 = "";
  for (let index = 0; index < oneOfs.length; index++) {
    const optionLocation = oneOfsLocation.getPropertyLocation(index);
    const optionSchema = optionLocation.schema;
    let mergedSchemaId = context2.mergedSchemasIds.get(optionSchema);
    let mergedLocation = null;
    if (mergedSchemaId) {
      mergedLocation = getMergedLocation(context2, mergedSchemaId);
    } else {
      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context2.mergedSchemasIds.set(optionSchema, mergedSchemaId);
      mergedLocation = mergeLocations(context2, mergedSchemaId, [
        locationWithoutOneOf,
        optionLocation
      ]);
    }
    const nestedResult = buildValue(context2, mergedLocation, input);
    const schemaRef2 = optionLocation.getSchemaRef();
    code2 += `
      ${index === 0 ? "if" : "else if"}(validator.validate("${schemaRef2}", ${input}))
        ${nestedResult}
    `;
  }
  let schemaRef = location2.getSchemaRef();
  if (schemaRef.startsWith(context2.rootSchemaId)) {
    schemaRef = schemaRef.replace(context2.rootSchemaId, "");
  }
  code2 += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
  return code2;
}
function buildIfThenElse(context2, location2, input) {
  context2.validatorSchemasIds.add(location2.schemaId);
  const {
    if: ifSchema,
    then: thenSchema,
    else: elseSchema,
    ...schemaWithoutIfThenElse
  } = location2.schema;
  const rootLocation = new Location2(
    schemaWithoutIfThenElse,
    location2.schemaId,
    location2.jsonPointer
  );
  const ifLocation = location2.getPropertyLocation("if");
  const ifSchemaRef = ifLocation.getSchemaRef();
  const thenLocation = location2.getPropertyLocation("then");
  let thenMergedSchemaId = context2.mergedSchemasIds.get(thenSchema);
  let thenMergedLocation = null;
  if (thenMergedSchemaId) {
    thenMergedLocation = getMergedLocation(context2, thenMergedSchemaId);
  } else {
    thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
    context2.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
    thenMergedLocation = mergeLocations(context2, thenMergedSchemaId, [
      rootLocation,
      thenLocation
    ]);
  }
  if (!elseSchema) {
    return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context2, thenMergedLocation, input)}
      } else {
        ${buildValue(context2, rootLocation, input)}
      }
    `;
  }
  const elseLocation = location2.getPropertyLocation("else");
  let elseMergedSchemaId = context2.mergedSchemasIds.get(elseSchema);
  let elseMergedLocation = null;
  if (elseMergedSchemaId) {
    elseMergedLocation = getMergedLocation(context2, elseMergedSchemaId);
  } else {
    elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
    context2.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
    elseMergedLocation = mergeLocations(context2, elseMergedSchemaId, [
      rootLocation,
      elseLocation
    ]);
  }
  return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context2, thenMergedLocation, input)}
    } else {
      ${buildValue(context2, elseMergedLocation, input)}
    }
  `;
}
function buildValue(context2, location2, input) {
  let schema2 = location2.schema;
  if (typeof schema2 === "boolean") {
    return `json += JSON.stringify(${input})`;
  }
  if (schema2.$ref) {
    location2 = resolveRef(context2, location2);
    schema2 = location2.schema;
  }
  if (schema2.allOf) {
    return buildAllOf(context2, location2, input);
  }
  if (schema2.anyOf || schema2.oneOf) {
    return buildOneOf(context2, location2, input);
  }
  if (schema2.if && schema2.then) {
    return buildIfThenElse(context2, location2, input);
  }
  if (schema2.type === void 0) {
    const inferredType = inferTypeByKeyword(schema2);
    if (inferredType) {
      schema2.type = inferredType;
    }
  }
  let code2 = "";
  const type2 = schema2.type;
  const nullable2 = schema2.nullable === true;
  if (nullable2) {
    code2 += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
  }
  if (schema2.const !== void 0) {
    code2 += buildConstSerializer(location2, input);
  } else if (Array.isArray(type2)) {
    code2 += buildMultiTypeSerializer(context2, location2, input);
  } else {
    code2 += buildSingleTypeSerializer(context2, location2, input);
  }
  if (nullable2) {
    code2 += `
      }
    `;
  }
  return code2;
}
fastJsonStringify$1.exports = build;
fastJsonStringify$1.exports.default = build;
fastJsonStringify$1.exports.build = build;
fastJsonStringify$1.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
fastJsonStringify$1.exports.restore = function({ code: code2, validator: validator2, serializer: serializer2 }) {
  return Function.apply(null, ["validator", "serializer", code2]).apply(null, [validator2, serializer2]);
};
var fastJsonStringifyExports = fastJsonStringify$1.exports;
const fastJsonStringify = fastJsonStringifyExports;
function SerializerSelector$2() {
  return function buildSerializerFactory(externalSchemas, serializerOpts) {
    const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
    return responseSchemaCompiler.bind(null, fjsOpts);
  };
}
function responseSchemaCompiler(fjsOpts, {
  schema: schema2
  /* method, url, httpStatus */
}) {
  if (fjsOpts.schema && schema2.$id && fjsOpts.schema[schema2.$id]) {
    fjsOpts.schema = { ...fjsOpts.schema };
    delete fjsOpts.schema[schema2.$id];
  }
  return fastJsonStringify(schema2, fjsOpts);
}
function StandaloneSerializer$1(options = { readMode: true }) {
  if (options.readMode === true && typeof options.restoreFunction !== "function") {
    throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
  }
  if (options.readMode !== true && typeof options.storeFunction !== "function") {
    throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
  }
  if (options.readMode === true) {
    return function wrapper() {
      return function(opts) {
        return options.restoreFunction(opts);
      };
    };
  }
  const factory = SerializerSelector$2();
  return function wrapper(externalSchemas, serializerOpts = {}) {
    serializerOpts.mode = "standalone";
    const compiler = factory(externalSchemas, serializerOpts);
    return function(opts) {
      const serializeFuncCode = compiler(opts);
      options.storeFunction(opts, serializeFuncCode);
      return new Function(serializeFuncCode);
    };
  };
}
standalone$3.SerializerSelector = SerializerSelector$2;
standalone$3.StandaloneSerializer = StandaloneSerializer$1;
standalone$3.default = StandaloneSerializer$1;
const { SerializerSelector: SerializerSelector$1, StandaloneSerializer } = standalone$3;
fastJsonStringifyCompiler.exports = SerializerSelector$1;
fastJsonStringifyCompiler.exports.default = SerializerSelector$1;
fastJsonStringifyCompiler.exports.SerializerSelector = SerializerSelector$1;
fastJsonStringifyCompiler.exports.StandaloneSerializer = StandaloneSerializer;
var fastJsonStringifyCompilerExports = fastJsonStringifyCompiler.exports;
var ajvCompiler = { exports: {} };
var jtd$1 = { exports: {} };
var jtd = {};
var ref$1 = {};
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.checkMetadata = void 0;
const util_1$b = util$9;
const def$7 = {
  keyword: "metadata",
  schemaType: "object",
  code(cxt) {
    checkMetadata(cxt);
    const { gen, schema: schema2, it } = cxt;
    if ((0, util_1$b.alwaysValidSchema)(it, schema2))
      return;
    const valid2 = gen.name("valid");
    cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid2);
    cxt.ok(valid2);
  }
};
function checkMetadata({ it, keyword: keyword2 }, metadata2) {
  if (it.jtdMetadata !== metadata2) {
    throw new Error(`JTD: "${keyword2}" cannot be used in this schema location`);
  }
}
metadata.checkMetadata = checkMetadata;
metadata.default = def$7;
Object.defineProperty(ref$1, "__esModule", { value: true });
ref$1.hasRef = void 0;
const compile_1 = compile;
const codegen_1$8 = codegen;
const ref_error_1$2 = ref_error;
const names_1$2 = names$1;
const ref_1$3 = ref$2;
const metadata_1$5 = metadata;
const def$6 = {
  keyword: "ref",
  schemaType: "string",
  code(cxt) {
    (0, metadata_1$5.checkMetadata)(cxt);
    const { gen, data, schema: ref2, parentSchema, it } = cxt;
    const { schemaEnv: { root: root2 } } = it;
    const valid2 = gen.name("valid");
    if (parentSchema.nullable) {
      gen.var(valid2, (0, codegen_1$8._)`${data} === null`);
      gen.if((0, codegen_1$8.not)(valid2), validateJtdRef);
    } else {
      gen.var(valid2, false);
      validateJtdRef();
    }
    cxt.ok(valid2);
    function validateJtdRef() {
      var _a2;
      const refSchema = (_a2 = root2.schema.definitions) === null || _a2 === void 0 ? void 0 : _a2[ref2];
      if (!refSchema) {
        throw new ref_error_1$2.default(it.opts.uriResolver, "", ref2, `No definition ${ref2}`);
      }
      if (hasRef(refSchema) || !it.opts.inlineRefs)
        callValidate(refSchema);
      else
        inlineRefSchema(refSchema);
    }
    function callValidate(schema2) {
      const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema: schema2, root: root2, schemaPath: `/definitions/${ref2}` }));
      const v = (0, ref_1$3.getValidate)(cxt, sch);
      const errsCount = gen.const("_errs", names_1$2.default.errors);
      (0, ref_1$3.callRef)(cxt, v, sch, sch.$async);
      gen.assign(valid2, (0, codegen_1$8._)`${errsCount} === ${names_1$2.default.errors}`);
    }
    function inlineRefSchema(schema2) {
      const schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema2, code: (0, codegen_1$8.stringify)(schema2) } : { ref: schema2 });
      cxt.subschema({
        schema: schema2,
        dataTypes: [],
        schemaPath: codegen_1$8.nil,
        topSchemaRef: schName,
        errSchemaPath: `/definitions/${ref2}`
      }, valid2);
    }
  }
};
function hasRef(schema2) {
  for (const key in schema2) {
    let sch;
    if (key === "ref" || typeof (sch = schema2[key]) == "object" && hasRef(sch))
      return true;
  }
  return false;
}
ref$1.hasRef = hasRef;
ref$1.default = def$6;
var type$2 = {};
var timestamp$1 = {};
Object.defineProperty(timestamp$1, "__esModule", { value: true });
const DT_SEPARATOR = /t|\s/i;
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function validTimestamp(str2, allowDate) {
  const dt = str2.split(DT_SEPARATOR);
  return dt.length === 2 && validDate(dt[0]) && validTime(dt[1]) || allowDate && dt.length === 1 && validDate(dt[0]);
}
timestamp$1.default = validTimestamp;
function validDate(str2) {
  const matches = DATE.exec(str2);
  if (!matches)
    return false;
  const y = +matches[1];
  const m = +matches[2];
  const d = +matches[3];
  return m >= 1 && m <= 12 && d >= 1 && (d <= DAYS[m] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
  m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0));
}
function validTime(str2) {
  const matches = TIME.exec(str2);
  if (!matches)
    return false;
  const hr = +matches[1];
  const min2 = +matches[2];
  const sec = +matches[3];
  const tzH = +(matches[4] || 0);
  const tzM = +(matches[5] || 0);
  return hr <= 23 && min2 <= 59 && sec <= 59 || // leap second
  hr - tzH === 23 && min2 - tzM === 59 && sec === 60;
}
validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
var error$3 = {};
Object.defineProperty(error$3, "__esModule", { value: true });
error$3.typeErrorParams = error$3.typeErrorMessage = error$3.typeError = void 0;
const codegen_1$7 = codegen;
function typeError(t2) {
  return {
    message: (cxt) => typeErrorMessage(cxt, t2),
    params: (cxt) => typeErrorParams(cxt, t2)
  };
}
error$3.typeError = typeError;
function typeErrorMessage({ parentSchema }, t2) {
  return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t2} or null` : `must be ${t2}`;
}
error$3.typeErrorMessage = typeErrorMessage;
function typeErrorParams({ parentSchema }, t2) {
  return (0, codegen_1$7._)`{type: ${t2}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
}
error$3.typeErrorParams = typeErrorParams;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intRange = void 0;
  const codegen_12 = codegen;
  const timestamp_12 = timestamp$1;
  const util_12 = util$9;
  const metadata_12 = metadata;
  const error_12 = error$3;
  exports.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10]
  };
  const error2 = {
    message: (cxt) => (0, error_12.typeErrorMessage)(cxt, cxt.schema),
    params: (cxt) => (0, error_12.typeErrorParams)(cxt, cxt.schema)
  };
  function timestampCode(cxt) {
    const { gen, data, it } = cxt;
    const { timestamp: timestamp2, allowDate } = it.opts;
    if (timestamp2 === "date")
      return (0, codegen_12._)`${data} instanceof Date `;
    const vts = (0, util_12.useFunc)(gen, timestamp_12.default);
    const allowDateArg = allowDate ? (0, codegen_12._)`, true` : codegen_12.nil;
    const validString = (0, codegen_12._)`typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
    return timestamp2 === "string" ? validString : (0, codegen_12.or)((0, codegen_12._)`${data} instanceof Date`, validString);
  }
  const def2 = {
    keyword: "type",
    schemaType: "string",
    error: error2,
    code(cxt) {
      (0, metadata_12.checkMetadata)(cxt);
      const { data, schema: schema2, parentSchema, it } = cxt;
      let cond;
      switch (schema2) {
        case "boolean":
        case "string":
          cond = (0, codegen_12._)`typeof ${data} == ${schema2}`;
          break;
        case "timestamp": {
          cond = timestampCode(cxt);
          break;
        }
        case "float32":
        case "float64":
          cond = (0, codegen_12._)`typeof ${data} == "number"`;
          break;
        default: {
          const sch = schema2;
          cond = (0, codegen_12._)`typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
          if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
            if (sch === "uint32")
              cond = (0, codegen_12._)`${cond} && ${data} >= 0`;
          } else {
            const [min2, max2] = exports.intRange[sch];
            cond = (0, codegen_12._)`${cond} && ${data} >= ${min2} && ${data} <= ${max2}`;
          }
        }
      }
      cxt.pass(parentSchema.nullable ? (0, codegen_12.or)((0, codegen_12._)`${data} === null`, cond) : cond);
    }
  };
  exports.default = def2;
})(type$2);
var _enum = {};
var nullable = {};
Object.defineProperty(nullable, "__esModule", { value: true });
nullable.checkNullableObject = nullable.checkNullable = void 0;
const codegen_1$6 = codegen;
function checkNullable({ gen, data, parentSchema }, cond = codegen_1$6.nil) {
  const valid2 = gen.name("valid");
  if (parentSchema.nullable) {
    gen.let(valid2, (0, codegen_1$6._)`${data} === null`);
    cond = (0, codegen_1$6.not)(valid2);
  } else {
    gen.let(valid2, false);
  }
  return [valid2, cond];
}
nullable.checkNullable = checkNullable;
function checkNullableObject(cxt, cond) {
  const [valid2, cond_] = checkNullable(cxt, cond);
  return [valid2, (0, codegen_1$6._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
}
nullable.checkNullableObject = checkNullableObject;
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$5 = codegen;
const metadata_1$4 = metadata;
const nullable_1$3 = nullable;
const error$2 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$5._)`{allowedValues: ${schemaCode}}`
};
const def$5 = {
  keyword: "enum",
  schemaType: "array",
  error: error$2,
  code(cxt) {
    (0, metadata_1$4.checkMetadata)(cxt);
    const { gen, data, schema: schema2, schemaValue, parentSchema, it } = cxt;
    if (schema2.length === 0)
      throw new Error("enum must have non-empty array");
    if (schema2.length !== new Set(schema2).size)
      throw new Error("enum items must be unique");
    let valid2;
    const isString2 = (0, codegen_1$5._)`typeof ${data} == "string"`;
    if (schema2.length >= it.opts.loopEnum) {
      let cond;
      [valid2, cond] = (0, nullable_1$3.checkNullable)(cxt, isString2);
      gen.if(cond, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      valid2 = (0, codegen_1$5.and)(isString2, (0, codegen_1$5.or)(...schema2.map((value) => (0, codegen_1$5._)`${data} === ${value}`)));
      if (parentSchema.nullable)
        valid2 = (0, codegen_1$5.or)((0, codegen_1$5._)`${data} === null`, valid2);
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1$5._)`${valid2} = ${data} === ${v}`, () => gen.break()));
    }
  }
};
_enum.default = def$5;
var elements = {};
Object.defineProperty(elements, "__esModule", { value: true });
const util_1$a = util$9;
const code_1$3 = code;
const codegen_1$4 = codegen;
const metadata_1$3 = metadata;
const nullable_1$2 = nullable;
const error_1$5 = error$3;
const def$4 = {
  keyword: "elements",
  schemaType: "object",
  error: (0, error_1$5.typeError)("array"),
  code(cxt) {
    (0, metadata_1$3.checkMetadata)(cxt);
    const { gen, data, schema: schema2, it } = cxt;
    if ((0, util_1$a.alwaysValidSchema)(it, schema2))
      return;
    const [valid2] = (0, nullable_1$2.checkNullable)(cxt);
    gen.if((0, codegen_1$4.not)(valid2), () => gen.if((0, codegen_1$4._)`Array.isArray(${data})`, () => gen.assign(valid2, (0, code_1$3.validateArray)(cxt)), () => cxt.error()));
    cxt.ok(valid2);
  }
};
elements.default = def$4;
var properties = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateProperties = exports.error = void 0;
  const code_12 = code;
  const util_12 = util$9;
  const codegen_12 = codegen;
  const metadata_12 = metadata;
  const nullable_12 = nullable;
  const error_12 = error$3;
  var PropError;
  (function(PropError2) {
    PropError2["Additional"] = "additional";
    PropError2["Missing"] = "missing";
  })(PropError || (PropError = {}));
  exports.error = {
    message: (cxt) => {
      const { params } = cxt;
      return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_12.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
      const { params } = cxt;
      return params.propError ? params.propError === PropError.Additional ? (0, codegen_12._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_12._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_12.typeErrorParams)(cxt, "object");
    }
  };
  const def2 = {
    keyword: "properties",
    schemaType: "object",
    error: exports.error,
    code: validateProperties
  };
  function validateProperties(cxt) {
    (0, metadata_12.checkMetadata)(cxt);
    const { gen, data, parentSchema, it } = cxt;
    const { additionalProperties: additionalProperties2, nullable: nullable2 } = parentSchema;
    if (it.jtdDiscriminator && nullable2)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (commonProperties()) {
      throw new Error("JTD: properties and optionalProperties have common members");
    }
    const [allProps, properties2] = schemaProperties2("properties");
    const [allOptProps, optProperties] = schemaProperties2("optionalProperties");
    if (properties2.length === 0 && optProperties.length === 0 && additionalProperties2) {
      return;
    }
    const [valid2, cond] = it.jtdDiscriminator === void 0 ? (0, nullable_12.checkNullableObject)(cxt, data) : [gen.let("valid", false), true];
    gen.if(cond, () => gen.assign(valid2, true).block(() => {
      validateProps(properties2, "properties", true);
      validateProps(optProperties, "optionalProperties");
      if (!additionalProperties2)
        validateAdditional();
    }));
    cxt.pass(valid2);
    function commonProperties() {
      const props = parentSchema.properties;
      const optProps = parentSchema.optionalProperties;
      if (!(props && optProps))
        return false;
      for (const p in props) {
        if (Object.prototype.hasOwnProperty.call(optProps, p))
          return true;
      }
      return false;
    }
    function schemaProperties2(keyword2) {
      const schema2 = parentSchema[keyword2];
      const allPs = schema2 ? (0, code_12.allSchemaProperties)(schema2) : [];
      if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
        throw new Error(`JTD: discriminator tag used in ${keyword2}`);
      }
      const ps = allPs.filter((p) => !(0, util_12.alwaysValidSchema)(it, schema2[p]));
      return [allPs, ps];
    }
    function validateProps(props, keyword2, required2) {
      const _valid = gen.var("valid");
      for (const prop of props) {
        gen.if((0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword2, _valid), () => missingProperty(prop));
        cxt.ok(_valid);
      }
      function missingProperty(prop) {
        if (required2) {
          gen.assign(_valid, false);
          cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
        } else {
          gen.assign(_valid, true);
        }
      }
    }
    function applyPropertySchema(prop, keyword2, _valid) {
      cxt.subschema({
        keyword: keyword2,
        schemaProp: prop,
        dataProp: prop
      }, _valid);
    }
    function validateAdditional() {
      gen.forIn("key", data, (key) => {
        const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
        const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
        const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_12.and)(addProp, addOptProp);
        gen.if(extra, () => {
          if (it.opts.removeAdditional) {
            gen.code((0, codegen_12._)`delete ${data}[${key}]`);
          } else {
            cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
            if (!it.opts.allErrors)
              gen.break();
          }
        });
      });
    }
    function isAdditional(key, props, keyword2, jtdDiscriminator) {
      let additional;
      if (props.length > 8) {
        const propsSchema = (0, util_12.schemaRefOrVal)(it, parentSchema[keyword2], keyword2);
        additional = (0, codegen_12.not)((0, code_12.isOwnProperty)(gen, propsSchema, key));
        if (jtdDiscriminator !== void 0) {
          additional = (0, codegen_12.and)(additional, (0, codegen_12._)`${key} !== ${jtdDiscriminator}`);
        }
      } else if (props.length || jtdDiscriminator !== void 0) {
        const ps = jtdDiscriminator === void 0 ? props : [jtdDiscriminator].concat(props);
        additional = (0, codegen_12.and)(...ps.map((p) => (0, codegen_12._)`${key} !== ${p}`));
      } else {
        additional = true;
      }
      return additional;
    }
  }
  exports.validateProperties = validateProperties;
  exports.default = def2;
})(properties);
var optionalProperties = {};
Object.defineProperty(optionalProperties, "__esModule", { value: true });
const properties_1$1 = properties;
const def$3 = {
  keyword: "optionalProperties",
  schemaType: "object",
  error: properties_1$1.error,
  code(cxt) {
    if (cxt.parentSchema.properties)
      return;
    (0, properties_1$1.validateProperties)(cxt);
  }
};
optionalProperties.default = def$3;
var discriminator = {};
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1$3 = codegen;
const metadata_1$2 = metadata;
const nullable_1$1 = nullable;
const error_1$4 = error$3;
const types_1$d = types$5;
const error$1 = {
  message: (cxt) => {
    const { schema: schema2, params } = cxt;
    return params.discrError ? params.discrError === types_1$d.DiscrError.Tag ? `tag "${schema2}" must be string` : `value of tag "${schema2}" must be in mapping` : (0, error_1$4.typeErrorMessage)(cxt, "object");
  },
  params: (cxt) => {
    const { schema: schema2, params } = cxt;
    return params.discrError ? (0, codegen_1$3._)`{error: ${params.discrError}, tag: ${schema2}, tagValue: ${params.tag}}` : (0, error_1$4.typeErrorParams)(cxt, "object");
  }
};
const def$2 = {
  keyword: "discriminator",
  schemaType: "string",
  implements: ["mapping"],
  error: error$1,
  code(cxt) {
    (0, metadata_1$2.checkMetadata)(cxt);
    const { gen, data, schema: schema2, parentSchema } = cxt;
    const [valid2, cond] = (0, nullable_1$1.checkNullableObject)(cxt, data);
    gen.if(cond);
    validateDiscriminator();
    gen.elseIf((0, codegen_1$3.not)(valid2));
    cxt.error();
    gen.endIf();
    cxt.ok(valid2);
    function validateDiscriminator() {
      const tag = gen.const("tag", (0, codegen_1$3._)`${data}${(0, codegen_1$3.getProperty)(schema2)}`);
      gen.if((0, codegen_1$3._)`${tag} === undefined`);
      cxt.error(false, { discrError: types_1$d.DiscrError.Tag, tag });
      gen.elseIf((0, codegen_1$3._)`typeof ${tag} == "string"`);
      validateMapping(tag);
      gen.else();
      cxt.error(false, { discrError: types_1$d.DiscrError.Tag, tag }, { instancePath: schema2 });
      gen.endIf();
    }
    function validateMapping(tag) {
      gen.if(false);
      for (const tagValue in parentSchema.mapping) {
        gen.elseIf((0, codegen_1$3._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(tagValue));
      }
      gen.else();
      cxt.error(false, { discrError: types_1$d.DiscrError.Mapping, tag }, { instancePath: schema2, schemaPath: "mapping", parentSchema: true });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      cxt.subschema({
        keyword: "mapping",
        schemaProp,
        jtdDiscriminator: schema2
      }, _valid);
      return _valid;
    }
  }
};
discriminator.default = def$2;
var values = {};
Object.defineProperty(values, "__esModule", { value: true });
const util_1$9 = util$9;
const codegen_1$2 = codegen;
const metadata_1$1 = metadata;
const nullable_1 = nullable;
const error_1$3 = error$3;
const def$1 = {
  keyword: "values",
  schemaType: "object",
  error: (0, error_1$3.typeError)("object"),
  code(cxt) {
    (0, metadata_1$1.checkMetadata)(cxt);
    const { gen, data, schema: schema2, it } = cxt;
    const [valid2, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
    if ((0, util_1$9.alwaysValidSchema)(it, schema2)) {
      gen.if((0, codegen_1$2.not)((0, codegen_1$2.or)(cond, valid2)), () => cxt.error());
    } else {
      gen.if(cond);
      gen.assign(valid2, validateMap());
      gen.elseIf((0, codegen_1$2.not)(valid2));
      cxt.error();
      gen.endIf();
    }
    cxt.ok(valid2);
    function validateMap() {
      const _valid = gen.name("valid");
      if (it.allErrors) {
        const validMap = gen.let("valid", true);
        validateValues(() => gen.assign(validMap, false));
        return validMap;
      }
      gen.var(_valid, true);
      validateValues(() => gen.break());
      return _valid;
      function validateValues(notValid) {
        gen.forIn("key", data, (key) => {
          cxt.subschema({
            keyword: "values",
            dataProp: key,
            dataPropType: util_1$9.Type.Str
          }, _valid);
          gen.if((0, codegen_1$2.not)(_valid), notValid);
        });
      }
    }
  }
};
values.default = def$1;
var union = {};
Object.defineProperty(union, "__esModule", { value: true });
const code_1$2 = code;
const def = {
  keyword: "union",
  schemaType: "array",
  trackErrors: true,
  code: code_1$2.validateUnion,
  error: { message: "must match a schema in union" }
};
union.default = def;
Object.defineProperty(jtd, "__esModule", { value: true });
const ref_1$2 = ref$1;
const type_1$1 = type$2;
const enum_1 = _enum;
const elements_1 = elements;
const properties_1 = properties;
const optionalProperties_1 = optionalProperties;
const discriminator_1 = discriminator;
const values_1 = values;
const union_1 = union;
const metadata_1 = metadata;
const jtdVocabulary = [
  "definitions",
  ref_1$2.default,
  type_1$1.default,
  enum_1.default,
  elements_1.default,
  properties_1.default,
  optionalProperties_1.default,
  discriminator_1.default,
  values_1.default,
  union_1.default,
  metadata_1.default,
  { keyword: "additionalProperties", schemaType: "boolean" },
  { keyword: "nullable", schemaType: "boolean" }
];
jtd.default = jtdVocabulary;
var jtdSchema = {};
Object.defineProperty(jtdSchema, "__esModule", { value: true });
const shared = (root2) => {
  const sch = {
    nullable: { type: "boolean" },
    metadata: {
      optionalProperties: {
        union: { elements: { ref: "schema" } }
      },
      additionalProperties: true
    }
  };
  if (root2)
    sch.definitions = { values: { ref: "schema" } };
  return sch;
};
const emptyForm = (root2) => ({
  optionalProperties: shared(root2)
});
const refForm = (root2) => ({
  properties: {
    ref: { type: "string" }
  },
  optionalProperties: shared(root2)
});
const typeForm = (root2) => ({
  properties: {
    type: {
      enum: [
        "boolean",
        "timestamp",
        "string",
        "float32",
        "float64",
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32"
      ]
    }
  },
  optionalProperties: shared(root2)
});
const enumForm = (root2) => ({
  properties: {
    enum: { elements: { type: "string" } }
  },
  optionalProperties: shared(root2)
});
const elementsForm = (root2) => ({
  properties: {
    elements: { ref: "schema" }
  },
  optionalProperties: shared(root2)
});
const propertiesForm = (root2) => ({
  properties: {
    properties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    optionalProperties: { values: { ref: "schema" } },
    additionalProperties: { type: "boolean" },
    ...shared(root2)
  }
});
const optionalPropertiesForm = (root2) => ({
  properties: {
    optionalProperties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    additionalProperties: { type: "boolean" },
    ...shared(root2)
  }
});
const discriminatorForm = (root2) => ({
  properties: {
    discriminator: { type: "string" },
    mapping: {
      values: {
        metadata: {
          union: [propertiesForm(false), optionalPropertiesForm(false)]
        }
      }
    }
  },
  optionalProperties: shared(root2)
});
const valuesForm = (root2) => ({
  properties: {
    values: { ref: "schema" }
  },
  optionalProperties: shared(root2)
});
const schema$1 = (root2) => ({
  metadata: {
    union: [
      emptyForm,
      refForm,
      typeForm,
      enumForm,
      elementsForm,
      propertiesForm,
      optionalPropertiesForm,
      discriminatorForm,
      valuesForm
    ].map((s) => s(root2))
  }
});
const jtdMetaSchema = {
  definitions: {
    schema: schema$1(false)
  },
  ...schema$1(true)
};
jtdSchema.default = jtdMetaSchema;
var serialize = {};
var types$4 = {};
Object.defineProperty(types$4, "__esModule", { value: true });
types$4.jtdForms = void 0;
types$4.jtdForms = [
  "elements",
  "values",
  "discriminator",
  "properties",
  "optionalProperties",
  "enum",
  "type",
  "ref"
];
var quote$1 = {};
Object.defineProperty(quote$1, "__esModule", { value: true });
const rxEscapable = (
  // eslint-disable-next-line no-control-regex, no-misleading-character-class
  /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
);
const escaped = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};
function quote(s) {
  rxEscapable.lastIndex = 0;
  return '"' + (rxEscapable.test(s) ? s.replace(rxEscapable, (a) => {
    const c = escaped[a];
    return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
  }) : s) + '"';
}
quote$1.default = quote;
quote.code = 'require("ajv/dist/runtime/quote").default';
Object.defineProperty(serialize, "__esModule", { value: true });
const types_1$c = types$4;
const __1$1 = compile;
const codegen_1$1 = codegen;
const ref_error_1$1 = ref_error;
const names_1$1 = names$1;
const code_1$1 = code;
const ref_1$1 = ref$1;
const util_1$8 = util$9;
const quote_1 = quote$1;
const genSerialize = {
  elements: serializeElements,
  values: serializeValues,
  discriminator: serializeDiscriminator,
  properties: serializeProperties,
  optionalProperties: serializeProperties,
  enum: serializeString,
  type: serializeType,
  ref: serializeRef
};
function compileSerializer(sch, definitions2) {
  const _sch = __1$1.getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$1.CodeGen(this.scope, { es5, lines, ownProperties });
  const serializeName = gen.scopeName("serialize");
  const cxt = {
    self: this,
    gen,
    schema: sch.schema,
    schemaEnv: sch,
    definitions: definitions2,
    data: names_1$1.default.data
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    sch.serializeName = serializeName;
    gen.func(serializeName, names_1$1.default.data, false, () => {
      gen.let(names_1$1.default.json, (0, codegen_1$1.str)``);
      serializeCode(cxt);
      gen.return(names_1$1.default.json);
    });
    gen.optimize(this.opts.code.optimize);
    const serializeFuncCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$1.default.scope)}return ${serializeFuncCode}`;
    const makeSerialize = new Function(`${names_1$1.default.scope}`, sourceCode);
    const serialize2 = makeSerialize(this.scope.get());
    this.scope.value(serializeName, { ref: serialize2 });
    sch.serialize = serialize2;
  } catch (e) {
    if (sourceCode)
      this.logger.error("Error compiling serializer, function code:", sourceCode);
    delete sch.serialize;
    delete sch.serializeName;
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
  return sch;
}
serialize.default = compileSerializer;
function serializeCode(cxt) {
  let form;
  for (const key of types_1$c.jtdForms) {
    if (key in cxt.schema) {
      form = key;
      break;
    }
  }
  serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
}
function serializeNullable(cxt, serializeForm) {
  const { gen, schema: schema2, data } = cxt;
  if (!schema2.nullable)
    return serializeForm(cxt);
  gen.if((0, codegen_1$1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1$1.default.json, (0, codegen_1$1._)`"null"`), () => serializeForm(cxt));
}
function serializeElements(cxt) {
  const { gen, schema: schema2, data } = cxt;
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`[`);
  const first = gen.let("first", true);
  gen.forOf("el", data, (el) => {
    addComma(cxt, first);
    serializeCode({ ...cxt, schema: schema2.elements, data: el });
  });
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`]`);
}
function serializeValues(cxt) {
  const { gen, schema: schema2, data } = cxt;
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`{`);
  const first = gen.let("first", true);
  gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema2.values, first));
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`}`);
}
function serializeKeyValue(cxt, key, schema2, first) {
  const { gen, data } = cxt;
  addComma(cxt, first);
  serializeString({ ...cxt, data: key });
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`:`);
  const value = gen.const("value", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(key)}`);
  serializeCode({ ...cxt, schema: schema2, data: value });
}
function serializeDiscriminator(cxt) {
  const { gen, schema: schema2, data } = cxt;
  const { discriminator: discriminator2 } = schema2;
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`{${JSON.stringify(discriminator2)}:`);
  const tag = gen.const("tag", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(discriminator2)}`);
  serializeString({ ...cxt, data: tag });
  gen.if(false);
  for (const tagValue in schema2.mapping) {
    gen.elseIf((0, codegen_1$1._)`${tag} === ${tagValue}`);
    const sch = schema2.mapping[tagValue];
    serializeSchemaProperties({ ...cxt, schema: sch }, discriminator2);
  }
  gen.endIf();
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`}`);
}
function serializeProperties(cxt) {
  const { gen } = cxt;
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`{`);
  serializeSchemaProperties(cxt);
  gen.add(names_1$1.default.json, (0, codegen_1$1.str)`}`);
}
function serializeSchemaProperties(cxt, discriminator2) {
  const { gen, schema: schema2, data } = cxt;
  const { properties: properties2, optionalProperties: optionalProperties2 } = schema2;
  const props = keys2(properties2);
  const optProps = keys2(optionalProperties2);
  const allProps = allProperties(props.concat(optProps));
  let first = !discriminator2;
  let firstProp;
  for (const key of props) {
    if (first)
      first = false;
    else
      gen.add(names_1$1.default.json, (0, codegen_1$1.str)`,`);
    serializeProperty(key, properties2[key], keyValue(key));
  }
  if (first)
    firstProp = gen.let("first", true);
  for (const key of optProps) {
    const value = keyValue(key);
    gen.if((0, codegen_1$1.and)((0, codegen_1$1._)`${value} !== undefined`, (0, code_1$1.isOwnProperty)(gen, data, key)), () => {
      addComma(cxt, firstProp);
      serializeProperty(key, optionalProperties2[key], value);
    });
  }
  if (schema2.additionalProperties) {
    gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
  }
  function keys2(ps) {
    return ps ? Object.keys(ps) : [];
  }
  function allProperties(ps) {
    if (discriminator2)
      ps.push(discriminator2);
    if (new Set(ps).size !== ps.length) {
      throw new Error("JTD: properties/optionalProperties/disciminator overlap");
    }
    return ps;
  }
  function keyValue(key) {
    return gen.const("value", (0, codegen_1$1._)`${data}${(0, codegen_1$1.getProperty)(key)}`);
  }
  function serializeProperty(key, propSchema, value) {
    gen.add(names_1$1.default.json, (0, codegen_1$1.str)`${JSON.stringify(key)}:`);
    serializeCode({ ...cxt, schema: propSchema, data: value });
  }
  function isAdditional(key, ps) {
    return ps.length ? (0, codegen_1$1.and)(...ps.map((p) => (0, codegen_1$1._)`${key} !== ${p}`)) : true;
  }
}
function serializeType(cxt) {
  const { gen, schema: schema2, data } = cxt;
  switch (schema2.type) {
    case "boolean":
      gen.add(names_1$1.default.json, (0, codegen_1$1._)`${data} ? "true" : "false"`);
      break;
    case "string":
      serializeString(cxt);
      break;
    case "timestamp":
      gen.if((0, codegen_1$1._)`${data} instanceof Date`, () => gen.add(names_1$1.default.json, (0, codegen_1$1._)`'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
      break;
    default:
      serializeNumber(cxt);
  }
}
function serializeString({ gen, data }) {
  gen.add(names_1$1.default.json, (0, codegen_1$1._)`${(0, util_1$8.useFunc)(gen, quote_1.default)}(${data})`);
}
function serializeNumber({ gen, data }) {
  gen.add(names_1$1.default.json, (0, codegen_1$1._)`"" + ${data}`);
}
function serializeRef(cxt) {
  const { gen, self: self2, data, definitions: definitions2, schema: schema2, schemaEnv } = cxt;
  const { ref: ref2 } = schema2;
  const refSchema = definitions2[ref2];
  if (!refSchema)
    throw new ref_error_1$1.default(self2.opts.uriResolver, "", ref2, `No definition ${ref2}`);
  if (!(0, ref_1$1.hasRef)(refSchema))
    return serializeCode({ ...cxt, schema: refSchema });
  const { root: root2 } = schemaEnv;
  const sch = compileSerializer.call(self2, new __1$1.SchemaEnv({ schema: refSchema, root: root2 }), definitions2);
  gen.add(names_1$1.default.json, (0, codegen_1$1._)`${getSerialize(gen, sch)}(${data})`);
}
function getSerialize(gen, sch) {
  return sch.serialize ? gen.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1$1._)`${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
}
function serializeEmpty({ gen, data }) {
  gen.add(names_1$1.default.json, (0, codegen_1$1._)`JSON.stringify(${data})`);
}
function addComma({ gen }, first) {
  if (first) {
    gen.if(first, () => gen.assign(first, false), () => gen.add(names_1$1.default.json, (0, codegen_1$1.str)`,`));
  } else {
    gen.add(names_1$1.default.json, (0, codegen_1$1.str)`,`);
  }
}
var parse$a = {};
var parseJson$2 = {};
Object.defineProperty(parseJson$2, "__esModule", { value: true });
parseJson$2.parseJsonString = parseJson$2.parseJsonNumber = parseJson$2.parseJson = void 0;
const rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
function parseJson$1(s, pos) {
  let endPos;
  parseJson$1.message = void 0;
  let matches;
  if (pos)
    s = s.slice(pos);
  try {
    parseJson$1.position = pos + s.length;
    return JSON.parse(s);
  } catch (e) {
    matches = rxParseJson.exec(e.message);
    if (!matches) {
      parseJson$1.message = "unexpected end";
      return void 0;
    }
    endPos = +matches[1];
    const c = s[endPos];
    s = s.slice(0, endPos);
    parseJson$1.position = pos + endPos;
    try {
      return JSON.parse(s);
    } catch (e1) {
      parseJson$1.message = `unexpected token ${c}`;
      return void 0;
    }
  }
}
parseJson$2.parseJson = parseJson$1;
parseJson$1.message = void 0;
parseJson$1.position = 0;
parseJson$1.code = 'require("ajv/dist/runtime/parseJson").parseJson';
function parseJsonNumber(s, pos, maxDigits) {
  let numStr = "";
  let c;
  parseJsonNumber.message = void 0;
  if (s[pos] === "-") {
    numStr += "-";
    pos++;
  }
  if (s[pos] === "0") {
    numStr += "0";
    pos++;
  } else {
    if (!parseDigits(maxDigits)) {
      errorMessage();
      return void 0;
    }
  }
  if (maxDigits) {
    parseJsonNumber.position = pos;
    return +numStr;
  }
  if (s[pos] === ".") {
    numStr += ".";
    pos++;
    if (!parseDigits()) {
      errorMessage();
      return void 0;
    }
  }
  if (c = s[pos], c === "e" || c === "E") {
    numStr += "e";
    pos++;
    if (c = s[pos], c === "+" || c === "-") {
      numStr += c;
      pos++;
    }
    if (!parseDigits()) {
      errorMessage();
      return void 0;
    }
  }
  parseJsonNumber.position = pos;
  return +numStr;
  function parseDigits(maxLen) {
    let digit2 = false;
    while (c = s[pos], c >= "0" && c <= "9" && (maxLen === void 0 || maxLen-- > 0)) {
      digit2 = true;
      numStr += c;
      pos++;
    }
    return digit2;
  }
  function errorMessage() {
    parseJsonNumber.position = pos;
    parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
  }
}
parseJson$2.parseJsonNumber = parseJsonNumber;
parseJsonNumber.message = void 0;
parseJsonNumber.position = 0;
parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
const escapedChars = {
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  '"': '"',
  "/": "/",
  "\\": "\\"
};
const CODE_A = "a".charCodeAt(0);
const CODE_0 = "0".charCodeAt(0);
function parseJsonString(s, pos) {
  let str2 = "";
  let c;
  parseJsonString.message = void 0;
  while (true) {
    c = s[pos++];
    if (c === '"')
      break;
    if (c === "\\") {
      c = s[pos];
      if (c in escapedChars) {
        str2 += escapedChars[c];
        pos++;
      } else if (c === "u") {
        pos++;
        let count = 4;
        let code2 = 0;
        while (count--) {
          code2 <<= 4;
          c = s[pos];
          if (c === void 0) {
            errorMessage("unexpected end");
            return void 0;
          }
          c = c.toLowerCase();
          if (c >= "a" && c <= "f") {
            code2 += c.charCodeAt(0) - CODE_A + 10;
          } else if (c >= "0" && c <= "9") {
            code2 += c.charCodeAt(0) - CODE_0;
          } else {
            errorMessage(`unexpected token ${c}`);
            return void 0;
          }
          pos++;
        }
        str2 += String.fromCharCode(code2);
      } else {
        errorMessage(`unexpected token ${c}`);
        return void 0;
      }
    } else if (c === void 0) {
      errorMessage("unexpected end");
      return void 0;
    } else {
      if (c.charCodeAt(0) >= 32) {
        str2 += c;
      } else {
        errorMessage(`unexpected token ${c}`);
        return void 0;
      }
    }
  }
  parseJsonString.position = pos;
  return str2;
  function errorMessage(msg) {
    parseJsonString.position = pos;
    parseJsonString.message = msg;
  }
}
parseJson$2.parseJsonString = parseJsonString;
parseJsonString.message = void 0;
parseJsonString.position = 0;
parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
Object.defineProperty(parse$a, "__esModule", { value: true });
const types_1$b = types$4;
const __1 = compile;
const codegen_1 = codegen;
const ref_error_1 = ref_error;
const names_1 = names$1;
const code_1 = code;
const ref_1 = ref$1;
const type_1 = type$2;
const parseJson_1 = parseJson$2;
const util_1$7 = util$9;
const timestamp_1 = timestamp$1;
const genParse = {
  elements: parseElements,
  values: parseValues,
  discriminator: parseDiscriminator,
  properties: parseProperties,
  optionalProperties: parseProperties,
  enum: parseEnum,
  type: parseType,
  ref: parseRef
};
function compileParser(sch, definitions2) {
  const _sch = __1.getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
  const parseName = gen.scopeName("parse");
  const cxt = {
    self: this,
    gen,
    schema: sch.schema,
    schemaEnv: sch,
    definitions: definitions2,
    data: names_1.default.data,
    parseName,
    char: gen.name("c")
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    sch.parseName = parseName;
    parserFunction(cxt);
    gen.optimize(this.opts.code.optimize);
    const parseFuncCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
    const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
    const parse2 = makeParse(this.scope.get());
    this.scope.value(parseName, { ref: parse2 });
    sch.parse = parse2;
  } catch (e) {
    if (sourceCode)
      this.logger.error("Error compiling parser, function code:", sourceCode);
    delete sch.parse;
    delete sch.parseName;
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
  return sch;
}
parse$a.default = compileParser;
const undef = (0, codegen_1._)`undefined`;
function parserFunction(cxt) {
  const { gen, parseName, char } = cxt;
  gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
    gen.let(names_1.default.data);
    gen.let(char);
    gen.assign((0, codegen_1._)`${parseName}.message`, undef);
    gen.assign((0, codegen_1._)`${parseName}.position`, undef);
    gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
    gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
    parseCode(cxt);
    skipWhitespace(cxt);
    gen.if(names_1.default.jsonPart, () => {
      gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
      gen.return(names_1.default.data);
    });
    gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
    jsonSyntaxError(cxt);
  });
}
function parseCode(cxt) {
  let form;
  for (const key of types_1$b.jtdForms) {
    if (key in cxt.schema) {
      form = key;
      break;
    }
  }
  if (form)
    parseNullable(cxt, genParse[form]);
  else
    parseEmpty(cxt);
}
const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
function parseNullable(cxt, parseForm) {
  const { gen, schema: schema2, data } = cxt;
  if (!schema2.nullable)
    return parseForm(cxt);
  tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
}
function parseElements(cxt) {
  const { gen, schema: schema2, data } = cxt;
  parseToken(cxt, "[");
  const ix = gen.let("i", 0);
  gen.assign(data, (0, codegen_1._)`[]`);
  parseItems(cxt, "]", () => {
    const el = gen.let("el");
    parseCode({ ...cxt, schema: schema2.elements, data: el });
    gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);
  });
}
function parseValues(cxt) {
  const { gen, schema: schema2, data } = cxt;
  parseToken(cxt, "{");
  gen.assign(data, (0, codegen_1._)`{}`);
  parseItems(cxt, "}", () => parseKeyValue(cxt, schema2.values));
}
function parseItems(cxt, endToken, block) {
  tryParseItems(cxt, endToken, block);
  parseToken(cxt, endToken);
}
function tryParseItems(cxt, endToken, block) {
  const { gen } = cxt;
  gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
    block();
    tryParseToken(cxt, ",", () => gen.break(), hasItem);
  });
  function hasItem() {
    tryParseToken(cxt, endToken, () => {
    }, jsonSyntaxError);
  }
}
function parseKeyValue(cxt, schema2) {
  const { gen } = cxt;
  const key = gen.let("key");
  parseString({ ...cxt, data: key });
  parseToken(cxt, ":");
  parsePropertyValue(cxt, key, schema2);
}
function parseDiscriminator(cxt) {
  const { gen, data, schema: schema2 } = cxt;
  const { discriminator: discriminator2, mapping } = schema2;
  parseToken(cxt, "{");
  gen.assign(data, (0, codegen_1._)`{}`);
  const startPos = gen.const("pos", names_1.default.jsonPos);
  const value = gen.let("value");
  const tag = gen.let("tag");
  tryParseItems(cxt, "}", () => {
    const key = gen.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    gen.if(
      (0, codegen_1._)`${key} === ${discriminator2}`,
      () => {
        parseString({ ...cxt, data: tag });
        gen.assign((0, codegen_1._)`${data}[${key}]`, tag);
        gen.break();
      },
      () => parseEmpty({ ...cxt, data: value })
      // can be discarded/skipped
    );
  });
  gen.assign(names_1.default.jsonPos, startPos);
  gen.if((0, codegen_1._)`${tag} === undefined`);
  parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
  for (const tagValue in mapping) {
    gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
    parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator2);
  }
  gen.else();
  parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
  gen.endIf();
}
function parseProperties(cxt) {
  const { gen, data } = cxt;
  parseToken(cxt, "{");
  gen.assign(data, (0, codegen_1._)`{}`);
  parseSchemaProperties(cxt);
}
function parseSchemaProperties(cxt, discriminator2) {
  const { gen, schema: schema2, data } = cxt;
  const { properties: properties2, optionalProperties: optionalProperties2, additionalProperties: additionalProperties2 } = schema2;
  parseItems(cxt, "}", () => {
    const key = gen.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    gen.if(false);
    parseDefinedProperty(cxt, key, properties2);
    parseDefinedProperty(cxt, key, optionalProperties2);
    if (discriminator2) {
      gen.elseIf((0, codegen_1._)`${key} === ${discriminator2}`);
      const tag = gen.let("tag");
      parseString({ ...cxt, data: tag });
    }
    gen.else();
    if (additionalProperties2) {
      parseEmpty({ ...cxt, data: (0, codegen_1._)`${data}[${key}]` });
    } else {
      parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
    }
    gen.endIf();
  });
  if (properties2) {
    const hasProp = (0, code_1.hasPropFunc)(gen);
    const allProps = (0, codegen_1.and)(...Object.keys(properties2).map((p) => (0, codegen_1._)`${hasProp}.call(${data}, ${p})`));
    gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
  }
}
function parseDefinedProperty(cxt, key, schemas2 = {}) {
  const { gen } = cxt;
  for (const prop in schemas2) {
    gen.elseIf((0, codegen_1._)`${key} === ${prop}`);
    parsePropertyValue(cxt, key, schemas2[prop]);
  }
}
function parsePropertyValue(cxt, key, schema2) {
  parseCode({ ...cxt, schema: schema2, data: (0, codegen_1._)`${cxt.data}[${key}]` });
}
function parseType(cxt) {
  const { gen, schema: schema2, data, self: self2 } = cxt;
  switch (schema2.type) {
    case "boolean":
      parseBoolean(cxt);
      break;
    case "string":
      parseString(cxt);
      break;
    case "timestamp": {
      parseString(cxt);
      const vts = (0, util_1$7.useFunc)(gen, timestamp_1.default);
      const { allowDate, parseDate } = self2.opts;
      const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;
      const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;
      gen.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
      break;
    }
    case "float32":
    case "float64":
      parseNumber(cxt);
      break;
    default: {
      const t2 = schema2.type;
      if (!self2.opts.int32range && (t2 === "int32" || t2 === "uint32")) {
        parseNumber(cxt, 16);
        if (t2 === "uint32") {
          gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
        }
      } else {
        const [min2, max2, maxDigits] = type_1.intRange[t2];
        parseNumber(cxt, maxDigits);
        gen.if((0, codegen_1._)`${data} < ${min2} || ${data} > ${max2}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
      }
    }
  }
}
function parseString(cxt) {
  parseToken(cxt, '"');
  parseWith(cxt, parseJson_1.parseJsonString);
}
function parseEnum(cxt) {
  const { gen, data, schema: schema2 } = cxt;
  const enumSch = schema2.enum;
  parseToken(cxt, '"');
  gen.if(false);
  for (const value of enumSch) {
    const valueStr = JSON.stringify(value).slice(1);
    gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
    gen.assign(data, (0, codegen_1.str)`${value}`);
    gen.add(names_1.default.jsonPos, valueStr.length);
  }
  gen.else();
  jsonSyntaxError(cxt);
  gen.endIf();
}
function parseNumber(cxt, maxDigits) {
  const { gen } = cxt;
  skipWhitespace(cxt);
  gen.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
}
function parseBooleanToken(bool2, fail) {
  return (cxt) => {
    const { gen, data } = cxt;
    tryParseToken(cxt, `${bool2}`, () => fail(cxt), () => gen.assign(data, bool2));
  };
}
function parseRef(cxt) {
  const { gen, self: self2, definitions: definitions2, schema: schema2, schemaEnv } = cxt;
  const { ref: ref2 } = schema2;
  const refSchema = definitions2[ref2];
  if (!refSchema)
    throw new ref_error_1.default(self2.opts.uriResolver, "", ref2, `No definition ${ref2}`);
  if (!(0, ref_1.hasRef)(refSchema))
    return parseCode({ ...cxt, schema: refSchema });
  const { root: root2 } = schemaEnv;
  const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root: root2 }), definitions2);
  partialParse(cxt, getParser(gen, sch), true);
}
function getParser(gen, sch) {
  return sch.parse ? gen.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.parse`;
}
function parseEmpty(cxt) {
  parseWith(cxt, parseJson_1.parseJson);
}
function parseWith(cxt, parseFunc, args) {
  partialParse(cxt, (0, util_1$7.useFunc)(cxt.gen, parseFunc), args);
}
function partialParse(cxt, parseFunc, args) {
  const { gen, data } = cxt;
  gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
  gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
  gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
}
function parseToken(cxt, tok) {
  tryParseToken(cxt, tok, jsonSyntaxError);
}
function tryParseToken(cxt, tok, fail, success) {
  const { gen } = cxt;
  const n = tok.length;
  skipWhitespace(cxt);
  gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {
    gen.add(names_1.default.jsonPos, n);
    success === null || success === void 0 ? void 0 : success(cxt);
  }, () => fail(cxt));
}
function skipWhitespace({ gen, char: c }) {
  gen.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
}
function jsonSlice(len) {
  return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
}
function jsonSyntaxError(cxt) {
  parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
}
function parsingError({ gen, parseName }, msg) {
  gen.assign((0, codegen_1._)`${parseName}.message`, msg);
  gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
  gen.return(undef);
}
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
  const core_12 = core$3;
  const jtd_1 = jtd;
  const jtd_schema_1 = jtdSchema;
  const serialize_1 = serialize;
  const parse_12 = parse$a;
  const META_SCHEMA_ID = "JTD-meta-schema";
  class Ajv2 extends core_12.default {
    constructor(opts = {}) {
      super({
        ...opts,
        jtd: true
      });
    }
    _addVocabularies() {
      super._addVocabularies();
      this.addVocabulary(jtd_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
    compileSerializer(schema2) {
      const sch = this._addSchema(schema2);
      return sch.serialize || this._compileSerializer(sch);
    }
    compileParser(schema2) {
      const sch = this._addSchema(schema2);
      return sch.parse || this._compileParser(sch);
    }
    _compileSerializer(sch) {
      serialize_1.default.call(this, sch, sch.schema.definitions || {});
      if (!sch.serialize)
        throw new Error("ajv implementation error");
      return sch.serialize;
    }
    _compileParser(sch) {
      parse_12.default.call(this, sch, sch.schema.definitions || {});
      if (!sch.parse)
        throw new Error("ajv implementation error");
      return sch.parse;
    }
  }
  exports.Ajv = Ajv2;
  module.exports = exports = Ajv2;
  module.exports.Ajv = Ajv2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv2;
  var validate_12 = validate$2;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(jtd$1, jtd$1.exports);
var jtdExports = jtd$1.exports;
const fastUri = fastUriExports;
var defaultAjvOptions$2 = Object.freeze({
  coerceTypes: "array",
  useDefaults: true,
  removeAdditional: true,
  uriResolver: fastUri,
  addUsedSchema: false,
  // Explicitly set allErrors to `false`.
  // When set to `true`, a DoS attack is possible.
  allErrors: false
});
const Ajv = ajvExports.default;
const AjvJTD$1 = jtdExports;
const defaultAjvOptions$1 = defaultAjvOptions$2;
class ValidatorCompiler {
  constructor(externalSchemas, options) {
    var _a2;
    if (options.mode === "JTD") {
      this.ajv = new AjvJTD$1(Object.assign({}, defaultAjvOptions$1, options.customOptions));
    } else {
      this.ajv = new Ajv(Object.assign({}, defaultAjvOptions$1, options.customOptions));
    }
    let addFormatPlugin = true;
    if (options.plugins && options.plugins.length > 0) {
      for (const plugin2 of options.plugins) {
        if (Array.isArray(plugin2)) {
          addFormatPlugin = addFormatPlugin && plugin2[0].name !== "formatsPlugin";
          plugin2[0](this.ajv, plugin2[1]);
        } else {
          addFormatPlugin = addFormatPlugin && plugin2.name !== "formatsPlugin";
          plugin2(this.ajv);
        }
      }
    }
    if (addFormatPlugin) {
      requireDist$1()(this.ajv);
    }
    (_a2 = options.onCreate) == null ? void 0 : _a2.call(options, this.ajv);
    const sourceSchemas = Object.values(externalSchemas);
    for (const extSchema of sourceSchemas) {
      this.ajv.addSchema(extSchema);
    }
  }
  buildValidatorFunction({
    schema: schema2
    /*, method, url, httpPart */
  }) {
    if (schema2.$id) {
      const stored = this.ajv.getSchema(schema2.$id);
      if (stored) {
        return stored;
      }
    }
    return this.ajv.compile(schema2);
  }
}
var validatorCompiler = ValidatorCompiler;
const AjvJTD = jtdExports;
const defaultAjvOptions = defaultAjvOptions$2;
class SerializerCompiler {
  constructor(_externalSchemas, options) {
    this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));
  }
  buildSerializerFunction({
    schema: schema2
    /*, method, url, httpStatus */
  }) {
    return this.ajv.compileSerializer(schema2);
  }
}
var serializerCompiler = SerializerCompiler;
var standalone$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const scope_1 = scope;
  const code_12 = code$1;
  function standaloneCode(ajv2, refsOrFunc) {
    if (!ajv2.opts.code.source) {
      throw new Error("moduleCode: ajv instance must have code.source option");
    }
    const { _n } = ajv2.scope.opts;
    return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== void 0 ? multiExportsCode(refsOrFunc, getValidate2) : multiExportsCode(ajv2.schemas, (sch) => sch.meta ? void 0 : ajv2.compile(sch.schema));
    function getValidate2(id2) {
      const v = ajv2.getSchema(id2);
      if (!v)
        throw new Error(`moduleCode: no schema with id ${id2}`);
      return v;
    }
    function funcExportCode(source) {
      const usedValues = {};
      const n = source === null || source === void 0 ? void 0 : source.validateName;
      const vCode = validateCode(usedValues, source);
      if (ajv2.opts.code.esm) {
        return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
      }
      return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
    }
    function multiExportsCode(schemas2, getValidateFunc) {
      var _a2;
      const usedValues = {};
      let code2 = (0, code_12._)`"use strict";`;
      for (const name in schemas2) {
        const v = getValidateFunc(schemas2[name]);
        if (v) {
          const vCode = validateCode(usedValues, v.source);
          const exportSyntax = ajv2.opts.code.esm ? (0, code_12._)`export const ${(0, code_12.getEsmExportName)(name)}` : (0, code_12._)`exports${(0, code_12.getProperty)(name)}`;
          code2 = (0, code_12._)`${code2}${_n}${exportSyntax} = ${(_a2 = v.source) === null || _a2 === void 0 ? void 0 : _a2.validateName};${_n}${vCode}`;
        }
      }
      return `${code2}`;
    }
    function validateCode(usedValues, s) {
      if (!s)
        throw new Error('moduleCode: function does not have "source" property');
      if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
        return code_12.nil;
      setUsedState(s.validateName, scope_1.UsedValueState.Started);
      const scopeCode = ajv2.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
      const code2 = new code_12._Code(`${scopeCode}${_n}${s.validateCode}`);
      return s.evaluated ? (0, code_12._)`${code2}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code2;
      function refValidateCode(n) {
        var _a2;
        const vRef = (_a2 = n.value) === null || _a2 === void 0 ? void 0 : _a2.ref;
        if (n.prefix === "validate" && typeof vRef == "function") {
          const v = vRef;
          return validateCode(usedValues, v.source);
        } else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
          const { validate: validate2, validateName } = vRef;
          if (!validateName)
            throw new Error("ajv internal error");
          const def2 = ajv2.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
          const wrapper = (0, code_12._)`${def2} ${n} = {validate: ${validateName}};`;
          if (usedState(validateName) === scope_1.UsedValueState.Started)
            return wrapper;
          const vCode = validateCode(usedValues, validate2 === null || validate2 === void 0 ? void 0 : validate2.source);
          return (0, code_12._)`${wrapper}${_n}${vCode}`;
        }
        return void 0;
      }
      function usedState(name) {
        var _a2;
        return (_a2 = usedValues[name.prefix]) === null || _a2 === void 0 ? void 0 : _a2.get(name);
      }
      function setUsedState(name, state2) {
        const { prefix } = name;
        const names2 = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        names2.set(name, state2);
      }
    }
  }
  module.exports = exports = standaloneCode;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = standaloneCode;
})(standalone$1, standalone$1.exports);
var standaloneExports = standalone$1.exports;
var standalone;
var hasRequiredStandalone;
function requireStandalone() {
  if (hasRequiredStandalone) return standalone;
  hasRequiredStandalone = 1;
  const ValidatorSelector2 = requireAjvCompiler();
  const standaloneCode = standaloneExports.default;
  function StandaloneValidator(options = { readMode: true }) {
    if (options.readMode === true && !options.restoreFunction) {
      throw new Error("You must provide a restoreFunction options when readMode ON");
    }
    if (options.readMode !== true && !options.storeFunction) {
      throw new Error("You must provide a storeFunction options when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = ValidatorSelector2();
    return function wrapper(externalSchemas, ajvOptions = {}) {
      if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
        ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
      }
      const compiler = factory(externalSchemas, ajvOptions);
      return function(opts) {
        const validationFunc = compiler(opts);
        const schemaValidationCode = standaloneCode(compiler[ValidatorSelector2.AjvReference].ajv, validationFunc);
        options.storeFunction(opts, schemaValidationCode);
        return validationFunc;
      };
    };
  }
  standalone = StandaloneValidator;
  return standalone;
}
var hasRequiredAjvCompiler;
function requireAjvCompiler() {
  if (hasRequiredAjvCompiler) return ajvCompiler.exports;
  hasRequiredAjvCompiler = 1;
  const AjvReference = Symbol.for("fastify.ajv-compiler.reference");
  const ValidatorCompiler2 = validatorCompiler;
  const SerializerCompiler2 = serializerCompiler;
  function AjvCompiler(opts) {
    const validatorPool = /* @__PURE__ */ new Map();
    const serializerPool = /* @__PURE__ */ new Map();
    if (opts && opts.jtdSerializer === true) {
      return function buildSerializerFromPool(externalSchemas, serializerOpts) {
        const uniqueAjvKey = getPoolKey({}, serializerOpts);
        if (serializerPool.has(uniqueAjvKey)) {
          return serializerPool.get(uniqueAjvKey);
        }
        const compiler = new SerializerCompiler2(externalSchemas, serializerOpts);
        const ret = compiler.buildSerializerFunction.bind(compiler);
        serializerPool.set(uniqueAjvKey, ret);
        return ret;
      };
    }
    return function buildCompilerFromPool(externalSchemas, options) {
      const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
      if (validatorPool.has(uniqueAjvKey)) {
        return validatorPool.get(uniqueAjvKey);
      }
      const compiler = new ValidatorCompiler2(externalSchemas, options);
      const ret = compiler.buildValidatorFunction.bind(compiler);
      validatorPool.set(uniqueAjvKey, ret);
      if (options.customOptions.code !== void 0) {
        ret[AjvReference] = compiler;
      }
      return ret;
    };
  }
  function getPoolKey(externalSchemas, options) {
    const externals = JSON.stringify(externalSchemas);
    const ajvConfig = JSON.stringify(options);
    return `${externals}${ajvConfig}`;
  }
  ajvCompiler.exports = AjvCompiler;
  ajvCompiler.exports.default = AjvCompiler;
  ajvCompiler.exports.AjvCompiler = AjvCompiler;
  ajvCompiler.exports.AjvReference = AjvReference;
  ajvCompiler.exports.StandaloneValidator = requireStandalone();
  return ajvCompiler.exports;
}
const { buildSchemas } = schemas;
const SerializerSelector = fastJsonStringifyCompilerExports;
const ValidatorSelector = requireAjvCompiler();
function buildSchemaController(parentSchemaCtrl, opts) {
  var _a2, _b;
  if (parentSchemaCtrl) {
    return new SchemaController$2(parentSchemaCtrl, opts);
  }
  const compilersFactory = Object.assign({
    buildValidator: null,
    buildSerializer: null
  }, opts == null ? void 0 : opts.compilersFactory);
  if (!compilersFactory.buildValidator) {
    compilersFactory.buildValidator = ValidatorSelector();
  }
  if (!compilersFactory.buildSerializer) {
    compilersFactory.buildSerializer = SerializerSelector();
  }
  const option = {
    bucket: opts && opts.bucket || buildSchemas,
    compilersFactory,
    isCustomValidatorCompiler: typeof ((_a2 = opts == null ? void 0 : opts.compilersFactory) == null ? void 0 : _a2.buildValidator) === "function",
    isCustomSerializerCompiler: typeof ((_b = opts == null ? void 0 : opts.compilersFactory) == null ? void 0 : _b.buildValidator) === "function"
  };
  return new SchemaController$2(void 0, option);
}
let SchemaController$2 = class SchemaController {
  constructor(parent, options) {
    this.opts = options || (parent == null ? void 0 : parent.opts);
    this.addedSchemas = false;
    this.compilersFactory = this.opts.compilersFactory;
    if (parent) {
      this.schemaBucket = this.opts.bucket(parent.getSchemas());
      this.validatorCompiler = parent.getValidatorCompiler();
      this.serializerCompiler = parent.getSerializerCompiler();
      this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
      this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
      this.parent = parent;
    } else {
      this.schemaBucket = this.opts.bucket();
      this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
      this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
    }
  }
  // Bucket interface
  add(schema2) {
    this.addedSchemas = true;
    return this.schemaBucket.add(schema2);
  }
  getSchema(schemaId) {
    return this.schemaBucket.getSchema(schemaId);
  }
  getSchemas() {
    return this.schemaBucket.getSchemas();
  }
  setValidatorCompiler(validatorCompiler2) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildValidator: () => validatorCompiler2 }
    );
    this.validatorCompiler = validatorCompiler2;
    this.isCustomValidatorCompiler = true;
  }
  setSerializerCompiler(serializerCompiler2) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildSerializer: () => serializerCompiler2 }
    );
    this.serializerCompiler = serializerCompiler2;
    this.isCustomSerializerCompiler = true;
  }
  getValidatorCompiler() {
    return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
  }
  getSerializerCompiler() {
    return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
  }
  getSerializerBuilder() {
    return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
  }
  getValidatorBuilder() {
    return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
  }
  /**
   * This method will be called when a validator must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupValidator(serverOptions) {
    const isReady = this.validatorCompiler !== void 0 && !this.addedSchemas;
    if (isReady) {
      return;
    }
    this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
  }
  /**
   * This method will be called when a serializer must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupSerializer(serverOptions) {
    const isReady = this.serializerCompiler !== void 0 && !this.addedSchemas;
    if (isReady) {
      return;
    }
    this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
  }
};
SchemaController$2.buildSchemaController = buildSchemaController;
var schemaController = SchemaController$2;
var pluginUtils$2 = { exports: {} };
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$3 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$5 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$2 = debug$5;
(function(module, exports) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$3;
  const debug2 = debug_1$2;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const safeRe = exports.safeRe = [];
  const src2 = exports.src = [];
  const safeSrc = exports.safeSrc = [];
  const t2 = exports.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src2[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NUMERICIDENTIFIER]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NUMERICIDENTIFIERLOOSE]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$4 = debug_1$2;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$3;
const { safeRe: re$1, safeSrc: src$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug$4("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version2.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$4("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$4("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$4("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
      }
      if (identifier) {
        const r = new RegExp(`^${this.options.loose ? src$1[t$1.PRERELEASELOOSE] : src$1[t$1.PRERELEASE]}$`);
        const match = `-${identifier}`.match(r);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$2 = SemVer$d;
const SemVer$c = semver$2;
const parse$9 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1$1 = parse$9;
const parse$8 = parse_1$1;
const valid$2 = (version2, options) => {
  const v = parse$8(version2, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$7 = parse_1$1;
const clean$2 = (version2, options) => {
  const s = parse$7(version2.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$2;
const SemVer$b = semver$2;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$6 = parse_1$1;
const diff$1 = (version1, version2) => {
  const v1 = parse$6(version1, null, true);
  const v2 = parse$6(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return "minor";
      }
      return "patch";
    }
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$2;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$2;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2;
const patch$3 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$3;
const parse$5 = parse_1$1;
const prerelease$1 = (version2, options) => {
  const parsed = parse$5(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$2;
const parse$4 = parse_1$1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build2 = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$4(`${major2}.${minor2}.${patch2}${prerelease2}${build2}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.map.get(key);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
  set(key, value) {
    const deleted = this.delete(key);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range$1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range$1;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range$1 = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1$2;
  const SemVer3 = semver$2;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$3;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range$1;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1$2;
  const SemVer3 = semver$2;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set2 = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version2 of v) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first) {
        first = version2;
      }
    } else {
      if (prev) {
        set2.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set2.push([first, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants$2 = constants$3;
const SemVer2 = semver$2;
const identifiers = identifiers$1;
const parse$3 = parse_1$1;
const valid = valid_1;
const clean$1 = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch$2 = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver$1 = {
  parse: parse$3,
  valid,
  clean: clean$1,
  inc,
  diff,
  major,
  minor,
  patch: patch$2,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$2.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$2.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
(function(module) {
  const semver2 = semver$1;
  const assert2 = require$$0$9;
  const kRegisteredPlugins = Symbol.for("registered-plugin");
  const {
    kTestInternals
  } = symbols$1;
  const { exist, existReply, existRequest } = decorate_1;
  const {
    FST_ERR_PLUGIN_VERSION_MISMATCH,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
  } = errorsExports;
  const rcRegex = /-(?:rc|pre|alpha).+$/u;
  function getMeta(fn) {
    return fn[Symbol.for("plugin-meta")];
  }
  function getPluginName2(func) {
    const display = getDisplayName(func);
    if (display) {
      return display;
    }
    const cache = require.cache;
    if (cache) {
      const keys2 = Object.keys(cache);
      for (let i = 0; i < keys2.length; i++) {
        const key = keys2[i];
        if (cache[key].exports === func) {
          return key;
        }
      }
    }
    if (func.name) {
      return func.name;
    }
    return null;
  }
  function getFuncPreview(func) {
    return func.toString().split("\n", 2).map((s) => s.trim()).join(" -- ");
  }
  function getDisplayName(fn) {
    return fn[Symbol.for("fastify.display-name")];
  }
  function shouldSkipOverride(fn) {
    return !!fn[Symbol.for("skip-override")];
  }
  function checkDependencies2(fn) {
    const meta2 = getMeta(fn);
    if (!meta2) return;
    const dependencies2 = meta2.dependencies;
    if (!dependencies2) return;
    assert2(Array.isArray(dependencies2), "The dependencies should be an array of strings");
    dependencies2.forEach((dependency) => {
      assert2(
        this[kRegisteredPlugins].indexOf(dependency) > -1,
        `The dependency '${dependency}' of plugin '${meta2.name}' is not registered`
      );
    });
  }
  function checkDecorators(fn) {
    const meta2 = getMeta(fn);
    if (!meta2) return;
    const { decorators, name } = meta2;
    if (!decorators) return;
    if (decorators.fastify) _checkDecorators(this, "Fastify", decorators.fastify, name);
    if (decorators.reply) _checkDecorators(this, "Reply", decorators.reply, name);
    if (decorators.request) _checkDecorators(this, "Request", decorators.request, name);
  }
  const checks = {
    Fastify: exist,
    Request: existRequest,
    Reply: existReply
  };
  function _checkDecorators(that, instance, decorators, name) {
    assert2(Array.isArray(decorators), "The decorators should be an array of strings");
    decorators.forEach((decorator2) => {
      const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
      if (!checks[instance].call(that, decorator2)) {
        throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator2, withPluginName, instance);
      }
    });
  }
  function checkVersion(fn) {
    const meta2 = getMeta(fn);
    if ((meta2 == null ? void 0 : meta2.fastify) == null) return;
    const requiredVersion = meta2.fastify;
    const fastifyRc = rcRegex.test(this.version);
    if (fastifyRc === true && semver2.gt(this.version, semver2.coerce(requiredVersion)) === true) {
      return;
    }
    if (requiredVersion && semver2.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
      throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta2.name, requiredVersion, this.version);
    }
  }
  function registerPluginName(fn) {
    const meta2 = getMeta(fn);
    if (!meta2) return;
    const name = meta2.name;
    if (!name) return;
    this[kRegisteredPlugins].push(name);
    return name;
  }
  function checkPluginHealthiness(fn, pluginName) {
    if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
      throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName);
    }
  }
  function registerPlugin(fn) {
    const pluginName = registerPluginName.call(this, fn) || getPluginName2(fn);
    checkPluginHealthiness.call(this, fn, pluginName);
    checkVersion.call(this, fn);
    checkDecorators.call(this, fn);
    checkDependencies2.call(this, fn);
    return shouldSkipOverride(fn);
  }
  module.exports = {
    getPluginName: getPluginName2,
    getFuncPreview,
    kRegisteredPlugins,
    getDisplayName,
    registerPlugin
  };
  module.exports[kTestInternals] = {
    shouldSkipOverride,
    getMeta,
    checkDecorators,
    checkDependencies: checkDependencies2
  };
})(pluginUtils$2);
var pluginUtilsExports = pluginUtils$2.exports;
function reqIdGenFactory$1(requestIdHeader, optGenReqId) {
  const genReqId = optGenReqId || buildDefaultGenReqId();
  if (requestIdHeader) {
    return buildOptionalHeaderReqId(requestIdHeader, genReqId);
  }
  return genReqId;
}
function getGenReqId$3(contextServer, req2) {
  return contextServer.genReqId(req2);
}
function buildDefaultGenReqId() {
  const maxInt = 2147483647;
  let nextReqId = 0;
  return function defaultGenReqId() {
    nextReqId = nextReqId + 1 & maxInt;
    return `req-${nextReqId.toString(36)}`;
  };
}
function buildOptionalHeaderReqId(requestIdHeader, genReqId) {
  return function(req2) {
    return req2.headers[requestIdHeader] || genReqId(req2);
  };
}
var reqIdGenFactory_1 = {
  getGenReqId: getGenReqId$3,
  reqIdGenFactory: reqIdGenFactory$1
};
var lib$1 = { exports: {} };
var UTF8_ACCEPT = 12;
var UTF8_REJECT = 0;
var UTF8_DATA = [
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
function decodeURIComponent$1(uri2) {
  var percentPosition = uri2.indexOf("%");
  if (percentPosition === -1) return uri2;
  var length = uri2.length;
  var decoded = "";
  var last = 0;
  var codepoint = 0;
  var startOfOctets = percentPosition;
  var state2 = UTF8_ACCEPT;
  while (percentPosition > -1 && percentPosition < length) {
    var high = hexCodeToInt(uri2[percentPosition + 1], 4);
    var low = hexCodeToInt(uri2[percentPosition + 2], 0);
    var byte = high | low;
    var type2 = UTF8_DATA[byte];
    state2 = UTF8_DATA[256 + state2 + type2];
    codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type2];
    if (state2 === UTF8_ACCEPT) {
      decoded += uri2.slice(last, startOfOctets);
      decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
        55232 + (codepoint >> 10),
        56320 + (codepoint & 1023)
      );
      codepoint = 0;
      last = percentPosition + 3;
      percentPosition = startOfOctets = uri2.indexOf("%", last);
    } else if (state2 === UTF8_REJECT) {
      return null;
    } else {
      percentPosition += 3;
      if (percentPosition < length && uri2.charCodeAt(percentPosition) === 37) continue;
      return null;
    }
  }
  return decoded + uri2.slice(last);
}
var HEX = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
function hexCodeToInt(c, shift) {
  var i = HEX[c];
  return i === void 0 ? 255 : i << shift;
}
var fastDecodeUriComponent = decodeURIComponent$1;
const fastDecode = fastDecodeUriComponent;
const plusRegex = /\+/g;
const Empty = function() {
};
Empty.prototype = /* @__PURE__ */ Object.create(null);
function parse$2(input) {
  const result = new Empty();
  if (typeof input !== "string") {
    return result;
  }
  let inputLength = input.length;
  let key = "";
  let value = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let shouldDecodeKey = false;
  let shouldDecodeValue = false;
  let keyHasPlus = false;
  let valueHasPlus = false;
  let hasBothKeyValuePair = false;
  let c = 0;
  for (let i = 0; i < inputLength + 1; i++) {
    c = i !== inputLength ? input.charCodeAt(i) : 38;
    if (c === 38) {
      hasBothKeyValuePair = equalityIndex > startingIndex;
      if (!hasBothKeyValuePair) {
        equalityIndex = i;
      }
      key = input.slice(startingIndex + 1, equalityIndex);
      if (hasBothKeyValuePair || key.length > 0) {
        if (keyHasPlus) {
          key = key.replace(plusRegex, " ");
        }
        if (shouldDecodeKey) {
          key = fastDecode(key) || key;
        }
        if (hasBothKeyValuePair) {
          value = input.slice(equalityIndex + 1, i);
          if (valueHasPlus) {
            value = value.replace(plusRegex, " ");
          }
          if (shouldDecodeValue) {
            value = fastDecode(value) || value;
          }
        }
        const currentValue = result[key];
        if (currentValue === void 0) {
          result[key] = value;
        } else {
          if (currentValue.pop) {
            currentValue.push(value);
          } else {
            result[key] = [currentValue, value];
          }
        }
      }
      value = "";
      startingIndex = i;
      equalityIndex = i;
      shouldDecodeKey = false;
      shouldDecodeValue = false;
      keyHasPlus = false;
      valueHasPlus = false;
    } else if (c === 61) {
      if (equalityIndex <= startingIndex) {
        equalityIndex = i;
      } else {
        shouldDecodeValue = true;
      }
    } else if (c === 43) {
      if (equalityIndex > startingIndex) {
        valueHasPlus = true;
      } else {
        keyHasPlus = true;
      }
    } else if (c === 37) {
      if (equalityIndex > startingIndex) {
        shouldDecodeValue = true;
      } else {
        shouldDecodeKey = true;
      }
    }
  }
  return result;
}
var parse_1 = parse$2;
const hexTable = Array.from(
  { length: 256 },
  (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
);
const noEscape = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  // 80 - 95
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
  // 112 - 127
]);
function encodeString$1(str2) {
  const len = str2.length;
  if (len === 0) return "";
  let out2 = "";
  let lastPos = 0;
  let i = 0;
  outer: for (; i < len; i++) {
    let c = str2.charCodeAt(i);
    while (c < 128) {
      if (noEscape[c] !== 1) {
        if (lastPos < i) out2 += str2.slice(lastPos, i);
        lastPos = i + 1;
        out2 += hexTable[c];
      }
      if (++i === len) break outer;
      c = str2.charCodeAt(i);
    }
    if (lastPos < i) out2 += str2.slice(lastPos, i);
    if (c < 2048) {
      lastPos = i + 1;
      out2 += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
      continue;
    }
    if (c < 55296 || c >= 57344) {
      lastPos = i + 1;
      out2 += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      continue;
    }
    ++i;
    if (i >= len) {
      throw new Error("URI malformed");
    }
    const c2 = str2.charCodeAt(i) & 1023;
    lastPos = i + 1;
    c = 65536 + ((c & 1023) << 10 | c2);
    out2 += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  if (lastPos === 0) return str2;
  if (lastPos < len) return out2 + str2.slice(lastPos);
  return out2;
}
var querystring$1 = { encodeString: encodeString$1 };
const { encodeString } = querystring$1;
function getAsPrimitive(value) {
  const type2 = typeof value;
  if (type2 === "string") {
    return encodeString(value);
  } else if (type2 === "bigint") {
    return value.toString();
  } else if (type2 === "boolean") {
    return value ? "true" : "false";
  } else if (type2 === "number" && Number.isFinite(value)) {
    return value < 1e21 ? "" + value : encodeString("" + value);
  }
  return "";
}
function stringify$6(input) {
  let result = "";
  if (input === null || typeof input !== "object") {
    return result;
  }
  const separator = "&";
  const keys2 = Object.keys(input);
  const keyLength = keys2.length;
  let valueLength = 0;
  for (let i = 0; i < keyLength; i++) {
    const key = keys2[i];
    const value = input[key];
    const encodedKey = encodeString(key) + "=";
    if (i) {
      result += separator;
    }
    if (Array.isArray(value)) {
      valueLength = value.length;
      for (let j = 0; j < valueLength; j++) {
        if (j) {
          result += separator;
        }
        result += encodedKey;
        result += getAsPrimitive(value[j]);
      }
    } else {
      result += encodedKey;
      result += getAsPrimitive(value);
    }
  }
  return result;
}
var stringify_1 = stringify$6;
const parse$1 = parse_1;
const stringify$5 = stringify_1;
const fastQuerystring = {
  parse: parse$1,
  stringify: stringify$5
};
lib$1.exports = fastQuerystring;
lib$1.exports.default = fastQuerystring;
lib$1.exports.parse = parse$1;
lib$1.exports.stringify = stringify$5;
var libExports = lib$1.exports;
var safeRegex2 = { exports: {} };
var dist$1 = { exports: {} };
var types$3 = {};
var tokens = {};
Object.defineProperty(tokens, "__esModule", { value: true });
var types$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = void 0;
  (function(types2) {
    types2[types2["ROOT"] = 0] = "ROOT";
    types2[types2["GROUP"] = 1] = "GROUP";
    types2[types2["POSITION"] = 2] = "POSITION";
    types2[types2["SET"] = 3] = "SET";
    types2[types2["RANGE"] = 4] = "RANGE";
    types2[types2["REPETITION"] = 5] = "REPETITION";
    types2[types2["REFERENCE"] = 6] = "REFERENCE";
    types2[types2["CHAR"] = 7] = "CHAR";
  })(exports.types || (exports.types = {}));
})(types$2);
var setLookup = {};
Object.defineProperty(setLookup, "__esModule", { value: true });
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(tokens, exports);
  __exportStar(types$2, exports);
  __exportStar(setLookup, exports);
})(types$3);
var tokenizer = {};
var util$8 = {};
var sets$3 = {};
Object.defineProperty(sets$3, "__esModule", { value: true });
sets$3.anyChar = sets$3.notWhitespace = sets$3.whitespace = sets$3.notInts = sets$3.ints = sets$3.notWords = sets$3.words = void 0;
const types_1$a = types$3;
const INTS = () => [{ type: types_1$a.types.RANGE, from: 48, to: 57 }];
const WORDS = () => [
  { type: types_1$a.types.CHAR, value: 95 },
  { type: types_1$a.types.RANGE, from: 97, to: 122 },
  { type: types_1$a.types.RANGE, from: 65, to: 90 },
  { type: types_1$a.types.RANGE, from: 48, to: 57 }
];
const WHITESPACE = () => [
  { type: types_1$a.types.CHAR, value: 9 },
  { type: types_1$a.types.CHAR, value: 10 },
  { type: types_1$a.types.CHAR, value: 11 },
  { type: types_1$a.types.CHAR, value: 12 },
  { type: types_1$a.types.CHAR, value: 13 },
  { type: types_1$a.types.CHAR, value: 32 },
  { type: types_1$a.types.CHAR, value: 160 },
  { type: types_1$a.types.CHAR, value: 5760 },
  { type: types_1$a.types.RANGE, from: 8192, to: 8202 },
  { type: types_1$a.types.CHAR, value: 8232 },
  { type: types_1$a.types.CHAR, value: 8233 },
  { type: types_1$a.types.CHAR, value: 8239 },
  { type: types_1$a.types.CHAR, value: 8287 },
  { type: types_1$a.types.CHAR, value: 12288 },
  { type: types_1$a.types.CHAR, value: 65279 }
];
const NOTANYCHAR = () => [
  { type: types_1$a.types.CHAR, value: 10 },
  { type: types_1$a.types.CHAR, value: 13 },
  { type: types_1$a.types.CHAR, value: 8232 },
  { type: types_1$a.types.CHAR, value: 8233 }
];
sets$3.words = () => ({ type: types_1$a.types.SET, set: WORDS(), not: false });
sets$3.notWords = () => ({ type: types_1$a.types.SET, set: WORDS(), not: true });
sets$3.ints = () => ({ type: types_1$a.types.SET, set: INTS(), not: false });
sets$3.notInts = () => ({ type: types_1$a.types.SET, set: INTS(), not: true });
sets$3.whitespace = () => ({ type: types_1$a.types.SET, set: WHITESPACE(), not: false });
sets$3.notWhitespace = () => ({ type: types_1$a.types.SET, set: WHITESPACE(), not: true });
sets$3.anyChar = () => ({ type: types_1$a.types.SET, set: NOTANYCHAR(), not: true });
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
Object.defineProperty(util$8, "__esModule", { value: true });
util$8.tokenizeClass = util$8.strToChars = void 0;
const types_1$9 = types$3;
const sets$2 = __importStar$3(sets$3);
const CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
util$8.strToChars = (str2) => {
  const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
  return str2.replace(charsRegex, (s, b, lbs, a16, b16, dctrl, eslsh) => {
    if (lbs) {
      return s;
    }
    let code2 = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : dctrl ? CTRL.indexOf(dctrl) : {
      0: 0,
      t: 9,
      n: 10,
      v: 11,
      f: 12,
      r: 13
    }[eslsh];
    let c = String.fromCharCode(code2);
    return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
  });
};
util$8.tokenizeClass = (str2, regexpStr) => {
  var _a2, _b, _c, _d, _e, _f, _g;
  let tokens2 = [], rs, c;
  const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  while ((rs = regexp.exec(str2)) !== null) {
    const p = (_g = (_f = (_e = (_d = (_c = (_b = (_a2 = rs[1] && sets$2.words()) !== null && _a2 !== void 0 ? _a2 : rs[2] && sets$2.ints()) !== null && _b !== void 0 ? _b : rs[3] && sets$2.whitespace()) !== null && _c !== void 0 ? _c : rs[4] && sets$2.notWords()) !== null && _d !== void 0 ? _d : rs[5] && sets$2.notInts()) !== null && _e !== void 0 ? _e : rs[6] && sets$2.notWhitespace()) !== null && _f !== void 0 ? _f : rs[7] && {
      type: types_1$9.types.RANGE,
      from: (rs[8] || rs[9]).charCodeAt(0),
      to: (c = rs[10]).charCodeAt(c.length - 1)
    }) !== null && _g !== void 0 ? _g : (c = rs[16]) && { type: types_1$9.types.CHAR, value: c.charCodeAt(0) };
    if (p) {
      tokens2.push(p);
    } else {
      return [tokens2, regexp.lastIndex];
    }
  }
  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
Object.defineProperty(tokenizer, "__esModule", { value: true });
tokenizer.tokenizer = void 0;
const util$7 = __importStar$2(util$8);
const types_1$8 = types$3;
const sets$1 = __importStar$2(sets$3);
const captureGroupFirstChar = /^[a-zA-Z_$]$/i;
const captureGroupChars = /^[a-zA-Z0-9_$]$/i;
const digit = /\d/;
tokenizer.tokenizer = (regexpStr) => {
  let i = 0, c;
  let start = { type: types_1$8.types.ROOT, stack: [] };
  let lastGroup = start;
  let last = start.stack;
  let groupStack = [];
  let referenceQueue = [];
  let groupCount = 0;
  const repeatErr = (col) => {
    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
  };
  let str2 = util$7.strToChars(regexpStr);
  while (i < str2.length) {
    switch (c = str2[i++]) {
      case "\\":
        if (i === str2.length) {
          throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
        }
        switch (c = str2[i++]) {
          case "b":
            last.push({ type: types_1$8.types.POSITION, value: "b" });
            break;
          case "B":
            last.push({ type: types_1$8.types.POSITION, value: "B" });
            break;
          case "w":
            last.push(sets$1.words());
            break;
          case "W":
            last.push(sets$1.notWords());
            break;
          case "d":
            last.push(sets$1.ints());
            break;
          case "D":
            last.push(sets$1.notInts());
            break;
          case "s":
            last.push(sets$1.whitespace());
            break;
          case "S":
            last.push(sets$1.notWhitespace());
            break;
          default:
            if (digit.test(c)) {
              let digits = c;
              while (i < str2.length && digit.test(str2[i])) {
                digits += str2[i++];
              }
              let value = parseInt(digits, 10);
              const reference = { type: types_1$8.types.REFERENCE, value };
              last.push(reference);
              referenceQueue.push({ reference, stack: last, index: last.length - 1 });
            } else {
              last.push({ type: types_1$8.types.CHAR, value: c.charCodeAt(0) });
            }
        }
        break;
      case "^":
        last.push({ type: types_1$8.types.POSITION, value: "^" });
        break;
      case "$":
        last.push({ type: types_1$8.types.POSITION, value: "$" });
        break;
      case "[": {
        let not2;
        if (str2[i] === "^") {
          not2 = true;
          i++;
        } else {
          not2 = false;
        }
        let classTokens = util$7.tokenizeClass(str2.slice(i), regexpStr);
        i += classTokens[1];
        last.push({
          type: types_1$8.types.SET,
          set: classTokens[0],
          not: not2
        });
        break;
      }
      case ".":
        last.push(sets$1.anyChar());
        break;
      case "(": {
        let group = {
          type: types_1$8.types.GROUP,
          stack: [],
          remember: true
        };
        if (str2[i] === "?") {
          c = str2[i + 1];
          i += 2;
          if (c === "=") {
            group.followedBy = true;
            group.remember = false;
          } else if (c === "!") {
            group.notFollowedBy = true;
            group.remember = false;
          } else if (c === "<") {
            let name = "";
            if (captureGroupFirstChar.test(str2[i])) {
              name += str2[i];
              i++;
            } else {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str2[i]}' after '<' at column ${i + 1}`);
            }
            while (i < str2.length && captureGroupChars.test(str2[i])) {
              name += str2[i];
              i++;
            }
            if (!name) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str2[i]}' after '<' at column ${i + 1}`);
            }
            if (str2[i] !== ">") {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found '${str2[i]}' at column ${i + 1}`);
            }
            group.name = name;
            i++;
          } else if (c === ":") {
            group.remember = false;
          } else {
            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c}' after '?' at column ${i - 1}`);
          }
        } else {
          groupCount += 1;
        }
        last.push(group);
        groupStack.push(lastGroup);
        lastGroup = group;
        last = group.stack;
        break;
      }
      case ")":
        if (groupStack.length === 0) {
          throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
        }
        lastGroup = groupStack.pop();
        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;
      case "|": {
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        }
        let stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;
      }
      case "{": {
        let rs = /^(\d+)(,(\d+)?)?\}/.exec(str2.slice(i)), min2, max2;
        if (rs !== null) {
          if (last.length === 0) {
            repeatErr(i);
          }
          min2 = parseInt(rs[1], 10);
          max2 = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min2;
          i += rs[0].length;
          last.push({
            type: types_1$8.types.REPETITION,
            min: min2,
            max: max2,
            value: last.pop()
          });
        } else {
          last.push({
            type: types_1$8.types.CHAR,
            value: 123
          });
        }
        break;
      }
      case "?":
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types_1$8.types.REPETITION,
          min: 0,
          max: 1,
          value: last.pop()
        });
        break;
      case "+":
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types_1$8.types.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop()
        });
        break;
      case "*":
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types_1$8.types.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop()
        });
        break;
      default:
        last.push({
          type: types_1$8.types.CHAR,
          value: c.charCodeAt(0)
        });
    }
  }
  if (groupStack.length !== 0) {
    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
  }
  updateReferences(referenceQueue, groupCount);
  return start;
};
function updateReferences(referenceQueue, groupCount) {
  for (const elem of referenceQueue.reverse()) {
    if (groupCount < elem.reference.value) {
      elem.reference.type = types_1$8.types.CHAR;
      const valueString = elem.reference.value.toString();
      elem.reference.value = parseInt(valueString, 8);
      if (!/^[0-7]+$/.test(valueString)) {
        let i = 0;
        while (valueString[i] !== "8" && valueString[i] !== "9") {
          i += 1;
        }
        if (i === 0) {
          elem.reference.value = valueString.charCodeAt(0);
          i += 1;
        } else {
          elem.reference.value = parseInt(valueString.slice(0, i), 8);
        }
        if (valueString.length > i) {
          const tail = elem.stack.splice(elem.index + 1);
          for (const char of valueString.slice(i)) {
            elem.stack.push({
              type: types_1$8.types.CHAR,
              value: char.charCodeAt(0)
            });
          }
          elem.stack.push(...tail);
        }
      }
    }
  }
}
var reconstruct = {};
var writeSetTokens$1 = {};
var setsLookup = {};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
Object.defineProperty(setsLookup, "__esModule", { value: true });
setsLookup.NOTANYCHAR = setsLookup.WHITESPACE = setsLookup.WORDS = setsLookup.INTS = void 0;
const Sets = __importStar$1(sets$3);
const types_1$7 = types$3;
function setToLookup(tokens2) {
  let lookup2 = {};
  let len = 0;
  for (const token of tokens2) {
    if (token.type === types_1$7.types.CHAR) {
      lookup2[token.value] = true;
    }
    if (token.type === types_1$7.types.RANGE) {
      lookup2[`${token.from}-${token.to}`] = true;
    }
    len += 1;
  }
  return {
    lookup: () => Object.assign({}, lookup2),
    len
  };
}
setsLookup.INTS = setToLookup(Sets.ints().set);
setsLookup.WORDS = setToLookup(Sets.words().set);
setsLookup.WHITESPACE = setToLookup(Sets.whitespace().set);
setsLookup.NOTANYCHAR = setToLookup(Sets.anyChar().set);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  Object.defineProperty(o, k2, { enumerable: true, get: function() {
    return m[k];
  } });
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(writeSetTokens$1, "__esModule", { value: true });
writeSetTokens$1.writeSetTokens = writeSetTokens$1.setChar = void 0;
const types_1$6 = types$3;
const sets = __importStar(setsLookup);
function setChar(charCode) {
  return charCode === 94 ? "\\^" : charCode === 92 ? "\\\\" : charCode === 93 ? "\\]" : charCode === 45 ? "\\-" : String.fromCharCode(charCode);
}
writeSetTokens$1.setChar = setChar;
function isSameSet(set2, { lookup: lookup2, len }) {
  if (len !== set2.length) {
    return false;
  }
  const map2 = lookup2();
  for (const elem of set2) {
    if (elem.type === types_1$6.types.SET) {
      return false;
    }
    const key = elem.type === types_1$6.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
    if (map2[key]) {
      map2[key] = false;
    } else {
      return false;
    }
  }
  return true;
}
function writeSetTokens(set2, isNested = false) {
  if (isSameSet(set2.set, sets.INTS)) {
    return set2.not ? "\\D" : "\\d";
  }
  if (isSameSet(set2.set, sets.WORDS)) {
    return set2.not ? "\\W" : "\\w";
  }
  if (set2.not && isSameSet(set2.set, sets.NOTANYCHAR)) {
    return ".";
  }
  if (isSameSet(set2.set, sets.WHITESPACE)) {
    return set2.not ? "\\S" : "\\s";
  }
  let tokenString = "";
  for (let i = 0; i < set2.set.length; i++) {
    const subset2 = set2.set[i];
    tokenString += writeSetToken(subset2);
  }
  const contents = `${set2.not ? "^" : ""}${tokenString}`;
  return isNested ? contents : `[${contents}]`;
}
writeSetTokens$1.writeSetTokens = writeSetTokens;
function writeSetToken(set2) {
  if (set2.type === types_1$6.types.CHAR) {
    return setChar(set2.value);
  } else if (set2.type === types_1$6.types.RANGE) {
    return `${setChar(set2.from)}-${setChar(set2.to)}`;
  }
  return writeSetTokens(set2, true);
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconstruct = void 0;
  const types_12 = types$3;
  const write_set_tokens_1 = writeSetTokens$1;
  const reduceStack = (stack) => stack.map(exports.reconstruct).join("");
  const createAlternate = (token) => {
    if ("options" in token) {
      return token.options.map(reduceStack).join("|");
    } else if ("stack" in token) {
      return reduceStack(token.stack);
    } else {
      throw new Error(`options or stack must be Root or Group token`);
    }
  };
  exports.reconstruct = (token) => {
    switch (token.type) {
      case types_12.types.ROOT:
        return createAlternate(token);
      case types_12.types.CHAR: {
        const c = String.fromCharCode(token.value);
        return (/[[\\{}$^.|?*+()]/.test(c) ? "\\" : "") + c;
      }
      case types_12.types.POSITION:
        if (token.value === "^" || token.value === "$") {
          return token.value;
        } else {
          return `\\${token.value}`;
        }
      case types_12.types.REFERENCE:
        return `\\${token.value}`;
      case types_12.types.SET:
        return write_set_tokens_1.writeSetTokens(token);
      case types_12.types.GROUP: {
        const prefix = token.name ? `?<${token.name}>` : token.remember ? "" : token.followedBy ? "?=" : token.notFollowedBy ? "?!" : "?:";
        return `(${prefix}${createAlternate(token)})`;
      }
      case types_12.types.REPETITION: {
        const { min: min2, max: max2 } = token;
        let endWith;
        if (min2 === 0 && max2 === 1) {
          endWith = "?";
        } else if (min2 === 1 && max2 === Infinity) {
          endWith = "+";
        } else if (min2 === 0 && max2 === Infinity) {
          endWith = "*";
        } else if (max2 === Infinity) {
          endWith = `{${min2},}`;
        } else if (min2 === max2) {
          endWith = `{${min2}}`;
        } else {
          endWith = `{${min2},${max2}}`;
        }
        return `${exports.reconstruct(token.value)}${endWith}`;
      }
      case types_12.types.RANGE:
        return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
      default:
        throw new Error(`Invalid token type ${token}`);
    }
  };
})(reconstruct);
(function(module, exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = void 0;
  const types_12 = types$3;
  Object.defineProperty(exports, "types", { enumerable: true, get: function() {
    return types_12.types;
  } });
  __exportStar(tokenizer, exports);
  __exportStar(reconstruct, exports);
  const tokenizer_1 = tokenizer;
  const reconstruct_1 = reconstruct;
  __exportStar(types$3, exports);
  exports.default = tokenizer_1.tokenizer;
  module.exports = tokenizer_1.tokenizer;
  module.exports.types = types_12.types;
  module.exports.reconstruct = reconstruct_1.reconstruct;
})(dist$1, dist$1.exports);
var distExports = dist$1.exports;
const parse = distExports;
const types$1 = parse.types;
function safeRegex(re2, opts) {
  if (!opts) opts = {};
  const replimit = opts.limit === void 0 ? 25 : opts.limit;
  if (isRegExp$1(re2)) re2 = re2.source;
  else if (typeof re2 !== "string") re2 = String(re2);
  try {
    re2 = parse(re2);
  } catch {
    return false;
  }
  let reps = 0;
  return function walk(node2, starHeight) {
    var _a2;
    let i;
    let ok;
    let len;
    if (node2.type === types$1.REPETITION) {
      starHeight++;
      reps++;
      if (starHeight > 1) return false;
      if (reps > replimit) return false;
    }
    if (node2.options) {
      for (i = 0, len = node2.options.length; i < len; i++) {
        ok = walk({ stack: node2.options[i] }, starHeight);
        if (!ok) return false;
      }
    }
    const stack = node2.stack || ((_a2 = node2.value) == null ? void 0 : _a2.stack);
    if (!stack) return true;
    for (i = 0; i < stack.length; i++) {
      ok = walk(stack[i], starHeight);
      if (!ok) return false;
    }
    return true;
  }(re2, 0);
}
function isRegExp$1(x) {
  return {}.toString.call(x) === "[object RegExp]";
}
safeRegex2.exports = safeRegex;
safeRegex2.exports.default = safeRegex;
safeRegex2.exports.safeRegex = safeRegex;
var safeRegex2Exports = safeRegex2.exports;
var httpMethod = {
  name: "__fmw_internal_strategy_merged_tree_http_method__",
  storage: function() {
    const handlers = /* @__PURE__ */ new Map();
    return {
      get: (type2) => {
        return handlers.get(type2) || null;
      },
      set: (type2, store) => {
        handlers.set(type2, store);
      }
    };
  },
  /* c8 ignore next 1 */
  deriveConstraint: (req2) => req2.method,
  mustMatchWhenDerived: true
};
const deepEqual$1 = fastDeepEqual;
const httpMethodStrategy$2 = httpMethod;
const treeDataSymbol = Symbol("treeData");
function printObjectTree(obj, parentPrefix = "") {
  let tree = "";
  const keys2 = Object.keys(obj);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const value = obj[key];
    const isLast = i === keys2.length - 1;
    const nodePrefix = isLast ? "└── " : "├── ";
    const childPrefix = isLast ? "    " : "│   ";
    const nodeData = value[treeDataSymbol] || "";
    const prefixedNodeData = nodeData.replaceAll("\n", "\n" + parentPrefix + childPrefix);
    tree += parentPrefix + nodePrefix + key + prefixedNodeData + "\n";
    tree += printObjectTree(value, parentPrefix + childPrefix);
  }
  return tree;
}
function parseFunctionName(fn) {
  let fName = fn.name || "";
  fName = fName.replace("bound", "").trim();
  fName = (fName || "anonymous") + "()";
  return fName;
}
function parseMeta(meta2) {
  if (Array.isArray(meta2)) return meta2.map((m) => parseMeta(m));
  if (typeof meta2 === "symbol") return meta2.toString();
  if (typeof meta2 === "function") return parseFunctionName(meta2);
  return meta2;
}
function getRouteMetaData(route2, options) {
  if (!options.includeMeta) return {};
  const metaDataObject = options.buildPrettyMeta(route2);
  const filteredMetaData = {};
  let includeMetaKeys = options.includeMeta;
  if (!Array.isArray(includeMetaKeys)) {
    includeMetaKeys = Reflect.ownKeys(metaDataObject);
  }
  for (const metaKey of includeMetaKeys) {
    if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue;
    const serializedKey = metaKey.toString();
    const metaValue = metaDataObject[metaKey];
    if (metaValue !== void 0 && metaValue !== null) {
      const serializedValue = JSON.stringify(parseMeta(metaValue));
      filteredMetaData[serializedKey] = serializedValue;
    }
  }
  return filteredMetaData;
}
function serializeMetaData(metaData) {
  let serializedMetaData = "";
  for (const [key, value] of Object.entries(metaData)) {
    serializedMetaData += `
• (${key}) ${value}`;
  }
  return serializedMetaData;
}
function normalizeRoute(route2) {
  const constraints = { ...route2.opts.constraints };
  const method = constraints[httpMethodStrategy$2.name];
  delete constraints[httpMethodStrategy$2.name];
  return { ...route2, method, opts: { constraints } };
}
function serializeRoute(route2) {
  let serializedRoute = ` (${route2.method})`;
  const constraints = route2.opts.constraints || {};
  if (Object.keys(constraints).length !== 0) {
    serializedRoute += " " + JSON.stringify(constraints);
  }
  serializedRoute += serializeMetaData(route2.metaData);
  return serializedRoute;
}
function mergeSimilarRoutes(routes) {
  return routes.reduce((mergedRoutes, route2) => {
    for (const nodeRoute of mergedRoutes) {
      if (deepEqual$1(route2.opts.constraints, nodeRoute.opts.constraints) && deepEqual$1(route2.metaData, nodeRoute.metaData)) {
        nodeRoute.method += ", " + route2.method;
        return mergedRoutes;
      }
    }
    mergedRoutes.push(route2);
    return mergedRoutes;
  }, []);
}
function serializeNode(node2, prefix, options) {
  let routes = node2.routes;
  if (options.method === void 0) {
    routes = routes.map(normalizeRoute);
  }
  routes = routes.map((route2) => {
    route2.metaData = getRouteMetaData(route2, options);
    return route2;
  });
  if (options.method === void 0) {
    routes = mergeSimilarRoutes(routes);
  }
  return routes.map(serializeRoute).join(`
${prefix}`);
}
function buildObjectTree(node2, tree, prefix, options) {
  if (node2.isLeafNode || options.commonPrefix !== false) {
    prefix = prefix || "(empty root node)";
    tree = tree[prefix] = {};
    if (node2.isLeafNode) {
      tree[treeDataSymbol] = serializeNode(node2, prefix, options);
    }
    prefix = "";
  }
  if (node2.staticChildren) {
    for (const child of Object.values(node2.staticChildren)) {
      buildObjectTree(child, tree, prefix + child.prefix, options);
    }
  }
  if (node2.parametricChildren) {
    for (const child of Object.values(node2.parametricChildren)) {
      const childPrefix = Array.from(child.nodePaths).join("|");
      buildObjectTree(child, tree, prefix + childPrefix, options);
    }
  }
  if (node2.wildcardChild) {
    buildObjectTree(node2.wildcardChild, tree, "*", options);
  }
}
function prettyPrintTree$1(root2, options) {
  const objectTree = {};
  buildObjectTree(root2, objectTree, root2.prefix, options);
  return printObjectTree(objectTree);
}
var prettyPrint = { prettyPrintTree: prettyPrintTree$1 };
const NullObject$1 = function() {
};
NullObject$1.prototype = /* @__PURE__ */ Object.create(null);
var nullObject = {
  NullObject: NullObject$1
};
const { NullObject } = nullObject;
const httpMethodStrategy$1 = httpMethod;
let HandlerStorage$1 = class HandlerStorage {
  constructor() {
    this.unconstrainedHandler = null;
    this.constraints = [];
    this.handlers = [];
    this.constrainedHandlerStores = null;
  }
  // This is the hot path for node handler finding -- change with care!
  getMatchingHandler(derivedConstraints) {
    if (derivedConstraints === void 0) {
      return this.unconstrainedHandler;
    }
    return this._getHandlerMatchingConstraints(derivedConstraints);
  }
  addHandler(constrainer2, route2) {
    const params = route2.params;
    const constraints = route2.opts.constraints || {};
    const handlerObject = {
      params,
      constraints,
      handler: route2.handler,
      store: route2.store || null,
      _createParamsObject: this._compileCreateParamsObject(params)
    };
    const constraintsNames = Object.keys(constraints);
    if (constraintsNames.length === 0) {
      this.unconstrainedHandler = handlerObject;
    }
    for (const constraint of constraintsNames) {
      if (!this.constraints.includes(constraint)) {
        if (constraint === "version") {
          this.constraints.unshift(constraint);
        } else {
          this.constraints.push(constraint);
        }
      }
    }
    const isMergedTree = constraintsNames.includes(httpMethodStrategy$1.name);
    if (!isMergedTree && this.handlers.length >= 31) {
      throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
    }
    this.handlers.push(handlerObject);
    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);
    if (!isMergedTree) {
      this._compileGetHandlerMatchingConstraints(constrainer2, constraints);
    }
  }
  _compileCreateParamsObject(params) {
    const fnBody = [];
    fnBody.push("const fn = function _createParamsObject (paramsArray) {");
    fnBody.push("const params = new NullObject()");
    for (let i = 0; i < params.length; i++) {
      fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
    }
    fnBody.push("return params");
    fnBody.push("}");
    fnBody.push("return fn");
    return new Function("NullObject", fnBody.join("\n"))(NullObject);
  }
  _getHandlerMatchingConstraints() {
    return null;
  }
  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
  // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
  // The store's implementation comes from the strategies provided to the Router.
  _buildConstraintStore(store, constraint) {
    for (let i = 0; i < this.handlers.length; i++) {
      const handler = this.handlers[i];
      const constraintValue = handler.constraints[constraint];
      if (constraintValue !== void 0) {
        let indexes2 = store.get(constraintValue) || 0;
        indexes2 |= 1 << i;
        store.set(constraintValue, indexes2);
      }
    }
  }
  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
  _constrainedIndexBitmask(constraint) {
    let mask = 0;
    for (let i = 0; i < this.handlers.length; i++) {
      const handler = this.handlers[i];
      const constraintValue = handler.constraints[constraint];
      if (constraintValue !== void 0) {
        mask |= 1 << i;
      }
    }
    return ~mask;
  }
  // Compile a fast function to match the handlers for this node
  // The function implements a general case multi-constraint matching algorithm.
  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
  _compileGetHandlerMatchingConstraints(constrainer2) {
    this.constrainedHandlerStores = {};
    for (const constraint of this.constraints) {
      const store = constrainer2.newStoreForConstraint(constraint);
      this.constrainedHandlerStores[constraint] = store;
      this._buildConstraintStore(store, constraint);
    }
    const lines = [];
    lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
    for (const constraint of this.constraints) {
      lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
      const strategy = constrainer2.strategies[constraint];
      const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
      lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
    }
    for (const constraint in constrainer2.strategies) {
      const strategy = constrainer2.strategies[constraint];
      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
      }
    }
    lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
    this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
  }
};
var handlerStorage = HandlerStorage$1;
const HandlerStorage2 = handlerStorage;
const NODE_TYPES$1 = {
  STATIC: 0,
  PARAMETRIC: 1,
  WILDCARD: 2
};
class Node {
  constructor() {
    this.isLeafNode = false;
    this.routes = null;
    this.handlerStorage = null;
  }
  addRoute(route2, constrainer2) {
    if (this.routes === null) {
      this.routes = [];
    }
    if (this.handlerStorage === null) {
      this.handlerStorage = new HandlerStorage2();
    }
    this.isLeafNode = true;
    this.routes.push(route2);
    this.handlerStorage.addHandler(constrainer2, route2);
  }
}
class ParentNode extends Node {
  constructor() {
    super();
    this.staticChildren = {};
  }
  findStaticMatchingChild(path2, pathIndex) {
    const staticChild = this.staticChildren[path2.charAt(pathIndex)];
    if (staticChild === void 0 || !staticChild.matchPrefix(path2, pathIndex)) {
      return null;
    }
    return staticChild;
  }
  getStaticChild(path2, pathIndex = 0) {
    if (path2.length === pathIndex) {
      return this;
    }
    const staticChild = this.findStaticMatchingChild(path2, pathIndex);
    if (staticChild) {
      return staticChild.getStaticChild(path2, pathIndex + staticChild.prefix.length);
    }
    return null;
  }
  createStaticChild(path2) {
    if (path2.length === 0) {
      return this;
    }
    let staticChild = this.staticChildren[path2.charAt(0)];
    if (staticChild) {
      let i = 1;
      for (; i < staticChild.prefix.length; i++) {
        if (path2.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
          staticChild = staticChild.split(this, i);
          break;
        }
      }
      return staticChild.createStaticChild(path2.slice(i));
    }
    const label = path2.charAt(0);
    this.staticChildren[label] = new StaticNode$1(path2);
    return this.staticChildren[label];
  }
}
let StaticNode$1 = class StaticNode extends ParentNode {
  constructor(prefix) {
    super();
    this.prefix = prefix;
    this.wildcardChild = null;
    this.parametricChildren = [];
    this.kind = NODE_TYPES$1.STATIC;
    this._compilePrefixMatch();
  }
  getParametricChild(regex) {
    const regexpSource = regex && regex.source;
    const parametricChild = this.parametricChildren.find((child) => {
      const childRegexSource = child.regex && child.regex.source;
      return childRegexSource === regexpSource;
    });
    if (parametricChild) {
      return parametricChild;
    }
    return null;
  }
  createParametricChild(regex, staticSuffix, nodePath) {
    let parametricChild = this.getParametricChild(regex);
    if (parametricChild) {
      parametricChild.nodePaths.add(nodePath);
      return parametricChild;
    }
    parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
    this.parametricChildren.push(parametricChild);
    this.parametricChildren.sort((child1, child2) => {
      if (!child1.isRegex) return 1;
      if (!child2.isRegex) return -1;
      if (child1.staticSuffix === null) return 1;
      if (child2.staticSuffix === null) return -1;
      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;
      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;
      return 0;
    });
    return parametricChild;
  }
  getWildcardChild() {
    return this.wildcardChild;
  }
  createWildcardChild() {
    this.wildcardChild = this.getWildcardChild() || new WildcardNode();
    return this.wildcardChild;
  }
  split(parentNode, length) {
    const parentPrefix = this.prefix.slice(0, length);
    const childPrefix = this.prefix.slice(length);
    this.prefix = childPrefix;
    this._compilePrefixMatch();
    const staticNode = new StaticNode(parentPrefix);
    staticNode.staticChildren[childPrefix.charAt(0)] = this;
    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
    return staticNode;
  }
  getNextNode(path2, pathIndex, nodeStack, paramsCount) {
    let node2 = this.findStaticMatchingChild(path2, pathIndex);
    let parametricBrotherNodeIndex = 0;
    if (node2 === null) {
      if (this.parametricChildren.length === 0) {
        return this.wildcardChild;
      }
      node2 = this.parametricChildren[0];
      parametricBrotherNodeIndex = 1;
    }
    if (this.wildcardChild !== null) {
      nodeStack.push({
        paramsCount,
        brotherPathIndex: pathIndex,
        brotherNode: this.wildcardChild
      });
    }
    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
      nodeStack.push({
        paramsCount,
        brotherPathIndex: pathIndex,
        brotherNode: this.parametricChildren[i]
      });
    }
    return node2;
  }
  _compilePrefixMatch() {
    if (this.prefix.length === 1) {
      this.matchPrefix = () => true;
      return;
    }
    const lines = [];
    for (let i = 1; i < this.prefix.length; i++) {
      const charCode = this.prefix.charCodeAt(i);
      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
    }
    this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
  }
};
class ParametricNode extends ParentNode {
  constructor(regex, staticSuffix, nodePath) {
    super();
    this.isRegex = !!regex;
    this.regex = regex || null;
    this.staticSuffix = staticSuffix || null;
    this.kind = NODE_TYPES$1.PARAMETRIC;
    this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
  }
  getNextNode(path2, pathIndex) {
    return this.findStaticMatchingChild(path2, pathIndex);
  }
}
class WildcardNode extends Node {
  constructor() {
    super();
    this.kind = NODE_TYPES$1.WILDCARD;
  }
  getNextNode() {
    return null;
  }
}
var node$1 = { StaticNode: StaticNode$1, NODE_TYPES: NODE_TYPES$1 };
const assert$5 = require$$0$9;
function SemVerStore() {
  if (!(this instanceof SemVerStore)) {
    return new SemVerStore();
  }
  this.store = /* @__PURE__ */ new Map();
  this.maxMajor = 0;
  this.maxMinors = {};
  this.maxPatches = {};
}
SemVerStore.prototype.set = function(version2, store) {
  if (typeof version2 !== "string") {
    throw new TypeError("Version should be a string");
  }
  let [major2, minor2, patch2] = version2.split(".", 3);
  if (isNaN(major2)) {
    throw new TypeError("Major version must be a numeric value");
  }
  major2 = Number(major2);
  minor2 = Number(minor2) || 0;
  patch2 = Number(patch2) || 0;
  if (major2 >= this.maxMajor) {
    this.maxMajor = major2;
    this.store.set("x", store);
    this.store.set("*", store);
    this.store.set("x.x", store);
    this.store.set("x.x.x", store);
  }
  if (minor2 >= (this.maxMinors[major2] || 0)) {
    this.maxMinors[major2] = minor2;
    this.store.set(`${major2}.x`, store);
    this.store.set(`${major2}.x.x`, store);
  }
  if (patch2 >= (this.maxPatches[`${major2}.${minor2}`] || 0)) {
    this.maxPatches[`${major2}.${minor2}`] = patch2;
    this.store.set(`${major2}.${minor2}.x`, store);
  }
  this.store.set(`${major2}.${minor2}.${patch2}`, store);
  return this;
};
SemVerStore.prototype.get = function(version2) {
  return this.store.get(version2);
};
var acceptVersion = {
  name: "version",
  mustMatchWhenDerived: true,
  storage: SemVerStore,
  validate(value) {
    assert$5(typeof value === "string", "Version should be a string");
  }
};
const assert$4 = require$$0$9;
function HostStorage() {
  const hosts = /* @__PURE__ */ new Map();
  const regexHosts = [];
  return {
    get: (host) => {
      const exact = hosts.get(host);
      if (exact) {
        return exact;
      }
      for (const regex of regexHosts) {
        if (regex.host.test(host)) {
          return regex.value;
        }
      }
    },
    set: (host, value) => {
      if (host instanceof RegExp) {
        regexHosts.push({ host, value });
      } else {
        hosts.set(host, value);
      }
    }
  };
}
var acceptHost = {
  name: "host",
  mustMatchWhenDerived: false,
  storage: HostStorage,
  validate(value) {
    assert$4(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
  }
};
const acceptVersionStrategy = acceptVersion;
const acceptHostStrategy = acceptHost;
const assert$3 = require$$0$9;
let Constrainer$1 = class Constrainer {
  constructor(customStrategies) {
    this.strategies = {
      version: acceptVersionStrategy,
      host: acceptHostStrategy
    };
    this.strategiesInUse = /* @__PURE__ */ new Set();
    this.asyncStrategiesInUse = /* @__PURE__ */ new Set();
    if (customStrategies) {
      for (const strategy of Object.values(customStrategies)) {
        this.addConstraintStrategy(strategy);
      }
    }
  }
  isStrategyUsed(strategyName) {
    return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
  }
  hasConstraintStrategy(strategyName) {
    const customConstraintStrategy = this.strategies[strategyName];
    if (customConstraintStrategy !== void 0) {
      return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
    }
    return false;
  }
  addConstraintStrategy(strategy) {
    assert$3(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
    assert$3(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
    assert$3(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
    }
    if (this.isStrategyUsed(strategy.name)) {
      throw new Error(`There already exists a route with ${strategy.name} constraint.`);
    }
    strategy.isCustom = true;
    strategy.isAsync = strategy.deriveConstraint.length === 3;
    this.strategies[strategy.name] = strategy;
    if (strategy.mustMatchWhenDerived) {
      this.noteUsage({ [strategy.name]: strategy });
    }
  }
  deriveConstraints(req2, ctx, done) {
    const constraints = this.deriveSyncConstraints(req2, ctx);
    if (done === void 0) {
      return constraints;
    }
    this.deriveAsyncConstraints(constraints, req2, ctx, done);
  }
  deriveSyncConstraints(req2, ctx) {
    return void 0;
  }
  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
  noteUsage(constraints) {
    if (constraints) {
      const beforeSize = this.strategiesInUse.size;
      for (const key in constraints) {
        const strategy = this.strategies[key];
        if (strategy.isAsync) {
          this.asyncStrategiesInUse.add(key);
        } else {
          this.strategiesInUse.add(key);
        }
      }
      if (beforeSize !== this.strategiesInUse.size) {
        this._buildDeriveConstraints();
      }
    }
  }
  newStoreForConstraint(constraint) {
    if (!this.strategies[constraint]) {
      throw new Error(`No strategy registered for constraint key ${constraint}`);
    }
    return this.strategies[constraint].storage();
  }
  validateConstraints(constraints) {
    for (const key in constraints) {
      const value = constraints[key];
      if (typeof value === "undefined") {
        throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
      }
      const strategy = this.strategies[key];
      if (!strategy) {
        throw new Error(`No strategy registered for constraint key ${key}`);
      }
      if (strategy.validate) {
        strategy.validate(value);
      }
    }
  }
  deriveAsyncConstraints(constraints, req2, ctx, done) {
    let asyncConstraintsCount = this.asyncStrategiesInUse.size;
    if (asyncConstraintsCount === 0) {
      done(null, constraints);
      return;
    }
    constraints = constraints || {};
    for (const key of this.asyncStrategiesInUse) {
      const strategy = this.strategies[key];
      strategy.deriveConstraint(req2, ctx, (err2, constraintValue) => {
        if (err2 !== null) {
          done(err2);
          return;
        }
        constraints[key] = constraintValue;
        if (--asyncConstraintsCount === 0) {
          done(null, constraints);
        }
      });
    }
  }
  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
  // This allows us to not allocate an object to hold constraint values if no constraints are defined.
  _buildDeriveConstraints() {
    if (this.strategiesInUse.size === 0) return;
    const lines = ["return {"];
    for (const key of this.strategiesInUse) {
      const strategy = this.strategies[key];
      if (!strategy.isCustom) {
        if (key === "version") {
          lines.push("   version: req.headers['accept-version'],");
        } else {
          lines.push("   host: req.headers.host || req.headers[':authority'],");
        }
      } else {
        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
      }
    }
    lines.push("}");
    this.deriveSyncConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
  }
};
var constrainer = Constrainer$1;
const httpMethods$1 = [
  "ACL",
  "BIND",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LINK",
  "LOCK",
  "M-SEARCH",
  "MERGE",
  "MKACTIVITY",
  "MKCALENDAR",
  "MKCOL",
  "MOVE",
  "NOTIFY",
  "OPTIONS",
  "PATCH",
  "POST",
  "PROPFIND",
  "PROPPATCH",
  "PURGE",
  "PUT",
  "QUERY",
  "REBIND",
  "REPORT",
  "SEARCH",
  "SOURCE",
  "SUBSCRIBE",
  "TRACE",
  "UNBIND",
  "UNLINK",
  "UNLOCK",
  "UNSUBSCRIBE"
];
var httpMethods_1 = httpMethods$1;
function decodeComponentChar(highCharCode, lowCharCode) {
  if (highCharCode === 50) {
    if (lowCharCode === 53) return "%";
    if (lowCharCode === 51) return "#";
    if (lowCharCode === 52) return "$";
    if (lowCharCode === 54) return "&";
    if (lowCharCode === 66) return "+";
    if (lowCharCode === 98) return "+";
    if (lowCharCode === 67) return ",";
    if (lowCharCode === 99) return ",";
    if (lowCharCode === 70) return "/";
    if (lowCharCode === 102) return "/";
    return null;
  }
  if (highCharCode === 51) {
    if (lowCharCode === 65) return ":";
    if (lowCharCode === 97) return ":";
    if (lowCharCode === 66) return ";";
    if (lowCharCode === 98) return ";";
    if (lowCharCode === 68) return "=";
    if (lowCharCode === 100) return "=";
    if (lowCharCode === 70) return "?";
    if (lowCharCode === 102) return "?";
    return null;
  }
  if (highCharCode === 52 && lowCharCode === 48) {
    return "@";
  }
  return null;
}
function safeDecodeURI$1(path2, useSemicolonDelimiter) {
  let shouldDecode = false;
  let shouldDecodeParam = false;
  let querystring2 = "";
  for (let i = 1; i < path2.length; i++) {
    const charCode = path2.charCodeAt(i);
    if (charCode === 37) {
      const highCharCode = path2.charCodeAt(i + 1);
      const lowCharCode = path2.charCodeAt(i + 2);
      if (decodeComponentChar(highCharCode, lowCharCode) === null) {
        shouldDecode = true;
      } else {
        shouldDecodeParam = true;
        if (highCharCode === 50 && lowCharCode === 53) {
          shouldDecode = true;
          path2 = path2.slice(0, i + 1) + "25" + path2.slice(i + 1);
          i += 2;
        }
        i += 2;
      }
    } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
      querystring2 = path2.slice(i + 1);
      path2 = path2.slice(0, i);
      break;
    }
  }
  const decodedPath = shouldDecode ? decodeURI(path2) : path2;
  return { path: decodedPath, querystring: querystring2, shouldDecodeParam };
}
function safeDecodeURIComponent$1(uriComponent) {
  const startIndex = uriComponent.indexOf("%");
  if (startIndex === -1) return uriComponent;
  let decoded = "";
  let lastIndex = startIndex;
  for (let i = startIndex; i < uriComponent.length; i++) {
    if (uriComponent.charCodeAt(i) === 37) {
      const highCharCode = uriComponent.charCodeAt(i + 1);
      const lowCharCode = uriComponent.charCodeAt(i + 2);
      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
      decoded += uriComponent.slice(lastIndex, i) + decodedChar;
      lastIndex = i + 3;
    }
  }
  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
}
var urlSanitizer = { safeDecodeURI: safeDecodeURI$1, safeDecodeURIComponent: safeDecodeURIComponent$1 };
const assert$2 = require$$0$9;
const querystring = libExports;
const isRegexSafe = safeRegex2Exports;
const deepEqual = fastDeepEqual;
const { prettyPrintTree } = prettyPrint;
const { StaticNode: StaticNode2, NODE_TYPES } = node$1;
const Constrainer2 = constrainer;
const httpMethods = httpMethods_1;
const httpMethodStrategy = httpMethod;
const { safeDecodeURI, safeDecodeURIComponent } = urlSanitizer;
const FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
const OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
const ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
const REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;
if (!isRegexSafe(FULL_PATH_REGEXP)) {
  throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
}
if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
  throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
}
if (!isRegexSafe(ESCAPE_REGEXP)) {
  throw new Error("the ESCAPE_REGEXP is not safe, update this module");
}
if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
  throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
}
function Router(opts) {
  if (!(this instanceof Router)) {
    return new Router(opts);
  }
  opts = opts || {};
  this._opts = opts;
  if (opts.defaultRoute) {
    assert$2(typeof opts.defaultRoute === "function", "The default route must be a function");
    this.defaultRoute = opts.defaultRoute;
  } else {
    this.defaultRoute = null;
  }
  if (opts.onBadUrl) {
    assert$2(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
    this.onBadUrl = opts.onBadUrl;
  } else {
    this.onBadUrl = null;
  }
  if (opts.buildPrettyMeta) {
    assert$2(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
    this.buildPrettyMeta = opts.buildPrettyMeta;
  } else {
    this.buildPrettyMeta = defaultBuildPrettyMeta$1;
  }
  if (opts.querystringParser) {
    assert$2(typeof opts.querystringParser === "function", "querystringParser must be a function");
    this.querystringParser = opts.querystringParser;
  } else {
    this.querystringParser = (query) => query.length === 0 ? {} : querystring.parse(query);
  }
  this.caseSensitive = opts.caseSensitive === void 0 ? true : opts.caseSensitive;
  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
  this.maxParamLength = opts.maxParamLength || 100;
  this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
  this.constrainer = new Constrainer2(opts.constraints);
  this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
  this.routes = [];
  this.trees = {};
}
Router.prototype.on = function on(method, path2, opts, handler, store) {
  if (typeof opts === "function") {
    if (handler !== void 0) {
      store = handler;
    }
    handler = opts;
    opts = {};
  }
  assert$2(typeof path2 === "string", "Path should be a string");
  assert$2(path2.length > 0, "The path could not be empty");
  assert$2(path2[0] === "/" || path2[0] === "*", "The first character of a path should be `/` or `*`");
  assert$2(typeof handler === "function", "Handler should be a function");
  const optionalParamMatch = path2.match(OPTIONAL_PARAM_REGEXP);
  if (optionalParamMatch) {
    assert$2(path2.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
    const pathFull = path2.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
    const pathOptional = path2.replace(OPTIONAL_PARAM_REGEXP, "$2") || "/";
    this.on(method, pathFull, opts, handler, store);
    this.on(method, pathOptional, opts, handler, store);
    return;
  }
  const route2 = path2;
  if (this.ignoreDuplicateSlashes) {
    path2 = removeDuplicateSlashes(path2);
  }
  if (this.ignoreTrailingSlash) {
    path2 = trimLastSlash(path2);
  }
  const methods2 = Array.isArray(method) ? method : [method];
  for (const method2 of methods2) {
    assert$2(typeof method2 === "string", "Method should be a string");
    assert$2(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
    this._on(method2, path2, opts, handler, store, route2);
  }
};
Router.prototype._on = function _on(method, path2, opts, handler, store) {
  let constraints = {};
  if (opts.constraints !== void 0) {
    assert$2(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
    if (Object.keys(opts.constraints).length !== 0) {
      constraints = opts.constraints;
    }
  }
  this.constrainer.validateConstraints(constraints);
  this.constrainer.noteUsage(constraints);
  if (this.trees[method] === void 0) {
    this.trees[method] = new StaticNode2("/");
  }
  let pattern2 = path2;
  if (pattern2 === "*" && this.trees[method].prefix.length !== 0) {
    const currentRoot = this.trees[method];
    this.trees[method] = new StaticNode2("");
    this.trees[method].staticChildren["/"] = currentRoot;
  }
  let currentNode = this.trees[method];
  let parentNodePathIndex = currentNode.prefix.length;
  const params = [];
  for (let i = 0; i <= pattern2.length; i++) {
    if (pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) === 58) {
      i++;
      continue;
    }
    const isParametricNode = pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) !== 58;
    const isWildcardNode = pattern2.charCodeAt(i) === 42;
    if (isParametricNode || isWildcardNode || i === pattern2.length && i !== parentNodePathIndex) {
      let staticNodePath = pattern2.slice(parentNodePathIndex, i);
      if (!this.caseSensitive) {
        staticNodePath = staticNodePath.toLowerCase();
      }
      staticNodePath = staticNodePath.replaceAll("::", ":");
      staticNodePath = staticNodePath.replaceAll("%", "%25");
      currentNode = currentNode.createStaticChild(staticNodePath);
    }
    if (isParametricNode) {
      let isRegexNode = false;
      let isParamSafe = true;
      let backtrack = "";
      const regexps = [];
      let lastParamStartIndex = i + 1;
      for (let j = lastParamStartIndex; ; j++) {
        const charCode = pattern2.charCodeAt(j);
        const isRegexParam = charCode === 40;
        const isStaticPart = charCode === 45 || charCode === 46;
        const isEndOfNode = charCode === 47 || j === pattern2.length;
        if (isRegexParam || isStaticPart || isEndOfNode) {
          const paramName = pattern2.slice(lastParamStartIndex, j);
          params.push(paramName);
          isRegexNode = isRegexNode || isRegexParam || isStaticPart;
          if (isRegexParam) {
            const endOfRegexIndex = getClosingParenthensePosition(pattern2, j);
            const regexString = pattern2.slice(j, endOfRegexIndex + 1);
            if (!this.allowUnsafeRegex) {
              assert$2(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
            }
            regexps.push(trimRegExpStartAndEnd(regexString));
            j = endOfRegexIndex + 1;
            isParamSafe = true;
          } else {
            regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
            isParamSafe = false;
          }
          const staticPartStartIndex = j;
          for (; j < pattern2.length; j++) {
            const charCode2 = pattern2.charCodeAt(j);
            if (charCode2 === 47) break;
            if (charCode2 === 58) {
              const nextCharCode = pattern2.charCodeAt(j + 1);
              if (nextCharCode === 58) j++;
              else break;
            }
          }
          let staticPart = pattern2.slice(staticPartStartIndex, j);
          if (staticPart) {
            staticPart = staticPart.replaceAll("::", ":");
            staticPart = staticPart.replaceAll("%", "%25");
            regexps.push(backtrack = escapeRegExp$2(staticPart));
          }
          lastParamStartIndex = j + 1;
          if (isEndOfNode || pattern2.charCodeAt(j) === 47 || j === pattern2.length) {
            const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
            const nodePath = pattern2.slice(i, j);
            pattern2 = pattern2.slice(0, i + 1) + nodePattern + pattern2.slice(j);
            i += nodePattern.length;
            const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
            currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
            parentNodePathIndex = i + 1;
            break;
          }
        }
      }
    } else if (isWildcardNode) {
      params.push("*");
      currentNode = currentNode.createWildcardChild();
      parentNodePathIndex = i + 1;
      if (i !== pattern2.length - 1) {
        throw new Error("Wildcard must be the last character in the route");
      }
    }
  }
  if (!this.caseSensitive) {
    pattern2 = pattern2.toLowerCase();
  }
  if (pattern2 === "*") {
    pattern2 = "/*";
  }
  for (const existRoute of this.routes) {
    const routeConstraints = existRoute.opts.constraints || {};
    if (existRoute.method === method && existRoute.pattern === pattern2 && deepEqual(routeConstraints, constraints)) {
      throw new Error(`Method '${method}' already declared for route '${pattern2}' with constraints '${JSON.stringify(constraints)}'`);
    }
  }
  const route2 = { method, path: path2, pattern: pattern2, params, opts, handler, store };
  this.routes.push(route2);
  currentNode.addRoute(route2, this.constrainer);
};
Router.prototype.hasRoute = function hasRoute(method, path2, constraints) {
  const route2 = this.findRoute(method, path2, constraints);
  return route2 !== null;
};
Router.prototype.findRoute = function findNode(method, path2, constraints = {}) {
  if (this.trees[method] === void 0) {
    return null;
  }
  let pattern2 = path2;
  let currentNode = this.trees[method];
  let parentNodePathIndex = currentNode.prefix.length;
  for (let i = 0; i <= pattern2.length; i++) {
    if (pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) === 58) {
      i++;
      continue;
    }
    const isParametricNode = pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) !== 58;
    const isWildcardNode = pattern2.charCodeAt(i) === 42;
    if (isParametricNode || isWildcardNode || i === pattern2.length && i !== parentNodePathIndex) {
      let staticNodePath = pattern2.slice(parentNodePathIndex, i);
      if (!this.caseSensitive) {
        staticNodePath = staticNodePath.toLowerCase();
      }
      staticNodePath = staticNodePath.replaceAll("::", ":");
      staticNodePath = staticNodePath.replaceAll("%", "%25");
      currentNode = currentNode.getStaticChild(staticNodePath);
      if (currentNode === null) {
        return null;
      }
    }
    if (isParametricNode) {
      let isRegexNode = false;
      let isParamSafe = true;
      let backtrack = "";
      const regexps = [];
      let lastParamStartIndex = i + 1;
      for (let j = lastParamStartIndex; ; j++) {
        const charCode = pattern2.charCodeAt(j);
        const isRegexParam = charCode === 40;
        const isStaticPart = charCode === 45 || charCode === 46;
        const isEndOfNode = charCode === 47 || j === pattern2.length;
        if (isRegexParam || isStaticPart || isEndOfNode) {
          pattern2.slice(lastParamStartIndex, j);
          isRegexNode = isRegexNode || isRegexParam || isStaticPart;
          if (isRegexParam) {
            const endOfRegexIndex = getClosingParenthensePosition(pattern2, j);
            const regexString = pattern2.slice(j, endOfRegexIndex + 1);
            if (!this.allowUnsafeRegex) {
              assert$2(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
            }
            regexps.push(trimRegExpStartAndEnd(regexString));
            j = endOfRegexIndex + 1;
            isParamSafe = false;
          } else {
            regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
            isParamSafe = false;
          }
          const staticPartStartIndex = j;
          for (; j < pattern2.length; j++) {
            const charCode2 = pattern2.charCodeAt(j);
            if (charCode2 === 47) break;
            if (charCode2 === 58) {
              const nextCharCode = pattern2.charCodeAt(j + 1);
              if (nextCharCode === 58) j++;
              else break;
            }
          }
          let staticPart = pattern2.slice(staticPartStartIndex, j);
          if (staticPart) {
            staticPart = staticPart.replaceAll("::", ":");
            staticPart = staticPart.replaceAll("%", "%25");
            regexps.push(backtrack = escapeRegExp$2(staticPart));
          }
          lastParamStartIndex = j + 1;
          if (isEndOfNode || pattern2.charCodeAt(j) === 47 || j === pattern2.length) {
            const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
            const nodePath = pattern2.slice(i, j);
            pattern2 = pattern2.slice(0, i + 1) + nodePattern + pattern2.slice(j);
            i += nodePattern.length;
            const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
            currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
            if (currentNode === null) {
              return null;
            }
            parentNodePathIndex = i + 1;
            break;
          }
        }
      }
    } else if (isWildcardNode) {
      currentNode = currentNode.getWildcardChild();
      parentNodePathIndex = i + 1;
      if (i !== pattern2.length - 1) {
        throw new Error("Wildcard must be the last character in the route");
      }
    }
  }
  if (!this.caseSensitive) {
    pattern2 = pattern2.toLowerCase();
  }
  for (const existRoute of this.routes) {
    const routeConstraints = existRoute.opts.constraints || {};
    if (existRoute.method === method && existRoute.pattern === pattern2 && deepEqual(routeConstraints, constraints)) {
      return {
        handler: existRoute.handler,
        store: existRoute.store,
        params: existRoute.params
      };
    }
  }
  return null;
};
Router.prototype.hasConstraintStrategy = function(strategyName) {
  return this.constrainer.hasConstraintStrategy(strategyName);
};
Router.prototype.addConstraintStrategy = function(constraints) {
  this.constrainer.addConstraintStrategy(constraints);
  this._rebuild(this.routes);
};
Router.prototype.reset = function reset() {
  this.trees = {};
  this.routes = [];
};
Router.prototype.off = function off(method, path2, constraints) {
  assert$2(typeof path2 === "string", "Path should be a string");
  assert$2(path2.length > 0, "The path could not be empty");
  assert$2(path2[0] === "/" || path2[0] === "*", "The first character of a path should be `/` or `*`");
  assert$2(
    typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null,
    "Constraints should be an object or undefined."
  );
  const optionalParamMatch = path2.match(OPTIONAL_PARAM_REGEXP);
  if (optionalParamMatch) {
    assert$2(path2.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
    const pathFull = path2.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
    const pathOptional = path2.replace(OPTIONAL_PARAM_REGEXP, "$2");
    this.off(method, pathFull, constraints);
    this.off(method, pathOptional, constraints);
    return;
  }
  if (this.ignoreDuplicateSlashes) {
    path2 = removeDuplicateSlashes(path2);
  }
  if (this.ignoreTrailingSlash) {
    path2 = trimLastSlash(path2);
  }
  const methods2 = Array.isArray(method) ? method : [method];
  for (const method2 of methods2) {
    this._off(method2, path2, constraints);
  }
};
Router.prototype._off = function _off(method, path2, constraints) {
  assert$2(typeof method === "string", "Method should be a string");
  assert$2(httpMethods.includes(method), `Method '${method}' is not an http method.`);
  function matcherWithoutConstraints(route2) {
    return method !== route2.method || path2 !== route2.path;
  }
  function matcherWithConstraints(route2) {
    return matcherWithoutConstraints(route2) || !deepEqual(constraints, route2.opts.constraints || {});
  }
  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
  const newRoutes = this.routes.filter(predicate);
  this._rebuild(newRoutes);
};
Router.prototype.lookup = function lookup(req2, res2, ctx, done) {
  if (typeof ctx === "function") {
    done = ctx;
    ctx = void 0;
  }
  if (done === void 0) {
    const constraints = this.constrainer.deriveConstraints(req2, ctx);
    const handle = this.find(req2.method, req2.url, constraints);
    return this.callHandler(handle, req2, res2, ctx);
  }
  this.constrainer.deriveConstraints(req2, ctx, (err2, constraints) => {
    if (err2 !== null) {
      done(err2);
      return;
    }
    try {
      const handle = this.find(req2.method, req2.url, constraints);
      const result = this.callHandler(handle, req2, res2, ctx);
      done(null, result);
    } catch (err3) {
      done(err3);
    }
  });
};
Router.prototype.callHandler = function callHandler(handle, req2, res2, ctx) {
  if (handle === null) return this._defaultRoute(req2, res2, ctx);
  return ctx === void 0 ? handle.handler(req2, res2, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req2, res2, handle.params, handle.store, handle.searchParams);
};
Router.prototype.find = function find2(method, path2, derivedConstraints) {
  let currentNode = this.trees[method];
  if (currentNode === void 0) return null;
  if (path2.charCodeAt(0) !== 47) {
    path2 = path2.replace(FULL_PATH_REGEXP, "/");
  }
  if (this.ignoreDuplicateSlashes) {
    path2 = removeDuplicateSlashes(path2);
  }
  let sanitizedUrl;
  let querystring2;
  let shouldDecodeParam;
  try {
    sanitizedUrl = safeDecodeURI(path2, this.useSemicolonDelimiter);
    path2 = sanitizedUrl.path;
    querystring2 = sanitizedUrl.querystring;
    shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
  } catch (error2) {
    return this._onBadUrl(path2);
  }
  if (this.ignoreTrailingSlash) {
    path2 = trimLastSlash(path2);
  }
  const originPath = path2;
  if (this.caseSensitive === false) {
    path2 = path2.toLowerCase();
  }
  const maxParamLength = this.maxParamLength;
  let pathIndex = currentNode.prefix.length;
  const params = [];
  const pathLen = path2.length;
  const brothersNodesStack = [];
  while (true) {
    if (pathIndex === pathLen && currentNode.isLeafNode) {
      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
      if (handle !== null) {
        return {
          handler: handle.handler,
          store: handle.store,
          params: handle._createParamsObject(params),
          searchParams: this.querystringParser(querystring2)
        };
      }
    }
    let node2 = currentNode.getNextNode(path2, pathIndex, brothersNodesStack, params.length);
    if (node2 === null) {
      if (brothersNodesStack.length === 0) {
        return null;
      }
      const brotherNodeState = brothersNodesStack.pop();
      pathIndex = brotherNodeState.brotherPathIndex;
      params.splice(brotherNodeState.paramsCount);
      node2 = brotherNodeState.brotherNode;
    }
    currentNode = node2;
    if (currentNode.kind === NODE_TYPES.STATIC) {
      pathIndex += currentNode.prefix.length;
      continue;
    }
    if (currentNode.kind === NODE_TYPES.WILDCARD) {
      let param2 = originPath.slice(pathIndex);
      if (shouldDecodeParam) {
        param2 = safeDecodeURIComponent(param2);
      }
      params.push(param2);
      pathIndex = pathLen;
      continue;
    }
    let paramEndIndex = originPath.indexOf("/", pathIndex);
    if (paramEndIndex === -1) {
      paramEndIndex = pathLen;
    }
    let param = originPath.slice(pathIndex, paramEndIndex);
    if (shouldDecodeParam) {
      param = safeDecodeURIComponent(param);
    }
    if (currentNode.isRegex) {
      const matchedParameters = currentNode.regex.exec(param);
      if (matchedParameters === null) continue;
      for (let i = 1; i < matchedParameters.length; i++) {
        const matchedParam = matchedParameters[i];
        if (matchedParam.length > maxParamLength) {
          return null;
        }
        params.push(matchedParam);
      }
    } else {
      if (param.length > maxParamLength) {
        return null;
      }
      params.push(param);
    }
    pathIndex = paramEndIndex;
  }
};
Router.prototype._rebuild = function(routes) {
  this.reset();
  for (const route2 of routes) {
    const { method, path: path2, opts, handler, store } = route2;
    this._on(method, path2, opts, handler, store);
  }
};
Router.prototype._defaultRoute = function(req2, res2, ctx) {
  if (this.defaultRoute !== null) {
    return ctx === void 0 ? this.defaultRoute(req2, res2) : this.defaultRoute.call(ctx, req2, res2);
  } else {
    res2.statusCode = 404;
    res2.end();
  }
};
Router.prototype._onBadUrl = function(path2) {
  if (this.onBadUrl === null) {
    return null;
  }
  const onBadUrl = this.onBadUrl;
  return {
    handler: (req2, res2, ctx) => onBadUrl(path2, req2, res2),
    params: {},
    store: null
  };
};
Router.prototype.prettyPrint = function(options = {}) {
  const method = options.method;
  options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
  let tree = null;
  if (method === void 0) {
    const { version: version2, host, ...constraints } = this.constrainer.strategies;
    constraints[httpMethodStrategy.name] = httpMethodStrategy;
    const mergedRouter = new Router({ ...this._opts, constraints });
    const mergedRoutes = this.routes.map((route2) => {
      const constraints2 = {
        ...route2.opts.constraints,
        [httpMethodStrategy.name]: route2.method
      };
      return { ...route2, method: "MERGED", opts: { constraints: constraints2 } };
    });
    mergedRouter._rebuild(mergedRoutes);
    tree = mergedRouter.trees.MERGED;
  } else {
    tree = this.trees[method];
  }
  if (tree == null) return "(empty tree)";
  return prettyPrintTree(tree, options);
};
for (const i in httpMethods) {
  if (!httpMethods.hasOwnProperty(i)) continue;
  const m = httpMethods[i];
  const methodName = m.toLowerCase();
  Router.prototype[methodName] = function(path2, handler, store) {
    return this.on(m, path2, handler, store);
  };
}
Router.prototype.all = function(path2, handler, store) {
  this.on(httpMethods, path2, handler, store);
};
var findMyWay = Router;
function escapeRegExp$2(string) {
  return string.replace(ESCAPE_REGEXP, "\\$&");
}
function removeDuplicateSlashes(path2) {
  return path2.indexOf("//") !== -1 ? path2.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, "/") : path2;
}
function trimLastSlash(path2) {
  if (path2.length > 1 && path2.charCodeAt(path2.length - 1) === 47) {
    return path2.slice(0, -1);
  }
  return path2;
}
function trimRegExpStartAndEnd(regexString) {
  if (regexString.charCodeAt(1) === 94) {
    regexString = regexString.slice(0, 1) + regexString.slice(2);
  }
  if (regexString.charCodeAt(regexString.length - 2) === 36) {
    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
  }
  return regexString;
}
function getClosingParenthensePosition(path2, idx) {
  let parentheses = 1;
  while (idx < path2.length) {
    idx++;
    if (path2.charCodeAt(idx) === 92) {
      idx++;
      continue;
    }
    if (path2.charCodeAt(idx) === 41) {
      parentheses--;
    } else if (path2.charCodeAt(idx) === 40) {
      parentheses++;
    }
    if (!parentheses) return idx;
  }
  throw new TypeError('Invalid regexp expression in "' + path2 + '"');
}
function defaultBuildPrettyMeta$1(route2) {
  if (!route2) return {};
  if (!route2.store) return {};
  return Object.assign({}, route2.store);
}
function headRouteOnSendHandler(req2, reply2, payload, done) {
  if (payload === void 0) {
    reply2.header("content-length", "0");
    done(null, null);
    return;
  }
  if (typeof payload.resume === "function") {
    payload.on("error", (err2) => {
      reply2.log.error({ err: err2 }, "Error on Stream found for HEAD route");
    });
    payload.resume();
    done(null, null);
    return;
  }
  const size = "" + Buffer.byteLength(payload);
  reply2.header("content-length", size);
  done(null, null);
}
function parseHeadOnSendHandlers$1(onSendHandlers) {
  if (onSendHandlers == null) return headRouteOnSendHandler;
  return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
}
var headRoute = {
  parseHeadOnSendHandlers: parseHeadOnSendHandlers$1
};
const FindMyWay$1 = findMyWay;
const Context$2 = context;
const handleRequest = handleRequestExports;
const { onRequestAbortHookRunner, lifecycleHooks: lifecycleHooks$1, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = hooks;
const { normalizeSchema } = schemas;
const { parseHeadOnSendHandlers } = headRoute;
const {
  compileSchemasForValidation,
  compileSchemasForSerialization
} = validation$2;
const {
  FST_ERR_SCH_VALIDATION_BUILD,
  FST_ERR_SCH_SERIALIZATION_BUILD,
  FST_ERR_DUPLICATED_ROUTE,
  FST_ERR_INVALID_URL,
  FST_ERR_HOOK_INVALID_HANDLER,
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
  FST_ERR_ROUTE_DUPLICATED_HANDLER,
  FST_ERR_ROUTE_HANDLER_NOT_FN,
  FST_ERR_ROUTE_MISSING_HANDLER,
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
  FST_ERR_ROUTE_METHOD_INVALID: FST_ERR_ROUTE_METHOD_INVALID$1,
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER
} = errorsExports;
const {
  kRoutePrefix: kRoutePrefix$3,
  kSupportedHTTPMethods: kSupportedHTTPMethods$1,
  kLogLevel: kLogLevel$2,
  kLogSerializers: kLogSerializers$2,
  kHooks: kHooks$3,
  kSchemaController: kSchemaController$2,
  kOptions: kOptions$1,
  kReplySerializerDefault: kReplySerializerDefault$1,
  kReplyIsError,
  kRequestPayloadStream,
  kDisableRequestLogging,
  kSchemaErrorFormatter: kSchemaErrorFormatter$1,
  kErrorHandler: kErrorHandler$2,
  kHasBeenDecorated,
  kRequestAcceptVersion: kRequestAcceptVersion$1,
  kRouteByFastify,
  kRouteContext
} = symbols$1;
const { buildErrorHandler: buildErrorHandler$2 } = errorHandler;
const { createChildLogger: createChildLogger$2 } = loggerFactory;
const { getGenReqId: getGenReqId$2 } = reqIdGenFactory_1;
function buildRouting$1(options) {
  const router = FindMyWay$1(options.config);
  let avvio;
  let fourOhFour2;
  let logger;
  let hasLogger;
  let setupResponseListeners2;
  let throwIfAlreadyStarted;
  let disableRequestLogging;
  let ignoreTrailingSlash;
  let ignoreDuplicateSlashes;
  let return503OnClosing;
  let globalExposeHeadRoutes;
  let keepAliveConnections;
  let closing = false;
  return {
    /**
     * @param {import('../fastify').FastifyServerOptions} options
     * @param {*} fastifyArgs
     */
    setup(options2, fastifyArgs) {
      avvio = fastifyArgs.avvio;
      fourOhFour2 = fastifyArgs.fourOhFour;
      logger = fastifyArgs.logger;
      hasLogger = fastifyArgs.hasLogger;
      setupResponseListeners2 = fastifyArgs.setupResponseListeners;
      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
      globalExposeHeadRoutes = options2.exposeHeadRoutes;
      disableRequestLogging = options2.disableRequestLogging;
      ignoreTrailingSlash = options2.ignoreTrailingSlash;
      ignoreDuplicateSlashes = options2.ignoreDuplicateSlashes;
      return503OnClosing = Object.hasOwn(options2, "return503OnClosing") ? options2.return503OnClosing : true;
      keepAliveConnections = fastifyArgs.keepAliveConnections;
    },
    routing: router.lookup.bind(router),
    // router func to find the right handler to call
    route: route2,
    // configure a route in the fastify instance
    hasRoute: hasRoute2,
    prepareRoute,
    routeHandler,
    closeRoutes: () => {
      closing = true;
    },
    printRoutes: router.prettyPrint.bind(router),
    addConstraintStrategy,
    hasConstraintStrategy,
    isAsyncConstraint,
    findRoute
  };
  function addConstraintStrategy(strategy) {
    throwIfAlreadyStarted("Cannot add constraint strategy!");
    return router.addConstraintStrategy(strategy);
  }
  function hasConstraintStrategy(strategyName) {
    return router.hasConstraintStrategy(strategyName);
  }
  function isAsyncConstraint() {
    return router.constrainer.asyncStrategiesInUse.size > 0;
  }
  function prepareRoute({ method, url: url2, options: options2, handler, isFastify }) {
    if (typeof url2 !== "string") {
      throw new FST_ERR_INVALID_URL(typeof url2);
    }
    if (!handler && typeof options2 === "function") {
      handler = options2;
      options2 = {};
    } else if (handler && typeof handler === "function") {
      if (Object.prototype.toString.call(options2) !== "[object Object]") {
        throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url2);
      } else if (options2.handler) {
        if (typeof options2.handler === "function") {
          throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url2);
        } else {
          throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url2);
        }
      }
    }
    options2 = Object.assign({}, options2, {
      method,
      url: url2,
      path: url2,
      handler: handler || options2 && options2.handler
    });
    return route2.call(this, { options: options2, isFastify });
  }
  function hasRoute2({ options: options2 }) {
    var _a2;
    const normalizedMethod = ((_a2 = options2.method) == null ? void 0 : _a2.toUpperCase()) ?? "";
    return router.hasRoute(
      normalizedMethod,
      options2.url || "",
      options2.constraints
    );
  }
  function findRoute(options2) {
    const route3 = router.find(
      options2.method,
      options2.url || "",
      options2.constraints
    );
    if (route3) {
      return {
        handler: route3.handler,
        params: route3.params,
        searchParams: route3.searchParams
      };
    } else {
      return null;
    }
  }
  function route2({ options: options2, isFastify }) {
    throwIfAlreadyStarted("Cannot add route!");
    const opts = { ...options2 };
    const path2 = opts.url || opts.path || "";
    if (!opts.handler) {
      throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path2);
    }
    if (opts.errorHandler !== void 0 && typeof opts.errorHandler !== "function") {
      throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path2);
    }
    validateBodyLimitOption$1(opts.bodyLimit);
    const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;
    let isGetRoute = false;
    let isHeadRoute = false;
    if (Array.isArray(opts.method)) {
      for (let i = 0; i < opts.method.length; ++i) {
        opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
        validateSchemaBodyOption.call(this, opts.method[i], path2, opts.schema);
        isGetRoute = opts.method.includes("GET");
        isHeadRoute = opts.method.includes("HEAD");
      }
    } else {
      opts.method = normalizeAndValidateMethod.call(this, opts.method);
      validateSchemaBodyOption.call(this, opts.method, path2, opts.schema);
      isGetRoute = opts.method === "GET";
      isHeadRoute = opts.method === "HEAD";
    }
    const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
    const prefix = this[kRoutePrefix$3];
    if (path2 === "/" && prefix.length > 0 && opts.method !== "HEAD") {
      switch (opts.prefixTrailingSlash) {
        case "slash":
          addNewRoute.call(this, { path: path2, isFastify });
          break;
        case "no-slash":
          addNewRoute.call(this, { path: "", isFastify });
          break;
        case "both":
        default:
          addNewRoute.call(this, { path: "", isFastify });
          if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
            addNewRoute.call(this, { path: path2, prefixing: true, isFastify });
          }
      }
    } else if (path2[0] === "/" && prefix.endsWith("/")) {
      addNewRoute.call(this, { path: path2.slice(1), isFastify });
    } else {
      addNewRoute.call(this, { path: path2, isFastify });
    }
    return this;
    function addNewRoute({ path: path3, prefixing = false, isFastify: isFastify2 = false }) {
      const url2 = prefix + path3;
      opts.url = url2;
      opts.path = url2;
      opts.routePath = path3;
      opts.prefix = prefix;
      opts.logLevel = opts.logLevel || this[kLogLevel$2];
      if (this[kLogSerializers$2] || opts.logSerializers) {
        opts.logSerializers = Object.assign(Object.create(this[kLogSerializers$2]), opts.logSerializers);
      }
      if (opts.attachValidation == null) {
        opts.attachValidation = false;
      }
      if (prefixing === false) {
        for (const hook of this[kHooks$3].onRoute) {
          hook.call(this, opts);
        }
      }
      for (const hook of lifecycleHooks$1) {
        if (opts && hook in opts) {
          if (Array.isArray(opts[hook])) {
            for (const func of opts[hook]) {
              if (typeof func !== "function") {
                throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
              }
              if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                }
              } else if (hook === "onRequestAbort") {
                if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                }
              } else {
                if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                }
              }
            }
          } else if (opts[hook] !== void 0 && typeof opts[hook] !== "function") {
            throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
          }
        }
      }
      const constraints = opts.constraints || {};
      const config2 = {
        ...opts.config,
        url: url2,
        method: opts.method
      };
      const context2 = new Context$2({
        schema: opts.schema,
        handler: opts.handler.bind(this),
        config: config2,
        errorHandler: opts.errorHandler,
        childLoggerFactory: opts.childLoggerFactory,
        bodyLimit: opts.bodyLimit,
        logLevel: opts.logLevel,
        logSerializers: opts.logSerializers,
        attachValidation: opts.attachValidation,
        schemaErrorFormatter: opts.schemaErrorFormatter,
        replySerializer: this[kReplySerializerDefault$1],
        validatorCompiler: opts.validatorCompiler,
        serializerCompiler: opts.serializerCompiler,
        exposeHeadRoute: shouldExposeHead,
        prefixTrailingSlash: opts.prefixTrailingSlash || "both",
        server: this,
        isFastify: isFastify2
      });
      const headHandler = router.findRoute("HEAD", opts.url, constraints);
      const hasHEADHandler = headHandler !== null;
      try {
        router.on(opts.method, opts.url, { constraints }, routeHandler, context2);
      } catch (error2) {
        if (!context2[kRouteByFastify]) {
          const isDuplicatedRoute = error2.message.includes(`Method '${opts.method}' already declared for route`);
          if (isDuplicatedRoute) {
            throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
          }
          throw error2;
        }
      }
      this.after((notHandledErr, done) => {
        context2.errorHandler = opts.errorHandler ? buildErrorHandler$2(this[kErrorHandler$2], opts.errorHandler) : this[kErrorHandler$2];
        context2._parserOptions.limit = opts.bodyLimit || null;
        context2.logLevel = opts.logLevel;
        context2.logSerializers = opts.logSerializers;
        context2.attachValidation = opts.attachValidation;
        context2[kReplySerializerDefault$1] = this[kReplySerializerDefault$1];
        context2.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter$1] || context2.schemaErrorFormatter;
        avvio.once("preReady", () => {
          for (const hook of lifecycleHooks$1) {
            const toSet = this[kHooks$3][hook].concat(opts[hook] || []).map((h) => h.bind(this));
            context2[hook] = toSet.length ? toSet : null;
          }
          while (!context2.Request[kHasBeenDecorated] && context2.Request.parent) {
            context2.Request = context2.Request.parent;
          }
          while (!context2.Reply[kHasBeenDecorated] && context2.Reply.parent) {
            context2.Reply = context2.Reply.parent;
          }
          fourOhFour2.setContext(this, context2);
          if (opts.schema) {
            context2.schema = normalizeSchema(context2.schema, this.initialConfig);
            const schemaController2 = this[kSchemaController$2];
            if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
              schemaController2.setupValidator(this[kOptions$1]);
            }
            try {
              const isCustom = typeof (opts == null ? void 0 : opts.validatorCompiler) === "function" || schemaController2.isCustomValidatorCompiler;
              compileSchemasForValidation(context2, opts.validatorCompiler || schemaController2.validatorCompiler, isCustom);
            } catch (error2) {
              throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url2, error2.message);
            }
            if (opts.schema.response && !opts.serializerCompiler) {
              schemaController2.setupSerializer(this[kOptions$1]);
            }
            try {
              compileSchemasForSerialization(context2, opts.serializerCompiler || schemaController2.serializerCompiler);
            } catch (error2) {
              throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url2, error2.message);
            }
          }
        });
        done(notHandledErr);
      });
      if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
        const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
        prepareRoute.call(this, { method: "HEAD", url: path3, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
      }
    }
  }
  function routeHandler(req2, res2, params, context2, query) {
    const id2 = getGenReqId$2(context2.server, req2);
    const loggerOpts = {
      level: context2.logLevel
    };
    if (context2.logSerializers) {
      loggerOpts.serializers = context2.logSerializers;
    }
    const childLogger = createChildLogger$2(context2, logger, req2, id2, loggerOpts);
    childLogger[kDisableRequestLogging] = disableRequestLogging;
    if (closing === true) {
      if (req2.httpVersionMajor !== 2) {
        res2.setHeader("Connection", "close");
      }
      if (return503OnClosing) {
        const headers2 = {
          "Content-Type": "application/json",
          "Content-Length": "80"
        };
        res2.writeHead(503, headers2);
        res2.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
        childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
        return;
      }
    }
    const connHeader = String.prototype.toLowerCase.call(req2.headers.connection || "");
    if (connHeader === "keep-alive") {
      if (keepAliveConnections.has(req2.socket) === false) {
        keepAliveConnections.add(req2.socket);
        req2.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req2.socket }));
      }
    }
    if (req2.headers[kRequestAcceptVersion$1] !== void 0) {
      req2.headers["accept-version"] = req2.headers[kRequestAcceptVersion$1];
      req2.headers[kRequestAcceptVersion$1] = void 0;
    }
    const request2 = new context2.Request(id2, params, req2, query, childLogger, context2);
    const reply2 = new context2.Reply(res2, request2, childLogger);
    if (disableRequestLogging === false) {
      childLogger.info({ req: request2 }, "incoming request");
    }
    if (hasLogger === true || context2.onResponse !== null) {
      setupResponseListeners2(reply2);
    }
    if (context2.onRequest !== null) {
      onRequestHookRunner(
        context2.onRequest,
        request2,
        reply2,
        runPreParsing
      );
    } else {
      runPreParsing(null, request2, reply2);
    }
    if (context2.onRequestAbort !== null) {
      req2.on("close", () => {
        if (req2.aborted) {
          onRequestAbortHookRunner(
            context2.onRequestAbort,
            request2,
            handleOnRequestAbortHooksErrors.bind(null, reply2)
          );
        }
      });
    }
    if (context2.onTimeout !== null) {
      if (!request2.raw.socket._meta) {
        request2.raw.socket.on("timeout", handleTimeout);
      }
      request2.raw.socket._meta = { context: context2, request: request2, reply: reply2 };
    }
  }
}
function handleOnRequestAbortHooksErrors(reply2, err2) {
  if (err2) {
    reply2.log.error({ err: err2 }, "onRequestAborted hook failed");
  }
}
function handleTimeout() {
  const { context: context2, request: request2, reply: reply2 } = this._meta;
  onTimeoutHookRunner(
    context2.onTimeout,
    request2,
    reply2,
    noop$3
  );
}
function normalizeAndValidateMethod(method) {
  if (typeof method !== "string") {
    throw new FST_ERR_ROUTE_METHOD_INVALID$1();
  }
  method = method.toUpperCase();
  if (!this[kSupportedHTTPMethods$1].bodyless.has(method) && !this[kSupportedHTTPMethods$1].bodywith.has(method)) {
    throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
  }
  return method;
}
function validateSchemaBodyOption(method, path2, schema2) {
  if (this[kSupportedHTTPMethods$1].bodyless.has(method) && (schema2 == null ? void 0 : schema2.body)) {
    throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path2);
  }
}
function validateBodyLimitOption$1(bodyLimit) {
  if (bodyLimit === void 0) return;
  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
    throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
  }
}
function runPreParsing(err2, request2, reply2) {
  if (reply2.sent === true) return;
  if (err2 != null) {
    reply2[kReplyIsError] = true;
    reply2.send(err2);
    return;
  }
  request2[kRequestPayloadStream] = request2.raw;
  if (request2[kRouteContext].preParsing !== null) {
    preParsingHookRunner(request2[kRouteContext].preParsing, request2, reply2, handleRequest.bind(request2.server));
  } else {
    handleRequest.call(request2.server, null, request2, reply2);
  }
}
function removeTrackedSocket() {
  this.keepAliveConnections.delete(this.socket);
}
function noop$3() {
}
var route = { buildRouting: buildRouting$1, validateBodyLimitOption: validateBodyLimitOption$1 };
const FindMyWay = findMyWay;
const Reply$2 = replyExports;
const Request$3 = requestExports;
const Context$1 = context;
const {
  kRoutePrefix: kRoutePrefix$2,
  kCanSetNotFoundHandler,
  kFourOhFourLevelInstance,
  kFourOhFourContext,
  kHooks: kHooks$2,
  kErrorHandler: kErrorHandler$1
} = symbols$1;
const { lifecycleHooks } = hooks;
const { buildErrorHandler: buildErrorHandler$1 } = errorHandler;
const {
  FST_ERR_NOT_FOUND
} = errorsExports;
const { createChildLogger: createChildLogger$1 } = loggerFactory;
const { getGenReqId: getGenReqId$1 } = reqIdGenFactory_1;
function fourOhFour(options) {
  const { logger, disableRequestLogging } = options;
  const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
  let _onBadUrlHandler = null;
  return { router, setNotFoundHandler, setContext, arrange404 };
  function arrange404(instance) {
    instance[kFourOhFourLevelInstance] = instance;
    instance[kCanSetNotFoundHandler] = true;
    router.onBadUrl = router.onBadUrl.bind(instance);
    router.defaultRoute = router.defaultRoute.bind(instance);
  }
  function basic404(request2, reply2) {
    const { url: url2, method } = request2.raw;
    const message = `Route ${method}:${url2} not found`;
    if (!disableRequestLogging) {
      request2.log.info(message);
    }
    reply2.code(404).send({
      message,
      error: "Not Found",
      statusCode: 404
    });
  }
  function createOnBadUrl() {
    return function onBadUrl(path2, req2, res2) {
      const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
      const id2 = getGenReqId$1(fourOhFourContext.server, req2);
      const childLogger = createChildLogger$1(fourOhFourContext, logger, req2, id2);
      const request2 = new Request$3(id2, null, req2, null, childLogger, fourOhFourContext);
      const reply2 = new Reply$2(res2, request2, childLogger);
      _onBadUrlHandler(request2, reply2);
    };
  }
  function setContext(instance, context2) {
    const _404Context = Object.assign({}, instance[kFourOhFourContext]);
    _404Context.onSend = context2.onSend;
    context2[kFourOhFourContext] = _404Context;
  }
  function setNotFoundHandler(opts, handler, avvio, routeHandler) {
    if (this[kCanSetNotFoundHandler] === void 0) {
      this[kCanSetNotFoundHandler] = true;
    }
    if (this[kFourOhFourContext] === void 0) {
      this[kFourOhFourContext] = null;
    }
    const _fastify = this;
    const prefix = this[kRoutePrefix$2] || "/";
    if (this[kCanSetNotFoundHandler] === false) {
      throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
    }
    if (typeof opts === "object") {
      if (opts.preHandler) {
        if (Array.isArray(opts.preHandler)) {
          opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
        } else {
          opts.preHandler = opts.preHandler.bind(_fastify);
        }
      }
      if (opts.preValidation) {
        if (Array.isArray(opts.preValidation)) {
          opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
        } else {
          opts.preValidation = opts.preValidation.bind(_fastify);
        }
      }
    }
    if (typeof opts === "function") {
      handler = opts;
      opts = void 0;
    }
    opts = opts || {};
    if (handler) {
      this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
      handler = handler.bind(this);
      _onBadUrlHandler = handler;
    } else {
      handler = basic404;
      _onBadUrlHandler = basic404;
    }
    this.after((notHandledErr, done) => {
      _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
      done(notHandledErr);
    });
  }
  function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
    const context2 = new Context$1({
      schema: opts.schema,
      handler,
      config: opts.config || {},
      server: this
    });
    avvio.once("preReady", () => {
      const context3 = this[kFourOhFourContext];
      for (const hook of lifecycleHooks) {
        const toSet = this[kHooks$2][hook].concat(opts[hook] || []).map((h) => h.bind(this));
        context3[hook] = toSet.length ? toSet : null;
      }
      context3.errorHandler = opts.errorHandler ? buildErrorHandler$1(this[kErrorHandler$1], opts.errorHandler) : this[kErrorHandler$1];
    });
    if (this[kFourOhFourContext] !== null && prefix === "/") {
      Object.assign(this[kFourOhFourContext], context2);
      return;
    }
    this[kFourOhFourLevelInstance][kFourOhFourContext] = context2;
    router.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context2);
    router.all(prefix, routeHandler, context2);
  }
  function fourOhFourFallBack(req2, res2) {
    const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
    const id2 = getGenReqId$1(fourOhFourContext.server, req2);
    const childLogger = createChildLogger$1(fourOhFourContext, logger, req2, id2);
    childLogger.info({ req: req2 }, "incoming request");
    const request2 = new Request$3(id2, null, req2, null, childLogger, fourOhFourContext);
    const reply2 = new Reply$2(res2, request2, childLogger);
    request2.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
    request2.log.warn(router.prettyPrint());
    reply2.code(404).send(new FST_ERR_NOT_FOUND());
  }
}
var fourOhFour_1 = fourOhFour;
var initialConfigValidation = { exports: {} };
var configValidator$1 = { exports: {} };
configValidator$1.exports = validate10;
configValidator$1.exports.default = validate10;
const schema11 = { "properties": { "connectionTimeout": { "type": "integer", "default": 0 }, "keepAliveTimeout": { "type": "integer", "default": 72e3 }, "forceCloseConnections": { "oneOf": [{ "type": "string", "pattern": "idle" }, { "type": "boolean" }] }, "maxRequestsPerSocket": { "type": "integer", "default": 0, "nullable": true }, "requestTimeout": { "type": "integer", "default": 0 }, "bodyLimit": { "type": "integer", "default": 1048576 }, "caseSensitive": { "type": "boolean", "default": true }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "http2": { "type": "boolean" }, "https": { "if": { "not": { "oneOf": [{ "type": "boolean" }, { "type": "null" }, { "type": "object", "additionalProperties": false, "required": ["allowHTTP1"], "properties": { "allowHTTP1": { "type": "boolean" } } }] } }, "then": { "setDefaultValue": true } }, "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "disableRequestLogging": { "type": "boolean", "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "onProtoPoisoning": { "type": "string", "default": "error" }, "onConstructorPoisoning": { "type": "string", "default": "error" }, "pluginTimeout": { "type": "integer", "default": 1e4 }, "requestIdHeader": { "anyOf": [{ "type": "boolean" }, { "type": "string" }], "default": false }, "requestIdLogLabel": { "type": "string", "default": "reqId" }, "http2SessionTimeout": { "type": "integer", "default": 72e3 }, "exposeHeadRoutes": { "type": "boolean", "default": true }, "useSemicolonDelimiter": { "type": "boolean", "default": false }, "constraints": { "type": "object", "additionalProperties": { "type": "object", "required": ["name", "storage", "validate", "deriveConstraint"], "additionalProperties": true, "properties": { "name": { "type": "string" }, "storage": {}, "validate": {}, "deriveConstraint": {} } } } } };
const func2 = Object.prototype.hasOwnProperty;
const pattern0 = new RegExp("idle", "u");
function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors2 = 0;
  if (errors2 === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.connectionTimeout === void 0) {
        data.connectionTimeout = 0;
      }
      if (data.keepAliveTimeout === void 0) {
        data.keepAliveTimeout = 72e3;
      }
      if (data.maxRequestsPerSocket === void 0) {
        data.maxRequestsPerSocket = 0;
      }
      if (data.requestTimeout === void 0) {
        data.requestTimeout = 0;
      }
      if (data.bodyLimit === void 0) {
        data.bodyLimit = 1048576;
      }
      if (data.caseSensitive === void 0) {
        data.caseSensitive = true;
      }
      if (data.allowUnsafeRegex === void 0) {
        data.allowUnsafeRegex = false;
      }
      if (data.ignoreTrailingSlash === void 0) {
        data.ignoreTrailingSlash = false;
      }
      if (data.ignoreDuplicateSlashes === void 0) {
        data.ignoreDuplicateSlashes = false;
      }
      if (data.disableRequestLogging === void 0) {
        data.disableRequestLogging = false;
      }
      if (data.maxParamLength === void 0) {
        data.maxParamLength = 100;
      }
      if (data.onProtoPoisoning === void 0) {
        data.onProtoPoisoning = "error";
      }
      if (data.onConstructorPoisoning === void 0) {
        data.onConstructorPoisoning = "error";
      }
      if (data.pluginTimeout === void 0) {
        data.pluginTimeout = 1e4;
      }
      if (data.requestIdHeader === void 0) {
        data.requestIdHeader = false;
      }
      if (data.requestIdLogLabel === void 0) {
        data.requestIdLogLabel = "reqId";
      }
      if (data.http2SessionTimeout === void 0) {
        data.http2SessionTimeout = 72e3;
      }
      if (data.exposeHeadRoutes === void 0) {
        data.exposeHeadRoutes = true;
      }
      if (data.useSemicolonDelimiter === void 0) {
        data.useSemicolonDelimiter = false;
      }
      const _errs1 = errors2;
      for (const key0 in data) {
        if (!func2.call(schema11.properties, key0)) {
          delete data[key0];
        }
      }
      if (_errs1 === errors2) {
        let data0 = data.connectionTimeout;
        const _errs2 = errors2;
        if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
          let dataType0 = typeof data0;
          let coerced0 = void 0;
          if (!(coerced0 !== void 0)) {
            if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
              coerced0 = +data0;
            } else {
              validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
              return false;
            }
          }
          if (coerced0 !== void 0) {
            data0 = coerced0;
            if (data !== void 0) {
              data["connectionTimeout"] = coerced0;
            }
          }
        }
        var valid0 = _errs2 === errors2;
        if (valid0) {
          let data1 = data.keepAliveTimeout;
          const _errs4 = errors2;
          if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
            let dataType1 = typeof data1;
            let coerced1 = void 0;
            if (!(coerced1 !== void 0)) {
              if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                coerced1 = +data1;
              } else {
                validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                return false;
              }
            }
            if (coerced1 !== void 0) {
              data1 = coerced1;
              if (data !== void 0) {
                data["keepAliveTimeout"] = coerced1;
              }
            }
          }
          var valid0 = _errs4 === errors2;
          if (valid0) {
            if (data.forceCloseConnections !== void 0) {
              let data2 = data.forceCloseConnections;
              const _errs6 = errors2;
              const _errs7 = errors2;
              let valid1 = false;
              let passing0 = null;
              const _errs8 = errors2;
              if (typeof data2 !== "string") {
                let dataType2 = typeof data2;
                let coerced2 = void 0;
                if (!(coerced2 !== void 0)) {
                  if (dataType2 == "number" || dataType2 == "boolean") {
                    coerced2 = "" + data2;
                  } else if (data2 === null) {
                    coerced2 = "";
                  } else {
                    const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err0];
                    } else {
                      vErrors.push(err0);
                    }
                    errors2++;
                  }
                }
                if (coerced2 !== void 0) {
                  data2 = coerced2;
                  if (data !== void 0) {
                    data["forceCloseConnections"] = coerced2;
                  }
                }
              }
              if (errors2 === _errs8) {
                if (typeof data2 === "string") {
                  if (!pattern0.test(data2)) {
                    const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                    if (vErrors === null) {
                      vErrors = [err1];
                    } else {
                      vErrors.push(err1);
                    }
                    errors2++;
                  }
                }
              }
              var _valid0 = _errs8 === errors2;
              if (_valid0) {
                valid1 = true;
                passing0 = 0;
              }
              const _errs10 = errors2;
              if (typeof data2 !== "boolean") {
                let coerced3 = void 0;
                if (!(coerced3 !== void 0)) {
                  if (data2 === "false" || data2 === 0 || data2 === null) {
                    coerced3 = false;
                  } else if (data2 === "true" || data2 === 1) {
                    coerced3 = true;
                  } else {
                    const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    if (vErrors === null) {
                      vErrors = [err2];
                    } else {
                      vErrors.push(err2);
                    }
                    errors2++;
                  }
                }
                if (coerced3 !== void 0) {
                  data2 = coerced3;
                  if (data !== void 0) {
                    data["forceCloseConnections"] = coerced3;
                  }
                }
              }
              var _valid0 = _errs10 === errors2;
              if (_valid0 && valid1) {
                valid1 = false;
                passing0 = [passing0, 1];
              } else {
                if (_valid0) {
                  valid1 = true;
                  passing0 = 1;
                }
              }
              if (!valid1) {
                const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors2++;
                validate10.errors = vErrors;
                return false;
              } else {
                errors2 = _errs7;
                if (vErrors !== null) {
                  if (_errs7) {
                    vErrors.length = _errs7;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid0 = _errs6 === errors2;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              let data3 = data.maxRequestsPerSocket;
              const _errs12 = errors2;
              if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3)) && data3 !== null) {
                let dataType4 = typeof data3;
                let coerced4 = void 0;
                if (!(coerced4 !== void 0)) {
                  if (dataType4 === "boolean" || data3 === null || dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1)) {
                    coerced4 = +data3;
                  } else if (data3 === "" || data3 === 0 || data3 === false) {
                    coerced4 = null;
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                    return false;
                  }
                }
                if (coerced4 !== void 0) {
                  data3 = coerced4;
                  if (data !== void 0) {
                    data["maxRequestsPerSocket"] = coerced4;
                  }
                }
              }
              var valid0 = _errs12 === errors2;
              if (valid0) {
                let data4 = data.requestTimeout;
                const _errs15 = errors2;
                if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                  let dataType5 = typeof data4;
                  let coerced5 = void 0;
                  if (!(coerced5 !== void 0)) {
                    if (dataType5 === "boolean" || data4 === null || dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1)) {
                      coerced5 = +data4;
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                      return false;
                    }
                  }
                  if (coerced5 !== void 0) {
                    data4 = coerced5;
                    if (data !== void 0) {
                      data["requestTimeout"] = coerced5;
                    }
                  }
                }
                var valid0 = _errs15 === errors2;
                if (valid0) {
                  let data5 = data.bodyLimit;
                  const _errs17 = errors2;
                  if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                    let dataType6 = typeof data5;
                    let coerced6 = void 0;
                    if (!(coerced6 !== void 0)) {
                      if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                        coerced6 = +data5;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced6 !== void 0) {
                      data5 = coerced6;
                      if (data !== void 0) {
                        data["bodyLimit"] = coerced6;
                      }
                    }
                  }
                  var valid0 = _errs17 === errors2;
                  if (valid0) {
                    let data6 = data.caseSensitive;
                    const _errs19 = errors2;
                    if (typeof data6 !== "boolean") {
                      let coerced7 = void 0;
                      if (!(coerced7 !== void 0)) {
                        if (data6 === "false" || data6 === 0 || data6 === null) {
                          coerced7 = false;
                        } else if (data6 === "true" || data6 === 1) {
                          coerced7 = true;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                          return false;
                        }
                      }
                      if (coerced7 !== void 0) {
                        data6 = coerced7;
                        if (data !== void 0) {
                          data["caseSensitive"] = coerced7;
                        }
                      }
                    }
                    var valid0 = _errs19 === errors2;
                    if (valid0) {
                      let data7 = data.allowUnsafeRegex;
                      const _errs21 = errors2;
                      if (typeof data7 !== "boolean") {
                        let coerced8 = void 0;
                        if (!(coerced8 !== void 0)) {
                          if (data7 === "false" || data7 === 0 || data7 === null) {
                            coerced8 = false;
                          } else if (data7 === "true" || data7 === 1) {
                            coerced8 = true;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                            return false;
                          }
                        }
                        if (coerced8 !== void 0) {
                          data7 = coerced8;
                          if (data !== void 0) {
                            data["allowUnsafeRegex"] = coerced8;
                          }
                        }
                      }
                      var valid0 = _errs21 === errors2;
                      if (valid0) {
                        if (data.http2 !== void 0) {
                          let data8 = data.http2;
                          const _errs23 = errors2;
                          if (typeof data8 !== "boolean") {
                            let coerced9 = void 0;
                            if (!(coerced9 !== void 0)) {
                              if (data8 === "false" || data8 === 0 || data8 === null) {
                                coerced9 = false;
                              } else if (data8 === "true" || data8 === 1) {
                                coerced9 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced9 !== void 0) {
                              data8 = coerced9;
                              if (data !== void 0) {
                                data["http2"] = coerced9;
                              }
                            }
                          }
                          var valid0 = _errs23 === errors2;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.https !== void 0) {
                            let data9 = data.https;
                            const _errs25 = errors2;
                            const _errs26 = errors2;
                            let valid2 = true;
                            const _errs27 = errors2;
                            const _errs28 = errors2;
                            const _errs29 = errors2;
                            const _errs30 = errors2;
                            let valid4 = false;
                            const _errs31 = errors2;
                            if (typeof data9 !== "boolean") {
                              let coerced10 = void 0;
                              if (!(coerced10 !== void 0)) {
                                if (data9 === "false" || data9 === 0 || data9 === null) {
                                  coerced10 = false;
                                } else if (data9 === "true" || data9 === 1) {
                                  coerced10 = true;
                                } else {
                                  const err4 = {};
                                  if (vErrors === null) {
                                    vErrors = [err4];
                                  } else {
                                    vErrors.push(err4);
                                  }
                                  errors2++;
                                }
                              }
                              if (coerced10 !== void 0) {
                                data9 = coerced10;
                                if (data !== void 0) {
                                  data["https"] = coerced10;
                                }
                              }
                            }
                            var _valid2 = _errs31 === errors2;
                            if (_valid2) {
                              valid4 = true;
                            }
                            const _errs33 = errors2;
                            if (data9 !== null) {
                              let coerced11 = void 0;
                              if (!(coerced11 !== void 0)) {
                                if (data9 === "" || data9 === 0 || data9 === false) {
                                  coerced11 = null;
                                } else {
                                  const err5 = {};
                                  if (vErrors === null) {
                                    vErrors = [err5];
                                  } else {
                                    vErrors.push(err5);
                                  }
                                  errors2++;
                                }
                              }
                              if (coerced11 !== void 0) {
                                data9 = coerced11;
                                if (data !== void 0) {
                                  data["https"] = coerced11;
                                }
                              }
                            }
                            var _valid2 = _errs33 === errors2;
                            if (_valid2 && valid4) {
                              valid4 = false;
                            } else {
                              if (_valid2) {
                                valid4 = true;
                              }
                              const _errs35 = errors2;
                              if (errors2 === _errs35) {
                                if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                  if (data9.allowHTTP1 === void 0 && "allowHTTP1") {
                                    const err6 = {};
                                    if (vErrors === null) {
                                      vErrors = [err6];
                                    } else {
                                      vErrors.push(err6);
                                    }
                                    errors2++;
                                  } else {
                                    const _errs37 = errors2;
                                    for (const key1 in data9) {
                                      if (!(key1 === "allowHTTP1")) {
                                        delete data9[key1];
                                      }
                                    }
                                    if (_errs37 === errors2) {
                                      if (data9.allowHTTP1 !== void 0) {
                                        let data10 = data9.allowHTTP1;
                                        if (typeof data10 !== "boolean") {
                                          let coerced12 = void 0;
                                          if (!(coerced12 !== void 0)) {
                                            if (data10 === "false" || data10 === 0 || data10 === null) {
                                              coerced12 = false;
                                            } else if (data10 === "true" || data10 === 1) {
                                              coerced12 = true;
                                            } else {
                                              const err7 = {};
                                              if (vErrors === null) {
                                                vErrors = [err7];
                                              } else {
                                                vErrors.push(err7);
                                              }
                                              errors2++;
                                            }
                                          }
                                          if (coerced12 !== void 0) {
                                            data10 = coerced12;
                                            if (data9 !== void 0) {
                                              data9["allowHTTP1"] = coerced12;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  const err8 = {};
                                  if (vErrors === null) {
                                    vErrors = [err8];
                                  } else {
                                    vErrors.push(err8);
                                  }
                                  errors2++;
                                }
                              }
                              var _valid2 = _errs35 === errors2;
                              if (_valid2 && valid4) {
                                valid4 = false;
                              } else {
                                if (_valid2) {
                                  valid4 = true;
                                }
                              }
                            }
                            if (!valid4) {
                              const err9 = {};
                              if (vErrors === null) {
                                vErrors = [err9];
                              } else {
                                vErrors.push(err9);
                              }
                              errors2++;
                            } else {
                              errors2 = _errs30;
                              if (vErrors !== null) {
                                if (_errs30) {
                                  vErrors.length = _errs30;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var valid3 = _errs29 === errors2;
                            if (valid3) {
                              const err10 = {};
                              if (vErrors === null) {
                                vErrors = [err10];
                              } else {
                                vErrors.push(err10);
                              }
                              errors2++;
                            } else {
                              errors2 = _errs28;
                              if (vErrors !== null) {
                                if (_errs28) {
                                  vErrors.length = _errs28;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var _valid1 = _errs27 === errors2;
                            errors2 = _errs26;
                            if (vErrors !== null) {
                              if (_errs26) {
                                vErrors.length = _errs26;
                              } else {
                                vErrors = null;
                              }
                            }
                            if (_valid1) {
                              const _errs40 = errors2;
                              data["https"] = true;
                              var _valid1 = _errs40 === errors2;
                              valid2 = _valid1;
                            }
                            if (!valid2) {
                              const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                              if (vErrors === null) {
                                vErrors = [err11];
                              } else {
                                vErrors.push(err11);
                              }
                              errors2++;
                              validate10.errors = vErrors;
                              return false;
                            }
                            var valid0 = _errs25 === errors2;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            let data11 = data.ignoreTrailingSlash;
                            const _errs41 = errors2;
                            if (typeof data11 !== "boolean") {
                              let coerced13 = void 0;
                              if (!(coerced13 !== void 0)) {
                                if (data11 === "false" || data11 === 0 || data11 === null) {
                                  coerced13 = false;
                                } else if (data11 === "true" || data11 === 1) {
                                  coerced13 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced13 !== void 0) {
                                data11 = coerced13;
                                if (data !== void 0) {
                                  data["ignoreTrailingSlash"] = coerced13;
                                }
                              }
                            }
                            var valid0 = _errs41 === errors2;
                            if (valid0) {
                              let data12 = data.ignoreDuplicateSlashes;
                              const _errs43 = errors2;
                              if (typeof data12 !== "boolean") {
                                let coerced14 = void 0;
                                if (!(coerced14 !== void 0)) {
                                  if (data12 === "false" || data12 === 0 || data12 === null) {
                                    coerced14 = false;
                                  } else if (data12 === "true" || data12 === 1) {
                                    coerced14 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced14 !== void 0) {
                                  data12 = coerced14;
                                  if (data !== void 0) {
                                    data["ignoreDuplicateSlashes"] = coerced14;
                                  }
                                }
                              }
                              var valid0 = _errs43 === errors2;
                              if (valid0) {
                                let data13 = data.disableRequestLogging;
                                const _errs45 = errors2;
                                if (typeof data13 !== "boolean") {
                                  let coerced15 = void 0;
                                  if (!(coerced15 !== void 0)) {
                                    if (data13 === "false" || data13 === 0 || data13 === null) {
                                      coerced15 = false;
                                    } else if (data13 === "true" || data13 === 1) {
                                      coerced15 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced15 !== void 0) {
                                    data13 = coerced15;
                                    if (data !== void 0) {
                                      data["disableRequestLogging"] = coerced15;
                                    }
                                  }
                                }
                                var valid0 = _errs45 === errors2;
                                if (valid0) {
                                  let data14 = data.maxParamLength;
                                  const _errs47 = errors2;
                                  if (!(typeof data14 == "number" && (!(data14 % 1) && !isNaN(data14)) && isFinite(data14))) {
                                    let dataType16 = typeof data14;
                                    let coerced16 = void 0;
                                    if (!(coerced16 !== void 0)) {
                                      if (dataType16 === "boolean" || data14 === null || dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1)) {
                                        coerced16 = +data14;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                        return false;
                                      }
                                    }
                                    if (coerced16 !== void 0) {
                                      data14 = coerced16;
                                      if (data !== void 0) {
                                        data["maxParamLength"] = coerced16;
                                      }
                                    }
                                  }
                                  var valid0 = _errs47 === errors2;
                                  if (valid0) {
                                    let data15 = data.onProtoPoisoning;
                                    const _errs49 = errors2;
                                    if (typeof data15 !== "string") {
                                      let dataType17 = typeof data15;
                                      let coerced17 = void 0;
                                      if (!(coerced17 !== void 0)) {
                                        if (dataType17 == "number" || dataType17 == "boolean") {
                                          coerced17 = "" + data15;
                                        } else if (data15 === null) {
                                          coerced17 = "";
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                      }
                                      if (coerced17 !== void 0) {
                                        data15 = coerced17;
                                        if (data !== void 0) {
                                          data["onProtoPoisoning"] = coerced17;
                                        }
                                      }
                                    }
                                    var valid0 = _errs49 === errors2;
                                    if (valid0) {
                                      let data16 = data.onConstructorPoisoning;
                                      const _errs51 = errors2;
                                      if (typeof data16 !== "string") {
                                        let dataType18 = typeof data16;
                                        let coerced18 = void 0;
                                        if (!(coerced18 !== void 0)) {
                                          if (dataType18 == "number" || dataType18 == "boolean") {
                                            coerced18 = "" + data16;
                                          } else if (data16 === null) {
                                            coerced18 = "";
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                        if (coerced18 !== void 0) {
                                          data16 = coerced18;
                                          if (data !== void 0) {
                                            data["onConstructorPoisoning"] = coerced18;
                                          }
                                        }
                                      }
                                      var valid0 = _errs51 === errors2;
                                      if (valid0) {
                                        let data17 = data.pluginTimeout;
                                        const _errs53 = errors2;
                                        if (!(typeof data17 == "number" && (!(data17 % 1) && !isNaN(data17)) && isFinite(data17))) {
                                          let dataType19 = typeof data17;
                                          let coerced19 = void 0;
                                          if (!(coerced19 !== void 0)) {
                                            if (dataType19 === "boolean" || data17 === null || dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1)) {
                                              coerced19 = +data17;
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                              return false;
                                            }
                                          }
                                          if (coerced19 !== void 0) {
                                            data17 = coerced19;
                                            if (data !== void 0) {
                                              data["pluginTimeout"] = coerced19;
                                            }
                                          }
                                        }
                                        var valid0 = _errs53 === errors2;
                                        if (valid0) {
                                          let data18 = data.requestIdHeader;
                                          const _errs55 = errors2;
                                          const _errs56 = errors2;
                                          let valid6 = false;
                                          const _errs57 = errors2;
                                          if (typeof data18 !== "boolean") {
                                            let coerced20 = void 0;
                                            if (!(coerced20 !== void 0)) {
                                              if (data18 === "false" || data18 === 0 || data18 === null) {
                                                coerced20 = false;
                                              } else if (data18 === "true" || data18 === 1) {
                                                coerced20 = true;
                                              } else {
                                                const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                if (vErrors === null) {
                                                  vErrors = [err12];
                                                } else {
                                                  vErrors.push(err12);
                                                }
                                                errors2++;
                                              }
                                            }
                                            if (coerced20 !== void 0) {
                                              data18 = coerced20;
                                              if (data !== void 0) {
                                                data["requestIdHeader"] = coerced20;
                                              }
                                            }
                                          }
                                          var _valid3 = _errs57 === errors2;
                                          valid6 = valid6 || _valid3;
                                          if (!valid6) {
                                            const _errs59 = errors2;
                                            if (typeof data18 !== "string") {
                                              let dataType21 = typeof data18;
                                              let coerced21 = void 0;
                                              if (!(coerced21 !== void 0)) {
                                                if (dataType21 == "number" || dataType21 == "boolean") {
                                                  coerced21 = "" + data18;
                                                } else if (data18 === null) {
                                                  coerced21 = "";
                                                } else {
                                                  const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                  if (vErrors === null) {
                                                    vErrors = [err13];
                                                  } else {
                                                    vErrors.push(err13);
                                                  }
                                                  errors2++;
                                                }
                                              }
                                              if (coerced21 !== void 0) {
                                                data18 = coerced21;
                                                if (data !== void 0) {
                                                  data["requestIdHeader"] = coerced21;
                                                }
                                              }
                                            }
                                            var _valid3 = _errs59 === errors2;
                                            valid6 = valid6 || _valid3;
                                          }
                                          if (!valid6) {
                                            const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            if (vErrors === null) {
                                              vErrors = [err14];
                                            } else {
                                              vErrors.push(err14);
                                            }
                                            errors2++;
                                            validate10.errors = vErrors;
                                            return false;
                                          } else {
                                            errors2 = _errs56;
                                            if (vErrors !== null) {
                                              if (_errs56) {
                                                vErrors.length = _errs56;
                                              } else {
                                                vErrors = null;
                                              }
                                            }
                                          }
                                          var valid0 = _errs55 === errors2;
                                          if (valid0) {
                                            let data19 = data.requestIdLogLabel;
                                            const _errs61 = errors2;
                                            if (typeof data19 !== "string") {
                                              let dataType22 = typeof data19;
                                              let coerced22 = void 0;
                                              if (!(coerced22 !== void 0)) {
                                                if (dataType22 == "number" || dataType22 == "boolean") {
                                                  coerced22 = "" + data19;
                                                } else if (data19 === null) {
                                                  coerced22 = "";
                                                } else {
                                                  validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                              }
                                              if (coerced22 !== void 0) {
                                                data19 = coerced22;
                                                if (data !== void 0) {
                                                  data["requestIdLogLabel"] = coerced22;
                                                }
                                              }
                                            }
                                            var valid0 = _errs61 === errors2;
                                            if (valid0) {
                                              let data20 = data.http2SessionTimeout;
                                              const _errs63 = errors2;
                                              if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                                                let dataType23 = typeof data20;
                                                let coerced23 = void 0;
                                                if (!(coerced23 !== void 0)) {
                                                  if (dataType23 === "boolean" || data20 === null || dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1)) {
                                                    coerced23 = +data20;
                                                  } else {
                                                    validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                    return false;
                                                  }
                                                }
                                                if (coerced23 !== void 0) {
                                                  data20 = coerced23;
                                                  if (data !== void 0) {
                                                    data["http2SessionTimeout"] = coerced23;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs63 === errors2;
                                              if (valid0) {
                                                let data21 = data.exposeHeadRoutes;
                                                const _errs65 = errors2;
                                                if (typeof data21 !== "boolean") {
                                                  let coerced24 = void 0;
                                                  if (!(coerced24 !== void 0)) {
                                                    if (data21 === "false" || data21 === 0 || data21 === null) {
                                                      coerced24 = false;
                                                    } else if (data21 === "true" || data21 === 1) {
                                                      coerced24 = true;
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced24 !== void 0) {
                                                    data21 = coerced24;
                                                    if (data !== void 0) {
                                                      data["exposeHeadRoutes"] = coerced24;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs65 === errors2;
                                                if (valid0) {
                                                  let data22 = data.useSemicolonDelimiter;
                                                  const _errs67 = errors2;
                                                  if (typeof data22 !== "boolean") {
                                                    let coerced25 = void 0;
                                                    if (!(coerced25 !== void 0)) {
                                                      if (data22 === "false" || data22 === 0 || data22 === null) {
                                                        coerced25 = false;
                                                      } else if (data22 === "true" || data22 === 1) {
                                                        coerced25 = true;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced25 !== void 0) {
                                                      data22 = coerced25;
                                                      if (data !== void 0) {
                                                        data["useSemicolonDelimiter"] = coerced25;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs67 === errors2;
                                                  if (valid0) {
                                                    if (data.constraints !== void 0) {
                                                      let data23 = data.constraints;
                                                      const _errs69 = errors2;
                                                      if (errors2 === _errs69) {
                                                        if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
                                                          for (const key2 in data23) {
                                                            let data24 = data23[key2];
                                                            const _errs72 = errors2;
                                                            if (errors2 === _errs72) {
                                                              if (data24 && typeof data24 == "object" && !Array.isArray(data24)) {
                                                                let missing1;
                                                                if (data24.name === void 0 && (missing1 = "name") || data24.storage === void 0 && (missing1 = "storage") || data24.validate === void 0 && (missing1 = "validate") || data24.deriveConstraint === void 0 && (missing1 = "deriveConstraint")) {
                                                                  validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                  return false;
                                                                } else {
                                                                  if (data24.name !== void 0) {
                                                                    let data25 = data24.name;
                                                                    if (typeof data25 !== "string") {
                                                                      let dataType26 = typeof data25;
                                                                      let coerced26 = void 0;
                                                                      if (!(coerced26 !== void 0)) {
                                                                        if (dataType26 == "number" || dataType26 == "boolean") {
                                                                          coerced26 = "" + data25;
                                                                        } else if (data25 === null) {
                                                                          coerced26 = "";
                                                                        } else {
                                                                          validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      if (coerced26 !== void 0) {
                                                                        data25 = coerced26;
                                                                        if (data24 !== void 0) {
                                                                          data24["name"] = coerced26;
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid7 = _errs72 === errors2;
                                                            if (!valid7) {
                                                              break;
                                                            }
                                                          }
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                          return false;
                                                        }
                                                      }
                                                      var valid0 = _errs69 === errors2;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate10.errors = vErrors;
  return errors2 === 0;
}
configValidator$1.exports.defaultInitOptions = { "connectionTimeout": 0, "keepAliveTimeout": 72e3, "maxRequestsPerSocket": 0, "requestTimeout": 0, "bodyLimit": 1048576, "caseSensitive": true, "allowUnsafeRegex": false, "disableRequestLogging": false, "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "onProtoPoisoning": "error", "onConstructorPoisoning": "error", "pluginTimeout": 1e4, "requestIdHeader": false, "requestIdLogLabel": "reqId", "http2SessionTimeout": 72e3, "exposeHeadRoutes": true, "useSemicolonDelimiter": false };
var configValidatorExports = configValidator$1.exports;
const validate = configValidatorExports;
const deepClone = rfdc_1({ circles: true, proto: false });
const { FST_ERR_INIT_OPTS_INVALID } = errorsExports;
function validateInitialConfig(options) {
  const opts = deepClone(options);
  if (!validate(opts)) {
    const error2 = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e) => e.message)));
    error2.errors = validate.errors;
    throw error2;
  }
  return deepFreezeObject(opts);
}
function deepFreezeObject(object) {
  const properties2 = Object.getOwnPropertyNames(object);
  for (const name of properties2) {
    const value = object[name];
    if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
      continue;
    }
    object[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
  }
  return Object.freeze(object);
}
initialConfigValidation.exports = validateInitialConfig;
initialConfigValidation.exports.defaultInitOptions = validate.defaultInitOptions;
initialConfigValidation.exports.utils = { deepFreezeObject };
var initialConfigValidationExports = initialConfigValidation.exports;
const {
  kAvvioBoot: kAvvioBoot$1,
  kChildren: kChildren$1,
  kRoutePrefix: kRoutePrefix$1,
  kLogLevel: kLogLevel$1,
  kLogSerializers: kLogSerializers$1,
  kHooks: kHooks$1,
  kSchemaController: kSchemaController$1,
  kContentTypeParser: kContentTypeParser$1,
  kReply: kReply$1,
  kRequest: kRequest$1,
  kFourOhFour: kFourOhFour$1,
  kPluginNameChain: kPluginNameChain$1
} = symbols$1;
const Reply$1 = replyExports;
const Request$2 = requestExports;
const SchemaController$1 = schemaController;
const ContentTypeParser$1 = contentTypeParserExports;
const { buildHooks } = hooks;
const pluginUtils$1 = pluginUtilsExports;
var pluginOverride = function override(old, fn, opts) {
  const shouldSkipOverride = pluginUtils$1.registerPlugin.call(old, fn);
  const fnName = pluginUtils$1.getPluginName(fn) || pluginUtils$1.getFuncPreview(fn);
  if (shouldSkipOverride) {
    old[kPluginNameChain$1].push(fnName);
    return old;
  }
  const instance = Object.create(old);
  old[kChildren$1].push(instance);
  instance.ready = old[kAvvioBoot$1].bind(instance);
  instance[kChildren$1] = [];
  instance[kReply$1] = Reply$1.buildReply(instance[kReply$1]);
  instance[kRequest$1] = Request$2.buildRequest(instance[kRequest$1]);
  instance[kContentTypeParser$1] = ContentTypeParser$1.helpers.buildContentTypeParser(instance[kContentTypeParser$1]);
  instance[kHooks$1] = buildHooks(instance[kHooks$1]);
  instance[kRoutePrefix$1] = buildRoutePrefix(instance[kRoutePrefix$1], opts.prefix);
  instance[kLogLevel$1] = opts.logLevel || instance[kLogLevel$1];
  instance[kSchemaController$1] = SchemaController$1.buildSchemaController(old[kSchemaController$1]);
  instance.getSchema = instance[kSchemaController$1].getSchema.bind(instance[kSchemaController$1]);
  instance.getSchemas = instance[kSchemaController$1].getSchemas.bind(instance[kSchemaController$1]);
  instance[pluginUtils$1.kRegisteredPlugins] = Object.create(instance[pluginUtils$1.kRegisteredPlugins]);
  instance[kPluginNameChain$1] = [fnName];
  if (instance[kLogSerializers$1] || opts.logSerializers) {
    instance[kLogSerializers$1] = Object.assign(Object.create(instance[kLogSerializers$1]), opts.logSerializers);
  }
  if (opts.prefix) {
    instance[kFourOhFour$1].arrange404(instance);
  }
  for (const hook of instance[kHooks$1].onRegister) hook.call(old, instance, opts);
  return instance;
};
function buildRoutePrefix(instancePrefix, pluginPrefix) {
  if (!pluginPrefix) {
    return instancePrefix;
  }
  if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
    pluginPrefix = pluginPrefix.slice(1);
  } else if (pluginPrefix[0] !== "/") {
    pluginPrefix = "/" + pluginPrefix;
  }
  return instancePrefix + pluginPrefix;
}
var noopSet$1 = function noopSet() {
  return {
    [Symbol.iterator]: function* () {
    },
    add() {
    },
    delete() {
    },
    has() {
      return true;
    }
  };
};
var lightMyRequest$1 = { exports: {} };
var request = { exports: {} };
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.parse = parse2;
  dist.serialize = serialize2;
  const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  const __toString = Object.prototype.toString;
  const NullObject2 = /* @__PURE__ */ (() => {
    const C = function() {
    };
    C.prototype = /* @__PURE__ */ Object.create(null);
    return C;
  })();
  function parse2(str2, options) {
    const obj = new NullObject2();
    const len = str2.length;
    if (len < 2)
      return obj;
    const dec = (options == null ? void 0 : options.decode) || decode;
    let index = 0;
    do {
      const eqIdx = str2.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str2.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str2.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str2, index, eqIdx);
      const keyEndIdx = endIndex(str2, eqIdx, keyStartIdx);
      const key = str2.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === void 0) {
        let valStartIdx = startIndex(str2, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str2, endIdx, valStartIdx);
        const value = dec(str2.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str2, index, max2) {
    do {
      const code2 = str2.charCodeAt(index);
      if (code2 !== 32 && code2 !== 9)
        return index;
    } while (++index < max2);
    return max2;
  }
  function endIndex(str2, index, min2) {
    while (index > min2) {
      const code2 = str2.charCodeAt(--index);
      if (code2 !== 32 && code2 !== 9)
        return index + 1;
    }
    return min2;
  }
  function serialize2(name, val, options) {
    const enc = (options == null ? void 0 : options.encode) || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str2 = name + "=" + value;
    if (!options)
      return str2;
    if (options.maxAge !== void 0) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str2 += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str2 += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str2 += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate2(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str2 += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str2 += "; HttpOnly";
    }
    if (options.secure) {
      str2 += "; Secure";
    }
    if (options.partitioned) {
      str2 += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
      switch (priority) {
        case "low":
          str2 += "; Priority=Low";
          break;
        case "medium":
          str2 += "; Priority=Medium";
          break;
        case "high":
          str2 += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str2 += "; SameSite=Strict";
          break;
        case "lax":
          str2 += "; SameSite=Lax";
          break;
        case "none":
          str2 += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str2;
  }
  function decode(str2) {
    if (str2.indexOf("%") === -1)
      return str2;
    try {
      return decodeURIComponent(str2);
    } catch (e) {
      return str2;
    }
  }
  function isDate2(val) {
    return __toString.call(val) === "[object Date]";
  }
  return dist;
}
var parseUrl$3;
var hasRequiredParseUrl;
function requireParseUrl() {
  if (hasRequiredParseUrl) return parseUrl$3;
  hasRequiredParseUrl = 1;
  const { URL: URL2 } = require$$0$a;
  const BASE_URL = "http://localhost";
  parseUrl$3 = function parseURL(url2, query) {
    if ((typeof url2 === "string" || Object.prototype.toString.call(url2) === "[object String]") && url2.startsWith("//")) {
      url2 = BASE_URL + url2;
    }
    const result = typeof url2 === "object" ? Object.assign(new URL2(BASE_URL), url2) : new URL2(url2, BASE_URL);
    if (typeof query === "string") {
      query = new URLSearchParams(query);
      for (const key of query.keys()) {
        result.searchParams.delete(key);
        for (const value of query.getAll(key)) {
          result.searchParams.append(key, value);
        }
      }
    } else {
      const merged = Object.assign({}, url2.query, query);
      for (const key in merged) {
        const value = merged[key];
        if (Array.isArray(value)) {
          result.searchParams.delete(key);
          for (const param of value) {
            result.searchParams.append(key, param);
          }
        } else {
          result.searchParams.set(key, value);
        }
      }
    }
    return result;
  };
  return parseUrl$3;
}
var formData = {};
var hasRequiredFormData;
function requireFormData() {
  if (hasRequiredFormData) return formData;
  hasRequiredFormData = 1;
  const { randomUUID } = require$$0$b;
  const { Readable: Readable2 } = require$$0$7;
  let textEncoder2;
  function isFormDataLike(payload) {
    return payload && typeof payload === "object" && typeof payload.append === "function" && typeof payload.delete === "function" && typeof payload.get === "function" && typeof payload.getAll === "function" && typeof payload.has === "function" && typeof payload.set === "function" && payload[Symbol.toStringTag] === "FormData";
  }
  function formDataToStream2(formdata) {
    textEncoder2 = textEncoder2 ?? new TextEncoder();
    const boundary = `----formdata-${randomUUID()}`;
    const prefix = `--${boundary}\r
Content-Disposition: form-data`;
    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
    const escape2 = (str2) => str2.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
    const linebreak = new Uint8Array([13, 10]);
    async function* asyncIterator2() {
      for (const [name, value] of formdata) {
        if (typeof value === "string") {
          yield textEncoder2.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"\r
\r
`);
          yield textEncoder2.encode(`${normalizeLinefeeds(value)}\r
`);
        } else {
          let header = `${prefix}; name="${escape2(normalizeLinefeeds(name))}"`;
          value.name && (header += `; filename="${escape2(value.name)}"`);
          header += `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
          yield textEncoder2.encode(header);
          if (value.stream) {
            yield* value.stream();
          } else {
            yield value;
          }
          yield linebreak;
        }
      }
      yield textEncoder2.encode(`--${boundary}--`);
    }
    const stream2 = Readable2.from(asyncIterator2());
    return {
      stream: stream2,
      contentType: `multipart/form-data; boundary=${boundary}`
    };
  }
  formData.isFormDataLike = isFormDataLike;
  formData.formDataToStream = formDataToStream2;
  return formData;
}
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request.exports;
  hasRequiredRequest = 1;
  const { Readable: Readable2, addAbortSignal } = require$$0$7;
  const util2 = require$$0$2;
  const cookie = requireDist();
  const assert2 = require$$0$9;
  const { createDeprecation: createDeprecation2 } = processWarningExports;
  const parseURL = requireParseUrl();
  const { isFormDataLike, formDataToStream: formDataToStream2 } = requireFormData();
  const { EventEmitter: EventEmitter2 } = require$$0$3;
  const FST_LIGHTMYREQUEST_DEP01 = createDeprecation2({
    name: "FastifyDeprecationLightMyRequest",
    code: "FST_LIGHTMYREQUEST_DEP01",
    message: 'You are accessing "request.connection", use "request.socket" instead.'
  });
  function hostHeaderFromURL(parsedURL) {
    return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
  }
  class MockSocket extends EventEmitter2 {
    constructor(remoteAddress) {
      super();
      this.remoteAddress = remoteAddress;
    }
  }
  function CustomRequest(options) {
    return new _CustomLMRRequest(this);
    function _CustomLMRRequest(obj) {
      Request2.call(obj, {
        ...options,
        Request: void 0
      });
      Object.assign(this, obj);
      for (const fn of Object.keys(Request2.prototype)) {
        this.constructor.prototype[fn] = Request2.prototype[fn];
      }
      util2.inherits(this.constructor, options.Request);
      return this;
    }
  }
  function Request2(options) {
    Readable2.call(this, {
      autoDestroy: false
    });
    const parsedURL = parseURL(options.url || options.path, options.query);
    this.url = parsedURL.pathname + parsedURL.search;
    this.aborted = false;
    this.httpVersionMajor = 1;
    this.httpVersionMinor = 1;
    this.httpVersion = "1.1";
    this.method = options.method ? options.method.toUpperCase() : "GET";
    this.headers = {};
    this.rawHeaders = [];
    const headers2 = options.headers || {};
    for (const field in headers2) {
      const fieldLowerCase = field.toLowerCase();
      if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers2[field] === void 0) {
        this.headers[fieldLowerCase] = void 0;
        continue;
      }
      const value = headers2[field];
      assert2(value !== void 0, 'invalid value "undefined" for header ' + field);
      this.headers[fieldLowerCase] = "" + value;
    }
    if ("user-agent" in this.headers === false) {
      this.headers["user-agent"] = "lightMyRequest";
    }
    this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
    if (options.cookies) {
      const { cookies: cookies2 } = options;
      const cookieValues = Object.keys(cookies2).map((key) => cookie.serialize(key, cookies2[key]));
      if (this.headers.cookie) {
        cookieValues.unshift(this.headers.cookie);
      }
      this.headers.cookie = cookieValues.join("; ");
    }
    this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
    Object.defineProperty(this, "connection", {
      get() {
        FST_LIGHTMYREQUEST_DEP01();
        return this.socket;
      },
      configurable: true
    });
    let payload = options.payload || options.body || null;
    let payloadResume = payload && typeof payload.resume === "function";
    if (isFormDataLike(payload)) {
      const stream2 = formDataToStream2(payload);
      payload = stream2.stream;
      payloadResume = true;
      this.headers["content-type"] = stream2.contentType;
      this.headers["transfer-encoding"] = "chunked";
    }
    if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
      payload = JSON.stringify(payload);
      if ("content-type" in this.headers === false) {
        this.headers["content-type"] = "application/json";
      }
    }
    if (payload && !payloadResume && !Object.hasOwn(this.headers, "content-length")) {
      this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
    }
    for (const header of Object.keys(this.headers)) {
      this.rawHeaders.push(header, this.headers[header]);
    }
    this._lightMyRequest = {
      payload,
      isDone: false,
      simulate: options.simulate || {},
      payloadAsStream: options.payloadAsStream,
      signal: options.signal
    };
    const signal = options.signal;
    if (signal) {
      addAbortSignal(signal, this);
    }
    {
      const payload2 = this._lightMyRequest.payload;
      if (payload2 == null ? void 0 : payload2._readableState) {
        this._read = readStream2;
        payload2.on("error", (err2) => {
          this.destroy(err2);
        });
        payload2.on("end", () => {
          this.push(null);
        });
      } else {
        this._read = readEverythingElse;
      }
    }
    return this;
  }
  function readStream2() {
    const payload = this._lightMyRequest.payload;
    let more = true;
    let pushed = false;
    let chunk;
    while (more && (chunk = payload.read())) {
      pushed = true;
      more = this.push(chunk);
    }
    if (more && !pushed) {
      this._lightMyRequest.payload.once("readable", this._read.bind(this));
    }
  }
  function readEverythingElse() {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
        return;
      }
      this._lightMyRequest.isDone = true;
      if (this._lightMyRequest.payload) {
        if (this._lightMyRequest.simulate.split) {
          this.push(this._lightMyRequest.payload.slice(0, 1));
          this.push(this._lightMyRequest.payload.slice(1));
        } else {
          this.push(this._lightMyRequest.payload);
        }
      }
      if (this._lightMyRequest.simulate.error) {
        this.emit("error", new Error("Simulated"));
      }
      if (this._lightMyRequest.simulate.close) {
        this.emit("close");
      }
      if (this._lightMyRequest.simulate.end !== false) {
        this.push(null);
      }
    });
  }
  util2.inherits(Request2, Readable2);
  util2.inherits(CustomRequest, Request2);
  Request2.prototype.destroy = function(error2) {
    if (this.destroyed || this._lightMyRequest.isDone) return;
    this.destroyed = true;
    if (error2) {
      this._error = true;
      process.nextTick(() => this.emit("error", error2));
    }
    process.nextTick(() => this.emit("close"));
  };
  request.exports = Request2;
  request.exports.Request = Request2;
  request.exports.CustomRequest = CustomRequest;
  return request.exports;
}
var setCookie = { exports: {} };
var hasRequiredSetCookie;
function requireSetCookie() {
  if (hasRequiredSetCookie) return setCookie.exports;
  hasRequiredSetCookie = 1;
  var defaultParseOptions = {
    decodeValues: true,
    map: false,
    silent: false
  };
  function isNonEmptyString(str2) {
    return typeof str2 === "string" && !!str2.trim();
  }
  function parseString2(setCookieValue, options) {
    var parts = setCookieValue.split(";").filter(isNonEmptyString);
    var nameValuePairStr = parts.shift();
    var parsed = parseNameValuePair(nameValuePairStr);
    var name = parsed.name;
    var value = parsed.value;
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    try {
      value = options.decodeValues ? decodeURIComponent(value) : value;
    } catch (e) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
        e
      );
    }
    var cookie = {
      name,
      value
    };
    parts.forEach(function(part) {
      var sides = part.split("=");
      var key = sides.shift().trimLeft().toLowerCase();
      var value2 = sides.join("=");
      if (key === "expires") {
        cookie.expires = new Date(value2);
      } else if (key === "max-age") {
        cookie.maxAge = parseInt(value2, 10);
      } else if (key === "secure") {
        cookie.secure = true;
      } else if (key === "httponly") {
        cookie.httpOnly = true;
      } else if (key === "samesite") {
        cookie.sameSite = value2;
      } else if (key === "partitioned") {
        cookie.partitioned = true;
      } else {
        cookie[key] = value2;
      }
    });
    return cookie;
  }
  function parseNameValuePair(nameValuePairStr) {
    var name = "";
    var value = "";
    var nameValueArr = nameValuePairStr.split("=");
    if (nameValueArr.length > 1) {
      name = nameValueArr.shift();
      value = nameValueArr.join("=");
    } else {
      value = nameValuePairStr;
    }
    return { name, value };
  }
  function parse2(input, options) {
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    if (!input) {
      if (!options.map) {
        return [];
      } else {
        return {};
      }
    }
    if (input.headers) {
      if (typeof input.headers.getSetCookie === "function") {
        input = input.headers.getSetCookie();
      } else if (input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          );
        }
        input = sch;
      }
    }
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!options.map) {
      return input.filter(isNonEmptyString).map(function(str2) {
        return parseString2(str2, options);
      });
    } else {
      var cookies2 = {};
      return input.filter(isNonEmptyString).reduce(function(cookies3, str2) {
        var cookie = parseString2(str2, options);
        cookies3[cookie.name] = cookie;
        return cookies3;
      }, cookies2);
    }
  }
  function splitCookiesString(cookiesString) {
    if (Array.isArray(cookiesString)) {
      return cookiesString;
    }
    if (typeof cookiesString !== "string") {
      return [];
    }
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace2() {
      while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
        pos += 1;
      }
      return pos < cookiesString.length;
    }
    function notSpecialChar() {
      ch = cookiesString.charAt(pos);
      return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while (pos < cookiesString.length) {
      start = pos;
      cookiesSeparatorFound = false;
      while (skipWhitespace2()) {
        ch = cookiesString.charAt(pos);
        if (ch === ",") {
          lastComma = pos;
          pos += 1;
          skipWhitespace2();
          nextStart = pos;
          while (pos < cookiesString.length && notSpecialChar()) {
            pos += 1;
          }
          if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
            cookiesSeparatorFound = true;
            pos = nextStart;
            cookiesStrings.push(cookiesString.substring(start, lastComma));
            start = pos;
          } else {
            pos = lastComma + 1;
          }
        } else {
          pos += 1;
        }
      }
      if (!cookiesSeparatorFound || pos >= cookiesString.length) {
        cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
    }
    return cookiesStrings;
  }
  setCookie.exports = parse2;
  setCookie.exports.parse = parse2;
  setCookie.exports.parseString = parseString2;
  setCookie.exports.splitCookiesString = splitCookiesString;
  return setCookie.exports;
}
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  const http3 = require$$0$4;
  const { Writable: Writable2, Readable: Readable2, addAbortSignal } = require$$0$7;
  const util2 = require$$0$2;
  const setCookie2 = requireSetCookie();
  function Response2(req2, onEnd, reject) {
    var _a2;
    http3.ServerResponse.call(this, req2);
    if ((_a2 = req2._lightMyRequest) == null ? void 0 : _a2.payloadAsStream) {
      const read = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable2({ read }) };
      const signal = req2._lightMyRequest.signal;
      if (signal) {
        addAbortSignal(signal, this._lightMyRequest.stream);
      }
    } else {
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    }
    this.setHeader("foo", "bar");
    this.removeHeader("foo");
    this.assignSocket(getNullSocket());
    this._promiseCallback = typeof reject === "function";
    let called = false;
    const onEndSuccess = (payload) => {
      if (called) return;
      called = true;
      if (this._promiseCallback) {
        return process.nextTick(() => onEnd(payload));
      }
      process.nextTick(() => onEnd(null, payload));
    };
    this._lightMyRequest.onEndSuccess = onEndSuccess;
    let finished = false;
    const onEndFailure = (err2) => {
      if (called) {
        if (this._lightMyRequest.stream && !finished) {
          if (!err2) {
            err2 = new Error("response destroyed before completion");
            err2.code = "LIGHT_ECONNRESET";
          }
          this._lightMyRequest.stream.destroy(err2);
          this._lightMyRequest.stream.on("error", () => {
          });
        }
        return;
      }
      called = true;
      if (!err2) {
        err2 = new Error("response destroyed before completion");
        err2.code = "LIGHT_ECONNRESET";
      }
      if (this._promiseCallback) {
        return process.nextTick(() => reject(err2));
      }
      process.nextTick(() => onEnd(err2, null));
    };
    if (this._lightMyRequest.stream) {
      this.once("finish", () => {
        finished = true;
        this._lightMyRequest.stream.push(null);
      });
    } else {
      this.once("finish", () => {
        const res2 = generatePayload(this);
        res2.raw.req = req2;
        onEndSuccess(res2);
      });
    }
    this.connection.once("error", onEndFailure);
    this.once("error", onEndFailure);
    this.once("close", onEndFailure);
  }
  util2.inherits(Response2, http3.ServerResponse);
  Response2.prototype.setTimeout = function(msecs, callback) {
    this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, msecs);
    this.on("timeout", callback);
    return this;
  };
  Response2.prototype.writeHead = function() {
    const result = http3.ServerResponse.prototype.writeHead.apply(this, arguments);
    copyHeaders(this);
    if (this._lightMyRequest.stream) {
      this._lightMyRequest.onEndSuccess(generatePayload(this));
    }
    return result;
  };
  Response2.prototype.write = function(data, encoding, callback) {
    if (this.timeoutHandle) {
      clearTimeout(this.timeoutHandle);
    }
    http3.ServerResponse.prototype.write.call(this, data, encoding, callback);
    if (this._lightMyRequest.stream) {
      return this._lightMyRequest.stream.push(Buffer.from(data, encoding));
    } else {
      this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
      return true;
    }
  };
  Response2.prototype.end = function(data, encoding, callback) {
    if (data) {
      this.write(data, encoding);
    }
    http3.ServerResponse.prototype.end.call(this, callback);
    this.emit("finish");
    this.destroy();
  };
  Response2.prototype.destroy = function(error2) {
    if (this.destroyed) return;
    this.destroyed = true;
    if (error2) {
      process.nextTick(() => this.emit("error", error2));
    }
    process.nextTick(() => this.emit("close"));
  };
  Response2.prototype.addTrailers = function(trailers) {
    for (const key in trailers) {
      this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
    }
  };
  function generatePayload(response2) {
    if (response2._lightMyRequest.headers === null) {
      copyHeaders(response2);
    }
    serializeHeaders(response2);
    const res2 = {
      raw: {
        res: response2
      },
      headers: response2._lightMyRequest.headers,
      statusCode: response2.statusCode,
      statusMessage: response2.statusMessage,
      trailers: {},
      get cookies() {
        return setCookie2.parse(this);
      }
    };
    res2.trailers = response2._lightMyRequest.trailers;
    if (response2._lightMyRequest.payloadChunks) {
      const rawBuffer = Buffer.concat(response2._lightMyRequest.payloadChunks);
      res2.rawPayload = rawBuffer;
      res2.payload = rawBuffer.toString();
      res2.body = res2.payload;
      res2.json = function parseJsonPayload() {
        return JSON.parse(res2.payload);
      };
    } else {
      res2.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    }
    res2.stream = function streamPayload() {
      if (response2._lightMyRequest.stream) {
        return response2._lightMyRequest.stream;
      }
      return Readable2.from(response2._lightMyRequest.payloadChunks);
    };
    return res2;
  }
  function getNullSocket() {
    return new Writable2({
      write(_chunk, _encoding, callback) {
        setImmediate(callback);
      }
    });
  }
  function serializeHeaders(response2) {
    const headers2 = response2._lightMyRequest.headers;
    for (const headerName of Object.keys(headers2)) {
      const headerValue = headers2[headerName];
      if (Array.isArray(headerValue)) {
        headers2[headerName] = headerValue.map((value) => "" + value);
      } else {
        headers2[headerName] = "" + headerValue;
      }
    }
  }
  function copyHeaders(response2) {
    response2._lightMyRequest.headers = Object.assign({}, response2.getHeaders());
    ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
      var _a2;
      const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
      const field = (_a2 = response2._header) == null ? void 0 : _a2.match(regex);
      if (field) {
        response2._lightMyRequest.headers[name.toLowerCase()] = field[1];
      }
    });
  }
  response = Response2;
  return response;
}
var configValidator = { exports: {} };
var hasRequiredConfigValidator;
function requireConfigValidator() {
  if (hasRequiredConfigValidator) return configValidator.exports;
  hasRequiredConfigValidator = 1;
  configValidator.exports = validate102;
  configValidator.exports.default = validate102;
  const schema112 = { "properties": { "method": { "enum": ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] } } };
  function validate102(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors2 = 0;
    const _errs1 = errors2;
    let valid0 = false;
    let passing0 = null;
    const _errs2 = errors2;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.url === void 0 && (missing0 = "url")) {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors2++;
      }
    }
    var _valid0 = _errs2 === errors2;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs3 = errors2;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing1;
      if (data.path === void 0 && (missing1 = "path")) {
        const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors2++;
      }
    }
    var _valid0 = _errs3 === errors2;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors2++;
      validate102.errors = vErrors;
      return false;
    } else {
      errors2 = _errs1;
      if (vErrors !== null) {
        if (_errs1) {
          vErrors.length = _errs1;
        } else {
          vErrors = null;
        }
      }
    }
    if (errors2 === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.url !== void 0) {
          let data0 = data.url;
          const _errs5 = errors2;
          const _errs6 = errors2;
          let valid2 = false;
          let passing1 = null;
          const _errs7 = errors2;
          if (typeof data0 !== "string") {
            let dataType0 = typeof data0;
            let coerced0 = void 0;
            if (!(coerced0 !== void 0)) {
              if (dataType0 == "number" || dataType0 == "boolean") {
                coerced0 = "" + data0;
              } else if (data0 === null) {
                coerced0 = "";
              } else {
                const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors2++;
              }
            }
            if (coerced0 !== void 0) {
              data0 = coerced0;
              if (data !== void 0) {
                data["url"] = coerced0;
              }
            }
          }
          var _valid1 = _errs7 === errors2;
          if (_valid1) {
            valid2 = true;
            passing1 = 0;
          }
          const _errs9 = errors2;
          if (errors2 === _errs9) {
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              let missing2;
              if (data0.pathname === void 0 && (missing2 = "pathname")) {
                const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors2++;
              } else {
                if (data0.protocol !== void 0) {
                  let data1 = data0.protocol;
                  const _errs12 = errors2;
                  if (typeof data1 !== "string") {
                    let dataType1 = typeof data1;
                    let coerced1 = void 0;
                    if (!(coerced1 !== void 0)) {
                      if (dataType1 == "number" || dataType1 == "boolean") {
                        coerced1 = "" + data1;
                      } else if (data1 === null) {
                        coerced1 = "";
                      } else {
                        const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err5];
                        } else {
                          vErrors.push(err5);
                        }
                        errors2++;
                      }
                    }
                    if (coerced1 !== void 0) {
                      data1 = coerced1;
                      if (data0 !== void 0) {
                        data0["protocol"] = coerced1;
                      }
                    }
                  }
                  var valid3 = _errs12 === errors2;
                } else {
                  var valid3 = true;
                }
                if (valid3) {
                  if (data0.hostname !== void 0) {
                    let data2 = data0.hostname;
                    const _errs14 = errors2;
                    if (typeof data2 !== "string") {
                      let dataType2 = typeof data2;
                      let coerced2 = void 0;
                      if (!(coerced2 !== void 0)) {
                        if (dataType2 == "number" || dataType2 == "boolean") {
                          coerced2 = "" + data2;
                        } else if (data2 === null) {
                          coerced2 = "";
                        } else {
                          const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err6];
                          } else {
                            vErrors.push(err6);
                          }
                          errors2++;
                        }
                      }
                      if (coerced2 !== void 0) {
                        data2 = coerced2;
                        if (data0 !== void 0) {
                          data0["hostname"] = coerced2;
                        }
                      }
                    }
                    var valid3 = _errs14 === errors2;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.pathname !== void 0) {
                      let data3 = data0.pathname;
                      const _errs16 = errors2;
                      if (typeof data3 !== "string") {
                        let dataType3 = typeof data3;
                        let coerced3 = void 0;
                        if (!(coerced3 !== void 0)) {
                          if (dataType3 == "number" || dataType3 == "boolean") {
                            coerced3 = "" + data3;
                          } else if (data3 === null) {
                            coerced3 = "";
                          } else {
                            const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err7];
                            } else {
                              vErrors.push(err7);
                            }
                            errors2++;
                          }
                        }
                        if (coerced3 !== void 0) {
                          data3 = coerced3;
                          if (data0 !== void 0) {
                            data0["pathname"] = coerced3;
                          }
                        }
                      }
                      var valid3 = _errs16 === errors2;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              }
            } else {
              const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors2++;
            }
          }
          var _valid1 = _errs9 === errors2;
          if (_valid1 && valid2) {
            valid2 = false;
            passing1 = [passing1, 1];
          } else {
            if (_valid1) {
              valid2 = true;
              passing1 = 1;
            }
          }
          if (!valid2) {
            const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors2++;
            validate102.errors = vErrors;
            return false;
          } else {
            errors2 = _errs6;
            if (vErrors !== null) {
              if (_errs6) {
                vErrors.length = _errs6;
              } else {
                vErrors = null;
              }
            }
          }
          var valid1 = _errs5 === errors2;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.path !== void 0) {
            let data4 = data.path;
            const _errs18 = errors2;
            const _errs19 = errors2;
            let valid4 = false;
            let passing2 = null;
            const _errs20 = errors2;
            if (typeof data4 !== "string") {
              let dataType4 = typeof data4;
              let coerced4 = void 0;
              if (!(coerced4 !== void 0)) {
                if (dataType4 == "number" || dataType4 == "boolean") {
                  coerced4 = "" + data4;
                } else if (data4 === null) {
                  coerced4 = "";
                } else {
                  const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors2++;
                }
              }
              if (coerced4 !== void 0) {
                data4 = coerced4;
                if (data !== void 0) {
                  data["path"] = coerced4;
                }
              }
            }
            var _valid2 = _errs20 === errors2;
            if (_valid2) {
              valid4 = true;
              passing2 = 0;
            }
            const _errs22 = errors2;
            if (errors2 === _errs22) {
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                let missing3;
                if (data4.pathname === void 0 && (missing3 = "pathname")) {
                  const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors2++;
                } else {
                  if (data4.protocol !== void 0) {
                    let data5 = data4.protocol;
                    const _errs25 = errors2;
                    if (typeof data5 !== "string") {
                      let dataType5 = typeof data5;
                      let coerced5 = void 0;
                      if (!(coerced5 !== void 0)) {
                        if (dataType5 == "number" || dataType5 == "boolean") {
                          coerced5 = "" + data5;
                        } else if (data5 === null) {
                          coerced5 = "";
                        } else {
                          const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err12];
                          } else {
                            vErrors.push(err12);
                          }
                          errors2++;
                        }
                      }
                      if (coerced5 !== void 0) {
                        data5 = coerced5;
                        if (data4 !== void 0) {
                          data4["protocol"] = coerced5;
                        }
                      }
                    }
                    var valid5 = _errs25 === errors2;
                  } else {
                    var valid5 = true;
                  }
                  if (valid5) {
                    if (data4.hostname !== void 0) {
                      let data6 = data4.hostname;
                      const _errs27 = errors2;
                      if (typeof data6 !== "string") {
                        let dataType6 = typeof data6;
                        let coerced6 = void 0;
                        if (!(coerced6 !== void 0)) {
                          if (dataType6 == "number" || dataType6 == "boolean") {
                            coerced6 = "" + data6;
                          } else if (data6 === null) {
                            coerced6 = "";
                          } else {
                            const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err13];
                            } else {
                              vErrors.push(err13);
                            }
                            errors2++;
                          }
                        }
                        if (coerced6 !== void 0) {
                          data6 = coerced6;
                          if (data4 !== void 0) {
                            data4["hostname"] = coerced6;
                          }
                        }
                      }
                      var valid5 = _errs27 === errors2;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data4.pathname !== void 0) {
                        let data7 = data4.pathname;
                        const _errs29 = errors2;
                        if (typeof data7 !== "string") {
                          let dataType7 = typeof data7;
                          let coerced7 = void 0;
                          if (!(coerced7 !== void 0)) {
                            if (dataType7 == "number" || dataType7 == "boolean") {
                              coerced7 = "" + data7;
                            } else if (data7 === null) {
                              coerced7 = "";
                            } else {
                              const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err14];
                              } else {
                                vErrors.push(err14);
                              }
                              errors2++;
                            }
                          }
                          if (coerced7 !== void 0) {
                            data7 = coerced7;
                            if (data4 !== void 0) {
                              data4["pathname"] = coerced7;
                            }
                          }
                        }
                        var valid5 = _errs29 === errors2;
                      } else {
                        var valid5 = true;
                      }
                    }
                  }
                }
              } else {
                const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors2++;
              }
            }
            var _valid2 = _errs22 === errors2;
            if (_valid2 && valid4) {
              valid4 = false;
              passing2 = [passing2, 1];
            } else {
              if (_valid2) {
                valid4 = true;
                passing2 = 1;
              }
            }
            if (!valid4) {
              const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors2++;
              validate102.errors = vErrors;
              return false;
            } else {
              errors2 = _errs19;
              if (vErrors !== null) {
                if (_errs19) {
                  vErrors.length = _errs19;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs18 === errors2;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.cookies !== void 0) {
              let data8 = data.cookies;
              const _errs31 = errors2;
              if (errors2 === _errs31) {
                if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                  validate102.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid1 = _errs31 === errors2;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data.headers !== void 0) {
                let data9 = data.headers;
                const _errs34 = errors2;
                if (errors2 === _errs34) {
                  if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                    validate102.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs34 === errors2;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data.query !== void 0) {
                  let data10 = data.query;
                  const _errs37 = errors2;
                  const _errs38 = errors2;
                  let valid6 = false;
                  const _errs39 = errors2;
                  if (errors2 === _errs39) {
                    if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                      const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors2++;
                    }
                  }
                  var _valid3 = _errs39 === errors2;
                  valid6 = valid6 || _valid3;
                  if (!valid6) {
                    const _errs42 = errors2;
                    if (typeof data10 !== "string") {
                      let dataType8 = typeof data10;
                      let coerced8 = void 0;
                      if (!(coerced8 !== void 0)) {
                        if (dataType8 == "number" || dataType8 == "boolean") {
                          coerced8 = "" + data10;
                        } else if (data10 === null) {
                          coerced8 = "";
                        } else {
                          const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err18];
                          } else {
                            vErrors.push(err18);
                          }
                          errors2++;
                        }
                      }
                      if (coerced8 !== void 0) {
                        data10 = coerced8;
                        if (data !== void 0) {
                          data["query"] = coerced8;
                        }
                      }
                    }
                    var _valid3 = _errs42 === errors2;
                    valid6 = valid6 || _valid3;
                  }
                  if (!valid6) {
                    const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    if (vErrors === null) {
                      vErrors = [err19];
                    } else {
                      vErrors.push(err19);
                    }
                    errors2++;
                    validate102.errors = vErrors;
                    return false;
                  } else {
                    errors2 = _errs38;
                    if (vErrors !== null) {
                      if (_errs38) {
                        vErrors.length = _errs38;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid1 = _errs37 === errors2;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data.simulate !== void 0) {
                    let data11 = data.simulate;
                    const _errs44 = errors2;
                    if (errors2 === _errs44) {
                      if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                        if (data11.end !== void 0) {
                          let data12 = data11.end;
                          const _errs46 = errors2;
                          if (typeof data12 !== "boolean") {
                            let coerced9 = void 0;
                            if (!(coerced9 !== void 0)) {
                              if (data12 === "false" || data12 === 0 || data12 === null) {
                                coerced9 = false;
                              } else if (data12 === "true" || data12 === 1) {
                                coerced9 = true;
                              } else {
                                validate102.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced9 !== void 0) {
                              data12 = coerced9;
                              if (data11 !== void 0) {
                                data11["end"] = coerced9;
                              }
                            }
                          }
                          var valid7 = _errs46 === errors2;
                        } else {
                          var valid7 = true;
                        }
                        if (valid7) {
                          if (data11.split !== void 0) {
                            let data13 = data11.split;
                            const _errs48 = errors2;
                            if (typeof data13 !== "boolean") {
                              let coerced10 = void 0;
                              if (!(coerced10 !== void 0)) {
                                if (data13 === "false" || data13 === 0 || data13 === null) {
                                  coerced10 = false;
                                } else if (data13 === "true" || data13 === 1) {
                                  coerced10 = true;
                                } else {
                                  validate102.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced10 !== void 0) {
                                data13 = coerced10;
                                if (data11 !== void 0) {
                                  data11["split"] = coerced10;
                                }
                              }
                            }
                            var valid7 = _errs48 === errors2;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.error !== void 0) {
                              let data14 = data11.error;
                              const _errs50 = errors2;
                              if (typeof data14 !== "boolean") {
                                let coerced11 = void 0;
                                if (!(coerced11 !== void 0)) {
                                  if (data14 === "false" || data14 === 0 || data14 === null) {
                                    coerced11 = false;
                                  } else if (data14 === "true" || data14 === 1) {
                                    coerced11 = true;
                                  } else {
                                    validate102.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced11 !== void 0) {
                                  data14 = coerced11;
                                  if (data11 !== void 0) {
                                    data11["error"] = coerced11;
                                  }
                                }
                              }
                              var valid7 = _errs50 === errors2;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.close !== void 0) {
                                let data15 = data11.close;
                                const _errs52 = errors2;
                                if (typeof data15 !== "boolean") {
                                  let coerced12 = void 0;
                                  if (!(coerced12 !== void 0)) {
                                    if (data15 === "false" || data15 === 0 || data15 === null) {
                                      coerced12 = false;
                                    } else if (data15 === "true" || data15 === 1) {
                                      coerced12 = true;
                                    } else {
                                      validate102.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced12 !== void 0) {
                                    data15 = coerced12;
                                    if (data11 !== void 0) {
                                      data11["close"] = coerced12;
                                    }
                                  }
                                }
                                var valid7 = _errs52 === errors2;
                              } else {
                                var valid7 = true;
                              }
                            }
                          }
                        }
                      } else {
                        validate102.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid1 = _errs44 === errors2;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data.authority !== void 0) {
                      let data16 = data.authority;
                      const _errs54 = errors2;
                      if (typeof data16 !== "string") {
                        let dataType13 = typeof data16;
                        let coerced13 = void 0;
                        if (!(coerced13 !== void 0)) {
                          if (dataType13 == "number" || dataType13 == "boolean") {
                            coerced13 = "" + data16;
                          } else if (data16 === null) {
                            coerced13 = "";
                          } else {
                            validate102.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                        }
                        if (coerced13 !== void 0) {
                          data16 = coerced13;
                          if (data !== void 0) {
                            data["authority"] = coerced13;
                          }
                        }
                      }
                      var valid1 = _errs54 === errors2;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data.remoteAddress !== void 0) {
                        let data17 = data.remoteAddress;
                        const _errs56 = errors2;
                        if (typeof data17 !== "string") {
                          let dataType14 = typeof data17;
                          let coerced14 = void 0;
                          if (!(coerced14 !== void 0)) {
                            if (dataType14 == "number" || dataType14 == "boolean") {
                              coerced14 = "" + data17;
                            } else if (data17 === null) {
                              coerced14 = "";
                            } else {
                              validate102.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced14 !== void 0) {
                            data17 = coerced14;
                            if (data !== void 0) {
                              data["remoteAddress"] = coerced14;
                            }
                          }
                        }
                        var valid1 = _errs56 === errors2;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data.method !== void 0) {
                          let data18 = data.method;
                          const _errs58 = errors2;
                          if (typeof data18 !== "string") {
                            let dataType15 = typeof data18;
                            let coerced15 = void 0;
                            if (!(coerced15 !== void 0)) {
                              if (dataType15 == "number" || dataType15 == "boolean") {
                                coerced15 = "" + data18;
                              } else if (data18 === null) {
                                coerced15 = "";
                              } else {
                                validate102.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced15 !== void 0) {
                              data18 = coerced15;
                              if (data !== void 0) {
                                data["method"] = coerced15;
                              }
                            }
                          }
                          if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "QUERY" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "query" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                            validate102.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema112.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs58 === errors2;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data.validate !== void 0) {
                            let data19 = data.validate;
                            const _errs60 = errors2;
                            if (typeof data19 !== "boolean") {
                              let coerced16 = void 0;
                              if (!(coerced16 !== void 0)) {
                                if (data19 === "false" || data19 === 0 || data19 === null) {
                                  coerced16 = false;
                                } else if (data19 === "true" || data19 === 1) {
                                  coerced16 = true;
                                } else {
                                  validate102.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced16 !== void 0) {
                                data19 = coerced16;
                                if (data !== void 0) {
                                  data["validate"] = coerced16;
                                }
                              }
                            }
                            var valid1 = _errs60 === errors2;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate102.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate102.errors = vErrors;
    return errors2 === 0;
  }
  return configValidator.exports;
}
var hasRequiredLightMyRequest;
function requireLightMyRequest() {
  if (hasRequiredLightMyRequest) return lightMyRequest$1.exports;
  hasRequiredLightMyRequest = 1;
  const assert2 = require$$0$9;
  const Request2 = requireRequest();
  const Response2 = requireResponse();
  const errorMessage = "The dispatch function has already been invoked";
  const optsValidator = requireConfigValidator();
  function inject(dispatchFunc, options, callback) {
    if (callback === void 0) {
      return new Chain(dispatchFunc, options);
    } else {
      return doInject(dispatchFunc, options, callback);
    }
  }
  function supportStream1(req2, next) {
    const payload = req2._lightMyRequest.payload;
    if (!payload || payload._readableState || typeof payload.resume !== "function") {
      return next();
    }
    const chunks = [];
    payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    payload.on("end", () => {
      const payload2 = Buffer.concat(chunks);
      req2.headers["content-length"] = req2.headers["content-length"] || "" + payload2.length;
      delete req2.headers["transfer-encoding"];
      req2._lightMyRequest.payload = payload2;
      return next();
    });
    payload.resume();
  }
  function makeRequest(dispatchFunc, server2, req2, res2) {
    req2.once("error", function(err2) {
      if (this.destroyed) res2.destroy(err2);
    });
    req2.once("close", function() {
      if (this.destroyed && !this._error) {
        res2.destroy();
      }
    });
    return supportStream1(req2, () => dispatchFunc.call(server2, req2, res2));
  }
  function doInject(dispatchFunc, options, callback) {
    options = typeof options === "string" ? { url: options } : options;
    if (options.validate !== false) {
      assert2(typeof dispatchFunc === "function", "dispatchFunc should be a function");
      const isOptionValid = optsValidator(options);
      if (!isOptionValid) {
        throw new Error(optsValidator.errors.map((e) => e.message));
      }
    }
    const server2 = options.server || {};
    const RequestConstructor = options.Request ? Request2.CustomRequest : Request2;
    if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response2.prototype);
    }
    if (typeof callback === "function") {
      const req2 = new RequestConstructor(options);
      const res2 = new Response2(req2, callback);
      return makeRequest(dispatchFunc, server2, req2, res2);
    } else {
      return new Promise((resolve2, reject) => {
        const req2 = new RequestConstructor(options);
        const res2 = new Response2(req2, resolve2, reject);
        makeRequest(dispatchFunc, server2, req2, res2);
      });
    }
  }
  function Chain(dispatch, option) {
    if (typeof option === "string") {
      this.option = { url: option };
    } else {
      this.option = Object.assign({}, option);
    }
    this.dispatch = dispatch;
    this._hasInvoked = false;
    this._promise = null;
    if (this.option.autoStart !== false) {
      process.nextTick(() => {
        if (!this._hasInvoked) {
          this.end();
        }
      });
    }
  }
  const httpMethods2 = [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ];
  httpMethods2.forEach((method) => {
    Chain.prototype[method] = function(url2) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option.url = url2;
      this.option.method = method.toUpperCase();
      return this;
    };
  });
  const chainMethods = [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ];
  chainMethods.forEach((method) => {
    Chain.prototype[method] = function(value) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option[method] = value;
      return this;
    };
  });
  Chain.prototype.end = function(callback) {
    if (this._hasInvoked === true || this._promise) {
      throw new Error(errorMessage);
    }
    this._hasInvoked = true;
    if (typeof callback === "function") {
      doInject(this.dispatch, this.option, callback);
    } else {
      this._promise = doInject(this.dispatch, this.option);
      return this._promise;
    }
  };
  Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
    if (method === "constructor") return;
    Chain.prototype[method] = function(...args) {
      if (!this._promise) {
        if (this._hasInvoked === true) {
          throw new Error(errorMessage);
        }
        this._hasInvoked = true;
        this._promise = doInject(this.dispatch, this.option);
      }
      return this._promise[method](...args);
    };
  });
  function isInjection(obj) {
    var _a2;
    return obj instanceof Request2 || obj instanceof Response2 || ((_a2 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a2.name) === "_CustomLMRRequest";
  }
  lightMyRequest$1.exports = inject;
  lightMyRequest$1.exports.default = inject;
  lightMyRequest$1.exports.inject = inject;
  lightMyRequest$1.exports.isInjection = isInjection;
  return lightMyRequest$1.exports;
}
const VERSION$2 = "5.2.2";
const Avvio = boot;
const http$2 = require$$0$4;
const diagnostics = require$$1$1;
let lightMyRequest;
const {
  kAvvioBoot,
  kChildren,
  kServerBindings,
  kBodyLimit,
  kSupportedHTTPMethods,
  kRoutePrefix,
  kLogLevel,
  kLogSerializers,
  kHooks,
  kSchemaController,
  kRequestAcceptVersion,
  kReplySerializerDefault,
  kContentTypeParser,
  kReply,
  kRequest,
  kFourOhFour,
  kState,
  kOptions,
  kPluginNameChain,
  kSchemaErrorFormatter,
  kErrorHandler,
  kKeepAliveConnections,
  kChildLoggerFactory,
  kGenReqId
} = symbols$1;
const { createServer } = server;
const Reply = replyExports;
const Request$1 = requestExports;
const Context = context;
const decorator = decorate_1;
const ContentTypeParser = contentTypeParserExports;
const SchemaController2 = schemaController;
const { Hooks, hookRunnerApplication, supportedHooks } = hooks;
const { createChildLogger, defaultChildLoggerFactory, createLogger } = loggerFactory;
const pluginUtils = pluginUtilsExports;
const { getGenReqId, reqIdGenFactory } = reqIdGenFactory_1;
const { buildRouting, validateBodyLimitOption } = route;
const build404 = fourOhFour_1;
const getSecuredInitialConfig = initialConfigValidationExports;
const override2 = pluginOverride;
const noopSet2 = noopSet$1;
const {
  appendStackTrace,
  AVVIO_ERRORS_MAP,
  ...errorCodes
} = errorsExports;
const { defaultInitOptions } = getSecuredInitialConfig;
const {
  FST_ERR_ASYNC_CONSTRAINT,
  FST_ERR_BAD_URL,
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
  FST_ERR_OPTIONS_NOT_OBJ,
  FST_ERR_QSP_NOT_FN,
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
  FST_ERR_INSTANCE_ALREADY_LISTENING,
  FST_ERR_REOPENED_CLOSE_SERVER,
  FST_ERR_ROUTE_REWRITE_NOT_STR,
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
  FST_ERR_ERROR_HANDLER_NOT_FN,
  FST_ERR_ROUTE_METHOD_INVALID
} = errorCodes;
const { buildErrorHandler } = errorHandler;
const initChannel = diagnostics.channel("fastify.initialization");
function defaultBuildPrettyMeta(route2) {
  const cleanKeys = {};
  const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
  allowedProps.concat(supportedHooks).forEach((k) => {
    cleanKeys[k] = route2.store[k];
  });
  return Object.assign({}, cleanKeys);
}
function fastify(options) {
  if (options && typeof options !== "object") {
    throw new FST_ERR_OPTIONS_NOT_OBJ();
  } else {
    options = Object.assign({}, options);
  }
  if (options.querystringParser && typeof options.querystringParser !== "function") {
    throw new FST_ERR_QSP_NOT_FN(typeof options.querystringParser);
  }
  if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
    throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
  }
  validateBodyLimitOption(options.bodyLimit);
  const requestIdHeader = typeof options.requestIdHeader === "string" && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : options.requestIdHeader === true && "request-id";
  const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
  const requestIdLogLabel = options.requestIdLogLabel || "reqId";
  const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
  const disableRequestLogging = options.disableRequestLogging || false;
  const ajvOptions = Object.assign({
    customOptions: {},
    plugins: []
  }, options.ajv);
  const frameworkErrors = options.frameworkErrors;
  if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
    throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
  }
  if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
    throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
  }
  const { logger, hasLogger } = createLogger(options);
  options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
  options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
  options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
  options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
  options.logger = logger;
  options.requestIdHeader = requestIdHeader;
  options.requestIdLogLabel = requestIdLogLabel;
  options.disableRequestLogging = disableRequestLogging;
  options.ajv = ajvOptions;
  options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
  const initialConfig = getSecuredInitialConfig(options);
  options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
  const router = buildRouting({
    config: {
      defaultRoute,
      onBadUrl,
      constraints: options.constraints,
      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
      ignoreDuplicateSlashes: options.ignoreDuplicateSlashes || defaultInitOptions.ignoreDuplicateSlashes,
      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
      caseSensitive: options.caseSensitive,
      allowUnsafeRegex: options.allowUnsafeRegex || defaultInitOptions.allowUnsafeRegex,
      buildPrettyMeta: defaultBuildPrettyMeta,
      querystringParser: options.querystringParser,
      useSemicolonDelimiter: options.useSemicolonDelimiter ?? defaultInitOptions.useSemicolonDelimiter
    }
  });
  const fourOhFour2 = build404(options);
  const httpHandler = wrapRouting(router, options);
  options.http2SessionTimeout = initialConfig.http2SessionTimeout;
  const { server: server2, listen } = createServer(options, httpHandler);
  const serverHasCloseAllConnections = typeof server2.closeAllConnections === "function";
  const serverHasCloseIdleConnections = typeof server2.closeIdleConnections === "function";
  let forceCloseConnections = options.forceCloseConnections;
  if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
    throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE();
  } else if (typeof forceCloseConnections !== "boolean") {
    forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
  }
  const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? /* @__PURE__ */ new Set() : noopSet2();
  const setupResponseListeners2 = Reply.setupResponseListeners;
  const schemaController2 = SchemaController2.buildSchemaController(null, options.schemaController);
  const fastify2 = {
    // Fastify internals
    [kState]: {
      listening: false,
      closing: false,
      started: false,
      ready: false,
      booting: false,
      readyPromise: null
    },
    [kKeepAliveConnections]: keepAliveConnections,
    [kSupportedHTTPMethods]: {
      bodyless: /* @__PURE__ */ new Set([
        // Standard
        "GET",
        "HEAD",
        "TRACE"
      ]),
      bodywith: /* @__PURE__ */ new Set([
        // Standard
        "DELETE",
        "OPTIONS",
        "PATCH",
        "PUT",
        "POST"
      ])
    },
    [kOptions]: options,
    [kChildren]: [],
    [kServerBindings]: [],
    [kBodyLimit]: bodyLimit,
    [kRoutePrefix]: "",
    [kLogLevel]: "",
    [kLogSerializers]: null,
    [kHooks]: new Hooks(),
    [kSchemaController]: schemaController2,
    [kSchemaErrorFormatter]: null,
    [kErrorHandler]: buildErrorHandler(),
    [kChildLoggerFactory]: defaultChildLoggerFactory,
    [kReplySerializerDefault]: null,
    [kContentTypeParser]: new ContentTypeParser(
      bodyLimit,
      options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning,
      options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning
    ),
    [kReply]: Reply.buildReply(Reply),
    [kRequest]: Request$1.buildRequest(Request$1, options.trustProxy),
    [kFourOhFour]: fourOhFour2,
    [pluginUtils.kRegisteredPlugins]: [],
    [kPluginNameChain]: ["fastify"],
    [kAvvioBoot]: null,
    [kGenReqId]: genReqId,
    // routing method
    routing: httpHandler,
    // routes shorthand methods
    delete: function _delete(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "DELETE", url: url2, options: options2, handler });
    },
    get: function _get(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "GET", url: url2, options: options2, handler });
    },
    head: function _head(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "HEAD", url: url2, options: options2, handler });
    },
    trace: function _trace(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "TRACE", url: url2, options: options2, handler });
    },
    patch: function _patch(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "PATCH", url: url2, options: options2, handler });
    },
    post: function _post(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "POST", url: url2, options: options2, handler });
    },
    put: function _put(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "PUT", url: url2, options: options2, handler });
    },
    options: function _options(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: "OPTIONS", url: url2, options: options2, handler });
    },
    all: function _all(url2, options2, handler) {
      return router.prepareRoute.call(this, { method: this.supportedMethods, url: url2, options: options2, handler });
    },
    // extended route
    route: function _route(options2) {
      return router.route.call(this, { options: options2 });
    },
    hasRoute: function _route(options2) {
      return router.hasRoute.call(this, { options: options2 });
    },
    findRoute: function _findRoute(options2) {
      return router.findRoute(options2);
    },
    // expose logger instance
    log: logger,
    // type provider
    withTypeProvider,
    // hooks
    addHook,
    // schemas
    addSchema,
    getSchema: schemaController2.getSchema.bind(schemaController2),
    getSchemas: schemaController2.getSchemas.bind(schemaController2),
    setValidatorCompiler,
    setSerializerCompiler,
    setSchemaController,
    setReplySerializer,
    setSchemaErrorFormatter,
    // set generated request id
    setGenReqId,
    // custom parsers
    addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
    hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
    getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
    defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
    removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
    removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
    // Fastify architecture methods (initialized by Avvio)
    register: null,
    after: null,
    ready: null,
    onClose: null,
    close: null,
    printPlugins: null,
    hasPlugin: function(name) {
      return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
    },
    // http server
    listen,
    server: server2,
    addresses: function() {
      const binded = this[kServerBindings].map((b) => b.address());
      binded.push(this.server.address());
      return binded.filter((adr) => adr);
    },
    // extend fastify objects
    decorate: decorator.add,
    hasDecorator: decorator.exist,
    decorateReply: decorator.decorateReply,
    decorateRequest: decorator.decorateRequest,
    hasRequestDecorator: decorator.existRequest,
    hasReplyDecorator: decorator.existReply,
    addHttpMethod,
    // fake http injection
    inject,
    // pretty print of the registered routes
    printRoutes,
    // custom error handling
    setNotFoundHandler,
    setErrorHandler,
    // child logger
    setChildLoggerFactory,
    // Set fastify initial configuration options read-only object
    initialConfig,
    // constraint strategies
    addConstraintStrategy: router.addConstraintStrategy.bind(router),
    hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
  };
  Object.defineProperties(fastify2, {
    listeningOrigin: {
      get() {
        const address = this.addresses().slice(-1).pop();
        if (typeof address === "string") {
          return address;
        }
        const host = address.family === "IPv6" ? `[${address.address}]` : address.address;
        return `${this[kOptions].https ? "https" : "http"}://${host}:${address.port}`;
      }
    },
    pluginName: {
      configurable: true,
      get() {
        if (this[kPluginNameChain].length > 1) {
          return this[kPluginNameChain].join(" -> ");
        }
        return this[kPluginNameChain][0];
      }
    },
    prefix: {
      configurable: true,
      get() {
        return this[kRoutePrefix];
      }
    },
    validatorCompiler: {
      configurable: true,
      get() {
        return this[kSchemaController].getValidatorCompiler();
      }
    },
    serializerCompiler: {
      configurable: true,
      get() {
        return this[kSchemaController].getSerializerCompiler();
      }
    },
    childLoggerFactory: {
      configurable: true,
      get() {
        return this[kChildLoggerFactory];
      }
    },
    version: {
      configurable: true,
      get() {
        return VERSION$2;
      }
    },
    errorHandler: {
      configurable: true,
      get() {
        return this[kErrorHandler].func;
      }
    },
    genReqId: {
      configurable: true,
      get() {
        return this[kGenReqId];
      }
    },
    supportedMethods: {
      configurable: false,
      get() {
        return [
          ...this[kSupportedHTTPMethods].bodyless,
          ...this[kSupportedHTTPMethods].bodywith
        ];
      }
    }
  });
  if (options.schemaErrorFormatter) {
    validateSchemaErrorFormatter(options.schemaErrorFormatter);
    fastify2[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify2);
  }
  const avvioPluginTimeout = Number(options.pluginTimeout);
  const avvio = Avvio(fastify2, {
    autostart: false,
    timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
    expose: {
      use: "register"
    }
  });
  avvio.override = override2;
  avvio.on("start", () => fastify2[kState].started = true);
  fastify2[kAvvioBoot] = fastify2.ready;
  fastify2.ready = ready;
  fastify2.printPlugins = avvio.prettyPrint.bind(avvio);
  avvio.once("preReady", () => {
    fastify2.onClose((instance, done) => {
      fastify2[kState].closing = true;
      router.closeRoutes();
      hookRunnerApplication("preClose", fastify2[kAvvioBoot], fastify2, function() {
        if (fastify2[kState].listening) {
          if (forceCloseConnections === "idle") {
            instance.server.closeIdleConnections();
          } else if (serverHasCloseAllConnections && forceCloseConnections) {
            instance.server.closeAllConnections();
          } else if (forceCloseConnections === true) {
            for (const conn of fastify2[kKeepAliveConnections]) {
              conn.destroy();
              fastify2[kKeepAliveConnections].delete(conn);
            }
          }
        }
        if (!options.serverFactory || fastify2[kState].listening) {
          instance.server.close(function(err2) {
            if (err2 && err2.code !== "ERR_SERVER_NOT_RUNNING") {
              done(null);
            } else {
              done();
            }
          });
        } else {
          process.nextTick(done, null);
        }
      });
    });
  });
  const onBadUrlContext = new Context({
    server: fastify2,
    config: {}
  });
  fastify2.setNotFoundHandler();
  fourOhFour2.arrange404(fastify2);
  router.setup(options, {
    avvio,
    fourOhFour: fourOhFour2,
    logger,
    hasLogger,
    setupResponseListeners: setupResponseListeners2,
    throwIfAlreadyStarted,
    keepAliveConnections
  });
  server2.on("clientError", options.clientErrorHandler.bind(fastify2));
  if (initChannel.hasSubscribers) {
    initChannel.publish({ fastify: fastify2 });
  }
  if ("asyncDispose" in Symbol) {
    fastify2[Symbol.asyncDispose] = function dispose() {
      return fastify2.close();
    };
  }
  return fastify2;
  function throwIfAlreadyStarted(msg) {
    if (fastify2[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
  }
  function inject(opts, cb) {
    if (lightMyRequest === void 0) {
      lightMyRequest = requireLightMyRequest();
    }
    if (fastify2[kState].started) {
      if (fastify2[kState].closing) {
        const error2 = new FST_ERR_REOPENED_CLOSE_SERVER();
        if (cb) {
          cb(error2);
          return;
        } else {
          return Promise.reject(error2);
        }
      }
      return lightMyRequest(httpHandler, opts, cb);
    }
    if (cb) {
      this.ready((err2) => {
        if (err2) cb(err2, null);
        else lightMyRequest(httpHandler, opts, cb);
      });
    } else {
      return lightMyRequest((req2, res2) => {
        this.ready(function(err2) {
          if (err2) {
            res2.emit("error", err2);
            return;
          }
          httpHandler(req2, res2);
        });
      }, opts);
    }
  }
  function ready(cb) {
    if (this[kState].readyPromise !== null) {
      if (cb != null) {
        this[kState].readyPromise.then(() => cb(null, fastify2), cb);
        return;
      }
      return this[kState].readyPromise;
    }
    let resolveReady;
    let rejectReady;
    process.nextTick(runHooks);
    this[kState].readyPromise = new Promise(function(resolve2, reject) {
      resolveReady = resolve2;
      rejectReady = reject;
    });
    if (!cb) {
      return this[kState].readyPromise;
    } else {
      this[kState].readyPromise.then(() => cb(null, fastify2), cb);
    }
    function runHooks() {
      fastify2[kAvvioBoot]((err2, done) => {
        if (err2 || fastify2[kState].started || fastify2[kState].ready || fastify2[kState].booting) {
          manageErr(err2);
        } else {
          fastify2[kState].booting = true;
          hookRunnerApplication("onReady", fastify2[kAvvioBoot], fastify2, manageErr);
        }
        done();
      });
    }
    function manageErr(err2) {
      err2 = err2 != null && AVVIO_ERRORS_MAP[err2.code] != null ? appendStackTrace(err2, new AVVIO_ERRORS_MAP[err2.code](err2.message)) : err2;
      if (err2) {
        return rejectReady(err2);
      }
      resolveReady(fastify2);
      fastify2[kState].booting = false;
      fastify2[kState].ready = true;
      fastify2[kState].promise = null;
    }
  }
  function withTypeProvider() {
    return this;
  }
  function addHook(name, fn) {
    throwIfAlreadyStarted('Cannot call "addHook"!');
    if (fn == null) {
      throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
    }
    if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
      if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      }
    } else if (name === "onReady" || name === "onListen") {
      if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      }
    } else if (name === "onRequestAbort") {
      if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      }
    } else {
      if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
      }
    }
    if (name === "onClose") {
      this.onClose(fn.bind(this));
    } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
      this[kHooks].add(name, fn);
    } else {
      this.after((err2, done) => {
        _addHook.call(this, name, fn);
        done(err2);
      });
    }
    return this;
    function _addHook(name2, fn2) {
      this[kHooks].add(name2, fn2);
      this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
    }
  }
  function addSchema(schema2) {
    throwIfAlreadyStarted('Cannot call "addSchema"!');
    this[kSchemaController].add(schema2);
    this[kChildren].forEach((child) => child.addSchema(schema2));
    return this;
  }
  function defaultClientErrorHandler(err2, socket) {
    if (err2.code === "ECONNRESET" || socket.destroyed) {
      return;
    }
    let body, errorCode, errorStatus, errorLabel;
    if (err2.code === "ERR_HTTP_REQUEST_TIMEOUT") {
      errorCode = "408";
      errorStatus = http$2.STATUS_CODES[errorCode];
      body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
      errorLabel = "timeout";
    } else if (err2.code === "HPE_HEADER_OVERFLOW") {
      errorCode = "431";
      errorStatus = http$2.STATUS_CODES[errorCode];
      body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
      errorLabel = "header_overflow";
    } else {
      errorCode = "400";
      errorStatus = http$2.STATUS_CODES[errorCode];
      body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
      errorLabel = "error";
    }
    this.log.trace({ err: err2 }, `client ${errorLabel}`);
    if (socket.writable) {
      socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
    }
    socket.destroy(err2);
  }
  function defaultRoute(req2, res2) {
    if (req2.headers["accept-version"] !== void 0) {
      req2.headers[kRequestAcceptVersion] = req2.headers["accept-version"];
      req2.headers["accept-version"] = void 0;
    }
    fourOhFour2.router.lookup(req2, res2);
  }
  function onBadUrl(path2, req2, res2) {
    if (frameworkErrors) {
      const id2 = getGenReqId(onBadUrlContext.server, req2);
      const childLogger = createChildLogger(onBadUrlContext, logger, req2, id2);
      const request2 = new Request$1(id2, null, req2, null, childLogger, onBadUrlContext);
      const reply2 = new Reply(res2, request2, childLogger);
      if (disableRequestLogging === false) {
        childLogger.info({ req: request2 }, "incoming request");
      }
      return frameworkErrors(new FST_ERR_BAD_URL(path2), request2, reply2);
    }
    const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path2}' is not a valid url component","statusCode":400}`;
    res2.writeHead(400, {
      "Content-Type": "application/json",
      "Content-Length": body.length
    });
    res2.end(body);
  }
  function buildAsyncConstraintCallback(isAsync, req2, res2) {
    if (isAsync === false) return void 0;
    return function onAsyncConstraintError(err2) {
      if (err2) {
        if (frameworkErrors) {
          const id2 = getGenReqId(onBadUrlContext.server, req2);
          const childLogger = createChildLogger(onBadUrlContext, logger, req2, id2);
          const request2 = new Request$1(id2, null, req2, null, childLogger, onBadUrlContext);
          const reply2 = new Reply(res2, request2, childLogger);
          if (disableRequestLogging === false) {
            childLogger.info({ req: request2 }, "incoming request");
          }
          return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request2, reply2);
        }
        const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
        res2.writeHead(500, {
          "Content-Type": "application/json",
          "Content-Length": body.length
        });
        res2.end(body);
      }
    };
  }
  function setNotFoundHandler(opts, handler) {
    throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
    fourOhFour2.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
    return this;
  }
  function setValidatorCompiler(validatorCompiler2) {
    throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
    this[kSchemaController].setValidatorCompiler(validatorCompiler2);
    return this;
  }
  function setSchemaErrorFormatter(errorFormatter) {
    throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
    validateSchemaErrorFormatter(errorFormatter);
    this[kSchemaErrorFormatter] = errorFormatter.bind(this);
    return this;
  }
  function setSerializerCompiler(serializerCompiler2) {
    throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
    this[kSchemaController].setSerializerCompiler(serializerCompiler2);
    return this;
  }
  function setSchemaController(schemaControllerOpts) {
    throwIfAlreadyStarted('Cannot call "setSchemaController"!');
    const old = this[kSchemaController];
    const schemaController3 = SchemaController2.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
    this[kSchemaController] = schemaController3;
    this.getSchema = schemaController3.getSchema.bind(schemaController3);
    this.getSchemas = schemaController3.getSchemas.bind(schemaController3);
    return this;
  }
  function setReplySerializer(replySerializer) {
    throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
    this[kReplySerializerDefault] = replySerializer;
    return this;
  }
  function setErrorHandler(func) {
    throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
    if (typeof func !== "function") {
      throw new FST_ERR_ERROR_HANDLER_NOT_FN();
    }
    this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
    return this;
  }
  function setChildLoggerFactory(factory) {
    throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
    this[kChildLoggerFactory] = factory;
    return this;
  }
  function printRoutes(opts = {}) {
    opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
    return router.printRoutes(opts);
  }
  function wrapRouting(router2, { rewriteUrl, logger: logger2 }) {
    let isAsync;
    return function preRouting(req2, res2) {
      if (isAsync === void 0) isAsync = router2.isAsyncConstraint();
      if (rewriteUrl) {
        req2.originalUrl = req2.url;
        const url2 = rewriteUrl.call(fastify2, req2);
        if (typeof url2 === "string") {
          req2.url = url2;
        } else {
          const err2 = new FST_ERR_ROUTE_REWRITE_NOT_STR(req2.url, typeof url2);
          req2.destroy(err2);
        }
      }
      router2.routing(req2, res2, buildAsyncConstraintCallback(isAsync, req2, res2));
    };
  }
  function setGenReqId(func) {
    throwIfAlreadyStarted('Cannot call "setGenReqId"!');
    this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
    return this;
  }
  function addHttpMethod(method, { hasBody = false } = {}) {
    if (typeof method !== "string" || http$2.METHODS.indexOf(method) === -1) {
      throw new FST_ERR_ROUTE_METHOD_INVALID();
    }
    if (hasBody === true) {
      this[kSupportedHTTPMethods].bodywith.add(method);
      this[kSupportedHTTPMethods].bodyless.delete(method);
    } else {
      this[kSupportedHTTPMethods].bodywith.delete(method);
      this[kSupportedHTTPMethods].bodyless.add(method);
    }
    const _method = method.toLowerCase();
    if (!this.hasDecorator(_method)) {
      this.decorate(_method, function(url2, options2, handler) {
        return router.prepareRoute.call(this, { method, url: url2, options: options2, handler });
      });
    }
    return this;
  }
}
function validateSchemaErrorFormatter(schemaErrorFormatter) {
  if (typeof schemaErrorFormatter !== "function") {
    throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
  } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
    throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
  }
}
fastify$1.exports = fastify;
fastify$1.exports.errorCodes = errorCodes;
fastify$1.exports.fastify = fastify;
fastify$1.exports.default = fastify;
var fastifyExports = fastify$1.exports;
const Fastify = /* @__PURE__ */ getDefaultExportFromCjs(fastifyExports);
function bind$1(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$1 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str2 = toString$1.call(thing);
  return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean$1 = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str2, searchString, position) => {
  str2 = String(str2);
  if (position === void 0 || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  const lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray$1 = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray2) => {
  return (thing) => {
    return TypedArray2 && thing instanceof TypedArray2;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str2) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str2)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str2) => {
  return str2.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$1(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$4 = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean: isBoolean$1,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$1,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError$1(message, code2, config2, request2, response2) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  if (response2) {
    this.response = response2;
    this.status = response2.status ? response2.status : null;
  }
}
utils$4.inherits(AxiosError$1, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$4.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error2, code2, config2, request2, response2, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$4.toFlatObject(error2, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error2.message, code2, config2, request2, response2);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var Stream$3 = stream.Stream;
var util$6 = require$$1$2;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$6.inherits(DelayedStream$1, Stream$3);
DelayedStream$1.create = function(source, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source;
  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };
  source.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach((function(args) {
    this.emit.apply(this, args);
  }).bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$3.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }
  if (args[0] === "data") {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }
  this._bufferedEvents.push(args);
};
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$5 = require$$1$2;
var Stream$2 = stream.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$5.inherits(CombinedStream$1, Stream$2);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
};
CombinedStream$1.isStreamLike = function(stream2) {
  return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
};
CombinedStream$1.prototype.append = function(stream2) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream2);
  if (isStreamLike) {
    if (!(stream2 instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream2, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams
      });
      stream2.on("data", this._checkDataSize.bind(this));
      stream2 = newStream;
    }
    this._handleErrors(stream2);
    if (this.pauseStreams) {
      stream2.pause();
    }
  }
  this._streams.push(stream2);
  return this;
};
CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream$2.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};
CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;
  if (this._insideLoop) {
    this._pendingNext = true;
    return;
  }
  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};
CombinedStream$1.prototype._realGetNext = function() {
  var stream2 = this._streams.shift();
  if (typeof stream2 == "undefined") {
    this.end();
    return;
  }
  if (typeof stream2 !== "function") {
    this._pipeNext(stream2);
    return;
  }
  var getStream = stream2;
  getStream((function(stream3) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream3);
    if (isStreamLike) {
      stream3.on("data", this._checkDataSize.bind(this));
      this._handleErrors(stream3);
    }
    this._pipeNext(stream3);
  }).bind(this));
};
CombinedStream$1.prototype._pipeNext = function(stream2) {
  this._currentStream = stream2;
  var isStreamLike = CombinedStream$1.isStreamLike(stream2);
  if (isStreamLike) {
    stream2.on("end", this._getNext.bind(this));
    stream2.pipe(this, { end: false });
    return;
  }
  var value = stream2;
  this.write(value);
  this._getNext();
};
CombinedStream$1.prototype._handleErrors = function(stream2) {
  var self2 = this;
  stream2.on("error", function(err2) {
    self2._emitError(err2);
  });
};
CombinedStream$1.prototype.write = function(data) {
  this.emit("data", data);
};
CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
  this.emit("pause");
};
CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
  this.emit("resume");
};
CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit("end");
};
CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit("close");
};
CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};
CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this._emitError(new Error(message));
};
CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var self2 = this;
  this._streams.forEach(function(stream2) {
    if (!stream2.dataSize) {
      return;
    }
    self2.dataSize += stream2.dataSize;
  });
  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};
CombinedStream$1.prototype._emitError = function(err2) {
  this._reset();
  this.emit("error", err2);
};
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports) {
  var db = mimeDb;
  var extname = path$n.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = /* @__PURE__ */ Object.create(null);
  exports.lookup = lookup2;
  exports.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var mime2 = match && db[match[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str2) {
    if (!str2 || typeof str2 !== "string") {
      return false;
    }
    var mime2 = str2.indexOf("/") === -1 ? exports.lookup(str2) : str2;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime2);
      if (charset2) mime2 += "; charset=" + charset2.toLowerCase();
    }
    return mime2;
  }
  function extension(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup2(path2) {
    if (!path2 || typeof path2 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path2).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type2) {
      var mime2 = db[type2];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type2] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from = preference.indexOf(db[types2[extension2]].source);
          var to = preference.indexOf(mime2.source);
          if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension2] = type2;
      }
    });
  }
})(mimeTypes);
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick) {
    nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$2;
function async$2(callback) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err2, result) {
    if (isAsync) {
      callback(err2, result);
    } else {
      defer(function nextTick_callback() {
        callback(err2, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean.bind(state2));
  state2.jobs = {};
}
function clean(key) {
  if (typeof this.jobs[key] == "function") {
    this.jobs[key]();
  }
}
var async$1 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list, iterator, state2, callback) {
  var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key] = runJob(iterator, key, list[key], function(error2, output) {
    if (!(key in state2.jobs)) {
      return;
    }
    delete state2.jobs[key];
    if (error2) {
      abort$1(state2);
    } else {
      state2.results[key] = output;
    }
    callback(error2, state2.results);
  });
}
function runJob(iterator, key, item, callback) {
  var aborter;
  if (iterator.length == 2) {
    aborter = iterator(item, async$1(callback));
  } else {
    aborter = iterator(item, key, async$1(callback));
  }
  return aborter;
}
var state_1 = state;
function state(list, sortMethod) {
  var isNamedList = !Array.isArray(list), initState2 = {
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list).length : list.length
  };
  if (sortMethod) {
    initState2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list[a], list[b]);
    });
  }
  return initState2;
}
var abort = abort_1, async = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async(callback)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list, iterator, callback) {
  var state2 = initState$1(list);
  while (state2.index < (state2["keyedList"] || list).length) {
    iterate$1(list, iterator, state2, function(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      if (Object.keys(state2.jobs).length === 0) {
        callback(null, state2.results);
        return;
      }
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list, iterator, sortMethod, callback) {
  var state2 = initState(list, sortMethod);
  iterate(list, iterator, state2, function iteratorHandler(error2, result) {
    if (error2) {
      callback(error2, result);
      return;
    }
    state2.index++;
    if (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator, state2, iteratorHandler);
      return;
    }
    callback(null, state2.results);
  });
  return terminator.bind(state2, callback);
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function descending(a, b) {
  return -1 * ascending(a, b);
}
var serialOrderedExports = serialOrdered$2.exports;
var serialOrdered = serialOrderedExports;
var serial_1 = serial;
function serial(list, iterator, callback) {
  return serialOrdered(list, iterator, null, callback);
}
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrderedExports
};
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type$1 = TypeError;
var uri = URIError;
var abs$1 = Math.abs;
var floor$1 = Math.floor;
var max$1 = Math.max;
var min$1 = Math.min;
var pow$1 = Math.pow;
var round$1 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a) {
  return a !== a;
};
var $isNaN = _isNaN;
var sign$1 = function sign(number) {
  if ($isNaN(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : 1;
};
var gOPD = Object.getOwnPropertyDescriptor;
var $gOPD$1 = gOPD;
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var gopd = $gOPD$1;
var $defineProperty$2 = Object.defineProperty || false;
if ($defineProperty$2) {
  try {
    $defineProperty$2({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty$2 = false;
  }
}
var esDefineProperty = $defineProperty$2;
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object2 = esObjectAtoms;
  Object_getPrototypeOf = $Object2.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str2 = "";
    for (var i = 0; i < arr.length; i += 1) {
      str2 += arr[i];
      if (i + 1 < arr.length) {
        str2 += joiner;
      }
    }
    return str2;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty2 = function Empty3() {
      };
      Empty2.prototype = target.prototype;
      bound.prototype = new Empty2();
      Empty2.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply2 = requireFunctionApply();
  var $call2 = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call2, $apply2);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError2 = type$1;
  var $call2 = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError2("a function is required");
    }
    return $actualApply(bind2, $call2, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = gopd;
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object2 = Object;
  var $getPrototypeOf = $Object2.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object2(value));
    }
  ) : false;
  return get;
}
var getProto$1;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$1;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto$1 = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto$1;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var undefined$1;
var $Object = esObjectAtoms;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError = syntax;
var $TypeError$1 = type$1;
var $URIError = uri;
var abs = abs$1;
var floor = floor$1;
var max = max$1;
var min = min$1;
var pow = pow$1;
var round = round$1;
var sign2 = sign$1;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = gopd;
var $defineProperty$1 = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = requireHasSymbols()();
var getProto = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty$1,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign2,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind = requireFunctionBind();
var hasOwn$1 = requireHasown();
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var GetIntrinsic2 = getIntrinsic;
var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
var hasToStringTag = requireShams()();
var hasOwn = requireHasown();
var $TypeError = type$1;
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
var esSetTostringtag = function setToStringTag(object, value) {
  var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
  var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
    throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  }
  if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
    if ($defineProperty) {
      $defineProperty(object, toStringTag, {
        configurable: !nonConfigurable,
        enumerable: false,
        value,
        writable: false
      });
    } else {
      object[toStringTag] = value;
    }
  }
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util$4 = require$$1$2;
var path$m = path$n;
var http$1 = require$$3$2;
var https$1 = require$$4;
var parseUrl$2 = require$$0$5.parse;
var fs$j = fs$k;
var Stream$1 = stream.Stream;
var mime = mimeTypes;
var asynckit = asynckit$1;
var setToStringTag2 = esSetTostringtag;
var populate = populate$1;
var form_data = FormData$1;
util$4.inherits(FormData$1, CombinedStream);
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
FormData$1.LINE_BREAK = "\r\n";
FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$1.prototype.append = function(field, value, options) {
  options = options || {};
  if (typeof options == "string") {
    options = { filename: options };
  }
  var append2 = CombinedStream.prototype.append.bind(this);
  if (typeof value == "number") {
    value = "" + value;
  }
  if (Array.isArray(value)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();
  append2(header);
  append2(value);
  append2(footer);
  this._trackLength(header, value, options);
};
FormData$1.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === "string") {
    valueLength = Buffer.byteLength(value);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header) + FormData$1.LINE_BREAK.length;
  if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream$1)) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};
FormData$1.prototype._lengthRetriever = function(value, callback) {
  if (Object.prototype.hasOwnProperty.call(value, "fd")) {
    if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
      callback(null, value.end + 1 - (value.start ? value.start : 0));
    } else {
      fs$j.stat(value.path, function(err2, stat2) {
        var fileSize;
        if (err2) {
          callback(err2);
          return;
        }
        fileSize = stat2.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }
  } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
    callback(null, +value.headers["content-length"]);
  } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
    value.on("response", function(response2) {
      value.pause();
      callback(null, +response2.headers["content-length"]);
    });
    value.resume();
  } else {
    callback("Unknown stream");
  }
};
FormData$1.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header == "string") {
    return options.header;
  }
  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);
  var contents = "";
  var headers2 = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(contentType || [])
  };
  if (typeof options.header == "object") {
    populate(headers2, options.header);
  }
  var header;
  for (var prop in headers2) {
    if (Object.prototype.hasOwnProperty.call(headers2, prop)) {
      header = headers2[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData$1.LINE_BREAK;
      }
    }
  }
  return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};
FormData$1.prototype._getContentDisposition = function(value, options) {
  var filename, contentDisposition;
  if (typeof options.filepath === "string") {
    filename = path$m.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value.name || value.path) {
    filename = path$m.basename(options.filename || value.name || value.path);
  } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
    filename = path$m.basename(value.client._httpMessage.path || "");
  }
  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }
  return contentDisposition;
};
FormData$1.prototype._getContentType = function(value, options) {
  var contentType = options.contentType;
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }
  if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
    contentType = value.headers["content-type"];
  }
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType && typeof value == "object") {
    contentType = FormData$1.DEFAULT_CONTENT_TYPE;
  }
  return contentType;
};
FormData$1.prototype._multiPartFooter = function() {
  return (function(next) {
    var footer = FormData$1.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }).bind(this);
};
FormData$1.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
};
FormData$1.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header in userHeaders) {
    if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }
  return formHeaders;
};
FormData$1.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};
FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$1.prototype._generateBoundary = function() {
  var boundary = "--------------------------";
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }
  this._boundary = boundary;
};
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err2, values2) {
    if (err2) {
      cb(err2);
      return;
    }
    values2.forEach(function(length) {
      knownLength += length;
    });
    cb(null, knownLength);
  });
};
FormData$1.prototype.submit = function(params, cb) {
  var request2, options, defaults2 = { method: "post" };
  if (typeof params == "string") {
    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol == "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol == "https:") {
    request2 = https$1.request(options);
  } else {
    request2 = http$1.request(options);
  }
  this.getLength((function(err2, length) {
    if (err2 && err2 !== "Unknown stream") {
      this._error(err2);
      return;
    }
    if (length) {
      request2.setHeader("Content-Length", length);
    }
    this.pipe(request2);
    if (cb) {
      var onResponse;
      var callback = function(error2, responce) {
        request2.removeListener("error", callback);
        request2.removeListener("response", onResponse);
        return cb.call(this, error2, responce);
      };
      onResponse = callback.bind(this, null);
      request2.on("error", callback);
      request2.on("response", onResponse);
    }
  }).bind(this));
  return request2;
};
FormData$1.prototype._error = function(err2) {
  if (!this.error) {
    this.error = err2;
    this.pause();
    this.emit("error", err2);
  }
};
FormData$1.prototype.toString = function() {
  return "[object FormData]";
};
setToStringTag2(FormData$1, "FormData");
const FormData$2 = /* @__PURE__ */ getDefaultExportFromCjs(form_data);
function isVisitable(thing) {
  return utils$4.isPlainObject(thing) || utils$4.isArray(thing);
}
function removeBrackets(key) {
  return utils$4.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$4.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$4.toFlatObject(utils$4, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData2, options) {
  if (!utils$4.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData2 = formData2 || new (FormData$2 || FormData)();
  options = utils$4.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$4.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes2 = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$4.isSpecCompliantForm(formData2);
  if (!utils$4.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$4.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$4.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$4.isArrayBuffer(value) || utils$4.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$4.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$4.isArray(value) && isFlatArray(value) || (utils$4.isFileList(value) || utils$4.endsWith(key, "[]")) && (arr = utils$4.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils$4.isUndefined(el) || el === null) && formData2.append(
            // eslint-disable-next-line no-nested-ternary
            indexes2 === true ? renderKey([key], index, dots) : indexes2 === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData2.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build2(value, path2) {
    if (utils$4.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$4.forEach(value, function each(el, key) {
      const result = !(utils$4.isUndefined(el) || el === null) && visitor.call(
        formData2,
        el,
        utils$4.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build2(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$4.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build2(obj);
  return formData2;
}
function encode$1(str2) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode;
  if (utils$4.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$4.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$4.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = require$$0$5.URLSearchParams;
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str2 = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  require$$0$c.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str2 += alphabet[randomValues[i] % length];
  }
  return str2;
};
const platform$2 = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$2,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform$1 = {
  ...utils$3,
  ...platform$2
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform$1.isNode && utils$4.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$4.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData2) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils$4.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$4.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$4.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils$4.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$4.isFormData(formData2) && utils$4.isFunction(formData2.entries)) {
    const obj = {};
    utils$4.forEachEntry(formData2, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$4.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$4.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers2) {
    const contentType = headers2.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$4.isObject(data);
    if (isObjectPayload && utils$4.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$4.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$4.isArrayBuffer(data) || utils$4.isBuffer(data) || utils$4.isStream(data) || utils$4.isFile(data) || utils$4.isBlob(data) || utils$4.isReadableStream(data)) {
      return data;
    }
    if (utils$4.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$4.isURLSearchParams(data)) {
      headers2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$4.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers2.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$4.isResponse(data) || utils$4.isReadableStream(data)) {
      return data;
    }
    if (data && utils$4.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$4.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const ignoreDuplicateOf = utils$4.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$4.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens2 = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str2)) {
    tokens2[match[1]] = match[2];
  }
  return tokens2;
}
const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
function matchHeaderValue(context2, value, header, filter3, isHeaderNameFilter) {
  if (utils$4.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$4.isString(value)) return;
  if (utils$4.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$4.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$4.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers2) {
    headers2 && this.set(headers2);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$4.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers2, _rewrite) => utils$4.forEach(headers2, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$4.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$4.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$4.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$4.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$4.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$4.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$4.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$4.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$4.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers2 = {};
    utils$4.forEach(this, (value, header) => {
      const key = utils$4.findKey(headers2, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers2[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$4.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$4.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals2 = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals2.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$4.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$4.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$4.freezeMethods(AxiosHeaders$1);
function transformData(fns, response2) {
  const config2 = this || defaults$1;
  const context2 = response2 || config2;
  const headers2 = AxiosHeaders$1.from(context2.headers);
  let data = context2.data;
  utils$4.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers2.normalize(), response2 ? response2.status : void 0);
  });
  headers2.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config2, request2) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils$4.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve2, reject, response2) {
  const validateStatus2 = response2.config.validateStatus;
  if (!response2.status || !validateStatus2 || validateStatus2(response2.status)) {
    resolve2(response2);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response2.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response2.status / 100) - 4],
      response2.config,
      response2.request,
      response2
    ));
  }
}
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var proxyFromEnv = {};
var parseUrl$1 = require$$0$5.parse;
var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
function getProxyForUrl(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl$1(url2) : url2 || {};
  var proto2 = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== "string" || !hostname || typeof proto2 !== "string") {
    return "";
  }
  proto2 = proto2.split(":", 1)[0];
  hostname = hostname.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto2] || 0;
  if (!shouldProxy(hostname, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto2 + "_proxy") || getEnv(proto2 + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto2 + "://" + proxy;
  }
  return proxy;
}
function shouldProxy(hostname, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
}
proxyFromEnv.getProxyForUrl = getProxyForUrl;
var followRedirects$1 = { exports: {} };
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common$6;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common$6;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend3;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend3(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip2 of createDebug.skips) {
        if (matchesTemplate(name, skip2)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$6 = setup;
  return common$6;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$2$2;
  const tty = require$$1$4;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign3) => sign3 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$1$4;
    const util2 = require$$1$2;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
var debug$3;
var debug_1$1 = function() {
  if (!debug$3) {
    try {
      debug$3 = srcExports("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$3 !== "function") {
      debug$3 = function() {
      };
    }
  }
  debug$3.apply(null, arguments);
};
var url = require$$0$5;
var URL$1 = url.URL;
var http = require$$3$2;
var https = require$$4;
var Writable = stream.Writable;
var assert$1 = require$$5;
var debug$2 = debug_1$1;
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
})();
var useNativeURL = false;
try {
  assert$1(new URL$1(""));
} catch (error2) {
  useNativeURL = error2.code === "ERR_INVALID_URL";
}
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
];
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
var destroy = Writable.prototype.destroy || noop$1;
function RedirectableRequest(options, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response2) {
    try {
      self2._processResponse(response2);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data, encoding, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data, encoding });
    this._currentRequest.write(data, encoding, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data, encoding, callback) {
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  } else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};
RedirectableRequest.prototype.removeHeader = function(name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    self2.removeListener("close", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b) {
    return this._currentRequest[method](a, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function() {
      return this._currentRequest[property];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
  if (!options.headers) {
    options.headers = {};
  }
  if (options.host) {
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  request2._redirectable = this;
  for (var event of events) {
    request2.on(event, eventHandlers[event]);
  }
  this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path
  );
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request2 === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer = buffers[i++];
          if (!request2.finished) {
            request2.write(buffer.data, buffer.encoding, writeNext);
          }
        } else if (self2._ended) {
          request2.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response2) {
  var statusCode = response2.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response2.headers,
      statusCode
    });
  }
  var location2 = response2.headers.location;
  if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response2.responseUrl = this._currentUrl;
    response2.redirects = this._redirects;
    this.emit("response", response2);
    this._requestBodyBuffers = [];
    return;
  }
  destroyRequest(this._currentRequest);
  response2.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response2.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource […]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) […]
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location2, currentUrl);
  debug$2("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response2.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function wrap(protocols) {
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
    function request2(input, options, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options;
        options = validateUrl(input);
        input = { protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }
      assert$1.equal(options.protocol, protocol, "protocol mismatch");
      debug$2("options", options);
      return new RedirectableRequest(options, callback);
    }
    function get2(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request2, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports;
}
function noop$1() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative, base) {
  return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread2 = target || {};
  for (var key of preservedUrlFields) {
    spread2[key] = urlObject[key];
  }
  if (spread2.hostname.startsWith("[")) {
    spread2.hostname = spread2.hostname.slice(1, -1);
  }
  if (spread2.port !== "") {
    spread2.port = Number(spread2.port);
  }
  spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
  return spread2;
}
function removeMatchingHeaders(regex, headers2) {
  var lastValue;
  for (var header in headers2) {
    if (regex.test(header)) {
      lastValue = headers2[header];
      delete headers2[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code2, message, baseClass) {
  function CustomError(properties2) {
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties2 || {});
    this.code = code2;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code2 + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request2, error2) {
  for (var event of events) {
    request2.removeListener(event, eventHandlers[event]);
  }
  request2.on("error", noop$1);
  request2.destroy(error2);
}
function isSubdomain(subdomain, domain) {
  assert$1(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
  return typeof value === "function";
}
function isBuffer(value) {
  return typeof value === "object" && "length" in value;
}
function isURL(value) {
  return URL$1 && value instanceof URL$1;
}
followRedirects$1.exports = wrap({ http, https });
followRedirects$1.exports.wrap = wrap;
var followRedirectsExports = followRedirects$1.exports;
const followRedirects = /* @__PURE__ */ getDefaultExportFromCjs(followRedirectsExports);
const VERSION$1 = "1.8.4";
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform$1.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
    }
    const mime2 = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime2 });
    }
    return buffer;
  }
  throw new AxiosError$1("Unsupported protocol " + protocol, AxiosError$1.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils$4.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$4.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals2 = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals2.isCaptured) {
          internals2.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals2 = this[kInternals];
    if (internals2.onReadCallback) {
      internals2.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals2 = this[kInternals];
    const maxRate = internals2.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals2.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals2.minChunkSize !== false ? Math.max(internals2.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals2.bytesSeen += bytes;
      internals2.bytes += bytes;
      internals2.isCaptured && this.emit("progress", internals2.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals2.onReadCallback = () => {
          internals2.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now2 = Date.now();
        if (!internals2.ts || (passed = now2 - internals2.ts) >= timeWindow) {
          internals2.ts = now2;
          bytesLeft = bytesThreshold - internals2.bytes;
          internals2.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals2.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err2, _chunk) {
      if (err2) {
        return callback(err2);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const BOUNDARY_ALPHABET = platform$1.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$1$2.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$4.isString(value);
    let headers2 = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers2 += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers2 + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$4.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$4.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$4.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable$1.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
class ZlibHeaderTransformStream extends stream.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
const callbackify = (fn, reducer) => {
  return utils$4.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err2) {
        cb(err2);
      }
    }, cb);
  } : fn;
};
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now2 = Date.now()) => {
    timestamp2 = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp2;
    if (passed >= threshold) {
      invoke(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$4.asap(() => fn(...args));
const zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$4.isFunction(zlib.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects;
const isHttps = /https:?/;
const supportedProtocols = platform$1.protocols.map((protocol) => {
  return protocol + ":";
});
const flushOnFinish = (stream2, [throttled, flush]) => {
  stream2.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location2) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location2);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location2;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$4.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve2, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve2(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$4.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$4.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config2) {
  return wrapAsync(async function dispatchHttpRequest(resolve2, reject, onDone) {
    let { data, lookup: lookup2, family } = config2;
    const { responseType, responseEncoding } = config2;
    const method = config2.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req2;
    if (lookup2) {
      const _lookup = callbackify(lookup2, (value) => utils$4.isArray(value) ? value : [value]);
      lookup2 = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err2, arg0, arg1) => {
          if (err2) {
            return cb(err2);
          }
          const addresses = utils$4.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err2, addresses) : cb(err2, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter$1();
    const onFinished = () => {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(abort2);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", abort2);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort2(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError$1(null, config2, req2) : reason);
    }
    emitter.once("abort", reject);
    if (config2.cancelToken || config2.signal) {
      config2.cancelToken && config2.cancelToken.subscribe(abort2);
      if (config2.signal) {
        config2.signal.aborted ? abort2() : config2.signal.addEventListener("abort", abort2);
      }
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform$1.hasBrowserEnv ? platform$1.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve2, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: config2
        });
      }
      try {
        convertedData = fromDataURI(config2.url, responseType === "blob", {
          Blob: config2.env && config2.env.Blob
        });
      } catch (err2) {
        throw AxiosError$1.from(err2, AxiosError$1.ERR_BAD_REQUEST, config2);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$4.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream.Readable.from(convertedData);
      }
      return settle(resolve2, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$1(),
        config: config2
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError$1(
        "Unsupported protocol " + protocol,
        AxiosError$1.ERR_BAD_REQUEST,
        config2
      ));
    }
    const headers2 = AxiosHeaders$1.from(config2.headers).normalize();
    headers2.set("User-Agent", "axios/" + VERSION$1, false);
    const { onUploadProgress, onDownloadProgress } = config2;
    const maxRate = config2.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$4.isSpecCompliantForm(data)) {
      const userBoundary = headers2.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream(data, (formHeaders) => {
        headers2.set(formHeaders);
      }, {
        tag: `axios-${VERSION$1}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$4.isFormData(data) && utils$4.isFunction(data.getHeaders)) {
      headers2.set(data.getHeaders());
      if (!headers2.hasContentLength()) {
        try {
          const knownLength = await require$$1$2.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers2.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$4.isBlob(data) || utils$4.isFile(data)) {
      data.size && headers2.setContentType(data.type || "application/octet-stream");
      headers2.setContentLength(data.size || 0);
      data = stream.Readable.from(readBlob(data));
    } else if (data && !utils$4.isStream(data)) {
      if (Buffer.isBuffer(data)) ;
      else if (utils$4.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$4.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError$1(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError$1.ERR_BAD_REQUEST,
          config2
        ));
      }
      headers2.setContentLength(data.length, false);
      if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
        return reject(new AxiosError$1(
          "Request body larger than maxBodyLength limit",
          AxiosError$1.ERR_BAD_REQUEST,
          config2
        ));
      }
    }
    const contentLength = utils$4.toFiniteNumber(headers2.getContentLength());
    if (utils$4.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$4.isStream(data)) {
        data = stream.Readable.from(data, { objectMode: false });
      }
      data = stream.pipeline([data, new AxiosTransformStream({
        maxRate: utils$4.toFiniteNumber(maxUploadRate)
      })], utils$4.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers2.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config2.params,
        config2.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err2) {
      const customErr = new Error(err2.message);
      customErr.config = config2;
      customErr.url = config2.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers2.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method,
      headers: headers2.toJSON(),
      agents: { http: config2.httpAgent, https: config2.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$4.isUndefined(lookup2) && (options.lookup = lookup2);
    if (config2.socketPath) {
      options.socketPath = config2.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
    if (config2.transport) {
      transport = config2.transport;
    } else if (config2.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$4 : require$$3$2;
    } else {
      if (config2.maxRedirects) {
        options.maxRedirects = config2.maxRedirects;
      }
      if (config2.beforeRedirect) {
        options.beforeRedirects.config = config2.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config2.maxBodyLength > -1) {
      options.maxBodyLength = config2.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config2.insecureHTTPParser) {
      options.insecureHTTPParser = config2.insecureHTTPParser;
    }
    req2 = transport.request(options, function handleResponse(res2) {
      if (req2.destroyed) return;
      const streams = [res2];
      const responseLength = +res2.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream({
          maxRate: utils$4.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams.push(transformStream);
      }
      let responseStream = res2;
      const lastRequest = res2.req || req2;
      if (config2.decompress !== false && res2.headers["content-encoding"]) {
        if (method === "HEAD" || res2.statusCode === 204) {
          delete res2.headers["content-encoding"];
        }
        switch ((res2.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res2.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream());
            streams.push(zlib.createUnzip(zlibOptions));
            delete res2.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res2.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? stream.pipeline(streams, utils$4.noop) : streams[0];
      const offListeners = stream.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response2 = {
        status: res2.statusCode,
        statusText: res2.statusMessage,
        headers: new AxiosHeaders$1(res2.headers),
        config: config2,
        request: lastRequest
      };
      if (responseType === "stream") {
        response2.data = responseStream;
        settle(resolve2, reject, response2);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError$1(
              "maxContentLength size of " + config2.maxContentLength + " exceeded",
              AxiosError$1.ERR_BAD_RESPONSE,
              config2,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err2 = new AxiosError$1(
            "stream has been aborted",
            AxiosError$1.ERR_BAD_RESPONSE,
            config2,
            lastRequest
          );
          responseStream.destroy(err2);
          reject(err2);
        });
        responseStream.on("error", function handleStreamError(err2) {
          if (req2.destroyed) return;
          reject(AxiosError$1.from(err2, null, config2, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$4.stripBOM(responseData);
              }
            }
            response2.data = responseData;
          } catch (err2) {
            return reject(AxiosError$1.from(err2, null, config2, response2.request, response2));
          }
          settle(resolve2, reject, response2);
        });
      }
      emitter.once("abort", (err2) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err2);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err2) => {
      reject(err2);
      req2.destroy(err2);
    });
    req2.on("error", function handleRequestError(err2) {
      reject(AxiosError$1.from(err2, null, config2, req2));
    });
    req2.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config2.timeout) {
      const timeout = parseInt(config2.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError$1(
          "error trying to parse `config.timeout` to int",
          AxiosError$1.ERR_BAD_OPTION_VALUE,
          config2,
          req2
        ));
        return;
      }
      req2.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitionalDefaults;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config2,
          req2
        ));
        abort2();
      });
    }
    if (utils$4.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err2) => {
        errored = true;
        req2.destroy(err2);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort2(new CanceledError$1("Request stream has been aborted", config2, req2));
        }
      });
      data.pipe(req2);
    } else {
      req2.end(data);
    }
  });
};
const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform$1.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform$1.origin),
  platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
) : () => true;
const cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$4.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$4.isString(path2) && cookie.push("path=" + path2);
      utils$4.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$4.isPlainObject(target) && utils$4.isPlainObject(source)) {
      return utils$4.merge.call({ caseless }, target, source);
    } else if (utils$4.isPlainObject(source)) {
      return utils$4.merge({}, source);
    } else if (utils$4.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$4.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$4.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$4.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$4.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig$1({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers: headers2, auth } = newConfig;
  newConfig.headers = headers2 = AxiosHeaders$1.from(headers2);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers2.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$4.isFormData(data)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
      headers2.setContentType(void 0);
    } else if ((contentType = headers2.getContentType()) !== false) {
      const [type2, ...tokens2] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers2.setContentType([type2 || "multipart/form-data", ...tokens2].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv) {
    withXSRFToken && utils$4.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers2.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response2 = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err2) {
        reject(err2);
        done();
      }, response2);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError2() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout2() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$4.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$4.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err2 = reason instanceof Error ? reason : this.reason;
        controller.abort(err2 instanceof AxiosError$1 ? err2 : new CanceledError$1(err2 instanceof Error ? err2.message : err2));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$4.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream2) {
  if (stream2[Symbol.asyncIterator]) {
    yield* stream2;
    return;
  }
  const reader = stream2.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream2, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err2) {
        _onFinish(err2);
        throw err2;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder()) : async (str2) => new Uint8Array(await new Response(str2).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$1.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$4.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res2) => res2.body)
};
isFetchSupported && ((res2) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$4.isFunction(res2[type2]) ? (res3) => res3[type2]() : (_, config2) => {
      throw new AxiosError$1(`Response type '${type2}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$4.isBlob(body)) {
    return body.size;
  }
  if (utils$4.isSpecCompliantForm(body)) {
    const _request = new Request(platform$1.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$4.isArrayBufferView(body) || utils$4.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$4.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$4.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers2, body) => {
  const length = utils$4.toFiniteNumber(headers2.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers: headers2,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers2, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$4.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers2.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$4.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers2.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response2 = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response2[prop];
      });
      const responseContentLength = utils$4.toFiniteNumber(response2.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response2 = new Response(
        trackStream(response2.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$4.findKey(resolvers, responseType) || "text"](response2, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response2.headers),
        status: response2.status,
        statusText: response2.statusText,
        config: config2,
        request: request2
      });
    });
  } catch (err2) {
    unsubscribe && unsubscribe();
    if (err2 && err2.name === "TypeError" && /fetch/i.test(err2.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request2),
        {
          cause: err2.cause || err2
        }
      );
    }
    throw AxiosError$1.from(err2, err2 && err2.code, config2, request2);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$4.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$4.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$4.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state2]) => `adapter ${id2} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError$1(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response2) {
    throwIfCancellationRequested(config2);
    response2.data = transformData.call(
      config2,
      config2.transformResponse,
      response2
    );
    response2.headers = AxiosHeaders$1.from(response2.headers);
    return response2;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema2, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator2 = schema2[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err2) {
      if (err2 instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err2.stack) {
            err2.stack = stack;
          } else if (stack && !String(err2.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err2.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err2;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers: headers2 } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$4.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers2 && utils$4.merge(
      headers2.common,
      headers2[config2.method]
    );
    headers2 && utils$4.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers2[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers2);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod2(url2, data, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort2 = (err2) => {
      controller.abort(err2);
    };
    this.subscribe(abort2);
    controller.signal.unsubscribe = () => this.unsubscribe(abort2);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$4.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context2 = new Axios$1(defaultConfig);
  const instance = bind$1(Axios$1.prototype.request, context2);
  utils$4.extend(instance, Axios$1.prototype, context2, { allOwnKeys: true });
  utils$4.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$4.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m, z: function(t3) {
      var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t3(e2, n2) {
      if (e2.date() < n2.date()) return -t3(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c, y: h, w: o, d: a, D: d, h: u2, m: s, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p]);
    }, w = function t3(e2, n2, r2) {
      var i2;
      if (!e2) return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u3 = e2.split("-");
        if (!i2 && u3.length > 1) return t3(u3[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t3, e2) {
      if (S(t3)) return t3.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t3, e2) {
      return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (null === e2) return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2)) return /* @__PURE__ */ new Date();
          if (e2 instanceof Date) return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t3), this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t3, e2) {
        var n2 = O(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t3, e2) {
        return O(t3) < this.startOf(e2);
      }, m2.isBefore = function(t3, e2) {
        return this.endOf(e2) < O(t3);
      }, m2.$g = function(t3, e2, n2) {
        return b.u(t3) ? this[e2] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function(t4, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t4, e3) {
          return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u2:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e2) {
        var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u2] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m2.get = function(t3) {
        return this[b.p(t3)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = b.p(f2), y2 = function(t3) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
        };
        if ($2 === c) return this.set(c, this.$M + r2);
        if ($2 === h) return this.set(h, this.$y + r2);
        if ($2 === a) return y2(1);
        if ($2 === o) return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u2] = n, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m2.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid()) return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t4, n3, i3, s3) {
          return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t4) {
          return b.s(s2 % 12 || 12, t4, "0");
        }, $2 = f2 || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h2(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h2(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s2, u3, true);
              case "A":
                return $2(s2, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b.s(u3, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h:
            $2 = D2() / 12;
            break;
          case c:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a:
            $2 = (g2 - v2) / 864e5;
            break;
          case u2:
            $2 = g2 / n;
            break;
          case s:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t2;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : b.a($2);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t3, e2) {
        if (!t3) return this.$L;
        var n2 = this.clone(), r2 = w(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t3) {
      k[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, O), t3.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
      return O(1e3 * t3);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var util$3 = { exports: {} };
var constants$1 = {
  /* The local file header */
  LOCHDR: 30,
  // LOC header size
  LOCSIG: 67324752,
  // "PK\003\004"
  LOCVER: 4,
  // version needed to extract
  LOCFLG: 6,
  // general purpose bit flag
  LOCHOW: 8,
  // compression method
  LOCTIM: 10,
  // modification time (2 bytes time, 2 bytes date)
  LOCCRC: 14,
  // uncompressed file crc-32 value
  LOCSIZ: 18,
  // compressed size
  LOCLEN: 22,
  // uncompressed size
  LOCNAM: 26,
  // filename length
  LOCEXT: 28,
  // extra field length
  /* The Data descriptor */
  EXTSIG: 134695760,
  // "PK\007\008"
  EXTHDR: 16,
  // EXT header size
  EXTCRC: 4,
  // uncompressed file crc-32 value
  EXTSIZ: 8,
  // compressed size
  EXTLEN: 12,
  // uncompressed size
  /* The central directory file header */
  CENHDR: 46,
  // CEN header size
  CENSIG: 33639248,
  // "PK\001\002"
  CENVEM: 4,
  // version made by
  CENVER: 6,
  // version needed to extract
  CENFLG: 8,
  // encrypt, decrypt flags
  CENHOW: 10,
  // compression method
  CENTIM: 12,
  // modification time (2 bytes time, 2 bytes date)
  CENCRC: 16,
  // uncompressed file crc-32 value
  CENSIZ: 20,
  // compressed size
  CENLEN: 24,
  // uncompressed size
  CENNAM: 28,
  // filename length
  CENEXT: 30,
  // extra field length
  CENCOM: 32,
  // file comment length
  CENDSK: 34,
  // volume number start
  CENATT: 36,
  // internal file attributes
  CENATX: 38,
  // external file attributes (host system dependent)
  CENOFF: 42,
  // LOC header offset
  /* The entries in the end of central directory */
  ENDHDR: 22,
  // END header size
  ENDSIG: 101010256,
  // "PK\005\006"
  ENDSUB: 8,
  // number of entries on this disk
  ENDTOT: 10,
  // total number of entries
  ENDSIZ: 12,
  // central directory size in bytes
  ENDOFF: 16,
  // offset of first CEN header
  ENDCOM: 20,
  // zip file comment length
  END64HDR: 20,
  // zip64 END header size
  END64SIG: 117853008,
  // zip64 Locator signature, "PK\006\007"
  END64START: 4,
  // number of the disk with the start of the zip64
  END64OFF: 8,
  // relative offset of the zip64 end of central directory
  END64NUMDISKS: 16,
  // total number of disks
  ZIP64SIG: 101075792,
  // zip64 signature, "PK\006\006"
  ZIP64HDR: 56,
  // zip64 record minimum size
  ZIP64LEAD: 12,
  // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
  ZIP64SIZE: 4,
  // zip64 size of the central directory record
  ZIP64VEM: 12,
  // zip64 version made by
  ZIP64VER: 14,
  // zip64 version needed to extract
  ZIP64DSK: 16,
  // zip64 number of this disk
  ZIP64DSKDIR: 20,
  // number of the disk with the start of the record directory
  ZIP64SUB: 24,
  // number of entries on this disk
  ZIP64TOT: 32,
  // total number of entries
  ZIP64SIZB: 40,
  // zip64 central directory size in bytes
  ZIP64OFF: 48,
  // offset of start of central directory with respect to the starting disk number
  ZIP64EXTRA: 56,
  // extensible data sector
  /* Compression methods */
  STORED: 0,
  // no compression
  SHRUNK: 1,
  // shrunk
  REDUCED1: 2,
  // reduced with compression factor 1
  REDUCED2: 3,
  // reduced with compression factor 2
  REDUCED3: 4,
  // reduced with compression factor 3
  REDUCED4: 5,
  // reduced with compression factor 4
  IMPLODED: 6,
  // imploded
  // 7 reserved for Tokenizing compression algorithm
  DEFLATED: 8,
  // deflated
  ENHANCED_DEFLATED: 9,
  // enhanced deflated
  PKWARE: 10,
  // PKWare DCL imploded
  // 11 reserved by PKWARE
  BZIP2: 12,
  //  compressed using BZIP2
  // 13 reserved by PKWARE
  LZMA: 14,
  // LZMA
  // 15-17 reserved by PKWARE
  IBM_TERSE: 18,
  // compressed using IBM TERSE
  IBM_LZ77: 19,
  // IBM LZ77 z
  AES_ENCRYPT: 99,
  // WinZIP AES encryption method
  /* General purpose bit flag */
  // values can obtained with expression 2**bitnr
  FLG_ENC: 1,
  // Bit 0: encrypted file
  FLG_COMP1: 2,
  // Bit 1, compression option
  FLG_COMP2: 4,
  // Bit 2, compression option
  FLG_DESC: 8,
  // Bit 3, data descriptor
  FLG_ENH: 16,
  // Bit 4, enhanced deflating
  FLG_PATCH: 32,
  // Bit 5, indicates that the file is compressed patched data.
  FLG_STR: 64,
  // Bit 6, strong encryption (patented)
  // Bits 7-10: Currently unused.
  FLG_EFS: 2048,
  // Bit 11: Language encoding flag (EFS)
  // Bit 12: Reserved by PKWARE for enhanced compression.
  // Bit 13: encrypted the Central Directory (patented).
  // Bits 14-15: Reserved by PKWARE.
  FLG_MSK: 4096,
  // mask header values
  /* Load type */
  FILE: 2,
  BUFFER: 1,
  NONE: 0,
  /* 4.5 Extensible data fields */
  EF_ID: 0,
  EF_SIZE: 2,
  /* Header IDs */
  ID_ZIP64: 1,
  ID_AVINFO: 7,
  ID_PFS: 8,
  ID_OS2: 9,
  ID_NTFS: 10,
  ID_OPENVMS: 12,
  ID_UNIX: 13,
  ID_FORK: 14,
  ID_PATCH: 15,
  ID_X509_PKCS7: 20,
  ID_X509_CERTID_F: 21,
  ID_X509_CERTID_C: 22,
  ID_STRONGENC: 23,
  ID_RECORD_MGT: 24,
  ID_X509_PKCS7_RL: 25,
  ID_IBM1: 101,
  ID_IBM2: 102,
  ID_POSZIP: 18064,
  EF_ZIP64_OR_32: 4294967295,
  EF_ZIP64_OR_16: 65535,
  EF_ZIP64_SUNCOMP: 0,
  EF_ZIP64_SCOMP: 8,
  EF_ZIP64_RHO: 16,
  EF_ZIP64_DSN: 24
};
var errors = {};
(function(exports) {
  const errors2 = {
    /* Header error messages */
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",
    /* Descriptor */
    DESCRIPTOR_NOT_EXIST: "No descriptor present",
    DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
    DESCRIPTOR_FAULTY: "Descriptor data is malformed",
    /* ZipEntry error messages*/
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed {0}",
    FILE_IN_THE_WAY: "There is a file in the way: {0}",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",
    /* Inflater error messages */
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
    /* ADM-ZIP error messages */
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: 'File not found: "{0}"',
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
    INVALID_PASS_PARAM: "Incompatible password parameter",
    WRONG_PASSWORD: "Wrong Password",
    /* ADM-ZIP */
    COMMENT_TOO_LONG: "Comment is too long",
    // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)
    EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
  };
  function E(message) {
    return function(...args) {
      if (args.length) {
        message = message.replace(/\{(\d)\}/g, (_, n) => args[n] || "");
      }
      return new Error("ADM-ZIP: " + message);
    };
  }
  for (const msg of Object.keys(errors2)) {
    exports[msg] = E(errors2[msg]);
  }
})(errors);
const fsystem = fs$k;
const pth$2 = path$n;
const Constants$3 = constants$1;
const Errors$1 = errors;
const isWin = typeof process === "object" && "win32" === process.platform;
const is_Obj = (obj) => typeof obj === "object" && obj !== null;
const crcTable = new Uint32Array(256).map((t2, c) => {
  for (let k = 0; k < 8; k++) {
    if ((c & 1) !== 0) {
      c = 3988292384 ^ c >>> 1;
    } else {
      c >>>= 1;
    }
  }
  return c >>> 0;
});
function Utils$5(opts) {
  this.sep = pth$2.sep;
  this.fs = fsystem;
  if (is_Obj(opts)) {
    if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
      this.fs = opts.fs;
    }
  }
}
var utils$2 = Utils$5;
Utils$5.prototype.makeDir = function(folder) {
  const self2 = this;
  function mkdirSync(fpath) {
    let resolvedPath = fpath.split(self2.sep)[0];
    fpath.split(self2.sep).forEach(function(name) {
      if (!name || name.substr(-1, 1) === ":") return;
      resolvedPath += self2.sep + name;
      var stat2;
      try {
        stat2 = self2.fs.statSync(resolvedPath);
      } catch (e) {
        self2.fs.mkdirSync(resolvedPath);
      }
      if (stat2 && stat2.isFile()) throw Errors$1.FILE_IN_THE_WAY(`"${resolvedPath}"`);
    });
  }
  mkdirSync(folder);
};
Utils$5.prototype.writeFileTo = function(path2, content, overwrite, attr) {
  const self2 = this;
  if (self2.fs.existsSync(path2)) {
    if (!overwrite) return false;
    var stat2 = self2.fs.statSync(path2);
    if (stat2.isDirectory()) {
      return false;
    }
  }
  var folder = pth$2.dirname(path2);
  if (!self2.fs.existsSync(folder)) {
    self2.makeDir(folder);
  }
  var fd;
  try {
    fd = self2.fs.openSync(path2, "w", 438);
  } catch (e) {
    self2.fs.chmodSync(path2, 438);
    fd = self2.fs.openSync(path2, "w", 438);
  }
  if (fd) {
    try {
      self2.fs.writeSync(fd, content, 0, content.length, 0);
    } finally {
      self2.fs.closeSync(fd);
    }
  }
  self2.fs.chmodSync(path2, attr || 438);
  return true;
};
Utils$5.prototype.writeFileToAsync = function(path2, content, overwrite, attr, callback) {
  if (typeof attr === "function") {
    callback = attr;
    attr = void 0;
  }
  const self2 = this;
  self2.fs.exists(path2, function(exist) {
    if (exist && !overwrite) return callback(false);
    self2.fs.stat(path2, function(err2, stat2) {
      if (exist && stat2.isDirectory()) {
        return callback(false);
      }
      var folder = pth$2.dirname(path2);
      self2.fs.exists(folder, function(exists) {
        if (!exists) self2.makeDir(folder);
        self2.fs.open(path2, "w", 438, function(err3, fd) {
          if (err3) {
            self2.fs.chmod(path2, 438, function() {
              self2.fs.open(path2, "w", 438, function(err4, fd2) {
                self2.fs.write(fd2, content, 0, content.length, 0, function() {
                  self2.fs.close(fd2, function() {
                    self2.fs.chmod(path2, attr || 438, function() {
                      callback(true);
                    });
                  });
                });
              });
            });
          } else if (fd) {
            self2.fs.write(fd, content, 0, content.length, 0, function() {
              self2.fs.close(fd, function() {
                self2.fs.chmod(path2, attr || 438, function() {
                  callback(true);
                });
              });
            });
          } else {
            self2.fs.chmod(path2, attr || 438, function() {
              callback(true);
            });
          }
        });
      });
    });
  });
};
Utils$5.prototype.findFiles = function(path2) {
  const self2 = this;
  function findSync(dir, pattern2, recursive) {
    let files = [];
    self2.fs.readdirSync(dir).forEach(function(file2) {
      const path3 = pth$2.join(dir, file2);
      const stat2 = self2.fs.statSync(path3);
      {
        files.push(pth$2.normalize(path3) + (stat2.isDirectory() ? self2.sep : ""));
      }
      if (stat2.isDirectory() && recursive) files = files.concat(findSync(path3, pattern2, recursive));
    });
    return files;
  }
  return findSync(path2, void 0, true);
};
Utils$5.prototype.findFilesAsync = function(dir, cb) {
  const self2 = this;
  let results = [];
  self2.fs.readdir(dir, function(err2, list) {
    if (err2) return cb(err2);
    let list_length = list.length;
    if (!list_length) return cb(null, results);
    list.forEach(function(file2) {
      file2 = pth$2.join(dir, file2);
      self2.fs.stat(file2, function(err3, stat2) {
        if (err3) return cb(err3);
        if (stat2) {
          results.push(pth$2.normalize(file2) + (stat2.isDirectory() ? self2.sep : ""));
          if (stat2.isDirectory()) {
            self2.findFilesAsync(file2, function(err4, res2) {
              if (err4) return cb(err4);
              results = results.concat(res2);
              if (!--list_length) cb(null, results);
            });
          } else {
            if (!--list_length) cb(null, results);
          }
        }
      });
    });
  });
};
Utils$5.prototype.getAttributes = function() {
};
Utils$5.prototype.setAttributes = function() {
};
Utils$5.crc32update = function(crc, byte) {
  return crcTable[(crc ^ byte) & 255] ^ crc >>> 8;
};
Utils$5.crc32 = function(buf) {
  if (typeof buf === "string") {
    buf = Buffer.from(buf, "utf8");
  }
  let len = buf.length;
  let crc = -1;
  for (let off2 = 0; off2 < len; ) crc = Utils$5.crc32update(crc, buf[off2++]);
  return ~crc >>> 0;
};
Utils$5.methodToString = function(method) {
  switch (method) {
    case Constants$3.STORED:
      return "STORED (" + method + ")";
    case Constants$3.DEFLATED:
      return "DEFLATED (" + method + ")";
    default:
      return "UNSUPPORTED (" + method + ")";
  }
};
Utils$5.canonical = function(path2) {
  if (!path2) return "";
  const safeSuffix = pth$2.posix.normalize("/" + path2.split("\\").join("/"));
  return pth$2.join(".", safeSuffix);
};
Utils$5.zipnamefix = function(path2) {
  if (!path2) return "";
  const safeSuffix = pth$2.posix.normalize("/" + path2.split("\\").join("/"));
  return pth$2.posix.join(".", safeSuffix);
};
Utils$5.findLast = function(arr, callback) {
  if (!Array.isArray(arr)) throw new TypeError("arr is not array");
  const len = arr.length >>> 0;
  for (let i = len - 1; i >= 0; i--) {
    if (callback(arr[i], i, arr)) {
      return arr[i];
    }
  }
  return void 0;
};
Utils$5.sanitize = function(prefix, name) {
  prefix = pth$2.resolve(pth$2.normalize(prefix));
  var parts = name.split("/");
  for (var i = 0, l = parts.length; i < l; i++) {
    var path2 = pth$2.normalize(pth$2.join(prefix, parts.slice(i, l).join(pth$2.sep)));
    if (path2.indexOf(prefix) === 0) {
      return path2;
    }
  }
  return pth$2.normalize(pth$2.join(prefix, pth$2.basename(name)));
};
Utils$5.toBuffer = function toBuffer(input, encoder) {
  if (Buffer.isBuffer(input)) {
    return input;
  } else if (input instanceof Uint8Array) {
    return Buffer.from(input);
  } else {
    return typeof input === "string" ? encoder(input) : Buffer.alloc(0);
  }
};
Utils$5.readBigUInt64LE = function(buffer, index) {
  var slice = Buffer.from(buffer.slice(index, index + 8));
  slice.swap64();
  return parseInt(`0x${slice.toString("hex")}`);
};
Utils$5.fromDOS2Date = function(val) {
  return new Date((val >> 25 & 127) + 1980, Math.max((val >> 21 & 15) - 1, 0), Math.max(val >> 16 & 31, 1), val >> 11 & 31, val >> 5 & 63, (val & 31) << 1);
};
Utils$5.fromDate2DOS = function(val) {
  let date = 0;
  let time2 = 0;
  if (val.getFullYear() > 1979) {
    date = (val.getFullYear() - 1980 & 127) << 9 | val.getMonth() + 1 << 5 | val.getDate();
    time2 = val.getHours() << 11 | val.getMinutes() << 5 | val.getSeconds() >> 1;
  }
  return date << 16 | time2;
};
Utils$5.isWin = isWin;
Utils$5.crcTable = crcTable;
const pth$1 = path$n;
var fattr = function(path2, { fs: fs2 }) {
  var _path = path2 || "", _obj = newAttr(), _stat = null;
  function newAttr() {
    return {
      directory: false,
      readonly: false,
      hidden: false,
      executable: false,
      mtime: 0,
      atime: 0
    };
  }
  if (_path && fs2.existsSync(_path)) {
    _stat = fs2.statSync(_path);
    _obj.directory = _stat.isDirectory();
    _obj.mtime = _stat.mtime;
    _obj.atime = _stat.atime;
    _obj.executable = (73 & _stat.mode) !== 0;
    _obj.readonly = (128 & _stat.mode) === 0;
    _obj.hidden = pth$1.basename(_path)[0] === ".";
  } else {
    console.warn("Invalid path: " + _path);
  }
  return {
    get directory() {
      return _obj.directory;
    },
    get readOnly() {
      return _obj.readonly;
    },
    get hidden() {
      return _obj.hidden;
    },
    get mtime() {
      return _obj.mtime;
    },
    get atime() {
      return _obj.atime;
    },
    get executable() {
      return _obj.executable;
    },
    decodeAttributes: function() {
    },
    encodeAttributes: function() {
    },
    toJSON: function() {
      return {
        path: _path,
        isDirectory: _obj.directory,
        isReadOnly: _obj.readonly,
        isHidden: _obj.hidden,
        isExecutable: _obj.executable,
        mTime: _obj.mtime,
        aTime: _obj.atime
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
var decoder = {
  efs: true,
  encode: (data) => Buffer.from(data, "utf8"),
  decode: (data) => data.toString("utf8")
};
util$3.exports = utils$2;
util$3.exports.Constants = constants$1;
util$3.exports.Errors = errors;
util$3.exports.FileAttr = fattr;
util$3.exports.decoder = decoder;
var utilExports = util$3.exports;
var headers = {};
var Utils$4 = utilExports, Constants$2 = Utils$4.Constants;
var entryHeader = function() {
  var _verMade = 20, _version = 10, _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;
  _verMade |= Utils$4.isWin ? 2560 : 768;
  _flags |= Constants$2.FLG_EFS;
  const _localHeader = {
    extraLen: 0
  };
  const uint32 = (val) => Math.max(0, val) >>> 0;
  const uint8 = (val) => Math.max(0, val) & 255;
  _time = Utils$4.fromDate2DOS(/* @__PURE__ */ new Date());
  return {
    get made() {
      return _verMade;
    },
    set made(val) {
      _verMade = val;
    },
    get version() {
      return _version;
    },
    set version(val) {
      _version = val;
    },
    get flags() {
      return _flags;
    },
    set flags(val) {
      _flags = val;
    },
    get flags_efs() {
      return (_flags & Constants$2.FLG_EFS) > 0;
    },
    set flags_efs(val) {
      if (val) {
        _flags |= Constants$2.FLG_EFS;
      } else {
        _flags &= ~Constants$2.FLG_EFS;
      }
    },
    get flags_desc() {
      return (_flags & Constants$2.FLG_DESC) > 0;
    },
    set flags_desc(val) {
      if (val) {
        _flags |= Constants$2.FLG_DESC;
      } else {
        _flags &= ~Constants$2.FLG_DESC;
      }
    },
    get method() {
      return _method;
    },
    set method(val) {
      switch (val) {
        case Constants$2.STORED:
          this.version = 10;
        case Constants$2.DEFLATED:
        default:
          this.version = 20;
      }
      _method = val;
    },
    get time() {
      return Utils$4.fromDOS2Date(this.timeval);
    },
    set time(val) {
      this.timeval = Utils$4.fromDate2DOS(val);
    },
    get timeval() {
      return _time;
    },
    set timeval(val) {
      _time = uint32(val);
    },
    get timeHighByte() {
      return uint8(_time >>> 8);
    },
    get crc() {
      return _crc;
    },
    set crc(val) {
      _crc = uint32(val);
    },
    get compressedSize() {
      return _compressedSize;
    },
    set compressedSize(val) {
      _compressedSize = uint32(val);
    },
    get size() {
      return _size;
    },
    set size(val) {
      _size = uint32(val);
    },
    get fileNameLength() {
      return _fnameLen;
    },
    set fileNameLength(val) {
      _fnameLen = val;
    },
    get extraLength() {
      return _extraLen;
    },
    set extraLength(val) {
      _extraLen = val;
    },
    get extraLocalLength() {
      return _localHeader.extraLen;
    },
    set extraLocalLength(val) {
      _localHeader.extraLen = val;
    },
    get commentLength() {
      return _comLen;
    },
    set commentLength(val) {
      _comLen = val;
    },
    get diskNumStart() {
      return _diskStart;
    },
    set diskNumStart(val) {
      _diskStart = uint32(val);
    },
    get inAttr() {
      return _inattr;
    },
    set inAttr(val) {
      _inattr = uint32(val);
    },
    get attr() {
      return _attr;
    },
    set attr(val) {
      _attr = uint32(val);
    },
    // get Unix file permissions
    get fileAttr() {
      return (_attr || 0) >> 16 & 4095;
    },
    get offset() {
      return _offset;
    },
    set offset(val) {
      _offset = uint32(val);
    },
    get encrypted() {
      return (_flags & Constants$2.FLG_ENC) === Constants$2.FLG_ENC;
    },
    get centralHeaderSize() {
      return Constants$2.CENHDR + _fnameLen + _extraLen + _comLen;
    },
    get realDataOffset() {
      return _offset + Constants$2.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;
    },
    get localHeader() {
      return _localHeader;
    },
    loadLocalHeaderFromBinary: function(input) {
      var data = input.slice(_offset, _offset + Constants$2.LOCHDR);
      if (data.readUInt32LE(0) !== Constants$2.LOCSIG) {
        throw Utils$4.Errors.INVALID_LOC();
      }
      _localHeader.version = data.readUInt16LE(Constants$2.LOCVER);
      _localHeader.flags = data.readUInt16LE(Constants$2.LOCFLG);
      _localHeader.method = data.readUInt16LE(Constants$2.LOCHOW);
      _localHeader.time = data.readUInt32LE(Constants$2.LOCTIM);
      _localHeader.crc = data.readUInt32LE(Constants$2.LOCCRC);
      _localHeader.compressedSize = data.readUInt32LE(Constants$2.LOCSIZ);
      _localHeader.size = data.readUInt32LE(Constants$2.LOCLEN);
      _localHeader.fnameLen = data.readUInt16LE(Constants$2.LOCNAM);
      _localHeader.extraLen = data.readUInt16LE(Constants$2.LOCEXT);
      const extraStart = _offset + Constants$2.LOCHDR + _localHeader.fnameLen;
      const extraEnd = extraStart + _localHeader.extraLen;
      return input.slice(extraStart, extraEnd);
    },
    loadFromBinary: function(data) {
      if (data.length !== Constants$2.CENHDR || data.readUInt32LE(0) !== Constants$2.CENSIG) {
        throw Utils$4.Errors.INVALID_CEN();
      }
      _verMade = data.readUInt16LE(Constants$2.CENVEM);
      _version = data.readUInt16LE(Constants$2.CENVER);
      _flags = data.readUInt16LE(Constants$2.CENFLG);
      _method = data.readUInt16LE(Constants$2.CENHOW);
      _time = data.readUInt32LE(Constants$2.CENTIM);
      _crc = data.readUInt32LE(Constants$2.CENCRC);
      _compressedSize = data.readUInt32LE(Constants$2.CENSIZ);
      _size = data.readUInt32LE(Constants$2.CENLEN);
      _fnameLen = data.readUInt16LE(Constants$2.CENNAM);
      _extraLen = data.readUInt16LE(Constants$2.CENEXT);
      _comLen = data.readUInt16LE(Constants$2.CENCOM);
      _diskStart = data.readUInt16LE(Constants$2.CENDSK);
      _inattr = data.readUInt16LE(Constants$2.CENATT);
      _attr = data.readUInt32LE(Constants$2.CENATX);
      _offset = data.readUInt32LE(Constants$2.CENOFF);
    },
    localHeaderToBinary: function() {
      var data = Buffer.alloc(Constants$2.LOCHDR);
      data.writeUInt32LE(Constants$2.LOCSIG, 0);
      data.writeUInt16LE(_version, Constants$2.LOCVER);
      data.writeUInt16LE(_flags, Constants$2.LOCFLG);
      data.writeUInt16LE(_method, Constants$2.LOCHOW);
      data.writeUInt32LE(_time, Constants$2.LOCTIM);
      data.writeUInt32LE(_crc, Constants$2.LOCCRC);
      data.writeUInt32LE(_compressedSize, Constants$2.LOCSIZ);
      data.writeUInt32LE(_size, Constants$2.LOCLEN);
      data.writeUInt16LE(_fnameLen, Constants$2.LOCNAM);
      data.writeUInt16LE(_localHeader.extraLen, Constants$2.LOCEXT);
      return data;
    },
    centralHeaderToBinary: function() {
      var data = Buffer.alloc(Constants$2.CENHDR + _fnameLen + _extraLen + _comLen);
      data.writeUInt32LE(Constants$2.CENSIG, 0);
      data.writeUInt16LE(_verMade, Constants$2.CENVEM);
      data.writeUInt16LE(_version, Constants$2.CENVER);
      data.writeUInt16LE(_flags, Constants$2.CENFLG);
      data.writeUInt16LE(_method, Constants$2.CENHOW);
      data.writeUInt32LE(_time, Constants$2.CENTIM);
      data.writeUInt32LE(_crc, Constants$2.CENCRC);
      data.writeUInt32LE(_compressedSize, Constants$2.CENSIZ);
      data.writeUInt32LE(_size, Constants$2.CENLEN);
      data.writeUInt16LE(_fnameLen, Constants$2.CENNAM);
      data.writeUInt16LE(_extraLen, Constants$2.CENEXT);
      data.writeUInt16LE(_comLen, Constants$2.CENCOM);
      data.writeUInt16LE(_diskStart, Constants$2.CENDSK);
      data.writeUInt16LE(_inattr, Constants$2.CENATT);
      data.writeUInt32LE(_attr, Constants$2.CENATX);
      data.writeUInt32LE(_offset, Constants$2.CENOFF);
      return data;
    },
    toJSON: function() {
      const bytes = function(nr) {
        return nr + " bytes";
      };
      return {
        made: _verMade,
        version: _version,
        flags: _flags,
        method: Utils$4.methodToString(_method),
        time: this.time,
        crc: "0x" + _crc.toString(16).toUpperCase(),
        compressedSize: bytes(_compressedSize),
        size: bytes(_size),
        fileNameLength: bytes(_fnameLen),
        extraLength: bytes(_extraLen),
        commentLength: bytes(_comLen),
        diskNumStart: _diskStart,
        inAttr: _inattr,
        attr: _attr,
        offset: _offset,
        centralHeaderSize: bytes(Constants$2.CENHDR + _fnameLen + _extraLen + _comLen)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
var Utils$3 = utilExports, Constants$1 = Utils$3.Constants;
var mainHeader = function() {
  var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;
  return {
    get diskEntries() {
      return _volumeEntries;
    },
    set diskEntries(val) {
      _volumeEntries = _totalEntries = val;
    },
    get totalEntries() {
      return _totalEntries;
    },
    set totalEntries(val) {
      _totalEntries = _volumeEntries = val;
    },
    get size() {
      return _size;
    },
    set size(val) {
      _size = val;
    },
    get offset() {
      return _offset;
    },
    set offset(val) {
      _offset = val;
    },
    get commentLength() {
      return _commentLength;
    },
    set commentLength(val) {
      _commentLength = val;
    },
    get mainHeaderSize() {
      return Constants$1.ENDHDR + _commentLength;
    },
    loadFromBinary: function(data) {
      if ((data.length !== Constants$1.ENDHDR || data.readUInt32LE(0) !== Constants$1.ENDSIG) && (data.length < Constants$1.ZIP64HDR || data.readUInt32LE(0) !== Constants$1.ZIP64SIG)) {
        throw Utils$3.Errors.INVALID_END();
      }
      if (data.readUInt32LE(0) === Constants$1.ENDSIG) {
        _volumeEntries = data.readUInt16LE(Constants$1.ENDSUB);
        _totalEntries = data.readUInt16LE(Constants$1.ENDTOT);
        _size = data.readUInt32LE(Constants$1.ENDSIZ);
        _offset = data.readUInt32LE(Constants$1.ENDOFF);
        _commentLength = data.readUInt16LE(Constants$1.ENDCOM);
      } else {
        _volumeEntries = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64SUB);
        _totalEntries = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64TOT);
        _size = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64SIZE);
        _offset = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64OFF);
        _commentLength = 0;
      }
    },
    toBinary: function() {
      var b = Buffer.alloc(Constants$1.ENDHDR + _commentLength);
      b.writeUInt32LE(Constants$1.ENDSIG, 0);
      b.writeUInt32LE(0, 4);
      b.writeUInt16LE(_volumeEntries, Constants$1.ENDSUB);
      b.writeUInt16LE(_totalEntries, Constants$1.ENDTOT);
      b.writeUInt32LE(_size, Constants$1.ENDSIZ);
      b.writeUInt32LE(_offset, Constants$1.ENDOFF);
      b.writeUInt16LE(_commentLength, Constants$1.ENDCOM);
      b.fill(" ", Constants$1.ENDHDR);
      return b;
    },
    toJSON: function() {
      const offset = function(nr, len) {
        let offs = nr.toString(16).toUpperCase();
        while (offs.length < len) offs = "0" + offs;
        return "0x" + offs;
      };
      return {
        diskEntries: _volumeEntries,
        totalEntries: _totalEntries,
        size: _size + " bytes",
        offset: offset(_offset, 4),
        commentLength: _commentLength
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
headers.EntryHeader = entryHeader;
headers.MainHeader = mainHeader;
var methods = {};
var deflater = function(inbuf) {
  var zlib$1 = zlib;
  var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };
  return {
    deflate: function() {
      return zlib$1.deflateRawSync(inbuf, opts);
    },
    deflateAsync: function(callback) {
      var tmp = zlib$1.createDeflateRaw(opts), parts = [], total = 0;
      tmp.on("data", function(data) {
        parts.push(data);
        total += data.length;
      });
      tmp.on("end", function() {
        var buf = Buffer.alloc(total), written = 0;
        buf.fill(0);
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          part.copy(buf, written);
          written += part.length;
        }
        callback && callback(buf);
      });
      tmp.end(inbuf);
    }
  };
};
const version = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
var inflater = function(inbuf, expectedLength) {
  var zlib$1 = zlib;
  const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};
  return {
    inflate: function() {
      return zlib$1.inflateRawSync(inbuf, option);
    },
    inflateAsync: function(callback) {
      var tmp = zlib$1.createInflateRaw(option), parts = [], total = 0;
      tmp.on("data", function(data) {
        parts.push(data);
        total += data.length;
      });
      tmp.on("end", function() {
        var buf = Buffer.alloc(total), written = 0;
        buf.fill(0);
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          part.copy(buf, written);
          written += part.length;
        }
        callback && callback(buf);
      });
      tmp.end(inbuf);
    }
  };
};
const { randomFillSync } = require$$0$c;
const Errors = errors;
const crctable = new Uint32Array(256).map((t2, crc) => {
  for (let j = 0; j < 8; j++) {
    if (0 !== (crc & 1)) {
      crc = crc >>> 1 ^ 3988292384;
    } else {
      crc >>>= 1;
    }
  }
  return crc >>> 0;
});
const uMul = (a, b) => Math.imul(a, b) >>> 0;
const crc32update = (pCrc32, bval) => {
  return crctable[(pCrc32 ^ bval) & 255] ^ pCrc32 >>> 8;
};
const genSalt = () => {
  if ("function" === typeof randomFillSync) {
    return randomFillSync(Buffer.alloc(12));
  } else {
    return genSalt.node();
  }
};
genSalt.node = () => {
  const salt = Buffer.alloc(12);
  const len = salt.length;
  for (let i = 0; i < len; i++) salt[i] = Math.random() * 256 & 255;
  return salt;
};
const config = {
  genSalt
};
function Initkeys(pw) {
  const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
  this.keys = new Uint32Array([305419896, 591751049, 878082192]);
  for (let i = 0; i < pass.length; i++) {
    this.updateKeys(pass[i]);
  }
}
Initkeys.prototype.updateKeys = function(byteValue) {
  const keys2 = this.keys;
  keys2[0] = crc32update(keys2[0], byteValue);
  keys2[1] += keys2[0] & 255;
  keys2[1] = uMul(keys2[1], 134775813) + 1;
  keys2[2] = crc32update(keys2[2], keys2[1] >>> 24);
  return byteValue;
};
Initkeys.prototype.next = function() {
  const k = (this.keys[2] | 2) >>> 0;
  return uMul(k, k ^ 1) >> 8 & 255;
};
function make_decrypter(pwd) {
  const keys2 = new Initkeys(pwd);
  return function(data) {
    const result = Buffer.alloc(data.length);
    let pos = 0;
    for (let c of data) {
      result[pos++] = keys2.updateKeys(c ^ keys2.next());
    }
    return result;
  };
}
function make_encrypter(pwd) {
  const keys2 = new Initkeys(pwd);
  return function(data, result, pos = 0) {
    if (!result) result = Buffer.alloc(data.length);
    for (let c of data) {
      const k = keys2.next();
      result[pos++] = c ^ k;
      keys2.updateKeys(c);
    }
    return result;
  };
}
function decrypt(data, header, pwd) {
  if (!data || !Buffer.isBuffer(data) || data.length < 12) {
    return Buffer.alloc(0);
  }
  const decrypter = make_decrypter(pwd);
  const salt = decrypter(data.slice(0, 12));
  const verifyByte = (header.flags & 8) === 8 ? header.timeHighByte : header.crc >>> 24;
  if (salt[11] !== verifyByte) {
    throw Errors.WRONG_PASSWORD();
  }
  return decrypter(data.slice(12));
}
function _salter(data) {
  if (Buffer.isBuffer(data) && data.length >= 12) {
    config.genSalt = function() {
      return data.slice(0, 12);
    };
  } else if (data === "node") {
    config.genSalt = genSalt.node;
  } else {
    config.genSalt = genSalt;
  }
}
function encrypt(data, header, pwd, oldlike = false) {
  if (data == null) data = Buffer.alloc(0);
  if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());
  const encrypter = make_encrypter(pwd);
  const salt = config.genSalt();
  salt[11] = header.crc >>> 24 & 255;
  if (oldlike) salt[10] = header.crc >>> 16 & 255;
  const result = Buffer.alloc(data.length + 12);
  encrypter(salt, result);
  return encrypter(data, result, 12);
}
var zipcrypto = { decrypt, encrypt, _salter };
methods.Deflater = deflater;
methods.Inflater = inflater;
methods.ZipCrypto = zipcrypto;
var Utils$2 = utilExports, Headers$1 = headers, Constants = Utils$2.Constants, Methods = methods;
var zipEntry = function(options, input) {
  var _centralHeader = new Headers$1.EntryHeader(), _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0), _extralocal = Buffer.alloc(0), _efs = true;
  const opts = options;
  const decoder2 = typeof opts.decoder === "object" ? opts.decoder : Utils$2.decoder;
  _efs = decoder2.hasOwnProperty("efs") ? decoder2.efs : false;
  function getCompressedDataFromZip() {
    if (!input || !(input instanceof Uint8Array)) {
      return Buffer.alloc(0);
    }
    _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);
    return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);
  }
  function crc32OK(data) {
    if (!_centralHeader.flags_desc) {
      if (Utils$2.crc32(data) !== _centralHeader.localHeader.crc) {
        return false;
      }
    } else {
      const descriptor = {};
      const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;
      if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {
        throw Utils$2.Errors.DESCRIPTOR_NOT_EXIST();
      }
      if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {
        descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);
        descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);
        descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);
      } else if (input.readUInt16LE(dataEndOffset + 12) === 19280) {
        descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);
        descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);
        descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);
      } else {
        throw Utils$2.Errors.DESCRIPTOR_UNKNOWN();
      }
      if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {
        throw Utils$2.Errors.DESCRIPTOR_FAULTY();
      }
      if (Utils$2.crc32(data) !== descriptor.crc) {
        return false;
      }
    }
    return true;
  }
  function decompress(async2, callback, pass) {
    if (typeof callback === "undefined" && typeof async2 === "string") {
      pass = async2;
      async2 = void 0;
    }
    if (_isDirectory) {
      if (async2 && callback) {
        callback(Buffer.alloc(0), Utils$2.Errors.DIRECTORY_CONTENT_ERROR());
      }
      return Buffer.alloc(0);
    }
    var compressedData = getCompressedDataFromZip();
    if (compressedData.length === 0) {
      if (async2 && callback) callback(compressedData);
      return compressedData;
    }
    if (_centralHeader.encrypted) {
      if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
        throw Utils$2.Errors.INVALID_PASS_PARAM();
      }
      compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);
    }
    var data = Buffer.alloc(_centralHeader.size);
    switch (_centralHeader.method) {
      case Utils$2.Constants.STORED:
        compressedData.copy(data);
        if (!crc32OK(data)) {
          if (async2 && callback) callback(data, Utils$2.Errors.BAD_CRC());
          throw Utils$2.Errors.BAD_CRC();
        } else {
          if (async2 && callback) callback(data);
          return data;
        }
      case Utils$2.Constants.DEFLATED:
        var inflater2 = new Methods.Inflater(compressedData, _centralHeader.size);
        if (!async2) {
          const result = inflater2.inflate(data);
          result.copy(data, 0);
          if (!crc32OK(data)) {
            throw Utils$2.Errors.BAD_CRC(`"${decoder2.decode(_entryName)}"`);
          }
          return data;
        } else {
          inflater2.inflateAsync(function(result) {
            result.copy(result, 0);
            if (callback) {
              if (!crc32OK(result)) {
                callback(result, Utils$2.Errors.BAD_CRC());
              } else {
                callback(result);
              }
            }
          });
        }
        break;
      default:
        if (async2 && callback) callback(Buffer.alloc(0), Utils$2.Errors.UNKNOWN_METHOD());
        throw Utils$2.Errors.UNKNOWN_METHOD();
    }
  }
  function compress(async2, callback) {
    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
      if (async2 && callback) callback(getCompressedDataFromZip());
      return getCompressedDataFromZip();
    }
    if (uncompressedData.length && !_isDirectory) {
      var compressedData;
      switch (_centralHeader.method) {
        case Utils$2.Constants.STORED:
          _centralHeader.compressedSize = _centralHeader.size;
          compressedData = Buffer.alloc(uncompressedData.length);
          uncompressedData.copy(compressedData);
          if (async2 && callback) callback(compressedData);
          return compressedData;
        default:
        case Utils$2.Constants.DEFLATED:
          var deflater2 = new Methods.Deflater(uncompressedData);
          if (!async2) {
            var deflated = deflater2.deflate();
            _centralHeader.compressedSize = deflated.length;
            return deflated;
          } else {
            deflater2.deflateAsync(function(data) {
              compressedData = Buffer.alloc(data.length);
              _centralHeader.compressedSize = data.length;
              data.copy(compressedData);
              callback && callback(compressedData);
            });
          }
          deflater2 = null;
          break;
      }
    } else if (async2 && callback) {
      callback(Buffer.alloc(0));
    } else {
      return Buffer.alloc(0);
    }
  }
  function readUInt64LE(buffer, offset) {
    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
  }
  function parseExtra(data) {
    try {
      var offset = 0;
      var signature, size, part;
      while (offset + 4 < data.length) {
        signature = data.readUInt16LE(offset);
        offset += 2;
        size = data.readUInt16LE(offset);
        offset += 2;
        part = data.slice(offset, offset + size);
        offset += size;
        if (Constants.ID_ZIP64 === signature) {
          parseZip64ExtendedInformation(part);
        }
      }
    } catch (error2) {
      throw Utils$2.Errors.EXTRA_FIELD_PARSE_ERROR();
    }
  }
  function parseZip64ExtendedInformation(data) {
    var size, compressedSize, offset, diskNumStart;
    if (data.length >= Constants.EF_ZIP64_SCOMP) {
      size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
      if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {
        _centralHeader.size = size;
      }
    }
    if (data.length >= Constants.EF_ZIP64_RHO) {
      compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
      if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
        _centralHeader.compressedSize = compressedSize;
      }
    }
    if (data.length >= Constants.EF_ZIP64_DSN) {
      offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
      if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {
        _centralHeader.offset = offset;
      }
    }
    if (data.length >= Constants.EF_ZIP64_DSN + 4) {
      diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
      if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
        _centralHeader.diskNumStart = diskNumStart;
      }
    }
  }
  return {
    get entryName() {
      return decoder2.decode(_entryName);
    },
    get rawEntryName() {
      return _entryName;
    },
    set entryName(val) {
      _entryName = Utils$2.toBuffer(val, decoder2.encode);
      var lastChar = _entryName[_entryName.length - 1];
      _isDirectory = lastChar === 47 || lastChar === 92;
      _centralHeader.fileNameLength = _entryName.length;
    },
    get efs() {
      if (typeof _efs === "function") {
        return _efs(this.entryName);
      } else {
        return _efs;
      }
    },
    get extra() {
      return _extra;
    },
    set extra(val) {
      _extra = val;
      _centralHeader.extraLength = val.length;
      parseExtra(val);
    },
    get comment() {
      return decoder2.decode(_comment);
    },
    set comment(val) {
      _comment = Utils$2.toBuffer(val, decoder2.encode);
      _centralHeader.commentLength = _comment.length;
      if (_comment.length > 65535) throw Utils$2.Errors.COMMENT_TOO_LONG();
    },
    get name() {
      var n = decoder2.decode(_entryName);
      return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop();
    },
    get isDirectory() {
      return _isDirectory;
    },
    getCompressedData: function() {
      return compress(false, null);
    },
    getCompressedDataAsync: function(callback) {
      compress(true, callback);
    },
    setData: function(value) {
      uncompressedData = Utils$2.toBuffer(value, Utils$2.decoder.encode);
      if (!_isDirectory && uncompressedData.length) {
        _centralHeader.size = uncompressedData.length;
        _centralHeader.method = Utils$2.Constants.DEFLATED;
        _centralHeader.crc = Utils$2.crc32(value);
        _centralHeader.changed = true;
      } else {
        _centralHeader.method = Utils$2.Constants.STORED;
      }
    },
    getData: function(pass) {
      if (_centralHeader.changed) {
        return uncompressedData;
      } else {
        return decompress(false, null, pass);
      }
    },
    getDataAsync: function(callback, pass) {
      if (_centralHeader.changed) {
        callback(uncompressedData);
      } else {
        decompress(true, callback, pass);
      }
    },
    set attr(attr) {
      _centralHeader.attr = attr;
    },
    get attr() {
      return _centralHeader.attr;
    },
    set header(data) {
      _centralHeader.loadFromBinary(data);
    },
    get header() {
      return _centralHeader;
    },
    packCentralHeader: function() {
      _centralHeader.flags_efs = this.efs;
      _centralHeader.extraLength = _extra.length;
      var header = _centralHeader.centralHeaderToBinary();
      var addpos = Utils$2.Constants.CENHDR;
      _entryName.copy(header, addpos);
      addpos += _entryName.length;
      _extra.copy(header, addpos);
      addpos += _centralHeader.extraLength;
      _comment.copy(header, addpos);
      return header;
    },
    packLocalHeader: function() {
      let addpos = 0;
      _centralHeader.flags_efs = this.efs;
      _centralHeader.extraLocalLength = _extralocal.length;
      const localHeaderBuf = _centralHeader.localHeaderToBinary();
      const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);
      localHeaderBuf.copy(localHeader, addpos);
      addpos += localHeaderBuf.length;
      _entryName.copy(localHeader, addpos);
      addpos += _entryName.length;
      _extralocal.copy(localHeader, addpos);
      addpos += _extralocal.length;
      return localHeader;
    },
    toJSON: function() {
      const bytes = function(nr) {
        return "<" + (nr && nr.length + " bytes buffer" || "null") + ">";
      };
      return {
        entryName: this.entryName,
        name: this.name,
        comment: this.comment,
        isDirectory: this.isDirectory,
        header: _centralHeader.toJSON(),
        compressedData: bytes(input),
        data: bytes(uncompressedData)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
const ZipEntry$1 = zipEntry;
const Headers = headers;
const Utils$1 = utilExports;
var zipFile = function(inBuffer, options) {
  var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader2 = new Headers.MainHeader(), loadedEntries = false;
  const temporary = /* @__PURE__ */ new Set();
  const opts = options;
  const { noSort, decoder: decoder2 } = opts;
  if (inBuffer) {
    readMainHeader(opts.readEntries);
  } else {
    loadedEntries = true;
  }
  function makeTemporaryFolders() {
    const foldersList = /* @__PURE__ */ new Set();
    for (const elem of Object.keys(entryTable)) {
      const elements2 = elem.split("/");
      elements2.pop();
      if (!elements2.length) continue;
      for (let i = 0; i < elements2.length; i++) {
        const sub = elements2.slice(0, i + 1).join("/") + "/";
        foldersList.add(sub);
      }
    }
    for (const elem of foldersList) {
      if (!(elem in entryTable)) {
        const tempfolder = new ZipEntry$1(opts);
        tempfolder.entryName = elem;
        tempfolder.attr = 16;
        tempfolder.temporary = true;
        entryList.push(tempfolder);
        entryTable[tempfolder.entryName] = tempfolder;
        temporary.add(tempfolder);
      }
    }
  }
  function readEntries() {
    loadedEntries = true;
    entryTable = {};
    if (mainHeader2.diskEntries > (inBuffer.length - mainHeader2.offset) / Utils$1.Constants.CENHDR) {
      throw Utils$1.Errors.DISK_ENTRY_TOO_LARGE();
    }
    entryList = new Array(mainHeader2.diskEntries);
    var index = mainHeader2.offset;
    for (var i = 0; i < entryList.length; i++) {
      var tmp = index, entry = new ZipEntry$1(opts, inBuffer);
      entry.header = inBuffer.slice(tmp, tmp += Utils$1.Constants.CENHDR);
      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
      if (entry.header.extraLength) {
        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
      }
      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
      index += entry.header.centralHeaderSize;
      entryList[i] = entry;
      entryTable[entry.entryName] = entry;
    }
    temporary.clear();
    makeTemporaryFolders();
  }
  function readMainHeader(readNow) {
    var i = inBuffer.length - Utils$1.Constants.ENDHDR, max2 = Math.max(0, i - 65535), n = max2, endStart = inBuffer.length, endOffset = -1, commentEnd = 0;
    const trailingSpace = typeof opts.trailingSpace === "boolean" ? opts.trailingSpace : false;
    if (trailingSpace) max2 = 0;
    for (i; i >= n; i--) {
      if (inBuffer[i] !== 80) continue;
      if (inBuffer.readUInt32LE(i) === Utils$1.Constants.ENDSIG) {
        endOffset = i;
        commentEnd = i;
        endStart = i + Utils$1.Constants.ENDHDR;
        n = i - Utils$1.Constants.END64HDR;
        continue;
      }
      if (inBuffer.readUInt32LE(i) === Utils$1.Constants.END64SIG) {
        n = max2;
        continue;
      }
      if (inBuffer.readUInt32LE(i) === Utils$1.Constants.ZIP64SIG) {
        endOffset = i;
        endStart = i + Utils$1.readBigUInt64LE(inBuffer, i + Utils$1.Constants.ZIP64SIZE) + Utils$1.Constants.ZIP64LEAD;
        break;
      }
    }
    if (endOffset == -1) throw Utils$1.Errors.INVALID_FORMAT();
    mainHeader2.loadFromBinary(inBuffer.slice(endOffset, endStart));
    if (mainHeader2.commentLength) {
      _comment = inBuffer.slice(commentEnd + Utils$1.Constants.ENDHDR);
    }
    if (readNow) readEntries();
  }
  function sortEntries() {
    if (entryList.length > 1 && !noSort) {
      entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
    }
  }
  return {
    /**
     * Returns an array of ZipEntry objects existent in the current opened archive
     * @return Array
     */
    get entries() {
      if (!loadedEntries) {
        readEntries();
      }
      return entryList.filter((e) => !temporary.has(e));
    },
    /**
     * Archive comment
     * @return {String}
     */
    get comment() {
      return decoder2.decode(_comment);
    },
    set comment(val) {
      _comment = Utils$1.toBuffer(val, decoder2.encode);
      mainHeader2.commentLength = _comment.length;
    },
    getEntryCount: function() {
      if (!loadedEntries) {
        return mainHeader2.diskEntries;
      }
      return entryList.length;
    },
    forEach: function(callback) {
      this.entries.forEach(callback);
    },
    /**
     * Returns a reference to the entry with the given name or null if entry is inexistent
     *
     * @param entryName
     * @return ZipEntry
     */
    getEntry: function(entryName) {
      if (!loadedEntries) {
        readEntries();
      }
      return entryTable[entryName] || null;
    },
    /**
     * Adds the given entry to the entry list
     *
     * @param entry
     */
    setEntry: function(entry) {
      if (!loadedEntries) {
        readEntries();
      }
      entryList.push(entry);
      entryTable[entry.entryName] = entry;
      mainHeader2.totalEntries = entryList.length;
    },
    /**
     * Removes the file with the given name from the entry list.
     *
     * If the entry is a directory, then all nested files and directories will be removed
     * @param entryName
     * @returns {void}
     */
    deleteFile: function(entryName, withsubfolders = true) {
      if (!loadedEntries) {
        readEntries();
      }
      const entry = entryTable[entryName];
      const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);
      list.forEach(this.deleteEntry);
    },
    /**
     * Removes the entry with the given name from the entry list.
     *
     * @param {string} entryName
     * @returns {void}
     */
    deleteEntry: function(entryName) {
      if (!loadedEntries) {
        readEntries();
      }
      const entry = entryTable[entryName];
      const index = entryList.indexOf(entry);
      if (index >= 0) {
        entryList.splice(index, 1);
        delete entryTable[entryName];
        mainHeader2.totalEntries = entryList.length;
      }
    },
    /**
     *  Iterates and returns all nested files and directories of the given entry
     *
     * @param entry
     * @return Array
     */
    getEntryChildren: function(entry, subfolders = true) {
      if (!loadedEntries) {
        readEntries();
      }
      if (typeof entry === "object") {
        if (entry.isDirectory && subfolders) {
          const list = [];
          const name = entry.entryName;
          for (const zipEntry2 of entryList) {
            if (zipEntry2.entryName.startsWith(name)) {
              list.push(zipEntry2);
            }
          }
          return list;
        } else {
          return [entry];
        }
      }
      return [];
    },
    /**
     *  How many child elements entry has
     *
     * @param {ZipEntry} entry
     * @return {integer}
     */
    getChildCount: function(entry) {
      if (entry && entry.isDirectory) {
        const list = this.getEntryChildren(entry);
        return list.includes(entry) ? list.length - 1 : list.length;
      }
      return 0;
    },
    /**
     * Returns the zip file
     *
     * @return Buffer
     */
    compressToBuffer: function() {
      if (!loadedEntries) {
        readEntries();
      }
      sortEntries();
      const dataBlock = [];
      const headerBlocks = [];
      let totalSize = 0;
      let dindex = 0;
      mainHeader2.size = 0;
      mainHeader2.offset = 0;
      let totalEntries = 0;
      for (const entry of this.entries) {
        const compressedData = entry.getCompressedData();
        entry.header.offset = dindex;
        const localHeader = entry.packLocalHeader();
        const dataLength = localHeader.length + compressedData.length;
        dindex += dataLength;
        dataBlock.push(localHeader);
        dataBlock.push(compressedData);
        const centralHeader = entry.packCentralHeader();
        headerBlocks.push(centralHeader);
        mainHeader2.size += centralHeader.length;
        totalSize += dataLength + centralHeader.length;
        totalEntries++;
      }
      totalSize += mainHeader2.mainHeaderSize;
      mainHeader2.offset = dindex;
      mainHeader2.totalEntries = totalEntries;
      dindex = 0;
      const outBuffer = Buffer.alloc(totalSize);
      for (const content of dataBlock) {
        content.copy(outBuffer, dindex);
        dindex += content.length;
      }
      for (const content of headerBlocks) {
        content.copy(outBuffer, dindex);
        dindex += content.length;
      }
      const mh = mainHeader2.toBinary();
      if (_comment) {
        _comment.copy(mh, Utils$1.Constants.ENDHDR);
      }
      mh.copy(outBuffer, dindex);
      inBuffer = outBuffer;
      loadedEntries = false;
      return outBuffer;
    },
    toAsyncBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
      try {
        if (!loadedEntries) {
          readEntries();
        }
        sortEntries();
        const dataBlock = [];
        const centralHeaders = [];
        let totalSize = 0;
        let dindex = 0;
        let totalEntries = 0;
        mainHeader2.size = 0;
        mainHeader2.offset = 0;
        const compress2Buffer = function(entryLists) {
          if (entryLists.length > 0) {
            const entry = entryLists.shift();
            const name = entry.entryName + entry.extra.toString();
            if (onItemStart) onItemStart(name);
            entry.getCompressedDataAsync(function(compressedData) {
              if (onItemEnd) onItemEnd(name);
              entry.header.offset = dindex;
              const localHeader = entry.packLocalHeader();
              const dataLength = localHeader.length + compressedData.length;
              dindex += dataLength;
              dataBlock.push(localHeader);
              dataBlock.push(compressedData);
              const centalHeader = entry.packCentralHeader();
              centralHeaders.push(centalHeader);
              mainHeader2.size += centalHeader.length;
              totalSize += dataLength + centalHeader.length;
              totalEntries++;
              compress2Buffer(entryLists);
            });
          } else {
            totalSize += mainHeader2.mainHeaderSize;
            mainHeader2.offset = dindex;
            mainHeader2.totalEntries = totalEntries;
            dindex = 0;
            const outBuffer = Buffer.alloc(totalSize);
            dataBlock.forEach(function(content) {
              content.copy(outBuffer, dindex);
              dindex += content.length;
            });
            centralHeaders.forEach(function(content) {
              content.copy(outBuffer, dindex);
              dindex += content.length;
            });
            const mh = mainHeader2.toBinary();
            if (_comment) {
              _comment.copy(mh, Utils$1.Constants.ENDHDR);
            }
            mh.copy(outBuffer, dindex);
            inBuffer = outBuffer;
            loadedEntries = false;
            onSuccess(outBuffer);
          }
        };
        compress2Buffer(Array.from(this.entries));
      } catch (e) {
        onFail(e);
      }
    }
  };
};
const Utils = utilExports;
const pth = path$n;
const ZipEntry = zipEntry;
const ZipFile = zipFile;
const get_Bool = (...val) => Utils.findLast(val, (c) => typeof c === "boolean");
const get_Str = (...val) => Utils.findLast(val, (c) => typeof c === "string");
const get_Fun = (...val) => Utils.findLast(val, (c) => typeof c === "function");
const defaultOptions = {
  // option "noSort" : if true it disables files sorting
  noSort: false,
  // read entries during load (initial loading may be slower)
  readEntries: false,
  // default method is none
  method: Utils.Constants.NONE,
  // file system
  fs: null
};
var admZip = function(input, options) {
  let inBuffer = null;
  const opts = Object.assign(/* @__PURE__ */ Object.create(null), defaultOptions);
  if (input && "object" === typeof input) {
    if (!(input instanceof Uint8Array)) {
      Object.assign(opts, input);
      input = opts.input ? opts.input : void 0;
      if (opts.input) delete opts.input;
    }
    if (Buffer.isBuffer(input)) {
      inBuffer = input;
      opts.method = Utils.Constants.BUFFER;
      input = void 0;
    }
  }
  Object.assign(opts, options);
  const filetools = new Utils(opts);
  if (typeof opts.decoder !== "object" || typeof opts.decoder.encode !== "function" || typeof opts.decoder.decode !== "function") {
    opts.decoder = Utils.decoder;
  }
  if (input && "string" === typeof input) {
    if (filetools.fs.existsSync(input)) {
      opts.method = Utils.Constants.FILE;
      opts.filename = input;
      inBuffer = filetools.fs.readFileSync(input);
    } else {
      throw Utils.Errors.INVALID_FILENAME();
    }
  }
  const _zip = new ZipFile(inBuffer, opts);
  const { canonical, sanitize, zipnamefix } = Utils;
  function getEntry(entry) {
    if (entry && _zip) {
      var item;
      if (typeof entry === "string") item = _zip.getEntry(pth.posix.normalize(entry));
      if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined") item = _zip.getEntry(entry.entryName);
      if (item) {
        return item;
      }
    }
    return null;
  }
  function fixPath(zipPath) {
    const { join, normalize: normalize2, sep } = pth.posix;
    return join(".", normalize2(sep + zipPath.split("\\").join(sep) + sep));
  }
  function filenameFilter(filterfn) {
    if (filterfn instanceof RegExp) {
      return /* @__PURE__ */ function(rx2) {
        return function(filename) {
          return rx2.test(filename);
        };
      }(filterfn);
    } else if ("function" !== typeof filterfn) {
      return () => true;
    }
    return filterfn;
  }
  const relativePath = (local, entry) => {
    let lastChar = entry.slice(-1);
    lastChar = lastChar === filetools.sep ? filetools.sep : "";
    return pth.relative(local, entry) + lastChar;
  };
  return {
    /**
     * Extracts the given entry from the archive and returns the content as a Buffer object
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {Buffer|string} [pass] - password
     * @return Buffer or Null in case of error
     */
    readFile: function(entry, pass) {
      var item = getEntry(entry);
      return item && item.getData(pass) || null;
    },
    /**
     * Returns how many child elements has on entry (directories) on files it is always 0
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @returns {integer}
     */
    childCount: function(entry) {
      const item = getEntry(entry);
      if (item) {
        return _zip.getChildCount(item);
      }
    },
    /**
     * Asynchronous readFile
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     *
     * @return Buffer or Null in case of error
     */
    readFileAsync: function(entry, callback) {
      var item = getEntry(entry);
      if (item) {
        item.getDataAsync(callback);
      } else {
        callback(null, "getEntry failed for:" + entry);
      }
    },
    /**
     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
     * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry
     * @param {string} encoding - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsText: function(entry, encoding) {
      var item = getEntry(entry);
      if (item) {
        var data = item.getData();
        if (data && data.length) {
          return data.toString(encoding || "utf8");
        }
      }
      return "";
    },
    /**
     * Asynchronous readAsText
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsTextAsync: function(entry, callback, encoding) {
      var item = getEntry(entry);
      if (item) {
        item.getDataAsync(function(data, err2) {
          if (err2) {
            callback(data, err2);
            return;
          }
          if (data && data.length) {
            callback(data.toString(encoding || "utf8"));
          } else {
            callback("");
          }
        });
      } else {
        callback("");
      }
    },
    /**
     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteFile: function(entry, withsubfolders = true) {
      var item = getEntry(entry);
      if (item) {
        _zip.deleteFile(item.entryName, withsubfolders);
      }
    },
    /**
     * Remove the entry from the file or directory without affecting any nested entries
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteEntry: function(entry) {
      var item = getEntry(entry);
      if (item) {
        _zip.deleteEntry(item.entryName);
      }
    },
    /**
     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
     *
     * @param {string} comment
     */
    addZipComment: function(comment) {
      _zip.comment = comment;
    },
    /**
     * Returns the zip comment
     *
     * @return String
     */
    getZipComment: function() {
      return _zip.comment || "";
    },
    /**
     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
     * The comment cannot exceed 65535 characters in length
     *
     * @param {ZipEntry} entry
     * @param {string} comment
     */
    addZipEntryComment: function(entry, comment) {
      var item = getEntry(entry);
      if (item) {
        item.comment = comment;
      }
    },
    /**
     * Returns the comment of the specified entry
     *
     * @param {ZipEntry} entry
     * @return String
     */
    getZipEntryComment: function(entry) {
      var item = getEntry(entry);
      if (item) {
        return item.comment || "";
      }
      return "";
    },
    /**
     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
     *
     * @param {ZipEntry} entry
     * @param {Buffer} content
     */
    updateFile: function(entry, content) {
      var item = getEntry(entry);
      if (item) {
        item.setData(content);
      }
    },
    /**
     * Adds a file from the disk to the archive
     *
     * @param {string} localPath File to add to zip
     * @param {string} [zipPath] Optional path inside the zip
     * @param {string} [zipName] Optional name for the file
     * @param {string} [comment] Optional file comment
     */
    addLocalFile: function(localPath2, zipPath, zipName, comment) {
      if (filetools.fs.existsSync(localPath2)) {
        zipPath = zipPath ? fixPath(zipPath) : "";
        const p = pth.win32.basename(pth.win32.normalize(localPath2));
        zipPath += zipName ? zipName : p;
        const _attr = filetools.fs.statSync(localPath2);
        const data = _attr.isFile() ? filetools.fs.readFileSync(localPath2) : Buffer.alloc(0);
        if (_attr.isDirectory()) zipPath += filetools.sep;
        this.addFile(zipPath, data, comment, _attr);
      } else {
        throw Utils.Errors.FILE_NOT_FOUND(localPath2);
      }
    },
    /**
     * Callback for showing if everything was done.
     *
     * @callback doneCallback
     * @param {Error} err - Error object
     * @param {boolean} done - was request fully completed
     */
    /**
     * Adds a file from the disk to the archive
     *
     * @param {(object|string)} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the file.
     * @param {string} [options.comment] - Optional file comment.
     * @param {string} [options.zipPath] - Optional path inside the zip
     * @param {string} [options.zipName] - Optional name for the file
     * @param {doneCallback} callback - The callback that handles the response.
     */
    addLocalFileAsync: function(options2, callback) {
      options2 = typeof options2 === "object" ? options2 : { localPath: options2 };
      const localPath2 = pth.resolve(options2.localPath);
      const { comment } = options2;
      let { zipPath, zipName } = options2;
      const self2 = this;
      filetools.fs.stat(localPath2, function(err2, stats) {
        if (err2) return callback(err2, false);
        zipPath = zipPath ? fixPath(zipPath) : "";
        const p = pth.win32.basename(pth.win32.normalize(localPath2));
        zipPath += zipName ? zipName : p;
        if (stats.isFile()) {
          filetools.fs.readFile(localPath2, function(err3, data) {
            if (err3) return callback(err3, false);
            self2.addFile(zipPath, data, comment, stats);
            return setImmediate(callback, void 0, true);
          });
        } else if (stats.isDirectory()) {
          zipPath += filetools.sep;
          self2.addFile(zipPath, Buffer.alloc(0), comment, stats);
          return setImmediate(callback, void 0, true);
        }
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - local path to the folder
     * @param {string} [zipPath] - optional path inside zip
     * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.
     */
    addLocalFolder: function(localPath2, zipPath, filter3) {
      filter3 = filenameFilter(filter3);
      zipPath = zipPath ? fixPath(zipPath) : "";
      localPath2 = pth.normalize(localPath2);
      if (filetools.fs.existsSync(localPath2)) {
        const items2 = filetools.findFiles(localPath2);
        const self2 = this;
        if (items2.length) {
          for (const filepath of items2) {
            const p = pth.join(zipPath, relativePath(localPath2, filepath));
            if (filter3(p)) {
              self2.addLocalFile(filepath, pth.dirname(p));
            }
          }
        }
      } else {
        throw Utils.Errors.FILE_NOT_FOUND(localPath2);
      }
    },
    /**
     * Asynchronous addLocalFolder
     * @param {string} localPath
     * @param {callback} callback
     * @param {string} [zipPath] optional path inside zip
     * @param {RegExp|function} [filter] optional RegExp or Function if files match will
     *               be included.
     */
    addLocalFolderAsync: function(localPath2, callback, zipPath, filter3) {
      filter3 = filenameFilter(filter3);
      zipPath = zipPath ? fixPath(zipPath) : "";
      localPath2 = pth.normalize(localPath2);
      var self2 = this;
      filetools.fs.open(localPath2, "r", function(err2) {
        if (err2 && err2.code === "ENOENT") {
          callback(void 0, Utils.Errors.FILE_NOT_FOUND(localPath2));
        } else if (err2) {
          callback(void 0, err2);
        } else {
          var items2 = filetools.findFiles(localPath2);
          var i = -1;
          var next = function() {
            i += 1;
            if (i < items2.length) {
              var filepath = items2[i];
              var p = relativePath(localPath2, filepath).split("\\").join("/");
              p = p.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
              if (filter3(p)) {
                filetools.fs.stat(filepath, function(er0, stats) {
                  if (er0) callback(void 0, er0);
                  if (stats.isFile()) {
                    filetools.fs.readFile(filepath, function(er1, data) {
                      if (er1) {
                        callback(void 0, er1);
                      } else {
                        self2.addFile(zipPath + p, data, "", stats);
                        next();
                      }
                    });
                  } else {
                    self2.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                    next();
                  }
                });
              } else {
                process.nextTick(() => {
                  next();
                });
              }
            } else {
              callback(true, void 0);
            }
          };
          next();
        }
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {object | string} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the folder.
     * @param {string} [options.zipPath] - optional path inside zip.
     * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [options.namefix] - optional function to help fix filename
     * @param {doneCallback} callback - The callback that handles the response.
     *
     */
    addLocalFolderAsync2: function(options2, callback) {
      const self2 = this;
      options2 = typeof options2 === "object" ? options2 : { localPath: options2 };
      localPath = pth.resolve(fixPath(options2.localPath));
      let { zipPath, filter: filter3, namefix } = options2;
      if (filter3 instanceof RegExp) {
        filter3 = /* @__PURE__ */ function(rx2) {
          return function(filename) {
            return rx2.test(filename);
          };
        }(filter3);
      } else if ("function" !== typeof filter3) {
        filter3 = function() {
          return true;
        };
      }
      zipPath = zipPath ? fixPath(zipPath) : "";
      if (namefix == "latin1") {
        namefix = (str2) => str2.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
      }
      if (typeof namefix !== "function") namefix = (str2) => str2;
      const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));
      const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));
      filetools.fs.open(localPath, "r", function(err2) {
        if (err2 && err2.code === "ENOENT") {
          callback(void 0, Utils.Errors.FILE_NOT_FOUND(localPath));
        } else if (err2) {
          callback(void 0, err2);
        } else {
          filetools.findFilesAsync(localPath, function(err3, fileEntries) {
            if (err3) return callback(err3);
            fileEntries = fileEntries.filter((dir) => filter3(relPathFix(dir)));
            if (!fileEntries.length) callback(void 0, false);
            setImmediate(
              fileEntries.reverse().reduce(function(next, entry) {
                return function(err4, done) {
                  if (err4 || done === false) return setImmediate(next, err4, false);
                  self2.addLocalFileAsync(
                    {
                      localPath: entry,
                      zipPath: pth.dirname(relPathFix(entry)),
                      zipName: fileNameFix(entry)
                    },
                    next
                  );
                };
              }, callback)
            );
          });
        }
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - path where files will be extracted
     * @param {object} props - optional properties
     * @param {string} [props.zipPath] - optional path inside zip
     * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [props.namefix] - optional function to help fix filename
     */
    addLocalFolderPromise: function(localPath2, props) {
      return new Promise((resolve2, reject) => {
        this.addLocalFolderAsync2(Object.assign({ localPath: localPath2 }, props), (err2, done) => {
          if (err2) reject(err2);
          if (done) resolve2(this);
        });
      });
    },
    /**
     * Allows you to create a entry (file or directory) in the zip file.
     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
     * Comment and attributes are optional
     *
     * @param {string} entryName
     * @param {Buffer | string} content - file content as buffer or utf8 coded string
     * @param {string} [comment] - file comment
     * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object
     */
    addFile: function(entryName, content, comment, attr) {
      entryName = zipnamefix(entryName);
      let entry = getEntry(entryName);
      const update = entry != null;
      if (!update) {
        entry = new ZipEntry(opts);
        entry.entryName = entryName;
      }
      entry.comment = comment || "";
      const isStat = "object" === typeof attr && attr instanceof filetools.fs.Stats;
      if (isStat) {
        entry.header.time = attr.mtime;
      }
      var fileattr = entry.isDirectory ? 16 : 0;
      let unix = entry.isDirectory ? 16384 : 32768;
      if (isStat) {
        unix |= 4095 & attr.mode;
      } else if ("number" === typeof attr) {
        unix |= 4095 & attr;
      } else {
        unix |= entry.isDirectory ? 493 : 420;
      }
      fileattr = (fileattr | unix << 16) >>> 0;
      entry.attr = fileattr;
      entry.setData(content);
      if (!update) _zip.setEntry(entry);
      return entry;
    },
    /**
     * Returns an array of ZipEntry objects representing the files and folders inside the archive
     *
     * @param {string} [password]
     * @returns Array
     */
    getEntries: function(password) {
      _zip.password = password;
      return _zip ? _zip.entries : [];
    },
    /**
     * Returns a ZipEntry object representing the file or folder specified by ``name``.
     *
     * @param {string} name
     * @return ZipEntry
     */
    getEntry: function(name) {
      return getEntry(name);
    },
    getEntryCount: function() {
      return _zip.getEntryCount();
    },
    forEach: function(callback) {
      return _zip.forEach(callback);
    },
    /**
     * Extracts the given entry to the given targetPath
     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
     *
     * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry
     * @param {string} targetPath - Target folder where to write the file
     * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE
     * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.
     * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.
     * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)
     *
     * @return Boolean
     */
    extractEntryTo: function(entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {
      overwrite = get_Bool(false, overwrite);
      keepOriginalPermission = get_Bool(false, keepOriginalPermission);
      maintainEntryPath = get_Bool(true, maintainEntryPath);
      outFileName = get_Str(keepOriginalPermission, outFileName);
      var item = getEntry(entry);
      if (!item) {
        throw Utils.Errors.NO_ENTRY();
      }
      var entryName = canonical(item.entryName);
      var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));
      if (item.isDirectory) {
        var children = _zip.getEntryChildren(item);
        children.forEach(function(child) {
          if (child.isDirectory) return;
          var content2 = child.getData();
          if (!content2) {
            throw Utils.Errors.CANT_EXTRACT_FILE();
          }
          var name = canonical(child.entryName);
          var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
          const fileAttr2 = keepOriginalPermission ? child.header.fileAttr : void 0;
          filetools.writeFileTo(childName, content2, overwrite, fileAttr2);
        });
        return true;
      }
      var content = item.getData(_zip.password);
      if (!content) throw Utils.Errors.CANT_EXTRACT_FILE();
      if (filetools.fs.existsSync(target) && !overwrite) {
        throw Utils.Errors.CANT_OVERRIDE();
      }
      const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
      filetools.writeFileTo(target, content, overwrite, fileAttr);
      return true;
    },
    /**
     * Test the archive
     * @param {string} [pass]
     */
    test: function(pass) {
      if (!_zip) {
        return false;
      }
      for (var entry in _zip.entries) {
        try {
          if (entry.isDirectory) {
            continue;
          }
          var content = _zip.entries[entry].getData(pass);
          if (!content) {
            return false;
          }
        } catch (err2) {
          return false;
        }
      }
      return true;
    },
    /**
     * Extracts the entire archive to the given location
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {string|Buffer} [pass] password
     */
    extractAllTo: function(targetPath, overwrite, keepOriginalPermission, pass) {
      keepOriginalPermission = get_Bool(false, keepOriginalPermission);
      pass = get_Str(keepOriginalPermission, pass);
      overwrite = get_Bool(false, overwrite);
      if (!_zip) throw Utils.Errors.NO_ZIP();
      _zip.entries.forEach(function(entry) {
        var entryName = sanitize(targetPath, canonical(entry.entryName));
        if (entry.isDirectory) {
          filetools.makeDir(entryName);
          return;
        }
        var content = entry.getData(pass);
        if (!content) {
          throw Utils.Errors.CANT_EXTRACT_FILE();
        }
        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
        filetools.writeFileTo(entryName, content, overwrite, fileAttr);
        try {
          filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
        } catch (err2) {
          throw Utils.Errors.CANT_EXTRACT_FILE();
        }
      });
    },
    /**
     * Asynchronous extractAllTo
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.
     */
    extractAllToAsync: function(targetPath, overwrite, keepOriginalPermission, callback) {
      callback = get_Fun(overwrite, keepOriginalPermission, callback);
      keepOriginalPermission = get_Bool(false, keepOriginalPermission);
      overwrite = get_Bool(false, overwrite);
      if (!callback) {
        return new Promise((resolve2, reject) => {
          this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function(err2) {
            if (err2) {
              reject(err2);
            } else {
              resolve2(this);
            }
          });
        });
      }
      if (!_zip) {
        callback(Utils.Errors.NO_ZIP());
        return;
      }
      targetPath = pth.resolve(targetPath);
      const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));
      const getError = (msg, file2) => new Error(msg + ': "' + file2 + '"');
      const dirEntries = [];
      const fileEntries = [];
      _zip.entries.forEach((e) => {
        if (e.isDirectory) {
          dirEntries.push(e);
        } else {
          fileEntries.push(e);
        }
      });
      for (const entry of dirEntries) {
        const dirPath = getPath(entry);
        const dirAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
        try {
          filetools.makeDir(dirPath);
          if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);
          filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
        } catch (er) {
          callback(getError("Unable to create folder", dirPath));
        }
      }
      fileEntries.reverse().reduce(function(next, entry) {
        return function(err2) {
          if (err2) {
            next(err2);
          } else {
            const entryName = pth.normalize(canonical(entry.entryName));
            const filePath = sanitize(targetPath, entryName);
            entry.getDataAsync(function(content, err_1) {
              if (err_1) {
                next(err_1);
              } else if (!content) {
                next(Utils.Errors.CANT_EXTRACT_FILE());
              } else {
                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function(succ) {
                  if (!succ) {
                    next(getError("Unable to write file", filePath));
                  }
                  filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function(err_2) {
                    if (err_2) {
                      next(getError("Unable to set times", filePath));
                    } else {
                      next();
                    }
                  });
                });
              }
            });
          }
        };
      }, callback)();
    },
    /**
     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
     *
     * @param {string} targetFileName
     * @param {function} callback
     */
    writeZip: function(targetFileName, callback) {
      if (arguments.length === 1) {
        if (typeof targetFileName === "function") {
          callback = targetFileName;
          targetFileName = "";
        }
      }
      if (!targetFileName && opts.filename) {
        targetFileName = opts.filename;
      }
      if (!targetFileName) return;
      var zipData = _zip.compressToBuffer();
      if (zipData) {
        var ok = filetools.writeFileTo(targetFileName, zipData, true);
        if (typeof callback === "function") callback(!ok ? new Error("failed") : null, "");
      }
    },
    /**
             *
             * @param {string} targetFileName
             * @param {object} [props]
             * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.
             * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.
    
             * @returns {Promise<void>}
             */
    writeZipPromise: function(targetFileName, props) {
      const { overwrite, perm } = Object.assign({ overwrite: true }, props);
      return new Promise((resolve2, reject) => {
        if (!targetFileName && opts.filename) targetFileName = opts.filename;
        if (!targetFileName) reject("ADM-ZIP: ZIP File Name Missing");
        this.toBufferPromise().then((zipData) => {
          const ret = (done) => done ? resolve2(done) : reject("ADM-ZIP: Wasn't able to write zip file");
          filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
        }, reject);
      });
    },
    /**
     * @returns {Promise<Buffer>} A promise to the Buffer.
     */
    toBufferPromise: function() {
      return new Promise((resolve2, reject) => {
        _zip.toAsyncBuffer(resolve2, reject);
      });
    },
    /**
     * Returns the content of the entire zip file as a Buffer object
     *
     * @prop {function} [onSuccess]
     * @prop {function} [onFail]
     * @prop {function} [onItemStart]
     * @prop {function} [onItemEnd]
     * @returns {Buffer}
     */
    toBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
      if (typeof onSuccess === "function") {
        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
        return null;
      }
      return _zip.compressToBuffer();
    }
  };
};
const AdmZip = /* @__PURE__ */ getDefaultExportFromCjs(admZip);
function findProcessOnPort(port) {
  try {
    let command;
    if (process.platform === "win32") {
      command = `netstat -ano | findstr :${port}`;
    } else {
      command = `lsof -i :${port} | awk 'NR>1 {print $2}'`;
    }
    const result = execSync(command, { encoding: "utf8" }).trim();
    if (!result) return null;
    let pids;
    if (process.platform === "win32") {
      const pidRegex = /\s+(\d+)\s*$/;
      pids = result.split("\n").map((line) => {
        const match = line.match(pidRegex);
        return match ? parseInt(match[1], 10) : NaN;
      }).filter((pid) => !isNaN(pid));
    } else {
      pids = result.split("\n").map((line) => parseInt(line.trim(), 10)).filter((pid) => !isNaN(pid));
    }
    return [...new Set(pids)];
  } catch (error2) {
    return null;
  }
}
function PortIsRun(port) {
  const pids = findProcessOnPort(port);
  if (pids && pids.length > 0) {
    return true;
  } else {
    return false;
  }
}
function parseLog(line) {
  const regex = /^\[(.*?)\] \[(.*?)\] \[(.*?)\] \[(.*?)\] (.*)$/;
  const match = line.match(regex);
  if (!match) return null;
  return {
    time: match[1],
    // 时间
    level: match[2],
    // 日志等级
    app: match[3],
    // 日志应用
    line: match[4],
    // 日志位置
    message: match[5]
    // 日志消息
  };
}
const require$1 = createRequire(import.meta.url);
const koffi = require$1("koffi");
const cron = require$1("node-cron");
class WCF {
  constructor(win2) {
    __publicField(this, "Wcf_directory");
    __publicField(this, "wcfconfigPath");
    __publicField(this, "wcfConfig");
    __publicField(this, "windown");
    __publicField(this, "server");
    __publicField(this, "WxInitSDK");
    __publicField(this, "WxDestroySDK");
    __publicField(this, "tray", null);
    __publicField(this, "scheduleJobs");
    //   上报配置文件
    __publicField(this, "reportConfig", () => {
      this.windown.webContents.send("wcf:config", this.wcfConfig);
    });
    //   写入配置文件
    __publicField(this, "writeConfig", (config2) => {
      this.wcfConfig = config2;
      fs$k.writeFileSync(this.wcfconfigPath, JSON.stringify(config2, null, 4));
    });
    //   发送日志
    __publicField(this, "sendLog", (message, level) => {
      this.windown.webContents.send("wcf:log", { message, level: level || "INFO", timestamp: dayjs().format("YYYY-MM-DD HH:mm:ss.SSS ") });
    });
    //   检测WCF是否有更新
    __publicField(this, "checkUpdate", async () => {
      const config_path = path$n.join(this.Wcf_directory, "config.json");
      if (fs$k.existsSync(config_path)) {
        const config2 = JSON.parse(fs$k.readFileSync(config_path, "utf-8"));
        const version2 = config2.version.replace("v", "").split(".").join("") || "0";
        const result = await this.getWCFVersion();
        const remove_version = (result == null ? void 0 : result.version.replace("v", "").split(".").join("")) || "0";
        if (Number(version2) < Number(remove_version)) {
          return { status: true, version: (result == null ? void 0 : result.version) || "" };
        }
      }
      return { staus: false, version: this.wcfConfig.version };
    });
    //   检测WCF是否存在
    __publicField(this, "checkWCF", () => {
      const wcf_path = path$n.join(this.Wcf_directory, "sdk.dll");
      if (fs$k.existsSync(wcf_path)) {
        return true;
      } else {
        return false;
      }
    });
    // 获取WCF版本信息
    __publicField(this, "getWCFVersion", async () => {
      const github_apiUrl = "https://api.github.com/repos/lich0821/WeChatFerry/releases/latest";
      try {
        const response2 = await axios.get(github_apiUrl, {
          responseType: "json",
          validateStatus: (status) => status < 500
        });
        if (!response2 || !response2.data || !response2.data.assets || response2.data.assets.length === 0) {
          this.sendLog("Failed to retrieve valid data from GitHub API.", "ERROR");
          if (response2.data.message) {
            this.sendLog(response2.data.message, "ERROR");
          }
          return { version: "", download_url: "" };
        }
        return {
          version: response2.data.tag_name,
          download_url: response2.data.assets[0].browser_download_url
        };
      } catch (err2) {
        this.sendLog(`获取WCF版本信息失败:${err2 == null ? void 0 : err2.message}`, "ERROR");
        return null;
      }
    });
    __publicField(this, "downloadFile", async (url2, dest) => {
      const writer = fs$k.createWriteStream(dest);
      try {
        const proxyurl = this.wcfConfig.proxy_url ? this.wcfConfig.proxy_url + "/" : "";
        const down_url = proxyurl + url2;
        this.sendLog(`开始下载文件:${down_url}`, "INFO");
        const download = await axios({
          method: "get",
          url: down_url,
          responseType: "stream",
          timeout: 12e3
        });
        download.data.pipe(writer);
        return await new Promise((resolve2, reject) => {
          writer.on("finish", async () => {
            this.sendLog("下载完成", "SUCCESS");
            resolve2(true);
          });
          writer.on("error", reject);
        });
      } catch (error2) {
        await writer.close();
        this.sendLog(`下载失败:${error2.message},url:${url2}`, "ERROR");
        fs$k.unlinkSync(dest);
        return false;
      }
    });
    //   下载最新版的WCF
    __publicField(this, "downloadWCF", async () => {
      this.sendLog("开始下载最新版本的WCF", "INFO");
      let output = "";
      try {
        const result = await this.getWCFVersion();
        this.sendLog(`✅ 获取WCF最新版本信息成功:${result == null ? void 0 : result.version}`, "SUCCESS");
        this.wcfConfig.version = (result == null ? void 0 : result.version) || "";
        const filename = path$n.basename(result == null ? void 0 : result.download_url);
        output = path$n.join(this.Wcf_directory, filename);
        if (fs$k.existsSync(output)) {
          console.log("文件存在跳过下载");
          return await this.unzipFile(output);
        }
        const res2 = await this.downloadFile(result == null ? void 0 : result.download_url, output);
        if (!res2) return res2;
        const unCompress = await this.unzipFile(output);
        if (unCompress) {
          this.wcfConfig.version = (result == null ? void 0 : result.version) || "";
          this.writeConfig(this.wcfConfig);
          this.reportConfig();
        }
      } catch (error2) {
        this.sendLog(`下载WCF失败:${error2.message}`, "ERROR");
        return false;
      }
    });
    // 注入Dll
    __publicField(this, "InjectWCF", async () => {
      if (process.platform !== "win32") {
        this.sendLog("当前系统不支持WCF注入", "ERROR");
        return;
      }
      const hasDll = this.checkWCF();
      if (!hasDll) {
        this.sendLog("WCF核心不存在，即将自动下载", "WARN");
        await this.downloadWCF();
      }
      const result = await this.checkWCFIsRun();
      if (!result.wcf_run && result.portOcc) {
        this.sendLog(`当前端口已被占用:${this.wcfConfig.port}请修改系统设置端口，避免启动失败！`, "WARN");
        return false;
      }
      this.sendLog("开始注入WCF", "INFO");
      const dllPath = path$n.join(this.Wcf_directory, "sdk.dll");
      const sdkDLL = koffi.load(dllPath);
      this.WxInitSDK = sdkDLL.func("int WxInitSDK(bool, int)", "stdcall");
      this.WxDestroySDK = sdkDLL.func("WxDestroySDK", "void", []);
      return true;
    });
    // 启动WCF
    __publicField(this, "startWCF", async () => {
      var _a2;
      try {
        const res2 = await this.InjectWCF();
        if (!res2) return res2;
        const result = (_a2 = this.WxInitSDK) == null ? void 0 : _a2.call(this, this.wcfConfig.debug, this.wcfConfig.port);
        if (result !== 0) {
          this.sendLog(`WCF启动失败：${result}`, "ERROR");
          return;
        }
        this.sendLog(`✅WCF启动成功:Tcp://0.0.0.0:${this.wcfConfig.port}`, "SUCCESS");
        this.checkWCFIsRun();
        return true;
      } catch (error2) {
        this.sendLog(`启动WCF失败:${error2.message}`, "ERROR");
      }
    });
    // 更新WCFdLL
    __publicField(this, "updateWCF", async () => {
      var _a2;
      const result = await this.checkWCFIsRun();
      if (result.wcf_run) {
        (_a2 = this.WxDestroySDK) == null ? void 0 : _a2.call(this);
        this.sendLog("WCF已关闭", "INFO");
      }
      await this.downloadWCF();
      await this.startWCF();
    });
    // 重启WCF
    __publicField(this, "restartWCF", async () => {
      var _a2;
      const result = await this.checkWCFIsRun();
      if (result.wcf_run) {
        await ((_a2 = this.WxDestroySDK) == null ? void 0 : _a2.call(this));
      }
      await this.startWCF();
    });
    // 关闭WCF
    __publicField(this, "closeWCF", async () => {
      if (this.WxDestroySDK) {
        this.WxDestroySDK();
        this.sendLog("WCF已关闭", "INFO");
      } else {
        this.sendLog("WCF未运行", "INFO");
      }
      this.checkWCFIsRun();
      this.clearWcfLog();
    });
    // 修改WCF配置文件
    __publicField(this, "modifyWCFConfig", async (_, config2) => {
      this.wcfConfig = { ...this.wcfConfig, ...config2 };
      this.writeConfig(this.wcfConfig);
      this.reportConfig();
    });
    // 获取配置文件
    __publicField(this, "getWCFConfig", async () => {
      return this.wcfConfig;
    });
    //   检测WCF是否在运行
    __publicField(this, "checkWCFIsRun", async () => {
      const params = {
        portOcc: PortIsRun(this.wcfConfig.port),
        wcf_run: PortIsRun(this.wcfConfig.port) && Boolean(this.WxInitSDK),
        http: this.server && PortIsRun(this.wcfConfig.httpPort) ? true : false
      };
      this.windown.webContents.send("wcf:startEvent", params);
      await this.updateTrayMenu(params);
      return params;
    });
    // 重置WCF环境
    __publicField(this, "resetWCF", async () => {
      this.sendLog("开始重置WCF环境", "INFO");
      await this.KillPort(this.wcfConfig.port);
      await this.KillPort(+this.wcfConfig.port + 1);
      this.checkWCFIsRun();
    });
    __publicField(this, "KillPort", async (port) => {
      try {
        const pids = await this.getPidsByPort(port);
        const filteredPids = pids.filter((pid) => pid !== 0);
        if (filteredPids.length == 0) {
          this.sendLog(`当前端口:${port}没有被占用`, "INFO");
          return;
        }
        if (pids.length == 0) {
          this.sendLog(`当前端口:${port}没有被占用`, "INFO");
          return;
        }
        this.sendLog(`成功检测${port}端口对应的PID:${pids},即将终止相关PID进程`, "INFO");
        filteredPids.forEach((item) => {
          const result = this.killProcessByPid(item);
          this.sendLog(result.message, result.success ? "SUCCESS" : "ERROR");
        });
      } catch (error2) {
        this.sendLog(`重置WCF环境失败:${error2.message}`, "ERROR");
      }
    });
    // 开启http服务
    __publicField(this, "startWcfServer", async () => {
      try {
        const fastify2 = Fastify({ trustProxy: true });
        fastify2.get("/", async () => {
          return { code: 0, ...this.wcfConfig };
        });
        fastify2.get("/start-wcf", async () => {
          const result = await this.startWCF();
          if (!result) {
            return { code: 1, message: "WCF启动失败,详情请看软件日志区域" };
          }
          return { code: 0, message: "WCF启动成功" };
        });
        fastify2.get("/close-wcf", async () => {
          await this.closeWCF();
          return { code: 0, message: "WCF关闭成功" };
        });
        fastify2.addHook("onSend", async (request2, _, playLoad) => {
          this.sendLog(`HTTP LOG: Method: ${request2.method}、Url: ${request2.url}、ClientIp:${request2.ip}、Response:${playLoad}`, "INFO");
        });
        await fastify2.listen({ host: "0.0.0.0", port: this.wcfConfig.httpPort });
        this.sendLog(`✅ HTTP SERVER IS START:0.0.0.0:${this.wcfConfig.httpPort}`, "SUCCESS");
        this.server = fastify2;
        this.checkWCFIsRun();
      } catch (err2) {
        this.sendLog(err2.message, "ERROR");
      }
    });
    // 关闭http服务
    __publicField(this, "closeWcfServer", async () => {
      if (this.server) {
        await this.server.close();
        this.sendLog("Http Server Is Close", "INFO");
      }
      this.checkWCFIsRun();
    });
    // 注册定时任务
    __publicField(this, "registerSchedule", (cronTime, callback) => {
      const job = cron.schedule(cronTime, callback);
      this.scheduleJobs.push(job);
      job.start();
    });
    // 清空定时任务
    __publicField(this, "clearSchedule", () => {
      this.scheduleJobs.map((job) => {
        job.stop();
      });
      this.scheduleJobs.length = 0;
    });
    // 检测端口对应的pid
    __publicField(this, "getPidsByPort", async (port) => {
      try {
        const output = execSync(`netstat -ano | findstr :${port}`, { encoding: "utf-8" });
        const lines = output.split("\n").filter((line) => line.includes(`:${port}`));
        if (lines.length === 0) return [];
        const pids = lines.map((line) => {
          const pid = line.trim().split(/\s+/).pop();
          return Number(pid);
        });
        return pids;
      } catch {
        return [];
      }
    });
    __publicField(this, "killProcessByPid", (pid) => {
      try {
        execSync(`taskkill /PID ${pid} /F`, { stdio: "ignore" });
        return { success: true, message: `✅ 成功终止 PID ${pid} 的进程` };
      } catch (err2) {
        return { success: false, message: `❌ 无法终止 PID ${pid}，可能不存在或已退出,请打开任务管理器核对` };
      }
    });
    // 唤醒微信
    __publicField(this, "wakeUpWeChat", () => {
      try {
        if (process.platform === "win32") {
          execSync("start weixin://");
        } else if (process.platform === "darwin") {
          open("open weixin://");
        } else {
          this.sendLog("❌ 当前系统不支持微信协议唤醒", "ERROR");
          return;
        }
        console.log("✅ 微信客户端已唤醒");
      } catch (error2) {
        this.sendLog(`❌ 无法唤醒微信:${error2.message}`, "ERROR");
      }
    });
    __publicField(this, "injectVersionDll", async (version2, download_wechat = false) => {
      const app_downloadDir = app.getPath("downloads");
      this.closeWCF();
      this.sendLog(`开始检测指定版本:${version2}是否存在`, "INFO");
      const url2 = `https://api.github.com/repos/lich0821/WeChatFerry/releases/tags/${version2}`;
      const res2 = await axios.get(url2, {
        validateStatus: (status) => status < 500
      });
      const info = res2.data;
      if (info.status == 404) {
        this.sendLog(`指定版本:${version2}不存在`, "ERROR");
        return 404;
      }
      const assets = info.assets;
      const [sdkInfo, WechatInfo] = assets;
      const sdkUrl = sdkInfo.browser_download_url;
      this.sendLog(`✅ 获取指定版本:${version2}下载地址成功:${sdkUrl}`, "SUCCESS");
      const filename = path$n.basename(sdkUrl);
      const sdkFilepath = path$n.join(this.Wcf_directory, filename);
      const sdkResponse = await this.downloadFile(sdkUrl, sdkFilepath);
      if (!sdkResponse) return sdkResponse;
      const unCompress = await this.unzipFile(sdkFilepath, this.Wcf_directory);
      if (unCompress) {
        this.wcfConfig.version = version2 || "";
        this.writeConfig(this.wcfConfig);
        this.reportConfig();
      }
      if (!unCompress) return unCompress;
      this.sendLog(`✅ 指定版本:${version2}下载完成`, "SUCCESS");
      if (download_wechat) {
        const wechatUrl = WechatInfo.browser_download_url;
        const wechatFilename = path$n.basename(wechatUrl);
        this.sendLog(`开始下载指定版本:${version2}对应的${WechatInfo.name}`, "INFO");
        const wechatFilepath = path$n.join(app_downloadDir, wechatFilename);
        const wechatResponse = await this.downloadFile(wechatUrl, wechatFilepath);
        if (!wechatResponse) return wechatResponse;
        this.sendLog(`✅ 指定版本:${version2}对应的${WechatInfo.name}下载完成`, "SUCCESS");
        this.sendLog(`文件已保存:${wechatFilepath}`, "INFO");
        this.sendLog(`安装指定版本微信登录成功后 重新启动WCF即可`, "INFO");
      }
    });
    // 读取wcf日志
    __publicField(this, "readWcfLog", () => {
      try {
        const exePath = app.getPath("exe");
        const installDir = path$n.dirname(exePath);
        const logsPath = path$n.join(installDir, "logs/wcf.txt");
        if (fs$k.existsSync(logsPath)) {
          const logs = fs$k.readFileSync(logsPath, "utf-8").trim();
          return logs.split("\n").reverse().map((line) => parseLog(line.trim()));
        } else {
          this.sendLog("WCF日志文件不存在", "ERROR");
          this.sendLog("请先启动WCF后再查看日志", "ERROR");
        }
        return [];
      } catch (error2) {
        this.sendLog(`读取WCF日志失败:${error2.message}`, "ERROR");
      }
    });
    //清空日志
    __publicField(this, "clearWcfLog", () => {
      const logsPath = path$n.join(app.getAppPath(), "logs/wcf.txt");
      if (fs$k.existsSync(logsPath)) {
        fs$k.writeFileSync(logsPath, "");
      }
    });
    // 创建托盘图标
    __publicField(this, "crateTray", async () => {
      this.tray = new Tray(path$n.join(process.env.VITE_PUBLIC, "logo.png"));
      this.tray.setToolTip("WCF-TOOL");
      this.tray.on("double-click", () => {
        var _a2;
        (_a2 = this.windown) == null ? void 0 : _a2.show();
      });
    });
    // 更新系统托盘菜单
    __publicField(this, "updateTrayMenu", async (runConfig) => {
      if (this.tray) {
        const wcf_run = !runConfig.portOcc && runConfig.wcf_run;
        const wcf_meun = wcf_run ? [
          {
            label: "❌ 关闭WCF",
            click: () => {
              this.closeWCF();
            }
          },
          {
            label: "🔄 重启WCF",
            click: () => {
              this.restartWCF();
            }
          }
        ] : [
          {
            label: "🚀 启动WCF ",
            click: () => {
              this.closeWCF();
            }
          },
          {
            label: "♻️ 清理WCF环境",
            click: () => {
              this.resetWCF();
            }
          }
        ];
        const http_meun = runConfig.http ? [
          {
            label: "❌ 关闭HTTP",
            click: () => {
              this.closeWcfServer();
            }
          },
          {
            label: "🔄 重启HTTP",
            click: () => {
              this.closeWcfServer();
              this.startWcfServer();
            }
          }
        ] : [
          {
            label: "🚀 启动HTTP",
            click: () => {
              this.startWcfServer();
            }
          }
        ];
        const contextMenu = Menu.buildFromTemplate([
          {
            label: `🧱 WCF运行状态：${wcf_run ? "🟢" : "🔴"} 端口:${this.wcfConfig.port}`
          },
          {
            label: `🧱 HTTP运行状态：${runConfig.http ? "🟢" : "🔴"} 端口:${this.wcfConfig.httpPort}`
          },
          ...wcf_meun,
          ...http_meun,
          { type: "separator" },
          {
            label: "❎ 退出",
            click: () => {
              var _a2;
              this.closeWcfServer();
              this.clearSchedule();
              this.closeWCF();
              (_a2 = this.tray) == null ? void 0 : _a2.destroy();
              app.quit();
            }
          }
        ]);
        this.tray.setContextMenu(contextMenu);
      }
    });
    this.windown = win2;
    this.server = null;
    this.Wcf_directory = path$n.join(app.getPath("documents"), "WCFApp");
    this.wcfconfigPath = path$n.join(this.Wcf_directory, "config.json");
    this.WxInitSDK = null;
    this.WxDestroySDK = null;
    if (!fs$k.existsSync(this.Wcf_directory)) {
      fs$k.mkdirSync(this.Wcf_directory, { recursive: true });
    }
    const version2 = app.getVersion();
    const initConfig = {
      port: 10086,
      debug: false,
      proxy_url: "",
      version: "",
      httpPort: 9200,
      cronCheck: 12,
      app_version: version2
    };
    if (fs$k.existsSync(this.wcfconfigPath)) {
      const config2 = JSON.parse(fs$k.readFileSync(this.wcfconfigPath, "utf-8"));
      this.wcfConfig = { ...initConfig, ...config2, app_version: version2 };
    } else {
      this.wcfConfig = initConfig;
    }
    this.writeConfig(this.wcfConfig);
    this.scheduleJobs = [];
  }
  //   解压文件
  async unzipFile(filePath, dest = this.Wcf_directory) {
    try {
      this.sendLog("开始解压文件", "INFO");
      const zip = new AdmZip(filePath);
      return await new Promise((resolve2, reject) => {
        try {
          zip.extractAllToAsync(dest, true, (err2) => {
            console.log(err2, 195);
            if (err2) reject(err2);
            else {
              this.sendLog("✅ 解压文件完成", "SUCCESS");
              fs$k.unlinkSync(filePath);
              resolve2(true);
            }
          });
        } catch (err2) {
          console.log(err2, 205);
        }
      });
    } catch (error2) {
      this.sendLog(`解压文件失败: ${error2}`, "ERROR");
      fs$k.unlinkSync(filePath);
      return false;
    }
  }
}
var main$1 = {};
var fs$i = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function") fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        args.push((err2, res2) => err2 != null ? reject(err2) : resolve2(res2));
        fn.apply(this, args);
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function") return fn.apply(this, args);
    else {
      args.pop();
      fn.apply(this, args).then((r) => cb(null, r), cb);
    }
  }, "name", { value: fn.name });
};
var constants = require$$0$d;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$1;
function patch$1(fs2) {
  if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename2(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename2, fs$rename);
      return rename2;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs22) {
    fs22.lchmod = function(path2, mode, callback) {
      fs22.open(
        path2,
        constants.O_WRONLY | constants.O_SYMLINK,
        mode,
        function(err2, fd) {
          if (err2) {
            if (callback) callback(err2);
            return;
          }
          fs22.fchmod(fd, mode, function(err22) {
            fs22.close(fd, function(err222) {
              if (callback) callback(err22 || err222);
            });
          });
        }
      );
    };
    fs22.lchmodSync = function(path2, mode) {
      var fd = fs22.openSync(path2, constants.O_WRONLY | constants.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs22.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs22.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs22.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs22) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
      fs22.lutimes = function(path2, at, mt, cb) {
        fs22.open(path2, constants.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb) cb(er);
            return;
          }
          fs22.futimes(fd, at, mt, function(er2) {
            fs22.close(fd, function(er22) {
              if (cb) cb(er2 || er22);
            });
          });
        });
      };
      fs22.lutimesSync = function(path2, at, mt) {
        var fd = fs22.openSync(path2, constants.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs22.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs22.futimes) {
      fs22.lutimes = function(_a2, _b, _c, cb) {
        if (cb) process.nextTick(cb);
      };
      fs22.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig) return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig) return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig) return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig) return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig) return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig) return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0) stats.uid += 4294967296;
        if (stats.gid < 0) stats.gid += 4294967296;
      }
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = stream.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys2 = Object.keys(options);
    for (var index = 0, length = keys2.length; index < length; index++) {
      var key = keys2[index];
      this[key] = options[key];
    }
    if (this.encoding) this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err2, fd) {
      if (err2) {
        self2.emit("error", err2);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys2 = Object.keys(options);
    for (var index = 0, length = keys2.length; index < length; index++) {
      var key = keys2[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$h = fs$k;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$2 = require$$1$2;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context2, queue2) {
  Object.defineProperty(context2, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$1 = noop;
if (util$2.debuglog)
  debug$1 = util$2.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$1 = function() {
    var m = util$2.format.apply(util$2, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$h[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$h, queue);
  fs$h.close = function(fs$close) {
    function close2(fd, cb) {
      return fs$close.call(fs$h, fd, function(err2) {
        if (!err2) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close2, previousSymbol, {
      value: fs$close
    });
    return close2;
  }(fs$h.close);
  fs$h.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$h, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$h.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$1(fs$h[gracefulQueue]);
      require$$5.equal(fs$h[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$h[gracefulQueue]);
}
var gracefulFs = patch(clone(fs$h));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$h.__patched) {
  gracefulFs = patch(fs$h);
  fs$h.__patched = true;
}
function patch(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path22, options2, cb2, startTime) {
      return fs$readFile(path22, options2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$readFile, [path22, options2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path22, data2, options2, cb2, startTime) {
      return fs$writeFile(path22, data2, options2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$writeFile, [path22, data2, options2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path22, data2, options2, cb2, startTime) {
      return fs$appendFile(path22, data2, options2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$appendFile, [path22, data2, options2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src2, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src22, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src22, dest2, flags2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$copyFile, [src22, dest2, flags2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    } : function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, options2, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options, cb);
    function fs$readdirCallback(path22, options2, cb2, startTime) {
      return function(err2, files) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path22, options2, cb2],
            err2,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err2, files);
        }
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err2, fd) {
      if (err2) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err2);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err2, fd) {
      if (err2) {
        that.destroy();
        that.emit("error", err2);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open2;
  function open2(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path22, flags2, mode2, cb2, startTime) {
      return fs$open(path22, flags2, mode2, function(err2, fd) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$open, [path22, flags2, mode2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$1("ENQUEUE", elem[0].name, elem[1]);
  fs$h[gracefulQueue].push(elem);
  retry$2();
}
var retryTimer;
function resetQueue() {
  var now2 = Date.now();
  for (var i = 0; i < fs$h[gracefulQueue].length; ++i) {
    if (fs$h[gracefulQueue][i].length > 2) {
      fs$h[gracefulQueue][i][3] = now2;
      fs$h[gracefulQueue][i][4] = now2;
    }
  }
  retry$2();
}
function retry$2() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$h[gracefulQueue].length === 0)
    return;
  var elem = fs$h[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err2 = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$1("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$1("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err2);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$1("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$h[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry$2, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err2, bytesRead, buffer2) => {
        if (err2) return reject(err2);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err2, bytesWritten, buffer2) => {
        if (err2) return reject(err2);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.writev(fd, buffers, ...args, (err2, bytesWritten, buffers2) => {
          if (err2) return reject(err2);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
  if (typeof fs2.realpath.native === "function") {
    exports.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$i);
var makeDir$1 = {};
var utils$1 = {};
const path$l = path$n;
utils$1.checkPath = function checkPath(pth2) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth2.replace(path$l.parse(pth2).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth2}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$g = fs$i;
const { checkPath: checkPath2 } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number") return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$g.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$g.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$9 = universalify$1.fromPromise;
const fs$f = fs$i;
function pathExists$6(path2) {
  return fs$f.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$6),
  pathExistsSync: fs$f.existsSync
};
const fs$e = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$e.open(path2, "r+", (err2, fd) => {
    if (err2) return callback(err2);
    fs$e.futimes(fd, atime, mtime, (futimesErr) => {
      fs$e.close(fd, (closeErr) => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$e.openSync(path2, "r+");
  fs$e.futimesSync(fd, atime, mtime);
  return fs$e.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$d = fs$i;
const path$k = path$n;
const util$1 = require$$1$2;
function getStats$2(src2, dest, opts) {
  const statFunc = opts.dereference ? (file2) => fs$d.stat(file2, { bigint: true }) : (file2) => fs$d.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src2),
    statFunc(dest).catch((err2) => {
      if (err2.code === "ENOENT") return null;
      throw err2;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src2, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file2) => fs$d.statSync(file2, { bigint: true }) : (file2) => fs$d.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src2);
  try {
    destStat = statFunc(dest);
  } catch (err2) {
    if (err2.code === "ENOENT") return { srcStat, destStat: null };
    throw err2;
  }
  return { srcStat, destStat };
}
function checkPaths(src2, dest, funcName, opts, cb) {
  util$1.callbackify(getStats$2)(src2, dest, opts, (err2, stats) => {
    if (err2) return cb(err2);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$k.basename(src2);
        const destBaseName = path$k.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
      return cb(new Error(errMsg(src2, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src2, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$k.basename(src2);
      const destBaseName = path$k.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src2, srcStat, dest, funcName, cb) {
  const srcParent = path$k.resolve(path$k.dirname(src2));
  const destParent = path$k.resolve(path$k.dirname(dest));
  if (destParent === srcParent || destParent === path$k.parse(destParent).root) return cb();
  fs$d.stat(destParent, { bigint: true }, (err2, destStat) => {
    if (err2) {
      if (err2.code === "ENOENT") return cb();
      return cb(err2);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src2, dest, funcName)));
    }
    return checkParentPaths(src2, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src2, srcStat, dest, funcName) {
  const srcParent = path$k.resolve(path$k.dirname(src2));
  const destParent = path$k.resolve(path$k.dirname(dest));
  if (destParent === srcParent || destParent === path$k.parse(destParent).root) return;
  let destStat;
  try {
    destStat = fs$d.statSync(destParent, { bigint: true });
  } catch (err2) {
    if (err2.code === "ENOENT") return;
    throw err2;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPathsSync(src2, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src2, dest) {
  const srcArr = path$k.resolve(src2).split(path$k.sep).filter((i) => i);
  const destArr = path$k.resolve(dest).split(path$k.sep).filter((i) => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
}
function errMsg(src2, dest, funcName) {
  return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$c = gracefulFs;
const path$j = path$n;
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$5 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$3 = stat$4;
function copy$2(src2, dest, opts, cb) {
  if (typeof opts === "function" && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === "function") {
    opts = { filter: opts };
  }
  cb = cb || function() {
  };
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  stat$3.checkPaths(src2, dest, "copy", opts, (err2, stats) => {
    if (err2) return cb(err2);
    const { srcStat, destStat } = stats;
    stat$3.checkParentPaths(src2, srcStat, dest, "copy", (err3) => {
      if (err3) return cb(err3);
      if (opts.filter) return handleFilter(checkParentDir, destStat, src2, dest, opts, cb);
      return checkParentDir(destStat, src2, dest, opts, cb);
    });
  });
}
function checkParentDir(destStat, src2, dest, opts, cb) {
  const destParent = path$j.dirname(dest);
  pathExists$5(destParent, (err2, dirExists) => {
    if (err2) return cb(err2);
    if (dirExists) return getStats$1(destStat, src2, dest, opts, cb);
    mkdirs$1(destParent, (err3) => {
      if (err3) return cb(err3);
      return getStats$1(destStat, src2, dest, opts, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src2, dest, opts, cb) {
  Promise.resolve(opts.filter(src2, dest)).then((include) => {
    if (include) return onInclude(destStat, src2, dest, opts, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy$1(destStat, src2, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats$1, destStat, src2, dest, opts, cb);
  return getStats$1(destStat, src2, dest, opts, cb);
}
function getStats$1(destStat, src2, dest, opts, cb) {
  const stat2 = opts.dereference ? fs$c.stat : fs$c.lstat;
  stat2(src2, (err2, srcStat) => {
    if (err2) return cb(err2);
    if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src2, dest, opts, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src2, dest, opts, cb);
    else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src2, dest, opts, cb);
    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src2}`));
    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src2}`));
    return cb(new Error(`Unknown file: ${src2}`));
  });
}
function onFile$1(srcStat, destStat, src2, dest, opts, cb) {
  if (!destStat) return copyFile$1(srcStat, src2, dest, opts, cb);
  return mayCopyFile$1(srcStat, src2, dest, opts, cb);
}
function mayCopyFile$1(srcStat, src2, dest, opts, cb) {
  if (opts.overwrite) {
    fs$c.unlink(dest, (err2) => {
      if (err2) return cb(err2);
      return copyFile$1(srcStat, src2, dest, opts, cb);
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else return cb();
}
function copyFile$1(srcStat, src2, dest, opts, cb) {
  fs$c.copyFile(src2, dest, (err2) => {
    if (err2) return cb(err2);
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src2, dest, cb);
    return setDestMode$1(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src2, dest, cb) {
  if (fileIsNotWritable$1(srcMode)) {
    return makeFileWritable$1(dest, srcMode, (err2) => {
      if (err2) return cb(err2);
      return setDestTimestampsAndMode(srcMode, src2, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src2, dest, cb);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode, cb) {
  return setDestMode$1(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src2, dest, cb) {
  setDestTimestamps$1(src2, dest, (err2) => {
    if (err2) return cb(err2);
    return setDestMode$1(dest, srcMode, cb);
  });
}
function setDestMode$1(dest, srcMode, cb) {
  return fs$c.chmod(dest, srcMode, cb);
}
function setDestTimestamps$1(src2, dest, cb) {
  fs$c.stat(src2, (err2, updatedSrcStat) => {
    if (err2) return cb(err2);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir$1(srcStat, destStat, src2, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src2, dest, opts, cb);
  return copyDir$1(src2, dest, opts, cb);
}
function mkDirAndCopy$1(srcMode, src2, dest, opts, cb) {
  fs$c.mkdir(dest, (err2) => {
    if (err2) return cb(err2);
    copyDir$1(src2, dest, opts, (err3) => {
      if (err3) return cb(err3);
      return setDestMode$1(dest, srcMode, cb);
    });
  });
}
function copyDir$1(src2, dest, opts, cb) {
  fs$c.readdir(src2, (err2, items2) => {
    if (err2) return cb(err2);
    return copyDirItems(items2, src2, dest, opts, cb);
  });
}
function copyDirItems(items2, src2, dest, opts, cb) {
  const item = items2.pop();
  if (!item) return cb();
  return copyDirItem$1(items2, item, src2, dest, opts, cb);
}
function copyDirItem$1(items2, item, src2, dest, opts, cb) {
  const srcItem = path$j.join(src2, item);
  const destItem = path$j.join(dest, item);
  stat$3.checkPaths(srcItem, destItem, "copy", opts, (err2, stats) => {
    if (err2) return cb(err2);
    const { destStat } = stats;
    startCopy$1(destStat, srcItem, destItem, opts, (err3) => {
      if (err3) return cb(err3);
      return copyDirItems(items2, src2, dest, opts, cb);
    });
  });
}
function onLink$1(destStat, src2, dest, opts, cb) {
  fs$c.readlink(src2, (err2, resolvedSrc) => {
    if (err2) return cb(err2);
    if (opts.dereference) {
      resolvedSrc = path$j.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$c.symlink(resolvedSrc, dest, cb);
    } else {
      fs$c.readlink(dest, (err3, resolvedDest) => {
        if (err3) {
          if (err3.code === "EINVAL" || err3.code === "UNKNOWN") return fs$c.symlink(resolvedSrc, dest, cb);
          return cb(err3);
        }
        if (opts.dereference) {
          resolvedDest = path$j.resolve(process.cwd(), resolvedDest);
        }
        if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink$1(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink$1(resolvedSrc, dest, cb) {
  fs$c.unlink(dest, (err2) => {
    if (err2) return cb(err2);
    return fs$c.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const fs$b = gracefulFs;
const path$i = path$n;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src2, dest, opts) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src2, dest, "copy", opts);
  stat$2.checkParentPathsSync(src2, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src2, dest, opts);
}
function handleFilterAndCopy(destStat, src2, dest, opts) {
  if (opts.filter && !opts.filter(src2, dest)) return;
  const destParent = path$i.dirname(dest);
  if (!fs$b.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats(destStat, src2, dest, opts);
}
function startCopy(destStat, src2, dest, opts) {
  if (opts.filter && !opts.filter(src2, dest)) return;
  return getStats(destStat, src2, dest, opts);
}
function getStats(destStat, src2, dest, opts) {
  const statSync = opts.dereference ? fs$b.statSync : fs$b.lstatSync;
  const srcStat = statSync(src2);
  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts);
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
function onFile(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return copyFile(srcStat, src2, dest, opts);
  return mayCopyFile(srcStat, src2, dest, opts);
}
function mayCopyFile(srcStat, src2, dest, opts) {
  if (opts.overwrite) {
    fs$b.unlinkSync(dest);
    return copyFile(srcStat, src2, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src2, dest, opts) {
  fs$b.copyFileSync(src2, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src2, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src2, dest) {
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src2, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$b.chmodSync(dest, srcMode);
}
function setDestTimestamps(src2, dest) {
  const updatedSrcStat = fs$b.statSync(src2);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts);
  return copyDir(src2, dest, opts);
}
function mkDirAndCopy(srcMode, src2, dest, opts) {
  fs$b.mkdirSync(dest);
  copyDir(src2, dest, opts);
  return setDestMode(dest, srcMode);
}
function copyDir(src2, dest, opts) {
  fs$b.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
}
function copyDirItem(item, src2, dest, opts) {
  const srcItem = path$i.join(src2, item);
  const destItem = path$i.join(dest, item);
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
  return startCopy(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src2, dest, opts) {
  let resolvedSrc = fs$b.readlinkSync(src2);
  if (opts.dereference) {
    resolvedSrc = path$i.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$b.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$b.readlinkSync(dest);
    } catch (err2) {
      if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs$b.symlinkSync(resolvedSrc, dest);
      throw err2;
    }
    if (opts.dereference) {
      resolvedDest = path$i.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$b.statSync(dest).isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$b.unlinkSync(dest);
  return fs$b.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1),
  copySync: copySync_1
};
const fs$a = gracefulFs;
const path$h = path$n;
const assert = require$$5;
const isWindows = process.platform === "win32";
function defaults(options) {
  const methods2 = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods2.forEach((m) => {
    options[m] = options[m] || fs$a[m];
    m = m + "Sync";
    options[m] = options[m] || fs$a[m];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$1(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults(options);
  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time2 = busyTries * 100;
        return setTimeout(() => rimraf_(p, options, CB), time2);
      }
      if (er.code === "ENOENT") er = null;
    }
    cb(er);
  });
}
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir(p, options, er2, cb);
        }
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync(p, options, er) {
  let stats;
  assert(p);
  assert(options);
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er) return cb(er);
    let n = files.length;
    let errState;
    if (n === 0) return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$h.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2) return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}
function rimrafSync(p, options) {
  let st;
  options = options || {};
  defaults(options);
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    }
    if (er.code === "EPERM" && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$h.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$9 = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$9.rm) return fs$9.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$9.rmSync) return fs$9.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$8 = fs$i;
const path$g = path$n;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$8.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$g.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$8.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$g.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$f = path$n;
const fs$7 = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile$1(file2, callback) {
  function makeFile() {
    fs$7.writeFile(file2, "", (err2) => {
      if (err2) return callback(err2);
      callback();
    });
  }
  fs$7.stat(file2, (err2, stats) => {
    if (!err2 && stats.isFile()) return callback();
    const dir = path$f.dirname(file2);
    fs$7.stat(dir, (err3, stats2) => {
      if (err3) {
        if (err3.code === "ENOENT") {
          return mkdir$2.mkdirs(dir, (err4) => {
            if (err4) return callback(err4);
            makeFile();
          });
        }
        return callback(err3);
      }
      if (stats2.isDirectory()) makeFile();
      else {
        fs$7.readdir(dir, (err4) => {
          if (err4) return callback(err4);
        });
      }
    });
  });
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$7.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile()) return;
  const dir = path$f.dirname(file2);
  try {
    if (!fs$7.statSync(dir).isDirectory()) {
      fs$7.readdirSync(dir);
    }
  } catch (err2) {
    if (err2 && err2.code === "ENOENT") mkdir$2.mkdirsSync(dir);
    else throw err2;
  }
  fs$7.writeFileSync(file2, "");
}
var file = {
  createFile: u$5(createFile$1),
  createFileSync: createFileSync$1
};
const u$4 = universalify$1.fromCallback;
const path$e = path$n;
const fs$6 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink$1(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$6.link(srcpath2, dstpath2, (err2) => {
      if (err2) return callback(err2);
      callback(null);
    });
  }
  fs$6.lstat(dstpath, (_, dstStat) => {
    fs$6.lstat(srcpath, (err2, srcStat) => {
      if (err2) {
        err2.message = err2.message.replace("lstat", "ensureLink");
        return callback(err2);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null);
      const dir = path$e.dirname(dstpath);
      pathExists$4(dir, (err3, dirExists) => {
        if (err3) return callback(err3);
        if (dirExists) return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err4) => {
          if (err4) return callback(err4);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$6.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$6.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat)) return;
  } catch (err2) {
    err2.message = err2.message.replace("lstat", "ensureLink");
    throw err2;
  }
  const dir = path$e.dirname(dstpath);
  const dirExists = fs$6.existsSync(dir);
  if (dirExists) return fs$6.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$6.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$4(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$d = path$n;
const fs$5 = gracefulFs;
const pathExists$3 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$d.isAbsolute(srcpath)) {
    return fs$5.lstat(srcpath, (err2) => {
      if (err2) {
        err2.message = err2.message.replace("lstat", "ensureSymlink");
        return callback(err2);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$d.dirname(dstpath);
    const relativeToDst = path$d.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err2, exists) => {
      if (err2) return callback(err2);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$5.lstat(srcpath, (err3) => {
          if (err3) {
            err3.message = err3.message.replace("lstat", "ensureSymlink");
            return callback(err3);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$d.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$d.isAbsolute(srcpath)) {
    exists = fs$5.existsSync(srcpath);
    if (!exists) throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
    const dstdir = path$d.dirname(dstpath);
    const relativeToDst = path$d.join(dstdir, srcpath);
    exists = fs$5.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    } else {
      exists = fs$5.existsSync(srcpath);
      if (!exists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$d.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$4 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2) return callback(null, type2);
  fs$4.lstat(srcpath, (err2, stats) => {
    if (err2) return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2) return type2;
  try {
    stats = fs$4.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$c = path$n;
const fs$3 = fs$i;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$2 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink$1(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$3.lstat(dstpath, (err2, stats) => {
    if (!err2 && stats.isSymbolicLink()) {
      Promise.all([
        fs$3.stat(srcpath),
        fs$3.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat)) return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err2, relative) => {
    if (err2) return callback(err2);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err3, type3) => {
      if (err3) return callback(err3);
      const dir = path$c.dirname(dstpath);
      pathExists$2(dir, (err4, dirExists) => {
        if (err4) return callback(err4);
        if (dirExists) return fs$3.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err5) => {
          if (err5) return callback(err5);
          fs$3.symlink(srcpath, dstpath, type3, callback);
        });
      });
    });
  });
}
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$3.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$3.statSync(srcpath);
    const dstStat = fs$3.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$c.dirname(dstpath);
  const exists = fs$3.existsSync(dir);
  if (exists) return fs$3.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$3.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$4(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content)) content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$4, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = fs$k;
}
const universalify = universalify$1;
const { stringify: stringify$3, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err2) {
    if (shouldThrow) {
      err2.message = `${file2}: ${err2.message}`;
      throw err2;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile = universalify.fromPromise(_readFile);
function readFileSync(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err2) {
    if (shouldThrow) {
      err2.message = `${file2}: ${err2.message}`;
      throw err2;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile = universalify.fromPromise(_writeFile);
function writeFileSync(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromCallback;
const fs$2 = gracefulFs;
const path$b = path$n;
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$b.dirname(file2);
  pathExists$1(dir, (err2, itDoes) => {
    if (err2) return callback(err2);
    if (itDoes) return fs$2.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err3) => {
      if (err3) return callback(err3);
      fs$2.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$b.dirname(file2);
  if (fs$2.existsSync(dir)) {
    return fs$2.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$2.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$2 } = utils;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str2 = stringify$2(data, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify: stringify$1 } = utils;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str2 = stringify$1(data, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json$1 = jsonFile;
const fs$1 = gracefulFs;
const path$a = path$n;
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists = pathExists_1.pathExists;
const stat$1 = stat$4;
function move$1(src2, dest, opts, cb) {
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  stat$1.checkPaths(src2, dest, "move", opts, (err2, stats) => {
    if (err2) return cb(err2);
    const { srcStat, isChangingCase = false } = stats;
    stat$1.checkParentPaths(src2, srcStat, dest, "move", (err3) => {
      if (err3) return cb(err3);
      if (isParentRoot$1(dest)) return doRename$1(src2, dest, overwrite, isChangingCase, cb);
      mkdirp(path$a.dirname(dest), (err4) => {
        if (err4) return cb(err4);
        return doRename$1(src2, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot$1(dest) {
  const parent = path$a.dirname(dest);
  const parsedPath = path$a.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src2, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase) return rename$1(src2, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err2) => {
      if (err2) return cb(err2);
      return rename$1(src2, dest, overwrite, cb);
    });
  }
  pathExists(dest, (err2, destExists) => {
    if (err2) return cb(err2);
    if (destExists) return cb(new Error("dest already exists."));
    return rename$1(src2, dest, overwrite, cb);
  });
}
function rename$1(src2, dest, overwrite, cb) {
  fs$1.rename(src2, dest, (err2) => {
    if (!err2) return cb();
    if (err2.code !== "EXDEV") return cb(err2);
    return moveAcrossDevice$1(src2, dest, overwrite, cb);
  });
}
function moveAcrossDevice$1(src2, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy(src2, dest, opts, (err2) => {
    if (err2) return cb(err2);
    return remove(src2, cb);
  });
}
var move_1 = move$1;
const fs = gracefulFs;
const path$9 = path$n;
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src2, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src2, dest, "move", opts);
  stat.checkParentPathsSync(src2, srcStat, dest, "move");
  if (!isParentRoot(dest)) mkdirpSync(path$9.dirname(dest));
  return doRename(src2, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$9.dirname(dest);
  const parsedPath = path$9.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src2, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename(src2, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src2, dest, overwrite);
  }
  if (fs.existsSync(dest)) throw new Error("dest already exists.");
  return rename(src2, dest, overwrite);
}
function rename(src2, dest, overwrite) {
  try {
    fs.renameSync(src2, dest);
  } catch (err2) {
    if (err2.code !== "EXDEV") throw err2;
    return moveAcrossDevice(src2, dest, overwrite);
  }
}
function moveAcrossDevice(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync(src2, dest, opts);
  return removeSync(src2);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = {
  // Export promiseified graceful-fs:
  ...fs$i,
  // Export extra methods:
  ...copy$1,
  ...empty,
  ...ensure,
  ...json$1,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var BaseUpdater$1 = {};
var AppUpdater$1 = {};
var out = {};
var CancellationToken$1 = {};
Object.defineProperty(CancellationToken$1, "__esModule", { value: true });
CancellationToken$1.CancellationError = CancellationToken$1.CancellationToken = void 0;
const events_1$1 = require$$1$3;
class CancellationToken extends events_1$1.EventEmitter {
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(value) {
    this.removeParentCancelHandler();
    this._parent = value;
    this.parentCancelHandler = () => this.cancel();
    this._parent.onCancel(this.parentCancelHandler);
  }
  // babel cannot compile ... correctly for super calls
  constructor(parent) {
    super();
    this.parentCancelHandler = null;
    this._parent = null;
    this._cancelled = false;
    if (parent != null) {
      this.parent = parent;
    }
  }
  cancel() {
    this._cancelled = true;
    this.emit("cancel");
  }
  onCancel(handler) {
    if (this.cancelled) {
      handler();
    } else {
      this.once("cancel", handler);
    }
  }
  createPromise(callback) {
    if (this.cancelled) {
      return Promise.reject(new CancellationError());
    }
    const finallyHandler = () => {
      if (cancelHandler != null) {
        try {
          this.removeListener("cancel", cancelHandler);
          cancelHandler = null;
        } catch (_ignore) {
        }
      }
    };
    let cancelHandler = null;
    return new Promise((resolve2, reject) => {
      let addedCancelHandler = null;
      cancelHandler = () => {
        try {
          if (addedCancelHandler != null) {
            addedCancelHandler();
            addedCancelHandler = null;
          }
        } finally {
          reject(new CancellationError());
        }
      };
      if (this.cancelled) {
        cancelHandler();
        return;
      }
      this.onCancel(cancelHandler);
      callback(resolve2, reject, (callback2) => {
        addedCancelHandler = callback2;
      });
    }).then((it) => {
      finallyHandler();
      return it;
    }).catch((e) => {
      finallyHandler();
      throw e;
    });
  }
  removeParentCancelHandler() {
    const parent = this._parent;
    if (parent != null && this.parentCancelHandler != null) {
      parent.removeListener("cancel", this.parentCancelHandler);
      this.parentCancelHandler = null;
    }
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners();
      this._parent = null;
    }
  }
}
CancellationToken$1.CancellationToken = CancellationToken;
class CancellationError extends Error {
  constructor() {
    super("cancelled");
  }
}
CancellationToken$1.CancellationError = CancellationError;
var error = {};
Object.defineProperty(error, "__esModule", { value: true });
error.newError = newError;
function newError(message, code2) {
  const error2 = new Error(message);
  error2.code = code2;
  return error2;
}
var httpExecutor = {};
var ProgressCallbackTransform$1 = {};
Object.defineProperty(ProgressCallbackTransform$1, "__esModule", { value: true });
ProgressCallbackTransform$1.ProgressCallbackTransform = void 0;
const stream_1$3 = stream;
class ProgressCallbackTransform extends stream_1$3.Transform {
  constructor(total, cancellationToken, onProgress) {
    super();
    this.total = total;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now2 = Date.now();
    if (now2 >= this.nextUpdate && this.transferred !== this.total) {
      this.nextUpdate = now2 + 1e3;
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.total * 100,
        bytesPerSecond: Math.round(this.transferred / ((now2 - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    callback(null);
  }
}
ProgressCallbackTransform$1.ProgressCallbackTransform = ProgressCallbackTransform;
Object.defineProperty(httpExecutor, "__esModule", { value: true });
httpExecutor.DigestTransform = httpExecutor.HttpExecutor = httpExecutor.HttpError = void 0;
httpExecutor.createHttpError = createHttpError;
httpExecutor.parseJson = parseJson;
httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
httpExecutor.configureRequestUrl = configureRequestUrl;
httpExecutor.safeGetHeader = safeGetHeader;
httpExecutor.configureRequestOptions = configureRequestOptions;
httpExecutor.safeStringifyJson = safeStringifyJson;
const crypto_1$4 = require$$0$c;
const debug_1 = srcExports;
const fs_1$5 = fs$k;
const stream_1$2 = stream;
const url_1$5 = require$$0$5;
const CancellationToken_1$1 = CancellationToken$1;
const error_1$2 = error;
const ProgressCallbackTransform_1 = ProgressCallbackTransform$1;
const debug = (0, debug_1.default)("electron-builder");
function createHttpError(response2, description2 = null) {
  return new HttpError(response2.statusCode || -1, `${response2.statusCode} ${response2.statusMessage}` + (description2 == null ? "" : "\n" + JSON.stringify(description2, null, "  ")) + "\nHeaders: " + safeStringifyJson(response2.headers), description2);
}
const HTTP_STATUS_CODES = /* @__PURE__ */ new Map([
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
class HttpError extends Error {
  constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description2 = null) {
    super(message);
    this.statusCode = statusCode;
    this.description = description2;
    this.name = "HttpError";
    this.code = `HTTP_ERROR_${statusCode}`;
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
httpExecutor.HttpError = HttpError;
function parseJson(result) {
  return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
}
class HttpExecutor {
  constructor() {
    this.maxRedirects = 10;
  }
  request(options, cancellationToken = new CancellationToken_1$1.CancellationToken(), data) {
    configureRequestOptions(options);
    const json2 = data == null ? void 0 : JSON.stringify(data);
    const encodedData = json2 ? Buffer.from(json2) : void 0;
    if (encodedData != null) {
      debug(json2);
      const { headers: headers2, ...opts } = options;
      options = {
        method: "post",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": encodedData.length,
          ...headers2
        },
        ...opts
      };
    }
    return this.doApiRequest(options, cancellationToken, (it) => it.end(encodedData));
  }
  doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
    if (debug.enabled) {
      debug(`Request: ${safeStringifyJson(options)}`);
    }
    return cancellationToken.createPromise((resolve2, reject, onCancel) => {
      const request2 = this.createRequest(options, (response2) => {
        try {
          this.handleResponse(response2, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor);
        } catch (e) {
          reject(e);
        }
      });
      this.addErrorAndTimeoutHandlers(request2, reject, options.timeout);
      this.addRedirectHandlers(request2, options, reject, redirectCount, (options2) => {
        this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      });
      requestProcessor(request2, reject);
      onCancel(() => request2.abort());
    });
  }
  // noinspection JSUnusedLocalSymbols
  // eslint-disable-next-line
  addRedirectHandlers(request2, options, reject, redirectCount, handler) {
  }
  addErrorAndTimeoutHandlers(request2, reject, timeout = 60 * 1e3) {
    this.addTimeOutHandler(request2, reject, timeout);
    request2.on("error", reject);
    request2.on("aborted", () => {
      reject(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(response2, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor) {
    var _a2;
    if (debug.enabled) {
      debug(`Response: ${response2.statusCode} ${response2.statusMessage}, request options: ${safeStringifyJson(options)}`);
    }
    if (response2.statusCode === 404) {
      reject(createHttpError(response2, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (response2.statusCode === 204) {
      resolve2();
      return;
    }
    const code2 = (_a2 = response2.statusCode) !== null && _a2 !== void 0 ? _a2 : 0;
    const shouldRedirect = code2 >= 300 && code2 < 400;
    const redirectUrl = safeGetHeader(response2, "location");
    if (shouldRedirect && redirectUrl != null) {
      if (redirectCount > this.maxRedirects) {
        reject(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      return;
    }
    response2.setEncoding("utf8");
    let data = "";
    response2.on("error", reject);
    response2.on("data", (chunk) => data += chunk);
    response2.on("end", () => {
      try {
        if (response2.statusCode != null && response2.statusCode >= 400) {
          const contentType = safeGetHeader(response2, "content-type");
          const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
          reject(createHttpError(response2, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
        } else {
          resolve2(data.length === 0 ? null : data);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
  async downloadToBuffer(url2, options) {
    return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
      const responseChunks = [];
      const requestOptions = {
        headers: options.headers || void 0,
        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
        redirect: "manual"
      };
      configureRequestUrl(url2, requestOptions);
      configureRequestOptions(requestOptions);
      this.doDownload(requestOptions, {
        destination: null,
        options,
        onCancel,
        callback: (error2) => {
          if (error2 == null) {
            resolve2(Buffer.concat(responseChunks));
          } else {
            reject(error2);
          }
        },
        responseHandler: (response2, callback) => {
          let receivedLength = 0;
          response2.on("data", (chunk) => {
            receivedLength += chunk.length;
            if (receivedLength > 524288e3) {
              callback(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            responseChunks.push(chunk);
          });
          response2.on("end", () => {
            callback(null);
          });
        }
      }, 0);
    });
  }
  doDownload(requestOptions, options, redirectCount) {
    const request2 = this.createRequest(requestOptions, (response2) => {
      if (response2.statusCode >= 400) {
        options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response2.statusCode}: ${response2.statusMessage}`));
        return;
      }
      response2.on("error", options.callback);
      const redirectUrl = safeGetHeader(response2, "location");
      if (redirectUrl != null) {
        if (redirectCount < this.maxRedirects) {
          this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
        } else {
          options.callback(this.createMaxRedirectError());
        }
        return;
      }
      if (options.responseHandler == null) {
        configurePipes(options, response2);
      } else {
        options.responseHandler(response2, options.callback);
      }
    });
    this.addErrorAndTimeoutHandlers(request2, options.callback, requestOptions.timeout);
    this.addRedirectHandlers(request2, requestOptions, options.callback, redirectCount, (requestOptions2) => {
      this.doDownload(requestOptions2, options, redirectCount++);
    });
    request2.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(request2, callback, timeout) {
    request2.on("socket", (socket) => {
      socket.setTimeout(timeout, () => {
        request2.abort();
        callback(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(redirectUrl, options) {
    const newOptions = configureRequestOptionsFromUrl(redirectUrl, { ...options });
    const headers2 = newOptions.headers;
    if (headers2 === null || headers2 === void 0 ? void 0 : headers2.authorization) {
      const parsedNewUrl = new url_1$5.URL(redirectUrl);
      if (parsedNewUrl.hostname.endsWith(".amazonaws.com") || parsedNewUrl.searchParams.has("X-Amz-Credential")) {
        delete headers2.authorization;
      }
    }
    return newOptions;
  }
  static retryOnServerError(task, maxRetries = 3) {
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return task();
      } catch (e) {
        if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
          continue;
        }
        throw e;
      }
    }
  }
}
httpExecutor.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url2, options) {
  const result = configureRequestOptions(options);
  configureRequestUrl(new url_1$5.URL(url2), result);
  return result;
}
function configureRequestUrl(url2, options) {
  options.protocol = url2.protocol;
  options.hostname = url2.hostname;
  if (url2.port) {
    options.port = url2.port;
  } else if (options.port) {
    delete options.port;
  }
  options.path = url2.pathname + url2.search;
}
class DigestTransform extends stream_1$2.Transform {
  // noinspection JSUnusedGlobalSymbols
  get actual() {
    return this._actual;
  }
  constructor(expected, algorithm = "sha512", encoding = "base64") {
    super();
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this._actual = null;
    this.isValidateOnEnd = true;
    this.digester = (0, crypto_1$4.createHash)(algorithm);
  }
  // noinspection JSUnusedGlobalSymbols
  _transform(chunk, encoding, callback) {
    this.digester.update(chunk);
    callback(null, chunk);
  }
  // noinspection JSUnusedGlobalSymbols
  _flush(callback) {
    this._actual = this.digester.digest(this.encoding);
    if (this.isValidateOnEnd) {
      try {
        this.validate();
      } catch (e) {
        callback(e);
        return;
      }
    }
    callback(null);
  }
  validate() {
    if (this._actual == null) {
      throw (0, error_1$2.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    }
    if (this._actual !== this.expected) {
      throw (0, error_1$2.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    }
    return null;
  }
}
httpExecutor.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
  if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
    callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
    return false;
  }
  return true;
}
function safeGetHeader(response2, headerKey) {
  const value = response2.headers[headerKey];
  if (value == null) {
    return null;
  } else if (Array.isArray(value)) {
    return value.length === 0 ? null : value[value.length - 1];
  } else {
    return value;
  }
}
function configurePipes(options, response2) {
  if (!checkSha2(safeGetHeader(response2, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
    return;
  }
  const streams = [];
  if (options.options.onProgress != null) {
    const contentLength = safeGetHeader(response2, "content-length");
    if (contentLength != null) {
      streams.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
    }
  }
  const sha512 = options.options.sha512;
  if (sha512 != null) {
    streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
  } else if (options.options.sha2 != null) {
    streams.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
  }
  const fileOut = (0, fs_1$5.createWriteStream)(options.destination);
  streams.push(fileOut);
  let lastStream = response2;
  for (const stream2 of streams) {
    stream2.on("error", (error2) => {
      fileOut.close();
      if (!options.options.cancellationToken.cancelled) {
        options.callback(error2);
      }
    });
    lastStream = lastStream.pipe(stream2);
  }
  fileOut.on("finish", () => {
    fileOut.close(options.callback);
  });
}
function configureRequestOptions(options, token, method) {
  if (method != null) {
    options.method = method;
  }
  options.headers = { ...options.headers };
  const headers2 = options.headers;
  if (token != null) {
    headers2.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
  }
  if (headers2["User-Agent"] == null) {
    headers2["User-Agent"] = "electron-builder";
  }
  if (method == null || method === "GET" || headers2["Cache-Control"] == null) {
    headers2["Cache-Control"] = "no-cache";
  }
  if (options.protocol == null && process.versions.electron != null) {
    options.protocol = "https:";
  }
  return options;
}
function safeStringifyJson(data, skippedNames) {
  return JSON.stringify(data, (name, value) => {
    if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
      return "<stripped sensitive data>";
    }
    return value;
  }, 2);
}
var MemoLazy$1 = {};
Object.defineProperty(MemoLazy$1, "__esModule", { value: true });
MemoLazy$1.MemoLazy = void 0;
class MemoLazy {
  constructor(selector, creator) {
    this.selector = selector;
    this.creator = creator;
    this.selected = void 0;
    this._value = void 0;
  }
  get hasValue() {
    return this._value !== void 0;
  }
  get value() {
    const selected = this.selector();
    if (this._value !== void 0 && equals(this.selected, selected)) {
      return this._value;
    }
    this.selected = selected;
    const result = this.creator(selected);
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
  }
}
MemoLazy$1.MemoLazy = MemoLazy;
function equals(firstValue, secondValue) {
  const isFirstObject = typeof firstValue === "object" && firstValue !== null;
  const isSecondObject = typeof secondValue === "object" && secondValue !== null;
  if (isFirstObject && isSecondObject) {
    const keys1 = Object.keys(firstValue);
    const keys2 = Object.keys(secondValue);
    return keys1.length === keys2.length && keys1.every((key) => equals(firstValue[key], secondValue[key]));
  }
  return firstValue === secondValue;
}
var publishOptions = {};
Object.defineProperty(publishOptions, "__esModule", { value: true });
publishOptions.githubUrl = githubUrl;
publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
function githubUrl(options, defaultHost = "github.com") {
  return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
function getS3LikeProviderBaseUrl(configuration) {
  const provider = configuration.provider;
  if (provider === "s3") {
    return s3Url(configuration);
  }
  if (provider === "spaces") {
    return spacesUrl(configuration);
  }
  throw new Error(`Not supported provider: ${provider}`);
}
function s3Url(options) {
  let url2;
  if (options.accelerate == true) {
    url2 = `https://${options.bucket}.s3-accelerate.amazonaws.com`;
  } else if (options.endpoint != null) {
    url2 = `${options.endpoint}/${options.bucket}`;
  } else if (options.bucket.includes(".")) {
    if (options.region == null) {
      throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
    }
    if (options.region === "us-east-1") {
      url2 = `https://s3.amazonaws.com/${options.bucket}`;
    } else {
      url2 = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
    }
  } else if (options.region === "cn-north-1") {
    url2 = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
  } else {
    url2 = `https://${options.bucket}.s3.amazonaws.com`;
  }
  return appendPath(url2, options.path);
}
function appendPath(url2, p) {
  if (p != null && p.length > 0) {
    if (!p.startsWith("/")) {
      url2 += "/";
    }
    url2 += p;
  }
  return url2;
}
function spacesUrl(options) {
  if (options.name == null) {
    throw new Error(`name is missing`);
  }
  if (options.region == null) {
    throw new Error(`region is missing`);
  }
  return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
}
var retry$1 = {};
Object.defineProperty(retry$1, "__esModule", { value: true });
retry$1.retry = retry;
const CancellationToken_1 = CancellationToken$1;
async function retry(task, retryCount, interval, backoff = 0, attempt = 0, shouldRetry) {
  var _a2;
  const cancellationToken = new CancellationToken_1.CancellationToken();
  try {
    return await task();
  } catch (error2) {
    if (((_a2 = shouldRetry === null || shouldRetry === void 0 ? void 0 : shouldRetry(error2)) !== null && _a2 !== void 0 ? _a2 : true) && retryCount > 0 && !cancellationToken.cancelled) {
      await new Promise((resolve2) => setTimeout(resolve2, interval + backoff * attempt));
      return await retry(task, retryCount - 1, interval, backoff, attempt + 1, shouldRetry);
    } else {
      throw error2;
    }
  }
}
var rfc2253Parser = {};
Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
rfc2253Parser.parseDn = parseDn;
function parseDn(seq2) {
  let quoted = false;
  let key = null;
  let token = "";
  let nextNonSpace = 0;
  seq2 = seq2.trim();
  const result = /* @__PURE__ */ new Map();
  for (let i = 0; i <= seq2.length; i++) {
    if (i === seq2.length) {
      if (key !== null) {
        result.set(key, token);
      }
      break;
    }
    const ch = seq2[i];
    if (quoted) {
      if (ch === '"') {
        quoted = false;
        continue;
      }
    } else {
      if (ch === '"') {
        quoted = true;
        continue;
      }
      if (ch === "\\") {
        i++;
        const ord = parseInt(seq2.slice(i, i + 2), 16);
        if (Number.isNaN(ord)) {
          token += seq2[i];
        } else {
          i++;
          token += String.fromCharCode(ord);
        }
        continue;
      }
      if (key === null && ch === "=") {
        key = token;
        token = "";
        continue;
      }
      if (ch === "," || ch === ";" || ch === "+") {
        if (key !== null) {
          result.set(key, token);
        }
        key = null;
        token = "";
        continue;
      }
    }
    if (ch === " " && !quoted) {
      if (token.length === 0) {
        continue;
      }
      if (i > nextNonSpace) {
        let j = i;
        while (seq2[j] === " ") {
          j++;
        }
        nextNonSpace = j;
      }
      if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key === null && seq2[nextNonSpace] === "=" || key !== null && seq2[nextNonSpace] === "+") {
        i = nextNonSpace - 1;
        continue;
      }
    }
    token += ch;
  }
  return result;
}
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.nil = uuid.UUID = void 0;
const crypto_1$3 = require$$0$c;
const error_1$1 = error;
const invalidName = "options.name must be either a string or a Buffer";
const randomHost = (0, crypto_1$3.randomBytes)(16);
randomHost[0] = randomHost[0] | 1;
const hex2byte = {};
const byte2hex = [];
for (let i = 0; i < 256; i++) {
  const hex = (i + 256).toString(16).substr(1);
  hex2byte[hex] = i;
  byte2hex[i] = hex;
}
class UUID {
  constructor(uuid2) {
    this.ascii = null;
    this.binary = null;
    const check = UUID.check(uuid2);
    if (!check) {
      throw new Error("not a UUID");
    }
    this.version = check.version;
    if (check.format === "ascii") {
      this.ascii = uuid2;
    } else {
      this.binary = uuid2;
    }
  }
  static v5(name, namespace) {
    return uuidNamed(name, "sha1", 80, namespace);
  }
  toString() {
    if (this.ascii == null) {
      this.ascii = stringify(this.binary);
    }
    return this.ascii;
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(uuid2, offset = 0) {
    if (typeof uuid2 === "string") {
      uuid2 = uuid2.toLowerCase();
      if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
        return false;
      }
      if (uuid2 === "00000000-0000-0000-0000-000000000000") {
        return { version: void 0, variant: "nil", format: "ascii" };
      }
      return {
        version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
        variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
        format: "ascii"
      };
    }
    if (Buffer.isBuffer(uuid2)) {
      if (uuid2.length < offset + 16) {
        return false;
      }
      let i = 0;
      for (; i < 16; i++) {
        if (uuid2[offset + i] !== 0) {
          break;
        }
      }
      if (i === 16) {
        return { version: void 0, variant: "nil", format: "binary" };
      }
      return {
        version: (uuid2[offset + 6] & 240) >> 4,
        variant: getVariant((uuid2[offset + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, error_1$1.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  // read stringified uuid into a Buffer
  static parse(input) {
    const buffer = Buffer.allocUnsafe(16);
    let j = 0;
    for (let i = 0; i < 16; i++) {
      buffer[i] = hex2byte[input[j++] + input[j++]];
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        j += 1;
      }
    }
    return buffer;
  }
}
uuid.UUID = UUID;
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function getVariant(bits) {
  switch (bits) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
var UuidEncoding;
(function(UuidEncoding2) {
  UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
  UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
  UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
function uuidNamed(name, hashMethod, version2, namespace, encoding = UuidEncoding.ASCII) {
  const hash = (0, crypto_1$3.createHash)(hashMethod);
  const nameIsNotAString = typeof name !== "string";
  if (nameIsNotAString && !Buffer.isBuffer(name)) {
    throw (0, error_1$1.newError)(invalidName, "ERR_INVALID_UUID_NAME");
  }
  hash.update(namespace);
  hash.update(name);
  const buffer = hash.digest();
  let result;
  switch (encoding) {
    case UuidEncoding.BINARY:
      buffer[6] = buffer[6] & 15 | version2;
      buffer[8] = buffer[8] & 63 | 128;
      result = buffer;
      break;
    case UuidEncoding.OBJECT:
      buffer[6] = buffer[6] & 15 | version2;
      buffer[8] = buffer[8] & 63 | 128;
      result = new UUID(buffer);
      break;
    default:
      result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version2] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
      break;
  }
  return result;
}
function stringify(buffer) {
  return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
var xml = {};
var sax$1 = {};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      if (parser.opt.unquotedAttributeValues === void 0) {
        parser.opt.unquotedAttributeValues = !strict;
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error2(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require("stream").Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    if (!Stream2) Stream2 = function() {
    };
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1$5.StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace2(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace2(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++,
      // leading whitespace
      TEXT: S++,
      // general stuff
      TEXT_ENTITY: S++,
      // &amp and such.
      OPEN_WAKA: S++,
      // <
      SGML_DECL: S++,
      // <!BLARG
      SGML_DECL_QUOTED: S++,
      // <!BLARG foo "bar
      DOCTYPE: S++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++,
      // <!-
      COMMENT: S++,
      // <!--
      COMMENT_ENDING: S++,
      // <!-- blah -
      COMMENT_ENDED: S++,
      // <!-- blah --
      CDATA: S++,
      // <![CDATA[ something
      CDATA_ENDING: S++,
      // ]
      CDATA_ENDING_2: S++,
      // ]]
      PROC_INST: S++,
      // <?hi
      PROC_INST_BODY: S++,
      // <?hi there
      PROC_INST_ENDING: S++,
      // <?hi "there" ?
      OPEN_TAG: S++,
      // <strong
      OPEN_TAG_SLASH: S++,
      // <strong /
      ATTRIB: S++,
      // <a
      ATTRIB_NAME: S++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S++,
      // <a foo _
      ATTRIB_VALUE: S++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++,
      // <foo bar=&quot
      CLOSE_TAG: S++,
      // </a
      CLOSE_TAG_SAW_WHITE: S++,
      // </a   >
      SCRIPT: S++,
      // <script> ...
      SCRIPT_ENDING: S++
      // <script> ... <
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e = sax2.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key] = s2;
    });
    for (var s in sax2.STATE) {
      sax2.STATE[sax2.STATE[s]] = s;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser,
              "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(
              parser,
              "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri: uri2
          };
          if (prefix && prefix !== "xmlns" && !uri2) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t2 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close2 = parser.tags[t2];
        if (close2.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t2 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t2 === 0) parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace2(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error2(
          parser,
          "Cannot write after close. Assign an onready handler."
        );
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace2(c)) ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
              continue;
            }
            if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
              parser.state = S.DOCTYPE_DTD;
              parser.doctype += "<!" + parser.sgmlDecl + c;
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(
                  parser,
                  "Inappropriately located doctype declaration"
                );
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            if (c === "]") {
              parser.doctype += c;
              parser.state = S.DOCTYPE;
            } else if (c === "<") {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else if (isQuote(c)) {
              parser.doctype += c;
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            } else {
              parser.doctype += c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else if (parser.doctype && parser.doctype !== true) {
              parser.state = S.DOCTYPE_DTD;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace2(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace2(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace2(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace2(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace2(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace2(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace2(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              if (!parser.opt.unquotedAttributeValues) {
                error2(parser, "Unquoted attribute value");
              }
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace2(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace2(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace2(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace2(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parsedEntity;
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default: {
            throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor2 = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor2(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
Object.defineProperty(xml, "__esModule", { value: true });
xml.XElement = void 0;
xml.parseXml = parseXml;
const sax = sax$1;
const error_1 = error;
class XElement {
  constructor(name) {
    this.name = name;
    this.value = "";
    this.attributes = null;
    this.isCData = false;
    this.elements = null;
    if (!name) {
      throw (0, error_1.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    }
    if (!isValidName(name)) {
      throw (0, error_1.newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
  }
  attribute(name) {
    const result = this.attributes === null ? null : this.attributes[name];
    if (result == null) {
      throw (0, error_1.newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
    }
    return result;
  }
  removeAttribute(name) {
    if (this.attributes !== null) {
      delete this.attributes[name];
    }
  }
  element(name, ignoreCase = false, errorIfMissed = null) {
    const result = this.elementOrNull(name, ignoreCase);
    if (result === null) {
      throw (0, error_1.newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
    }
    return result;
  }
  elementOrNull(name, ignoreCase = false) {
    if (this.elements === null) {
      return null;
    }
    for (const element of this.elements) {
      if (isNameEquals(element, name, ignoreCase)) {
        return element;
      }
    }
    return null;
  }
  getElements(name, ignoreCase = false) {
    if (this.elements === null) {
      return [];
    }
    return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
  }
  elementValueOrEmpty(name, ignoreCase = false) {
    const element = this.elementOrNull(name, ignoreCase);
    return element === null ? "" : element.value;
  }
}
xml.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
  return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
  const elementName = element.name;
  return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
  let rootElement = null;
  const parser = sax.parser(true, {});
  const elements2 = [];
  parser.onopentag = (saxElement) => {
    const element = new XElement(saxElement.name);
    element.attributes = saxElement.attributes;
    if (rootElement === null) {
      rootElement = element;
    } else {
      const parent = elements2[elements2.length - 1];
      if (parent.elements == null) {
        parent.elements = [];
      }
      parent.elements.push(element);
    }
    elements2.push(element);
  };
  parser.onclosetag = () => {
    elements2.pop();
  };
  parser.ontext = (text) => {
    if (elements2.length > 0) {
      elements2[elements2.length - 1].value = text;
    }
  };
  parser.oncdata = (cdata) => {
    const element = elements2[elements2.length - 1];
    element.value = cdata;
    element.isCData = true;
  };
  parser.onerror = (err2) => {
    throw err2;
  };
  parser.write(data);
  return rootElement;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.UUID = exports.parseDn = exports.retry = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.ProgressCallbackTransform = exports.MemoLazy = exports.safeStringifyJson = exports.safeGetHeader = exports.parseJson = exports.HttpExecutor = exports.HttpError = exports.DigestTransform = exports.createHttpError = exports.configureRequestUrl = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.newError = exports.CancellationToken = exports.CancellationError = void 0;
  exports.asArray = asArray;
  var CancellationToken_12 = CancellationToken$1;
  Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationError;
  } });
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationToken;
  } });
  var error_12 = error;
  Object.defineProperty(exports, "newError", { enumerable: true, get: function() {
    return error_12.newError;
  } });
  var httpExecutor_1 = httpExecutor;
  Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptions;
  } });
  Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptionsFromUrl;
  } });
  Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestUrl;
  } });
  Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
    return httpExecutor_1.createHttpError;
  } });
  Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
    return httpExecutor_1.DigestTransform;
  } });
  Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
    return httpExecutor_1.HttpError;
  } });
  Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
    return httpExecutor_1.HttpExecutor;
  } });
  Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
    return httpExecutor_1.parseJson;
  } });
  Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
    return httpExecutor_1.safeGetHeader;
  } });
  Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
    return httpExecutor_1.safeStringifyJson;
  } });
  var MemoLazy_1 = MemoLazy$1;
  Object.defineProperty(exports, "MemoLazy", { enumerable: true, get: function() {
    return MemoLazy_1.MemoLazy;
  } });
  var ProgressCallbackTransform_12 = ProgressCallbackTransform$1;
  Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
    return ProgressCallbackTransform_12.ProgressCallbackTransform;
  } });
  var publishOptions_1 = publishOptions;
  Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
    return publishOptions_1.getS3LikeProviderBaseUrl;
  } });
  Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
    return publishOptions_1.githubUrl;
  } });
  var retry_1 = retry$1;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var rfc2253Parser_1 = rfc2253Parser;
  Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
    return rfc2253Parser_1.parseDn;
  } });
  var uuid_1 = uuid;
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return uuid_1.UUID;
  } });
  var xml_1 = xml;
  Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
    return xml_1.parseXml;
  } });
  Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
    return xml_1.XElement;
  } });
  exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
  exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function asArray(v) {
    if (v == null) {
      return [];
    } else if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  }
})(out);
var jsYaml = {};
var loader$1 = {};
var common$5 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
common$5.isNothing = isNothing;
common$5.isObject = isObject;
common$5.toArray = toArray;
common$5.repeat = repeat;
common$5.isNegativeZero = isNegativeZero;
common$5.extend = extend;
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$4(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$4;
var common$4 = common$5;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max2) {
  return common$4.repeat(" ", max2 - string.length) + string;
}
function makeSnippet$1(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common$4.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$4.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common$4.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$e(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$e;
var YAMLException$2 = exception;
var Type$d = type;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof Type$d) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new YAMLException$2("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type2.multi) {
      throw new YAMLException$2("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var Type$c = type;
var str = new Type$c("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var Type$b = type;
var seq = new Type$b("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var Type$a = type;
var map = new Type$a("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var Schema = schema;
var failsafe = new Schema({
  explicit: [
    str,
    seq,
    map
  ]
});
var Type$9 = type;
function resolveYamlNull(data) {
  if (data === null) return true;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
var Type$8 = type;
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$8("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
var common$3 = common$5;
var Type$7 = type;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max2 = data.length, index = 0, hasDigits = false, ch;
  if (!max2) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max2) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max2; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign3 = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign3 = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign3 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign3 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign3 * parseInt(value.slice(2), 8);
  }
  return sign3 * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$3.isNegativeZero(object));
}
var int = new Type$7("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var common$2 = common$5;
var Type$6 = type;
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign3;
  value = data.replace(/_/g, "").toLowerCase();
  sign3 = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign3 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign3 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res2;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common$2.isNegativeZero(object)) {
    return "-0.0";
  }
  res2 = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$2.isNegativeZero(object));
}
var float = new Type$6("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var Type$5 = type;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new Type$5("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$4 = type;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type$4("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var Type$3 = type;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code2, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    code2 = map2.indexOf(data.charAt(idx));
    if (code2 > 64) continue;
    if (code2 < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max2 % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max2 % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new Type$3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$2 = type;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$1 = type;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys2, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1) return false;
    result[index] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys2, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys2 = Object.keys(pair);
    result[index] = [keys2[0], pair[keys2[0]]];
  }
  return result;
}
var pairs = new Type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type = type;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var common$1 = common$5;
var YAMLException$1 = exception;
var makeSnippet = snippet;
var DEFAULT_SCHEMA$1 = _default;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || DEFAULT_SCHEMA$1;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state2, message) {
  var mark = {
    name: state2.filename,
    buffer: state2.input.slice(0, -1),
    // omit trailing \0
    position: state2.position,
    line: state2.line,
    column: state2.position - state2.lineStart
  };
  mark.snippet = makeSnippet(mark);
  return new YAMLException$1(message, mark);
}
function throwError(state2, message) {
  throw generateError(state2, message);
}
function throwWarning(state2, message) {
  if (state2.onWarning) {
    state2.onWarning.call(null, generateError(state2, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state2, name, args) {
    var match, major2, minor2;
    if (state2.version !== null) {
      throwError(state2, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state2, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state2, "ill-formed argument of the YAML directive");
    }
    major2 = parseInt(match[1], 10);
    minor2 = parseInt(match[2], 10);
    if (major2 !== 1) {
      throwError(state2, "unacceptable YAML version of the document");
    }
    state2.version = args[0];
    state2.checkLineBreaks = minor2 < 2;
    if (minor2 !== 1 && minor2 !== 2) {
      throwWarning(state2, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state2, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state2, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state2, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state2.tagMap, handle)) {
      throwError(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state2, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err2) {
      throwError(state2, "tag prefix is malformed: " + prefix);
    }
    state2.tagMap[handle] = prefix;
  }
};
function captureSegment(state2, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state2.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state2, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state2, "the stream contains non-printable characters");
    }
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common$1.isObject(source)) {
    throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state2, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state2, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state2, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state2.line = startLine || state2.line;
      state2.lineStart = startLineStart || state2.lineStart;
      state2.position = startPos || state2.position;
      throwError(state2, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 10) {
    state2.position++;
  } else if (ch === 13) {
    state2.position++;
    if (state2.input.charCodeAt(state2.position) === 10) {
      state2.position++;
    }
  } else {
    throwError(state2, "a line break is expected");
  }
  state2.line += 1;
  state2.lineStart = state2.position;
  state2.firstTabInLine = -1;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state2.firstTabInLine === -1) {
        state2.firstTabInLine = state2.position;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state2);
      ch = state2.input.charCodeAt(state2.position);
      lineBreaks++;
      state2.lineIndent = 0;
      while (ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
    throwWarning(state2, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  ch = state2.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state2.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state2, count) {
  if (count === 1) {
    state2.result += " ";
  } else if (count > 1) {
    state2.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state2.input.charCodeAt(state2.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state2.kind = "scalar";
  state2.result = "";
  captureStart = captureEnd = state2.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state2.input.charCodeAt(state2.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state2.line;
      _lineStart = state2.lineStart;
      _lineIndent = state2.lineIndent;
      skipSeparationSpace(state2, false, -1);
      if (state2.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state2.input.charCodeAt(state2.position);
        continue;
      } else {
        state2.position = captureEnd;
        state2.line = _line;
        state2.lineStart = _lineStart;
        state2.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state2, captureStart, captureEnd, false);
      writeFoldedLines(state2, state2.line - _line);
      captureStart = captureEnd = state2.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state2.position + 1;
    }
    ch = state2.input.charCodeAt(++state2.position);
  }
  captureSegment(state2, captureStart, captureEnd, false);
  if (state2.result) {
    return true;
  }
  state2.kind = _kind;
  state2.result = _result;
  return false;
}
function readSingleQuotedScalar(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 39) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (ch === 39) {
        captureStart = state2.position;
        state2.position++;
        captureEnd = state2.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a single quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 34) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state2, captureStart, state2.position, true);
      state2.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state2, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state2.result += simpleEscapeMap[ch];
        state2.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state2.input.charCodeAt(++state2.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state2, "expected hexadecimal character");
          }
        }
        state2.result += charFromCodepoint(hexResult);
        state2.position++;
      } else {
        throwError(state2, "unknown escape sequence");
      }
      captureStart = captureEnd = state2.position;
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a double quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state2, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator2, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 91) {
    terminator2 = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator2 = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(++state2.position);
  while (ch !== 0) {
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === terminator2) {
      state2.position++;
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = isMapping ? "mapping" : "sequence";
      state2.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state2, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state2, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state2.position++;
        skipSeparationSpace(state2, true, nodeIndent);
      }
    }
    _line = state2.line;
    _lineStart = state2.lineStart;
    _pos = state2.position;
    composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state2.tag;
    keyNode = state2.result;
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if ((isExplicitPair || state2.line === _line) && ch === 58) {
      isPair = true;
      ch = state2.input.charCodeAt(++state2.position);
      skipSeparationSpace(state2, true, nodeIndent);
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state2.result;
    }
    if (isMapping) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 44) {
      readNext = true;
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      readNext = false;
    }
  }
  throwError(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  while (ch !== 0) {
    ch = state2.input.charCodeAt(++state2.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state2, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state2, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state2);
    state2.lineIndent = 0;
    ch = state2.input.charCodeAt(state2.position);
    while ((!detectedIndent || state2.lineIndent < textIndent) && ch === 32) {
      state2.lineIndent++;
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (!detectedIndent && state2.lineIndent > textIndent) {
      textIndent = state2.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state2.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state2.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state2.result += " ";
        }
      } else {
        state2.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state2.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, state2.position, false);
  }
  return true;
}
function readBlockSequence(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state2.input.charCodeAt(state2.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state2.position++;
    if (skipSeparationSpace(state2, true, -1)) {
      if (state2.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state2.input.charCodeAt(state2.position);
        continue;
      }
    }
    _line = state2.line;
    composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state2.result);
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a sequence entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "sequence";
    state2.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (!atExplicitKey && state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    following = state2.input.charCodeAt(state2.position + 1);
    _line = state2.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state2.position += 1;
      ch = following;
    } else {
      _keyLine = state2.line;
      _keyLineStart = state2.lineStart;
      _keyPos = state2.position;
      if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state2.line === _line) {
        ch = state2.input.charCodeAt(state2.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        if (ch === 58) {
          ch = state2.input.charCodeAt(++state2.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state2, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state2.tag;
          keyNode = state2.result;
        } else if (detected) {
          throwError(state2, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state2.tag = _tag;
        state2.anchor = _anchor;
        return true;
      }
    }
    if (state2.line === _line || state2.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
      }
      if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state2.result;
        } else {
          valueNode = state2.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
    }
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a mapping entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "mapping";
    state2.result = _result;
  }
  return detected;
}
function readTagProperty(state2) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 33) return false;
  if (state2.tag !== null) {
    throwError(state2, "duplication of a tag property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state2.input.charCodeAt(++state2.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state2.input.charCodeAt(++state2.position);
  } else {
    tagHandle = "!";
  }
  _position = state2.position;
  if (isVerbatim) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (ch !== 0 && ch !== 62);
    if (state2.position < state2.length) {
      tagName = state2.input.slice(_position, state2.position);
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      throwError(state2, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state2.input.slice(_position - 1, state2.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state2, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state2.position + 1;
        } else {
          throwError(state2, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    tagName = state2.input.slice(_position, state2.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state2, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state2, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err2) {
    throwError(state2, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state2.tag = tagName;
  } else if (_hasOwnProperty$1.call(state2.tagMap, tagHandle)) {
    state2.tag = state2.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state2.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state2.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state2, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state2) {
  var _position, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 38) return false;
  if (state2.anchor !== null) {
    throwError(state2, "duplication of an anchor property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an anchor node must contain at least one character");
  }
  state2.anchor = state2.input.slice(_position, state2.position);
  return true;
}
function readAlias(state2) {
  var _position, alias, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 42) return false;
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an alias node must contain at least one character");
  }
  alias = state2.input.slice(_position, state2.position);
  if (!_hasOwnProperty$1.call(state2.anchorMap, alias)) {
    throwError(state2, 'unidentified alias "' + alias + '"');
  }
  state2.result = state2.anchorMap[alias];
  skipSeparationSpace(state2, true, -1);
  return true;
}
function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state2.listener !== null) {
    state2.listener("open", state2);
  }
  state2.tag = null;
  state2.anchor = null;
  state2.kind = null;
  state2.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state2, true, -1)) {
      atNewLine = true;
      if (state2.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state2.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state2.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state2) || readAnchorProperty(state2)) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state2.position - state2.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state2)) {
          hasContent = true;
          if (state2.tag !== null || state2.anchor !== null) {
            throwError(state2, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state2.tag === null) {
            state2.tag = "?";
          }
        }
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
    }
  }
  if (state2.tag === null) {
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = state2.result;
    }
  } else if (state2.tag === "?") {
    if (state2.result !== null && state2.kind !== "scalar") {
      throwError(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state2.implicitTypes[typeIndex];
      if (type2.resolve(state2.result)) {
        state2.result = type2.construct(state2.result);
        state2.tag = type2.tag;
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
        break;
      }
    }
  } else if (state2.tag !== "!") {
    if (_hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
      type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
    } else {
      type2 = null;
      typeList = state2.typeMap.multi[state2.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state2, "unknown tag !<" + state2.tag + ">");
    }
    if (state2.result !== null && type2.kind !== state2.kind) {
      throwError(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"');
    }
    if (!type2.resolve(state2.result, state2.tag)) {
      throwError(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
    } else {
      state2.result = type2.construct(state2.result, state2.tag);
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    }
  }
  if (state2.listener !== null) {
    state2.listener("close", state2);
  }
  return state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state2.version = null;
  state2.checkLineBreaks = state2.legacy;
  state2.tagMap = /* @__PURE__ */ Object.create(null);
  state2.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if (state2.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    directiveName = state2.input.slice(_position, state2.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state2, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    if (ch !== 0) readLineBreak(state2);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state2, directiveName, directiveArgs);
    } else {
      throwWarning(state2, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state2, true, -1);
  if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
    state2.position += 3;
    skipSeparationSpace(state2, true, -1);
  } else if (hasDirectives) {
    throwError(state2, "directives end mark is expected");
  }
  composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state2, true, -1);
  if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
    throwWarning(state2, "non-ASCII line breaks are interpreted as content");
  }
  state2.documents.push(state2.result);
  if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    if (state2.input.charCodeAt(state2.position) === 46) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    }
    return;
  }
  if (state2.position < state2.length - 1) {
    throwError(state2, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state2 = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state2.position = nullpos;
    throwError(state2, "null byte is not allowed in input");
  }
  state2.input += "\0";
  while (state2.input.charCodeAt(state2.position) === 32) {
    state2.lineIndent += 1;
    state2.position += 1;
  }
  while (state2.position < state2.length - 1) {
    readDocument(state2);
  }
  return state2.documents;
}
function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
loader$1.loadAll = loadAll;
loader$1.load = load;
var dumper$1 = {};
var common = common$5;
var YAMLException = exception;
var DEFAULT_SCHEMA = _default;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys2, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys2 = Object.keys(map2);
  for (index = 0, length = keys2.length; index < length; index += 1) {
    tag = keys2[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || DEFAULT_SCHEMA;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state2, level) {
  return "\n" + common.repeat(" ", state2.indent * level);
}
function testImplicitResolving(state2, str2) {
  var index, length, type2;
  for (index = 0, length = state2.implicitTypes.length; index < length; index += 1) {
    type2 = state2.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state2, string, level, iskey, inblock) {
  state2.dump = function() {
    if (string.length === 0) {
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state2.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state2.indent * Math.max(1, level);
    var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
    var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state2, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state2.indent,
      lineWidth,
      testAmbiguity,
      state2.quotingType,
      state2.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state2, level, object) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index), value);
    }
    if (writeNode(state2, level, value, false, false) || typeof value === "undefined" && writeNode(state2, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state2.condenseFlow ? " " : "");
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = "[" + _result + "]";
}
function writeBlockSequence(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index), value);
    }
    if (writeNode(state2, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state2, level);
      }
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = _result || "[]";
}
function writeFlowMapping(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state2.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level, objectKey, false, false)) {
      continue;
    }
    if (state2.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
    if (!writeNode(state2, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = "{" + _result + "}";
}
function writeBlockMapping(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state2.sortKeys === "function") {
    objectKeyList.sort(state2.sortKeys);
  } else if (state2.sortKeys) {
    throw new YAMLException("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state2, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024;
    if (explicitPair) {
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state2.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state2, level);
    }
    if (!writeNode(state2, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = _result || "{}";
}
function detectType(state2, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state2.tag = type2.representName(object);
        } else {
          state2.tag = type2.tag;
        }
      } else {
        state2.tag = "?";
      }
      if (type2.represent) {
        style = state2.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state2.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state2, level, object, block, compact, iskey, isblockseq) {
  state2.tag = null;
  state2.dump = object;
  if (!detectType(state2, object, false)) {
    detectType(state2, object, true);
  }
  var type2 = _toString.call(state2.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state2.flowLevel < 0 || state2.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state2.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state2.tag !== null && state2.tag !== "?" || duplicate || state2.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state2.usedDuplicates[duplicateIndex]) {
    state2.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state2.usedDuplicates[duplicateIndex]) {
      state2.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state2.dump).length !== 0) {
        writeBlockMapping(state2, level, state2.dump, compact);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowMapping(state2, level, state2.dump);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state2.dump.length !== 0) {
        if (state2.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state2, level - 1, state2.dump, compact);
        } else {
          writeBlockSequence(state2, level, state2.dump, compact);
        }
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowSequence(state2, level, state2.dump);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state2.tag !== "?") {
        writeScalar(state2, state2.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state2.skipInvalid) return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state2.tag !== null && state2.tag !== "?") {
      tagStr = encodeURI(
        state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
      ).replace(/!/g, "%21");
      if (state2.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state2.dump = tagStr + " " + state2.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state2) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state2.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state2 = new State(options);
  if (!state2.noRefs) getDuplicateReferences(input, state2);
  var value = input;
  if (state2.replacer) {
    value = state2.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state2, 0, value, true, true)) return state2.dump + "\n";
  return "";
}
dumper$1.dump = dump;
var loader = loader$1;
var dumper = dumper$1;
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
jsYaml.Type = type;
jsYaml.Schema = schema;
jsYaml.FAILSAFE_SCHEMA = failsafe;
jsYaml.JSON_SCHEMA = json;
jsYaml.CORE_SCHEMA = core;
jsYaml.DEFAULT_SCHEMA = _default;
jsYaml.load = loader.load;
jsYaml.loadAll = loader.loadAll;
jsYaml.dump = dumper.dump;
jsYaml.YAMLException = exception;
jsYaml.types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
jsYaml.safeLoad = renamed("safeLoad", "load");
jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml.safeDump = renamed("safeDump", "dump");
var main = {};
Object.defineProperty(main, "__esModule", { value: true });
main.Lazy = void 0;
class Lazy {
  constructor(creator) {
    this._value = null;
    this.creator = creator;
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) {
      return this._value;
    }
    const result = this.creator();
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
    this.creator = null;
  }
}
main.Lazy = Lazy;
var DownloadedUpdateHelper$1 = {};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values2) {
    var index = -1, length = values2.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values2[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values2) {
    var index = -1, length = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values2[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if (hasOwnProperty2.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
Object.defineProperty(DownloadedUpdateHelper$1, "__esModule", { value: true });
DownloadedUpdateHelper$1.DownloadedUpdateHelper = void 0;
DownloadedUpdateHelper$1.createTempUpdateFile = createTempUpdateFile;
const crypto_1$2 = require$$0$c;
const fs_1$4 = fs$k;
const isEqual = lodash_isequalExports;
const fs_extra_1$6 = lib;
const path$8 = path$n;
class DownloadedUpdateHelper {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    this._downloadedFileInfo = null;
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return path$8.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
      if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await (0, fs_extra_1$6.pathExists)(updateFile)) {
        return updateFile;
      } else {
        return null;
      }
    }
    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
    if (cachedUpdateFile === null) {
      return null;
    }
    logger.info(`Update has already been downloaded to ${updateFile}).`);
    this._file = cachedUpdateFile;
    return cachedUpdateFile;
  }
  async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
    this._file = downloadedFile;
    this._packageFile = packageFile;
    this.versionInfo = versionInfo;
    this.fileInfo = fileInfo;
    this._downloadedFileInfo = {
      fileName: updateFileName,
      sha512: fileInfo.info.sha512,
      isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
    };
    if (isSaveCache) {
      await (0, fs_extra_1$6.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
    }
  }
  async clear() {
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, fs_extra_1$6.emptyDir)(this.cacheDirForPendingUpdate);
    } catch (_ignore) {
    }
  }
  /**
   * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
   * @param fileInfo
   * @param logger
   */
  async getValidCachedUpdateFile(fileInfo, logger) {
    const updateInfoFilePath = this.getUpdateInfoFile();
    const doesUpdateInfoFileExist = await (0, fs_extra_1$6.pathExists)(updateInfoFilePath);
    if (!doesUpdateInfoFileExist) {
      return null;
    }
    let cachedInfo;
    try {
      cachedInfo = await (0, fs_extra_1$6.readJson)(updateInfoFilePath);
    } catch (error2) {
      let message = `No cached update info available`;
      if (error2.code !== "ENOENT") {
        await this.cleanCacheDirForPendingUpdate();
        message += ` (error on read: ${error2.message})`;
      }
      logger.info(message);
      return null;
    }
    const isCachedInfoFileNameValid = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null;
    if (!isCachedInfoFileNameValid) {
      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    if (fileInfo.info.sha512 !== cachedInfo.sha512) {
      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    const updateFile = path$8.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
    if (!await (0, fs_extra_1$6.pathExists)(updateFile)) {
      logger.info("Cached update file doesn't exist");
      return null;
    }
    const sha512 = await hashFile(updateFile);
    if (fileInfo.info.sha512 !== sha512) {
      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    this._downloadedFileInfo = cachedInfo;
    return updateFile;
  }
  getUpdateInfoFile() {
    return path$8.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
DownloadedUpdateHelper$1.DownloadedUpdateHelper = DownloadedUpdateHelper;
function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
  return new Promise((resolve2, reject) => {
    const hash = (0, crypto_1$2.createHash)(algorithm);
    hash.on("error", reject).setEncoding(encoding);
    (0, fs_1$4.createReadStream)(file2, {
      ...options,
      highWaterMark: 1024 * 1024
      /* better to use more memory but hash faster */
    }).on("error", reject).on("end", () => {
      hash.end();
      resolve2(hash.read());
    }).pipe(hash, { end: false });
  });
}
async function createTempUpdateFile(name, cacheDir, log) {
  let nameCounter = 0;
  let result = path$8.join(cacheDir, name);
  for (let i = 0; i < 3; i++) {
    try {
      await (0, fs_extra_1$6.unlink)(result);
      return result;
    } catch (e) {
      if (e.code === "ENOENT") {
        return result;
      }
      log.warn(`Error on remove temp update file: ${e}`);
      result = path$8.join(cacheDir, `${nameCounter++}-${name}`);
    }
  }
  return result;
}
var ElectronAppAdapter$1 = {};
var AppAdapter = {};
Object.defineProperty(AppAdapter, "__esModule", { value: true });
AppAdapter.getAppCacheDir = getAppCacheDir;
const path$7 = path$n;
const os_1$1 = require$$2$2;
function getAppCacheDir() {
  const homedir = (0, os_1$1.homedir)();
  let result;
  if (process.platform === "win32") {
    result = process.env["LOCALAPPDATA"] || path$7.join(homedir, "AppData", "Local");
  } else if (process.platform === "darwin") {
    result = path$7.join(homedir, "Library", "Caches");
  } else {
    result = process.env["XDG_CACHE_HOME"] || path$7.join(homedir, ".cache");
  }
  return result;
}
Object.defineProperty(ElectronAppAdapter$1, "__esModule", { value: true });
ElectronAppAdapter$1.ElectronAppAdapter = void 0;
const path$6 = path$n;
const AppAdapter_1 = AppAdapter;
class ElectronAppAdapter {
  constructor(app2 = require$$1$6.app) {
    this.app = app2;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === true;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? path$6.join(process.resourcesPath, "app-update.yml") : path$6.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return (0, AppAdapter_1.getAppCacheDir)();
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(handler) {
    this.app.once("quit", (_, exitCode) => handler(exitCode));
  }
}
ElectronAppAdapter$1.ElectronAppAdapter = ElectronAppAdapter;
var electronHttpExecutor = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElectronHttpExecutor = exports.NET_SESSION_NAME = void 0;
  exports.getNetSession = getNetSession;
  const builder_util_runtime_12 = out;
  exports.NET_SESSION_NAME = "electron-updater";
  function getNetSession() {
    return require$$1$6.session.fromPartition(exports.NET_SESSION_NAME, {
      cache: false
    });
  }
  class ElectronHttpExecutor extends builder_util_runtime_12.HttpExecutor {
    constructor(proxyLoginCallback) {
      super();
      this.proxyLoginCallback = proxyLoginCallback;
      this.cachedSession = null;
    }
    async download(url2, destination, options) {
      return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
        const requestOptions = {
          headers: options.headers || void 0,
          redirect: "manual"
        };
        (0, builder_util_runtime_12.configureRequestUrl)(url2, requestOptions);
        (0, builder_util_runtime_12.configureRequestOptions)(requestOptions);
        this.doDownload(requestOptions, {
          destination,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve2(destination);
            } else {
              reject(error2);
            }
          },
          responseHandler: null
        }, 0);
      });
    }
    createRequest(options, callback) {
      if (options.headers && options.headers.Host) {
        options.host = options.headers.Host;
        delete options.headers.Host;
      }
      if (this.cachedSession == null) {
        this.cachedSession = getNetSession();
      }
      const request2 = require$$1$6.net.request({
        ...options,
        session: this.cachedSession
      });
      request2.on("response", callback);
      if (this.proxyLoginCallback != null) {
        request2.on("login", this.proxyLoginCallback);
      }
      return request2;
    }
    addRedirectHandlers(request2, options, reject, redirectCount, handler) {
      request2.on("redirect", (statusCode, method, redirectUrl) => {
        request2.abort();
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
        } else {
          handler(builder_util_runtime_12.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        }
      });
    }
  }
  exports.ElectronHttpExecutor = ElectronHttpExecutor;
})(electronHttpExecutor);
var GenericProvider$1 = {};
var util = {};
var symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString3(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp$1(string) {
  string = toString3(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp$1;
Object.defineProperty(util, "__esModule", { value: true });
util.newBaseUrl = newBaseUrl;
util.newUrlFromBase = newUrlFromBase;
util.getChannelFilename = getChannelFilename;
util.blockmapFiles = blockmapFiles;
const url_1$4 = require$$0$5;
const escapeRegExp = lodash_escaperegexp;
function newBaseUrl(url2) {
  const result = new url_1$4.URL(url2);
  if (!result.pathname.endsWith("/")) {
    result.pathname += "/";
  }
  return result;
}
function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
  const result = new url_1$4.URL(pathname, baseUrl);
  const search = baseUrl.search;
  if (search != null && search.length !== 0) {
    result.search = search;
  } else if (addRandomQueryToAvoidCaching) {
    result.search = `noCache=${Date.now().toString(32)}`;
  }
  return result;
}
function getChannelFilename(channel) {
  return `${channel}.yml`;
}
function blockmapFiles(baseUrl, oldVersion, newVersion) {
  const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
  const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
  return [oldBlockMapUrl, newBlockMapUrl];
}
var Provider$1 = {};
Object.defineProperty(Provider$1, "__esModule", { value: true });
Provider$1.Provider = void 0;
Provider$1.findFile = findFile;
Provider$1.parseUpdateInfo = parseUpdateInfo;
Provider$1.getFileList = getFileList;
Provider$1.resolveFiles = resolveFiles;
const builder_util_runtime_1$e = out;
const js_yaml_1$2 = jsYaml;
const util_1$6 = util;
class Provider {
  constructor(runtimeOptions) {
    this.runtimeOptions = runtimeOptions;
    this.requestHeaders = null;
    this.executor = runtimeOptions.executor;
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== false;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
      const archSuffix = arch === "x64" ? "" : `-${arch}`;
      return "-linux" + archSuffix;
    } else {
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
    }
  }
  // due to historical reasons for windows we use channel name without platform specifier
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(channel) {
    return `${channel}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  /**
   * Method to perform API request only to resolve update info, but not to download update.
   */
  httpRequest(url2, headers2, cancellationToken) {
    return this.executor.request(this.createRequestOptions(url2, headers2), cancellationToken);
  }
  createRequestOptions(url2, headers2) {
    const result = {};
    if (this.requestHeaders == null) {
      if (headers2 != null) {
        result.headers = headers2;
      }
    } else {
      result.headers = headers2 == null ? this.requestHeaders : { ...this.requestHeaders, ...headers2 };
    }
    (0, builder_util_runtime_1$e.configureRequestUrl)(url2, result);
    return result;
  }
}
Provider$1.Provider = Provider;
function findFile(files, extension, not2) {
  if (files.length === 0) {
    throw (0, builder_util_runtime_1$e.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
  if (result != null) {
    return result;
  } else if (not2 == null) {
    return files[0];
  } else {
    return files.find((fileInfo) => !not2.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
  }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
  if (rawData == null) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  let result;
  try {
    result = (0, js_yaml_1$2.load)(rawData);
  } catch (e) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  return result;
}
function getFileList(updateInfo) {
  const files = updateInfo.files;
  if (files != null && files.length > 0) {
    return files;
  }
  if (updateInfo.path != null) {
    return [
      {
        url: updateInfo.path,
        sha2: updateInfo.sha2,
        sha512: updateInfo.sha512
      }
    ];
  } else {
    throw (0, builder_util_runtime_1$e.newError)(`No files provided: ${(0, builder_util_runtime_1$e.safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
  }
}
function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
  const files = getFileList(updateInfo);
  const result = files.map((fileInfo) => {
    if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
      throw (0, builder_util_runtime_1$e.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1$e.safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
    }
    return {
      url: (0, util_1$6.newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
      info: fileInfo
    };
  });
  const packages = updateInfo.packages;
  const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
  if (packageInfo != null) {
    result[0].packageInfo = {
      ...packageInfo,
      path: (0, util_1$6.newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href
    };
  }
  return result;
}
Object.defineProperty(GenericProvider$1, "__esModule", { value: true });
GenericProvider$1.GenericProvider = void 0;
const builder_util_runtime_1$d = out;
const util_1$5 = util;
const Provider_1$a = Provider$1;
class GenericProvider extends Provider_1$a.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(runtimeOptions);
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = (0, util_1$5.newBaseUrl)(this.configuration.url);
  }
  get channel() {
    const result = this.updater.channel || this.configuration.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
    const channelFile = (0, util_1$5.getChannelFilename)(this.channel);
    const channelUrl = (0, util_1$5.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return (0, Provider_1$a.parseUpdateInfo)(await this.httpRequest(channelUrl), channelFile, channelUrl);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$d.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$d.newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        } else if (e.code === "ECONNREFUSED") {
          if (attemptNumber < 3) {
            await new Promise((resolve2, reject) => {
              try {
                setTimeout(resolve2, 1e3 * attemptNumber);
              } catch (e2) {
                reject(e2);
              }
            });
            continue;
          }
        }
        throw e;
      }
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$a.resolveFiles)(updateInfo, this.baseUrl);
  }
}
GenericProvider$1.GenericProvider = GenericProvider;
var providerFactory = {};
var BitbucketProvider$1 = {};
Object.defineProperty(BitbucketProvider$1, "__esModule", { value: true });
BitbucketProvider$1.BitbucketProvider = void 0;
const builder_util_runtime_1$c = out;
const util_1$4 = util;
const Provider_1$9 = Provider$1;
class BitbucketProvider extends Provider_1$9.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super({
      ...runtimeOptions,
      isUseMultipleRangeRequest: false
    });
    this.configuration = configuration;
    this.updater = updater;
    const { owner, slug } = configuration;
    this.baseUrl = (0, util_1$4.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$c.CancellationToken();
    const channelFile = (0, util_1$4.getChannelFilename)(this.getCustomChannelName(this.channel));
    const channelUrl = (0, util_1$4.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, void 0, cancellationToken);
      return (0, Provider_1$9.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw (0, builder_util_runtime_1$c.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$9.resolveFiles)(updateInfo, this.baseUrl);
  }
  toString() {
    const { owner, slug } = this.configuration;
    return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;
  }
}
BitbucketProvider$1.BitbucketProvider = BitbucketProvider;
var GitHubProvider$1 = {};
Object.defineProperty(GitHubProvider$1, "__esModule", { value: true });
GitHubProvider$1.GitHubProvider = GitHubProvider$1.BaseGitHubProvider = void 0;
GitHubProvider$1.computeReleaseNotes = computeReleaseNotes;
const builder_util_runtime_1$b = out;
const semver = semver$1;
const url_1$3 = require$$0$5;
const util_1$3 = util;
const Provider_1$8 = Provider$1;
const hrefRegExp = /\/tag\/([^/]+)$/;
class BaseGitHubProvider extends Provider_1$8.Provider {
  constructor(options, defaultHost, runtimeOptions) {
    super({
      ...runtimeOptions,
      /* because GitHib uses S3 */
      isUseMultipleRangeRequest: false
    });
    this.options = options;
    this.baseUrl = (0, util_1$3.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, defaultHost));
    const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
    this.baseApiUrl = (0, util_1$3.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, apiHost));
  }
  computeGithubBasePath(result) {
    const host = this.options.host;
    return host && !["github.com", "api.github.com"].includes(host) ? `/api/v3${result}` : result;
  }
}
GitHubProvider$1.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
  constructor(options, updater, runtimeOptions) {
    super(options, "github.com", runtimeOptions);
    this.options = options;
    this.updater = updater;
  }
  get channel() {
    const result = this.updater.channel || this.options.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
    var _a2, _b, _c, _d, _e;
    const cancellationToken = new builder_util_runtime_1$b.CancellationToken();
    const feedXml = await this.httpRequest((0, util_1$3.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, cancellationToken);
    const feed = (0, builder_util_runtime_1$b.parseXml)(feedXml);
    let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
    let tag = null;
    try {
      if (this.updater.allowPrerelease) {
        const currentChannel = ((_a2 = this.updater) === null || _a2 === void 0 ? void 0 : _a2.channel) || ((_b = semver.prerelease(this.updater.currentVersion)) === null || _b === void 0 ? void 0 : _b[0]) || null;
        if (currentChannel === null) {
          tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
        } else {
          for (const element of feed.getElements("entry")) {
            const hrefElement = hrefRegExp.exec(element.element("link").attribute("href"));
            if (hrefElement === null)
              continue;
            const hrefTag = hrefElement[1];
            const hrefChannel = ((_c = semver.prerelease(hrefTag)) === null || _c === void 0 ? void 0 : _c[0]) || null;
            const shouldFetchVersion = !currentChannel || ["alpha", "beta"].includes(currentChannel);
            const isCustomChannel = hrefChannel !== null && !["alpha", "beta"].includes(String(hrefChannel));
            const channelMismatch = currentChannel === "beta" && hrefChannel === "alpha";
            if (shouldFetchVersion && !isCustomChannel && !channelMismatch) {
              tag = hrefTag;
              break;
            }
            const isNextPreRelease = hrefChannel && hrefChannel === currentChannel;
            if (isNextPreRelease) {
              tag = hrefTag;
              break;
            }
          }
        }
      } else {
        tag = await this.getLatestTagName(cancellationToken);
        for (const element of feed.getElements("entry")) {
          if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
            latestRelease = element;
            break;
          }
        }
      }
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Cannot parse releases feed: ${e.stack || e.message},
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
    if (tag == null) {
      throw (0, builder_util_runtime_1$b.newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    }
    let rawData;
    let channelFile = "";
    let channelFileUrl = "";
    const fetchData = async (channelName) => {
      channelFile = (0, util_1$3.getChannelFilename)(channelName);
      channelFileUrl = (0, util_1$3.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);
      const requestOptions = this.createRequestOptions(channelFileUrl);
      try {
        return await this.executor.request(requestOptions, cancellationToken);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$b.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$b.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        throw e;
      }
    };
    try {
      let channel = this.channel;
      if (this.updater.allowPrerelease && ((_d = semver.prerelease(tag)) === null || _d === void 0 ? void 0 : _d[0])) {
        channel = this.getCustomChannelName(String((_e = semver.prerelease(tag)) === null || _e === void 0 ? void 0 : _e[0]));
      }
      rawData = await fetchData(channel);
    } catch (e) {
      if (this.updater.allowPrerelease) {
        rawData = await fetchData(this.getDefaultChannelName());
      } else {
        throw e;
      }
    }
    const result = (0, Provider_1$8.parseUpdateInfo)(rawData, channelFile, channelFileUrl);
    if (result.releaseName == null) {
      result.releaseName = latestRelease.elementValueOrEmpty("title");
    }
    if (result.releaseNotes == null) {
      result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
    }
    return {
      tag,
      ...result
    };
  }
  async getLatestTagName(cancellationToken) {
    const options = this.options;
    const url2 = options.host == null || options.host === "github.com" ? (0, util_1$3.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1$3.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const rawData = await this.httpRequest(url2, { Accept: "application/json" }, cancellationToken);
      if (rawData == null) {
        return null;
      }
      const releaseInfo = JSON.parse(rawData);
      return releaseInfo.tag_name;
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Unable to find latest version on GitHub (${url2}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$8.resolveFiles)(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
  }
  getBaseDownloadPath(tag, fileName) {
    return `${this.basePath}/download/${tag}/${fileName}`;
  }
}
GitHubProvider$1.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
  const result = parent.elementValueOrEmpty("content");
  return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
  if (!isFullChangelog) {
    return getNoteValue(latestRelease);
  }
  const releaseNotes = [];
  for (const release of feed.getElements("entry")) {
    const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
    if (semver.lt(currentVersion, versionRelease)) {
      releaseNotes.push({
        version: versionRelease,
        note: getNoteValue(release)
      });
    }
  }
  return releaseNotes.sort((a, b) => semver.rcompare(a.version, b.version));
}
var KeygenProvider$1 = {};
Object.defineProperty(KeygenProvider$1, "__esModule", { value: true });
KeygenProvider$1.KeygenProvider = void 0;
const builder_util_runtime_1$a = out;
const util_1$2 = util;
const Provider_1$7 = Provider$1;
class KeygenProvider extends Provider_1$7.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super({
      ...runtimeOptions,
      isUseMultipleRangeRequest: false
    });
    this.configuration = configuration;
    this.updater = updater;
    this.defaultHostname = "api.keygen.sh";
    const host = this.configuration.host || this.defaultHostname;
    this.baseUrl = (0, util_1$2.newBaseUrl)(`https://${host}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$a.CancellationToken();
    const channelFile = (0, util_1$2.getChannelFilename)(this.getCustomChannelName(this.channel));
    const channelUrl = (0, util_1$2.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, {
        Accept: "application/vnd.api+json",
        "Keygen-Version": "1.1"
      }, cancellationToken);
      return (0, Provider_1$7.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw (0, builder_util_runtime_1$a.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$7.resolveFiles)(updateInfo, this.baseUrl);
  }
  toString() {
    const { account, product, platform: platform2 } = this.configuration;
    return `Keygen (account: ${account}, product: ${product}, platform: ${platform2}, channel: ${this.channel})`;
  }
}
KeygenProvider$1.KeygenProvider = KeygenProvider;
var PrivateGitHubProvider$1 = {};
Object.defineProperty(PrivateGitHubProvider$1, "__esModule", { value: true });
PrivateGitHubProvider$1.PrivateGitHubProvider = void 0;
const builder_util_runtime_1$9 = out;
const js_yaml_1$1 = jsYaml;
const path$5 = path$n;
const url_1$2 = require$$0$5;
const util_1$1 = util;
const GitHubProvider_1$1 = GitHubProvider$1;
const Provider_1$6 = Provider$1;
class PrivateGitHubProvider extends GitHubProvider_1$1.BaseGitHubProvider {
  constructor(options, updater, token, runtimeOptions) {
    super(options, "api.github.com", runtimeOptions);
    this.updater = updater;
    this.token = token;
  }
  createRequestOptions(url2, headers2) {
    const result = super.createRequestOptions(url2, headers2);
    result.redirect = "manual";
    return result;
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$9.CancellationToken();
    const channelFile = (0, util_1$1.getChannelFilename)(this.getDefaultChannelName());
    const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
    const asset = releaseInfo.assets.find((it) => it.name === channelFile);
    if (asset == null) {
      throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    }
    const url2 = new url_1$2.URL(asset.url);
    let result;
    try {
      result = (0, js_yaml_1$1.load)(await this.httpRequest(url2, this.configureHeaders("application/octet-stream"), cancellationToken));
    } catch (e) {
      if (e instanceof builder_util_runtime_1$9.HttpError && e.statusCode === 404) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the latest release artifacts (${url2}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    result.assets = releaseInfo.assets;
    return result;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(accept) {
    return {
      accept,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(cancellationToken) {
    const allowPrerelease = this.updater.allowPrerelease;
    let basePath = this.basePath;
    if (!allowPrerelease) {
      basePath = `${basePath}/latest`;
    }
    const url2 = (0, util_1$1.newUrlFromBase)(basePath, this.baseUrl);
    try {
      const version2 = JSON.parse(await this.httpRequest(url2, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
      if (allowPrerelease) {
        return version2.find((it) => it.prerelease) || version2[0];
      } else {
        return version2;
      }
    } catch (e) {
      throw (0, builder_util_runtime_1$9.newError)(`Unable to find latest version on GitHub (${url2}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$6.getFileList)(updateInfo).map((it) => {
      const name = path$5.posix.basename(it.url).replace(/ /g, "-");
      const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
      if (asset == null) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      }
      return {
        url: new url_1$2.URL(asset.url),
        info: it
      };
    });
  }
}
PrivateGitHubProvider$1.PrivateGitHubProvider = PrivateGitHubProvider;
Object.defineProperty(providerFactory, "__esModule", { value: true });
providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
providerFactory.createClient = createClient;
const builder_util_runtime_1$8 = out;
const BitbucketProvider_1 = BitbucketProvider$1;
const GenericProvider_1$1 = GenericProvider$1;
const GitHubProvider_1 = GitHubProvider$1;
const KeygenProvider_1 = KeygenProvider$1;
const PrivateGitHubProvider_1 = PrivateGitHubProvider$1;
function isUrlProbablySupportMultiRangeRequests(url2) {
  return !url2.includes("s3.amazonaws.com");
}
function createClient(data, updater, runtimeOptions) {
  if (typeof data === "string") {
    throw (0, builder_util_runtime_1$8.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  }
  const provider = data.provider;
  switch (provider) {
    case "github": {
      const githubOptions = data;
      const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
      if (token == null) {
        return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
      } else {
        return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
      }
    }
    case "bitbucket":
      return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);
    case "keygen":
      return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
    case "s3":
    case "spaces":
      return new GenericProvider_1$1.GenericProvider({
        provider: "generic",
        url: (0, builder_util_runtime_1$8.getS3LikeProviderBaseUrl)(data),
        channel: data.channel || null
      }, updater, {
        ...runtimeOptions,
        // https://github.com/minio/minio/issues/5285#issuecomment-350428955
        isUseMultipleRangeRequest: false
      });
    case "generic": {
      const options = data;
      return new GenericProvider_1$1.GenericProvider(options, updater, {
        ...runtimeOptions,
        isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
      });
    }
    case "custom": {
      const options = data;
      const constructor = options.updateProvider;
      if (!constructor) {
        throw (0, builder_util_runtime_1$8.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      }
      return new constructor(options, updater, runtimeOptions);
    }
    default:
      throw (0, builder_util_runtime_1$8.newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
var GenericDifferentialDownloader$1 = {};
var DifferentialDownloader$1 = {};
var DataSplitter$1 = {};
var downloadPlanBuilder = {};
Object.defineProperty(downloadPlanBuilder, "__esModule", { value: true });
downloadPlanBuilder.OperationKind = void 0;
downloadPlanBuilder.computeOperations = computeOperations;
var OperationKind$1;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind$1 || (downloadPlanBuilder.OperationKind = OperationKind$1 = {}));
function computeOperations(oldBlockMap, newBlockMap, logger) {
  const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
  const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
  let lastOperation = null;
  const blockMapFile = newBlockMap.files[0];
  const operations = [];
  const name = blockMapFile.name;
  const oldEntry = nameToOldBlocks.get(name);
  if (oldEntry == null) {
    throw new Error(`no file ${name} in old blockmap`);
  }
  const newFile = nameToNewBlocks.get(name);
  let changedBlockCount = 0;
  const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
  let newOffset = blockMapFile.offset;
  for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
    const blockSize = newFile.sizes[i];
    const checksum = newFile.checksums[i];
    let oldOffset = checksumToOldOffset.get(checksum);
    if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
      logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
      oldOffset = void 0;
    }
    if (oldOffset === void 0) {
      changedBlockCount++;
      if (lastOperation != null && lastOperation.kind === OperationKind$1.DOWNLOAD && lastOperation.end === newOffset) {
        lastOperation.end += blockSize;
      } else {
        lastOperation = {
          kind: OperationKind$1.DOWNLOAD,
          start: newOffset,
          end: newOffset + blockSize
          // oldBlocks: null,
        };
        validateAndAdd(lastOperation, operations, checksum, i);
      }
    } else {
      if (lastOperation != null && lastOperation.kind === OperationKind$1.COPY && lastOperation.end === oldOffset) {
        lastOperation.end += blockSize;
      } else {
        lastOperation = {
          kind: OperationKind$1.COPY,
          start: oldOffset,
          end: oldOffset + blockSize
          // oldBlocks: [checksum]
        };
        validateAndAdd(lastOperation, operations, checksum, i);
      }
    }
  }
  if (changedBlockCount > 0) {
    logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
  }
  return operations;
}
const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
function validateAndAdd(operation, operations, checksum, index) {
  if (isValidateOperationRange && operations.length !== 0) {
    const lastOperation = operations[operations.length - 1];
    if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
      const min2 = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
      throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind$1[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min2} until ${lastOperation.end - min2} and ${operation.start - min2} until ${operation.end - min2}`);
    }
  }
  operations.push(operation);
}
function buildChecksumMap(file2, fileOffset, logger) {
  const checksumToOffset = /* @__PURE__ */ new Map();
  const checksumToSize = /* @__PURE__ */ new Map();
  let offset = fileOffset;
  for (let i = 0; i < file2.checksums.length; i++) {
    const checksum = file2.checksums[i];
    const size = file2.sizes[i];
    const existing = checksumToSize.get(checksum);
    if (existing === void 0) {
      checksumToOffset.set(checksum, offset);
      checksumToSize.set(checksum, size);
    } else if (logger.debug != null) {
      const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
      logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    offset += size;
  }
  return { checksumToOffset, checksumToOldSize: checksumToSize };
}
function buildBlockFileMap(list) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    result.set(item.name, item);
  }
  return result;
}
Object.defineProperty(DataSplitter$1, "__esModule", { value: true });
DataSplitter$1.DataSplitter = void 0;
DataSplitter$1.copyData = copyData;
const builder_util_runtime_1$7 = out;
const fs_1$3 = fs$k;
const stream_1$1 = stream;
const downloadPlanBuilder_1$2 = downloadPlanBuilder;
const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function(ReadState2) {
  ReadState2[ReadState2["INIT"] = 0] = "INIT";
  ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
  ReadState2[ReadState2["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out2, oldFileFd, reject, resolve2) {
  const readStream2 = (0, fs_1$3.createReadStream)("", {
    fd: oldFileFd,
    autoClose: false,
    start: task.start,
    // end is inclusive
    end: task.end - 1
  });
  readStream2.on("error", reject);
  readStream2.once("end", resolve2);
  readStream2.pipe(out2, {
    end: false
  });
}
class DataSplitter extends stream_1$1.Writable {
  constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
    super();
    this.out = out2;
    this.options = options;
    this.partIndexToTaskIndex = partIndexToTaskIndex;
    this.partIndexToLength = partIndexToLength;
    this.finishHandler = finishHandler;
    this.partIndex = -1;
    this.headerListBuffer = null;
    this.readState = ReadState.INIT;
    this.ignoreByteCount = 0;
    this.remainingPartDataCount = 0;
    this.actualPartLength = 0;
    this.boundaryLength = boundary.length + 4;
    this.ignoreByteCount = this.boundaryLength - 2;
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  // noinspection JSUnusedGlobalSymbols
  _write(data, encoding, callback) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${data.length} bytes`);
      return;
    }
    this.handleData(data).then(callback).catch(callback);
  }
  async handleData(chunk) {
    let start = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
      throw (0, builder_util_runtime_1$7.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    }
    if (this.ignoreByteCount > 0) {
      const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
      this.ignoreByteCount -= toIgnore;
      start = toIgnore;
    } else if (this.remainingPartDataCount > 0) {
      const toRead = Math.min(this.remainingPartDataCount, chunk.length);
      this.remainingPartDataCount -= toRead;
      await this.processPartData(chunk, 0, toRead);
      start = toRead;
    }
    if (start === chunk.length) {
      return;
    }
    if (this.readState === ReadState.HEADER) {
      const headerListEnd = this.searchHeaderListEnd(chunk, start);
      if (headerListEnd === -1) {
        return;
      }
      start = headerListEnd;
      this.readState = ReadState.BODY;
      this.headerListBuffer = null;
    }
    while (true) {
      if (this.readState === ReadState.BODY) {
        this.readState = ReadState.INIT;
      } else {
        this.partIndex++;
        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
        if (taskIndex == null) {
          if (this.isFinished) {
            taskIndex = this.options.end;
          } else {
            throw (0, builder_util_runtime_1$7.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          }
        }
        const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
        if (prevTaskIndex < taskIndex) {
          await this.copyExistingData(prevTaskIndex, taskIndex);
        } else if (prevTaskIndex > taskIndex) {
          throw (0, builder_util_runtime_1$7.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
        }
        if (this.isFinished) {
          this.onPartEnd();
          this.finishHandler();
          return;
        }
        start = this.searchHeaderListEnd(chunk, start);
        if (start === -1) {
          this.readState = ReadState.HEADER;
          return;
        }
      }
      const partLength = this.partIndexToLength[this.partIndex];
      const end = start + partLength;
      const effectiveEnd = Math.min(end, chunk.length);
      await this.processPartStarted(chunk, start, effectiveEnd);
      this.remainingPartDataCount = partLength - (effectiveEnd - start);
      if (this.remainingPartDataCount > 0) {
        return;
      }
      start = end + this.boundaryLength;
      if (start >= chunk.length) {
        this.ignoreByteCount = this.boundaryLength - (chunk.length - end);
        return;
      }
    }
  }
  copyExistingData(index, end) {
    return new Promise((resolve2, reject) => {
      const w = () => {
        if (index === end) {
          resolve2();
          return;
        }
        const task = this.options.tasks[index];
        if (task.kind !== downloadPlanBuilder_1$2.OperationKind.COPY) {
          reject(new Error("Task kind must be COPY"));
          return;
        }
        copyData(task, this.out, this.options.oldFileFd, reject, () => {
          index++;
          w();
        });
      };
      w();
    });
  }
  searchHeaderListEnd(chunk, readOffset) {
    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
    if (headerListEnd !== -1) {
      return headerListEnd + DOUBLE_CRLF.length;
    }
    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
    if (this.headerListBuffer == null) {
      this.headerListBuffer = partialChunk;
    } else {
      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
    }
    return -1;
  }
  onPartEnd() {
    const expectedLength = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== expectedLength) {
      throw (0, builder_util_runtime_1$7.newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    }
    this.actualPartLength = 0;
  }
  processPartStarted(data, start, end) {
    if (this.partIndex !== 0) {
      this.onPartEnd();
    }
    return this.processPartData(data, start, end);
  }
  processPartData(data, start, end) {
    this.actualPartLength += end - start;
    const out2 = this.out;
    if (out2.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2, reject) => {
        out2.on("error", reject);
        out2.once("drain", () => {
          out2.removeListener("error", reject);
          resolve2();
        });
      });
    }
  }
}
DataSplitter$1.DataSplitter = DataSplitter;
var multipleRangeDownloader = {};
Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
const builder_util_runtime_1$6 = out;
const DataSplitter_1$1 = DataSplitter$1;
const downloadPlanBuilder_1$1 = downloadPlanBuilder;
function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
  const w = (taskOffset) => {
    if (taskOffset >= tasks.length) {
      if (differentialDownloader.fileMetadataBuffer != null) {
        out2.write(differentialDownloader.fileMetadataBuffer);
      }
      out2.end();
      return;
    }
    const nextOffset = taskOffset + 1e3;
    doExecuteTasks(differentialDownloader, {
      tasks,
      start: taskOffset,
      end: Math.min(tasks.length, nextOffset),
      oldFileFd
    }, out2, () => w(nextOffset), reject);
  };
  return w;
}
function doExecuteTasks(differentialDownloader, options, out2, resolve2, reject) {
  let ranges = "bytes=";
  let partCount = 0;
  const partIndexToTaskIndex = /* @__PURE__ */ new Map();
  const partIndexToLength = [];
  for (let i = options.start; i < options.end; i++) {
    const task = options.tasks[i];
    if (task.kind === downloadPlanBuilder_1$1.OperationKind.DOWNLOAD) {
      ranges += `${task.start}-${task.end - 1}, `;
      partIndexToTaskIndex.set(partCount, i);
      partCount++;
      partIndexToLength.push(task.end - task.start);
    }
  }
  if (partCount <= 1) {
    const w = (index) => {
      if (index >= options.end) {
        resolve2();
        return;
      }
      const task = options.tasks[index++];
      if (task.kind === downloadPlanBuilder_1$1.OperationKind.COPY) {
        (0, DataSplitter_1$1.copyData)(task, out2, options.oldFileFd, reject, () => w(index));
      } else {
        const requestOptions2 = differentialDownloader.createRequestOptions();
        requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
        const request3 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response2) => {
          if (!checkIsRangesSupported(response2, reject)) {
            return;
          }
          response2.pipe(out2, {
            end: false
          });
          response2.once("end", () => w(index));
        });
        differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request3, reject);
        request3.end();
      }
    };
    w(options.start);
    return;
  }
  const requestOptions = differentialDownloader.createRequestOptions();
  requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
  const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions, (response2) => {
    if (!checkIsRangesSupported(response2, reject)) {
      return;
    }
    const contentType = (0, builder_util_runtime_1$6.safeGetHeader)(response2, "content-type");
    const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
    if (m == null) {
      reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
      return;
    }
    const dicer = new DataSplitter_1$1.DataSplitter(out2, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve2);
    dicer.on("error", reject);
    response2.pipe(dicer);
    response2.on("end", () => {
      setTimeout(() => {
        request2.abort();
        reject(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
  request2.end();
}
function checkIsRangesSupported(response2, reject) {
  if (response2.statusCode >= 400) {
    reject((0, builder_util_runtime_1$6.createHttpError)(response2));
    return false;
  }
  if (response2.statusCode !== 206) {
    const acceptRanges = (0, builder_util_runtime_1$6.safeGetHeader)(response2, "accept-ranges");
    if (acceptRanges == null || acceptRanges === "none") {
      reject(new Error(`Server doesn't support Accept-Ranges (response code ${response2.statusCode})`));
      return false;
    }
  }
  return true;
}
var ProgressDifferentialDownloadCallbackTransform$1 = {};
Object.defineProperty(ProgressDifferentialDownloadCallbackTransform$1, "__esModule", { value: true });
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = void 0;
const stream_1 = stream;
var OperationKind;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (OperationKind = {}));
class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
  constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
    super();
    this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.expectedBytes = 0;
    this.index = 0;
    this.operationType = OperationKind.COPY;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == OperationKind.COPY) {
      callback(null, chunk);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now2 = Date.now();
    if (now2 >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.nextUpdate = now2 + 1e3;
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((now2 - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  beginFileCopy() {
    this.operationType = OperationKind.COPY;
  }
  beginRangeDownload() {
    this.operationType = OperationKind.DOWNLOAD;
    this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
    }
  }
  // Called when we are 100% done with the connection/download
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    this.transferred = 0;
    callback(null);
  }
}
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;
Object.defineProperty(DifferentialDownloader$1, "__esModule", { value: true });
DifferentialDownloader$1.DifferentialDownloader = void 0;
const builder_util_runtime_1$5 = out;
const fs_extra_1$5 = lib;
const fs_1$2 = fs$k;
const DataSplitter_1 = DataSplitter$1;
const url_1$1 = require$$0$5;
const downloadPlanBuilder_1 = downloadPlanBuilder;
const multipleRangeDownloader_1 = multipleRangeDownloader;
const ProgressDifferentialDownloadCallbackTransform_1 = ProgressDifferentialDownloadCallbackTransform$1;
class DifferentialDownloader {
  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
  constructor(blockAwareFileInfo, httpExecutor2, options) {
    this.blockAwareFileInfo = blockAwareFileInfo;
    this.httpExecutor = httpExecutor2;
    this.options = options;
    this.fileMetadataBuffer = null;
    this.logger = options.logger;
  }
  createRequestOptions() {
    const result = {
      headers: {
        ...this.options.requestHeaders,
        accept: "*/*"
      }
    };
    (0, builder_util_runtime_1$5.configureRequestUrl)(this.options.newUrl, result);
    (0, builder_util_runtime_1$5.configureRequestOptions)(result);
    return result;
  }
  doDownload(oldBlockMap, newBlockMap) {
    if (oldBlockMap.version !== newBlockMap.version) {
      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
    }
    const logger = this.logger;
    const operations = (0, downloadPlanBuilder_1.computeOperations)(oldBlockMap, newBlockMap, logger);
    if (logger.debug != null) {
      logger.debug(JSON.stringify(operations, null, 2));
    }
    let downloadSize = 0;
    let copySize = 0;
    for (const operation of operations) {
      const length = operation.end - operation.start;
      if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        downloadSize += length;
      } else {
        copySize += length;
      }
    }
    const newSize = this.blockAwareFileInfo.size;
    if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
    }
    logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
    return this.downloadFile(operations);
  }
  downloadFile(tasks) {
    const fdList = [];
    const closeFiles = () => {
      return Promise.all(fdList.map((openedFile) => {
        return (0, fs_extra_1$5.close)(openedFile.descriptor).catch((e) => {
          this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
        });
      }));
    };
    return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
      return closeFiles().catch((closeFilesError) => {
        try {
          this.logger.error(`cannot close files: ${closeFilesError}`);
        } catch (errorOnLog) {
          try {
            console.error(errorOnLog);
          } catch (_ignored) {
          }
        }
        throw e;
      }).then(() => {
        throw e;
      });
    });
  }
  async doDownloadFile(tasks, fdList) {
    const oldFileFd = await (0, fs_extra_1$5.open)(this.options.oldFile, "r");
    fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
    const newFileFd = await (0, fs_extra_1$5.open)(this.options.newFile, "w");
    fdList.push({ descriptor: newFileFd, path: this.options.newFile });
    const fileOut = (0, fs_1$2.createWriteStream)(this.options.newFile, { fd: newFileFd });
    await new Promise((resolve2, reject) => {
      const streams = [];
      let downloadInfoTransform = void 0;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const expectedByteCounts = [];
        let grandTotalBytes = 0;
        for (const task of tasks) {
          if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
            expectedByteCounts.push(task.end - task.start);
            grandTotalBytes += task.end - task.start;
          }
        }
        const progressDifferentialDownloadInfo = {
          expectedByteCounts,
          grandTotal: grandTotalBytes
        };
        downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
        streams.push(downloadInfoTransform);
      }
      const digestTransform = new builder_util_runtime_1$5.DigestTransform(this.blockAwareFileInfo.sha512);
      digestTransform.isValidateOnEnd = false;
      streams.push(digestTransform);
      fileOut.on("finish", () => {
        fileOut.close(() => {
          fdList.splice(1, 1);
          try {
            digestTransform.validate();
          } catch (e) {
            reject(e);
            return;
          }
          resolve2(void 0);
        });
      });
      streams.push(fileOut);
      let lastStream = null;
      for (const stream2 of streams) {
        stream2.on("error", reject);
        if (lastStream == null) {
          lastStream = stream2;
        } else {
          lastStream = lastStream.pipe(stream2);
        }
      }
      const firstStream = streams[0];
      let w;
      if (this.options.isUseMultipleRangeRequest) {
        w = (0, multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests)(this, tasks, firstStream, oldFileFd, reject);
        w(0);
        return;
      }
      let downloadOperationCount = 0;
      let actualUrl = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const requestOptions = this.createRequestOptions();
      requestOptions.redirect = "manual";
      w = (index) => {
        var _a2, _b;
        if (index >= tasks.length) {
          if (this.fileMetadataBuffer != null) {
            firstStream.write(this.fileMetadataBuffer);
          }
          firstStream.end();
          return;
        }
        const operation = tasks[index++];
        if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          if (downloadInfoTransform) {
            downloadInfoTransform.beginFileCopy();
          }
          (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w(index));
          return;
        }
        const range2 = `bytes=${operation.start}-${operation.end - 1}`;
        requestOptions.headers.range = range2;
        (_b = (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.debug) === null || _b === void 0 ? void 0 : _b.call(_a2, `download range: ${range2}`);
        if (downloadInfoTransform) {
          downloadInfoTransform.beginRangeDownload();
        }
        const request2 = this.httpExecutor.createRequest(requestOptions, (response2) => {
          response2.on("error", reject);
          response2.on("aborted", () => {
            reject(new Error("response has been aborted by the server"));
          });
          if (response2.statusCode >= 400) {
            reject((0, builder_util_runtime_1$5.createHttpError)(response2));
          }
          response2.pipe(firstStream, {
            end: false
          });
          response2.once("end", () => {
            if (downloadInfoTransform) {
              downloadInfoTransform.endRangeDownload();
            }
            if (++downloadOperationCount === 100) {
              downloadOperationCount = 0;
              setTimeout(() => w(index), 1e3);
            } else {
              w(index);
            }
          });
        });
        request2.on("redirect", (statusCode, method, redirectUrl) => {
          this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
          actualUrl = redirectUrl;
          (0, builder_util_runtime_1$5.configureRequestUrl)(new url_1$1.URL(actualUrl), requestOptions);
          request2.followRedirect();
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
        request2.end();
      };
      w(0);
    });
  }
  async readRemoteBytes(start, endInclusive) {
    const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
    const requestOptions = this.createRequestOptions();
    requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
    let position = 0;
    await this.request(requestOptions, (chunk) => {
      chunk.copy(buffer, position);
      position += chunk.length;
    });
    if (position !== buffer.length) {
      throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);
    }
    return buffer;
  }
  request(requestOptions, dataHandler) {
    return new Promise((resolve2, reject) => {
      const request2 = this.httpExecutor.createRequest(requestOptions, (response2) => {
        if (!(0, multipleRangeDownloader_1.checkIsRangesSupported)(response2, reject)) {
          return;
        }
        response2.on("error", reject);
        response2.on("aborted", () => {
          reject(new Error("response has been aborted by the server"));
        });
        response2.on("data", dataHandler);
        response2.on("end", () => resolve2());
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
      request2.end();
    });
  }
}
DifferentialDownloader$1.DifferentialDownloader = DifferentialDownloader;
function formatBytes(value, symbol = " KB") {
  return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function removeQuery(url2) {
  const index = url2.indexOf("?");
  return index < 0 ? url2 : url2.substring(0, index);
}
Object.defineProperty(GenericDifferentialDownloader$1, "__esModule", { value: true });
GenericDifferentialDownloader$1.GenericDifferentialDownloader = void 0;
const DifferentialDownloader_1$1 = DifferentialDownloader$1;
class GenericDifferentialDownloader extends DifferentialDownloader_1$1.DifferentialDownloader {
  download(oldBlockMap, newBlockMap) {
    return this.doDownload(oldBlockMap, newBlockMap);
  }
}
GenericDifferentialDownloader$1.GenericDifferentialDownloader = GenericDifferentialDownloader;
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.CancellationToken = void 0;
  exports.addHandler = addHandler;
  const builder_util_runtime_12 = out;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return builder_util_runtime_12.CancellationToken;
  } });
  exports.DOWNLOAD_PROGRESS = "download-progress";
  exports.UPDATE_DOWNLOADED = "update-downloaded";
  class UpdaterSignal {
    constructor(emitter) {
      this.emitter = emitter;
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(handler) {
      addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
      addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
      addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
      addHandler(this.emitter, "update-cancelled", handler);
    }
  }
  exports.UpdaterSignal = UpdaterSignal;
  function addHandler(emitter, event, handler) {
    {
      emitter.on(event, handler);
    }
  }
})(types);
Object.defineProperty(AppUpdater$1, "__esModule", { value: true });
AppUpdater$1.NoOpLogger = AppUpdater$1.AppUpdater = void 0;
const builder_util_runtime_1$4 = out;
const crypto_1$1 = require$$0$c;
const os_1 = require$$2$2;
const events_1 = require$$1$3;
const fs_extra_1$4 = lib;
const js_yaml_1 = jsYaml;
const lazy_val_1 = main;
const path$4 = path$n;
const semver_1 = semver$1;
const DownloadedUpdateHelper_1 = DownloadedUpdateHelper$1;
const ElectronAppAdapter_1 = ElectronAppAdapter$1;
const electronHttpExecutor_1 = electronHttpExecutor;
const GenericProvider_1 = GenericProvider$1;
const providerFactory_1 = providerFactory;
const zlib_1$1 = zlib;
const util_1 = util;
const GenericDifferentialDownloader_1 = GenericDifferentialDownloader$1;
const types_1$5 = types;
class AppUpdater extends events_1.EventEmitter {
  /**
   * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
   */
  get channel() {
    return this._channel;
  }
  /**
   * Set the update channel. Overrides `channel` in the update configuration.
   *
   * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
   */
  set channel(value) {
    if (this._channel != null) {
      if (typeof value !== "string") {
        throw (0, builder_util_runtime_1$4.newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
      } else if (value.length === 0) {
        throw (0, builder_util_runtime_1$4.newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
      }
    }
    this._channel = value;
    this.allowDowngrade = true;
  }
  /**
   *  Shortcut for explicitly adding auth tokens to request headers
   */
  addAuthHeader(token) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: token
    });
  }
  // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  get netSession() {
    return (0, electronHttpExecutor_1.getNetSession)();
  }
  /**
   * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
   * Set it to `null` if you would like to disable a logging feature.
   */
  get logger() {
    return this._logger;
  }
  set logger(value) {
    this._logger = value == null ? new NoOpLogger() : value;
  }
  // noinspection JSUnusedGlobalSymbols
  /**
   * test only
   * @private
   */
  set updateConfigPath(value) {
    this.clientPromise = null;
    this._appUpdateConfigPath = value;
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
  }
  /**
   * Allows developer to override default logic for determining if an update is supported.
   * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
   */
  get isUpdateSupported() {
    return this._isUpdateSupported;
  }
  set isUpdateSupported(value) {
    if (value) {
      this._isUpdateSupported = value;
    }
  }
  constructor(options, app2) {
    super();
    this.autoDownload = true;
    this.autoInstallOnAppQuit = true;
    this.autoRunAppAfterInstall = true;
    this.allowPrerelease = false;
    this.fullChangelog = false;
    this.allowDowngrade = false;
    this.disableWebInstaller = false;
    this.disableDifferentialDownload = false;
    this.forceDevUpdateConfig = false;
    this._channel = null;
    this.downloadedUpdateHelper = null;
    this.requestHeaders = null;
    this._logger = console;
    this.signals = new types_1$5.UpdaterSignal(this);
    this._appUpdateConfigPath = null;
    this._isUpdateSupported = (updateInfo) => this.checkIfUpdateSupported(updateInfo);
    this.clientPromise = null;
    this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    this.checkForUpdatesPromise = null;
    this.downloadPromise = null;
    this.updateInfoAndProvider = null;
    this._testOnlyOptions = null;
    this.on("error", (error2) => {
      this._logger.error(`Error: ${error2.stack || error2.message}`);
    });
    if (app2 == null) {
      this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
      this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
    } else {
      this.app = app2;
      this.httpExecutor = null;
    }
    const currentVersionString = this.app.version;
    const currentVersion = (0, semver_1.parse)(currentVersionString);
    if (currentVersion == null) {
      throw (0, builder_util_runtime_1$4.newError)(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    this.currentVersion = currentVersion;
    this.allowPrerelease = hasPrereleaseComponents(currentVersion);
    if (options != null) {
      this.setFeedURL(options);
      if (typeof options !== "string" && options.requestHeaders) {
        this.requestHeaders = options.requestHeaders;
      }
    }
  }
  //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  /**
   * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
   * @param options If you want to override configuration in the `app-update.yml`.
   */
  setFeedURL(options) {
    const runtimeOptions = this.createProviderRuntimeOptions();
    let provider;
    if (typeof options === "string") {
      provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, {
        ...runtimeOptions,
        isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)
      });
    } else {
      provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);
    }
    this.clientPromise = Promise.resolve(provider);
  }
  /**
   * Asks the server whether there is an update.
   * @returns null if the updater is disabled, otherwise info about the latest version
   */
  checkForUpdates() {
    if (!this.isUpdaterActive()) {
      return Promise.resolve(null);
    }
    let checkForUpdatesPromise = this.checkForUpdatesPromise;
    if (checkForUpdatesPromise != null) {
      this._logger.info("Checking for update (already in progress)");
      return checkForUpdatesPromise;
    }
    const nullizePromise = () => this.checkForUpdatesPromise = null;
    this._logger.info("Checking for update");
    checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
      nullizePromise();
      return it;
    }).catch((e) => {
      nullizePromise();
      this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
      throw e;
    });
    this.checkForUpdatesPromise = checkForUpdatesPromise;
    return checkForUpdatesPromise;
  }
  isUpdaterActive() {
    const isEnabled = this.app.isPackaged || this.forceDevUpdateConfig;
    if (!isEnabled) {
      this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced");
      return false;
    }
    return true;
  }
  // noinspection JSUnusedGlobalSymbols
  checkForUpdatesAndNotify(downloadNotification) {
    return this.checkForUpdates().then((it) => {
      if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {
        if (this._logger.debug != null) {
          this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
        }
        return it;
      }
      void it.downloadPromise.then(() => {
        const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
        new require$$1$6.Notification(notificationContent).show();
      });
      return it;
    });
  }
  static formatDownloadNotification(version2, appName, downloadNotification) {
    if (downloadNotification == null) {
      downloadNotification = {
        title: "A new update is ready to install",
        body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
      };
    }
    downloadNotification = {
      title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version2),
      body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version2)
    };
    return downloadNotification;
  }
  async isStagingMatch(updateInfo) {
    const rawStagingPercentage = updateInfo.stagingPercentage;
    let stagingPercentage = rawStagingPercentage;
    if (stagingPercentage == null) {
      return true;
    }
    stagingPercentage = parseInt(stagingPercentage, 10);
    if (isNaN(stagingPercentage)) {
      this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
      return true;
    }
    stagingPercentage = stagingPercentage / 100;
    const stagingUserId = await this.stagingUserIdPromise.value;
    const val = builder_util_runtime_1$4.UUID.parse(stagingUserId).readUInt32BE(12);
    const percentage = val / 4294967295;
    this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
    return percentage < stagingPercentage;
  }
  computeFinalHeaders(headers2) {
    if (this.requestHeaders != null) {
      Object.assign(headers2, this.requestHeaders);
    }
    return headers2;
  }
  async isUpdateAvailable(updateInfo) {
    const latestVersion = (0, semver_1.parse)(updateInfo.version);
    if (latestVersion == null) {
      throw (0, builder_util_runtime_1$4.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    const currentVersion = this.currentVersion;
    if ((0, semver_1.eq)(latestVersion, currentVersion)) {
      return false;
    }
    if (!await Promise.resolve(this.isUpdateSupported(updateInfo))) {
      return false;
    }
    const isStagingMatch = await this.isStagingMatch(updateInfo);
    if (!isStagingMatch) {
      return false;
    }
    const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);
    const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);
    if (isLatestVersionNewer) {
      return true;
    }
    return this.allowDowngrade && isLatestVersionOlder;
  }
  checkIfUpdateSupported(updateInfo) {
    const minimumSystemVersion = updateInfo === null || updateInfo === void 0 ? void 0 : updateInfo.minimumSystemVersion;
    const currentOSVersion = (0, os_1.release)();
    if (minimumSystemVersion) {
      try {
        if ((0, semver_1.lt)(currentOSVersion, minimumSystemVersion)) {
          this._logger.info(`Current OS version ${currentOSVersion} is less than the minimum OS version required ${minimumSystemVersion} for version ${currentOSVersion}`);
          return false;
        }
      } catch (e) {
        this._logger.warn(`Failed to compare current OS version(${currentOSVersion}) with minimum OS version(${minimumSystemVersion}): ${(e.message || e).toString()}`);
      }
    }
    return true;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady();
    if (this.clientPromise == null) {
      this.clientPromise = this.configOnDisk.value.then((it) => (0, providerFactory_1.createClient)(it, this, this.createProviderRuntimeOptions()));
    }
    const client = await this.clientPromise;
    const stagingUserId = await this.stagingUserIdPromise.value;
    client.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
    return {
      info: await client.getLatestVersion(),
      provider: client
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: true,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const result = await this.getUpdateInfoAndProvider();
    const updateInfo = result.info;
    if (!await this.isUpdateAvailable(updateInfo)) {
      this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
      this.emit("update-not-available", updateInfo);
      return {
        isUpdateAvailable: false,
        versionInfo: updateInfo,
        updateInfo
      };
    }
    this.updateInfoAndProvider = result;
    this.onUpdateAvailable(updateInfo);
    const cancellationToken = new builder_util_runtime_1$4.CancellationToken();
    return {
      isUpdateAvailable: true,
      versionInfo: updateInfo,
      updateInfo,
      cancellationToken,
      downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
    };
  }
  onUpdateAvailable(updateInfo) {
    this._logger.info(`Found version ${updateInfo.version} (url: ${(0, builder_util_runtime_1$4.asArray)(updateInfo.files).map((it) => it.url).join(", ")})`);
    this.emit("update-available", updateInfo);
  }
  /**
   * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
   * @returns {Promise<Array<string>>} Paths to downloaded files.
   */
  downloadUpdate(cancellationToken = new builder_util_runtime_1$4.CancellationToken()) {
    const updateInfoAndProvider = this.updateInfoAndProvider;
    if (updateInfoAndProvider == null) {
      const error2 = new Error("Please check update first");
      this.dispatchError(error2);
      return Promise.reject(error2);
    }
    if (this.downloadPromise != null) {
      this._logger.info("Downloading update (already in progress)");
      return this.downloadPromise;
    }
    this._logger.info(`Downloading update from ${(0, builder_util_runtime_1$4.asArray)(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
    const errorHandler2 = (e) => {
      if (!(e instanceof builder_util_runtime_1$4.CancellationError)) {
        try {
          this.dispatchError(e);
        } catch (nestedError) {
          this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
        }
      }
      return e;
    };
    this.downloadPromise = this.doDownloadUpdate({
      updateInfoAndProvider,
      requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
      cancellationToken,
      disableWebInstaller: this.disableWebInstaller,
      disableDifferentialDownload: this.disableDifferentialDownload
    }).catch((e) => {
      throw errorHandler2(e);
    }).finally(() => {
      this.downloadPromise = null;
    });
    return this.downloadPromise;
  }
  dispatchError(e) {
    this.emit("error", e, (e.stack || e).toString());
  }
  dispatchUpdateDownloaded(event) {
    this.emit(types_1$5.UPDATE_DOWNLOADED, event);
  }
  async loadUpdateConfig() {
    if (this._appUpdateConfigPath == null) {
      this._appUpdateConfigPath = this.app.appUpdateConfigPath;
    }
    return (0, js_yaml_1.load)(await (0, fs_extra_1$4.readFile)(this._appUpdateConfigPath, "utf-8"));
  }
  computeRequestHeaders(provider) {
    const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
    if (fileExtraDownloadHeaders != null) {
      const requestHeaders = this.requestHeaders;
      return requestHeaders == null ? fileExtraDownloadHeaders : {
        ...fileExtraDownloadHeaders,
        ...requestHeaders
      };
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const file2 = path$4.join(this.app.userDataPath, ".updaterId");
    try {
      const id3 = await (0, fs_extra_1$4.readFile)(file2, "utf-8");
      if (builder_util_runtime_1$4.UUID.check(id3)) {
        return id3;
      } else {
        this._logger.warn(`Staging user id file exists, but content was invalid: ${id3}`);
      }
    } catch (e) {
      if (e.code !== "ENOENT") {
        this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
      }
    }
    const id2 = builder_util_runtime_1$4.UUID.v5((0, crypto_1$1.randomBytes)(4096), builder_util_runtime_1$4.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${id2}`);
    try {
      await (0, fs_extra_1$4.outputFile)(file2, id2);
    } catch (e) {
      this._logger.warn(`Couldn't write out staging user ID: ${e}`);
    }
    return id2;
  }
  /** @internal */
  get isAddNoCacheQuery() {
    const headers2 = this.requestHeaders;
    if (headers2 == null) {
      return true;
    }
    for (const headerName of Object.keys(headers2)) {
      const s = headerName.toLowerCase();
      if (s === "authorization" || s === "private-token") {
        return false;
      }
    }
    return true;
  }
  async getOrCreateDownloadHelper() {
    let result = this.downloadedUpdateHelper;
    if (result == null) {
      const dirName = (await this.configOnDisk.value).updaterCacheDirName;
      const logger = this._logger;
      if (dirName == null) {
        logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      }
      const cacheDir = path$4.join(this.app.baseCachePath, dirName || this.app.name);
      if (logger.debug != null) {
        logger.debug(`updater cache dir: ${cacheDir}`);
      }
      result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
      this.downloadedUpdateHelper = result;
    }
    return result;
  }
  async executeDownload(taskOptions) {
    const fileInfo = taskOptions.fileInfo;
    const downloadOptions = {
      headers: taskOptions.downloadUpdateOptions.requestHeaders,
      cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
      sha2: fileInfo.info.sha2,
      sha512: fileInfo.info.sha512
    };
    if (this.listenerCount(types_1$5.DOWNLOAD_PROGRESS) > 0) {
      downloadOptions.onProgress = (it) => this.emit(types_1$5.DOWNLOAD_PROGRESS, it);
    }
    const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
    const version2 = updateInfo.version;
    const packageInfo = fileInfo.packageInfo;
    function getCacheUpdateFileName() {
      const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
      if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {
        return path$4.basename(urlPath);
      } else {
        return taskOptions.fileInfo.info.url;
      }
    }
    const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
    const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
    await (0, fs_extra_1$4.mkdir)(cacheDir, { recursive: true });
    const updateFileName = getCacheUpdateFileName();
    let updateFile = path$4.join(cacheDir, updateFileName);
    const packageFile = packageInfo == null ? null : path$4.join(cacheDir, `package-${version2}${path$4.extname(packageInfo.path) || ".7z"}`);
    const done = async (isSaveCache) => {
      await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
      await taskOptions.done({
        ...updateInfo,
        downloadedFile: updateFile
      });
      return packageFile == null ? [updateFile] : [updateFile, packageFile];
    };
    const log = this._logger;
    const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);
    if (cachedUpdateFile != null) {
      updateFile = cachedUpdateFile;
      return await done(false);
    }
    const removeFileIfAny = async () => {
      await downloadedUpdateHelper.clear().catch(() => {
      });
      return await (0, fs_extra_1$4.unlink)(updateFile).catch(() => {
      });
    };
    const tempUpdateFile = await (0, DownloadedUpdateHelper_1.createTempUpdateFile)(`temp-${updateFileName}`, cacheDir, log);
    try {
      await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
      await (0, builder_util_runtime_1$4.retry)(() => (0, fs_extra_1$4.rename)(tempUpdateFile, updateFile), 60, 500, 0, 0, (error2) => error2 instanceof Error && /^EBUSY:/.test(error2.message));
    } catch (e) {
      await removeFileIfAny();
      if (e instanceof builder_util_runtime_1$4.CancellationError) {
        log.info("cancelled");
        this.emit("update-cancelled", updateInfo);
      }
      throw e;
    }
    log.info(`New version ${version2} has been downloaded to ${updateFile}`);
    return await done(true);
  }
  async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider, oldInstallerFileName) {
    try {
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
        return true;
      }
      const blockmapFileUrls = (0, util_1.blockmapFiles)(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
      const downloadBlockMap = async (url2) => {
        const data = await this.httpExecutor.downloadToBuffer(url2, {
          headers: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        });
        if (data == null || data.length === 0) {
          throw new Error(`Blockmap "${url2.href}" is empty`);
        }
        try {
          return JSON.parse((0, zlib_1$1.gunzipSync)(data).toString());
        } catch (e) {
          throw new Error(`Cannot parse blockmap "${url2.href}", error: ${e}`);
        }
      };
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile: path$4.join(this.downloadedUpdateHelper.cacheDir, oldInstallerFileName),
        logger: this._logger,
        newFile: installerPath,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(types_1$5.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1$5.DOWNLOAD_PROGRESS, it);
      }
      const blockMapDataList = await Promise.all(blockmapFileUrls.map((u2) => downloadBlockMap(u2)));
      await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      if (this._testOnlyOptions != null) {
        throw e;
      }
      return true;
    }
  }
}
AppUpdater$1.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version2) {
  const versionPrereleaseComponent = (0, semver_1.prerelease)(version2);
  return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
class NoOpLogger {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  info(message) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  warn(message) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  error(message) {
  }
}
AppUpdater$1.NoOpLogger = NoOpLogger;
Object.defineProperty(BaseUpdater$1, "__esModule", { value: true });
BaseUpdater$1.BaseUpdater = void 0;
const child_process_1$3 = require$$1$7;
const AppUpdater_1$1 = AppUpdater$1;
class BaseUpdater extends AppUpdater_1$1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }
  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    this._logger.info(`Install on explicit quitAndInstall`);
    const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);
    if (isInstalled) {
      setImmediate(() => {
        require$$1$6.autoUpdater.emit("before-quit-for-update");
        this.app.quit();
      });
    } else {
      this.quitAndInstallCalled = false;
    }
  }
  executeDownload(taskOptions) {
    return super.executeDownload({
      ...taskOptions,
      done: (event) => {
        this.dispatchUpdateDownloaded(event);
        this.addQuitHandler();
        return Promise.resolve();
      }
    });
  }
  get installerPath() {
    return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
  }
  // must be sync (because quit even handler is not async)
  install(isSilent = false, isForceRunAfter = false) {
    if (this.quitAndInstallCalled) {
      this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
      return false;
    }
    const downloadedUpdateHelper = this.downloadedUpdateHelper;
    const installerPath = this.installerPath;
    const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
    if (installerPath == null || downloadedFileInfo == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    this.quitAndInstallCalled = true;
    try {
      this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);
      return this.doInstall({
        isSilent,
        isForceRunAfter,
        isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired
      });
    } catch (e) {
      this.dispatchError(e);
      return false;
    }
  }
  addQuitHandler() {
    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
      return;
    }
    this.quitHandlerAdded = true;
    this.app.onQuit((exitCode) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (exitCode !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
        return;
      }
      this._logger.info("Auto install update on quit");
      this.install(true, false);
    });
  }
  wrapSudo() {
    const { name } = this.app;
    const installComment = `"${name} would like to update"`;
    const sudo = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu");
    const command = [sudo];
    if (/kdesudo/i.test(sudo)) {
      command.push("--comment", installComment);
      command.push("-c");
    } else if (/gksudo/i.test(sudo)) {
      command.push("--message", installComment);
    } else if (/pkexec/i.test(sudo)) {
      command.push("--disable-internal-agent");
    }
    return command.join(" ");
  }
  spawnSyncLog(cmd, args = [], env = {}) {
    this._logger.info(`Executing: ${cmd} with args: ${args}`);
    const response2 = (0, child_process_1$3.spawnSync)(cmd, args, {
      env: { ...process.env, ...env },
      encoding: "utf-8",
      shell: true
    });
    const { error: error2, status, stdout, stderr } = response2;
    if (error2 != null) {
      this._logger.error(stderr);
      throw error2;
    } else if (status != null && status !== 0) {
      this._logger.error(stderr);
      throw new Error(`Command ${cmd} exited with code ${status}`);
    }
    return stdout.trim();
  }
  /**
   * This handles both node 8 and node 10 way of emitting error when spawning a process
   *   - node 8: Throws the error
   *   - node 10: Emit the error(Need to listen with on)
   */
  // https://github.com/electron-userland/electron-builder/issues/1129
  // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
  async spawnLog(cmd, args = [], env = void 0, stdio = "ignore") {
    this._logger.info(`Executing: ${cmd} with args: ${args}`);
    return new Promise((resolve2, reject) => {
      try {
        const params = { stdio, env, detached: true };
        const p = (0, child_process_1$3.spawn)(cmd, args, params);
        p.on("error", (error2) => {
          reject(error2);
        });
        p.unref();
        if (p.pid !== void 0) {
          resolve2(true);
        }
      } catch (error2) {
        reject(error2);
      }
    });
  }
}
BaseUpdater$1.BaseUpdater = BaseUpdater;
var AppImageUpdater$1 = {};
var FileWithEmbeddedBlockMapDifferentialDownloader$1 = {};
Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader$1, "__esModule", { value: true });
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const fs_extra_1$3 = lib;
const DifferentialDownloader_1 = DifferentialDownloader$1;
const zlib_1 = zlib;
class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
  async download() {
    const packageInfo = this.blockAwareFileInfo;
    const fileSize = packageInfo.size;
    const offset = fileSize - (packageInfo.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
    const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
  }
}
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;
function readBlockMap(data) {
  return JSON.parse((0, zlib_1.inflateRawSync)(data).toString());
}
async function readEmbeddedBlockMapData(file2) {
  const fd = await (0, fs_extra_1$3.open)(file2, "r");
  try {
    const fileSize = (await (0, fs_extra_1$3.fstat)(fd)).size;
    const sizeBuffer = Buffer.allocUnsafe(4);
    await (0, fs_extra_1$3.read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
    const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
    await (0, fs_extra_1$3.read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
    await (0, fs_extra_1$3.close)(fd);
    return readBlockMap(dataBuffer);
  } catch (e) {
    await (0, fs_extra_1$3.close)(fd);
    throw e;
  }
}
Object.defineProperty(AppImageUpdater$1, "__esModule", { value: true });
AppImageUpdater$1.AppImageUpdater = void 0;
const builder_util_runtime_1$3 = out;
const child_process_1$2 = require$$1$7;
const fs_extra_1$2 = lib;
const fs_1$1 = fs$k;
const path$3 = path$n;
const BaseUpdater_1$4 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1$1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const Provider_1$5 = Provider$1;
const types_1$4 = types;
class AppImageUpdater extends BaseUpdater_1$4.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  isUpdaterActive() {
    if (process.env["APPIMAGE"] == null) {
      if (process.env["SNAP"] == null) {
        this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
      } else {
        this._logger.info("SNAP env is defined, updater is disabled");
      }
      return false;
    }
    return super.isUpdaterActive();
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$5.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        const oldFile = process.env["APPIMAGE"];
        if (oldFile == null) {
          throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        if (downloadUpdateOptions.disableDifferentialDownload || await this.downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions)) {
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
        await (0, fs_extra_1$2.chmod)(updateFile, 493);
      }
    });
  }
  async downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions) {
    try {
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile,
        logger: this._logger,
        newFile: updateFile,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(types_1$4.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1$4.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1$1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download();
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "linux";
    }
  }
  doInstall(options) {
    const appImageFile = process.env["APPIMAGE"];
    if (appImageFile == null) {
      throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    }
    (0, fs_1$1.unlinkSync)(appImageFile);
    let destination;
    const existingBaseName = path$3.basename(appImageFile);
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    if (path$3.basename(installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
      destination = appImageFile;
    } else {
      destination = path$3.join(path$3.dirname(appImageFile), path$3.basename(installerPath));
    }
    (0, child_process_1$2.execFileSync)("mv", ["-f", installerPath, destination]);
    if (destination !== appImageFile) {
      this.emit("appimage-filename-updated", destination);
    }
    const env = {
      ...process.env,
      APPIMAGE_SILENT_INSTALL: "true"
    };
    if (options.isForceRunAfter) {
      this.spawnLog(destination, [], env);
    } else {
      env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
      (0, child_process_1$2.execFileSync)(destination, [], { env });
    }
    return true;
  }
}
AppImageUpdater$1.AppImageUpdater = AppImageUpdater;
var DebUpdater$1 = {};
Object.defineProperty(DebUpdater$1, "__esModule", { value: true });
DebUpdater$1.DebUpdater = void 0;
const BaseUpdater_1$3 = BaseUpdater$1;
const Provider_1$4 = Provider$1;
const types_1$3 = types;
class DebUpdater extends BaseUpdater_1$3.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$4.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(types_1$3.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1$3.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
      }
    });
  }
  get installerPath() {
    var _a2, _b;
    return (_b = (_a2 = super.installerPath) === null || _a2 === void 0 ? void 0 : _a2.replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
  }
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    const cmd = ["dpkg", "-i", installerPath, "||", "apt-get", "install", "-f", "-y"];
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    if (options.isForceRunAfter) {
      this.app.relaunch();
    }
    return true;
  }
}
DebUpdater$1.DebUpdater = DebUpdater;
var PacmanUpdater$1 = {};
Object.defineProperty(PacmanUpdater$1, "__esModule", { value: true });
PacmanUpdater$1.PacmanUpdater = void 0;
const BaseUpdater_1$2 = BaseUpdater$1;
const types_1$2 = types;
const Provider_1$3 = Provider$1;
class PacmanUpdater extends BaseUpdater_1$2.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$3.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
    return this.executeDownload({
      fileExtension: "pacman",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(types_1$2.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1$2.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
      }
    });
  }
  get installerPath() {
    var _a2, _b;
    return (_b = (_a2 = super.installerPath) === null || _a2 === void 0 ? void 0 : _a2.replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
  }
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    const cmd = ["pacman", "-U", "--noconfirm", installerPath];
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    if (options.isForceRunAfter) {
      this.app.relaunch();
    }
    return true;
  }
}
PacmanUpdater$1.PacmanUpdater = PacmanUpdater;
var RpmUpdater$1 = {};
Object.defineProperty(RpmUpdater$1, "__esModule", { value: true });
RpmUpdater$1.RpmUpdater = void 0;
const BaseUpdater_1$1 = BaseUpdater$1;
const types_1$1 = types;
const Provider_1$2 = Provider$1;
class RpmUpdater extends BaseUpdater_1$1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$2.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(types_1$1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1$1.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
      }
    });
  }
  get installerPath() {
    var _a2, _b;
    return (_b = (_a2 = super.installerPath) === null || _a2 === void 0 ? void 0 : _a2.replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
  }
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const packageManager = this.spawnSyncLog("which zypper");
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    let cmd;
    if (!packageManager) {
      const packageManager2 = this.spawnSyncLog("which dnf || which yum");
      cmd = [packageManager2, "-y", "install", installerPath];
    } else {
      cmd = [packageManager, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", installerPath];
    }
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    if (options.isForceRunAfter) {
      this.app.relaunch();
    }
    return true;
  }
}
RpmUpdater$1.RpmUpdater = RpmUpdater;
var MacUpdater$1 = {};
Object.defineProperty(MacUpdater$1, "__esModule", { value: true });
MacUpdater$1.MacUpdater = void 0;
const builder_util_runtime_1$2 = out;
const fs_extra_1$1 = lib;
const fs_1 = fs$k;
const path$2 = path$n;
const http_1 = require$$3$2;
const AppUpdater_1 = AppUpdater$1;
const Provider_1$1 = Provider$1;
const child_process_1$1 = require$$1$7;
const crypto_1 = require$$0$c;
class MacUpdater extends AppUpdater_1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.nativeUpdater = require$$1$6.autoUpdater;
    this.squirrelDownloadedUpdate = false;
    this.nativeUpdater.on("error", (it) => {
      this._logger.warn(it);
      this.emit("error", it);
    });
    this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = true;
      this.debug("nativeUpdater.update-downloaded");
    });
  }
  debug(message) {
    if (this._logger.debug != null) {
      this._logger.debug(message);
    }
  }
  closeServerIfExists() {
    if (this.server) {
      this.debug("Closing proxy server");
      this.server.close((err2) => {
        if (err2) {
          this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
        }
      });
    }
  }
  async doDownloadUpdate(downloadUpdateOptions) {
    let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
    const log = this._logger;
    const sysctlRosettaInfoKey = "sysctl.proc_translated";
    let isRosetta = false;
    try {
      this.debug("Checking for macOS Rosetta environment");
      const result = (0, child_process_1$1.execFileSync)("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
      isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
      log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
    } catch (e) {
      log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
    }
    let isArm64Mac = false;
    try {
      this.debug("Checking for arm64 in uname");
      const result = (0, child_process_1$1.execFileSync)("uname", ["-a"], { encoding: "utf8" });
      const isArm = result.includes("ARM");
      log.info(`Checked 'uname -a': arm64=${isArm}`);
      isArm64Mac = isArm64Mac || isArm;
    } catch (e) {
      log.warn(`uname shell command to check for arm64 failed: ${e}`);
    }
    isArm64Mac = isArm64Mac || process.arch === "arm64" || isRosetta;
    const isArm64 = (file2) => {
      var _a2;
      return file2.url.pathname.includes("arm64") || ((_a2 = file2.info.url) === null || _a2 === void 0 ? void 0 : _a2.includes("arm64"));
    };
    if (isArm64Mac && files.some(isArm64)) {
      files = files.filter((file2) => isArm64Mac === isArm64(file2));
    } else {
      files = files.filter((file2) => !isArm64(file2));
    }
    const zipFileInfo = (0, Provider_1$1.findFile)(files, "zip", ["pkg", "dmg"]);
    if (zipFileInfo == null) {
      throw (0, builder_util_runtime_1$2.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1$2.safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    }
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const CURRENT_MAC_APP_ZIP_FILE_NAME = "update.zip";
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: zipFileInfo,
      downloadUpdateOptions,
      task: async (destinationFile, downloadOptions) => {
        const cachedUpdateFilePath = path$2.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
        const canDifferentialDownload = () => {
          if (!(0, fs_extra_1$1.pathExistsSync)(cachedUpdateFilePath)) {
            log.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download");
            return false;
          }
          return !downloadUpdateOptions.disableDifferentialDownload;
        };
        let differentialDownloadFailed = true;
        if (canDifferentialDownload()) {
          differentialDownloadFailed = await this.differentialDownloadInstaller(zipFileInfo, downloadUpdateOptions, destinationFile, provider, CURRENT_MAC_APP_ZIP_FILE_NAME);
        }
        if (differentialDownloadFailed) {
          await this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
        }
      },
      done: async (event) => {
        if (!downloadUpdateOptions.disableDifferentialDownload) {
          try {
            const cachedUpdateFilePath = path$2.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
            await (0, fs_extra_1$1.copyFile)(event.downloadedFile, cachedUpdateFilePath);
          } catch (error2) {
            this._logger.warn(`Unable to copy file for caching for future differential downloads: ${error2.message}`);
          }
        }
        return this.updateDownloaded(zipFileInfo, event);
      }
    });
  }
  async updateDownloaded(zipFileInfo, event) {
    var _a2;
    const downloadedFile = event.downloadedFile;
    const updateFileSize = (_a2 = zipFileInfo.info.size) !== null && _a2 !== void 0 ? _a2 : (await (0, fs_extra_1$1.stat)(downloadedFile)).size;
    const log = this._logger;
    const logContext = `fileToProxy=${zipFileInfo.url.href}`;
    this.closeServerIfExists();
    this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
    this.server = (0, http_1.createServer)();
    this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
    this.server.on("close", () => {
      log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
    });
    const getServerUrl = (s) => {
      const address = s.address();
      if (typeof address === "string") {
        return address;
      }
      return `http://127.0.0.1:${address === null || address === void 0 ? void 0 : address.port}`;
    };
    return await new Promise((resolve2, reject) => {
      const pass = (0, crypto_1.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
      const authInfo = Buffer.from(`autoupdater:${pass}`, "ascii");
      const fileUrl = `/${(0, crypto_1.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (request2, response2) => {
        const requestUrl = request2.url;
        log.info(`${requestUrl} requested`);
        if (requestUrl === "/") {
          if (!request2.headers.authorization || request2.headers.authorization.indexOf("Basic ") === -1) {
            response2.statusCode = 401;
            response2.statusMessage = "Invalid Authentication Credentials";
            response2.end();
            log.warn("No authenthication info");
            return;
          }
          const base64Credentials = request2.headers.authorization.split(" ")[1];
          const credentials = Buffer.from(base64Credentials, "base64").toString("ascii");
          const [username, password] = credentials.split(":");
          if (username !== "autoupdater" || password !== pass) {
            response2.statusCode = 401;
            response2.statusMessage = "Invalid Authentication Credentials";
            response2.end();
            log.warn("Invalid authenthication credentials");
            return;
          }
          const data = Buffer.from(`{ "url": "${getServerUrl(this.server)}${fileUrl}" }`);
          response2.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
          response2.end(data);
          return;
        }
        if (!requestUrl.startsWith(fileUrl)) {
          log.warn(`${requestUrl} requested, but not supported`);
          response2.writeHead(404);
          response2.end();
          return;
        }
        log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
        let errorOccurred = false;
        response2.on("finish", () => {
          if (!errorOccurred) {
            this.nativeUpdater.removeListener("error", reject);
            resolve2([]);
          }
        });
        const readStream2 = (0, fs_1.createReadStream)(downloadedFile);
        readStream2.on("error", (error2) => {
          try {
            response2.end();
          } catch (e) {
            log.warn(`cannot end response: ${e}`);
          }
          errorOccurred = true;
          this.nativeUpdater.removeListener("error", reject);
          reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
        });
        response2.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": updateFileSize
        });
        readStream2.pipe(response2);
      });
      this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
      this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl(this.server)}, ${logContext})`);
        this.nativeUpdater.setFeedURL({
          url: getServerUrl(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${authInfo.toString("base64")}`
          }
        });
        this.dispatchUpdateDownloaded(event);
        if (this.autoInstallOnAppQuit) {
          this.nativeUpdater.once("error", reject);
          this.nativeUpdater.checkForUpdates();
        } else {
          resolve2([]);
        }
      });
    });
  }
  handleUpdateDownloaded() {
    if (this.autoRunAppAfterInstall) {
      this.nativeUpdater.quitAndInstall();
    } else {
      this.app.quit();
    }
    this.closeServerIfExists();
  }
  quitAndInstall() {
    if (this.squirrelDownloadedUpdate) {
      this.handleUpdateDownloaded();
    } else {
      this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded());
      if (!this.autoInstallOnAppQuit) {
        this.nativeUpdater.checkForUpdates();
      }
    }
  }
}
MacUpdater$1.MacUpdater = MacUpdater;
var NsisUpdater$1 = {};
var windowsExecutableCodeSignatureVerifier = {};
Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
const builder_util_runtime_1$1 = out;
const child_process_1 = require$$1$7;
const os = require$$2$2;
const path$1 = path$n;
function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
  return new Promise((resolve2, reject) => {
    const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''");
    logger.info(`Verifying signature ${tempUpdateFile}`);
    (0, child_process_1.execFile)(`set "PSModulePath=" & chcp 65001 >NUL & powershell.exe`, ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress"`], {
      shell: true,
      timeout: 20 * 1e3
    }, (error2, stdout, stderr) => {
      var _a2;
      try {
        if (error2 != null || stderr) {
          handleError(logger, error2, stderr, reject);
          resolve2(null);
          return;
        }
        const data = parseOut(stdout);
        if (data.Status === 0) {
          try {
            const normlaizedUpdateFilePath = path$1.normalize(data.Path);
            const normalizedTempUpdateFile = path$1.normalize(unescapedTempUpdateFile);
            logger.info(`LiteralPath: ${normlaizedUpdateFilePath}. Update Path: ${normalizedTempUpdateFile}`);
            if (normlaizedUpdateFilePath !== normalizedTempUpdateFile) {
              handleError(logger, new Error(`LiteralPath of ${normlaizedUpdateFilePath} is different than ${normalizedTempUpdateFile}`), stderr, reject);
              resolve2(null);
              return;
            }
          } catch (error3) {
            logger.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(_a2 = error3.message) !== null && _a2 !== void 0 ? _a2 : error3.stack}`);
          }
          const subject = (0, builder_util_runtime_1$1.parseDn)(data.SignerCertificate.Subject);
          let match = false;
          for (const name of publisherNames) {
            const dn = (0, builder_util_runtime_1$1.parseDn)(name);
            if (dn.size) {
              const allKeys = Array.from(dn.keys());
              match = allKeys.every((key) => {
                return dn.get(key) === subject.get(key);
              });
            } else if (name === subject.get("CN")) {
              logger.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);
              match = true;
            }
            if (match) {
              resolve2(null);
              return;
            }
          }
        }
        const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
        logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
        resolve2(result);
      } catch (e) {
        handleError(logger, e, null, reject);
        resolve2(null);
        return;
      }
    });
  });
}
function parseOut(out2) {
  const data = JSON.parse(out2);
  delete data.PrivateKey;
  delete data.IsOSBinary;
  delete data.SignatureType;
  const signerCertificate = data.SignerCertificate;
  if (signerCertificate != null) {
    delete signerCertificate.Archived;
    delete signerCertificate.Extensions;
    delete signerCertificate.Handle;
    delete signerCertificate.HasPrivateKey;
    delete signerCertificate.SubjectName;
  }
  return data;
}
function handleError(logger, error2, stderr, reject) {
  if (isOldWin6()) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    (0, child_process_1.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (testError) {
    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  if (error2 != null) {
    reject(error2);
  }
  if (stderr) {
    reject(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Failing signature validation due to unknown stderr.`));
  }
}
function isOldWin6() {
  const winVersion = os.release();
  return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
Object.defineProperty(NsisUpdater$1, "__esModule", { value: true });
NsisUpdater$1.NsisUpdater = void 0;
const builder_util_runtime_1 = out;
const path = path$n;
const BaseUpdater_1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const types_1 = types;
const Provider_1 = Provider$1;
const fs_extra_1 = lib;
const windowsExecutableCodeSignatureVerifier_1 = windowsExecutableCodeSignatureVerifier;
const url_1 = require$$0$5;
class NsisUpdater extends BaseUpdater_1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
    this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);
  }
  /**
   * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
   * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
   */
  get verifyUpdateCodeSignature() {
    return this._verifyUpdateCodeSignature;
  }
  set verifyUpdateCodeSignature(value) {
    if (value) {
      this._verifyUpdateCodeSignature = value;
    }
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions,
      fileInfo,
      task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
        const packageInfo = fileInfo.packageInfo;
        const isWebInstaller = packageInfo != null && packageFile != null;
        if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {
          throw (0, builder_util_runtime_1.newError)(`Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        }
        if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {
          this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.");
        }
        if (isWebInstaller || downloadUpdateOptions.disableDifferentialDownload || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME)) {
          await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
        }
        const signatureVerificationStatus = await this.verifySignature(destinationFile);
        if (signatureVerificationStatus != null) {
          await removeTempDirIfAny();
          throw (0, builder_util_runtime_1.newError)(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
        }
        if (isWebInstaller) {
          if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
            try {
              await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                headers: downloadUpdateOptions.requestHeaders,
                cancellationToken: downloadUpdateOptions.cancellationToken,
                sha512: packageInfo.sha512
              });
            } catch (e) {
              try {
                await (0, fs_extra_1.unlink)(packageFile);
              } catch (_ignored) {
              }
              throw e;
            }
          }
        }
      }
    });
  }
  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
  async verifySignature(tempUpdateFile) {
    let publisherName;
    try {
      publisherName = (await this.configOnDisk.value).publisherName;
      if (publisherName == null) {
        return null;
      }
    } catch (e) {
      if (e.code === "ENOENT") {
        return null;
      }
      throw e;
    }
    return await this._verifyUpdateCodeSignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile);
  }
  doInstall(options) {
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    const args = ["--updated"];
    if (options.isSilent) {
      args.push("/S");
    }
    if (options.isForceRunAfter) {
      args.push("--force-run");
    }
    if (this.installDirectory) {
      args.push(`/D=${this.installDirectory}`);
    }
    const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    if (packagePath != null) {
      args.push(`--package-file=${packagePath}`);
    }
    const callUsingElevation = () => {
      this.spawnLog(path.join(process.resourcesPath, "elevate.exe"), [installerPath].concat(args)).catch((e) => this.dispatchError(e));
    };
    if (options.isAdminRightsRequired) {
      this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
      callUsingElevation();
      return true;
    }
    this.spawnLog(installerPath, args).catch((e) => {
      const errorCode = e.code;
      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`);
      if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
        callUsingElevation();
      } else if (errorCode === "ENOENT") {
        require$$1$6.shell.openPath(installerPath).catch((err2) => this.dispatchError(err2));
      } else {
        this.dispatchError(e);
      }
    });
    return true;
  }
  async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
    if (packageInfo.blockMapSize == null) {
      return true;
    }
    try {
      const downloadOptions = {
        newUrl: new url_1.URL(packageInfo.path),
        oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: packagePath,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "win32";
    }
    return false;
  }
}
NsisUpdater$1.NsisUpdater = NsisUpdater;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NsisUpdater = exports.MacUpdater = exports.RpmUpdater = exports.PacmanUpdater = exports.DebUpdater = exports.AppImageUpdater = exports.Provider = exports.NoOpLogger = exports.AppUpdater = exports.BaseUpdater = void 0;
  const fs_extra_12 = lib;
  const path2 = path$n;
  var BaseUpdater_12 = BaseUpdater$1;
  Object.defineProperty(exports, "BaseUpdater", { enumerable: true, get: function() {
    return BaseUpdater_12.BaseUpdater;
  } });
  var AppUpdater_12 = AppUpdater$1;
  Object.defineProperty(exports, "AppUpdater", { enumerable: true, get: function() {
    return AppUpdater_12.AppUpdater;
  } });
  Object.defineProperty(exports, "NoOpLogger", { enumerable: true, get: function() {
    return AppUpdater_12.NoOpLogger;
  } });
  var Provider_12 = Provider$1;
  Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
    return Provider_12.Provider;
  } });
  var AppImageUpdater_1 = AppImageUpdater$1;
  Object.defineProperty(exports, "AppImageUpdater", { enumerable: true, get: function() {
    return AppImageUpdater_1.AppImageUpdater;
  } });
  var DebUpdater_1 = DebUpdater$1;
  Object.defineProperty(exports, "DebUpdater", { enumerable: true, get: function() {
    return DebUpdater_1.DebUpdater;
  } });
  var PacmanUpdater_1 = PacmanUpdater$1;
  Object.defineProperty(exports, "PacmanUpdater", { enumerable: true, get: function() {
    return PacmanUpdater_1.PacmanUpdater;
  } });
  var RpmUpdater_1 = RpmUpdater$1;
  Object.defineProperty(exports, "RpmUpdater", { enumerable: true, get: function() {
    return RpmUpdater_1.RpmUpdater;
  } });
  var MacUpdater_1 = MacUpdater$1;
  Object.defineProperty(exports, "MacUpdater", { enumerable: true, get: function() {
    return MacUpdater_1.MacUpdater;
  } });
  var NsisUpdater_1 = NsisUpdater$1;
  Object.defineProperty(exports, "NsisUpdater", { enumerable: true, get: function() {
    return NsisUpdater_1.NsisUpdater;
  } });
  __exportStar(types, exports);
  let _autoUpdater;
  function doLoadAutoUpdater() {
    if (process.platform === "win32") {
      _autoUpdater = new NsisUpdater$1.NsisUpdater();
    } else if (process.platform === "darwin") {
      _autoUpdater = new MacUpdater$1.MacUpdater();
    } else {
      _autoUpdater = new AppImageUpdater$1.AppImageUpdater();
      try {
        const identity = path2.join(process.resourcesPath, "package-type");
        if (!(0, fs_extra_12.existsSync)(identity)) {
          return _autoUpdater;
        }
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const fileType = (0, fs_extra_12.readFileSync)(identity).toString().trim();
        console.info("Found package-type:", fileType);
        switch (fileType) {
          case "deb":
            _autoUpdater = new DebUpdater$1.DebUpdater();
            break;
          case "rpm":
            _autoUpdater = new RpmUpdater$1.RpmUpdater();
            break;
          case "pacman":
            _autoUpdater = new PacmanUpdater$1.PacmanUpdater();
            break;
          default:
            break;
        }
      } catch (error2) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", error2.message);
      }
    }
    return _autoUpdater;
  }
  Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
      return _autoUpdater || doLoadAutoUpdater();
    }
  });
})(main$1);
class ElectronUpdate extends WCF {
  constructor(win2) {
    super(win2);
    __publicField(this, "updateInProgress");
    __publicField(this, "setUpdatSetFeedUrl", async () => {
      var _a2, _b;
      const tag = await this.getLatestVersion();
      const proxyurl = ((_a2 = this.wcfConfig) == null ? void 0 : _a2.proxy_url) ? ((_b = this.wcfConfig) == null ? void 0 : _b.proxy_url) + "/" : "";
      if (tag) {
        const url2 = `${proxyurl}https://github.com/dr-forget/wcferry-node/releases/download/${tag}`;
        main$1.autoUpdater.setFeedURL({
          provider: "generic",
          url: url2,
          requestHeaders: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"
          }
        });
        this.sendLog("设置更新地址成功", "INFO");
      }
    });
    // 获取最新的APP版本号
    __publicField(this, "getLatestVersion", async () => {
      try {
        const url2 = `https://api.github.com/repos/dr-forget/wcferry-node/releases`;
        const res2 = await axios.get(url2, { timeout: 6e3 });
        if (res2.status !== 200) {
          this.sendLog("获取最新版本失败", "ERROR");
          return null;
        }
        const data = res2.data;
        const latestAppVersion = data.filter((item) => /^app-v/.test(item.tag_name))[0] || null;
        return latestAppVersion.tag_name || null;
      } catch (err2) {
        this.sendLog(err2.message, "ERROR");
        return null;
      }
    });
    // 检查更新
    __publicField(this, "checkElectronUpdate", async () => {
      try {
        if (!app.isPackaged) return 0;
        if (this.updateInProgress) return 2;
        await this.setUpdatSetFeedUrl();
        this.updateInProgress = true;
        const res2 = await main$1.autoUpdater.checkForUpdates();
        main$1.autoUpdater.on("update-not-available", () => {
          this.updateInProgress = false;
        });
        main$1.autoUpdater.on("error", () => {
          console.log(666);
          this.updateInProgress = false;
        });
        main$1.autoUpdater.on("update-downloaded", () => {
          dialog.showMessageBox({
            type: "info",
            title: "更新已下载",
            message: "新版本已准备好，是否现在安装？",
            buttons: ["安装并重启", "稍后"]
          }).then((result) => {
            if (result.response === 0) {
              main$1.autoUpdater.quitAndInstall();
            }
            this.updateInProgress = false;
          });
        });
        if (res2 && (res2 == null ? void 0 : res2.updateInfo.version) !== app.getVersion()) {
          return 1;
        } else {
          return 0;
        }
      } catch (err2) {
        this.updateInProgress = false;
        this.sendLog(err2.message, "ERROR");
      }
    });
    this.updateInProgress = false;
  }
}
const __dirname$1 = path$o.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$o.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$o.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$o.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$o.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
let wcf = null;
let electronUpdate = null;
function startMemoryMonitor(win2) {
  const memoryUsage = process.memoryUsage();
  const totalMB = (memoryUsage.rss / 1024 / 1024).toFixed(1);
  win2 == null ? void 0 : win2.webContents.send("memory-usage", totalMB);
}
function createWindow() {
  win = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 1200,
    minHeight: 800,
    icon: path$o.join(process.env.VITE_PUBLIC, "logo.png"),
    webPreferences: {
      preload: path$o.join(__dirname$1, "preload.mjs")
    }
  });
  wcf = new WCF(win);
  wcf == null ? void 0 : wcf.crateTray();
  electronUpdate = new ElectronUpdate(win);
  win.webContents.on("did-finish-load", () => {
    electronUpdate == null ? void 0 : electronUpdate.checkElectronUpdate();
    startMemoryMonitor(win);
    wcf == null ? void 0 : wcf.registerSchedule("*/2 * * * *", () => {
      startMemoryMonitor(win);
    });
    wcf == null ? void 0 : wcf.registerSchedule("0 */12 * * *", async () => {
      const res2 = await (wcf == null ? void 0 : wcf.checkUpdate());
      await (electronUpdate == null ? void 0 : electronUpdate.checkElectronUpdate());
      win == null ? void 0 : win.webContents.send("wcf:checkUpdateNotiy", res2);
    });
    wcf == null ? void 0 : wcf.reportConfig();
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
    win == null ? void 0 : win.webContents.toggleDevTools();
  } else {
    win.loadFile(path$o.join(RENDERER_DIST, "index.html"));
  }
  ipcMain.handle("wcf:checkUpdate", wcf.checkUpdate);
  ipcMain.handle("wcf:checkWCF", wcf.checkWCF);
  ipcMain.handle("wcf:downloadWCF", wcf.downloadWCF);
  ipcMain.handle("wcf:chekWcfIsRun", wcf.checkWCFIsRun);
  ipcMain.handle("wcf:startWcfHttpServer", wcf.startWcfServer);
  ipcMain.handle("wcf:closeWcfHttpServer", wcf.closeWcfServer);
  ipcMain.handle("wcf:updateConfig", wcf.modifyWCFConfig);
  ipcMain.handle("wcf:config", wcf.getWCFConfig);
  ipcMain.handle("wcf:restartWcf", wcf.restartWCF);
  ipcMain.handle("wcf:closeWcf", wcf.closeWCF);
  ipcMain.handle("wcf:startWCF", wcf.startWCF);
  ipcMain.handle("wcf:resetWcf", wcf.resetWCF);
  ipcMain.handle("wcf:readWcfLog", wcf.readWcfLog);
  ipcMain.handle("wcf:injectVersionWcf", (_, data) => wcf == null ? void 0 : wcf.injectVersionDll(data.version, data.download_wechat || false));
  ipcMain.handle("open:url", (_, url2) => {
    shell.openExternal(url2);
  });
  ipcMain.handle("app:update", electronUpdate.checkUpdate);
  globalShortcut.register("CommandOrControl+Shift+I", () => {
    win == null ? void 0 : win.webContents.toggleDevTools();
  });
  win.on("close", (event) => {
    event.preventDefault();
    win == null ? void 0 : win.hide();
  });
}
const menu = Menu.buildFromTemplate([]);
Menu.setApplicationMenu(menu);
app.on("window-all-closed", (event) => {
  event.preventDefault();
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
process.on("uncaughtException", (error2) => {
  win == null ? void 0 : win.webContents.send("unhandledRejection", error2.message);
});
process.on("unhandledRejection", (reason) => {
  win == null ? void 0 : win.webContents.send("unhandledRejection", `Pormise:${reason.message}`);
});
app.whenReady().then(createWindow);
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
