<<<<<<< HEAD
var aC = Object.defineProperty;
var uv = (e) => {
  throw TypeError(e);
};
var cC = (e, t, r) => t in e ? aC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Te = (e, t, r) => cC(e, typeof t != "symbol" ? t + "" : t, r), Ff = (e, t, r) => t.has(e) || uv("Cannot " + r);
var pt = (e, t, r) => (Ff(e, t, "read from private field"), r ? r.call(e) : t.get(e)), fi = (e, t, r) => t.has(e) ? uv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), ts = (e, t, r, n) => (Ff(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), or = (e, t, r) => (Ff(e, t, "access private method"), r);
import ji, { app as js, dialog as lC, Menu as CS, BrowserWindow as AS, ipcMain as ar, shell as uC, globalShortcut as fC } from "electron";
import dC, { fileURLToPath as pC } from "node:url";
import { createRequire as hC } from "node:module";
import hu from "node:events";
import zi from "node:util";
import mu from "node:http";
import om from "node:diagnostics_channel";
import mC from "node:https";
import gC from "node:dns";
import IS from "node:os";
import Na from "node:stream";
import Ye from "fs";
import gu, { EventEmitter as yC } from "events";
import wn from "util";
import we from "path";
import ka from "assert";
import NS from "worker_threads";
import vC from "module";
import hn from "node:path";
import Hr from "url";
import _C from "buffer";
import bC from "node:async_hooks";
import Vi from "node:assert";
import EC from "node:crypto";
import It, { Readable as wC } from "stream";
import yu from "http";
import am from "https";
import Gi from "crypto";
import kS from "tty";
import vu from "os";
import Or from "zlib";
import _u, { execSync as al } from "child_process";
import SC from "constants";
import xC from "string_decoder";
var me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Da(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var La = { exports: {} }, cm = { exports: {} };
function RC(e) {
  var t = new e(), r = t;
  function n() {
    var s = t;
    return s.next ? t = s.next : (t = new e(), r = t), s.next = null, s;
  }
  function i(s) {
    r.next = s, r = s;
  }
  return {
    get: n,
    release: i
  };
}
var $C = RC, TC = $C;
function DS(e, t, r) {
  if (typeof e == "function" && (r = t, t = e, e = null), !(r >= 1))
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var n = TC(OC), i = null, s = null, o = 0, a = null, c = {
    push: h,
    drain: Tr,
    saturated: Tr,
=======
var uS = Object.defineProperty;
var vp = (e) => {
  throw TypeError(e);
};
var fS = (e, t, r) => t in e ? uS(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Se = (e, t, r) => fS(e, typeof t != "symbol" ? t + "" : t, r), Qa = (e, t, r) => t.has(e) || vp("Cannot " + r);
var Xe = (e, t, r) => (Qa(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Vr = (e, t, r) => t.has(e) ? vp("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), wn = (e, t, r, n) => (Qa(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), Rt = (e, t, r) => (Qa(e, t, "access private method"), r);
import { app as Gn, Menu as hv, BrowserWindow as mv, ipcMain as $t, shell as dS, globalShortcut as pS } from "electron";
import hS, { fileURLToPath as mS } from "node:url";
import { createRequire as yS } from "node:module";
import Qo from "node:events";
import yn from "node:util";
import ea from "node:http";
import zu from "node:diagnostics_channel";
import gS from "node:https";
import vS from "node:dns";
import yv from "node:os";
import ri from "node:stream";
import vt from "fs";
import gv, { EventEmitter as bS } from "events";
import gn from "util";
import rt from "path";
import Uu from "assert";
import vv from "worker_threads";
import _S from "module";
import vr from "node:path";
import ni from "url";
import ES from "buffer";
import SS from "node:async_hooks";
import vn from "node:assert";
import xS from "node:crypto";
import zt, { Readable as wS } from "stream";
import qu from "http";
import Hu from "https";
import bv from "crypto";
import _v from "tty";
import RS from "os";
import fr from "zlib";
import { execSync as ao } from "child_process";
var _e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function si(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ii = { exports: {} }, Bu = { exports: {} };
function $S(e) {
  var t = new e(), r = t;
  function n() {
    var i = t;
    return i.next ? t = i.next : (t = new e(), r = t), i.next = null, i;
  }
  function s(i) {
    r.next = i, r = i;
  }
  return {
    get: n,
    release: s
  };
}
var TS = $S, OS = TS;
function Ev(e, t, r) {
  if (typeof e == "function" && (r = t, t = e, e = null), !(r >= 1))
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var n = OS(CS), s = null, i = null, o = 0, a = null, c = {
    push: h,
    drain: Mt,
    saturated: Mt,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    pause: l,
    paused: !1,
    get concurrency() {
      return r;
    },
    set concurrency(R) {
      if (!(R >= 1))
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      if (r = R, !c.paused)
<<<<<<< HEAD
        for (; i && o < r; )
          o++, g();
    },
    running: u,
    resume: p,
    idle: d,
    length: f,
    getQueue: m,
    unshift: _,
    empty: Tr,
    kill: v,
    killAndDrain: y,
    error: E
  };
  return c;
  function u() {
=======
        for (; s && o < r; )
          o++, m();
    },
    running: f,
    resume: p,
    idle: u,
    length: d,
    getQueue: g,
    unshift: b,
    empty: Mt,
    kill: v,
    killAndDrain: y,
    error: _
  };
  return c;
  function f() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return o;
  }
  function l() {
    c.paused = !0;
  }
<<<<<<< HEAD
  function f() {
    for (var R = i, w = 0; R; )
      R = R.next, w++;
    return w;
  }
  function m() {
    for (var R = i, w = []; R; )
      w.push(R.value), R = R.next;
    return w;
  }
  function p() {
    if (c.paused) {
      if (c.paused = !1, i === null) {
        o++, g();
        return;
      }
      for (; i && o < r; )
        o++, g();
    }
  }
  function d() {
    return o === 0 && c.length() === 0;
  }
  function h(R, w) {
    var C = n.get();
    C.context = e, C.release = g, C.value = R, C.callback = w || Tr, C.errorHandler = a, o >= r || c.paused ? s ? (s.next = C, s = C) : (i = C, s = C, c.saturated()) : (o++, t.call(e, C.value, C.worked));
  }
  function _(R, w) {
    var C = n.get();
    C.context = e, C.release = g, C.value = R, C.callback = w || Tr, C.errorHandler = a, o >= r || c.paused ? i ? (C.next = i, i = C) : (i = C, s = C, c.saturated()) : (o++, t.call(e, C.value, C.worked));
  }
  function g(R) {
    R && n.release(R);
    var w = i;
    w && o <= r ? c.paused ? o-- : (s === i && (s = null), i = w.next, w.next = null, t.call(e, w.value, w.worked), s === null && c.empty()) : --o === 0 && c.drain();
  }
  function v() {
    i = null, s = null, c.drain = Tr;
  }
  function y() {
    i = null, s = null, c.drain(), c.drain = Tr;
  }
  function E(R) {
    a = R;
  }
}
function Tr() {
}
function OC() {
  this.value = null, this.callback = Tr, this.next = null, this.release = Tr, this.context = null, this.errorHandler = null;
  var e = this;
  this.worked = function(r, n) {
    var i = e.callback, s = e.errorHandler, o = e.value;
    e.value = null, e.callback = Tr, e.errorHandler && s(r, o), i.call(e.context, r, n), e.release(e);
  };
}
function PC(e, t, r) {
  typeof e == "function" && (r = t, t = e, e = null);
  function n(l, f) {
    t.call(this, l).then(function(m) {
      f(null, m);
    }, f);
  }
  var i = DS(e, n, r), s = i.push, o = i.unshift;
  return i.push = a, i.unshift = c, i.drained = u, i;
  function a(l) {
    var f = new Promise(function(m, p) {
      s(l, function(d, h) {
        if (d) {
          p(d);
          return;
        }
        m(h);
      });
    });
    return f.catch(Tr), f;
  }
  function c(l) {
    var f = new Promise(function(m, p) {
      o(l, function(d, h) {
        if (d) {
          p(d);
          return;
        }
        m(h);
      });
    });
    return f.catch(Tr), f;
  }
  function u() {
    var l = new Promise(function(f) {
      process.nextTick(function() {
        if (i.idle())
          f();
        else {
          var m = i.drain;
          i.drain = function() {
            typeof m == "function" && m(), f(), i.drain = m;
=======
  function d() {
    for (var R = s, E = 0; R; )
      R = R.next, E++;
    return E;
  }
  function g() {
    for (var R = s, E = []; R; )
      E.push(R.value), R = R.next;
    return E;
  }
  function p() {
    if (c.paused) {
      if (c.paused = !1, s === null) {
        o++, m();
        return;
      }
      for (; s && o < r; )
        o++, m();
    }
  }
  function u() {
    return o === 0 && c.length() === 0;
  }
  function h(R, E) {
    var O = n.get();
    O.context = e, O.release = m, O.value = R, O.callback = E || Mt, O.errorHandler = a, o >= r || c.paused ? i ? (i.next = O, i = O) : (s = O, i = O, c.saturated()) : (o++, t.call(e, O.value, O.worked));
  }
  function b(R, E) {
    var O = n.get();
    O.context = e, O.release = m, O.value = R, O.callback = E || Mt, O.errorHandler = a, o >= r || c.paused ? s ? (O.next = s, s = O) : (s = O, i = O, c.saturated()) : (o++, t.call(e, O.value, O.worked));
  }
  function m(R) {
    R && n.release(R);
    var E = s;
    E && o <= r ? c.paused ? o-- : (i === s && (i = null), s = E.next, E.next = null, t.call(e, E.value, E.worked), i === null && c.empty()) : --o === 0 && c.drain();
  }
  function v() {
    s = null, i = null, c.drain = Mt;
  }
  function y() {
    s = null, i = null, c.drain(), c.drain = Mt;
  }
  function _(R) {
    a = R;
  }
}
function Mt() {
}
function CS() {
  this.value = null, this.callback = Mt, this.next = null, this.release = Mt, this.context = null, this.errorHandler = null;
  var e = this;
  this.worked = function(r, n) {
    var s = e.callback, i = e.errorHandler, o = e.value;
    e.value = null, e.callback = Mt, e.errorHandler && i(r, o), s.call(e.context, r, n), e.release(e);
  };
}
function PS(e, t, r) {
  typeof e == "function" && (r = t, t = e, e = null);
  function n(l, d) {
    t.call(this, l).then(function(g) {
      d(null, g);
    }, d);
  }
  var s = Ev(e, n, r), i = s.push, o = s.unshift;
  return s.push = a, s.unshift = c, s.drained = f, s;
  function a(l) {
    var d = new Promise(function(g, p) {
      i(l, function(u, h) {
        if (u) {
          p(u);
          return;
        }
        g(h);
      });
    });
    return d.catch(Mt), d;
  }
  function c(l) {
    var d = new Promise(function(g, p) {
      o(l, function(u, h) {
        if (u) {
          p(u);
          return;
        }
        g(h);
      });
    });
    return d.catch(Mt), d;
  }
  function f() {
    var l = new Promise(function(d) {
      process.nextTick(function() {
        if (s.idle())
          d();
        else {
          var g = s.drain;
          s.drain = function() {
            typeof g == "function" && g(), d(), s.drain = g;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          };
        }
      });
    });
    return l;
  }
}
<<<<<<< HEAD
cm.exports = DS;
cm.exports.promise = PC;
var CC = cm.exports, bu = { exports: {} };
const { format: AC } = zi;
function IC() {
  return `${this.name} [${this.code}]: ${this.message}`;
}
function Fa(e, t, r = 500, n = Error, i = Fa.captureStackTrace) {
  if (!e) throw new Error("Fastify error code must not be empty");
  if (!t) throw new Error("Fastify error message must not be empty");
  e = e.toUpperCase(), !r && (r = void 0);
  function s(...o) {
    if (!new.target)
      return new s(...o);
    this.code = e, this.name = "FastifyError", this.statusCode = r;
    const a = o.length - 1;
    a !== -1 && o[a] && typeof o[a] == "object" && "cause" in o[a] && (this.cause = o.pop().cause), this.message = AC(t, ...o), Error.stackTraceLimit && i && Error.captureStackTrace(this, s);
  }
  return s.prototype = Object.create(n.prototype, {
    constructor: {
      value: s,
=======
Bu.exports = Ev;
Bu.exports.promise = PS;
var IS = Bu.exports, ta = { exports: {} };
const { format: NS } = yn;
function AS() {
  return `${this.name} [${this.code}]: ${this.message}`;
}
function oi(e, t, r = 500, n = Error, s = oi.captureStackTrace) {
  if (!e) throw new Error("Fastify error code must not be empty");
  if (!t) throw new Error("Fastify error message must not be empty");
  e = e.toUpperCase(), !r && (r = void 0);
  function i(...o) {
    if (!new.target)
      return new i(...o);
    this.code = e, this.name = "FastifyError", this.statusCode = r;
    const a = o.length - 1;
    a !== -1 && o[a] && typeof o[a] == "object" && "cause" in o[a] && (this.cause = o.pop().cause), this.message = NS(t, ...o), Error.stackTraceLimit && s && Error.captureStackTrace(this, i);
  }
  return i.prototype = Object.create(n.prototype, {
    constructor: {
      value: i,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
<<<<<<< HEAD
  }), s.prototype[Symbol.toStringTag] = "Error", s.prototype.toString = IC, s;
}
Fa.captureStackTrace = !0;
bu.exports = Fa;
bu.exports.default = Fa;
bu.exports.createError = Fa;
var LS = bu.exports;
const { createError: Cn } = LS;
var lm = {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: Cn(
    "AVV_ERR_EXPOSE_ALREADY_DEFINED",
    "'%s' is already defined, specify an expose option for '%s'"
  ),
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: Cn(
    "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
    "'%s' is already defined"
  ),
  AVV_ERR_CALLBACK_NOT_FN: Cn(
    "AVV_ERR_CALLBACK_NOT_FN",
    "Callback for '%s' hook is not a function. Received: '%s'"
  ),
  AVV_ERR_PLUGIN_NOT_VALID: Cn(
    "AVV_ERR_PLUGIN_NOT_VALID",
    "Plugin must be a function or a promise. Received: '%s'"
  ),
  AVV_ERR_ROOT_PLG_BOOTED: Cn(
    "AVV_ERR_ROOT_PLG_BOOTED",
    "Root plugin has already booted"
  ),
  AVV_ERR_PARENT_PLG_LOADED: Cn(
    "AVV_ERR_PARENT_PLG_LOADED",
    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
  ),
  AVV_ERR_READY_TIMEOUT: Cn(
    "AVV_ERR_READY_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: Cn(
=======
  }), i.prototype[Symbol.toStringTag] = "Error", i.prototype.toString = AS, i;
}
oi.captureStackTrace = !0;
ta.exports = oi;
ta.exports.default = oi;
ta.exports.createError = oi;
var Sv = ta.exports;
const { createError: Or } = Sv;
var Vu = {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: Or(
    "AVV_ERR_EXPOSE_ALREADY_DEFINED",
    "'%s' is already defined, specify an expose option for '%s'"
  ),
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: Or(
    "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
    "'%s' is already defined"
  ),
  AVV_ERR_CALLBACK_NOT_FN: Or(
    "AVV_ERR_CALLBACK_NOT_FN",
    "Callback for '%s' hook is not a function. Received: '%s'"
  ),
  AVV_ERR_PLUGIN_NOT_VALID: Or(
    "AVV_ERR_PLUGIN_NOT_VALID",
    "Plugin must be a function or a promise. Received: '%s'"
  ),
  AVV_ERR_ROOT_PLG_BOOTED: Or(
    "AVV_ERR_ROOT_PLG_BOOTED",
    "Root plugin has already booted"
  ),
  AVV_ERR_PARENT_PLG_LOADED: Or(
    "AVV_ERR_PARENT_PLG_LOADED",
    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
  ),
  AVV_ERR_READY_TIMEOUT: Or(
    "AVV_ERR_READY_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: Or(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  )
};
<<<<<<< HEAD
const NC = Symbol("avvio.Boot"), kC = Symbol("isOnCloseHandler"), DC = Symbol("avvio.ThenifyDoNotWrap"), LC = Symbol("avvio.TimeTree.untrackNode"), FC = Symbol("avvio.TimeTree.trackNode"), jC = Symbol("avvio.TimeTree.getParent"), UC = Symbol("avvio.TimeTree.getNode"), MC = Symbol("avvio.TimeTree.addNode"), HC = Symbol.for("plugin-meta");
var ja = {
  kAvvio: NC,
  kIsOnCloseHandler: kC,
  kThenifyDoNotWrap: DC,
  kUntrackNode: LC,
  kTrackNode: FC,
  kGetParent: jC,
  kGetNode: UC,
  kAddNode: MC,
  kPluginMeta: HC
};
const {
  kUntrackNode: fv,
  kTrackNode: jf,
  kGetParent: dv,
  kGetNode: pv,
  kAddNode: hv
} = ja;
let qC = class {
=======
const kS = Symbol("avvio.Boot"), LS = Symbol("isOnCloseHandler"), jS = Symbol("avvio.ThenifyDoNotWrap"), DS = Symbol("avvio.TimeTree.untrackNode"), FS = Symbol("avvio.TimeTree.trackNode"), MS = Symbol("avvio.TimeTree.getParent"), zS = Symbol("avvio.TimeTree.getNode"), US = Symbol("avvio.TimeTree.addNode"), qS = Symbol.for("plugin-meta");
var ai = {
  kAvvio: kS,
  kIsOnCloseHandler: LS,
  kThenifyDoNotWrap: jS,
  kUntrackNode: DS,
  kTrackNode: FS,
  kGetParent: MS,
  kGetNode: zS,
  kAddNode: US,
  kPluginMeta: qS
};
const {
  kUntrackNode: bp,
  kTrackNode: ec,
  kGetParent: _p,
  kGetNode: Ep,
  kAddNode: Sp
} = ai;
let HS = class {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    this.root = null, this.tableId = /* @__PURE__ */ new Map(), this.tableLabel = /* @__PURE__ */ new Map();
  }
  /**
   * @param {TimeTreeNode} node
   */
<<<<<<< HEAD
  [jf](t) {
=======
  [ec](t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    this.tableId.set(t.id, t), this.tableLabel.has(t.label) ? this.tableLabel.get(t.label).push(t) : this.tableLabel.set(t.label, [t]);
  }
  /**
   * @param {TimeTreeNode} node
   */
<<<<<<< HEAD
  [fv](t) {
=======
  [bp](t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    this.tableId.delete(t.id);
    const r = this.tableLabel.get(t.label);
    r.pop(), r.length === 0 && this.tableLabel.delete(t.label);
  }
  /**
   * @param {string} parent
   * @returns {TimeTreeNode}
   */
<<<<<<< HEAD
  [dv](t) {
=======
  [_p](t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (t === null)
      return null;
    if (this.tableLabel.has(t)) {
      const r = this.tableLabel.get(t);
      return r[r.length - 1];
    } else
      return null;
  }
  /**
   *
   * @param {string} nodeId
   * @returns {TimeTreeNode}
   */
<<<<<<< HEAD
  [pv](t) {
=======
  [Ep](t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return this.tableId.get(t);
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number} start
   * @returns {TimeTreeNode["id"]}
   */
<<<<<<< HEAD
  [hv](t, r, n) {
    const i = this[dv](t);
    if (i === null)
=======
  [Sp](t, r, n) {
    const s = this[_p](t);
    if (s === null)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return this.root = {
        parent: null,
        id: "root",
        label: r,
        nodes: [],
        start: n,
        stop: null,
        diff: -1
<<<<<<< HEAD
      }, this[jf](this.root), this.root.id;
=======
      }, this[ec](this.root), this.root.id;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const o = `${r}-${Math.random()}`, a = {
      parent: t,
      id: o,
      label: r,
      nodes: [],
      start: n,
      stop: null,
      diff: -1
    };
<<<<<<< HEAD
    return i.nodes.push(a), this[jf](a), o;
=======
    return s.nodes.push(a), this[ec](a), o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number|undefined} start
   * @returns {TimeTreeNode["id"]}
   */
  start(t, r, n = Date.now()) {
<<<<<<< HEAD
    return this[hv](t, r, n);
=======
    return this[Sp](t, r, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  /**
   * @param {string} nodeId
   * @param {number|undefined} stop
   */
  stop(t, r = Date.now()) {
<<<<<<< HEAD
    const n = this[pv](t);
    n && (n.stop = r, n.diff = n.stop - n.start || 0, this[fv](n));
=======
    const n = this[Ep](t);
    n && (n.stop = r, n.diff = n.stop - n.start || 0, this[bp](n));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  /**
   * @returns {TimeTreeNode}
   */
  toJSON() {
    return Object.assign({}, this.root);
  }
  /**
   * @returns {string}
   */
  prettyPrint() {
<<<<<<< HEAD
    return FS(this.toJSON());
  }
};
function FS(e, t = "") {
  let r = t;
  const n = e.nodes.length, i = n - 1;
  r += `${e.label} ${e.diff} ms
`;
  for (let s = 0; s < n; ++s) {
    const o = e.nodes[s], a = t + (s === i ? "  " : "│ ");
    r += t, r += s === i ? "└─" : "├─", r += o.nodes.length === 0 ? "─ " : "┬ ", r += FS(o, a).slice(t.length + 2);
  }
  return r;
}
var BC = {
  TimeTree: qC
};
const { debuglog: zC } = zi, VC = zC("avvio");
var um = {
  debug: VC
};
function GC() {
=======
    return xv(this.toJSON());
  }
};
function xv(e, t = "") {
  let r = t;
  const n = e.nodes.length, s = n - 1;
  r += `${e.label} ${e.diff} ms
`;
  for (let i = 0; i < n; ++i) {
    const o = e.nodes[i], a = t + (i === s ? "  " : "│ ");
    r += t, r += i === s ? "└─" : "├─", r += o.nodes.length === 0 ? "─ " : "┬ ", r += xv(o, a).slice(t.length + 2);
  }
  return r;
}
var BS = {
  TimeTree: HS
};
const { debuglog: VS } = yn, GS = VS("avvio");
var Gu = {
  debug: GS
};
function WS() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = {
    resolve: null,
    reject: null,
    promise: null
  };
  return e.promise = new Promise((t, r) => {
    e.resolve = t, e.reject = r;
  }), e;
}
<<<<<<< HEAD
var WC = {
  createPromise: GC
};
const { kPluginMeta: Uf } = ja;
function KC(e, t) {
  return e[Uf] && e[Uf].name ? e[Uf].name : t && t.name ? t.name : e.name ? e.name : e.toString().split(`
`).slice(0, 2).map((r) => r.trim()).join(" -- ");
}
var YC = {
  getPluginName: KC
};
function JC(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var fm = {
  isPromiseLike: JC
};
const { EventEmitter: XC } = hu, { inherits: ZC } = zi, { debug: At } = um, { createPromise: QC } = WC, { AVV_ERR_PLUGIN_EXEC_TIMEOUT: eA } = lm, { getPluginName: tA } = YC, { isPromiseLike: rA } = fm;
function Xs(e, t, r, n, i) {
  this.queue = e, this.func = t, this.options = r, this.isAfter = n, this.timeout = i, this.started = !1, this.name = tA(t, r), this.queue.pause(), this._error = null, this.loaded = !1, this._promise = null, this.startTime = null;
}
ZC(Xs, XC);
Xs.prototype.exec = function(e, t) {
  At("exec", this.name), this.server = e;
  const r = this.func, n = this.name;
  let i = !1;
  this.options = typeof this.options == "function" ? this.options(this.server) : this.options;
  let s = null;
  const o = (c) => {
    if (i) {
      At("loading complete", n);
      return;
    }
    this._error = c, At(c ? "exec errored" : "exec completed", n), i = !0, s && clearTimeout(s), t(c);
  };
  this.timeout > 0 && (At("setting up timeout", n, this.timeout), s = setTimeout(function() {
    At("timed out", n), s = null;
    const c = new eA(n);
    c.fn = r, o(c);
  }, this.timeout)), this.started = !0, this.startTime = Date.now(), this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
  const a = r(this.server, this.options, o);
  rA(a) ? (At("exec: resolving promise", n), a.then(
=======
var KS = {
  createPromise: WS
};
const { kPluginMeta: tc } = ai;
function JS(e, t) {
  return e[tc] && e[tc].name ? e[tc].name : t && t.name ? t.name : e.name ? e.name : e.toString().split(`
`).slice(0, 2).map((r) => r.trim()).join(" -- ");
}
var YS = {
  getPluginName: JS
};
function XS(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var Wu = {
  isPromiseLike: XS
};
const { EventEmitter: ZS } = Qo, { inherits: QS } = yn, { debug: ut } = Gu, { createPromise: ex } = KS, { AVV_ERR_PLUGIN_EXEC_TIMEOUT: tx } = Vu, { getPluginName: rx } = YS, { isPromiseLike: nx } = Wu;
function ts(e, t, r, n, s) {
  this.queue = e, this.func = t, this.options = r, this.isAfter = n, this.timeout = s, this.started = !1, this.name = rx(t, r), this.queue.pause(), this._error = null, this.loaded = !1, this._promise = null, this.startTime = null;
}
QS(ts, ZS);
ts.prototype.exec = function(e, t) {
  ut("exec", this.name), this.server = e;
  const r = this.func, n = this.name;
  let s = !1;
  this.options = typeof this.options == "function" ? this.options(this.server) : this.options;
  let i = null;
  const o = (c) => {
    if (s) {
      ut("loading complete", n);
      return;
    }
    this._error = c, ut(c ? "exec errored" : "exec completed", n), s = !0, i && clearTimeout(i), t(c);
  };
  this.timeout > 0 && (ut("setting up timeout", n, this.timeout), i = setTimeout(function() {
    ut("timed out", n), i = null;
    const c = new tx(n);
    c.fn = r, o(c);
  }, this.timeout)), this.started = !0, this.startTime = Date.now(), this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
  const a = r(this.server, this.options, o);
  nx(a) ? (ut("exec: resolving promise", n), a.then(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    () => process.nextTick(o),
    (c) => process.nextTick(o, c)
  )) : r.length < 3 && o();
};
<<<<<<< HEAD
Xs.prototype.loadedSoFar = function() {
  if (At("loadedSoFar", this.name), this.loaded)
    return Promise.resolve();
  const e = () => {
    this.server.after((r, n) => {
      this._error = r, this.queue.pause(), this._promise && (r ? (At("rejecting promise", this.name, r), this._promise.reject(r)) : (At("resolving promise", this.name), this._promise.resolve()), this._promise = null), process.nextTick(n, r);
    }), this.queue.resume();
  };
  let t;
  return this._promise ? t = Promise.resolve() : (this._promise = QC(), t = this._promise.promise, this.server ? e() : this.on("start", e)), t;
};
Xs.prototype.enqueue = function(e, t) {
  At("enqueue", this.name, e.name), this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now()), this.queue.push(e, t);
};
Xs.prototype.finish = function(e, t) {
  At("finish", this.name, e);
  const r = () => {
    this.loaded || (At("loaded", this.name), this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now()), this.loaded = !0, t(e));
=======
ts.prototype.loadedSoFar = function() {
  if (ut("loadedSoFar", this.name), this.loaded)
    return Promise.resolve();
  const e = () => {
    this.server.after((r, n) => {
      this._error = r, this.queue.pause(), this._promise && (r ? (ut("rejecting promise", this.name, r), this._promise.reject(r)) : (ut("resolving promise", this.name), this._promise.resolve()), this._promise = null), process.nextTick(n, r);
    }), this.queue.resume();
  };
  let t;
  return this._promise ? t = Promise.resolve() : (this._promise = ex(), t = this._promise.promise, this.server ? e() : this.on("start", e)), t;
};
ts.prototype.enqueue = function(e, t) {
  ut("enqueue", this.name, e.name), this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now()), this.queue.push(e, t);
};
ts.prototype.finish = function(e, t) {
  ut("finish", this.name, e);
  const r = () => {
    this.loaded || (ut("loaded", this.name), this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now()), this.loaded = !0, t(e));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  };
  if (e) {
    this._promise && (this._promise.reject(e), this._promise = null), r();
    return;
  }
  const n = () => {
<<<<<<< HEAD
    if (At("check", this.name, this.queue.length(), this.queue.running(), this._promise), this.queue.length() === 0 && this.queue.running() === 0)
      if (this._promise) {
        const i = () => {
          At("wrap"), queueMicrotask(n);
        };
        this._promise.resolve(), this._promise.promise.then(i, i), this._promise = null;
      } else
        r();
    else
      At("delayed", this.name), this.queue.drain = () => {
        At("drain", this.name), this.queue.drain = nA, queueMicrotask(n);
=======
    if (ut("check", this.name, this.queue.length(), this.queue.running(), this._promise), this.queue.length() === 0 && this.queue.running() === 0)
      if (this._promise) {
        const s = () => {
          ut("wrap"), queueMicrotask(n);
        };
        this._promise.resolve(), this._promise.promise.then(s, s), this._promise = null;
      } else
        r();
    else
      ut("delayed", this.name), this.queue.drain = () => {
        ut("drain", this.name), this.queue.drain = sx, queueMicrotask(n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
  };
  queueMicrotask(n), this.queue.resume();
};
<<<<<<< HEAD
function nA() {
}
var iA = {
  Plugin: Xs
};
const { AVV_ERR_PLUGIN_NOT_VALID: Mf } = lm;
function sA(e) {
  if (!(e && (typeof e == "function" || typeof e.then == "function")))
    throw Array.isArray(e) ? new Mf("array") : e === null ? new Mf("null") : new Mf(typeof e);
}
var oA = {
  validatePlugin: sA
};
function aA(e) {
  return e !== null && typeof e == "object" && typeof e.default == "function";
}
var cA = {
  isBundledOrTypescriptPlugin: aA
};
const { debug: mv } = um, { kThenifyDoNotWrap: Hf } = ja;
function lA() {
  if (this.booted) {
    mv("thenify returning undefined because we are already booted");
    return;
  }
  if (this[Hf]) {
    this[Hf] = !1;
    return;
  }
  return mv("thenify"), (e, t) => this._loadRegistered().then(() => (this[Hf] = !0, e(this._server)), t);
}
var uA = {
  thenify: lA
};
const { isPromiseLike: fA } = fm, { kAvvio: dA } = ja;
function pA(e, t, r) {
  const n = e.apply(e, t);
  fA(n) && !n[dA] ? n.then(() => process.nextTick(r), (i) => process.nextTick(r, i)) : r && process.nextTick(r);
}
var hA = {
  executeWithThenable: pA
};
const cl = CC, mA = hu.EventEmitter, gA = zi.inherits, {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: Eo,
  AVV_ERR_CALLBACK_NOT_FN: Cs,
  AVV_ERR_ROOT_PLG_BOOTED: yA,
  AVV_ERR_READY_TIMEOUT: vA,
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: _A
} = lm, {
  kAvvio: jS,
  kIsOnCloseHandler: US
} = ja, { TimeTree: bA } = BC, { Plugin: MS } = iA, { debug: Us } = um, { validatePlugin: EA } = oA, { isBundledOrTypescriptPlugin: wA } = cA, { isPromiseLike: SA } = fm, { thenify: HS } = uA, { executeWithThenable: gv } = hA;
function mt(e, t, r) {
  if (typeof e == "function" && arguments.length === 1 && (r = e, t = {}, e = null), typeof t == "function" && (r = t, t = {}), t = t || {}, t.autostart = t.autostart !== !1, t.timeout = Number(t.timeout) || 0, t.expose = t.expose || {}, !new.target)
    return new mt(e, t, r);
  this._server = e || this, this._opts = t, e && this._expose(), this._current = [], this._error = null, this._lastUsed = null, this.setMaxListeners(0), r && this.once("start", r), this.started = !1, this.booted = !1, this.pluginTree = new bA(), this._readyQ = cl(this, qS, 1), this._readyQ.pause(), this._readyQ.drain = () => {
    this.emit("start"), this._readyQ.drain = yv;
  }, this._closeQ = cl(this, RA, 1), this._closeQ.pause(), this._closeQ.drain = () => {
    this.emit("close"), this._closeQ.drain = yv;
  }, this._doStart = null;
  const n = this;
  this._root = new MS(cl(this, this._loadPluginNextTick, 1), function(s, o, a) {
    n._doStart = a, o.autostart && n.start();
  }, t, !1, 0), this._trackPluginLoading(this._root), this._loadPlugin(this._root, (i) => {
    Us("root plugin ready");
    try {
      this.emit("preReady"), this._root = null;
    } catch (s) {
      i = i || this._error || s;
    }
    if (i) {
      if (this._error = i, this._readyQ.length() === 0)
        throw i;
=======
function sx() {
}
var ix = {
  Plugin: ts
};
const { AVV_ERR_PLUGIN_NOT_VALID: rc } = Vu;
function ox(e) {
  if (!(e && (typeof e == "function" || typeof e.then == "function")))
    throw Array.isArray(e) ? new rc("array") : e === null ? new rc("null") : new rc(typeof e);
}
var ax = {
  validatePlugin: ox
};
function cx(e) {
  return e !== null && typeof e == "object" && typeof e.default == "function";
}
var lx = {
  isBundledOrTypescriptPlugin: cx
};
const { debug: xp } = Gu, { kThenifyDoNotWrap: nc } = ai;
function ux() {
  if (this.booted) {
    xp("thenify returning undefined because we are already booted");
    return;
  }
  if (this[nc]) {
    this[nc] = !1;
    return;
  }
  return xp("thenify"), (e, t) => this._loadRegistered().then(() => (this[nc] = !0, e(this._server)), t);
}
var fx = {
  thenify: ux
};
const { isPromiseLike: dx } = Wu, { kAvvio: px } = ai;
function hx(e, t, r) {
  const n = e.apply(e, t);
  dx(n) && !n[px] ? n.then(() => process.nextTick(r), (s) => process.nextTick(r, s)) : r && process.nextTick(r);
}
var mx = {
  executeWithThenable: hx
};
const co = IS, yx = Qo.EventEmitter, gx = yn.inherits, {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: ms,
  AVV_ERR_CALLBACK_NOT_FN: zn,
  AVV_ERR_ROOT_PLG_BOOTED: vx,
  AVV_ERR_READY_TIMEOUT: bx,
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: _x
} = Vu, {
  kAvvio: wv,
  kIsOnCloseHandler: Rv
} = ai, { TimeTree: Ex } = BS, { Plugin: $v } = ix, { debug: Wn } = Gu, { validatePlugin: Sx } = ax, { isBundledOrTypescriptPlugin: xx } = lx, { isPromiseLike: wx } = Wu, { thenify: Tv } = fx, { executeWithThenable: wp } = mx;
function Ze(e, t, r) {
  if (typeof e == "function" && arguments.length === 1 && (r = e, t = {}, e = null), typeof t == "function" && (r = t, t = {}), t = t || {}, t.autostart = t.autostart !== !1, t.timeout = Number(t.timeout) || 0, t.expose = t.expose || {}, !new.target)
    return new Ze(e, t, r);
  this._server = e || this, this._opts = t, e && this._expose(), this._current = [], this._error = null, this._lastUsed = null, this.setMaxListeners(0), r && this.once("start", r), this.started = !1, this.booted = !1, this.pluginTree = new Ex(), this._readyQ = co(this, Ov, 1), this._readyQ.pause(), this._readyQ.drain = () => {
    this.emit("start"), this._readyQ.drain = Rp;
  }, this._closeQ = co(this, $x, 1), this._closeQ.pause(), this._closeQ.drain = () => {
    this.emit("close"), this._closeQ.drain = Rp;
  }, this._doStart = null;
  const n = this;
  this._root = new $v(co(this, this._loadPluginNextTick, 1), function(i, o, a) {
    n._doStart = a, o.autostart && n.start();
  }, t, !1, 0), this._trackPluginLoading(this._root), this._loadPlugin(this._root, (s) => {
    Wn("root plugin ready");
    try {
      this.emit("preReady"), this._root = null;
    } catch (i) {
      s = s || this._error || i;
    }
    if (s) {
      if (this._error = s, this._readyQ.length() === 0)
        throw s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    } else
      this.booted = !0;
    this._readyQ.resume();
  });
}
<<<<<<< HEAD
gA(mt, mA);
mt.prototype.start = function() {
  return this.started = !0, process.nextTick(this._doStart), this;
};
mt.prototype.override = function(e, t, r) {
  return e;
};
mt.prototype[jS] = !0;
mt.prototype.use = function(e, t) {
  return this._lastUsed = this._addPlugin(e, t, !1), this;
};
mt.prototype._loadRegistered = function() {
  const e = this._current[0];
  return !this.started && !this.booted && process.nextTick(() => this._root.queue.resume()), e ? e.loadedSoFar() : Promise.resolve();
};
Object.defineProperty(mt.prototype, "then", { get: HS });
mt.prototype._addPlugin = function(e, t, r) {
  if (wA(e) && (e = e.default), EA(e), t = t || {}, this.booted)
    throw new yA();
  const n = this._current[0];
  let i = this._opts.timeout;
  if (!n.loaded && n.timeout > 0) {
    const o = Date.now() - n.startTime;
    i = n.timeout - (o + 3);
  }
  const s = new MS(cl(this, this._loadPluginNextTick, 1), e, t, r, i);
  if (this._trackPluginLoading(s), n.loaded)
    throw new Error(s.name, n.name);
  return n.enqueue(s, (o) => {
    o && (this._error = o);
  }), s;
};
mt.prototype._expose = function() {
  const t = this, r = t._server, {
    use: n = "use",
    after: i = "after",
    ready: s = "ready",
=======
gx(Ze, yx);
Ze.prototype.start = function() {
  return this.started = !0, process.nextTick(this._doStart), this;
};
Ze.prototype.override = function(e, t, r) {
  return e;
};
Ze.prototype[wv] = !0;
Ze.prototype.use = function(e, t) {
  return this._lastUsed = this._addPlugin(e, t, !1), this;
};
Ze.prototype._loadRegistered = function() {
  const e = this._current[0];
  return !this.started && !this.booted && process.nextTick(() => this._root.queue.resume()), e ? e.loadedSoFar() : Promise.resolve();
};
Object.defineProperty(Ze.prototype, "then", { get: Tv });
Ze.prototype._addPlugin = function(e, t, r) {
  if (xx(e) && (e = e.default), Sx(e), t = t || {}, this.booted)
    throw new vx();
  const n = this._current[0];
  let s = this._opts.timeout;
  if (!n.loaded && n.timeout > 0) {
    const o = Date.now() - n.startTime;
    s = n.timeout - (o + 3);
  }
  const i = new $v(co(this, this._loadPluginNextTick, 1), e, t, r, s);
  if (this._trackPluginLoading(i), n.loaded)
    throw new Error(i.name, n.name);
  return n.enqueue(i, (o) => {
    o && (this._error = o);
  }), i;
};
Ze.prototype._expose = function() {
  const t = this, r = t._server, {
    use: n = "use",
    after: s = "after",
    ready: i = "ready",
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    onClose: o = "onClose",
    close: a = "close"
  } = this._opts.expose;
  if (r[n])
<<<<<<< HEAD
    throw new Eo(n, "use");
  if (r[n] = function(c, u) {
    return t.use(c, u), this;
  }, r[i])
    throw new Eo(i, "after");
  if (r[i] = function(c) {
    return typeof c != "function" ? t._loadRegistered() : (t.after(qf(c, this)), this);
  }, r[s])
    throw new Eo(s, "ready");
  if (r[s] = function(c) {
    if (c && typeof c != "function")
      throw new Cs(s, typeof c);
    return t.ready(c ? qf(c, this) : void 0);
  }, r[o])
    throw new Eo(o, "onClose");
  if (r[o] = function(c) {
    if (typeof c != "function")
      throw new Cs(o, typeof c);
    return t.onClose($A(c, this)), this;
  }, r[a])
    throw new Eo(a, "close");
  if (r[a] = function(c) {
    if (c && typeof c != "function")
      throw new Cs(a, typeof c);
    return c ? (t.close(qf(c, this)), this) : t.close();
  }, r.then)
    throw new _A("then");
  Object.defineProperty(r, "then", { get: HS.bind(t) }), r[jS] = !0;
};
mt.prototype.after = function(e) {
  if (!e)
    return this._loadRegistered();
  this._addPlugin(t.bind(this), {}, !0);
  function t(r, n, i) {
    qS.call(this, e, i);
  }
  return this;
};
mt.prototype.onClose = function(e) {
  if (typeof e != "function")
    throw new Cs("onClose", typeof e);
  return e[US] = !0, this._closeQ.unshift(e, (t) => {
    t && (this._error = t);
  }), this;
};
mt.prototype.close = function(e) {
  let t;
  if (e) {
    if (typeof e != "function")
      throw new Cs("close", typeof e);
  } else
    t = new Promise(function(r, n) {
      e = function(i) {
        if (i)
          return n(i);
=======
    throw new ms(n, "use");
  if (r[n] = function(c, f) {
    return t.use(c, f), this;
  }, r[s])
    throw new ms(s, "after");
  if (r[s] = function(c) {
    return typeof c != "function" ? t._loadRegistered() : (t.after(sc(c, this)), this);
  }, r[i])
    throw new ms(i, "ready");
  if (r[i] = function(c) {
    if (c && typeof c != "function")
      throw new zn(i, typeof c);
    return t.ready(c ? sc(c, this) : void 0);
  }, r[o])
    throw new ms(o, "onClose");
  if (r[o] = function(c) {
    if (typeof c != "function")
      throw new zn(o, typeof c);
    return t.onClose(Tx(c, this)), this;
  }, r[a])
    throw new ms(a, "close");
  if (r[a] = function(c) {
    if (c && typeof c != "function")
      throw new zn(a, typeof c);
    return c ? (t.close(sc(c, this)), this) : t.close();
  }, r.then)
    throw new _x("then");
  Object.defineProperty(r, "then", { get: Tv.bind(t) }), r[wv] = !0;
};
Ze.prototype.after = function(e) {
  if (!e)
    return this._loadRegistered();
  this._addPlugin(t.bind(this), {}, !0);
  function t(r, n, s) {
    Ov.call(this, e, s);
  }
  return this;
};
Ze.prototype.onClose = function(e) {
  if (typeof e != "function")
    throw new zn("onClose", typeof e);
  return e[Rv] = !0, this._closeQ.unshift(e, (t) => {
    t && (this._error = t);
  }), this;
};
Ze.prototype.close = function(e) {
  let t;
  if (e) {
    if (typeof e != "function")
      throw new zn("close", typeof e);
  } else
    t = new Promise(function(r, n) {
      e = function(s) {
        if (s)
          return n(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        r();
      };
    });
  return this.ready(() => {
    this._error = null, this._closeQ.push(e), process.nextTick(this._closeQ.resume.bind(this._closeQ));
  }), t;
};
<<<<<<< HEAD
mt.prototype.ready = function(e) {
  if (e) {
    if (typeof e != "function")
      throw new Cs("ready", typeof e);
=======
Ze.prototype.ready = function(e) {
  if (e) {
    if (typeof e != "function")
      throw new zn("ready", typeof e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    this._readyQ.push(e), queueMicrotask(this.start.bind(this));
    return;
  }
  return new Promise((t, r) => {
<<<<<<< HEAD
    this._readyQ.push(i), this.start();
    const n = this._current[0].server;
    function i(s, o, a) {
      s ? r(s) : t(n), process.nextTick(a);
    }
  });
};
mt.prototype._trackPluginLoading = function(e) {
  var r;
  const t = ((r = this._current[0]) == null ? void 0 : r.name) || null;
  e.once("start", (n, i, s) => {
    const o = this.pluginTree.start(t || null, i, s);
    e.once("loaded", (a, c, u) => {
      this.pluginTree.stop(o, u);
    });
  });
};
mt.prototype.prettyPrint = function() {
  return this.pluginTree.prettyPrint();
};
mt.prototype.toJSON = function() {
  return this.pluginTree.toJSON();
};
mt.prototype._loadPlugin = function(e, t) {
  const r = this;
  if (SA(e.func)) {
=======
    this._readyQ.push(s), this.start();
    const n = this._current[0].server;
    function s(i, o, a) {
      i ? r(i) : t(n), process.nextTick(a);
    }
  });
};
Ze.prototype._trackPluginLoading = function(e) {
  var r;
  const t = ((r = this._current[0]) == null ? void 0 : r.name) || null;
  e.once("start", (n, s, i) => {
    const o = this.pluginTree.start(t || null, s, i);
    e.once("loaded", (a, c, f) => {
      this.pluginTree.stop(o, f);
    });
  });
};
Ze.prototype.prettyPrint = function() {
  return this.pluginTree.prettyPrint();
};
Ze.prototype.toJSON = function() {
  return this.pluginTree.toJSON();
};
Ze.prototype._loadPlugin = function(e, t) {
  const r = this;
  if (wx(e.func)) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    e.func.then((o) => {
      typeof o.default == "function" && (o = o.default), e.func = o, this._loadPlugin(e, t);
    }, t);
    return;
  }
  const n = r._current[0];
  if (r._current.unshift(e), r._error && !e.isAfter) {
<<<<<<< HEAD
    Us("skipping loading of plugin as instance errored and it is not an after", e.name), process.nextTick(s);
    return;
  }
  let i = n && n.server || r._server;
  if (!e.isAfter)
    try {
      i = r.override(i, e.func, e.options);
    } catch (o) {
      return Us("override errored", e.name), s(o);
    }
  e.exec(i, s);
  function s(o) {
=======
    Wn("skipping loading of plugin as instance errored and it is not an after", e.name), process.nextTick(i);
    return;
  }
  let s = n && n.server || r._server;
  if (!e.isAfter)
    try {
      s = r.override(s, e.func, e.options);
    } catch (o) {
      return Wn("override errored", e.name), i(o);
    }
  e.exec(s, i);
  function i(o) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    e.finish(o, (a) => {
      r._current.shift(), t(a);
    });
  }
};
<<<<<<< HEAD
mt.prototype._loadPluginNextTick = function(e, t) {
  process.nextTick(this._loadPlugin.bind(this), e, t);
};
function yv() {
}
function qS(e, t) {
  const r = this._server, n = this._error;
  if (this._error = null, e.length === 0)
    this._error = n, gv(e, [], t);
  else if (e.length === 1)
    gv(e, [n], t);
  else if (this._opts.timeout === 0) {
    const i = (s) => {
      this._error = s, t(this._error);
    };
    e.length === 2 ? e(n, i) : e(n, r, i);
  } else
    xA.call(this, e, n, r, t);
}
function xA(e, t, r, n) {
  const i = e.unwrappedName ?? e.name;
  Us("setting up ready timeout", i, this._opts.timeout);
  let s = setTimeout(() => {
    Us("timed out", i), s = null;
    const a = new vA(i);
=======
Ze.prototype._loadPluginNextTick = function(e, t) {
  process.nextTick(this._loadPlugin.bind(this), e, t);
};
function Rp() {
}
function Ov(e, t) {
  const r = this._server, n = this._error;
  if (this._error = null, e.length === 0)
    this._error = n, wp(e, [], t);
  else if (e.length === 1)
    wp(e, [n], t);
  else if (this._opts.timeout === 0) {
    const s = (i) => {
      this._error = i, t(this._error);
    };
    e.length === 2 ? e(n, s) : e(n, r, s);
  } else
    Rx.call(this, e, n, r, t);
}
function Rx(e, t, r, n) {
  const s = e.unwrappedName ?? e.name;
  Wn("setting up ready timeout", s, this._opts.timeout);
  let i = setTimeout(() => {
    Wn("timed out", s), i = null;
    const a = new bx(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    a.fn = e, this._error = a, n(a);
  }, this._opts.timeout);
  e.length === 2 ? e(t, o.bind(this)) : e(t, r, o.bind(this));
  function o(a) {
<<<<<<< HEAD
    s && (clearTimeout(s), this._error = a, n(this._error));
  }
}
function RA(e, t) {
  const r = this._server, n = e[US];
  if (e.length === 0 || e.length === 1) {
    let i;
    n ? i = e(r) : i = e(this._error), i && typeof i.then == "function" ? (Us("resolving close/onClose promise"), i.then(
      () => process.nextTick(t),
      (s) => process.nextTick(t, s)
    )) : process.nextTick(t);
  } else e.length === 2 ? e(n ? r : this._error, t) : n ? e(r, t) : e(this._error, r, t);
}
function $A(e, t) {
  return r.bind(t);
  function r(n, i) {
    let s;
    e.length === 0 ? (s = e(), s && s.then ? s.then(function() {
      process.nextTick(i);
    }, i) : process.nextTick(i)) : e.length === 1 ? (s = e(this), s && s.then ? s.then(function() {
      process.nextTick(i);
    }, i) : process.nextTick(i)) : e(this, i);
  }
}
function qf(e, t) {
  const r = n.bind(t);
  return r.unwrappedName = e.name, r;
  function n(i, s) {
    let o;
    e ? e.length === 0 ? (o = e(), o && o.then ? o.then(function() {
      process.nextTick(s, i);
    }, s) : process.nextTick(s, i)) : e.length === 1 ? (o = e(i), o && o.then ? o.then(function() {
      process.nextTick(s);
    }, s) : process.nextTick(s)) : e.length === 2 ? e(i, s) : e(i, this, s) : process.nextTick(s);
  }
}
var TA = mt;
const OA = {
=======
    i && (clearTimeout(i), this._error = a, n(this._error));
  }
}
function $x(e, t) {
  const r = this._server, n = e[Rv];
  if (e.length === 0 || e.length === 1) {
    let s;
    n ? s = e(r) : s = e(this._error), s && typeof s.then == "function" ? (Wn("resolving close/onClose promise"), s.then(
      () => process.nextTick(t),
      (i) => process.nextTick(t, i)
    )) : process.nextTick(t);
  } else e.length === 2 ? e(n ? r : this._error, t) : n ? e(r, t) : e(this._error, r, t);
}
function Tx(e, t) {
  return r.bind(t);
  function r(n, s) {
    let i;
    e.length === 0 ? (i = e(), i && i.then ? i.then(function() {
      process.nextTick(s);
    }, s) : process.nextTick(s)) : e.length === 1 ? (i = e(this), i && i.then ? i.then(function() {
      process.nextTick(s);
    }, s) : process.nextTick(s)) : e(this, s);
  }
}
function sc(e, t) {
  const r = n.bind(t);
  return r.unwrappedName = e.name, r;
  function n(s, i) {
    let o;
    e ? e.length === 0 ? (o = e(), o && o.then ? o.then(function() {
      process.nextTick(i, s);
    }, i) : process.nextTick(i, s)) : e.length === 1 ? (o = e(s), o && o.then ? o.then(function() {
      process.nextTick(i);
    }, i) : process.nextTick(i)) : e.length === 2 ? e(s, i) : e(s, this, i) : process.nextTick(i);
  }
}
var Ox = Ze;
const Cx = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  kAvvioBoot: Symbol("fastify.avvioBoot"),
  kChildren: Symbol("fastify.children"),
  kServerBindings: Symbol("fastify.serverBindings"),
  kBodyLimit: Symbol("fastify.bodyLimit"),
  kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
  kRoutePrefix: Symbol("fastify.routePrefix"),
  kLogLevel: Symbol("fastify.logLevel"),
  kLogSerializers: Symbol("fastify.logSerializers"),
  kHooks: Symbol("fastify.hooks"),
  kContentTypeParser: Symbol("fastify.contentTypeParser"),
  kState: Symbol("fastify.state"),
  kOptions: Symbol("fastify.options"),
  kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
  kPluginNameChain: Symbol("fastify.pluginNameChain"),
  kRouteContext: Symbol("fastify.context"),
  kGenReqId: Symbol("fastify.genReqId"),
  // Schema
  kSchemaController: Symbol("fastify.schemaController"),
  kSchemaHeaders: Symbol("headers-schema"),
  kSchemaParams: Symbol("params-schema"),
  kSchemaQuerystring: Symbol("querystring-schema"),
  kSchemaBody: Symbol("body-schema"),
  kSchemaResponse: Symbol("response-schema"),
  kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
  kSchemaVisited: Symbol("fastify.schemas.visited"),
  // Request
  kRequest: Symbol("fastify.Request"),
  kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
  kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
  kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
  kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
  // 404
  kFourOhFour: Symbol("fastify.404"),
  kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
  kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
  kFourOhFourContext: Symbol("fastify.404ContextKey"),
  kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
  // Reply
  kReply: Symbol("fastify.Reply"),
  kReplySerializer: Symbol("fastify.reply.serializer"),
  kReplyIsError: Symbol("fastify.reply.isError"),
  kReplyHeaders: Symbol("fastify.reply.headers"),
  kReplyTrailers: Symbol("fastify.reply.trailers"),
  kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
  kReplyHijacked: Symbol("fastify.reply.hijacked"),
  kReplyStartTime: Symbol("fastify.reply.startTime"),
  kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
  kReplyEndTime: Symbol("fastify.reply.endTime"),
  kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
  kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
  kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
  kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
  kTestInternals: Symbol("fastify.testInternals"),
  kErrorHandler: Symbol("fastify.errorHandler"),
  kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
  kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
  kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
  kRouteByFastify: Symbol("fastify.routeByFastify")
};
<<<<<<< HEAD
var Ft = OA, BS = {}, Eu = { exports: {} };
const { format: Bf } = zi;
function PA(e) {
  return zS({ ...e, name: "DeprecationWarning" });
}
function zS({ name: e, code: t, message: r, unlimited: n = !1 } = {}) {
=======
var ht = Cx, Cv = {}, ra = { exports: {} };
const { format: ic } = yn;
function Px(e) {
  return Pv({ ...e, name: "DeprecationWarning" });
}
function Pv({ name: e, code: t, message: r, unlimited: n = !1 } = {}) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!e) throw new Error("Warning name must not be empty");
  if (!t) throw new Error("Warning code must not be empty");
  if (!r) throw new Error("Warning message must not be empty");
  if (typeof n != "boolean") throw new Error("Warning opts.unlimited must be a boolean");
  t = t.toUpperCase();
<<<<<<< HEAD
  let i = {
    [e]: function(o, a, c) {
      s.emitted === !0 && s.unlimited !== !0 || (s.emitted = !0, process.emitWarning(s.format(o, a, c), s.name, s.code));
    }
  };
  n && (i = {
    [e]: function(o, a, c) {
      s.emitted = !0, process.emitWarning(s.format(o, a, c), s.name, s.code);
    }
  });
  const s = i[e];
  return s.emitted = !1, s.message = r, s.unlimited = n, s.code = t, s.format = function(o, a, c) {
    let u;
    return o && a && c ? u = Bf(r, o, a, c) : o && a ? u = Bf(r, o, a) : o ? u = Bf(r, o) : u = r, u;
  }, s;
}
const dm = { createWarning: zS, createDeprecation: PA };
Eu.exports = dm;
Eu.exports.default = dm;
Eu.exports.processWarning = dm;
var VS = Eu.exports;
const { createWarning: pm } = VS, CA = pm({
=======
  let s = {
    [e]: function(o, a, c) {
      i.emitted === !0 && i.unlimited !== !0 || (i.emitted = !0, process.emitWarning(i.format(o, a, c), i.name, i.code));
    }
  };
  n && (s = {
    [e]: function(o, a, c) {
      i.emitted = !0, process.emitWarning(i.format(o, a, c), i.name, i.code);
    }
  });
  const i = s[e];
  return i.emitted = !1, i.message = r, i.unlimited = n, i.code = t, i.format = function(o, a, c) {
    let f;
    return o && a && c ? f = ic(r, o, a, c) : o && a ? f = ic(r, o, a) : o ? f = ic(r, o) : f = r, f;
  }, i;
}
const Ku = { createWarning: Pv, createDeprecation: Px };
ra.exports = Ku;
ra.exports.default = Ku;
ra.exports.processWarning = Ku;
var Iv = ra.exports;
const { createWarning: Ju } = Iv, Ix = Ju({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  name: "FastifyWarning",
  code: "FSTWRN001",
  message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
  unlimited: !0
<<<<<<< HEAD
}), AA = pm({
=======
}), Nx = Ju({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  name: "FastifyWarning",
  code: "FSTWRN003",
  message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
  unlimited: !0
<<<<<<< HEAD
}), IA = pm({
=======
}), Ax = Ju({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  name: "FastifySecurity",
  code: "FSTSEC001",
  message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
  unlimited: !0
});
<<<<<<< HEAD
var hm = {
  FSTWRN001: CA,
  FSTWRN003: AA,
  FSTSEC001: IA
}, wu = { exports: {} };
const ie = LS, _i = {
  /**
   * Basic
   */
  FST_ERR_NOT_FOUND: ie(
=======
var Yu = {
  FSTWRN001: Ix,
  FSTWRN003: Nx,
  FSTSEC001: Ax
}, na = { exports: {} };
const te = Sv, Zr = {
  /**
   * Basic
   */
  FST_ERR_NOT_FOUND: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_NOT_FOUND",
    "Not Found",
    404
  ),
<<<<<<< HEAD
  FST_ERR_OPTIONS_NOT_OBJ: ie(
=======
  FST_ERR_OPTIONS_NOT_OBJ: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_OPTIONS_NOT_OBJ",
    "Options must be an object",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_QSP_NOT_FN: ie(
=======
  FST_ERR_QSP_NOT_FN: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_QSP_NOT_FN",
    "querystringParser option should be a function, instead got '%s'",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: ie(
=======
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
    "schemaController.bucket option should be a function, instead got '%s'",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: ie(
=======
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
    "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: ie(
=======
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
    "ajv.customOptions option should be an object, instead got '%s'",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: ie(
=======
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
    "ajv.plugins option should be an array, instead got '%s'",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_VALIDATION: ie(
=======
  FST_ERR_VALIDATION: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_VALIDATION",
    "%s",
    400
  ),
<<<<<<< HEAD
  FST_ERR_LISTEN_OPTIONS_INVALID: ie(
=======
  FST_ERR_LISTEN_OPTIONS_INVALID: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_LISTEN_OPTIONS_INVALID",
    "Invalid listen options: '%s'",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_ERROR_HANDLER_NOT_FN: ie(
=======
  FST_ERR_ERROR_HANDLER_NOT_FN: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ERROR_HANDLER_NOT_FN",
    "Error Handler must be a function",
    500,
    TypeError
  ),
  /**
   * ContentTypeParser
  */
<<<<<<< HEAD
  FST_ERR_CTP_ALREADY_PRESENT: ie(
    "FST_ERR_CTP_ALREADY_PRESENT",
    "Content type parser '%s' already present."
  ),
  FST_ERR_CTP_INVALID_TYPE: ie(
=======
  FST_ERR_CTP_ALREADY_PRESENT: te(
    "FST_ERR_CTP_ALREADY_PRESENT",
    "Content type parser '%s' already present."
  ),
  FST_ERR_CTP_INVALID_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_INVALID_TYPE",
    "The content type should be a string or a RegExp",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_CTP_EMPTY_TYPE: ie(
=======
  FST_ERR_CTP_EMPTY_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_EMPTY_TYPE",
    "The content type cannot be an empty string",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_CTP_INVALID_HANDLER: ie(
=======
  FST_ERR_CTP_INVALID_HANDLER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_INVALID_HANDLER",
    "The content type handler should be a function",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_CTP_INVALID_PARSE_TYPE: ie(
=======
  FST_ERR_CTP_INVALID_PARSE_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_INVALID_PARSE_TYPE",
    "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_CTP_BODY_TOO_LARGE: ie(
=======
  FST_ERR_CTP_BODY_TOO_LARGE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_BODY_TOO_LARGE",
    "Request body is too large",
    413,
    RangeError
  ),
<<<<<<< HEAD
  FST_ERR_CTP_INVALID_MEDIA_TYPE: ie(
=======
  FST_ERR_CTP_INVALID_MEDIA_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_INVALID_MEDIA_TYPE",
    "Unsupported Media Type: %s",
    415
  ),
<<<<<<< HEAD
  FST_ERR_CTP_INVALID_CONTENT_LENGTH: ie(
=======
  FST_ERR_CTP_INVALID_CONTENT_LENGTH: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
    "Request body size did not match Content-Length",
    400,
    RangeError
  ),
<<<<<<< HEAD
  FST_ERR_CTP_EMPTY_JSON_BODY: ie(
=======
  FST_ERR_CTP_EMPTY_JSON_BODY: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_EMPTY_JSON_BODY",
    "Body cannot be empty when content-type is set to 'application/json'",
    400
  ),
<<<<<<< HEAD
  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: ie(
=======
  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
    'Cannot call "%s" when fastify instance is already started!',
    400
  ),
  /**
   * decorate
  */
<<<<<<< HEAD
  FST_ERR_DEC_ALREADY_PRESENT: ie(
    "FST_ERR_DEC_ALREADY_PRESENT",
    "The decorator '%s' has already been added!"
  ),
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: ie(
=======
  FST_ERR_DEC_ALREADY_PRESENT: te(
    "FST_ERR_DEC_ALREADY_PRESENT",
    "The decorator '%s' has already been added!"
  ),
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
    "The dependencies of decorator '%s' must be of type Array.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_DEC_MISSING_DEPENDENCY: ie(
    "FST_ERR_DEC_MISSING_DEPENDENCY",
    "The decorator is missing dependency '%s'."
  ),
  FST_ERR_DEC_AFTER_START: ie(
    "FST_ERR_DEC_AFTER_START",
    "The decorator '%s' has been added after start!"
  ),
  FST_ERR_DEC_REFERENCE_TYPE: ie(
=======
  FST_ERR_DEC_MISSING_DEPENDENCY: te(
    "FST_ERR_DEC_MISSING_DEPENDENCY",
    "The decorator is missing dependency '%s'."
  ),
  FST_ERR_DEC_AFTER_START: te(
    "FST_ERR_DEC_AFTER_START",
    "The decorator '%s' has been added after start!"
  ),
  FST_ERR_DEC_REFERENCE_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_DEC_REFERENCE_TYPE",
    "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
  ),
  /**
   * hooks
  */
<<<<<<< HEAD
  FST_ERR_HOOK_INVALID_TYPE: ie(
=======
  FST_ERR_HOOK_INVALID_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_HOOK_INVALID_TYPE",
    "The hook name must be a string",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_HOOK_INVALID_HANDLER: ie(
=======
  FST_ERR_HOOK_INVALID_HANDLER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_HOOK_INVALID_HANDLER",
    "%s hook should be a function, instead got %s",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: ie(
=======
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
    "Async function has too many arguments. Async hooks should not use the 'done' argument.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_HOOK_NOT_SUPPORTED: ie(
=======
  FST_ERR_HOOK_NOT_SUPPORTED: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_HOOK_NOT_SUPPORTED",
    "%s hook not supported!",
    500,
    TypeError
  ),
  /**
   * Middlewares
   */
<<<<<<< HEAD
  FST_ERR_MISSING_MIDDLEWARE: ie(
=======
  FST_ERR_MISSING_MIDDLEWARE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_MISSING_MIDDLEWARE",
    "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
    500
  ),
<<<<<<< HEAD
  FST_ERR_HOOK_TIMEOUT: ie(
=======
  FST_ERR_HOOK_TIMEOUT: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_HOOK_TIMEOUT",
    "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  /**
   * logger
  */
<<<<<<< HEAD
  FST_ERR_LOG_INVALID_DESTINATION: ie(
    "FST_ERR_LOG_INVALID_DESTINATION",
    "Cannot specify both logger.stream and logger.file options"
  ),
  FST_ERR_LOG_INVALID_LOGGER: ie(
=======
  FST_ERR_LOG_INVALID_DESTINATION: te(
    "FST_ERR_LOG_INVALID_DESTINATION",
    "Cannot specify both logger.stream and logger.file options"
  ),
  FST_ERR_LOG_INVALID_LOGGER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_LOG_INVALID_LOGGER",
    "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: ie(
=======
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
    "loggerInstance only accepts a logger instance.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: ie(
=======
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
    "logger options only accepts a configuration object.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: ie(
=======
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
    "You cannot provide both logger and loggerInstance. Please provide only one.",
    500,
    TypeError
  ),
  /**
   * reply
  */
<<<<<<< HEAD
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: ie(
=======
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
    "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: ie(
    "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
    "Response.body is already consumed."
  ),
  FST_ERR_REP_READABLE_STREAM_LOCKED: ie(
    "FST_ERR_REP_READABLE_STREAM_LOCKED",
    "ReadableStream was locked. You should call releaseLock() method on reader before sending."
  ),
  FST_ERR_REP_ALREADY_SENT: ie(
    "FST_ERR_REP_ALREADY_SENT",
    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
  ),
  FST_ERR_REP_SENT_VALUE: ie(
=======
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: te(
    "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
    "Response.body is already consumed."
  ),
  FST_ERR_REP_READABLE_STREAM_LOCKED: te(
    "FST_ERR_REP_READABLE_STREAM_LOCKED",
    "ReadableStream was locked. You should call releaseLock() method on reader before sending."
  ),
  FST_ERR_REP_ALREADY_SENT: te(
    "FST_ERR_REP_ALREADY_SENT",
    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
  ),
  FST_ERR_REP_SENT_VALUE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_REP_SENT_VALUE",
    "The only possible value for reply.sent is true.",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_SEND_INSIDE_ONERR: ie(
    "FST_ERR_SEND_INSIDE_ONERR",
    "You cannot use `send` inside the `onError` hook"
  ),
  FST_ERR_SEND_UNDEFINED_ERR: ie(
    "FST_ERR_SEND_UNDEFINED_ERR",
    "Undefined error has occurred"
  ),
  FST_ERR_BAD_STATUS_CODE: ie(
    "FST_ERR_BAD_STATUS_CODE",
    "Called reply with an invalid status code: %s"
  ),
  FST_ERR_BAD_TRAILER_NAME: ie(
    "FST_ERR_BAD_TRAILER_NAME",
    "Called reply.trailer with an invalid header name: %s"
  ),
  FST_ERR_BAD_TRAILER_VALUE: ie(
    "FST_ERR_BAD_TRAILER_VALUE",
    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
  ),
  FST_ERR_FAILED_ERROR_SERIALIZATION: ie(
    "FST_ERR_FAILED_ERROR_SERIALIZATION",
    "Failed to serialize an error. Error: %s. Original error: %s"
  ),
  FST_ERR_MISSING_SERIALIZATION_FN: ie(
    "FST_ERR_MISSING_SERIALIZATION_FN",
    'Missing serialization function. Key "%s"'
  ),
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: ie(
    "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
    'Missing serialization function. Key "%s:%s"'
  ),
  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: ie(
=======
  FST_ERR_SEND_INSIDE_ONERR: te(
    "FST_ERR_SEND_INSIDE_ONERR",
    "You cannot use `send` inside the `onError` hook"
  ),
  FST_ERR_SEND_UNDEFINED_ERR: te(
    "FST_ERR_SEND_UNDEFINED_ERR",
    "Undefined error has occurred"
  ),
  FST_ERR_BAD_STATUS_CODE: te(
    "FST_ERR_BAD_STATUS_CODE",
    "Called reply with an invalid status code: %s"
  ),
  FST_ERR_BAD_TRAILER_NAME: te(
    "FST_ERR_BAD_TRAILER_NAME",
    "Called reply.trailer with an invalid header name: %s"
  ),
  FST_ERR_BAD_TRAILER_VALUE: te(
    "FST_ERR_BAD_TRAILER_VALUE",
    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
  ),
  FST_ERR_FAILED_ERROR_SERIALIZATION: te(
    "FST_ERR_FAILED_ERROR_SERIALIZATION",
    "Failed to serialize an error. Error: %s. Original error: %s"
  ),
  FST_ERR_MISSING_SERIALIZATION_FN: te(
    "FST_ERR_MISSING_SERIALIZATION_FN",
    'Missing serialization function. Key "%s"'
  ),
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: te(
    "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
    'Missing serialization function. Key "%s:%s"'
  ),
  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
    'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
  ),
  /**
   * schemas
  */
<<<<<<< HEAD
  FST_ERR_SCH_MISSING_ID: ie(
    "FST_ERR_SCH_MISSING_ID",
    "Missing schema $id property"
  ),
  FST_ERR_SCH_ALREADY_PRESENT: ie(
    "FST_ERR_SCH_ALREADY_PRESENT",
    "Schema with id '%s' already declared!"
  ),
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: ie(
    "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
    "Schema is missing for the content type '%s'"
  ),
  FST_ERR_SCH_DUPLICATE: ie(
    "FST_ERR_SCH_DUPLICATE",
    "Schema with '%s' already present!"
  ),
  FST_ERR_SCH_VALIDATION_BUILD: ie(
    "FST_ERR_SCH_VALIDATION_BUILD",
    "Failed building the validation schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_SERIALIZATION_BUILD: ie(
    "FST_ERR_SCH_SERIALIZATION_BUILD",
    "Failed building the serialization schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: ie(
=======
  FST_ERR_SCH_MISSING_ID: te(
    "FST_ERR_SCH_MISSING_ID",
    "Missing schema $id property"
  ),
  FST_ERR_SCH_ALREADY_PRESENT: te(
    "FST_ERR_SCH_ALREADY_PRESENT",
    "Schema with id '%s' already declared!"
  ),
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: te(
    "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
    "Schema is missing for the content type '%s'"
  ),
  FST_ERR_SCH_DUPLICATE: te(
    "FST_ERR_SCH_DUPLICATE",
    "Schema with '%s' already present!"
  ),
  FST_ERR_SCH_VALIDATION_BUILD: te(
    "FST_ERR_SCH_VALIDATION_BUILD",
    "Failed building the validation schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_SERIALIZATION_BUILD: te(
    "FST_ERR_SCH_SERIALIZATION_BUILD",
    "Failed building the serialization schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
    'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
  ),
  /**
   * http2
   */
<<<<<<< HEAD
  FST_ERR_HTTP2_INVALID_VERSION: ie(
=======
  FST_ERR_HTTP2_INVALID_VERSION: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_HTTP2_INVALID_VERSION",
    "HTTP2 is available only from node >= 8.8.1"
  ),
  /**
   * initialConfig
   */
<<<<<<< HEAD
  FST_ERR_INIT_OPTS_INVALID: ie(
    "FST_ERR_INIT_OPTS_INVALID",
    "Invalid initialization options: '%s'"
  ),
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: ie(
=======
  FST_ERR_INIT_OPTS_INVALID: te(
    "FST_ERR_INIT_OPTS_INVALID",
    "Invalid initialization options: '%s'"
  ),
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
    "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
  ),
  /**
   * router
   */
<<<<<<< HEAD
  FST_ERR_DUPLICATED_ROUTE: ie(
    "FST_ERR_DUPLICATED_ROUTE",
    "Method '%s' already declared for route '%s'"
  ),
  FST_ERR_BAD_URL: ie(
=======
  FST_ERR_DUPLICATED_ROUTE: te(
    "FST_ERR_DUPLICATED_ROUTE",
    "Method '%s' already declared for route '%s'"
  ),
  FST_ERR_BAD_URL: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_BAD_URL",
    "'%s' is not a valid url component",
    400,
    URIError
  ),
<<<<<<< HEAD
  FST_ERR_ASYNC_CONSTRAINT: ie(
=======
  FST_ERR_ASYNC_CONSTRAINT: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ASYNC_CONSTRAINT",
    "Unexpected error from async constraint",
    500
  ),
<<<<<<< HEAD
  FST_ERR_INVALID_URL: ie(
=======
  FST_ERR_INVALID_URL: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_INVALID_URL",
    "URL must be a string. Received '%s'",
    400,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: ie(
=======
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
    'Options for "%s:%s" route must be an object',
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_DUPLICATED_HANDLER: ie(
=======
  FST_ERR_ROUTE_DUPLICATED_HANDLER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_DUPLICATED_HANDLER",
    'Duplicate handler for "%s:%s" route is not allowed!',
    500
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_HANDLER_NOT_FN: ie(
=======
  FST_ERR_ROUTE_HANDLER_NOT_FN: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_HANDLER_NOT_FN",
    "Error Handler for %s:%s route, if defined, must be a function",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_MISSING_HANDLER: ie(
=======
  FST_ERR_ROUTE_MISSING_HANDLER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_MISSING_HANDLER",
    'Missing handler function for "%s:%s" route.',
    500
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_METHOD_INVALID: ie(
=======
  FST_ERR_ROUTE_METHOD_INVALID: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_METHOD_INVALID",
    "Provided method is invalid!",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: ie(
=======
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
    "%s method is not supported.",
    500
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: ie(
=======
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
    "Body validation schema for %s:%s route is not supported!",
    500
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: ie(
=======
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
    "'bodyLimit' option must be an integer > 0. Got '%s'",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_ROUTE_REWRITE_NOT_STR: ie(
=======
  FST_ERR_ROUTE_REWRITE_NOT_STR: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_ROUTE_REWRITE_NOT_STR",
    'Rewrite url for "%s" needs to be of type "string" but received "%s"',
    500,
    TypeError
  ),
  /**
   *  again listen when close server
   */
<<<<<<< HEAD
  FST_ERR_REOPENED_CLOSE_SERVER: ie(
    "FST_ERR_REOPENED_CLOSE_SERVER",
    "Fastify has already been closed and cannot be reopened"
  ),
  FST_ERR_REOPENED_SERVER: ie(
    "FST_ERR_REOPENED_SERVER",
    "Fastify is already listening"
  ),
  FST_ERR_INSTANCE_ALREADY_LISTENING: ie(
=======
  FST_ERR_REOPENED_CLOSE_SERVER: te(
    "FST_ERR_REOPENED_CLOSE_SERVER",
    "Fastify has already been closed and cannot be reopened"
  ),
  FST_ERR_REOPENED_SERVER: te(
    "FST_ERR_REOPENED_SERVER",
    "Fastify is already listening"
  ),
  FST_ERR_INSTANCE_ALREADY_LISTENING: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_INSTANCE_ALREADY_LISTENING",
    "Fastify instance is already listening. %s"
  ),
  /**
   * plugin
   */
<<<<<<< HEAD
  FST_ERR_PLUGIN_VERSION_MISMATCH: ie(
    "FST_ERR_PLUGIN_VERSION_MISMATCH",
    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
  ),
  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: ie(
    "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
    "The decorator '%s'%s is not present in %s"
  ),
  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: ie(
=======
  FST_ERR_PLUGIN_VERSION_MISMATCH: te(
    "FST_ERR_PLUGIN_VERSION_MISMATCH",
    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
  ),
  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: te(
    "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
    "The decorator '%s'%s is not present in %s"
  ),
  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
    "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
    500,
    TypeError
  ),
  /**
   *  Avvio Errors
   */
<<<<<<< HEAD
  FST_ERR_PLUGIN_CALLBACK_NOT_FN: ie(
=======
  FST_ERR_PLUGIN_CALLBACK_NOT_FN: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
    "fastify-plugin: %s",
    500,
    TypeError
  ),
<<<<<<< HEAD
  FST_ERR_PLUGIN_NOT_VALID: ie(
    "FST_ERR_PLUGIN_NOT_VALID",
    "fastify-plugin: %s"
  ),
  FST_ERR_ROOT_PLG_BOOTED: ie(
    "FST_ERR_ROOT_PLG_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PARENT_PLUGIN_BOOTED: ie(
    "FST_ERR_PARENT_PLUGIN_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PLUGIN_TIMEOUT: ie(
=======
  FST_ERR_PLUGIN_NOT_VALID: te(
    "FST_ERR_PLUGIN_NOT_VALID",
    "fastify-plugin: %s"
  ),
  FST_ERR_ROOT_PLG_BOOTED: te(
    "FST_ERR_ROOT_PLG_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PARENT_PLUGIN_BOOTED: te(
    "FST_ERR_PARENT_PLUGIN_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PLUGIN_TIMEOUT: te(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "FST_ERR_PLUGIN_TIMEOUT",
    "fastify-plugin: %s"
  )
};
<<<<<<< HEAD
function NA(e, t) {
  return t.cause = e, t;
}
wu.exports = _i;
wu.exports.appendStackTrace = NA;
wu.exports.AVVIO_ERRORS_MAP = {
  AVV_ERR_CALLBACK_NOT_FN: _i.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
  AVV_ERR_PLUGIN_NOT_VALID: _i.FST_ERR_PLUGIN_NOT_VALID,
  AVV_ERR_ROOT_PLG_BOOTED: _i.FST_ERR_ROOT_PLG_BOOTED,
  AVV_ERR_PARENT_PLG_LOADED: _i.FST_ERR_PARENT_PLUGIN_BOOTED,
  AVV_ERR_READY_TIMEOUT: _i.FST_ERR_PLUGIN_TIMEOUT,
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: _i.FST_ERR_PLUGIN_TIMEOUT
};
var Wt = wu.exports;
const kA = [
=======
function kx(e, t) {
  return t.cause = e, t;
}
na.exports = Zr;
na.exports.appendStackTrace = kx;
na.exports.AVVIO_ERRORS_MAP = {
  AVV_ERR_CALLBACK_NOT_FN: Zr.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
  AVV_ERR_PLUGIN_NOT_VALID: Zr.FST_ERR_PLUGIN_NOT_VALID,
  AVV_ERR_ROOT_PLG_BOOTED: Zr.FST_ERR_ROOT_PLG_BOOTED,
  AVV_ERR_PARENT_PLG_LOADED: Zr.FST_ERR_PARENT_PLUGIN_BOOTED,
  AVV_ERR_READY_TIMEOUT: Zr.FST_ERR_PLUGIN_TIMEOUT,
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: Zr.FST_ERR_PLUGIN_TIMEOUT
};
var _t = na.exports;
const Lx = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "onRoute",
  "onRegister",
  "onReady",
  "onListen",
  "preClose",
  "onClose"
<<<<<<< HEAD
], GS = [
=======
], Nv = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "onTimeout",
  "onRequest",
  "preParsing",
  "preValidation",
  "preSerialization",
  "preHandler",
  "onSend",
  "onResponse",
  "onError",
  "onRequestAbort"
<<<<<<< HEAD
], DA = GS.concat(kA), {
  FST_ERR_HOOK_INVALID_TYPE: LA,
  FST_ERR_HOOK_INVALID_HANDLER: FA,
  FST_ERR_SEND_UNDEFINED_ERR: Su,
  FST_ERR_HOOK_TIMEOUT: jA,
  FST_ERR_HOOK_NOT_SUPPORTED: UA,
  AVVIO_ERRORS_MAP: vv,
  appendStackTrace: _v
} = Wt, {
  kChildren: Go,
  kHooks: WS,
  kRequestPayloadStream: bv
} = Ft;
function Ua() {
  this.onRequest = [], this.preParsing = [], this.preValidation = [], this.preSerialization = [], this.preHandler = [], this.onResponse = [], this.onSend = [], this.onError = [], this.onRoute = [], this.onRegister = [], this.onReady = [], this.onListen = [], this.onTimeout = [], this.onRequestAbort = [], this.preClose = [];
}
Ua.prototype = /* @__PURE__ */ Object.create(null);
Ua.prototype.validate = function(e, t) {
  if (typeof e != "string") throw new LA();
  if (Array.isArray(this[e]) === !1)
    throw new UA(e);
  if (typeof t != "function") throw new FA(e, Object.prototype.toString.call(t));
};
Ua.prototype.add = function(e, t) {
  this.validate(e, t), this[e].push(t);
};
function MA(e) {
  const t = new Ua();
  return t.onRequest = e.onRequest.slice(), t.preParsing = e.preParsing.slice(), t.preValidation = e.preValidation.slice(), t.preSerialization = e.preSerialization.slice(), t.preHandler = e.preHandler.slice(), t.onSend = e.onSend.slice(), t.onResponse = e.onResponse.slice(), t.onError = e.onError.slice(), t.onRoute = e.onRoute.slice(), t.onRegister = e.onRegister.slice(), t.onTimeout = e.onTimeout.slice(), t.onRequestAbort = e.onRequestAbort.slice(), t.onReady = [], t.onListen = [], t.preClose = [], t;
}
function KS(e, t, r, n) {
  const i = r[WS][e];
  let s = 0, o = 0;
  c();
  function a(l) {
    var p;
    const f = (p = i[s - 1]) == null ? void 0 : p.name, m = f ? ` "${f}"` : "";
    if (l) {
      l.code === "AVV_ERR_READY_TIMEOUT" ? l = _v(l, new jA(e, m)) : l = vv[l.code] != null ? _v(l, new vv[l.code](l.message)) : l, n(l);
=======
], jx = Nv.concat(Lx), {
  FST_ERR_HOOK_INVALID_TYPE: Dx,
  FST_ERR_HOOK_INVALID_HANDLER: Fx,
  FST_ERR_SEND_UNDEFINED_ERR: sa,
  FST_ERR_HOOK_TIMEOUT: Mx,
  FST_ERR_HOOK_NOT_SUPPORTED: zx,
  AVVIO_ERRORS_MAP: $p,
  appendStackTrace: Tp
} = _t, {
  kChildren: ks,
  kHooks: Av,
  kRequestPayloadStream: Op
} = ht;
function ci() {
  this.onRequest = [], this.preParsing = [], this.preValidation = [], this.preSerialization = [], this.preHandler = [], this.onResponse = [], this.onSend = [], this.onError = [], this.onRoute = [], this.onRegister = [], this.onReady = [], this.onListen = [], this.onTimeout = [], this.onRequestAbort = [], this.preClose = [];
}
ci.prototype = /* @__PURE__ */ Object.create(null);
ci.prototype.validate = function(e, t) {
  if (typeof e != "string") throw new Dx();
  if (Array.isArray(this[e]) === !1)
    throw new zx(e);
  if (typeof t != "function") throw new Fx(e, Object.prototype.toString.call(t));
};
ci.prototype.add = function(e, t) {
  this.validate(e, t), this[e].push(t);
};
function Ux(e) {
  const t = new ci();
  return t.onRequest = e.onRequest.slice(), t.preParsing = e.preParsing.slice(), t.preValidation = e.preValidation.slice(), t.preSerialization = e.preSerialization.slice(), t.preHandler = e.preHandler.slice(), t.onSend = e.onSend.slice(), t.onResponse = e.onResponse.slice(), t.onError = e.onError.slice(), t.onRoute = e.onRoute.slice(), t.onRegister = e.onRegister.slice(), t.onTimeout = e.onTimeout.slice(), t.onRequestAbort = e.onRequestAbort.slice(), t.onReady = [], t.onListen = [], t.preClose = [], t;
}
function kv(e, t, r, n) {
  const s = r[Av][e];
  let i = 0, o = 0;
  c();
  function a(l) {
    var p;
    const d = (p = s[i - 1]) == null ? void 0 : p.name, g = d ? ` "${d}"` : "";
    if (l) {
      l.code === "AVV_ERR_READY_TIMEOUT" ? l = Tp(l, new Mx(e, g)) : l = $p[l.code] != null ? Tp(l, new $p[l.code](l.message)) : l, n(l);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    n();
  }
  function c(l) {
    if (l) {
      a(l);
      return;
    }
<<<<<<< HEAD
    if (s === i.length && o === r[Go].length) {
      s === 0 && o === 0 ? a() : t(function(m, p) {
        a(m), p(m);
      });
      return;
    }
    if (s === i.length && o < r[Go].length) {
      const f = r[Go][o++];
      KS(e, t, f, c);
      return;
    }
    t(u(i[s++], r)), c();
  }
  function u(l, f) {
    return function(m, p) {
      if (m) {
        p(m);
=======
    if (i === s.length && o === r[ks].length) {
      i === 0 && o === 0 ? a() : t(function(g, p) {
        a(g), p(g);
      });
      return;
    }
    if (i === s.length && o < r[ks].length) {
      const d = r[ks][o++];
      kv(e, t, d, c);
      return;
    }
    t(f(s[i++], r)), c();
  }
  function f(l, d) {
    return function(g, p) {
      if (g) {
        p(g);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return;
      }
      if (l.length === 1) {
        try {
<<<<<<< HEAD
          l.call(f, p);
        } catch (d) {
          p(d);
=======
          l.call(d, p);
        } catch (u) {
          p(u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
        return;
      }
      try {
<<<<<<< HEAD
        const d = l.call(f);
        if (d && typeof d.then == "function") {
          d.then(p, p);
          return;
        }
      } catch (d) {
        m = d;
      }
      p(m);
    };
  }
}
function YS(e) {
  const t = e[WS].onListen, r = t.length;
  let n = 0, i = 0;
  s();
  function s(a) {
    if (a && e.log.error(a), n === r) {
      for (; i < e[Go].length; ) {
        const c = e[Go][i++];
        YS(c);
      }
      return;
    }
    o(t[n++], e, s);
  }
  async function o(a, c, u) {
    if (a.length === 1) {
      try {
        a.call(c, u);
      } catch (l) {
        u(l);
=======
        const u = l.call(d);
        if (u && typeof u.then == "function") {
          u.then(p, p);
          return;
        }
      } catch (u) {
        g = u;
      }
      p(g);
    };
  }
}
function Lv(e) {
  const t = e[Av].onListen, r = t.length;
  let n = 0, s = 0;
  i();
  function i(a) {
    if (a && e.log.error(a), n === r) {
      for (; s < e[ks].length; ) {
        const c = e[ks][s++];
        Lv(c);
      }
      return;
    }
    o(t[n++], e, i);
  }
  async function o(a, c, f) {
    if (a.length === 1) {
      try {
        a.call(c, f);
      } catch (l) {
        f(l);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      return;
    }
    try {
      const l = a.call(c);
      if (l && typeof l.then == "function") {
<<<<<<< HEAD
        l.then(u, u);
        return;
      }
      u();
    } catch (l) {
      u(l);
    }
  }
}
function Ma(e) {
  return function(r, n, i, s) {
    let o = 0;
    function a(l) {
      if (l || o === r.length) {
        s(l, n, i);
        return;
      }
      let f;
      try {
        f = e(r[o++], n, i, a);
      } catch (m) {
        s(m, n, i);
        return;
      }
      f && typeof f.then == "function" && f.then(c, u);
=======
        l.then(f, f);
        return;
      }
      f();
    } catch (l) {
      f(l);
    }
  }
}
function li(e) {
  return function(r, n, s, i) {
    let o = 0;
    function a(l) {
      if (l || o === r.length) {
        i(l, n, s);
        return;
      }
      let d;
      try {
        d = e(r[o++], n, s, a);
      } catch (g) {
        i(g, n, s);
        return;
      }
      d && typeof d.then == "function" && d.then(c, f);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    function c() {
      a();
    }
<<<<<<< HEAD
    function u(l) {
      l || (l = new Su()), s(l, n, i);
=======
    function f(l) {
      l || (l = new sa()), i(l, n, s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    a();
  };
}
<<<<<<< HEAD
function HA(e, t, r, n) {
  return e(t, r, n);
}
const qA = Ma(HA), BA = Ma(xu), zA = Ma(xu), VA = Ma(xu), GA = Ma(xu);
function JS(e, t, r, n, i) {
  let s = 0;
  function o(u, l) {
    if (u) {
      i(u, t, r, n);
      return;
    }
    if (l !== void 0 && (n = l), s === e.length) {
      i(null, t, r, n);
      return;
    }
    let f;
    try {
      f = e[s++](t, r, n, o);
    } catch (m) {
      i(m, t, r);
      return;
    }
    f && typeof f.then == "function" && f.then(a, c);
  }
  function a(u) {
    o(null, u);
  }
  function c(u) {
    u || (u = new Su()), i(u, t, r, n);
  }
  o();
}
const WA = JS;
function KA(e, t, r, n) {
  let i = 0;
  function s(c, u) {
    if (r.sent)
      return;
    if (u !== void 0 && (t[bv] = u), c || i === e.length) {
=======
function qx(e, t, r, n) {
  return e(t, r, n);
}
const Hx = li(qx), Bx = li(ia), Vx = li(ia), Gx = li(ia), Wx = li(ia);
function jv(e, t, r, n, s) {
  let i = 0;
  function o(f, l) {
    if (f) {
      s(f, t, r, n);
      return;
    }
    if (l !== void 0 && (n = l), i === e.length) {
      s(null, t, r, n);
      return;
    }
    let d;
    try {
      d = e[i++](t, r, n, o);
    } catch (g) {
      s(g, t, r);
      return;
    }
    d && typeof d.then == "function" && d.then(a, c);
  }
  function a(f) {
    o(null, f);
  }
  function c(f) {
    f || (f = new sa()), s(f, t, r, n);
  }
  o();
}
const Kx = jv;
function Jx(e, t, r, n) {
  let s = 0;
  function i(c, f) {
    if (r.sent)
      return;
    if (f !== void 0 && (t[Op] = f), c || s === e.length) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      n(c, t, r);
      return;
    }
    let l;
    try {
<<<<<<< HEAD
      l = e[i++](t, r, t[bv], s);
    } catch (f) {
      n(f, t, r);
=======
      l = e[s++](t, r, t[Op], i);
    } catch (d) {
      n(d, t, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    l && typeof l.then == "function" && l.then(o, a);
  }
  function o(c) {
<<<<<<< HEAD
    s(null, c);
  }
  function a(c) {
    c || (c = new Su()), n(c, t, r);
  }
  s();
}
function YA(e, t, r) {
  let n = 0;
  function i(a) {
=======
    i(null, c);
  }
  function a(c) {
    c || (c = new sa()), n(c, t, r);
  }
  i();
}
function Yx(e, t, r) {
  let n = 0;
  function s(a) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (a || n === e.length) {
      r(a, t);
      return;
    }
    let c;
    try {
<<<<<<< HEAD
      c = e[n++](t, i);
    } catch (u) {
      r(u, t);
      return;
    }
    c && typeof c.then == "function" && c.then(s, o);
  }
  function s() {
    i();
  }
  function o(a) {
    a || (a = new Su()), r(a, t);
  }
  i();
}
function xu(e, t, r, n) {
  if (r.sent !== !0)
    return e(t, r, n);
}
var Wi = {
  Hooks: Ua,
  buildHooks: MA,
  preParsingHookRunner: KA,
  onResponseHookRunner: qA,
  onSendHookRunner: JS,
  preSerializationHookRunner: WA,
  onRequestAbortHookRunner: YA,
  hookRunnerApplication: KS,
  onListenHookRunner: YS,
  preHandlerHookRunner: zA,
  preValidationHookRunner: BA,
  onRequestHookRunner: GA,
  onTimeoutHookRunner: VA,
  lifecycleHooks: GS,
  supportedHooks: DA
};
const JA = mu, XA = mC, ZA = gC, QA = IS, { kState: Vt, kOptions: eI, kServerBindings: tI } = Ft, { FSTWRN003: rI } = hm, { onListenHookRunner: Ec } = Wi, {
  FST_ERR_HTTP2_INVALID_VERSION: nI,
  FST_ERR_REOPENED_CLOSE_SERVER: XS,
  FST_ERR_REOPENED_SERVER: ZS,
  FST_ERR_LISTEN_OPTIONS_INVALID: iI
} = Wt;
BS.createServer = sI;
function QS(e) {
  return `Server listening at ${e}`;
}
function sI(e, t) {
  const r = tx(e, t);
  function n(i = { port: 0, host: "localhost" }, s = void 0) {
    if (typeof s == "function" && (s.constructor.name === "AsyncFunction" && rI("listen method"), i.cb = s), i.signal) {
      if (typeof i.signal.on != "function" && typeof i.signal.addEventListener != "function")
        throw new iI("Invalid options.signal");
      if (i.signal.aborted)
=======
      c = e[n++](t, s);
    } catch (f) {
      r(f, t);
      return;
    }
    c && typeof c.then == "function" && c.then(i, o);
  }
  function i() {
    s();
  }
  function o(a) {
    a || (a = new sa()), r(a, t);
  }
  s();
}
function ia(e, t, r, n) {
  if (r.sent !== !0)
    return e(t, r, n);
}
var bn = {
  Hooks: ci,
  buildHooks: Ux,
  preParsingHookRunner: Jx,
  onResponseHookRunner: Hx,
  onSendHookRunner: jv,
  preSerializationHookRunner: Kx,
  onRequestAbortHookRunner: Yx,
  hookRunnerApplication: kv,
  onListenHookRunner: Lv,
  preHandlerHookRunner: Vx,
  preValidationHookRunner: Bx,
  onRequestHookRunner: Wx,
  onTimeoutHookRunner: Gx,
  lifecycleHooks: Nv,
  supportedHooks: jx
};
const Xx = ea, Zx = gS, Qx = vS, ew = yv, { kState: bt, kOptions: tw, kServerBindings: rw } = ht, { FSTWRN003: nw } = Yu, { onListenHookRunner: Oi } = bn, {
  FST_ERR_HTTP2_INVALID_VERSION: sw,
  FST_ERR_REOPENED_CLOSE_SERVER: Dv,
  FST_ERR_REOPENED_SERVER: Fv,
  FST_ERR_LISTEN_OPTIONS_INVALID: iw
} = _t;
Cv.createServer = ow;
function Mv(e) {
  return `Server listening at ${e}`;
}
function ow(e, t) {
  const r = Uv(e, t);
  function n(s = { port: 0, host: "localhost" }, i = void 0) {
    if (typeof i == "function" && (i.constructor.name === "AsyncFunction" && nw("listen method"), s.cb = i), s.signal) {
      if (typeof s.signal.on != "function" && typeof s.signal.addEventListener != "function")
        throw new iw("Invalid options.signal");
      if (s.signal.aborted)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        this.close();
      else {
        const a = () => {
          this.close();
        };
<<<<<<< HEAD
        i.signal.addEventListener("abort", a, { once: !0 });
      }
    }
    let o;
    if (i.path == null ? o = i.host ?? "localhost" : o = i.host, (!Object.hasOwn(i, "host") || i.host == null) && (i.host = o), o === "localhost" ? i.cb = (a, c) => {
      if (a) {
        s(a, c);
        return;
      }
      Ev.call(this, r, t, e, i, () => {
        this[Vt].listening = !0, s(null, c), Ec(this);
      });
    } : i.cb = (a, c) => {
      if (a) {
        s(a, c);
        return;
      }
      this[Vt].listening = !0, s(null, c), Ec(this);
    }, s === void 0)
      return oI.call(this, r, i).then((c) => new Promise((u, l) => {
        o === "localhost" ? Ev.call(this, r, t, e, i, () => {
          this[Vt].listening = !0, u(c), Ec(this);
        }) : (u(c), Ec(this));
      }));
    this.ready(ex.call(this, r, i));
  }
  return { server: r, listen: n };
}
function Ev(e, t, r, n, i) {
  this[Vt].listening = !1, ZA.lookup(n.host, { all: !0 }, (s, o) => {
    if (s) {
      i();
      return;
    }
    const a = e.listening && r.serverFactory;
    let c = 0, u = 0;
    if (!a) {
      const f = e.address();
      for (const m of o)
        if (m.address !== f.address) {
          c++;
          const p = Object.assign({}, n, {
            host: m.address,
            port: f.port,
            cb: (_) => {
              u++, _ || this[tI].push(d), u === c && i();
            }
          }), d = tx(r, t), h = () => {
            d.close(() => {
            }), typeof d.closeAllConnections == "function" && r.forceCloseConnections === !0 && d.closeAllConnections();
          };
          d.on("upgrade", e.emit.bind(e, "upgrade")), e.on("unref", h), e.on("close", h), e.on("error", h), this[Vt].listening = !1, ex.call(this, d, p)();
        }
    }
    if (c === 0) {
      i();
=======
        s.signal.addEventListener("abort", a, { once: !0 });
      }
    }
    let o;
    if (s.path == null ? o = s.host ?? "localhost" : o = s.host, (!Object.hasOwn(s, "host") || s.host == null) && (s.host = o), o === "localhost" ? s.cb = (a, c) => {
      if (a) {
        i(a, c);
        return;
      }
      Cp.call(this, r, t, e, s, () => {
        this[bt].listening = !0, i(null, c), Oi(this);
      });
    } : s.cb = (a, c) => {
      if (a) {
        i(a, c);
        return;
      }
      this[bt].listening = !0, i(null, c), Oi(this);
    }, i === void 0)
      return aw.call(this, r, s).then((c) => new Promise((f, l) => {
        o === "localhost" ? Cp.call(this, r, t, e, s, () => {
          this[bt].listening = !0, f(c), Oi(this);
        }) : (f(c), Oi(this));
      }));
    this.ready(zv.call(this, r, s));
  }
  return { server: r, listen: n };
}
function Cp(e, t, r, n, s) {
  this[bt].listening = !1, Qx.lookup(n.host, { all: !0 }, (i, o) => {
    if (i) {
      s();
      return;
    }
    const a = e.listening && r.serverFactory;
    let c = 0, f = 0;
    if (!a) {
      const d = e.address();
      for (const g of o)
        if (g.address !== d.address) {
          c++;
          const p = Object.assign({}, n, {
            host: g.address,
            port: d.port,
            cb: (b) => {
              f++, b || this[rw].push(u), f === c && s();
            }
          }), u = Uv(r, t), h = () => {
            u.close(() => {
            }), typeof u.closeAllConnections == "function" && r.forceCloseConnections === !0 && u.closeAllConnections();
          };
          u.on("upgrade", e.emit.bind(e, "upgrade")), e.on("unref", h), e.on("close", h), e.on("error", h), this[bt].listening = !1, zv.call(this, u, p)();
        }
    }
    if (c === 0) {
      s();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    const l = e.unref;
    e.unref = function() {
      l.call(e), e.emit("unref");
    };
  });
}
<<<<<<< HEAD
function ex(e, t) {
  const r = (n) => {
    if (e.removeListener("error", r), e.removeListener("listening", r), n)
      this[Vt].listening = !1, t.cb(n, null);
    else {
      const i = rx.call(this, e, t.listenTextResolver || QS);
      t.cb(null, i);
=======
function zv(e, t) {
  const r = (n) => {
    if (e.removeListener("error", r), e.removeListener("listening", r), n)
      this[bt].listening = !1, t.cb(n, null);
    else {
      const s = qv.call(this, e, t.listenTextResolver || Mv);
      t.cb(null, s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  };
  return (n) => {
    if (n != null) return t.cb(n);
<<<<<<< HEAD
    if (this[Vt].listening && this[Vt].closing)
      return t.cb(new XS(), null);
    if (this[Vt].listening)
      return t.cb(new ZS(), null);
    e.once("error", r), this[Vt].closing || (e.once("listening", r), e.listen(t), this[Vt].listening = !0);
  };
}
function oI(e, t) {
  return this[Vt].listening && this[Vt].closing ? Promise.reject(new XS()) : this[Vt].listening ? Promise.reject(new ZS()) : this.ready().then(() => {
    let r, n;
    function i() {
      e.removeListener("error", r), e.removeListener("listening", n);
    }
    const s = new Promise((a, c) => {
      r = (u) => {
        i(), this[Vt].listening = !1, c(u);
      }, e.once("error", r);
    }), o = new Promise((a, c) => {
      n = () => {
        i(), this[Vt].listening = !0, a(rx.call(this, e, t.listenTextResolver || QS));
      }, e.once("listening", n);
    });
    return e.listen(t), Promise.race([
      s,
=======
    if (this[bt].listening && this[bt].closing)
      return t.cb(new Dv(), null);
    if (this[bt].listening)
      return t.cb(new Fv(), null);
    e.once("error", r), this[bt].closing || (e.once("listening", r), e.listen(t), this[bt].listening = !0);
  };
}
function aw(e, t) {
  return this[bt].listening && this[bt].closing ? Promise.reject(new Dv()) : this[bt].listening ? Promise.reject(new Fv()) : this.ready().then(() => {
    let r, n;
    function s() {
      e.removeListener("error", r), e.removeListener("listening", n);
    }
    const i = new Promise((a, c) => {
      r = (f) => {
        s(), this[bt].listening = !1, c(f);
      }, e.once("error", r);
    }), o = new Promise((a, c) => {
      n = () => {
        s(), this[bt].listening = !0, a(qv.call(this, e, t.listenTextResolver || Mv));
      }, e.once("listening", n);
    });
    return e.listen(t), Promise.race([
      i,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      // e.g invalid port range error is always emitted before the server listening
      o
    ]);
  });
}
<<<<<<< HEAD
function tx(e, t) {
  let r = null;
  const n = e.https === !0 ? {} : e.https;
  return e.serverFactory ? r = e.serverFactory(t, e) : e.http2 ? (typeof n == "object" ? r = wv().createSecureServer(n, t) : r = wv().createServer(t), r.on("session", cI(e.http2SessionTimeout))) : (n ? r = XA.createServer(n, t) : r = JA.createServer(e.http, t), r.keepAliveTimeout = e.keepAliveTimeout, r.requestTimeout = e.requestTimeout, e.maxRequestsPerSocket > 0 && (r.maxRequestsPerSocket = e.maxRequestsPerSocket)), e.serverFactory || r.setTimeout(e.connectionTimeout), r;
}
function aI(e) {
  return e.address === "0.0.0.0" ? Object.values(QA.networkInterfaces()).flatMap((t) => t.filter((r) => r.family === "IPv4")).sort((t) => t.internal ? -1 : 1).map((t) => t.address) : [e.address];
}
function rx(e, t) {
  let r;
  typeof e.address() == "string" ? r = [e.address()] : (e.address().address.indexOf(":") === -1 ? r = aI(e.address()).map((i) => i + ":" + e.address().port) : r = ["[" + e.address().address + "]:" + e.address().port], r = r.map((i) => "http" + (this[eI].https ? "s" : "") + "://" + i));
  for (const i of r)
    this.log.info(t(i));
  return r[0];
}
function wv() {
  try {
    return require("node:http2");
  } catch {
    throw new nI();
  }
}
function cI(e) {
  return function(t) {
    t.setTimeout(e, lI);
  };
}
function lI() {
  this.close();
}
var Ru = { exports: {} }, nx = { exports: {} };
const {
  kSchemaHeaders: oh,
  kSchemaParams: ix,
  kSchemaQuerystring: sx,
  kSchemaBody: ws,
  kSchemaResponse: uI
} = Ft, fI = /^[1-5](?:\d{2}|xx)$|^default$/, {
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: dI
} = Wt, { FSTWRN001: wc } = hm;
function pI(e, t) {
  if (!e.schema || !e.schema.response)
    return;
  const { method: r, url: n } = e.config || {};
  e[uI] = Object.keys(e.schema.response).reduce(function(i, s) {
    const o = e.schema.response[s];
    if (s = s.toLowerCase(), !fI.test(s))
      throw new dI();
    if (o.content) {
      const a = {};
      for (const c of Object.keys(o.content)) {
        const u = o.content[c].schema;
        a[c] = t({
          schema: u,
          url: n,
          method: r,
          httpStatus: s,
          contentType: c
        });
      }
      i[s] = a;
    } else
      i[s] = t({
        schema: o,
        url: n,
        method: r,
        httpStatus: s
      });
    return i;
  }, {});
}
function hI(e, t, r) {
  const { schema: n } = e;
  if (!n)
    return;
  const { method: i, url: s } = e.config || {}, o = n.headers;
  if (o && (r || Object.getPrototypeOf(o) !== Object.prototype))
    e[oh] = t({ schema: o, method: i, url: s, httpPart: "headers" });
=======
function Uv(e, t) {
  let r = null;
  const n = e.https === !0 ? {} : e.https;
  return e.serverFactory ? r = e.serverFactory(t, e) : e.http2 ? (typeof n == "object" ? r = Pp().createSecureServer(n, t) : r = Pp().createServer(t), r.on("session", lw(e.http2SessionTimeout))) : (n ? r = Zx.createServer(n, t) : r = Xx.createServer(e.http, t), r.keepAliveTimeout = e.keepAliveTimeout, r.requestTimeout = e.requestTimeout, e.maxRequestsPerSocket > 0 && (r.maxRequestsPerSocket = e.maxRequestsPerSocket)), e.serverFactory || r.setTimeout(e.connectionTimeout), r;
}
function cw(e) {
  return e.address === "0.0.0.0" ? Object.values(ew.networkInterfaces()).flatMap((t) => t.filter((r) => r.family === "IPv4")).sort((t) => t.internal ? -1 : 1).map((t) => t.address) : [e.address];
}
function qv(e, t) {
  let r;
  typeof e.address() == "string" ? r = [e.address()] : (e.address().address.indexOf(":") === -1 ? r = cw(e.address()).map((s) => s + ":" + e.address().port) : r = ["[" + e.address().address + "]:" + e.address().port], r = r.map((s) => "http" + (this[tw].https ? "s" : "") + "://" + s));
  for (const s of r)
    this.log.info(t(s));
  return r[0];
}
function Pp() {
  try {
    return require("node:http2");
  } catch {
    throw new sw();
  }
}
function lw(e) {
  return function(t) {
    t.setTimeout(e, uw);
  };
}
function uw() {
  this.close();
}
var oa = { exports: {} }, Hv = { exports: {} };
const {
  kSchemaHeaders: tu,
  kSchemaParams: Bv,
  kSchemaQuerystring: Vv,
  kSchemaBody: Dn,
  kSchemaResponse: fw
} = ht, dw = /^[1-5](?:\d{2}|xx)$|^default$/, {
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: pw
} = _t, { FSTWRN001: Ci } = Yu;
function hw(e, t) {
  if (!e.schema || !e.schema.response)
    return;
  const { method: r, url: n } = e.config || {};
  e[fw] = Object.keys(e.schema.response).reduce(function(s, i) {
    const o = e.schema.response[i];
    if (i = i.toLowerCase(), !dw.test(i))
      throw new pw();
    if (o.content) {
      const a = {};
      for (const c of Object.keys(o.content)) {
        const f = o.content[c].schema;
        a[c] = t({
          schema: f,
          url: n,
          method: r,
          httpStatus: i,
          contentType: c
        });
      }
      s[i] = a;
    } else
      s[i] = t({
        schema: o,
        url: n,
        method: r,
        httpStatus: i
      });
    return s;
  }, {});
}
function mw(e, t, r) {
  const { schema: n } = e;
  if (!n)
    return;
  const { method: s, url: i } = e.config || {}, o = n.headers;
  if (o && (r || Object.getPrototypeOf(o) !== Object.prototype))
    e[tu] = t({ schema: o, method: s, url: i, httpPart: "headers" });
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  else if (o) {
    const a = {};
    Object.keys(o).forEach((c) => {
      a[c] = o[c];
    }), a.required instanceof Array && (a.required = a.required.map((c) => c.toLowerCase())), o.properties && (a.properties = {}, Object.keys(o.properties).forEach((c) => {
      a.properties[c.toLowerCase()] = o.properties[c];
<<<<<<< HEAD
    })), e[oh] = t({ schema: a, method: i, url: s, httpPart: "headers" });
  } else Object.hasOwn(n, "headers") && wc("headers", i, s);
=======
    })), e[tu] = t({ schema: a, method: s, url: i, httpPart: "headers" });
  } else Object.hasOwn(n, "headers") && Ci("headers", s, i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (n.body) {
    const a = n.body.content;
    if (a) {
      const c = {};
<<<<<<< HEAD
      for (const u of Object.keys(a)) {
        const l = a[u].schema;
        c[u] = t({ schema: l, method: i, url: s, httpPart: "body", contentType: u });
      }
      e[ws] = c;
    } else
      e[ws] = t({ schema: n.body, method: i, url: s, httpPart: "body" });
  } else Object.hasOwn(n, "body") && wc("body", i, s);
  n.querystring ? e[sx] = t({ schema: n.querystring, method: i, url: s, httpPart: "querystring" }) : Object.hasOwn(n, "querystring") && wc("querystring", i, s), n.params ? e[ix] = t({ schema: n.params, method: i, url: s, httpPart: "params" }) : Object.hasOwn(n, "params") && wc("params", i, s);
}
function Sc(e, t, r) {
  const n = t[r] === void 0, i = e && e(n ? null : t[r]);
  if (i && typeof i.then == "function")
    return i.then((o) => s(o)).catch((o) => o);
  return s(i);
  function s(o) {
    return o === !1 ? e.errors : o && o.error ? o.error : (o && o.value && (t[r] = o.value), !1);
  }
}
function $u(e, t, r) {
  var s;
  const n = r === void 0;
  if (n || !r.skipParams) {
    const o = Sc(e[ix], t, "params");
    if (o)
      return typeof o.then != "function" ? Hn(o, "params", e.schemaErrorFormatter) : mI(o, e, t);
  }
  if (n || !r.skipBody) {
    let o = null;
    if (typeof e[ws] == "function")
      o = e[ws];
    else if (e[ws]) {
      const c = (s = t.headers["content-type"]) == null ? void 0 : s.split(";", 1)[0], u = e[ws][c];
      u && (o = u);
    }
    const a = Sc(o, t, "body");
    if (a)
      return typeof a.then != "function" ? Hn(a, "body", e.schemaErrorFormatter) : gI(a, e, t);
  }
  if (n || !r.skipQuery) {
    const o = Sc(e[sx], t, "query");
    if (o)
      return typeof o.then != "function" ? Hn(o, "querystring", e.schemaErrorFormatter) : yI(o, e, t);
  }
  const i = Sc(e[oh], t, "headers");
  return i ? typeof i.then != "function" ? Hn(i, "headers", e.schemaErrorFormatter) : vI(i, e) : !1;
}
function mI(e, t, r) {
  return e.then((n) => n ? Hn(n, "params", t.schemaErrorFormatter) : $u(t, r, { skipParams: !0 }));
}
function gI(e, t, r) {
  return e.then((n) => n ? Hn(n, "body", t.schemaErrorFormatter) : $u(t, r, { skipParams: !0, skipBody: !0 }));
}
function yI(e, t, r) {
  return e.then((n) => n ? Hn(n, "querystring", t.schemaErrorFormatter) : $u(t, r, { skipParams: !0, skipBody: !0, skipQuery: !0 }));
}
function vI(e, t, r) {
  return e.then((n) => n ? Hn(n, "headers", t.schemaErrorFormatter) : !1);
}
function Hn(e, t, r) {
=======
      for (const f of Object.keys(a)) {
        const l = a[f].schema;
        c[f] = t({ schema: l, method: s, url: i, httpPart: "body", contentType: f });
      }
      e[Dn] = c;
    } else
      e[Dn] = t({ schema: n.body, method: s, url: i, httpPart: "body" });
  } else Object.hasOwn(n, "body") && Ci("body", s, i);
  n.querystring ? e[Vv] = t({ schema: n.querystring, method: s, url: i, httpPart: "querystring" }) : Object.hasOwn(n, "querystring") && Ci("querystring", s, i), n.params ? e[Bv] = t({ schema: n.params, method: s, url: i, httpPart: "params" }) : Object.hasOwn(n, "params") && Ci("params", s, i);
}
function Pi(e, t, r) {
  const n = t[r] === void 0, s = e && e(n ? null : t[r]);
  if (s && typeof s.then == "function")
    return s.then((o) => i(o)).catch((o) => o);
  return i(s);
  function i(o) {
    return o === !1 ? e.errors : o && o.error ? o.error : (o && o.value && (t[r] = o.value), !1);
  }
}
function aa(e, t, r) {
  var i;
  const n = r === void 0;
  if (n || !r.skipParams) {
    const o = Pi(e[Bv], t, "params");
    if (o)
      return typeof o.then != "function" ? jr(o, "params", e.schemaErrorFormatter) : yw(o, e, t);
  }
  if (n || !r.skipBody) {
    let o = null;
    if (typeof e[Dn] == "function")
      o = e[Dn];
    else if (e[Dn]) {
      const c = (i = t.headers["content-type"]) == null ? void 0 : i.split(";", 1)[0], f = e[Dn][c];
      f && (o = f);
    }
    const a = Pi(o, t, "body");
    if (a)
      return typeof a.then != "function" ? jr(a, "body", e.schemaErrorFormatter) : gw(a, e, t);
  }
  if (n || !r.skipQuery) {
    const o = Pi(e[Vv], t, "query");
    if (o)
      return typeof o.then != "function" ? jr(o, "querystring", e.schemaErrorFormatter) : vw(o, e, t);
  }
  const s = Pi(e[tu], t, "headers");
  return s ? typeof s.then != "function" ? jr(s, "headers", e.schemaErrorFormatter) : bw(s, e) : !1;
}
function yw(e, t, r) {
  return e.then((n) => n ? jr(n, "params", t.schemaErrorFormatter) : aa(t, r, { skipParams: !0 }));
}
function gw(e, t, r) {
  return e.then((n) => n ? jr(n, "body", t.schemaErrorFormatter) : aa(t, r, { skipParams: !0, skipBody: !0 }));
}
function vw(e, t, r) {
  return e.then((n) => n ? jr(n, "querystring", t.schemaErrorFormatter) : aa(t, r, { skipParams: !0, skipBody: !0, skipQuery: !0 }));
}
function bw(e, t, r) {
  return e.then((n) => n ? jr(n, "headers", t.schemaErrorFormatter) : !1);
}
function jr(e, t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (e instanceof Error)
    return e.statusCode = e.statusCode || 400, e.code = e.code || "FST_ERR_VALIDATION", e.validationContext = e.validationContext || t, e;
  const n = r(e, t);
  return n.statusCode = n.statusCode || 400, n.code = n.code || "FST_ERR_VALIDATION", n.validation = e, n.validationContext = t, n;
}
<<<<<<< HEAD
var ox = {
  compileSchemasForValidation: hI,
  compileSchemasForSerialization: pI,
  validate: $u
};
const {
  kReplyIsError: Sv,
  kReplyHijacked: _I
} = Ft, bI = om, wo = bI.tracingChannel("fastify.request.handler");
function EI(e, t, r) {
  r && (r.async = !0), e.then(function(n) {
    if (t[_I] !== !0) {
      r && wo.asyncStart.publish(r);
=======
var Gv = {
  compileSchemasForValidation: mw,
  compileSchemasForSerialization: hw,
  validate: aa
};
const {
  kReplyIsError: Ip,
  kReplyHijacked: _w
} = ht, Ew = zu, ys = Ew.tracingChannel("fastify.request.handler");
function Sw(e, t, r) {
  r && (r.async = !0), e.then(function(n) {
    if (t[_w] !== !0) {
      r && ys.asyncStart.publish(r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      try {
        if (n !== void 0 || //
        t.sent === !1 && //
        t.raw.headersSent === !1 && t.request.raw.aborted === !1 && t.request.socket && !t.request.socket.destroyed)
          try {
            t.send(n);
<<<<<<< HEAD
          } catch (i) {
            t[Sv] = !0, t.send(i);
          }
      } finally {
        r && wo.asyncEnd.publish(r);
      }
    }
  }, function(n) {
    r && (r.error = n, wo.error.publish(r), wo.asyncStart.publish(r));
=======
          } catch (s) {
            t[Ip] = !0, t.send(s);
          }
      } finally {
        r && ys.asyncEnd.publish(r);
      }
    }
  }, function(n) {
    r && (r.error = n, ys.error.publish(r), ys.asyncStart.publish(r));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    try {
      if (t.sent === !0) {
        t.log.error({ err: n }, "Promise errored, but reply.sent = true was set");
        return;
      }
<<<<<<< HEAD
      t[Sv] = !0, t.send(n);
    } catch (i) {
      t.send(i);
    } finally {
      r && wo.asyncEnd.publish(r);
    }
  });
}
var ax = EI;
(function(e) {
  const t = om, { validate: r } = ox, { preValidationHookRunner: n, preHandlerHookRunner: i } = Wi, s = ax, {
    kReplyIsError: o,
    kRouteContext: a,
    kFourOhFourContext: c,
    kSupportedHTTPMethods: u
  } = Ft, l = t.tracingChannel("fastify.request.handler");
  function f(g, v, y) {
    if (y.sent === !0) return;
    if (g != null) {
      y[o] = !0, y.send(g);
      return;
    }
    const E = v.raw.method, R = v.headers, w = v[a];
    if (this[u].bodyless.has(E)) {
      m(v, y);
      return;
    }
    if (this[u].bodywith.has(E)) {
      const C = R["content-type"], V = R["content-length"], b = R["transfer-encoding"];
      if (C === void 0)
        (V === void 0 || V === "0") && b === void 0 ? m(v, y) : w.contentTypeParser.run("", m, v, y);
      else {
        if (V === void 0 && b === void 0 && E === "OPTIONS") {
          m(v, y);
          return;
        }
        w.contentTypeParser.run(C, m, v, y);
      }
      return;
    }
    m(v, y);
  }
  function m(g, v) {
    try {
      g[a].preValidation !== null ? n(
        g[a].preValidation,
        g,
        v,
        p
      ) : p(null, g, v);
    } catch (y) {
      p(y, g, v);
    }
  }
  function p(g, v, y) {
    if (y.sent === !0) return;
    if (g != null) {
      y[o] = !0, y.send(g);
      return;
    }
    const E = r(y[a], v);
    if (E && typeof E.then == "function" || !1) {
      const w = d.bind(null, v, y);
      E.then(w, w);
    } else
      d(v, y, E);
  }
  function d(g, v, y) {
=======
      t[Ip] = !0, t.send(n);
    } catch (s) {
      t.send(s);
    } finally {
      r && ys.asyncEnd.publish(r);
    }
  });
}
var Wv = Sw;
(function(e) {
  const t = zu, { validate: r } = Gv, { preValidationHookRunner: n, preHandlerHookRunner: s } = bn, i = Wv, {
    kReplyIsError: o,
    kRouteContext: a,
    kFourOhFourContext: c,
    kSupportedHTTPMethods: f
  } = ht, l = t.tracingChannel("fastify.request.handler");
  function d(m, v, y) {
    if (y.sent === !0) return;
    if (m != null) {
      y[o] = !0, y.send(m);
      return;
    }
    const _ = v.raw.method, R = v.headers, E = v[a];
    if (this[f].bodyless.has(_)) {
      g(v, y);
      return;
    }
    if (this[f].bodywith.has(_)) {
      const O = R["content-type"], z = R["content-length"], S = R["transfer-encoding"];
      if (O === void 0)
        (z === void 0 || z === "0") && S === void 0 ? g(v, y) : E.contentTypeParser.run("", g, v, y);
      else {
        if (z === void 0 && S === void 0 && _ === "OPTIONS") {
          g(v, y);
          return;
        }
        E.contentTypeParser.run(O, g, v, y);
      }
      return;
    }
    g(v, y);
  }
  function g(m, v) {
    try {
      m[a].preValidation !== null ? n(
        m[a].preValidation,
        m,
        v,
        p
      ) : p(null, m, v);
    } catch (y) {
      p(y, m, v);
    }
  }
  function p(m, v, y) {
    if (y.sent === !0) return;
    if (m != null) {
      y[o] = !0, y.send(m);
      return;
    }
    const _ = r(y[a], v);
    if (_ && typeof _.then == "function" || !1) {
      const E = u.bind(null, v, y);
      _.then(E, E);
    } else
      u(v, y, _);
  }
  function u(m, v, y) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (y) {
      if (v[a].attachValidation === !1) {
        v.send(y);
        return;
      }
      v.request.validationError = y;
    }
<<<<<<< HEAD
    g[a].preHandler !== null ? i(
      g[a].preHandler,
      g,
      v,
      h
    ) : h(null, g, v);
  }
  function h(g, v, y) {
    if (y.sent) return;
    const E = v[a];
    if (!l.hasSubscribers || E[c] === null)
      _(g, v, y);
=======
    m[a].preHandler !== null ? s(
      m[a].preHandler,
      m,
      v,
      h
    ) : h(null, m, v);
  }
  function h(m, v, y) {
    if (y.sent) return;
    const _ = v[a];
    if (!l.hasSubscribers || _[c] === null)
      b(m, v, y);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    else {
      const R = {
        request: v,
        reply: y,
        async: !1,
        route: {
<<<<<<< HEAD
          url: E.config.url,
          method: E.config.method
        }
      };
      l.start.runStores(R, _, void 0, g, v, y, R);
    }
  }
  function _(g, v, y, E) {
    const R = v[a];
    try {
      if (g != null) {
        y[o] = !0, y.send(g), E && (E.error = g, l.error.publish(E));
        return;
      }
      let w;
      try {
        w = R.handler(v, y);
      } catch (C) {
        E && (E.error = C, l.error.publish(E)), y[o] = !0, y.send(C);
        return;
      }
      w !== void 0 && (w !== null && typeof w.then == "function" ? s(w, y, E) : y.send(w));
    } finally {
      E && l.end.publish(E);
    }
  }
  e.exports = f, e.exports[Symbol.for("internals")] = { handler: m, preHandlerCallback: h };
})(nx);
var cx = nx.exports, ll = { exports: {} };
ll.exports;
var xv;
function wI() {
  return xv || (xv = 1, function(e) {
=======
          url: _.config.url,
          method: _.config.method
        }
      };
      l.start.runStores(R, b, void 0, m, v, y, R);
    }
  }
  function b(m, v, y, _) {
    const R = v[a];
    try {
      if (m != null) {
        y[o] = !0, y.send(m), _ && (_.error = m, l.error.publish(_));
        return;
      }
      let E;
      try {
        E = R.handler(v, y);
      } catch (O) {
        _ && (_.error = O, l.error.publish(_)), y[o] = !0, y.send(O);
        return;
      }
      E !== void 0 && (E !== null && typeof E.then == "function" ? i(E, y, _) : y.send(E));
    } finally {
      _ && l.end.publish(_);
    }
  }
  e.exports = d, e.exports[Symbol.for("internals")] = { handler: g, preHandlerCallback: h };
})(Hv);
var Kv = Hv.exports, lo = { exports: {} };
lo.exports;
var Np;
function xw() {
  return Np || (Np = 1, function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    function t() {
    }
    const r = {
      fatal: t,
      error: t,
      warn: t,
      info: t,
      debug: t,
      trace: t
    };
    Object.defineProperty(e, "exports", {
      get() {
        return Object.create(r);
      }
    });
<<<<<<< HEAD
  }(ll)), ll.exports;
}
var hr = { exports: {} }, zf, Rv;
function lx() {
  if (Rv) return zf;
  Rv = 1;
=======
  }(lo)), lo.exports;
}
var It = { exports: {} }, oc, Ap;
function Jv() {
  if (Ap) return oc;
  Ap = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = (o) => o && typeof o.message == "string", t = (o) => {
    if (!o) return;
    const a = o.cause;
    if (typeof a == "function") {
      const c = o.cause();
      return e(c) ? c : void 0;
    } else
      return e(a) ? a : void 0;
  }, r = (o, a) => {
    if (!e(o)) return "";
    const c = o.stack || "";
    if (a.has(o))
      return c + `
causes have become circular...`;
<<<<<<< HEAD
    const u = t(o);
    return u ? (a.add(o), c + `
caused by: ` + r(u, a)) : c;
  }, n = (o) => r(o, /* @__PURE__ */ new Set()), i = (o, a, c) => {
    if (!e(o)) return "";
    const u = c ? "" : o.message || "";
    if (a.has(o))
      return u + ": ...";
    const l = t(o);
    if (l) {
      a.add(o);
      const f = typeof o.cause == "function";
      return u + (f ? "" : ": ") + i(l, a, f);
    } else
      return u;
  };
  return zf = {
    isErrorLike: e,
    getErrorCause: t,
    stackWithCauses: n,
    messageWithCauses: (o) => i(o, /* @__PURE__ */ new Set())
  }, zf;
}
var Vf, $v;
function ux() {
  if ($v) return Vf;
  $v = 1;
=======
    const f = t(o);
    return f ? (a.add(o), c + `
caused by: ` + r(f, a)) : c;
  }, n = (o) => r(o, /* @__PURE__ */ new Set()), s = (o, a, c) => {
    if (!e(o)) return "";
    const f = c ? "" : o.message || "";
    if (a.has(o))
      return f + ": ...";
    const l = t(o);
    if (l) {
      a.add(o);
      const d = typeof o.cause == "function";
      return f + (d ? "" : ": ") + s(l, a, d);
    } else
      return f;
  };
  return oc = {
    isErrorLike: e,
    getErrorCause: t,
    stackWithCauses: n,
    messageWithCauses: (o) => s(o, /* @__PURE__ */ new Set())
  }, oc;
}
var ac, kp;
function Yv() {
  if (kp) return ac;
  kp = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = Symbol("circular-ref-tag"), t = Symbol("pino-raw-err-ref"), r = Object.create({}, {
    type: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    message: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    stack: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    aggregateErrors: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[t];
      },
      set: function(n) {
        this[t] = n;
      }
    }
  });
  return Object.defineProperty(r, t, {
    writable: !0,
    value: {}
<<<<<<< HEAD
  }), Vf = {
=======
  }), ac = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    pinoErrProto: r,
    pinoErrorSymbols: {
      seen: e,
      rawSymbol: t
    }
<<<<<<< HEAD
  }, Vf;
}
var Gf, Tv;
function SI() {
  if (Tv) return Gf;
  Tv = 1, Gf = a;
  const { messageWithCauses: e, stackWithCauses: t, isErrorLike: r } = lx(), { pinoErrProto: n, pinoErrorSymbols: i } = ux(), { seen: s } = i, { toString: o } = Object.prototype;
  function a(c) {
    if (!r(c))
      return c;
    c[s] = void 0;
    const u = Object.create(n);
    u.type = o.call(c.constructor) === "[object Function]" ? c.constructor.name : c.name, u.message = e(c), u.stack = t(c), Array.isArray(c.errors) && (u.aggregateErrors = c.errors.map((l) => a(l)));
    for (const l in c)
      if (u[l] === void 0) {
        const f = c[l];
        r(f) ? l !== "cause" && !Object.prototype.hasOwnProperty.call(f, s) && (u[l] = a(f)) : u[l] = f;
      }
    return delete c[s], u.raw = c, u;
  }
  return Gf;
}
var Wf, Ov;
function xI() {
  if (Ov) return Wf;
  Ov = 1, Wf = s;
  const { isErrorLike: e } = lx(), { pinoErrProto: t, pinoErrorSymbols: r } = ux(), { seen: n } = r, { toString: i } = Object.prototype;
  function s(o) {
=======
  }, ac;
}
var cc, Lp;
function ww() {
  if (Lp) return cc;
  Lp = 1, cc = a;
  const { messageWithCauses: e, stackWithCauses: t, isErrorLike: r } = Jv(), { pinoErrProto: n, pinoErrorSymbols: s } = Yv(), { seen: i } = s, { toString: o } = Object.prototype;
  function a(c) {
    if (!r(c))
      return c;
    c[i] = void 0;
    const f = Object.create(n);
    f.type = o.call(c.constructor) === "[object Function]" ? c.constructor.name : c.name, f.message = e(c), f.stack = t(c), Array.isArray(c.errors) && (f.aggregateErrors = c.errors.map((l) => a(l)));
    for (const l in c)
      if (f[l] === void 0) {
        const d = c[l];
        r(d) ? l !== "cause" && !Object.prototype.hasOwnProperty.call(d, i) && (f[l] = a(d)) : f[l] = d;
      }
    return delete c[i], f.raw = c, f;
  }
  return cc;
}
var lc, jp;
function Rw() {
  if (jp) return lc;
  jp = 1, lc = i;
  const { isErrorLike: e } = Jv(), { pinoErrProto: t, pinoErrorSymbols: r } = Yv(), { seen: n } = r, { toString: s } = Object.prototype;
  function i(o) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (!e(o))
      return o;
    o[n] = void 0;
    const a = Object.create(t);
<<<<<<< HEAD
    a.type = i.call(o.constructor) === "[object Function]" ? o.constructor.name : o.name, a.message = o.message, a.stack = o.stack, Array.isArray(o.errors) && (a.aggregateErrors = o.errors.map((c) => s(c))), e(o.cause) && !Object.prototype.hasOwnProperty.call(o.cause, n) && (a.cause = s(o.cause));
    for (const c in o)
      if (a[c] === void 0) {
        const u = o[c];
        e(u) ? Object.prototype.hasOwnProperty.call(u, n) || (a[c] = s(u)) : a[c] = u;
      }
    return delete o[n], a.raw = o, a;
  }
  return Wf;
}
var Kf, Pv;
function RI() {
  if (Pv) return Kf;
  Pv = 1, Kf = {
=======
    a.type = s.call(o.constructor) === "[object Function]" ? o.constructor.name : o.name, a.message = o.message, a.stack = o.stack, Array.isArray(o.errors) && (a.aggregateErrors = o.errors.map((c) => i(c))), e(o.cause) && !Object.prototype.hasOwnProperty.call(o.cause, n) && (a.cause = i(o.cause));
    for (const c in o)
      if (a[c] === void 0) {
        const f = o[c];
        e(f) ? Object.prototype.hasOwnProperty.call(f, n) || (a[c] = i(f)) : a[c] = f;
      }
    return delete o[n], a.raw = o, a;
  }
  return lc;
}
var uc, Dp;
function $w() {
  if (Dp) return uc;
  Dp = 1, uc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    mapHttpRequest: n,
    reqSerializer: r
  };
  const e = Symbol("pino-raw-req-ref"), t = Object.create({}, {
    id: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    method: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    url: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    query: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    params: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    headers: {
      enumerable: !0,
      writable: !0,
      value: {}
    },
    remoteAddress: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    remotePort: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[e];
      },
<<<<<<< HEAD
      set: function(i) {
        this[e] = i;
=======
      set: function(s) {
        this[e] = s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  });
  Object.defineProperty(t, e, {
    writable: !0,
    value: {}
  });
<<<<<<< HEAD
  function r(i) {
    const s = i.info || i.socket, o = Object.create(t);
    if (o.id = typeof i.id == "function" ? i.id() : i.id || (i.info ? i.info.id : void 0), o.method = i.method, i.originalUrl)
      o.url = i.originalUrl;
    else {
      const a = i.path;
      o.url = typeof a == "string" ? a : i.url ? i.url.path || i.url : void 0;
    }
    return i.query && (o.query = i.query), i.params && (o.params = i.params), o.headers = i.headers, o.remoteAddress = s && s.remoteAddress, o.remotePort = s && s.remotePort, o.raw = i.raw || i, o;
  }
  function n(i) {
    return {
      req: r(i)
    };
  }
  return Kf;
}
var Yf, Cv;
function $I() {
  if (Cv) return Yf;
  Cv = 1, Yf = {
=======
  function r(s) {
    const i = s.info || s.socket, o = Object.create(t);
    if (o.id = typeof s.id == "function" ? s.id() : s.id || (s.info ? s.info.id : void 0), o.method = s.method, s.originalUrl)
      o.url = s.originalUrl;
    else {
      const a = s.path;
      o.url = typeof a == "string" ? a : s.url ? s.url.path || s.url : void 0;
    }
    return s.query && (o.query = s.query), s.params && (o.params = s.params), o.headers = s.headers, o.remoteAddress = i && i.remoteAddress, o.remotePort = i && i.remotePort, o.raw = s.raw || s, o;
  }
  function n(s) {
    return {
      req: r(s)
    };
  }
  return uc;
}
var fc, Fp;
function Tw() {
  if (Fp) return fc;
  Fp = 1, fc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    mapHttpResponse: n,
    resSerializer: r
  };
  const e = Symbol("pino-raw-res-ref"), t = Object.create({}, {
    statusCode: {
      enumerable: !0,
      writable: !0,
      value: 0
    },
    headers: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[e];
      },
<<<<<<< HEAD
      set: function(i) {
        this[e] = i;
=======
      set: function(s) {
        this[e] = s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  });
  Object.defineProperty(t, e, {
    writable: !0,
    value: {}
  });
<<<<<<< HEAD
  function r(i) {
    const s = Object.create(t);
    return s.statusCode = i.headersSent ? i.statusCode : null, s.headers = i.getHeaders ? i.getHeaders() : i._headers, s.raw = i, s;
  }
  function n(i) {
    return {
      res: r(i)
    };
  }
  return Yf;
}
var Jf, Av;
function fx() {
  if (Av) return Jf;
  Av = 1;
  const e = SI(), t = xI(), r = RI(), n = $I();
  return Jf = {
=======
  function r(s) {
    const i = Object.create(t);
    return i.statusCode = s.headersSent ? s.statusCode : null, i.headers = s.getHeaders ? s.getHeaders() : s._headers, i.raw = s, i;
  }
  function n(s) {
    return {
      res: r(s)
    };
  }
  return fc;
}
var dc, Mp;
function Xv() {
  if (Mp) return dc;
  Mp = 1;
  const e = ww(), t = Rw(), r = $w(), n = Tw();
  return dc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    err: e,
    errWithCause: t,
    mapHttpRequest: r.mapHttpRequest,
    mapHttpResponse: n.mapHttpResponse,
    req: r.reqSerializer,
    res: n.resSerializer,
<<<<<<< HEAD
    wrapErrorSerializer: function(s) {
      return s === e ? s : function(a) {
        return s(e(a));
      };
    },
    wrapRequestSerializer: function(s) {
      return s === r.reqSerializer ? s : function(a) {
        return s(r.reqSerializer(a));
      };
    },
    wrapResponseSerializer: function(s) {
      return s === n.resSerializer ? s : function(a) {
        return s(n.resSerializer(a));
      };
    }
  }, Jf;
}
var Xf, Iv;
function dx() {
  if (Iv) return Xf;
  Iv = 1;
  function e(t, r) {
    return r;
  }
  return Xf = function() {
=======
    wrapErrorSerializer: function(i) {
      return i === e ? i : function(a) {
        return i(e(a));
      };
    },
    wrapRequestSerializer: function(i) {
      return i === r.reqSerializer ? i : function(a) {
        return i(r.reqSerializer(a));
      };
    },
    wrapResponseSerializer: function(i) {
      return i === n.resSerializer ? i : function(a) {
        return i(n.resSerializer(a));
      };
    }
  }, dc;
}
var pc, zp;
function Zv() {
  if (zp) return pc;
  zp = 1;
  function e(t, r) {
    return r;
  }
  return pc = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const r = Error.prepareStackTrace;
    Error.prepareStackTrace = e;
    const n = new Error().stack;
    if (Error.prepareStackTrace = r, !Array.isArray(n))
      return;
<<<<<<< HEAD
    const i = n.slice(2), s = [];
    for (const o of i)
      o && s.push(o.getFileName());
    return s;
  }, Xf;
}
var Zf, Nv;
function TI() {
  if (Nv) return Zf;
  Nv = 1, Zf = e;
  function e(t = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS: r = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH: n = (i) => `fast-redact – Invalid path (${i})`
    } = t;
    return function({ paths: s }) {
      s.forEach((o) => {
=======
    const s = n.slice(2), i = [];
    for (const o of s)
      o && i.push(o.getFileName());
    return i;
  }, pc;
}
var hc, Up;
function Ow() {
  if (Up) return hc;
  Up = 1, hc = e;
  function e(t = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS: r = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH: n = (s) => `fast-redact – Invalid path (${s})`
    } = t;
    return function({ paths: i }) {
      i.forEach((o) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        if (typeof o != "string")
          throw Error(r());
        try {
          if (/〇/.test(o)) throw Error();
          const a = (o[0] === "[" ? "" : ".") + o.replace(/^\*/, "〇").replace(/\.\*/g, ".〇").replace(/\[\*\]/g, "[〇]");
          if (/\n|\r|;/.test(a) || /\/\*/.test(a)) throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const 〇 = null;
            o${a}
            if ([o${a}].length !== 1) throw Error()`)();
        } catch {
          throw Error(n(o));
        }
      });
    };
  }
<<<<<<< HEAD
  return Zf;
}
var Qf, kv;
function mm() {
  return kv || (kv = 1, Qf = /[^.[\]]+|\[((?:.)*?)\]/g), Qf;
}
var ed, Dv;
function OI() {
  if (Dv) return ed;
  Dv = 1;
  const e = mm();
  ed = t;
  function t({ paths: r }) {
    const n = [];
    var i = 0;
    const s = r.reduce(function(o, a, c) {
      var u = a.match(e).map((m) => m.replace(/'|"|`/g, ""));
      const l = a[0] === "[";
      u = u.map((m) => m[0] === "[" ? m.substr(1, m.length - 2) : m);
      const f = u.indexOf("*");
      if (f > -1) {
        const m = u.slice(0, f), p = m.join("."), d = u.slice(f + 1, u.length), h = d.length > 0;
        i++, n.push({
          before: m,
          beforeStr: p,
          after: d,
=======
  return hc;
}
var mc, qp;
function Xu() {
  return qp || (qp = 1, mc = /[^.[\]]+|\[((?:.)*?)\]/g), mc;
}
var yc, Hp;
function Cw() {
  if (Hp) return yc;
  Hp = 1;
  const e = Xu();
  yc = t;
  function t({ paths: r }) {
    const n = [];
    var s = 0;
    const i = r.reduce(function(o, a, c) {
      var f = a.match(e).map((g) => g.replace(/'|"|`/g, ""));
      const l = a[0] === "[";
      f = f.map((g) => g[0] === "[" ? g.substr(1, g.length - 2) : g);
      const d = f.indexOf("*");
      if (d > -1) {
        const g = f.slice(0, d), p = g.join("."), u = f.slice(d + 1, f.length), h = u.length > 0;
        s++, n.push({
          before: g,
          beforeStr: p,
          after: u,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          nested: h
        });
      } else
        o[a] = {
<<<<<<< HEAD
          path: u,
=======
          path: f,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          val: void 0,
          precensored: !1,
          circle: "",
          escPath: JSON.stringify(a),
          leadingBracket: l
        };
      return o;
    }, {});
<<<<<<< HEAD
    return { wildcards: n, wcLen: i, secret: s };
  }
  return ed;
}
var td, Lv;
function PI() {
  if (Lv) return td;
  Lv = 1;
  const e = mm();
  td = t;
  function t({ secret: o, serialize: a, wcLen: c, strict: u, isCensorFct: l, censorFctTakesPath: f }, m) {
    const p = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${s(u, a)}
=======
    return { wildcards: n, wcLen: s, secret: i };
  }
  return yc;
}
var gc, Bp;
function Pw() {
  if (Bp) return gc;
  Bp = 1;
  const e = Xu();
  gc = t;
  function t({ secret: o, serialize: a, wcLen: c, strict: f, isCensorFct: l, censorFctTakesPath: d }, g) {
    const p = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${i(f, a)}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

<<<<<<< HEAD
    ${r(o, l, f)}
    this.compileRestore()
    ${n(c > 0, l, f)}
    this.secret = originalSecret
    ${i(a)}
  `).bind(m);
    return p.state = m, a === !1 && (p.restore = (d) => m.restore(d)), p;
  }
  function r(o, a, c) {
    return Object.keys(o).map((u) => {
      const { escPath: l, leadingBracket: f, path: m } = o[u], p = f ? 1 : 0, d = f ? "" : ".", h = [];
      for (var _; (_ = e.exec(u)) !== null; ) {
        const [, E] = _, { index: R, input: w } = _;
        R > p && h.push(w.substring(0, R - (E ? 0 : 1)));
      }
      var g = h.map((E) => `o${d}${E}`).join(" && ");
      g.length === 0 ? g += `o${d}${u} != null` : g += ` && o${d}${u} != null`;
      const v = `
      switch (true) {
        ${h.reverse().map((E) => `
          case o${d}${E} === censor:
            secret[${l}].circle = ${JSON.stringify(E)}
=======
    ${r(o, l, d)}
    this.compileRestore()
    ${n(c > 0, l, d)}
    this.secret = originalSecret
    ${s(a)}
  `).bind(g);
    return p.state = g, a === !1 && (p.restore = (u) => g.restore(u)), p;
  }
  function r(o, a, c) {
    return Object.keys(o).map((f) => {
      const { escPath: l, leadingBracket: d, path: g } = o[f], p = d ? 1 : 0, u = d ? "" : ".", h = [];
      for (var b; (b = e.exec(f)) !== null; ) {
        const [, _] = b, { index: R, input: E } = b;
        R > p && h.push(E.substring(0, R - (_ ? 0 : 1)));
      }
      var m = h.map((_) => `o${u}${_}`).join(" && ");
      m.length === 0 ? m += `o${u}${f} != null` : m += ` && o${u}${f} != null`;
      const v = `
      switch (true) {
        ${h.reverse().map((_) => `
          case o${u}${_} === censor:
            secret[${l}].circle = ${JSON.stringify(_)}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            break
        `).join(`
`)}
      }
<<<<<<< HEAD
    `, y = c ? `val, ${JSON.stringify(m)}` : "val";
      return `
      if (${g}) {
        const val = o${d}${u}
=======
    `, y = c ? `val, ${JSON.stringify(g)}` : "val";
      return `
      if (${m}) {
        const val = o${u}${f}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        if (val === censor) {
          secret[${l}].precensored = true
        } else {
          secret[${l}].val = val
<<<<<<< HEAD
          o${d}${u} = ${a ? `censor(${y})` : "censor"}
=======
          o${u}${f} = ${a ? `censor(${y})` : "censor"}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          ${v}
        }
      }
    `;
    }).join(`
`);
  }
  function n(o, a, c) {
    return o === !0 ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${a}, ${c})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${a}, ${c})
      }
    }
  ` : "";
  }
<<<<<<< HEAD
  function i(o) {
=======
  function s(o) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return o === !1 ? "return o" : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
<<<<<<< HEAD
  function s(o, a) {
    return o === !0 ? "throw Error('fast-redact: primitives cannot be redacted')" : a === !1 ? "return o" : "return this.serialize(o)";
  }
  return td;
}
var rd, Fv;
function px() {
  if (Fv) return rd;
  Fv = 1, rd = {
=======
  function i(o, a) {
    return o === !0 ? "throw Error('fast-redact: primitives cannot be redacted')" : a === !1 ? "return o" : "return this.serialize(o)";
  }
  return gc;
}
var vc, Vp;
function Qv() {
  if (Vp) return vc;
  Vp = 1, vc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    groupRedact: t,
    groupRestore: e,
    nestedRedact: n,
    nestedRestore: r
  };
<<<<<<< HEAD
  function e({ keys: f, values: m, target: p }) {
    if (p == null || typeof p == "string") return;
    const d = f.length;
    for (var h = 0; h < d; h++) {
      const _ = f[h];
      p[_] = m[h];
    }
  }
  function t(f, m, p, d, h) {
    const _ = o(f, m);
    if (_ == null || typeof _ == "string") return { keys: null, values: null, target: _, flat: !0 };
    const g = Object.keys(_), v = g.length, y = m.length, E = h ? [...m] : void 0, R = new Array(v);
    for (var w = 0; w < v; w++) {
      const C = g[w];
      R[w] = _[C], h ? (E[y] = C, _[C] = p(_[C], E)) : d ? _[C] = p(_[C]) : _[C] = p;
    }
    return { keys: g, values: R, target: _, flat: !0 };
  }
  function r(f) {
    for (let m = 0; m < f.length; m++) {
      const { target: p, path: d, value: h } = f[m];
      let _ = p;
      for (let g = d.length - 1; g > 0; g--)
        _ = _[d[g]];
      _[d[0]] = h;
    }
  }
  function n(f, m, p, d, h, _, g) {
    const v = o(m, p);
    if (v == null) return;
    const y = Object.keys(v), E = y.length;
    for (var R = 0; R < E; R++) {
      const w = y[R];
      s(f, v, w, p, d, h, _, g);
    }
    return f;
  }
  function i(f, m) {
    return f != null ? "hasOwn" in Object ? Object.hasOwn(f, m) : Object.prototype.hasOwnProperty.call(f, m) : !1;
  }
  function s(f, m, p, d, h, _, g, v) {
    const y = h.length, E = y - 1, R = p;
    var w = -1, C, V, b, F = null, H, q, $ = !1, x = 0, A = 0, P = c();
    if (b = C = m[p], typeof C == "object") {
      for (; C != null && ++w < y && (A += 1, p = h[w], !(p !== "*" && !F && !(typeof C == "object" && p in C))); )
        if (!(p === "*" && (F === "*" && ($ = !0), F = p, w !== E))) {
          if (F) {
            const I = Object.keys(C);
            for (var D = 0; D < I.length; D++) {
              const L = I[D];
              if (q = C[L], H = p === "*", $)
                P = u(P, L, A), x = w, b = a(q, x - 1, p, d, h, _, g, v, R, C, V, b, H, L, w, E, P, f, m[R], A + 1);
              else if (H || typeof q == "object" && q !== null && p in q) {
                if (H ? b = q : b = q[p], V = w !== E ? b : g ? v ? _(b, [...d, R, ...h]) : _(b) : _, H) {
                  const j = l(u(P, L, A), b, m[R]);
                  f.push(j), C[L] = V;
                } else if (q[p] !== V) if (V === void 0 && _ !== void 0 || i(q, p) && V === b)
                  P = u(P, L, A);
                else {
                  P = u(P, L, A);
                  const j = l(u(P, p, A + 1), b, m[R]);
                  f.push(j), q[p] = V;
                }
              }
            }
            F = null;
          } else {
            if (b = C[p], P = u(P, p, A), V = w !== E ? b : g ? v ? _(b, [...d, R, ...h]) : _(b) : _, !(i(C, p) && V === b || V === void 0 && _ !== void 0)) {
              const I = l(P, b, m[R]);
              f.push(I), C[p] = V;
            }
            C = C[p];
          }
          if (typeof C != "object") break;
        }
    }
  }
  function o(f, m) {
    for (var p = -1, d = m.length, h = f; h != null && ++p < d; )
      h = h[m[p]];
    return h;
  }
  function a(f, m, p, d, h, _, g, v, y, E, R, w, C, V, b, F, H, q, $, x) {
    if (m === 0 && (C || typeof f == "object" && f !== null && p in f)) {
      if (C ? w = f : w = f[p], R = b !== F ? w : g ? v ? _(w, [...d, y, ...h]) : _(w) : _, C) {
        const A = l(H, w, $);
        q.push(A), E[V] = R;
      } else if (f[p] !== R) {
        if (!(R === void 0 && _ !== void 0 || i(f, p) && R === w)) {
          const A = l(u(H, p, x + 1), w, $);
          q.push(A), f[p] = R;
        }
      }
    }
    for (const A in f)
      typeof f[A] == "object" && (H = u(H, A, x), a(f[A], m - 1, p, d, h, _, g, v, y, E, R, w, C, V, b, F, H, q, $, x + 1));
=======
  function e({ keys: d, values: g, target: p }) {
    if (p == null || typeof p == "string") return;
    const u = d.length;
    for (var h = 0; h < u; h++) {
      const b = d[h];
      p[b] = g[h];
    }
  }
  function t(d, g, p, u, h) {
    const b = o(d, g);
    if (b == null || typeof b == "string") return { keys: null, values: null, target: b, flat: !0 };
    const m = Object.keys(b), v = m.length, y = g.length, _ = h ? [...g] : void 0, R = new Array(v);
    for (var E = 0; E < v; E++) {
      const O = m[E];
      R[E] = b[O], h ? (_[y] = O, b[O] = p(b[O], _)) : u ? b[O] = p(b[O]) : b[O] = p;
    }
    return { keys: m, values: R, target: b, flat: !0 };
  }
  function r(d) {
    for (let g = 0; g < d.length; g++) {
      const { target: p, path: u, value: h } = d[g];
      let b = p;
      for (let m = u.length - 1; m > 0; m--)
        b = b[u[m]];
      b[u[0]] = h;
    }
  }
  function n(d, g, p, u, h, b, m) {
    const v = o(g, p);
    if (v == null) return;
    const y = Object.keys(v), _ = y.length;
    for (var R = 0; R < _; R++) {
      const E = y[R];
      i(d, v, E, p, u, h, b, m);
    }
    return d;
  }
  function s(d, g) {
    return d != null ? "hasOwn" in Object ? Object.hasOwn(d, g) : Object.prototype.hasOwnProperty.call(d, g) : !1;
  }
  function i(d, g, p, u, h, b, m, v) {
    const y = h.length, _ = y - 1, R = p;
    var E = -1, O, z, S, L = null, M, U, $ = !1, x = 0, I = 0, T = c();
    if (S = O = g[p], typeof O == "object") {
      for (; O != null && ++E < y && (I += 1, p = h[E], !(p !== "*" && !L && !(typeof O == "object" && p in O))); )
        if (!(p === "*" && (L === "*" && ($ = !0), L = p, E !== _))) {
          if (L) {
            const C = Object.keys(O);
            for (var j = 0; j < C.length; j++) {
              const A = C[j];
              if (U = O[A], M = p === "*", $)
                T = f(T, A, I), x = E, S = a(U, x - 1, p, u, h, b, m, v, R, O, z, S, M, A, E, _, T, d, g[R], I + 1);
              else if (M || typeof U == "object" && U !== null && p in U) {
                if (M ? S = U : S = U[p], z = E !== _ ? S : m ? v ? b(S, [...u, R, ...h]) : b(S) : b, M) {
                  const k = l(f(T, A, I), S, g[R]);
                  d.push(k), O[A] = z;
                } else if (U[p] !== z) if (z === void 0 && b !== void 0 || s(U, p) && z === S)
                  T = f(T, A, I);
                else {
                  T = f(T, A, I);
                  const k = l(f(T, p, I + 1), S, g[R]);
                  d.push(k), U[p] = z;
                }
              }
            }
            L = null;
          } else {
            if (S = O[p], T = f(T, p, I), z = E !== _ ? S : m ? v ? b(S, [...u, R, ...h]) : b(S) : b, !(s(O, p) && z === S || z === void 0 && b !== void 0)) {
              const C = l(T, S, g[R]);
              d.push(C), O[p] = z;
            }
            O = O[p];
          }
          if (typeof O != "object") break;
        }
    }
  }
  function o(d, g) {
    for (var p = -1, u = g.length, h = d; h != null && ++p < u; )
      h = h[g[p]];
    return h;
  }
  function a(d, g, p, u, h, b, m, v, y, _, R, E, O, z, S, L, M, U, $, x) {
    if (g === 0 && (O || typeof d == "object" && d !== null && p in d)) {
      if (O ? E = d : E = d[p], R = S !== L ? E : m ? v ? b(E, [...u, y, ...h]) : b(E) : b, O) {
        const I = l(M, E, $);
        U.push(I), _[z] = R;
      } else if (d[p] !== R) {
        if (!(R === void 0 && b !== void 0 || s(d, p) && R === E)) {
          const I = l(f(M, p, x + 1), E, $);
          U.push(I), d[p] = R;
        }
      }
    }
    for (const I in d)
      typeof d[I] == "object" && (M = f(M, I, x), a(d[I], g - 1, p, u, h, b, m, v, y, _, R, E, O, z, S, L, M, U, $, x + 1));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function c() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
<<<<<<< HEAD
  function u(f, m, p) {
    if (f.depth === p)
      return u(f.parent, m, p);
    var d = {
      parent: f,
      key: m,
      depth: p,
      children: []
    };
    return f.children.push(d), d;
  }
  function l(f, m, p) {
    let d = f;
    const h = [];
    do
      h.push(d.key), d = d.parent;
    while (d.parent != null);
    return { path: h, value: m, target: p };
  }
  return rd;
}
var nd, jv;
function CI() {
  if (jv) return nd;
  jv = 1;
  const { groupRestore: e, nestedRestore: t } = px();
  nd = r;
=======
  function f(d, g, p) {
    if (d.depth === p)
      return f(d.parent, g, p);
    var u = {
      parent: d,
      key: g,
      depth: p,
      children: []
    };
    return d.children.push(u), u;
  }
  function l(d, g, p) {
    let u = d;
    const h = [];
    do
      h.push(u.key), u = u.parent;
    while (u.parent != null);
    return { path: h, value: g, target: p };
  }
  return vc;
}
var bc, Gp;
function Iw() {
  if (Gp) return bc;
  Gp = 1;
  const { groupRestore: e, nestedRestore: t } = Qv();
  bc = r;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  function r() {
    return function() {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
<<<<<<< HEAD
      const { secret: o, wcLen: a } = this, c = Object.keys(o), u = n(o, c), l = a > 0, f = l ? { secret: o, groupRestore: e, nestedRestore: t } : { secret: o };
      this.restore = Function(
        "o",
        i(u, c, l)
      ).bind(f), this.restore.state = f;
    };
  }
  function n(s, o) {
    return o.map((a) => {
      const { circle: c, escPath: u, leadingBracket: l } = s[a], m = c ? `o.${c} = secret[${u}].val` : `o${l ? "" : "."}${a} = secret[${u}].val`, p = `secret[${u}].val = undefined`;
      return `
      if (secret[${u}].val !== undefined) {
        try { ${m} } catch (e) {}
=======
      const { secret: o, wcLen: a } = this, c = Object.keys(o), f = n(o, c), l = a > 0, d = l ? { secret: o, groupRestore: e, nestedRestore: t } : { secret: o };
      this.restore = Function(
        "o",
        s(f, c, l)
      ).bind(d), this.restore.state = d;
    };
  }
  function n(i, o) {
    return o.map((a) => {
      const { circle: c, escPath: f, leadingBracket: l } = i[a], g = c ? `o.${c} = secret[${f}].val` : `o${l ? "" : "."}${a} = secret[${f}].val`, p = `secret[${f}].val = undefined`;
      return `
      if (secret[${f}].val !== undefined) {
        try { ${g} } catch (e) {}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        ${p}
      }
    `;
    }).join("");
  }
<<<<<<< HEAD
  function i(s, o, a) {
=======
  function s(i, o, a) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return `
    const secret = this.secret
    ${a === !0 ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${o.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : ""}
<<<<<<< HEAD
    ${s}
    return o
  `;
  }
  return nd;
}
var id, Uv;
function AI() {
  if (Uv) return id;
  Uv = 1, id = e;
=======
    ${i}
    return o
  `;
  }
  return bc;
}
var _c, Wp;
function Nw() {
  if (Wp) return _c;
  Wp = 1, _c = e;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  function e(t) {
    const {
      secret: r,
      censor: n,
<<<<<<< HEAD
      compileRestore: i,
      serialize: s,
      groupRedact: o,
      nestedRedact: a,
      wildcards: c,
      wcLen: u
    } = t, l = [{ secret: r, censor: n, compileRestore: i }];
    return s !== !1 && l.push({ serialize: s }), u > 0 && l.push({ groupRedact: o, nestedRedact: a, wildcards: c, wcLen: u }), Object.assign(...l);
  }
  return id;
}
var sd, Mv;
function II() {
  if (Mv) return sd;
  Mv = 1;
  const e = TI(), t = OI(), r = PI(), n = CI(), { groupRedact: i, nestedRedact: s } = px(), o = AI(), a = mm(), c = e(), u = (m) => m;
  u.restore = u;
  const l = "[REDACTED]";
  f.rx = a, f.validator = e, sd = f;
  function f(m = {}) {
    const p = Array.from(new Set(m.paths || [])), d = "serialize" in m && (m.serialize === !1 || typeof m.serialize == "function") ? m.serialize : JSON.stringify, h = m.remove;
    if (h === !0 && d !== JSON.stringify)
      throw Error("fast-redact – remove option may only be set when serializer is JSON.stringify");
    const _ = h === !0 ? void 0 : "censor" in m ? m.censor : l, g = typeof _ == "function", v = g && _.length > 1;
    if (p.length === 0) return d || u;
    c({ paths: p, serialize: d, censor: _ });
    const { wildcards: y, wcLen: E, secret: R } = t({ paths: p, censor: _ }), w = n(), C = "strict" in m ? m.strict : !0;
    return r({ secret: R, wcLen: E, serialize: d, strict: C, isCensorFct: g, censorFctTakesPath: v }, o({
      secret: R,
      censor: _,
      compileRestore: w,
      serialize: d,
      groupRedact: i,
      nestedRedact: s,
      wildcards: y,
      wcLen: E
    }));
  }
  return sd;
}
var od, Hv;
function Ha() {
  if (Hv) return od;
  Hv = 1;
  const e = Symbol("pino.setLevel"), t = Symbol("pino.getLevel"), r = Symbol("pino.levelVal"), n = Symbol("pino.levelComp"), i = Symbol("pino.useLevelLabels"), s = Symbol("pino.useOnlyCustomLevels"), o = Symbol("pino.mixin"), a = Symbol("pino.lsCache"), c = Symbol("pino.chindings"), u = Symbol("pino.asJson"), l = Symbol("pino.write"), f = Symbol("pino.redactFmt"), m = Symbol("pino.time"), p = Symbol("pino.timeSliceIndex"), d = Symbol("pino.stream"), h = Symbol("pino.stringify"), _ = Symbol("pino.stringifySafe"), g = Symbol("pino.stringifiers"), v = Symbol("pino.end"), y = Symbol("pino.formatOpts"), E = Symbol("pino.messageKey"), R = Symbol("pino.errorKey"), w = Symbol("pino.nestedKey"), C = Symbol("pino.nestedKeyStr"), V = Symbol("pino.mixinMergeStrategy"), b = Symbol("pino.msgPrefix"), F = Symbol("pino.wildcardFirst"), H = Symbol.for("pino.serializers"), q = Symbol.for("pino.formatters"), $ = Symbol.for("pino.hooks"), x = Symbol.for("pino.metadata");
  return od = {
=======
      compileRestore: s,
      serialize: i,
      groupRedact: o,
      nestedRedact: a,
      wildcards: c,
      wcLen: f
    } = t, l = [{ secret: r, censor: n, compileRestore: s }];
    return i !== !1 && l.push({ serialize: i }), f > 0 && l.push({ groupRedact: o, nestedRedact: a, wildcards: c, wcLen: f }), Object.assign(...l);
  }
  return _c;
}
var Ec, Kp;
function Aw() {
  if (Kp) return Ec;
  Kp = 1;
  const e = Ow(), t = Cw(), r = Pw(), n = Iw(), { groupRedact: s, nestedRedact: i } = Qv(), o = Nw(), a = Xu(), c = e(), f = (g) => g;
  f.restore = f;
  const l = "[REDACTED]";
  d.rx = a, d.validator = e, Ec = d;
  function d(g = {}) {
    const p = Array.from(new Set(g.paths || [])), u = "serialize" in g && (g.serialize === !1 || typeof g.serialize == "function") ? g.serialize : JSON.stringify, h = g.remove;
    if (h === !0 && u !== JSON.stringify)
      throw Error("fast-redact – remove option may only be set when serializer is JSON.stringify");
    const b = h === !0 ? void 0 : "censor" in g ? g.censor : l, m = typeof b == "function", v = m && b.length > 1;
    if (p.length === 0) return u || f;
    c({ paths: p, serialize: u, censor: b });
    const { wildcards: y, wcLen: _, secret: R } = t({ paths: p, censor: b }), E = n(), O = "strict" in g ? g.strict : !0;
    return r({ secret: R, wcLen: _, serialize: u, strict: O, isCensorFct: m, censorFctTakesPath: v }, o({
      secret: R,
      censor: b,
      compileRestore: E,
      serialize: u,
      groupRedact: s,
      nestedRedact: i,
      wildcards: y,
      wcLen: _
    }));
  }
  return Ec;
}
var Sc, Jp;
function ui() {
  if (Jp) return Sc;
  Jp = 1;
  const e = Symbol("pino.setLevel"), t = Symbol("pino.getLevel"), r = Symbol("pino.levelVal"), n = Symbol("pino.levelComp"), s = Symbol("pino.useLevelLabels"), i = Symbol("pino.useOnlyCustomLevels"), o = Symbol("pino.mixin"), a = Symbol("pino.lsCache"), c = Symbol("pino.chindings"), f = Symbol("pino.asJson"), l = Symbol("pino.write"), d = Symbol("pino.redactFmt"), g = Symbol("pino.time"), p = Symbol("pino.timeSliceIndex"), u = Symbol("pino.stream"), h = Symbol("pino.stringify"), b = Symbol("pino.stringifySafe"), m = Symbol("pino.stringifiers"), v = Symbol("pino.end"), y = Symbol("pino.formatOpts"), _ = Symbol("pino.messageKey"), R = Symbol("pino.errorKey"), E = Symbol("pino.nestedKey"), O = Symbol("pino.nestedKeyStr"), z = Symbol("pino.mixinMergeStrategy"), S = Symbol("pino.msgPrefix"), L = Symbol("pino.wildcardFirst"), M = Symbol.for("pino.serializers"), U = Symbol.for("pino.formatters"), $ = Symbol.for("pino.hooks"), x = Symbol.for("pino.metadata");
  return Sc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    setLevelSym: e,
    getLevelSym: t,
    levelValSym: r,
    levelCompSym: n,
<<<<<<< HEAD
    useLevelLabelsSym: i,
    mixinSym: o,
    lsCacheSym: a,
    chindingsSym: c,
    asJsonSym: u,
    writeSym: l,
    serializersSym: H,
    redactFmtSym: f,
    timeSym: m,
    timeSliceIndexSym: p,
    streamSym: d,
    stringifySym: h,
    stringifySafeSym: _,
    stringifiersSym: g,
    endSym: v,
    formatOptsSym: y,
    messageKeySym: E,
    errorKeySym: R,
    nestedKeySym: w,
    wildcardFirstSym: F,
    needsMetadataGsym: x,
    useOnlyCustomLevelsSym: s,
    formattersSym: q,
    hooksSym: $,
    nestedKeyStrSym: C,
    mixinMergeStrategySym: V,
    msgPrefixSym: b
  }, od;
}
var ad, qv;
function hx() {
  if (qv) return ad;
  qv = 1;
  const e = II(), { redactFmtSym: t, wildcardFirstSym: r } = Ha(), { rx: n, validator: i } = e, s = i({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino – redacted paths must be strings",
    ERR_INVALID_PATH: (l) => `pino – redact paths array contains an invalid path (${l})`
  }), o = "[Redacted]", a = !1;
  function c(l, f) {
    const { paths: m, censor: p } = u(l), d = m.reduce((g, v) => {
      n.lastIndex = 0;
      const y = n.exec(v), E = n.exec(v);
      let R = y[1] !== void 0 ? y[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : y[0];
      if (R === "*" && (R = r), E === null)
        return g[R] = null, g;
      if (g[R] === null)
        return g;
      const { index: w } = E, C = `${v.substr(w, v.length - 1)}`;
      return g[R] = g[R] || [], R !== r && g[R].length === 0 && g[R].push(...g[r] || []), R === r && Object.keys(g).forEach(function(V) {
        g[V] && g[V].push(C);
      }), g[R].push(C), g;
    }, {}), h = {
      [t]: e({ paths: m, censor: p, serialize: f, strict: a })
    }, _ = (...g) => f(typeof p == "function" ? p(...g) : p);
    return [...Object.keys(d), ...Object.getOwnPropertySymbols(d)].reduce((g, v) => {
      if (d[v] === null)
        g[v] = (y) => _(y, [v]);
      else {
        const y = typeof p == "function" ? (E, R) => p(E, [v, ...R]) : p;
        g[v] = e({
          paths: d[v],
          censor: y,
          serialize: f,
          strict: a
        });
      }
      return g;
    }, h);
  }
  function u(l) {
    if (Array.isArray(l))
      return l = { paths: l, censor: o }, s(l), l;
    let { paths: f, censor: m = o, remove: p } = l;
    if (Array.isArray(f) === !1)
      throw Error("pino – redact must contain an array of strings");
    return p === !0 && (m = void 0), s({ paths: f, censor: m }), { paths: f, censor: m };
  }
  return ad = c, ad;
}
var cd, Bv;
function NI() {
  return Bv || (Bv = 1, cd = { nullTime: () => "", epochTime: () => `,"time":${Date.now()}`, unixTime: () => `,"time":${Math.round(Date.now() / 1e3)}`, isoTime: () => `,"time":"${new Date(Date.now()).toISOString()}"` }), cd;
}
var ld, zv;
function kI() {
  if (zv) return ld;
  zv = 1;
=======
    useLevelLabelsSym: s,
    mixinSym: o,
    lsCacheSym: a,
    chindingsSym: c,
    asJsonSym: f,
    writeSym: l,
    serializersSym: M,
    redactFmtSym: d,
    timeSym: g,
    timeSliceIndexSym: p,
    streamSym: u,
    stringifySym: h,
    stringifySafeSym: b,
    stringifiersSym: m,
    endSym: v,
    formatOptsSym: y,
    messageKeySym: _,
    errorKeySym: R,
    nestedKeySym: E,
    wildcardFirstSym: L,
    needsMetadataGsym: x,
    useOnlyCustomLevelsSym: i,
    formattersSym: U,
    hooksSym: $,
    nestedKeyStrSym: O,
    mixinMergeStrategySym: z,
    msgPrefixSym: S
  }, Sc;
}
var xc, Yp;
function eb() {
  if (Yp) return xc;
  Yp = 1;
  const e = Aw(), { redactFmtSym: t, wildcardFirstSym: r } = ui(), { rx: n, validator: s } = e, i = s({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino – redacted paths must be strings",
    ERR_INVALID_PATH: (l) => `pino – redact paths array contains an invalid path (${l})`
  }), o = "[Redacted]", a = !1;
  function c(l, d) {
    const { paths: g, censor: p } = f(l), u = g.reduce((m, v) => {
      n.lastIndex = 0;
      const y = n.exec(v), _ = n.exec(v);
      let R = y[1] !== void 0 ? y[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : y[0];
      if (R === "*" && (R = r), _ === null)
        return m[R] = null, m;
      if (m[R] === null)
        return m;
      const { index: E } = _, O = `${v.substr(E, v.length - 1)}`;
      return m[R] = m[R] || [], R !== r && m[R].length === 0 && m[R].push(...m[r] || []), R === r && Object.keys(m).forEach(function(z) {
        m[z] && m[z].push(O);
      }), m[R].push(O), m;
    }, {}), h = {
      [t]: e({ paths: g, censor: p, serialize: d, strict: a })
    }, b = (...m) => d(typeof p == "function" ? p(...m) : p);
    return [...Object.keys(u), ...Object.getOwnPropertySymbols(u)].reduce((m, v) => {
      if (u[v] === null)
        m[v] = (y) => b(y, [v]);
      else {
        const y = typeof p == "function" ? (_, R) => p(_, [v, ...R]) : p;
        m[v] = e({
          paths: u[v],
          censor: y,
          serialize: d,
          strict: a
        });
      }
      return m;
    }, h);
  }
  function f(l) {
    if (Array.isArray(l))
      return l = { paths: l, censor: o }, i(l), l;
    let { paths: d, censor: g = o, remove: p } = l;
    if (Array.isArray(d) === !1)
      throw Error("pino – redact must contain an array of strings");
    return p === !0 && (g = void 0), i({ paths: d, censor: g }), { paths: d, censor: g };
  }
  return xc = c, xc;
}
var wc, Xp;
function kw() {
  return Xp || (Xp = 1, wc = { nullTime: () => "", epochTime: () => `,"time":${Date.now()}`, unixTime: () => `,"time":${Math.round(Date.now() / 1e3)}`, isoTime: () => `,"time":"${new Date(Date.now()).toISOString()}"` }), wc;
}
var Rc, Zp;
function Lw() {
  if (Zp) return Rc;
  Zp = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  function e(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
<<<<<<< HEAD
  ld = t;
  function t(r, n, i) {
    var s = i && i.stringify || e, o = 1;
=======
  Rc = t;
  function t(r, n, s) {
    var i = s && s.stringify || e, o = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (typeof r == "object" && r !== null) {
      var a = n.length + o;
      if (a === 1) return r;
      var c = new Array(a);
<<<<<<< HEAD
      c[0] = s(r);
      for (var u = 1; u < a; u++)
        c[u] = s(n[u]);
=======
      c[0] = i(r);
      for (var f = 1; f < a; f++)
        c[f] = i(n[f]);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return c.join(" ");
    }
    if (typeof r != "string")
      return r;
    var l = n.length;
    if (l === 0) return r;
<<<<<<< HEAD
    for (var f = "", m = 1 - o, p = -1, d = r && r.length || 0, h = 0; h < d; ) {
      if (r.charCodeAt(h) === 37 && h + 1 < d) {
        switch (p = p > -1 ? p : 0, r.charCodeAt(h + 1)) {
          case 100:
          case 102:
            if (m >= l || n[m] == null) break;
            p < h && (f += r.slice(p, h)), f += Number(n[m]), p = h + 2, h++;
            break;
          case 105:
            if (m >= l || n[m] == null) break;
            p < h && (f += r.slice(p, h)), f += Math.floor(Number(n[m])), p = h + 2, h++;
=======
    for (var d = "", g = 1 - o, p = -1, u = r && r.length || 0, h = 0; h < u; ) {
      if (r.charCodeAt(h) === 37 && h + 1 < u) {
        switch (p = p > -1 ? p : 0, r.charCodeAt(h + 1)) {
          case 100:
          case 102:
            if (g >= l || n[g] == null) break;
            p < h && (d += r.slice(p, h)), d += Number(n[g]), p = h + 2, h++;
            break;
          case 105:
            if (g >= l || n[g] == null) break;
            p < h && (d += r.slice(p, h)), d += Math.floor(Number(n[g])), p = h + 2, h++;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            break;
          case 79:
          case 111:
          case 106:
<<<<<<< HEAD
            if (m >= l || n[m] === void 0) break;
            p < h && (f += r.slice(p, h));
            var _ = typeof n[m];
            if (_ === "string") {
              f += "'" + n[m] + "'", p = h + 2, h++;
              break;
            }
            if (_ === "function") {
              f += n[m].name || "<anonymous>", p = h + 2, h++;
              break;
            }
            f += s(n[m]), p = h + 2, h++;
            break;
          case 115:
            if (m >= l)
              break;
            p < h && (f += r.slice(p, h)), f += String(n[m]), p = h + 2, h++;
            break;
          case 37:
            p < h && (f += r.slice(p, h)), f += "%", p = h + 2, h++, m--;
            break;
        }
        ++m;
      }
      ++h;
    }
    return p === -1 ? r : (p < d && (f += r.slice(p)), f);
  }
  return ld;
}
var xc = { exports: {} }, Vv;
function mx() {
  if (Vv) return xc.exports;
  if (Vv = 1, typeof SharedArrayBuffer < "u" && typeof Atomics < "u") {
=======
            if (g >= l || n[g] === void 0) break;
            p < h && (d += r.slice(p, h));
            var b = typeof n[g];
            if (b === "string") {
              d += "'" + n[g] + "'", p = h + 2, h++;
              break;
            }
            if (b === "function") {
              d += n[g].name || "<anonymous>", p = h + 2, h++;
              break;
            }
            d += i(n[g]), p = h + 2, h++;
            break;
          case 115:
            if (g >= l)
              break;
            p < h && (d += r.slice(p, h)), d += String(n[g]), p = h + 2, h++;
            break;
          case 37:
            p < h && (d += r.slice(p, h)), d += "%", p = h + 2, h++, g--;
            break;
        }
        ++g;
      }
      ++h;
    }
    return p === -1 ? r : (p < u && (d += r.slice(p)), d);
  }
  return Rc;
}
var Ii = { exports: {} }, Qp;
function tb() {
  if (Qp) return Ii.exports;
  if (Qp = 1, typeof SharedArrayBuffer < "u" && typeof Atomics < "u") {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    let t = function(r) {
      if ((r > 0 && r < 1 / 0) === !1)
        throw typeof r != "number" && typeof r != "bigint" ? TypeError("sleep: ms must be a number") : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      Atomics.wait(e, 0, 0, Number(r));
    };
    const e = new Int32Array(new SharedArrayBuffer(4));
<<<<<<< HEAD
    xc.exports = t;
=======
    Ii.exports = t;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } else {
    let e = function(t) {
      if ((t > 0 && t < 1 / 0) === !1)
        throw typeof t != "number" && typeof t != "bigint" ? TypeError("sleep: ms must be a number") : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
    };
<<<<<<< HEAD
    xc.exports = e;
  }
  return xc.exports;
}
var ud, Gv;
function DI() {
  if (Gv) return ud;
  Gv = 1;
  const e = Ye, t = gu, r = wn.inherits, n = we, i = mx(), s = ka, o = 100, a = Buffer.allocUnsafe(0), c = 16 * 1024, u = "buffer", l = "utf8", [f, m] = (process.versions.node || "0.0").split(".").map(Number), p = f >= 22 && m >= 7;
  function d($, x) {
    x._opening = !0, x._writing = !0, x._asyncDrainScheduled = !1;
    function A(I, L) {
      if (I) {
        x._reopening = !1, x._writing = !1, x._opening = !1, x.sync ? process.nextTick(() => {
          x.listenerCount("error") > 0 && x.emit("error", I);
        }) : x.emit("error", I);
        return;
      }
      const j = x._reopening;
      x.fd = L, x.file = $, x._reopening = !1, x._opening = !1, x._writing = !1, x.sync ? process.nextTick(() => x.emit("ready")) : x.emit("ready"), !x.destroyed && (!x._writing && x._len > x.minLength || x._flushPending ? x._actualWrite() : j && process.nextTick(() => x.emit("drain")));
    }
    const P = x.append ? "a" : "w", D = x.mode;
    if (x.sync)
      try {
        x.mkdir && e.mkdirSync(n.dirname($), { recursive: !0 });
        const I = e.openSync($, P, D);
        A(null, I);
      } catch (I) {
        throw A(I), I;
      }
    else x.mkdir ? e.mkdir(n.dirname($), { recursive: !0 }, (I) => {
      if (I) return A(I);
      e.open($, P, D, A);
    }) : e.open($, P, D, A);
=======
    Ii.exports = e;
  }
  return Ii.exports;
}
var $c, eh;
function jw() {
  if (eh) return $c;
  eh = 1;
  const e = vt, t = gv, r = gn.inherits, n = rt, s = tb(), i = Uu, o = 100, a = Buffer.allocUnsafe(0), c = 16 * 1024, f = "buffer", l = "utf8", [d, g] = (process.versions.node || "0.0").split(".").map(Number), p = d >= 22 && g >= 7;
  function u($, x) {
    x._opening = !0, x._writing = !0, x._asyncDrainScheduled = !1;
    function I(C, A) {
      if (C) {
        x._reopening = !1, x._writing = !1, x._opening = !1, x.sync ? process.nextTick(() => {
          x.listenerCount("error") > 0 && x.emit("error", C);
        }) : x.emit("error", C);
        return;
      }
      const k = x._reopening;
      x.fd = A, x.file = $, x._reopening = !1, x._opening = !1, x._writing = !1, x.sync ? process.nextTick(() => x.emit("ready")) : x.emit("ready"), !x.destroyed && (!x._writing && x._len > x.minLength || x._flushPending ? x._actualWrite() : k && process.nextTick(() => x.emit("drain")));
    }
    const T = x.append ? "a" : "w", j = x.mode;
    if (x.sync)
      try {
        x.mkdir && e.mkdirSync(n.dirname($), { recursive: !0 });
        const C = e.openSync($, T, j);
        I(null, C);
      } catch (C) {
        throw I(C), C;
      }
    else x.mkdir ? e.mkdir(n.dirname($), { recursive: !0 }, (C) => {
      if (C) return I(C);
      e.open($, T, j, I);
    }) : e.open($, T, j, I);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function h($) {
    if (!(this instanceof h))
      return new h($);
<<<<<<< HEAD
    let { fd: x, dest: A, minLength: P, maxLength: D, maxWrite: I, periodicFlush: L, sync: j, append: k = !0, mkdir: U, retryEAGAIN: M, fsync: T, contentMode: N, mode: G } = $ || {};
    x = x || A, this._len = 0, this.fd = -1, this._bufs = [], this._lens = [], this._writing = !1, this._ending = !1, this._reopening = !1, this._asyncDrainScheduled = !1, this._flushPending = !1, this._hwm = Math.max(P || 0, 16387), this.file = null, this.destroyed = !1, this.minLength = P || 0, this.maxLength = D || 0, this.maxWrite = I || c, this._periodicFlush = L || 0, this._periodicFlushTimer = void 0, this.sync = j || !1, this.writable = !0, this._fsync = T || !1, this.append = k || !1, this.mode = G, this.retryEAGAIN = M || (() => !0), this.mkdir = U || !1;
    let O, S;
    if (N === u)
      this._writingBuf = a, this.write = E, this.flush = C, this.flushSync = b, this._actualWrite = H, O = () => e.writeSync(this.fd, this._writingBuf), S = () => e.write(this.fd, this._writingBuf, this.release);
    else if (N === void 0 || N === l)
      this._writingBuf = "", this.write = y, this.flush = w, this.flushSync = V, this._actualWrite = F, O = () => e.writeSync(this.fd, this._writingBuf, "utf8"), S = () => e.write(this.fd, this._writingBuf, "utf8", this.release);
    else
      throw new Error(`SonicBoom supports "${l}" and "${u}", but passed ${N}`);
    if (typeof x == "number")
      this.fd = x, process.nextTick(() => this.emit("ready"));
    else if (typeof x == "string")
      d(x, this);
=======
    let { fd: x, dest: I, minLength: T, maxLength: j, maxWrite: C, periodicFlush: A, sync: k, append: P = !0, mkdir: D, retryEAGAIN: F, fsync: w, contentMode: N, mode: q } = $ || {};
    x = x || I, this._len = 0, this.fd = -1, this._bufs = [], this._lens = [], this._writing = !1, this._ending = !1, this._reopening = !1, this._asyncDrainScheduled = !1, this._flushPending = !1, this._hwm = Math.max(T || 0, 16387), this.file = null, this.destroyed = !1, this.minLength = T || 0, this.maxLength = j || 0, this.maxWrite = C || c, this._periodicFlush = A || 0, this._periodicFlushTimer = void 0, this.sync = k || !1, this.writable = !0, this._fsync = w || !1, this.append = P || !1, this.mode = q, this.retryEAGAIN = F || (() => !0), this.mkdir = D || !1;
    let K, V;
    if (N === f)
      this._writingBuf = a, this.write = _, this.flush = O, this.flushSync = S, this._actualWrite = M, K = () => e.writeSync(this.fd, this._writingBuf), V = () => e.write(this.fd, this._writingBuf, this.release);
    else if (N === void 0 || N === l)
      this._writingBuf = "", this.write = y, this.flush = E, this.flushSync = z, this._actualWrite = L, K = () => e.writeSync(this.fd, this._writingBuf, "utf8"), V = () => e.write(this.fd, this._writingBuf, "utf8", this.release);
    else
      throw new Error(`SonicBoom supports "${l}" and "${f}", but passed ${N}`);
    if (typeof x == "number")
      this.fd = x, process.nextTick(() => this.emit("ready"));
    else if (typeof x == "string")
      u(x, this);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    else
      throw new Error("SonicBoom supports only file descriptors and files");
    if (this.minLength >= this.maxWrite)
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
<<<<<<< HEAD
    this.release = (W, z) => {
      if (W) {
        if ((W.code === "EAGAIN" || W.code === "EBUSY") && this.retryEAGAIN(W, this._writingBuf.length, this._len - this._writingBuf.length))
          if (this.sync)
            try {
              i(o), this.release(void 0, 0);
            } catch (X) {
              this.release(X);
            }
          else
            setTimeout(S, o);
        else
          this._writing = !1, this.emit("error", W);
        return;
      }
      this.emit("write", z);
      const Q = _(this._writingBuf, this._len, z);
      if (this._len = Q.len, this._writingBuf = Q.writingBuf, this._writingBuf.length) {
        if (!this.sync) {
          S();
=======
    this.release = (Z, Y) => {
      if (Z) {
        if ((Z.code === "EAGAIN" || Z.code === "EBUSY") && this.retryEAGAIN(Z, this._writingBuf.length, this._len - this._writingBuf.length))
          if (this.sync)
            try {
              s(o), this.release(void 0, 0);
            } catch (W) {
              this.release(W);
            }
          else
            setTimeout(V, o);
        else
          this._writing = !1, this.emit("error", Z);
        return;
      }
      this.emit("write", Y);
      const J = b(this._writingBuf, this._len, Y);
      if (this._len = J.len, this._writingBuf = J.writingBuf, this._writingBuf.length) {
        if (!this.sync) {
          V();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          return;
        }
        try {
          do {
<<<<<<< HEAD
            const X = O(), J = _(this._writingBuf, this._len, X);
            this._len = J.len, this._writingBuf = J.writingBuf;
          } while (this._writingBuf.length);
        } catch (X) {
          this.release(X);
=======
            const W = K(), G = b(this._writingBuf, this._len, W);
            this._len = G.len, this._writingBuf = G.writingBuf;
          } while (this._writingBuf.length);
        } catch (W) {
          this.release(W);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          return;
        }
      }
      this._fsync && e.fsyncSync(this.fd);
<<<<<<< HEAD
      const K = this._len;
      this._reopening ? (this._writing = !1, this._reopening = !1, this.reopen()) : K > this.minLength ? this._actualWrite() : this._ending ? K > 0 ? this._actualWrite() : (this._writing = !1, q(this)) : (this._writing = !1, this.sync ? this._asyncDrainScheduled || (this._asyncDrainScheduled = !0, process.nextTick(g, this)) : this.emit("drain"));
    }, this.on("newListener", function(W) {
      W === "drain" && (this._asyncDrainScheduled = !1);
    }), this._periodicFlush !== 0 && (this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush), this._periodicFlushTimer.unref());
  }
  function _($, x, A) {
    return typeof $ == "string" && Buffer.byteLength($) !== A && (A = Buffer.from($).subarray(0, A).toString().length), x = Math.max(x - A, 0), $ = $.slice(A), { writingBuf: $, len: x };
  }
  function g($) {
=======
      const H = this._len;
      this._reopening ? (this._writing = !1, this._reopening = !1, this.reopen()) : H > this.minLength ? this._actualWrite() : this._ending ? H > 0 ? this._actualWrite() : (this._writing = !1, U(this)) : (this._writing = !1, this.sync ? this._asyncDrainScheduled || (this._asyncDrainScheduled = !0, process.nextTick(m, this)) : this.emit("drain"));
    }, this.on("newListener", function(Z) {
      Z === "drain" && (this._asyncDrainScheduled = !1);
    }), this._periodicFlush !== 0 && (this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush), this._periodicFlushTimer.unref());
  }
  function b($, x, I) {
    return typeof $ == "string" && Buffer.byteLength($) !== I && (I = Buffer.from($).subarray(0, I).toString().length), x = Math.max(x - I, 0), $ = $.slice(I), { writingBuf: $, len: x };
  }
  function m($) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    $.listenerCount("drain") > 0 && ($._asyncDrainScheduled = !1, $.emit("drain"));
  }
  r(h, t);
  function v($, x) {
    return $.length === 0 ? a : $.length === 1 ? $[0] : Buffer.concat($, x);
  }
  function y($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
<<<<<<< HEAD
    const x = this._len + $.length, A = this._bufs;
    return this.maxLength && x > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (A.length === 0 || A[A.length - 1].length + $.length > this.maxWrite ? A.push("" + $) : A[A.length - 1] += $, this._len = x, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
  }
  function E($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    const x = this._len + $.length, A = this._bufs, P = this._lens;
    return this.maxLength && x > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (A.length === 0 || P[P.length - 1] + $.length > this.maxWrite ? (A.push([$]), P.push($.length)) : (A[A.length - 1].push($), P[P.length - 1] += $.length), this._len = x, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
=======
    const x = this._len + $.length, I = this._bufs;
    return this.maxLength && x > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (I.length === 0 || I[I.length - 1].length + $.length > this.maxWrite ? I.push("" + $) : I[I.length - 1] += $, this._len = x, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
  }
  function _($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    const x = this._len + $.length, I = this._bufs, T = this._lens;
    return this.maxLength && x > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (I.length === 0 || T[T.length - 1] + $.length > this.maxWrite ? (I.push([$]), T.push($.length)) : (I[I.length - 1].push($), T[T.length - 1] += $.length), this._len = x, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function R($) {
    this._flushPending = !0;
    const x = () => {
      if (this._fsync)
        this._flushPending = !1, $();
      else
        try {
<<<<<<< HEAD
          e.fsync(this.fd, (P) => {
            this._flushPending = !1, $(P);
          });
        } catch (P) {
          $(P);
        }
      this.off("error", A);
    }, A = (P) => {
      this._flushPending = !1, $(P), this.off("drain", x);
    };
    this.once("drain", x), this.once("error", A);
  }
  function w($) {
=======
          e.fsync(this.fd, (T) => {
            this._flushPending = !1, $(T);
          });
        } catch (T) {
          $(T);
        }
      this.off("error", I);
    }, I = (T) => {
      this._flushPending = !1, $(T), this.off("drain", x);
    };
    this.once("drain", x), this.once("error", I);
  }
  function E($) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if ($ != null && typeof $ != "function")
      throw new Error("flush cb must be a function");
    if (this.destroyed) {
      const x = new Error("SonicBoom destroyed");
      if ($) {
        $(x);
        return;
      }
      throw x;
    }
    if (this.minLength <= 0) {
      $ == null || $();
      return;
    }
    $ && R.call(this, $), !this._writing && (this._bufs.length === 0 && this._bufs.push(""), this._actualWrite());
  }
<<<<<<< HEAD
  function C($) {
=======
  function O($) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if ($ != null && typeof $ != "function")
      throw new Error("flush cb must be a function");
    if (this.destroyed) {
      const x = new Error("SonicBoom destroyed");
      if ($) {
        $(x);
        return;
      }
      throw x;
    }
    if (this.minLength <= 0) {
      $ == null || $();
      return;
    }
    $ && R.call(this, $), !this._writing && (this._bufs.length === 0 && (this._bufs.push([]), this._lens.push(0)), this._actualWrite());
  }
  h.prototype.reopen = function($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.reopen($);
      });
      return;
    }
    if (this._ending)
      return;
    if (!this.file)
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    if ($ && (this.file = $), this._reopening = !0, this._writing)
      return;
    const x = this.fd;
    this.once("ready", () => {
<<<<<<< HEAD
      x !== this.fd && e.close(x, (A) => {
        if (A)
          return this.emit("error", A);
      });
    }), d(this.file, this);
=======
      x !== this.fd && e.close(x, (I) => {
        if (I)
          return this.emit("error", I);
      });
    }), u(this.file, this);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }, h.prototype.end = function() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
<<<<<<< HEAD
    this._ending || (this._ending = !0, !this._writing && (this._len > 0 && this.fd >= 0 ? this._actualWrite() : q(this)));
  };
  function V() {
=======
    this._ending || (this._ending = !0, !this._writing && (this._len > 0 && this.fd >= 0 ? this._actualWrite() : U(this)));
  };
  function z() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this.fd < 0)
      throw new Error("sonic boom is not ready yet");
    !this._writing && this._writingBuf.length > 0 && (this._bufs.unshift(this._writingBuf), this._writingBuf = "");
    let $ = "";
    for (; this._bufs.length || $; ) {
      $.length <= 0 && ($ = this._bufs[0]);
      try {
<<<<<<< HEAD
        const x = e.writeSync(this.fd, $, "utf8"), A = _($, this._len, x);
        $ = A.writingBuf, this._len = A.len, $.length <= 0 && this._bufs.shift();
      } catch (x) {
        if ((x.code === "EAGAIN" || x.code === "EBUSY") && !this.retryEAGAIN(x, $.length, this._len - $.length))
          throw x;
        i(o);
=======
        const x = e.writeSync(this.fd, $, "utf8"), I = b($, this._len, x);
        $ = I.writingBuf, this._len = I.len, $.length <= 0 && this._bufs.shift();
      } catch (x) {
        if ((x.code === "EAGAIN" || x.code === "EBUSY") && !this.retryEAGAIN(x, $.length, this._len - $.length))
          throw x;
        s(o);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
    try {
      e.fsyncSync(this.fd);
    } catch {
    }
  }
<<<<<<< HEAD
  function b() {
=======
  function S() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this.fd < 0)
      throw new Error("sonic boom is not ready yet");
    !this._writing && this._writingBuf.length > 0 && (this._bufs.unshift([this._writingBuf]), this._writingBuf = a);
    let $ = a;
    for (; this._bufs.length || $.length; ) {
      $.length <= 0 && ($ = v(this._bufs[0], this._lens[0]));
      try {
        const x = e.writeSync(this.fd, $);
        $ = $.subarray(x), this._len = Math.max(this._len - x, 0), $.length <= 0 && (this._bufs.shift(), this._lens.shift());
      } catch (x) {
        if ((x.code === "EAGAIN" || x.code === "EBUSY") && !this.retryEAGAIN(x, $.length, this._len - $.length))
          throw x;
<<<<<<< HEAD
        i(o);
=======
        s(o);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
  h.prototype.destroy = function() {
<<<<<<< HEAD
    this.destroyed || q(this);
  };
  function F() {
=======
    this.destroyed || U(this);
  };
  function L() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const $ = this.release;
    if (this._writing = !0, this._writingBuf = this._writingBuf || this._bufs.shift() || "", this.sync)
      try {
        const x = e.writeSync(this.fd, this._writingBuf, "utf8");
        $(null, x);
      } catch (x) {
        $(x);
      }
    else
      e.write(this.fd, this._writingBuf, "utf8", $);
  }
<<<<<<< HEAD
  function H() {
=======
  function M() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const $ = this.release;
    if (this._writing = !0, this._writingBuf = this._writingBuf.length ? this._writingBuf : v(this._bufs.shift(), this._lens.shift()), this.sync)
      try {
        const x = e.writeSync(this.fd, this._writingBuf);
        $(null, x);
      } catch (x) {
        $(x);
      }
    else
      p && (this._writingBuf = Buffer.from(this._writingBuf)), e.write(this.fd, this._writingBuf, $);
  }
<<<<<<< HEAD
  function q($) {
    if ($.fd === -1) {
      $.once("ready", q.bind(null, $));
      return;
    }
    $._periodicFlushTimer !== void 0 && clearInterval($._periodicFlushTimer), $.destroyed = !0, $._bufs = [], $._lens = [], s(typeof $.fd == "number", `sonic.fd must be a number, got ${typeof $.fd}`);
=======
  function U($) {
    if ($.fd === -1) {
      $.once("ready", U.bind(null, $));
      return;
    }
    $._periodicFlushTimer !== void 0 && clearInterval($._periodicFlushTimer), $.destroyed = !0, $._bufs = [], $._lens = [], i(typeof $.fd == "number", `sonic.fd must be a number, got ${typeof $.fd}`);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    try {
      e.fsync($.fd, x);
    } catch {
    }
    function x() {
<<<<<<< HEAD
      $.fd !== 1 && $.fd !== 2 ? e.close($.fd, A) : A();
    }
    function A(P) {
      if (P) {
        $.emit("error", P);
=======
      $.fd !== 1 && $.fd !== 2 ? e.close($.fd, I) : I();
    }
    function I(T) {
      if (T) {
        $.emit("error", T);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return;
      }
      $._ending && !$._writing && $.emit("finish"), $.emit("close");
    }
  }
<<<<<<< HEAD
  return h.SonicBoom = h, h.default = h, ud = h, ud;
}
var fd, Wv;
function gx() {
  if (Wv) return fd;
  Wv = 1;
=======
  return h.SonicBoom = h, h.default = h, $c = h, $c;
}
var Tc, th;
function rb() {
  if (th) return Tc;
  th = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = {
    exit: [],
    beforeExit: []
  }, t = {
    exit: o,
    beforeExit: a
  };
  let r;
  function n() {
<<<<<<< HEAD
    r === void 0 && (r = new FinalizationRegistry(u));
  }
  function i(d) {
    e[d].length > 0 || process.on(d, t[d]);
  }
  function s(d) {
    e[d].length > 0 || (process.removeListener(d, t[d]), e.exit.length === 0 && e.beforeExit.length === 0 && (r = void 0));
=======
    r === void 0 && (r = new FinalizationRegistry(f));
  }
  function s(u) {
    e[u].length > 0 || process.on(u, t[u]);
  }
  function i(u) {
    e[u].length > 0 || (process.removeListener(u, t[u]), e.exit.length === 0 && e.beforeExit.length === 0 && (r = void 0));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function o() {
    c("exit");
  }
  function a() {
    c("beforeExit");
  }
<<<<<<< HEAD
  function c(d) {
    for (const h of e[d]) {
      const _ = h.deref(), g = h.fn;
      _ !== void 0 && g(_, d);
    }
    e[d] = [];
  }
  function u(d) {
    for (const h of ["exit", "beforeExit"]) {
      const _ = e[h].indexOf(d);
      e[h].splice(_, _ + 1), s(h);
    }
  }
  function l(d, h, _) {
    if (h === void 0)
      throw new Error("the object can't be undefined");
    i(d);
    const g = new WeakRef(h);
    g.fn = _, n(), r.register(h, g), e[d].push(g);
  }
  function f(d, h) {
    l("exit", d, h);
  }
  function m(d, h) {
    l("beforeExit", d, h);
  }
  function p(d) {
    if (r !== void 0) {
      r.unregister(d);
      for (const h of ["exit", "beforeExit"])
        e[h] = e[h].filter((_) => {
          const g = _.deref();
          return g && g !== d;
        }), s(h);
    }
  }
  return fd = {
    register: f,
    registerBeforeExit: m,
    unregister: p
  }, fd;
}
const LI = "3.1.0", FI = {
  version: LI
};
var dd, Kv;
function jI() {
  if (Kv) return dd;
  Kv = 1;
  const e = 1e3;
  function t(n, i, s, o, a) {
    const c = Date.now() + o;
    let u = Atomics.load(n, i);
    if (u === s) {
      a(null, "ok");
      return;
    }
    let l = u;
    const f = (m) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        l = u, u = Atomics.load(n, i), u === l ? f(m >= e ? e : m * 2) : u === s ? a(null, "ok") : a(null, "not-equal");
      }, m);
    };
    f(1);
  }
  function r(n, i, s, o, a) {
    const c = Date.now() + o;
    let u = Atomics.load(n, i);
    if (u !== s) {
      a(null, "ok");
      return;
    }
    const l = (f) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        u = Atomics.load(n, i), u !== s ? a(null, "ok") : l(f >= e ? e : f * 2);
      }, f);
    };
    l(1);
  }
  return dd = { wait: t, waitDiff: r }, dd;
}
var pd, Yv;
function UI() {
  return Yv || (Yv = 1, pd = {
    WRITE_INDEX: 4,
    READ_INDEX: 8
  }), pd;
}
var hd, Jv;
function MI() {
  if (Jv) return hd;
  Jv = 1;
  const { version: e } = FI, { EventEmitter: t } = gu, { Worker: r } = NS, { join: n } = we, { pathToFileURL: i } = Hr, { wait: s } = jI(), {
    WRITE_INDEX: o,
    READ_INDEX: a
  } = UI(), c = _C, u = ka, l = Symbol("kImpl"), f = c.constants.MAX_STRING_LENGTH;
  class m {
=======
  function c(u) {
    for (const h of e[u]) {
      const b = h.deref(), m = h.fn;
      b !== void 0 && m(b, u);
    }
    e[u] = [];
  }
  function f(u) {
    for (const h of ["exit", "beforeExit"]) {
      const b = e[h].indexOf(u);
      e[h].splice(b, b + 1), i(h);
    }
  }
  function l(u, h, b) {
    if (h === void 0)
      throw new Error("the object can't be undefined");
    s(u);
    const m = new WeakRef(h);
    m.fn = b, n(), r.register(h, m), e[u].push(m);
  }
  function d(u, h) {
    l("exit", u, h);
  }
  function g(u, h) {
    l("beforeExit", u, h);
  }
  function p(u) {
    if (r !== void 0) {
      r.unregister(u);
      for (const h of ["exit", "beforeExit"])
        e[h] = e[h].filter((b) => {
          const m = b.deref();
          return m && m !== u;
        }), i(h);
    }
  }
  return Tc = {
    register: d,
    registerBeforeExit: g,
    unregister: p
  }, Tc;
}
const Dw = "3.1.0", Fw = {
  version: Dw
};
var Oc, rh;
function Mw() {
  if (rh) return Oc;
  rh = 1;
  const e = 1e3;
  function t(n, s, i, o, a) {
    const c = Date.now() + o;
    let f = Atomics.load(n, s);
    if (f === i) {
      a(null, "ok");
      return;
    }
    let l = f;
    const d = (g) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        l = f, f = Atomics.load(n, s), f === l ? d(g >= e ? e : g * 2) : f === i ? a(null, "ok") : a(null, "not-equal");
      }, g);
    };
    d(1);
  }
  function r(n, s, i, o, a) {
    const c = Date.now() + o;
    let f = Atomics.load(n, s);
    if (f !== i) {
      a(null, "ok");
      return;
    }
    const l = (d) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        f = Atomics.load(n, s), f !== i ? a(null, "ok") : l(d >= e ? e : d * 2);
      }, d);
    };
    l(1);
  }
  return Oc = { wait: t, waitDiff: r }, Oc;
}
var Cc, nh;
function zw() {
  return nh || (nh = 1, Cc = {
    WRITE_INDEX: 4,
    READ_INDEX: 8
  }), Cc;
}
var Pc, sh;
function Uw() {
  if (sh) return Pc;
  sh = 1;
  const { version: e } = Fw, { EventEmitter: t } = gv, { Worker: r } = vv, { join: n } = rt, { pathToFileURL: s } = ni, { wait: i } = Mw(), {
    WRITE_INDEX: o,
    READ_INDEX: a
  } = zw(), c = ES, f = Uu, l = Symbol("kImpl"), d = c.constants.MAX_STRING_LENGTH;
  class g {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    constructor(x) {
      this._value = x;
    }
    deref() {
      return this._value;
    }
  }
  class p {
    register() {
    }
    unregister() {
    }
  }
<<<<<<< HEAD
  const d = process.env.NODE_V8_COVERAGE ? p : me.FinalizationRegistry || p, h = process.env.NODE_V8_COVERAGE ? m : me.WeakRef || m, _ = new d(($) => {
    $.exited || $.terminate();
  });
  function g($, x) {
    const { filename: A, workerData: P } = x, I = ("__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {})["thread-stream-worker"] || n(__dirname, "lib", "worker.js"), L = new r(I, {
      ...x.workerOpts,
      trackUnmanagedFds: !1,
      workerData: {
        filename: A.indexOf("file://") === 0 ? A : i(A).href,
=======
  const u = process.env.NODE_V8_COVERAGE ? p : _e.FinalizationRegistry || p, h = process.env.NODE_V8_COVERAGE ? g : _e.WeakRef || g, b = new u(($) => {
    $.exited || $.terminate();
  });
  function m($, x) {
    const { filename: I, workerData: T } = x, C = ("__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {})["thread-stream-worker"] || n(__dirname, "lib", "worker.js"), A = new r(C, {
      ...x.workerOpts,
      trackUnmanagedFds: !1,
      workerData: {
        filename: I.indexOf("file://") === 0 ? I : s(I).href,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        dataBuf: $[l].dataBuf,
        stateBuf: $[l].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: e
          },
<<<<<<< HEAD
          ...P
        }
      }
    });
    return L.stream = new m($), L.on("message", E), L.on("exit", R), _.register($, L), L;
  }
  function v($) {
    u(!$[l].sync), $[l].needDrain && ($[l].needDrain = !1, $.emit("drain"));
  }
  function y($) {
    const x = Atomics.load($[l].state, o);
    let A = $[l].data.length - x;
    if (A > 0) {
      if ($[l].buf.length === 0) {
        $[l].flushing = !1, $[l].ending ? F($) : $[l].needDrain && process.nextTick(v, $);
        return;
      }
      let P = $[l].buf.slice(0, A), D = Buffer.byteLength(P);
      D <= A ? ($[l].buf = $[l].buf.slice(A), b($, P, y.bind(null, $))) : $.flush(() => {
        if (!$.destroyed) {
          for (Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); D > $[l].data.length; )
            A = A / 2, P = $[l].buf.slice(0, A), D = Buffer.byteLength(P);
          $[l].buf = $[l].buf.slice(A), b($, P, y.bind(null, $));
        }
      });
    } else if (A === 0) {
=======
          ...T
        }
      }
    });
    return A.stream = new g($), A.on("message", _), A.on("exit", R), b.register($, A), A;
  }
  function v($) {
    f(!$[l].sync), $[l].needDrain && ($[l].needDrain = !1, $.emit("drain"));
  }
  function y($) {
    const x = Atomics.load($[l].state, o);
    let I = $[l].data.length - x;
    if (I > 0) {
      if ($[l].buf.length === 0) {
        $[l].flushing = !1, $[l].ending ? L($) : $[l].needDrain && process.nextTick(v, $);
        return;
      }
      let T = $[l].buf.slice(0, I), j = Buffer.byteLength(T);
      j <= I ? ($[l].buf = $[l].buf.slice(I), S($, T, y.bind(null, $))) : $.flush(() => {
        if (!$.destroyed) {
          for (Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); j > $[l].data.length; )
            I = I / 2, T = $[l].buf.slice(0, I), j = Buffer.byteLength(T);
          $[l].buf = $[l].buf.slice(I), S($, T, y.bind(null, $));
        }
      });
    } else if (I === 0) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (x === 0 && $[l].buf.length === 0)
        return;
      $.flush(() => {
        Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0), y($);
      });
    } else
<<<<<<< HEAD
      V($, new Error("overwritten"));
  }
  function E($) {
=======
      z($, new Error("overwritten"));
  }
  function _($) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const x = this.stream.deref();
    if (x === void 0) {
      this.exited = !0, this.terminate();
      return;
    }
    switch ($.code) {
      case "READY":
        this.stream = new h(x), x.flush(() => {
          x[l].ready = !0, x.emit("ready");
        });
        break;
      case "ERROR":
<<<<<<< HEAD
        V(x, $.err);
=======
        z(x, $.err);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        break;
      case "EVENT":
        Array.isArray($.args) ? x.emit($.name, ...$.args) : x.emit($.name, $.args);
        break;
      case "WARNING":
        process.emitWarning($.err);
        break;
      default:
<<<<<<< HEAD
        V(x, new Error("this should not happen: " + $.code));
=======
        z(x, new Error("this should not happen: " + $.code));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  }
  function R($) {
    const x = this.stream.deref();
<<<<<<< HEAD
    x !== void 0 && (_.unregister(x), x.worker.exited = !0, x.worker.off("exit", R), V(x, $ !== 0 ? new Error("the worker thread exited") : null));
  }
  class w extends t {
    constructor(x = {}) {
      if (super(), x.bufferSize < 4)
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      this[l] = {}, this[l].stateBuf = new SharedArrayBuffer(128), this[l].state = new Int32Array(this[l].stateBuf), this[l].dataBuf = new SharedArrayBuffer(x.bufferSize || 4 * 1024 * 1024), this[l].data = Buffer.from(this[l].dataBuf), this[l].sync = x.sync || !1, this[l].ending = !1, this[l].ended = !1, this[l].needDrain = !1, this[l].destroyed = !1, this[l].flushing = !1, this[l].ready = !1, this[l].finished = !1, this[l].errored = null, this[l].closed = !1, this[l].buf = "", this.worker = g(this, x), this.on("message", (A, P) => {
        this.worker.postMessage(A, P);
=======
    x !== void 0 && (b.unregister(x), x.worker.exited = !0, x.worker.off("exit", R), z(x, $ !== 0 ? new Error("the worker thread exited") : null));
  }
  class E extends t {
    constructor(x = {}) {
      if (super(), x.bufferSize < 4)
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      this[l] = {}, this[l].stateBuf = new SharedArrayBuffer(128), this[l].state = new Int32Array(this[l].stateBuf), this[l].dataBuf = new SharedArrayBuffer(x.bufferSize || 4 * 1024 * 1024), this[l].data = Buffer.from(this[l].dataBuf), this[l].sync = x.sync || !1, this[l].ending = !1, this[l].ended = !1, this[l].needDrain = !1, this[l].destroyed = !1, this[l].flushing = !1, this[l].ready = !1, this[l].finished = !1, this[l].errored = null, this[l].closed = !1, this[l].buf = "", this.worker = m(this, x), this.on("message", (I, T) => {
        this.worker.postMessage(I, T);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      });
    }
    write(x) {
      if (this[l].destroyed)
<<<<<<< HEAD
        return C(this, new Error("the worker has exited")), !1;
      if (this[l].ending)
        return C(this, new Error("the worker is ending")), !1;
      if (this[l].flushing && this[l].buf.length + x.length >= f)
        try {
          H(this), this[l].flushing = !0;
        } catch (A) {
          return V(this, A), !1;
        }
      if (this[l].buf += x, this[l].sync)
        try {
          return H(this), !0;
        } catch (A) {
          return V(this, A), !1;
=======
        return O(this, new Error("the worker has exited")), !1;
      if (this[l].ending)
        return O(this, new Error("the worker is ending")), !1;
      if (this[l].flushing && this[l].buf.length + x.length >= d)
        try {
          M(this), this[l].flushing = !0;
        } catch (I) {
          return z(this, I), !1;
        }
      if (this[l].buf += x, this[l].sync)
        try {
          return M(this), !0;
        } catch (I) {
          return z(this, I), !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      return this[l].flushing || (this[l].flushing = !0, setImmediate(y, this)), this[l].needDrain = this[l].data.length - this[l].buf.length - Atomics.load(this[l].state, o) <= 0, !this[l].needDrain;
    }
    end() {
<<<<<<< HEAD
      this[l].destroyed || (this[l].ending = !0, F(this));
=======
      this[l].destroyed || (this[l].ending = !0, L(this));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    flush(x) {
      if (this[l].destroyed) {
        typeof x == "function" && process.nextTick(x, new Error("the worker has exited"));
        return;
      }
<<<<<<< HEAD
      const A = Atomics.load(this[l].state, o);
      s(this[l].state, a, A, 1 / 0, (P, D) => {
        if (P) {
          V(this, P), process.nextTick(x, P);
          return;
        }
        if (D === "not-equal") {
=======
      const I = Atomics.load(this[l].state, o);
      i(this[l].state, a, I, 1 / 0, (T, j) => {
        if (T) {
          z(this, T), process.nextTick(x, T);
          return;
        }
        if (j === "not-equal") {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          this.flush(x);
          return;
        }
        process.nextTick(x);
      });
    }
    flushSync() {
<<<<<<< HEAD
      this[l].destroyed || (H(this), q(this));
=======
      this[l].destroyed || (M(this), U(this));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[l].ready;
    }
    get destroyed() {
      return this[l].destroyed;
    }
    get closed() {
      return this[l].closed;
    }
    get writable() {
      return !this[l].destroyed && !this[l].ending;
    }
    get writableEnded() {
      return this[l].ending;
    }
    get writableFinished() {
      return this[l].finished;
    }
    get writableNeedDrain() {
      return this[l].needDrain;
    }
    get writableObjectMode() {
      return !1;
    }
    get writableErrored() {
      return this[l].errored;
    }
  }
<<<<<<< HEAD
  function C($, x) {
=======
  function O($, x) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    setImmediate(() => {
      $.emit("error", x);
    });
  }
<<<<<<< HEAD
  function V($, x) {
    $[l].destroyed || ($[l].destroyed = !0, x && ($[l].errored = x, C($, x)), $.worker.exited ? setImmediate(() => {
=======
  function z($, x) {
    $[l].destroyed || ($[l].destroyed = !0, x && ($[l].errored = x, O($, x)), $.worker.exited ? setImmediate(() => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      $[l].closed = !0, $.emit("close");
    }) : $.worker.terminate().catch(() => {
    }).then(() => {
      $[l].closed = !0, $.emit("close");
    }));
  }
<<<<<<< HEAD
  function b($, x, A) {
    const P = Atomics.load($[l].state, o), D = Buffer.byteLength(x);
    return $[l].data.write(x, P), Atomics.store($[l].state, o, P + D), Atomics.notify($[l].state, o), A(), !0;
  }
  function F($) {
=======
  function S($, x, I) {
    const T = Atomics.load($[l].state, o), j = Buffer.byteLength(x);
    return $[l].data.write(x, T), Atomics.store($[l].state, o, T + j), Atomics.notify($[l].state, o), I(), !0;
  }
  function L($) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (!($[l].ended || !$[l].ending || $[l].flushing)) {
      $[l].ended = !0;
      try {
        $.flushSync();
        let x = Atomics.load($[l].state, a);
        Atomics.store($[l].state, o, -1), Atomics.notify($[l].state, o);
<<<<<<< HEAD
        let A = 0;
        for (; x !== -1; ) {
          if (Atomics.wait($[l].state, a, x, 1e3), x = Atomics.load($[l].state, a), x === -2) {
            V($, new Error("end() failed"));
            return;
          }
          if (++A === 10) {
            V($, new Error("end() took too long (10s)"));
=======
        let I = 0;
        for (; x !== -1; ) {
          if (Atomics.wait($[l].state, a, x, 1e3), x = Atomics.load($[l].state, a), x === -2) {
            z($, new Error("end() failed"));
            return;
          }
          if (++I === 10) {
            z($, new Error("end() took too long (10s)"));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            return;
          }
        }
        process.nextTick(() => {
          $[l].finished = !0, $.emit("finish");
        });
      } catch (x) {
<<<<<<< HEAD
        V($, x);
      }
    }
  }
  function H($) {
    const x = () => {
      $[l].ending ? F($) : $[l].needDrain && process.nextTick(v, $);
    };
    for ($[l].flushing = !1; $[l].buf.length !== 0; ) {
      const A = Atomics.load($[l].state, o);
      let P = $[l].data.length - A;
      if (P === 0) {
        q($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0);
        continue;
      } else if (P < 0)
        throw new Error("overwritten");
      let D = $[l].buf.slice(0, P), I = Buffer.byteLength(D);
      if (I <= P)
        $[l].buf = $[l].buf.slice(P), b($, D, x);
      else {
        for (q($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); I > $[l].buf.length; )
          P = P / 2, D = $[l].buf.slice(0, P), I = Buffer.byteLength(D);
        $[l].buf = $[l].buf.slice(P), b($, D, x);
      }
    }
  }
  function q($) {
    if ($[l].flushing)
      throw new Error("unable to flush while flushing");
    const x = Atomics.load($[l].state, o);
    let A = 0;
    for (; ; ) {
      const P = Atomics.load($[l].state, a);
      if (P === -2)
        throw Error("_flushSync failed");
      if (P !== x)
        Atomics.wait($[l].state, a, P, 1e3);
      else
        break;
      if (++A === 10)
        throw new Error("_flushSync took too long (10s)");
    }
  }
  return hd = w, hd;
}
var md, Xv;
function yx() {
  if (Xv) return md;
  Xv = 1;
  const { createRequire: e } = vC, t = dx(), { join: r, isAbsolute: n, sep: i } = hn, s = mx(), o = gx(), a = MI();
  function c(p) {
    o.register(p, l), o.registerBeforeExit(p, f), p.on("close", function() {
      o.unregister(p);
    });
  }
  function u(p, d, h, _) {
    const g = new a({
      filename: p,
      workerData: d,
      workerOpts: h,
      sync: _
    });
    g.on("ready", v), g.on("close", function() {
      process.removeListener("exit", y);
    }), process.on("exit", y);
    function v() {
      process.removeListener("exit", y), g.unref(), h.autoEnd !== !1 && c(g);
    }
    function y() {
      g.closed || (g.flushSync(), s(100), g.end());
    }
    return g;
=======
        z($, x);
      }
    }
  }
  function M($) {
    const x = () => {
      $[l].ending ? L($) : $[l].needDrain && process.nextTick(v, $);
    };
    for ($[l].flushing = !1; $[l].buf.length !== 0; ) {
      const I = Atomics.load($[l].state, o);
      let T = $[l].data.length - I;
      if (T === 0) {
        U($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0);
        continue;
      } else if (T < 0)
        throw new Error("overwritten");
      let j = $[l].buf.slice(0, T), C = Buffer.byteLength(j);
      if (C <= T)
        $[l].buf = $[l].buf.slice(T), S($, j, x);
      else {
        for (U($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); C > $[l].buf.length; )
          T = T / 2, j = $[l].buf.slice(0, T), C = Buffer.byteLength(j);
        $[l].buf = $[l].buf.slice(T), S($, j, x);
      }
    }
  }
  function U($) {
    if ($[l].flushing)
      throw new Error("unable to flush while flushing");
    const x = Atomics.load($[l].state, o);
    let I = 0;
    for (; ; ) {
      const T = Atomics.load($[l].state, a);
      if (T === -2)
        throw Error("_flushSync failed");
      if (T !== x)
        Atomics.wait($[l].state, a, T, 1e3);
      else
        break;
      if (++I === 10)
        throw new Error("_flushSync took too long (10s)");
    }
  }
  return Pc = E, Pc;
}
var Ic, ih;
function nb() {
  if (ih) return Ic;
  ih = 1;
  const { createRequire: e } = _S, t = Zv(), { join: r, isAbsolute: n, sep: s } = vr, i = tb(), o = rb(), a = Uw();
  function c(p) {
    o.register(p, l), o.registerBeforeExit(p, d), p.on("close", function() {
      o.unregister(p);
    });
  }
  function f(p, u, h, b) {
    const m = new a({
      filename: p,
      workerData: u,
      workerOpts: h,
      sync: b
    });
    m.on("ready", v), m.on("close", function() {
      process.removeListener("exit", y);
    }), process.on("exit", y);
    function v() {
      process.removeListener("exit", y), m.unref(), h.autoEnd !== !1 && c(m);
    }
    function y() {
      m.closed || (m.flushSync(), i(100), m.end());
    }
    return m;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function l(p) {
    p.ref(), p.flushSync(), p.end(), p.once("close", function() {
      p.unref();
    });
  }
<<<<<<< HEAD
  function f(p) {
    p.flushSync();
  }
  function m(p) {
    const { pipeline: d, targets: h, levels: _, dedupe: g, worker: v = {}, caller: y = t(), sync: E = !1 } = p, R = {
      ...p.options
    }, w = typeof y == "string" ? [y] : y, C = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let V = p.target;
    if (V && h)
      throw new Error("only one of target or targets can be specified");
    return h ? (V = C["pino-worker"] || r(__dirname, "worker.js"), R.targets = h.filter((F) => F.target).map((F) => ({
      ...F,
      target: b(F.target)
    })), R.pipelines = h.filter((F) => F.pipeline).map((F) => F.pipeline.map((H) => ({
      ...H,
      level: F.level,
      // duplicate the pipeline `level` property defined in the upper level
      target: b(H.target)
    })))) : d && (V = C["pino-worker"] || r(__dirname, "worker.js"), R.pipelines = [d.map((F) => ({
      ...F,
      target: b(F.target)
    }))]), _ && (R.levels = _), g && (R.dedupe = g), R.pinoWillSendConfig = !0, u(b(V), R, v, E);
    function b(F) {
      if (F = C[F] || F, n(F) || F.indexOf("file://") === 0)
        return F;
      if (F === "pino/file")
        return r(__dirname, "..", "file.js");
      let H;
      for (const q of w)
        try {
          const $ = q === "node:repl" ? process.cwd() + i : q;
          H = e($).resolve(F);
=======
  function d(p) {
    p.flushSync();
  }
  function g(p) {
    const { pipeline: u, targets: h, levels: b, dedupe: m, worker: v = {}, caller: y = t(), sync: _ = !1 } = p, R = {
      ...p.options
    }, E = typeof y == "string" ? [y] : y, O = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let z = p.target;
    if (z && h)
      throw new Error("only one of target or targets can be specified");
    return h ? (z = O["pino-worker"] || r(__dirname, "worker.js"), R.targets = h.filter((L) => L.target).map((L) => ({
      ...L,
      target: S(L.target)
    })), R.pipelines = h.filter((L) => L.pipeline).map((L) => L.pipeline.map((M) => ({
      ...M,
      level: L.level,
      // duplicate the pipeline `level` property defined in the upper level
      target: S(M.target)
    })))) : u && (z = O["pino-worker"] || r(__dirname, "worker.js"), R.pipelines = [u.map((L) => ({
      ...L,
      target: S(L.target)
    }))]), b && (R.levels = b), m && (R.dedupe = m), R.pinoWillSendConfig = !0, f(S(z), R, v, _);
    function S(L) {
      if (L = O[L] || L, n(L) || L.indexOf("file://") === 0)
        return L;
      if (L === "pino/file")
        return r(__dirname, "..", "file.js");
      let M;
      for (const U of E)
        try {
          const $ = U === "node:repl" ? process.cwd() + s : U;
          M = e($).resolve(L);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          break;
        } catch {
          continue;
        }
<<<<<<< HEAD
      if (!H)
        throw new Error(`unable to determine transport target for "${F}"`);
      return H;
    }
  }
  return md = m, md;
}
var gd, Zv;
function gm() {
  if (Zv) return gd;
  Zv = 1;
  const e = kI(), { mapHttpRequest: t, mapHttpResponse: r } = fx(), n = DI(), i = gx(), {
    lsCacheSym: s,
    chindingsSym: o,
    writeSym: a,
    serializersSym: c,
    formatOptsSym: u,
    endSym: l,
    stringifiersSym: f,
    stringifySym: m,
    stringifySafeSym: p,
    wildcardFirstSym: d,
    nestedKeySym: h,
    formattersSym: _,
    messageKeySym: g,
    errorKeySym: v,
    nestedKeyStrSym: y,
    msgPrefixSym: E
  } = Ha(), { isMainThread: R } = NS, w = yx();
  function C() {
  }
  function V(j, k) {
    if (!k) return U;
    return function(...T) {
      k.call(this, T, U, j);
    };
    function U(M, ...T) {
      if (typeof M == "object") {
        let N = M;
        M !== null && (M.method && M.headers && M.socket ? M = t(M) : typeof M.setHeader == "function" && (M = r(M)));
        let G;
        N === null && T.length === 0 ? G = [null] : (N = T.shift(), G = T), typeof this[E] == "string" && N !== void 0 && N !== null && (N = this[E] + N), this[a](M, e(N, G, this[u]), j);
      } else {
        let N = M === void 0 ? T.shift() : M;
        typeof this[E] == "string" && N !== void 0 && N !== null && (N = this[E] + N), this[a](null, e(N, T, this[u]), j);
      }
    }
  }
  function b(j) {
    let k = "", U = 0, M = !1, T = 255;
    const N = j.length;
    if (N > 100)
      return JSON.stringify(j);
    for (var G = 0; G < N && T >= 32; G++)
      T = j.charCodeAt(G), (T === 34 || T === 92) && (k += j.slice(U, G) + "\\", U = G, M = !0);
    return M ? k += j.slice(U) : k = j, T < 32 ? JSON.stringify(j) : '"' + k + '"';
  }
  function F(j, k, U, M) {
    const T = this[m], N = this[p], G = this[f], O = this[l], S = this[o], W = this[c], z = this[_], Q = this[g], K = this[v];
    let X = this[s][U] + M;
    X = X + S;
    let J;
    z.log && (j = z.log(j));
    const re = G[d];
    let fe = "";
    for (const le in j)
      if (J = j[le], Object.prototype.hasOwnProperty.call(j, le) && J !== void 0) {
        W[le] ? J = W[le](J) : le === K && W.err && (J = W.err(J));
        const Se = G[le] || re;
        switch (typeof J) {
=======
      if (!M)
        throw new Error(`unable to determine transport target for "${L}"`);
      return M;
    }
  }
  return Ic = g, Ic;
}
var Nc, oh;
function Zu() {
  if (oh) return Nc;
  oh = 1;
  const e = Lw(), { mapHttpRequest: t, mapHttpResponse: r } = Xv(), n = jw(), s = rb(), {
    lsCacheSym: i,
    chindingsSym: o,
    writeSym: a,
    serializersSym: c,
    formatOptsSym: f,
    endSym: l,
    stringifiersSym: d,
    stringifySym: g,
    stringifySafeSym: p,
    wildcardFirstSym: u,
    nestedKeySym: h,
    formattersSym: b,
    messageKeySym: m,
    errorKeySym: v,
    nestedKeyStrSym: y,
    msgPrefixSym: _
  } = ui(), { isMainThread: R } = vv, E = nb();
  function O() {
  }
  function z(k, P) {
    if (!P) return D;
    return function(...w) {
      P.call(this, w, D, k);
    };
    function D(F, ...w) {
      if (typeof F == "object") {
        let N = F;
        F !== null && (F.method && F.headers && F.socket ? F = t(F) : typeof F.setHeader == "function" && (F = r(F)));
        let q;
        N === null && w.length === 0 ? q = [null] : (N = w.shift(), q = w), typeof this[_] == "string" && N !== void 0 && N !== null && (N = this[_] + N), this[a](F, e(N, q, this[f]), k);
      } else {
        let N = F === void 0 ? w.shift() : F;
        typeof this[_] == "string" && N !== void 0 && N !== null && (N = this[_] + N), this[a](null, e(N, w, this[f]), k);
      }
    }
  }
  function S(k) {
    let P = "", D = 0, F = !1, w = 255;
    const N = k.length;
    if (N > 100)
      return JSON.stringify(k);
    for (var q = 0; q < N && w >= 32; q++)
      w = k.charCodeAt(q), (w === 34 || w === 92) && (P += k.slice(D, q) + "\\", D = q, F = !0);
    return F ? P += k.slice(D) : P = k, w < 32 ? JSON.stringify(k) : '"' + P + '"';
  }
  function L(k, P, D, F) {
    const w = this[g], N = this[p], q = this[d], K = this[l], V = this[o], Z = this[c], Y = this[b], J = this[m], H = this[v];
    let W = this[i][D] + F;
    W = W + V;
    let G;
    Y.log && (k = Y.log(k));
    const ee = q[u];
    let le = "";
    for (const ce in k)
      if (G = k[ce], Object.prototype.hasOwnProperty.call(k, ce) && G !== void 0) {
        Z[ce] ? G = Z[ce](G) : ce === H && Z.err && (G = Z.err(G));
        const Ee = q[ce] || ee;
        switch (typeof G) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "undefined":
          case "function":
            continue;
          case "number":
<<<<<<< HEAD
            Number.isFinite(J) === !1 && (J = null);
          case "boolean":
            Se && (J = Se(J));
            break;
          case "string":
            J = (Se || b)(J);
            break;
          default:
            J = (Se || T)(J, N);
        }
        if (J === void 0) continue;
        const ye = b(le);
        fe += "," + ye + ":" + J;
      }
    let ee = "";
    if (k !== void 0) {
      J = W[Q] ? W[Q](k) : k;
      const le = G[Q] || re;
      switch (typeof J) {
        case "function":
          break;
        case "number":
          Number.isFinite(J) === !1 && (J = null);
        case "boolean":
          le && (J = le(J)), ee = ',"' + Q + '":' + J;
          break;
        case "string":
          J = (le || b)(J), ee = ',"' + Q + '":' + J;
          break;
        default:
          J = (le || T)(J, N), ee = ',"' + Q + '":' + J;
      }
    }
    return this[h] && fe ? X + this[y] + fe.slice(1) + "}" + ee + O : X + fe + ee + O;
  }
  function H(j, k) {
    let U, M = j[o];
    const T = j[m], N = j[p], G = j[f], O = G[d], S = j[c], W = j[_].bindings;
    k = W(k);
    for (const z in k)
      if (U = k[z], (z !== "level" && z !== "serializers" && z !== "formatters" && z !== "customLevels" && k.hasOwnProperty(z) && U !== void 0) === !0) {
        if (U = S[z] ? S[z](U) : U, U = (G[z] || O || T)(U, N), U === void 0) continue;
        M += ',"' + z + '":' + U;
      }
    return M;
  }
  function q(j) {
    return j.write !== j.constructor.prototype.write;
  }
  const $ = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function x(j) {
    const k = new n(j);
    return k.on("error", U), !$ && !j.sync && R && (i.register(k, A), k.on("close", function() {
      i.unregister(k);
    })), k;
    function U(M) {
      if (M.code === "EPIPE") {
        k.write = C, k.end = C, k.flushSync = C, k.destroy = C;
        return;
      }
      k.removeListener("error", U), k.emit("error", M);
    }
  }
  function A(j, k) {
    j.destroyed || (k === "beforeExit" ? (j.flush(), j.on("drain", function() {
      j.end();
    })) : j.flushSync());
  }
  function P(j) {
    return function(U, M, T = {}, N) {
      if (typeof T == "string")
        N = x({ dest: T }), T = {};
      else if (typeof N == "string") {
        if (T && T.transport)
          throw Error("only one of option.transport or stream can be specified");
        N = x({ dest: N });
      } else if (T instanceof n || T.writable || T._writableState)
        N = T, T = {};
      else if (T.transport) {
        if (T.transport instanceof n || T.transport.writable || T.transport._writableState)
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        if (T.transport.targets && T.transport.targets.length && T.formatters && typeof T.formatters.level == "function")
          throw Error("option.transport.targets do not allow custom level formatters");
        let S;
        T.customLevels && (S = T.useOnlyCustomLevels ? T.customLevels : Object.assign({}, T.levels, T.customLevels)), N = w({ caller: M, ...T.transport, levels: S });
      }
      if (T = Object.assign({}, j, T), T.serializers = Object.assign({}, j.serializers, T.serializers), T.formatters = Object.assign({}, j.formatters, T.formatters), T.prettyPrint)
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      const { enabled: G, onChild: O } = T;
      return G === !1 && (T.level = "silent"), O || (T.onChild = C), N || (q(process.stdout) ? N = process.stdout : N = x({ fd: process.stdout.fd || 1 })), { opts: T, stream: N };
    };
  }
  function D(j, k) {
    try {
      return JSON.stringify(j);
    } catch {
      try {
        return (k || this[p])(j);
=======
            Number.isFinite(G) === !1 && (G = null);
          case "boolean":
            Ee && (G = Ee(G));
            break;
          case "string":
            G = (Ee || S)(G);
            break;
          default:
            G = (Ee || w)(G, N);
        }
        if (G === void 0) continue;
        const pe = S(ce);
        le += "," + pe + ":" + G;
      }
    let X = "";
    if (P !== void 0) {
      G = Z[J] ? Z[J](P) : P;
      const ce = q[J] || ee;
      switch (typeof G) {
        case "function":
          break;
        case "number":
          Number.isFinite(G) === !1 && (G = null);
        case "boolean":
          ce && (G = ce(G)), X = ',"' + J + '":' + G;
          break;
        case "string":
          G = (ce || S)(G), X = ',"' + J + '":' + G;
          break;
        default:
          G = (ce || w)(G, N), X = ',"' + J + '":' + G;
      }
    }
    return this[h] && le ? W + this[y] + le.slice(1) + "}" + X + K : W + le + X + K;
  }
  function M(k, P) {
    let D, F = k[o];
    const w = k[g], N = k[p], q = k[d], K = q[u], V = k[c], Z = k[b].bindings;
    P = Z(P);
    for (const Y in P)
      if (D = P[Y], (Y !== "level" && Y !== "serializers" && Y !== "formatters" && Y !== "customLevels" && P.hasOwnProperty(Y) && D !== void 0) === !0) {
        if (D = V[Y] ? V[Y](D) : D, D = (q[Y] || K || w)(D, N), D === void 0) continue;
        F += ',"' + Y + '":' + D;
      }
    return F;
  }
  function U(k) {
    return k.write !== k.constructor.prototype.write;
  }
  const $ = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function x(k) {
    const P = new n(k);
    return P.on("error", D), !$ && !k.sync && R && (s.register(P, I), P.on("close", function() {
      s.unregister(P);
    })), P;
    function D(F) {
      if (F.code === "EPIPE") {
        P.write = O, P.end = O, P.flushSync = O, P.destroy = O;
        return;
      }
      P.removeListener("error", D), P.emit("error", F);
    }
  }
  function I(k, P) {
    k.destroyed || (P === "beforeExit" ? (k.flush(), k.on("drain", function() {
      k.end();
    })) : k.flushSync());
  }
  function T(k) {
    return function(D, F, w = {}, N) {
      if (typeof w == "string")
        N = x({ dest: w }), w = {};
      else if (typeof N == "string") {
        if (w && w.transport)
          throw Error("only one of option.transport or stream can be specified");
        N = x({ dest: N });
      } else if (w instanceof n || w.writable || w._writableState)
        N = w, w = {};
      else if (w.transport) {
        if (w.transport instanceof n || w.transport.writable || w.transport._writableState)
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        if (w.transport.targets && w.transport.targets.length && w.formatters && typeof w.formatters.level == "function")
          throw Error("option.transport.targets do not allow custom level formatters");
        let V;
        w.customLevels && (V = w.useOnlyCustomLevels ? w.customLevels : Object.assign({}, w.levels, w.customLevels)), N = E({ caller: F, ...w.transport, levels: V });
      }
      if (w = Object.assign({}, k, w), w.serializers = Object.assign({}, k.serializers, w.serializers), w.formatters = Object.assign({}, k.formatters, w.formatters), w.prettyPrint)
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      const { enabled: q, onChild: K } = w;
      return q === !1 && (w.level = "silent"), K || (w.onChild = O), N || (U(process.stdout) ? N = process.stdout : N = x({ fd: process.stdout.fd || 1 })), { opts: w, stream: N };
    };
  }
  function j(k, P) {
    try {
      return JSON.stringify(k);
    } catch {
      try {
        return (P || this[p])(k);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      } catch {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
<<<<<<< HEAD
  function I(j, k, U) {
    return {
      level: j,
      bindings: k,
      log: U
    };
  }
  function L(j) {
    const k = Number(j);
    return typeof j == "string" && Number.isFinite(k) ? k : j === void 0 ? 1 : j;
  }
  return gd = {
    noop: C,
    buildSafeSonicBoom: x,
    asChindings: H,
    asJson: F,
    genLog: V,
    createArgsNormalizer: P,
    stringify: D,
    buildFormatters: I,
    normalizeDestFileDescriptor: L
  }, gd;
}
var yd, Qv;
function ym() {
  return Qv || (Qv = 1, yd = {
=======
  function C(k, P, D) {
    return {
      level: k,
      bindings: P,
      log: D
    };
  }
  function A(k) {
    const P = Number(k);
    return typeof k == "string" && Number.isFinite(P) ? P : k === void 0 ? 1 : k;
  }
  return Nc = {
    noop: O,
    buildSafeSonicBoom: x,
    asChindings: M,
    asJson: L,
    genLog: z,
    createArgsNormalizer: T,
    stringify: j,
    buildFormatters: C,
    normalizeDestFileDescriptor: A
  }, Nc;
}
var Ac, ah;
function Qu() {
  return ah || (ah = 1, Ac = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    DEFAULT_LEVELS: {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    },
    SORTING_ORDER: {
      ASC: "ASC",
      DESC: "DESC"
    }
<<<<<<< HEAD
  }), yd;
}
var vd, e0;
function vx() {
  if (e0) return vd;
  e0 = 1;
=======
  }), Ac;
}
var kc, ch;
function sb() {
  if (ch) return kc;
  ch = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const {
    lsCacheSym: e,
    levelValSym: t,
    useOnlyCustomLevelsSym: r,
    streamSym: n,
<<<<<<< HEAD
    formattersSym: i,
    hooksSym: s,
    levelCompSym: o
  } = Ha(), { noop: a, genLog: c } = gm(), { DEFAULT_LEVELS: u, SORTING_ORDER: l } = ym(), f = {
    fatal: (b) => {
      const F = c(u.fatal, b);
      return function(...H) {
        const q = this[n];
        if (F.call(this, ...H), typeof q.flushSync == "function")
          try {
            q.flushSync();
=======
    formattersSym: s,
    hooksSym: i,
    levelCompSym: o
  } = ui(), { noop: a, genLog: c } = Zu(), { DEFAULT_LEVELS: f, SORTING_ORDER: l } = Qu(), d = {
    fatal: (S) => {
      const L = c(f.fatal, S);
      return function(...M) {
        const U = this[n];
        if (L.call(this, ...M), typeof U.flushSync == "function")
          try {
            U.flushSync();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          } catch {
          }
      };
    },
<<<<<<< HEAD
    error: (b) => c(u.error, b),
    warn: (b) => c(u.warn, b),
    info: (b) => c(u.info, b),
    debug: (b) => c(u.debug, b),
    trace: (b) => c(u.trace, b)
  }, m = Object.keys(u).reduce((b, F) => (b[u[F]] = F, b), {}), p = Object.keys(m).reduce((b, F) => (b[F] = '{"level":' + Number(F), b), {});
  function d(b) {
    const F = b[i].level, { labels: H } = b.levels, q = {};
    for (const $ in H) {
      const x = F(H[$], Number($));
      q[$] = JSON.stringify(x).slice(0, -1);
    }
    return b[e] = q, b;
  }
  function h(b, F) {
    if (F)
      return !1;
    switch (b) {
=======
    error: (S) => c(f.error, S),
    warn: (S) => c(f.warn, S),
    info: (S) => c(f.info, S),
    debug: (S) => c(f.debug, S),
    trace: (S) => c(f.trace, S)
  }, g = Object.keys(f).reduce((S, L) => (S[f[L]] = L, S), {}), p = Object.keys(g).reduce((S, L) => (S[L] = '{"level":' + Number(L), S), {});
  function u(S) {
    const L = S[s].level, { labels: M } = S.levels, U = {};
    for (const $ in M) {
      const x = L(M[$], Number($));
      U[$] = JSON.stringify(x).slice(0, -1);
    }
    return S[e] = U, S;
  }
  function h(S, L) {
    if (L)
      return !1;
    switch (S) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return !0;
      default:
        return !1;
    }
  }
<<<<<<< HEAD
  function _(b) {
    const { labels: F, values: H } = this.levels;
    if (typeof b == "number") {
      if (F[b] === void 0) throw Error("unknown level value" + b);
      b = F[b];
    }
    if (H[b] === void 0) throw Error("unknown level " + b);
    const q = this[t], $ = this[t] = H[b], x = this[r], A = this[o], P = this[s].logMethod;
    for (const D in H) {
      if (A(H[D], $) === !1) {
        this[D] = a;
        continue;
      }
      this[D] = h(D, x) ? f[D](P) : c(H[D], P);
    }
    this.emit(
      "level-change",
      b,
      $,
      F[q],
      q,
      this
    );
  }
  function g(b) {
    const { levels: F, levelVal: H } = this;
    return F && F.labels ? F.labels[H] : "";
  }
  function v(b) {
    const { values: F } = this.levels, H = F[b];
    return H !== void 0 && this[o](H, this[t]);
  }
  function y(b, F, H) {
    return b === l.DESC ? F <= H : F >= H;
  }
  function E(b) {
    return typeof b == "string" ? y.bind(null, b) : b;
  }
  function R(b = null, F = !1) {
    const H = b ? Object.keys(b).reduce((x, A) => (x[b[A]] = A, x), {}) : null, q = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      F ? null : m,
      H
    ), $ = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      F ? null : u,
      b
    );
    return { labels: q, values: $ };
  }
  function w(b, F, H) {
    if (typeof b == "number") {
      if (![].concat(
        Object.keys(F || {}).map((x) => F[x]),
        H ? [] : Object.keys(m).map((x) => +x),
        1 / 0
      ).includes(b))
        throw Error(`default level:${b} must be included in custom levels`);
      return;
    }
    const q = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      H ? null : u,
      F
    );
    if (!(b in q))
      throw Error(`default level:${b} must be included in custom levels`);
  }
  function C(b, F) {
    const { labels: H, values: q } = b;
    for (const $ in F) {
      if ($ in q)
        throw Error("levels cannot be overridden");
      if (F[$] in H)
        throw Error("pre-existing level values cannot be used for new levels");
    }
  }
  function V(b) {
    if (typeof b != "function" && !(typeof b == "string" && Object.values(l).includes(b)))
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  return vd = {
    initialLsCache: p,
    genLsCache: d,
    levelMethods: f,
    getLevel: g,
    setLevel: _,
    isLevelEnabled: v,
    mappings: R,
    assertNoLevelCollisions: C,
    assertDefaultLevelFound: w,
    genLevelComparison: E,
    assertLevelComparison: V
  }, vd;
}
var _d, t0;
function _x() {
  return t0 || (t0 = 1, _d = { version: "9.6.0" }), _d;
}
var bd, r0;
function HI() {
  if (r0) return bd;
  r0 = 1;
  const { EventEmitter: e } = hu, {
    lsCacheSym: t,
    levelValSym: r,
    setLevelSym: n,
    getLevelSym: i,
    chindingsSym: s,
    parsedChindingsSym: o,
    mixinSym: a,
    asJsonSym: c,
    writeSym: u,
    mixinMergeStrategySym: l,
    timeSym: f,
    timeSliceIndexSym: m,
    streamSym: p,
    serializersSym: d,
    formattersSym: h,
    errorKeySym: _,
    messageKeySym: g,
    useOnlyCustomLevelsSym: v,
    needsMetadataGsym: y,
    redactFmtSym: E,
    stringifySym: R,
    formatOptsSym: w,
    stringifiersSym: C,
    msgPrefixSym: V,
    hooksSym: b
  } = Ha(), {
    getLevel: F,
    setLevel: H,
    isLevelEnabled: q,
    mappings: $,
    initialLsCache: x,
    genLsCache: A,
    assertNoLevelCollisions: P
  } = vx(), {
    asChindings: D,
    asJson: I,
    buildFormatters: L,
    stringify: j
  } = gm(), {
    version: k
  } = _x(), U = hx(), T = {
    constructor: class {
    },
    child: G,
    bindings: O,
    setBindings: S,
    flush: K,
    isLevelEnabled: q,
    version: k,
    get level() {
      return this[i]();
    },
    set level(X) {
      this[n](X);
=======
  function b(S) {
    const { labels: L, values: M } = this.levels;
    if (typeof S == "number") {
      if (L[S] === void 0) throw Error("unknown level value" + S);
      S = L[S];
    }
    if (M[S] === void 0) throw Error("unknown level " + S);
    const U = this[t], $ = this[t] = M[S], x = this[r], I = this[o], T = this[i].logMethod;
    for (const j in M) {
      if (I(M[j], $) === !1) {
        this[j] = a;
        continue;
      }
      this[j] = h(j, x) ? d[j](T) : c(M[j], T);
    }
    this.emit(
      "level-change",
      S,
      $,
      L[U],
      U,
      this
    );
  }
  function m(S) {
    const { levels: L, levelVal: M } = this;
    return L && L.labels ? L.labels[M] : "";
  }
  function v(S) {
    const { values: L } = this.levels, M = L[S];
    return M !== void 0 && this[o](M, this[t]);
  }
  function y(S, L, M) {
    return S === l.DESC ? L <= M : L >= M;
  }
  function _(S) {
    return typeof S == "string" ? y.bind(null, S) : S;
  }
  function R(S = null, L = !1) {
    const M = S ? Object.keys(S).reduce((x, I) => (x[S[I]] = I, x), {}) : null, U = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      L ? null : g,
      M
    ), $ = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      L ? null : f,
      S
    );
    return { labels: U, values: $ };
  }
  function E(S, L, M) {
    if (typeof S == "number") {
      if (![].concat(
        Object.keys(L || {}).map((x) => L[x]),
        M ? [] : Object.keys(g).map((x) => +x),
        1 / 0
      ).includes(S))
        throw Error(`default level:${S} must be included in custom levels`);
      return;
    }
    const U = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      M ? null : f,
      L
    );
    if (!(S in U))
      throw Error(`default level:${S} must be included in custom levels`);
  }
  function O(S, L) {
    const { labels: M, values: U } = S;
    for (const $ in L) {
      if ($ in U)
        throw Error("levels cannot be overridden");
      if (L[$] in M)
        throw Error("pre-existing level values cannot be used for new levels");
    }
  }
  function z(S) {
    if (typeof S != "function" && !(typeof S == "string" && Object.values(l).includes(S)))
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  return kc = {
    initialLsCache: p,
    genLsCache: u,
    levelMethods: d,
    getLevel: m,
    setLevel: b,
    isLevelEnabled: v,
    mappings: R,
    assertNoLevelCollisions: O,
    assertDefaultLevelFound: E,
    genLevelComparison: _,
    assertLevelComparison: z
  }, kc;
}
var Lc, lh;
function ib() {
  return lh || (lh = 1, Lc = { version: "9.6.0" }), Lc;
}
var jc, uh;
function qw() {
  if (uh) return jc;
  uh = 1;
  const { EventEmitter: e } = Qo, {
    lsCacheSym: t,
    levelValSym: r,
    setLevelSym: n,
    getLevelSym: s,
    chindingsSym: i,
    parsedChindingsSym: o,
    mixinSym: a,
    asJsonSym: c,
    writeSym: f,
    mixinMergeStrategySym: l,
    timeSym: d,
    timeSliceIndexSym: g,
    streamSym: p,
    serializersSym: u,
    formattersSym: h,
    errorKeySym: b,
    messageKeySym: m,
    useOnlyCustomLevelsSym: v,
    needsMetadataGsym: y,
    redactFmtSym: _,
    stringifySym: R,
    formatOptsSym: E,
    stringifiersSym: O,
    msgPrefixSym: z,
    hooksSym: S
  } = ui(), {
    getLevel: L,
    setLevel: M,
    isLevelEnabled: U,
    mappings: $,
    initialLsCache: x,
    genLsCache: I,
    assertNoLevelCollisions: T
  } = sb(), {
    asChindings: j,
    asJson: C,
    buildFormatters: A,
    stringify: k
  } = Zu(), {
    version: P
  } = ib(), D = eb(), w = {
    constructor: class {
    },
    child: q,
    bindings: K,
    setBindings: V,
    flush: H,
    isLevelEnabled: U,
    version: P,
    get level() {
      return this[s]();
    },
    set level(W) {
      this[n](W);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get levelVal() {
      return this[r];
    },
<<<<<<< HEAD
    set levelVal(X) {
      throw Error("levelVal is read-only");
    },
    [t]: x,
    [u]: z,
    [c]: I,
    [i]: F,
    [n]: H
  };
  Object.setPrototypeOf(T, e.prototype), bd = function() {
    return Object.create(T);
  };
  const N = (X) => X;
  function G(X, J) {
    if (!X)
      throw Error("missing bindings for child Pino");
    J = J || {};
    const re = this[d], fe = this[h], ee = Object.create(this);
    if (J.hasOwnProperty("serializers") === !0) {
      ee[d] = /* @__PURE__ */ Object.create(null);
      for (const Ae in re)
        ee[d][Ae] = re[Ae];
      const ve = Object.getOwnPropertySymbols(re);
      for (var le = 0; le < ve.length; le++) {
        const Ae = ve[le];
        ee[d][Ae] = re[Ae];
      }
      for (const Ae in J.serializers)
        ee[d][Ae] = J.serializers[Ae];
      const qe = Object.getOwnPropertySymbols(J.serializers);
      for (var Se = 0; Se < qe.length; Se++) {
        const Ae = qe[Se];
        ee[d][Ae] = J.serializers[Ae];
      }
    } else ee[d] = re;
    if (J.hasOwnProperty("formatters")) {
      const { level: ve, bindings: qe, log: Ae } = J.formatters;
      ee[h] = L(
        ve || fe.level,
        qe || N,
        Ae || fe.log
      );
    } else
      ee[h] = L(
        fe.level,
        N,
        fe.log
      );
    if (J.hasOwnProperty("customLevels") === !0 && (P(this.levels, J.customLevels), ee.levels = $(J.customLevels, ee[v]), A(ee)), typeof J.redact == "object" && J.redact !== null || Array.isArray(J.redact)) {
      ee.redact = J.redact;
      const ve = U(ee.redact, j), qe = { stringify: ve[E] };
      ee[R] = j, ee[C] = ve, ee[w] = qe;
    }
    typeof J.msgPrefix == "string" && (ee[V] = (this[V] || "") + J.msgPrefix), ee[s] = D(ee, X);
    const ye = J.level || this.level;
    return ee[n](ye), this.onChild(ee), ee;
  }
  function O() {
    const J = `{${this[s].substr(1)}}`, re = JSON.parse(J);
    return delete re.pid, delete re.hostname, re;
  }
  function S(X) {
    const J = D(this, X);
    this[s] = J, delete this[o];
  }
  function W(X, J) {
    return Object.assign(J, X);
  }
  function z(X, J, re) {
    const fe = this[f](), ee = this[a], le = this[_], Se = this[g], ye = this[l] || W;
    let ve;
    const qe = this[b].streamWrite;
    X == null ? ve = {} : X instanceof Error ? (ve = { [le]: X }, J === void 0 && (J = X.message)) : (ve = X, J === void 0 && X[Se] === void 0 && X[le] && (J = X[le].message)), ee && (ve = ye(ve, ee(ve, re, this)));
    const Ae = this[c](ve, J, re, fe), $t = this[p];
    $t[y] === !0 && ($t.lastLevel = re, $t.lastObj = ve, $t.lastMsg = J, $t.lastTime = fe.slice(this[m]), $t.lastLogger = this), $t.write(qe ? qe(Ae) : Ae);
  }
  function Q() {
  }
  function K(X) {
    if (X != null && typeof X != "function")
      throw Error("callback must be a function");
    const J = this[p];
    typeof J.flush == "function" ? J.flush(X || Q) : X && X();
  }
  return bd;
}
var Rc = { exports: {} }, n0;
function qI() {
  return n0 || (n0 = 1, function(e, t) {
    const { hasOwnProperty: r } = Object.prototype, n = g();
    n.configure = g, n.stringify = n, n.default = n, t.stringify = n, t.configure = g, e.exports = n;
    const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function s(v) {
      return v.length < 5e3 && !i.test(v) ? `"${v}"` : JSON.stringify(v);
=======
    set levelVal(W) {
      throw Error("levelVal is read-only");
    },
    [t]: x,
    [f]: Y,
    [c]: C,
    [s]: L,
    [n]: M
  };
  Object.setPrototypeOf(w, e.prototype), jc = function() {
    return Object.create(w);
  };
  const N = (W) => W;
  function q(W, G) {
    if (!W)
      throw Error("missing bindings for child Pino");
    G = G || {};
    const ee = this[u], le = this[h], X = Object.create(this);
    if (G.hasOwnProperty("serializers") === !0) {
      X[u] = /* @__PURE__ */ Object.create(null);
      for (const we in ee)
        X[u][we] = ee[we];
      const me = Object.getOwnPropertySymbols(ee);
      for (var ce = 0; ce < me.length; ce++) {
        const we = me[ce];
        X[u][we] = ee[we];
      }
      for (const we in G.serializers)
        X[u][we] = G.serializers[we];
      const We = Object.getOwnPropertySymbols(G.serializers);
      for (var Ee = 0; Ee < We.length; Ee++) {
        const we = We[Ee];
        X[u][we] = G.serializers[we];
      }
    } else X[u] = ee;
    if (G.hasOwnProperty("formatters")) {
      const { level: me, bindings: We, log: we } = G.formatters;
      X[h] = A(
        me || le.level,
        We || N,
        we || le.log
      );
    } else
      X[h] = A(
        le.level,
        N,
        le.log
      );
    if (G.hasOwnProperty("customLevels") === !0 && (T(this.levels, G.customLevels), X.levels = $(G.customLevels, X[v]), I(X)), typeof G.redact == "object" && G.redact !== null || Array.isArray(G.redact)) {
      X.redact = G.redact;
      const me = D(X.redact, k), We = { stringify: me[_] };
      X[R] = k, X[O] = me, X[E] = We;
    }
    typeof G.msgPrefix == "string" && (X[z] = (this[z] || "") + G.msgPrefix), X[i] = j(X, W);
    const pe = G.level || this.level;
    return X[n](pe), this.onChild(X), X;
  }
  function K() {
    const G = `{${this[i].substr(1)}}`, ee = JSON.parse(G);
    return delete ee.pid, delete ee.hostname, ee;
  }
  function V(W) {
    const G = j(this, W);
    this[i] = G, delete this[o];
  }
  function Z(W, G) {
    return Object.assign(G, W);
  }
  function Y(W, G, ee) {
    const le = this[d](), X = this[a], ce = this[b], Ee = this[m], pe = this[l] || Z;
    let me;
    const We = this[S].streamWrite;
    W == null ? me = {} : W instanceof Error ? (me = { [ce]: W }, G === void 0 && (G = W.message)) : (me = W, G === void 0 && W[Ee] === void 0 && W[ce] && (G = W[ce].message)), X && (me = pe(me, X(me, ee, this)));
    const we = this[c](me, G, ee, le), Et = this[p];
    Et[y] === !0 && (Et.lastLevel = ee, Et.lastObj = me, Et.lastMsg = G, Et.lastTime = le.slice(this[g]), Et.lastLogger = this), Et.write(We ? We(we) : we);
  }
  function J() {
  }
  function H(W) {
    if (W != null && typeof W != "function")
      throw Error("callback must be a function");
    const G = this[p];
    typeof G.flush == "function" ? G.flush(W || J) : W && W();
  }
  return jc;
}
var Ni = { exports: {} }, fh;
function Hw() {
  return fh || (fh = 1, function(e, t) {
    const { hasOwnProperty: r } = Object.prototype, n = m();
    n.configure = m, n.stringify = n, n.default = n, t.stringify = n, t.configure = m, e.exports = n;
    const s = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function i(v) {
      return v.length < 5e3 && !s.test(v) ? `"${v}"` : JSON.stringify(v);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    function o(v, y) {
      if (v.length > 200 || y)
        return v.sort(y);
<<<<<<< HEAD
      for (let E = 1; E < v.length; E++) {
        const R = v[E];
        let w = E;
        for (; w !== 0 && v[w - 1] > R; )
          v[w] = v[w - 1], w--;
        v[w] = R;
=======
      for (let _ = 1; _ < v.length; _++) {
        const R = v[_];
        let E = _;
        for (; E !== 0 && v[E - 1] > R; )
          v[E] = v[E - 1], E--;
        v[E] = R;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      return v;
    }
    const a = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function c(v) {
      return a.call(v) !== void 0 && v.length !== 0;
    }
<<<<<<< HEAD
    function u(v, y, E) {
      v.length < E && (E = v.length);
      const R = y === "," ? "" : " ";
      let w = `"0":${R}${v[0]}`;
      for (let C = 1; C < E; C++)
        w += `${y}"${C}":${R}${v[C]}`;
      return w;
=======
    function f(v, y, _) {
      v.length < _ && (_ = v.length);
      const R = y === "," ? "" : " ";
      let E = `"0":${R}${v[0]}`;
      for (let O = 1; O < _; O++)
        E += `${y}"${O}":${R}${v[O]}`;
      return E;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    function l(v) {
      if (r.call(v, "circularValue")) {
        const y = v.circularValue;
        if (typeof y == "string")
          return `"${y}"`;
        if (y == null)
          return y;
        if (y === Error || y === TypeError)
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
<<<<<<< HEAD
    function f(v) {
=======
    function d(v) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      let y;
      if (r.call(v, "deterministic") && (y = v.deterministic, typeof y != "boolean" && typeof y != "function"))
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      return y === void 0 ? !0 : y;
    }
<<<<<<< HEAD
    function m(v, y) {
      let E;
      if (r.call(v, y) && (E = v[y], typeof E != "boolean"))
        throw new TypeError(`The "${y}" argument must be of type boolean`);
      return E === void 0 ? !0 : E;
    }
    function p(v, y) {
      let E;
      if (r.call(v, y)) {
        if (E = v[y], typeof E != "number")
          throw new TypeError(`The "${y}" argument must be of type number`);
        if (!Number.isInteger(E))
          throw new TypeError(`The "${y}" argument must be an integer`);
        if (E < 1)
          throw new RangeError(`The "${y}" argument must be >= 1`);
      }
      return E === void 0 ? 1 / 0 : E;
    }
    function d(v) {
=======
    function g(v, y) {
      let _;
      if (r.call(v, y) && (_ = v[y], typeof _ != "boolean"))
        throw new TypeError(`The "${y}" argument must be of type boolean`);
      return _ === void 0 ? !0 : _;
    }
    function p(v, y) {
      let _;
      if (r.call(v, y)) {
        if (_ = v[y], typeof _ != "number")
          throw new TypeError(`The "${y}" argument must be of type number`);
        if (!Number.isInteger(_))
          throw new TypeError(`The "${y}" argument must be an integer`);
        if (_ < 1)
          throw new RangeError(`The "${y}" argument must be >= 1`);
      }
      return _ === void 0 ? 1 / 0 : _;
    }
    function u(v) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return v === 1 ? "1 item" : `${v} items`;
    }
    function h(v) {
      const y = /* @__PURE__ */ new Set();
<<<<<<< HEAD
      for (const E of v)
        (typeof E == "string" || typeof E == "number") && y.add(String(E));
      return y;
    }
    function _(v) {
=======
      for (const _ of v)
        (typeof _ == "string" || typeof _ == "number") && y.add(String(_));
      return y;
    }
    function b(v) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (r.call(v, "strict")) {
        const y = v.strict;
        if (typeof y != "boolean")
          throw new TypeError('The "strict" argument must be of type boolean');
        if (y)
<<<<<<< HEAD
          return (E) => {
            let R = `Object can not safely be stringified. Received type ${typeof E}`;
            throw typeof E != "function" && (R += ` (${E.toString()})`), new Error(R);
          };
      }
    }
    function g(v) {
      v = { ...v };
      const y = _(v);
      y && (v.bigint === void 0 && (v.bigint = !1), "circularValue" in v || (v.circularValue = Error));
      const E = l(v), R = m(v, "bigint"), w = f(v), C = typeof w == "function" ? w : void 0, V = p(v, "maximumDepth"), b = p(v, "maximumBreadth");
      function F(A, P, D, I, L, j) {
        let k = P[A];
        switch (typeof k == "object" && k !== null && typeof k.toJSON == "function" && (k = k.toJSON(A)), k = I.call(P, A, k), typeof k) {
          case "string":
            return s(k);
          case "object": {
            if (k === null)
              return "null";
            if (D.indexOf(k) !== -1)
              return E;
            let U = "", M = ",";
            const T = j;
            if (Array.isArray(k)) {
              if (k.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(k), L !== "" && (j += L, U += `
${j}`, M = `,
${j}`);
              const z = Math.min(k.length, b);
              let Q = 0;
              for (; Q < z - 1; Q++) {
                const X = F(String(Q), k, D, I, L, j);
                U += X !== void 0 ? X : "null", U += M;
              }
              const K = F(String(Q), k, D, I, L, j);
              if (U += K !== void 0 ? K : "null", k.length - 1 > b) {
                const X = k.length - b - 1;
                U += `${M}"... ${d(X)} not stringified"`;
              }
              return L !== "" && (U += `
${T}`), D.pop(), `[${U}]`;
            }
            let N = Object.keys(k);
            const G = N.length;
            if (G === 0)
              return "{}";
            if (V < D.length + 1)
              return '"[Object]"';
            let O = "", S = "";
            L !== "" && (j += L, M = `,
${j}`, O = " ");
            const W = Math.min(G, b);
            w && !c(k) && (N = o(N, C)), D.push(k);
            for (let z = 0; z < W; z++) {
              const Q = N[z], K = F(Q, k, D, I, L, j);
              K !== void 0 && (U += `${S}${s(Q)}:${O}${K}`, S = M);
            }
            if (G > b) {
              const z = G - b;
              U += `${S}"...":${O}"${d(z)} not stringified"`, S = M;
            }
            return L !== "" && S.length > 1 && (U = `
${j}${U}
${T}`), D.pop(), `{${U}}`;
          }
          case "number":
            return isFinite(k) ? String(k) : y ? y(k) : "null";
          case "boolean":
            return k === !0 ? "true" : "false";
=======
          return (_) => {
            let R = `Object can not safely be stringified. Received type ${typeof _}`;
            throw typeof _ != "function" && (R += ` (${_.toString()})`), new Error(R);
          };
      }
    }
    function m(v) {
      v = { ...v };
      const y = b(v);
      y && (v.bigint === void 0 && (v.bigint = !1), "circularValue" in v || (v.circularValue = Error));
      const _ = l(v), R = g(v, "bigint"), E = d(v), O = typeof E == "function" ? E : void 0, z = p(v, "maximumDepth"), S = p(v, "maximumBreadth");
      function L(I, T, j, C, A, k) {
        let P = T[I];
        switch (typeof P == "object" && P !== null && typeof P.toJSON == "function" && (P = P.toJSON(I)), P = C.call(T, I, P), typeof P) {
          case "string":
            return i(P);
          case "object": {
            if (P === null)
              return "null";
            if (j.indexOf(P) !== -1)
              return _;
            let D = "", F = ",";
            const w = k;
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(P), A !== "" && (k += A, D += `
${k}`, F = `,
${k}`);
              const Y = Math.min(P.length, S);
              let J = 0;
              for (; J < Y - 1; J++) {
                const W = L(String(J), P, j, C, A, k);
                D += W !== void 0 ? W : "null", D += F;
              }
              const H = L(String(J), P, j, C, A, k);
              if (D += H !== void 0 ? H : "null", P.length - 1 > S) {
                const W = P.length - S - 1;
                D += `${F}"... ${u(W)} not stringified"`;
              }
              return A !== "" && (D += `
${w}`), j.pop(), `[${D}]`;
            }
            let N = Object.keys(P);
            const q = N.length;
            if (q === 0)
              return "{}";
            if (z < j.length + 1)
              return '"[Object]"';
            let K = "", V = "";
            A !== "" && (k += A, F = `,
${k}`, K = " ");
            const Z = Math.min(q, S);
            E && !c(P) && (N = o(N, O)), j.push(P);
            for (let Y = 0; Y < Z; Y++) {
              const J = N[Y], H = L(J, P, j, C, A, k);
              H !== void 0 && (D += `${V}${i(J)}:${K}${H}`, V = F);
            }
            if (q > S) {
              const Y = q - S;
              D += `${V}"...":${K}"${u(Y)} not stringified"`, V = F;
            }
            return A !== "" && V.length > 1 && (D = `
${k}${D}
${w}`), j.pop(), `{${D}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "undefined":
            return;
          case "bigint":
            if (R)
<<<<<<< HEAD
              return String(k);
          default:
            return y ? y(k) : void 0;
        }
      }
      function H(A, P, D, I, L, j) {
        switch (typeof P == "object" && P !== null && typeof P.toJSON == "function" && (P = P.toJSON(A)), typeof P) {
          case "string":
            return s(P);
          case "object": {
            if (P === null)
              return "null";
            if (D.indexOf(P) !== -1)
              return E;
            const k = j;
            let U = "", M = ",";
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(P), L !== "" && (j += L, U += `
${j}`, M = `,
${j}`);
              const G = Math.min(P.length, b);
              let O = 0;
              for (; O < G - 1; O++) {
                const W = H(String(O), P[O], D, I, L, j);
                U += W !== void 0 ? W : "null", U += M;
              }
              const S = H(String(O), P[O], D, I, L, j);
              if (U += S !== void 0 ? S : "null", P.length - 1 > b) {
                const W = P.length - b - 1;
                U += `${M}"... ${d(W)} not stringified"`;
              }
              return L !== "" && (U += `
${k}`), D.pop(), `[${U}]`;
            }
            D.push(P);
            let T = "";
            L !== "" && (j += L, M = `,
${j}`, T = " ");
            let N = "";
            for (const G of I) {
              const O = H(G, P[G], D, I, L, j);
              O !== void 0 && (U += `${N}${s(G)}:${T}${O}`, N = M);
            }
            return L !== "" && N.length > 1 && (U = `
${j}${U}
${k}`), D.pop(), `{${U}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
=======
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function M(I, T, j, C, A, k) {
        switch (typeof T == "object" && T !== null && typeof T.toJSON == "function" && (T = T.toJSON(I)), typeof T) {
          case "string":
            return i(T);
          case "object": {
            if (T === null)
              return "null";
            if (j.indexOf(T) !== -1)
              return _;
            const P = k;
            let D = "", F = ",";
            if (Array.isArray(T)) {
              if (T.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(T), A !== "" && (k += A, D += `
${k}`, F = `,
${k}`);
              const q = Math.min(T.length, S);
              let K = 0;
              for (; K < q - 1; K++) {
                const Z = M(String(K), T[K], j, C, A, k);
                D += Z !== void 0 ? Z : "null", D += F;
              }
              const V = M(String(K), T[K], j, C, A, k);
              if (D += V !== void 0 ? V : "null", T.length - 1 > S) {
                const Z = T.length - S - 1;
                D += `${F}"... ${u(Z)} not stringified"`;
              }
              return A !== "" && (D += `
${P}`), j.pop(), `[${D}]`;
            }
            j.push(T);
            let w = "";
            A !== "" && (k += A, F = `,
${k}`, w = " ");
            let N = "";
            for (const q of C) {
              const K = M(q, T[q], j, C, A, k);
              K !== void 0 && (D += `${N}${i(q)}:${w}${K}`, N = F);
            }
            return A !== "" && N.length > 1 && (D = `
${k}${D}
${P}`), j.pop(), `{${D}}`;
          }
          case "number":
            return isFinite(T) ? String(T) : y ? y(T) : "null";
          case "boolean":
            return T === !0 ? "true" : "false";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "undefined":
            return;
          case "bigint":
            if (R)
<<<<<<< HEAD
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function q(A, P, D, I, L) {
        switch (typeof P) {
          case "string":
            return s(P);
          case "object": {
            if (P === null)
              return "null";
            if (typeof P.toJSON == "function") {
              if (P = P.toJSON(A), typeof P != "object")
                return q(A, P, D, I, L);
              if (P === null)
                return "null";
            }
            if (D.indexOf(P) !== -1)
              return E;
            const j = L;
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(P), L += I;
              let O = `
${L}`;
              const S = `,
${L}`, W = Math.min(P.length, b);
              let z = 0;
              for (; z < W - 1; z++) {
                const K = q(String(z), P[z], D, I, L);
                O += K !== void 0 ? K : "null", O += S;
              }
              const Q = q(String(z), P[z], D, I, L);
              if (O += Q !== void 0 ? Q : "null", P.length - 1 > b) {
                const K = P.length - b - 1;
                O += `${S}"... ${d(K)} not stringified"`;
              }
              return O += `
${j}`, D.pop(), `[${O}]`;
            }
            let k = Object.keys(P);
            const U = k.length;
            if (U === 0)
              return "{}";
            if (V < D.length + 1)
              return '"[Object]"';
            L += I;
            const M = `,
${L}`;
            let T = "", N = "", G = Math.min(U, b);
            c(P) && (T += u(P, M, b), k = k.slice(P.length), G -= P.length, N = M), w && (k = o(k, C)), D.push(P);
            for (let O = 0; O < G; O++) {
              const S = k[O], W = q(S, P[S], D, I, L);
              W !== void 0 && (T += `${N}${s(S)}: ${W}`, N = M);
            }
            if (U > b) {
              const O = U - b;
              T += `${N}"...": "${d(O)} not stringified"`, N = M;
            }
            return N !== "" && (T = `
${L}${T}
${j}`), D.pop(), `{${T}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
=======
              return String(T);
          default:
            return y ? y(T) : void 0;
        }
      }
      function U(I, T, j, C, A) {
        switch (typeof T) {
          case "string":
            return i(T);
          case "object": {
            if (T === null)
              return "null";
            if (typeof T.toJSON == "function") {
              if (T = T.toJSON(I), typeof T != "object")
                return U(I, T, j, C, A);
              if (T === null)
                return "null";
            }
            if (j.indexOf(T) !== -1)
              return _;
            const k = A;
            if (Array.isArray(T)) {
              if (T.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(T), A += C;
              let K = `
${A}`;
              const V = `,
${A}`, Z = Math.min(T.length, S);
              let Y = 0;
              for (; Y < Z - 1; Y++) {
                const H = U(String(Y), T[Y], j, C, A);
                K += H !== void 0 ? H : "null", K += V;
              }
              const J = U(String(Y), T[Y], j, C, A);
              if (K += J !== void 0 ? J : "null", T.length - 1 > S) {
                const H = T.length - S - 1;
                K += `${V}"... ${u(H)} not stringified"`;
              }
              return K += `
${k}`, j.pop(), `[${K}]`;
            }
            let P = Object.keys(T);
            const D = P.length;
            if (D === 0)
              return "{}";
            if (z < j.length + 1)
              return '"[Object]"';
            A += C;
            const F = `,
${A}`;
            let w = "", N = "", q = Math.min(D, S);
            c(T) && (w += f(T, F, S), P = P.slice(T.length), q -= T.length, N = F), E && (P = o(P, O)), j.push(T);
            for (let K = 0; K < q; K++) {
              const V = P[K], Z = U(V, T[V], j, C, A);
              Z !== void 0 && (w += `${N}${i(V)}: ${Z}`, N = F);
            }
            if (D > S) {
              const K = D - S;
              w += `${N}"...": "${u(K)} not stringified"`, N = F;
            }
            return N !== "" && (w = `
${A}${w}
${k}`), j.pop(), `{${w}}`;
          }
          case "number":
            return isFinite(T) ? String(T) : y ? y(T) : "null";
          case "boolean":
            return T === !0 ? "true" : "false";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "undefined":
            return;
          case "bigint":
            if (R)
<<<<<<< HEAD
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function $(A, P, D) {
        switch (typeof P) {
          case "string":
            return s(P);
          case "object": {
            if (P === null)
              return "null";
            if (typeof P.toJSON == "function") {
              if (P = P.toJSON(A), typeof P != "object")
                return $(A, P, D);
              if (P === null)
                return "null";
            }
            if (D.indexOf(P) !== -1)
              return E;
            let I = "";
            const L = P.length !== void 0;
            if (L && Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(P);
              const T = Math.min(P.length, b);
              let N = 0;
              for (; N < T - 1; N++) {
                const O = $(String(N), P[N], D);
                I += O !== void 0 ? O : "null", I += ",";
              }
              const G = $(String(N), P[N], D);
              if (I += G !== void 0 ? G : "null", P.length - 1 > b) {
                const O = P.length - b - 1;
                I += `,"... ${d(O)} not stringified"`;
              }
              return D.pop(), `[${I}]`;
            }
            let j = Object.keys(P);
            const k = j.length;
            if (k === 0)
              return "{}";
            if (V < D.length + 1)
              return '"[Object]"';
            let U = "", M = Math.min(k, b);
            L && c(P) && (I += u(P, ",", b), j = j.slice(P.length), M -= P.length, U = ","), w && (j = o(j, C)), D.push(P);
            for (let T = 0; T < M; T++) {
              const N = j[T], G = $(N, P[N], D);
              G !== void 0 && (I += `${U}${s(N)}:${G}`, U = ",");
            }
            if (k > b) {
              const T = k - b;
              I += `${U}"...":"${d(T)} not stringified"`;
            }
            return D.pop(), `{${I}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
=======
              return String(T);
          default:
            return y ? y(T) : void 0;
        }
      }
      function $(I, T, j) {
        switch (typeof T) {
          case "string":
            return i(T);
          case "object": {
            if (T === null)
              return "null";
            if (typeof T.toJSON == "function") {
              if (T = T.toJSON(I), typeof T != "object")
                return $(I, T, j);
              if (T === null)
                return "null";
            }
            if (j.indexOf(T) !== -1)
              return _;
            let C = "";
            const A = T.length !== void 0;
            if (A && Array.isArray(T)) {
              if (T.length === 0)
                return "[]";
              if (z < j.length + 1)
                return '"[Array]"';
              j.push(T);
              const w = Math.min(T.length, S);
              let N = 0;
              for (; N < w - 1; N++) {
                const K = $(String(N), T[N], j);
                C += K !== void 0 ? K : "null", C += ",";
              }
              const q = $(String(N), T[N], j);
              if (C += q !== void 0 ? q : "null", T.length - 1 > S) {
                const K = T.length - S - 1;
                C += `,"... ${u(K)} not stringified"`;
              }
              return j.pop(), `[${C}]`;
            }
            let k = Object.keys(T);
            const P = k.length;
            if (P === 0)
              return "{}";
            if (z < j.length + 1)
              return '"[Object]"';
            let D = "", F = Math.min(P, S);
            A && c(T) && (C += f(T, ",", S), k = k.slice(T.length), F -= T.length, D = ","), E && (k = o(k, O)), j.push(T);
            for (let w = 0; w < F; w++) {
              const N = k[w], q = $(N, T[N], j);
              q !== void 0 && (C += `${D}${i(N)}:${q}`, D = ",");
            }
            if (P > S) {
              const w = P - S;
              C += `${D}"...":"${u(w)} not stringified"`;
            }
            return j.pop(), `{${C}}`;
          }
          case "number":
            return isFinite(T) ? String(T) : y ? y(T) : "null";
          case "boolean":
            return T === !0 ? "true" : "false";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "undefined":
            return;
          case "bigint":
            if (R)
<<<<<<< HEAD
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function x(A, P, D) {
        if (arguments.length > 1) {
          let I = "";
          if (typeof D == "number" ? I = " ".repeat(Math.min(D, 10)) : typeof D == "string" && (I = D.slice(0, 10)), P != null) {
            if (typeof P == "function")
              return F("", { "": A }, [], P, I, "");
            if (Array.isArray(P))
              return H("", A, [], h(P), I, "");
          }
          if (I.length !== 0)
            return q("", A, [], I, "");
        }
        return $("", A, []);
      }
      return x;
    }
  }(Rc, Rc.exports)), Rc.exports;
}
var Ed, i0;
function BI() {
  if (i0) return Ed;
  i0 = 1;
  const e = Symbol.for("pino.metadata"), { DEFAULT_LEVELS: t } = ym(), r = t.info;
  function n(c, u) {
    let l = 0;
    c = c || [], u = u || { dedupe: !1 };
    const f = Object.create(t);
    f.silent = 1 / 0, u.levels && typeof u.levels == "object" && Object.keys(u.levels).forEach((y) => {
      f[y] = u.levels[y];
    });
    const m = {
      write: p,
      add: _,
      emit: d,
      flushSync: h,
      end: g,
=======
              return String(T);
          default:
            return y ? y(T) : void 0;
        }
      }
      function x(I, T, j) {
        if (arguments.length > 1) {
          let C = "";
          if (typeof j == "number" ? C = " ".repeat(Math.min(j, 10)) : typeof j == "string" && (C = j.slice(0, 10)), T != null) {
            if (typeof T == "function")
              return L("", { "": I }, [], T, C, "");
            if (Array.isArray(T))
              return M("", I, [], h(T), C, "");
          }
          if (C.length !== 0)
            return U("", I, [], C, "");
        }
        return $("", I, []);
      }
      return x;
    }
  }(Ni, Ni.exports)), Ni.exports;
}
var Dc, dh;
function Bw() {
  if (dh) return Dc;
  dh = 1;
  const e = Symbol.for("pino.metadata"), { DEFAULT_LEVELS: t } = Qu(), r = t.info;
  function n(c, f) {
    let l = 0;
    c = c || [], f = f || { dedupe: !1 };
    const d = Object.create(t);
    d.silent = 1 / 0, f.levels && typeof f.levels == "object" && Object.keys(f.levels).forEach((y) => {
      d[y] = f.levels[y];
    });
    const g = {
      write: p,
      add: b,
      emit: u,
      flushSync: h,
      end: m,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      minLevel: 0,
      streams: [],
      clone: v,
      [e]: !0,
<<<<<<< HEAD
      streamLevels: f
    };
    return Array.isArray(c) ? c.forEach(_, m) : _.call(m, c), c = null, m;
    function p(y) {
      let E;
      const R = this.lastLevel, { streams: w } = this;
      let C = 0, V;
      for (let b = s(w.length, u.dedupe); a(b, w.length, u.dedupe); b = o(b, u.dedupe))
        if (E = w[b], E.level <= R) {
          if (C !== 0 && C !== E.level)
            break;
          if (V = E.stream, V[e]) {
            const { lastTime: F, lastMsg: H, lastObj: q, lastLogger: $ } = this;
            V.lastLevel = R, V.lastTime = F, V.lastMsg = H, V.lastObj = q, V.lastLogger = $;
          }
          V.write(y), u.dedupe && (C = E.level);
        } else if (!u.dedupe)
          break;
    }
    function d(...y) {
      for (const { stream: E } of this.streams)
        typeof E.emit == "function" && E.emit(...y);
=======
      streamLevels: d
    };
    return Array.isArray(c) ? c.forEach(b, g) : b.call(g, c), c = null, g;
    function p(y) {
      let _;
      const R = this.lastLevel, { streams: E } = this;
      let O = 0, z;
      for (let S = i(E.length, f.dedupe); a(S, E.length, f.dedupe); S = o(S, f.dedupe))
        if (_ = E[S], _.level <= R) {
          if (O !== 0 && O !== _.level)
            break;
          if (z = _.stream, z[e]) {
            const { lastTime: L, lastMsg: M, lastObj: U, lastLogger: $ } = this;
            z.lastLevel = R, z.lastTime = L, z.lastMsg = M, z.lastObj = U, z.lastLogger = $;
          }
          z.write(y), f.dedupe && (O = _.level);
        } else if (!f.dedupe)
          break;
    }
    function u(...y) {
      for (const { stream: _ } of this.streams)
        typeof _.emit == "function" && _.emit(...y);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    function h() {
      for (const { stream: y } of this.streams)
        typeof y.flushSync == "function" && y.flushSync();
    }
<<<<<<< HEAD
    function _(y) {
      if (!y)
        return m;
      const E = typeof y.write == "function" || y.stream, R = y.write ? y : y.stream;
      if (!E)
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      const { streams: w, streamLevels: C } = this;
      let V;
      typeof y.levelVal == "number" ? V = y.levelVal : typeof y.level == "string" ? V = C[y.level] : typeof y.level == "number" ? V = y.level : V = r;
      const b = {
        stream: R,
        level: V,
        levelVal: void 0,
        id: l++
      };
      return w.unshift(b), w.sort(i), this.minLevel = w[0].level, m;
    }
    function g() {
=======
    function b(y) {
      if (!y)
        return g;
      const _ = typeof y.write == "function" || y.stream, R = y.write ? y : y.stream;
      if (!_)
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      const { streams: E, streamLevels: O } = this;
      let z;
      typeof y.levelVal == "number" ? z = y.levelVal : typeof y.level == "string" ? z = O[y.level] : typeof y.level == "number" ? z = y.level : z = r;
      const S = {
        stream: R,
        level: z,
        levelVal: void 0,
        id: l++
      };
      return E.unshift(S), E.sort(s), this.minLevel = E[0].level, g;
    }
    function m() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      for (const { stream: y } of this.streams)
        typeof y.flushSync == "function" && y.flushSync(), y.end();
    }
    function v(y) {
<<<<<<< HEAD
      const E = new Array(this.streams.length);
      for (let R = 0; R < E.length; R++)
        E[R] = {
=======
      const _ = new Array(this.streams.length);
      for (let R = 0; R < _.length; R++)
        _[R] = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          level: y,
          stream: this.streams[R].stream
        };
      return {
        write: p,
<<<<<<< HEAD
        add: _,
        minLevel: y,
        streams: E,
        clone: v,
        emit: d,
=======
        add: b,
        minLevel: y,
        streams: _,
        clone: v,
        emit: u,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        flushSync: h,
        [e]: !0
      };
    }
  }
<<<<<<< HEAD
  function i(c, u) {
    return c.level - u.level;
  }
  function s(c, u) {
    return u ? c - 1 : 0;
  }
  function o(c, u) {
    return u ? c - 1 : c + 1;
  }
  function a(c, u, l) {
    return l ? c >= 0 : c < u;
  }
  return Ed = n, Ed;
}
var s0;
function zI() {
  if (s0) return hr.exports;
  s0 = 1;
  const e = IS, t = fx(), r = dx(), n = hx(), i = NI(), s = HI(), o = Ha(), { configure: a } = qI(), { assertDefaultLevelFound: c, mappings: u, genLsCache: l, genLevelComparison: f, assertLevelComparison: m } = vx(), { DEFAULT_LEVELS: p, SORTING_ORDER: d } = ym(), {
    createArgsNormalizer: h,
    asChindings: _,
    buildSafeSonicBoom: g,
    buildFormatters: v,
    stringify: y,
    normalizeDestFileDescriptor: E,
    noop: R
  } = gm(), { version: w } = _x(), {
    chindingsSym: C,
    redactFmtSym: V,
    serializersSym: b,
    timeSym: F,
    timeSliceIndexSym: H,
    streamSym: q,
    stringifySym: $,
    stringifySafeSym: x,
    stringifiersSym: A,
    setLevelSym: P,
    endSym: D,
    formatOptsSym: I,
    messageKeySym: L,
    errorKeySym: j,
    nestedKeySym: k,
    mixinSym: U,
    levelCompSym: M,
    useOnlyCustomLevelsSym: T,
    formattersSym: N,
    hooksSym: G,
    nestedKeyStrSym: O,
    mixinMergeStrategySym: S,
    msgPrefixSym: W
  } = o, { epochTime: z, nullTime: Q } = i, { pid: K } = process, X = e.hostname(), J = t.err, re = {
    level: "info",
    levelComparison: d.ASC,
=======
  function s(c, f) {
    return c.level - f.level;
  }
  function i(c, f) {
    return f ? c - 1 : 0;
  }
  function o(c, f) {
    return f ? c - 1 : c + 1;
  }
  function a(c, f, l) {
    return l ? c >= 0 : c < f;
  }
  return Dc = n, Dc;
}
var ph;
function Vw() {
  if (ph) return It.exports;
  ph = 1;
  const e = yv, t = Xv(), r = Zv(), n = eb(), s = kw(), i = qw(), o = ui(), { configure: a } = Hw(), { assertDefaultLevelFound: c, mappings: f, genLsCache: l, genLevelComparison: d, assertLevelComparison: g } = sb(), { DEFAULT_LEVELS: p, SORTING_ORDER: u } = Qu(), {
    createArgsNormalizer: h,
    asChindings: b,
    buildSafeSonicBoom: m,
    buildFormatters: v,
    stringify: y,
    normalizeDestFileDescriptor: _,
    noop: R
  } = Zu(), { version: E } = ib(), {
    chindingsSym: O,
    redactFmtSym: z,
    serializersSym: S,
    timeSym: L,
    timeSliceIndexSym: M,
    streamSym: U,
    stringifySym: $,
    stringifySafeSym: x,
    stringifiersSym: I,
    setLevelSym: T,
    endSym: j,
    formatOptsSym: C,
    messageKeySym: A,
    errorKeySym: k,
    nestedKeySym: P,
    mixinSym: D,
    levelCompSym: F,
    useOnlyCustomLevelsSym: w,
    formattersSym: N,
    hooksSym: q,
    nestedKeyStrSym: K,
    mixinMergeStrategySym: V,
    msgPrefixSym: Z
  } = o, { epochTime: Y, nullTime: J } = s, { pid: H } = process, W = e.hostname(), G = t.err, ee = {
    level: "info",
    levelComparison: u.ASC,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    levels: p,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: !0,
<<<<<<< HEAD
    base: { pid: K, hostname: X },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: J
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(Se) {
        return Se;
      },
      level(Se, ye) {
        return { level: ye };
=======
    base: { pid: H, hostname: W },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: G
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(Ee) {
        return Ee;
      },
      level(Ee, pe) {
        return { level: pe };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
<<<<<<< HEAD
    timestamp: z,
=======
    timestamp: Y,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: !1,
    depthLimit: 5,
    edgeLimit: 100
<<<<<<< HEAD
  }, fe = h(re), ee = Object.assign(/* @__PURE__ */ Object.create(null), t);
  function le(...Se) {
    const ye = {}, { opts: ve, stream: qe } = fe(ye, r(), ...Se);
    ve.level && typeof ve.level == "string" && p[ve.level.toLowerCase()] !== void 0 && (ve.level = ve.level.toLowerCase());
    const {
      redact: Ae,
      crlf: $t,
      serializers: Rn,
      timestamp: Le,
      messageKey: Ut,
      errorKey: br,
      nestedKey: Ne,
      base: je,
      name: ho,
      level: Mt,
      customLevels: dr,
      levelComparison: mo,
      mixin: We,
      mixinMergeStrategy: Qi,
      useOnlyCustomLevels: si,
      formatters: _t,
      hooks: Er,
      depthLimit: dc,
      edgeLimit: $n,
      onChild: Yt,
      msgPrefix: Nr
    } = ve, Ht = a({
      maximumDepth: dc,
      maximumBreadth: $n
    }), wr = v(
      _t.level,
      _t.bindings,
      _t.log
    ), cn = y.bind({
      [x]: Ht
    }), sr = Ae ? n(Ae, cn) : {}, oi = Ae ? { stringify: sr[V] } : { stringify: cn }, kf = "}" + ($t ? `\r
` : `
`), pc = _.bind(null, {
      [C]: "",
      [b]: Rn,
      [A]: sr,
      [$]: y,
      [x]: Ht,
      [N]: wr
    });
    let go = "";
    je !== null && (ho === void 0 ? go = pc(je) : go = pc(Object.assign({}, je, { name: ho })));
    const hc = Le instanceof Function ? Le : Le ? z : Q, Df = hc().indexOf(":") + 1;
    if (si && !dr) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (We && typeof We != "function") throw Error(`Unknown mixin type "${typeof We}" - expected "function"`);
    if (Nr && typeof Nr != "string") throw Error(`Unknown msgPrefix type "${typeof Nr}" - expected "string"`);
    c(Mt, dr, si);
    const yo = u(dr, si);
    typeof qe.emit == "function" && qe.emit("message", { code: "PINO_CONFIG", config: { levels: yo, messageKey: Ut, errorKey: br } }), m(mo);
    const vo = f(mo);
    return Object.assign(ye, {
      levels: yo,
      [M]: vo,
      [T]: si,
      [q]: qe,
      [F]: hc,
      [H]: Df,
      [$]: y,
      [x]: Ht,
      [A]: sr,
      [D]: kf,
      [I]: oi,
      [L]: Ut,
      [j]: br,
      [k]: Ne,
      // protect against injection
      [O]: Ne ? `,${JSON.stringify(Ne)}:{` : "",
      [b]: Rn,
      [U]: We,
      [S]: Qi,
      [C]: go,
      [N]: wr,
      [G]: Er,
      silent: R,
      onChild: Yt,
      [W]: Nr
    }), Object.setPrototypeOf(ye, s()), l(ye), ye[P](Mt), ye;
  }
  return hr.exports = le, hr.exports.destination = (Se = process.stdout.fd) => typeof Se == "object" ? (Se.dest = E(Se.dest || process.stdout.fd), g(Se)) : g({ dest: E(Se), minLength: 0 }), hr.exports.transport = yx(), hr.exports.multistream = BI(), hr.exports.levels = u(), hr.exports.stdSerializers = ee, hr.exports.stdTimeFunctions = Object.assign({}, i), hr.exports.symbols = o, hr.exports.version = w, hr.exports.default = le, hr.exports.pino = le, hr.exports;
}
var wd, o0;
function VI() {
  if (o0) return wd;
  o0 = 1;
  const e = zI(), { serializersSym: t } = e.symbols, {
    FST_ERR_LOG_INVALID_DESTINATION: r
  } = Wt;
  function n(s) {
    if (s.stream && s.file)
      throw new r();
    s.file && (s.stream = e.destination(s.file), delete s.file);
    const o = s.logger, a = s.genReqId;
    let c = null;
    return o ? (s.logger = void 0, s.genReqId = void 0, o[t] && (s.serializers = Object.assign({}, s.serializers, o[t])), c = o.child({}, s), s.logger = o, s.genReqId = a) : c = e(s, s.stream), c;
  }
  return wd = {
=======
  }, le = h(ee), X = Object.assign(/* @__PURE__ */ Object.create(null), t);
  function ce(...Ee) {
    const pe = {}, { opts: me, stream: We } = le(pe, r(), ...Ee);
    me.level && typeof me.level == "string" && p[me.level.toLowerCase()] !== void 0 && (me.level = me.level.toLowerCase());
    const {
      redact: we,
      crlf: Et,
      serializers: Sn,
      timestamp: Ce,
      messageKey: Bt,
      errorKey: $r,
      nestedKey: Te,
      base: ot,
      name: pp,
      level: Ct,
      customLevels: Vt,
      levelComparison: hp,
      mixin: Qe,
      mixinMergeStrategy: Xa,
      useOnlyCustomLevels: $i,
      formatters: mt,
      hooks: Ti,
      depthLimit: iS,
      edgeLimit: xn,
      onChild: Pt,
      msgPrefix: Br
    } = me, tr = a({
      maximumDepth: iS,
      maximumBreadth: xn
    }), Tr = v(
      mt.level,
      mt.bindings,
      mt.log
    ), hs = y.bind({
      [x]: tr
    }), rr = we ? n(we, hs) : {}, oS = we ? { stringify: rr[z] } : { stringify: hs }, aS = "}" + (Et ? `\r
` : `
`), mp = b.bind(null, {
      [O]: "",
      [S]: Sn,
      [I]: rr,
      [$]: y,
      [x]: tr,
      [N]: Tr
    });
    let Za = "";
    ot !== null && (pp === void 0 ? Za = mp(ot) : Za = mp(Object.assign({}, ot, { name: pp })));
    const yp = Ce instanceof Function ? Ce : Ce ? Y : J, cS = yp().indexOf(":") + 1;
    if ($i && !Vt) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (Qe && typeof Qe != "function") throw Error(`Unknown mixin type "${typeof Qe}" - expected "function"`);
    if (Br && typeof Br != "string") throw Error(`Unknown msgPrefix type "${typeof Br}" - expected "string"`);
    c(Ct, Vt, $i);
    const gp = f(Vt, $i);
    typeof We.emit == "function" && We.emit("message", { code: "PINO_CONFIG", config: { levels: gp, messageKey: Bt, errorKey: $r } }), g(hp);
    const lS = d(hp);
    return Object.assign(pe, {
      levels: gp,
      [F]: lS,
      [w]: $i,
      [U]: We,
      [L]: yp,
      [M]: cS,
      [$]: y,
      [x]: tr,
      [I]: rr,
      [j]: aS,
      [C]: oS,
      [A]: Bt,
      [k]: $r,
      [P]: Te,
      // protect against injection
      [K]: Te ? `,${JSON.stringify(Te)}:{` : "",
      [S]: Sn,
      [D]: Qe,
      [V]: Xa,
      [O]: Za,
      [N]: Tr,
      [q]: Ti,
      silent: R,
      onChild: Pt,
      [Z]: Br
    }), Object.setPrototypeOf(pe, i()), l(pe), pe[T](Ct), pe;
  }
  return It.exports = ce, It.exports.destination = (Ee = process.stdout.fd) => typeof Ee == "object" ? (Ee.dest = _(Ee.dest || process.stdout.fd), m(Ee)) : m({ dest: _(Ee), minLength: 0 }), It.exports.transport = nb(), It.exports.multistream = Bw(), It.exports.levels = f(), It.exports.stdSerializers = X, It.exports.stdTimeFunctions = Object.assign({}, s), It.exports.symbols = o, It.exports.version = E, It.exports.default = ce, It.exports.pino = ce, It.exports;
}
var Fc, hh;
function Gw() {
  if (hh) return Fc;
  hh = 1;
  const e = Vw(), { serializersSym: t } = e.symbols, {
    FST_ERR_LOG_INVALID_DESTINATION: r
  } = _t;
  function n(i) {
    if (i.stream && i.file)
      throw new r();
    i.file && (i.stream = e.destination(i.file), delete i.file);
    const o = i.logger, a = i.genReqId;
    let c = null;
    return o ? (i.logger = void 0, i.genReqId = void 0, o[t] && (i.serializers = Object.assign({}, i.serializers, o[t])), c = o.child({}, i), i.logger = o, i.genReqId = a) : c = e(i, i.stream), c;
  }
  return Fc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    serializers: {
      req: function(o) {
        return {
          method: o.method,
          url: o.url,
          version: o.headers && o.headers["accept-version"],
          host: o.host,
          remoteAddress: o.ip,
          remotePort: o.socket ? o.socket.remotePort : void 0
        };
      },
      err: e.stdSerializers.err,
      res: function(o) {
        return {
          statusCode: o.statusCode
        };
      }
    },
    createPinoLogger: n
<<<<<<< HEAD
  }, wd;
}
const {
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: GI,
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: WI,
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: KI,
  FST_ERR_LOG_INVALID_LOGGER: YI
} = Wt;
function JI(e, t, r, n, i) {
  const s = {
    [e.requestIdLogLabel]: n
  }, o = e.childLoggerFactory.call(e.server, t, s, i || {}, r);
  return e.childLoggerFactory !== bx && ah(o, !0), o;
}
function bx(e, t, r) {
  return e.child(t, r);
}
function ah(e, t) {
  const r = ["info", "error", "debug", "fatal", "warn", "trace", "child"], n = e ? r.filter((i) => !e[i] || typeof e[i] != "function") : r;
  if (n.length) {
    if (n.length === r.length && !t)
      return !1;
    throw YI(n.join(","));
  } else return !0;
}
function XI(e) {
  if (e.logger && e.loggerInstance)
    throw new GI();
  if (!e.loggerInstance && !e.logger) {
    const o = wI();
    return o.child = () => o, { logger: o, hasLogger: !1 };
  }
  const { createPinoLogger: t, serializers: r } = VI();
  if (ah(e.loggerInstance))
=======
  }, Fc;
}
const {
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: Ww,
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: Kw,
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: Jw,
  FST_ERR_LOG_INVALID_LOGGER: Yw
} = _t;
function Xw(e, t, r, n, s) {
  const i = {
    [e.requestIdLogLabel]: n
  }, o = e.childLoggerFactory.call(e.server, t, i, s || {}, r);
  return e.childLoggerFactory !== ob && ru(o, !0), o;
}
function ob(e, t, r) {
  return e.child(t, r);
}
function ru(e, t) {
  const r = ["info", "error", "debug", "fatal", "warn", "trace", "child"], n = e ? r.filter((s) => !e[s] || typeof e[s] != "function") : r;
  if (n.length) {
    if (n.length === r.length && !t)
      return !1;
    throw Yw(n.join(","));
  } else return !0;
}
function Zw(e) {
  if (e.logger && e.loggerInstance)
    throw new Ww();
  if (!e.loggerInstance && !e.logger) {
    const o = xw();
    return o.child = () => o, { logger: o, hasLogger: !1 };
  }
  const { createPinoLogger: t, serializers: r } = Gw();
  if (ru(e.loggerInstance))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return { logger: t({
      logger: e.loggerInstance,
      serializers: Object.assign({}, r, e.loggerInstance.serializers)
    }), hasLogger: !0 };
<<<<<<< HEAD
  if (ah(e.logger))
    throw WI();
  if (e.loggerInstance)
    throw KI();
  const n = {};
  return Object.prototype.toString.call(e.logger) === "[object Object]" && Reflect.ownKeys(e.logger).forEach((s) => {
    Object.defineProperty(n, s, {
      value: e.logger[s],
=======
  if (ru(e.logger))
    throw Kw();
  if (e.loggerInstance)
    throw Jw();
  const n = {};
  return Object.prototype.toString.call(e.logger) === "[object Object]" && Reflect.ownKeys(e.logger).forEach((i) => {
    Object.defineProperty(n, i, {
      value: e.logger[i],
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }), n.level = n.level || "info", n.serializers = Object.assign({}, r, n.serializers), e.logger = n, { logger: t(e.logger), hasLogger: !0 };
}
<<<<<<< HEAD
function ZI() {
  const e = process.hrtime();
  return e[0] * 1e3 + e[1] / 1e6;
}
var Tu = {
  createChildLogger: JI,
  defaultChildLoggerFactory: bx,
  createLogger: XI,
  now: ZI
}, vm = QI;
function As(e) {
  return e instanceof Buffer ? Buffer.from(e) : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
}
function QI(e) {
  if (e = e || {}, e.circles) return eN(e);
=======
function Qw() {
  const e = process.hrtime();
  return e[0] * 1e3 + e[1] / 1e6;
}
var ca = {
  createChildLogger: Xw,
  defaultChildLoggerFactory: ob,
  createLogger: Zw,
  now: Qw
}, ef = eR;
function Un(e) {
  return e instanceof Buffer ? Buffer.from(e) : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
}
function eR(e) {
  if (e = e || {}, e.circles) return tR(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = /* @__PURE__ */ new Map();
  if (t.set(Date, (o) => new Date(o)), t.set(Map, (o, a) => new Map(n(Array.from(o), a))), t.set(Set, (o, a) => new Set(n(Array.from(o), a))), e.constructorHandlers)
    for (const o of e.constructorHandlers)
      t.set(o[0], o[1]);
  let r = null;
<<<<<<< HEAD
  return e.proto ? s : i;
  function n(o, a) {
    const c = Object.keys(o), u = new Array(c.length);
    for (let l = 0; l < c.length; l++) {
      const f = c[l], m = o[f];
      typeof m != "object" || m === null ? u[f] = m : m.constructor !== Object && (r = t.get(m.constructor)) ? u[f] = r(m, a) : ArrayBuffer.isView(m) ? u[f] = As(m) : u[f] = a(m);
    }
    return u;
  }
  function i(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, i);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, i);
    const a = {};
    for (const c in o) {
      if (Object.hasOwnProperty.call(o, c) === !1) continue;
      const u = o[c];
      typeof u != "object" || u === null ? a[c] = u : u.constructor !== Object && (r = t.get(u.constructor)) ? a[c] = r(u, i) : ArrayBuffer.isView(u) ? a[c] = As(u) : a[c] = i(u);
    }
    return a;
=======
  return e.proto ? i : s;
  function n(o, a) {
    const c = Object.keys(o), f = new Array(c.length);
    for (let l = 0; l < c.length; l++) {
      const d = c[l], g = o[d];
      typeof g != "object" || g === null ? f[d] = g : g.constructor !== Object && (r = t.get(g.constructor)) ? f[d] = r(g, a) : ArrayBuffer.isView(g) ? f[d] = Un(g) : f[d] = a(g);
    }
    return f;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function s(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, s);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, s);
    const a = {};
    for (const c in o) {
<<<<<<< HEAD
      const u = o[c];
      typeof u != "object" || u === null ? a[c] = u : u.constructor !== Object && (r = t.get(u.constructor)) ? a[c] = r(u, s) : ArrayBuffer.isView(u) ? a[c] = As(u) : a[c] = s(u);
=======
      if (Object.hasOwnProperty.call(o, c) === !1) continue;
      const f = o[c];
      typeof f != "object" || f === null ? a[c] = f : f.constructor !== Object && (r = t.get(f.constructor)) ? a[c] = r(f, s) : ArrayBuffer.isView(f) ? a[c] = Un(f) : a[c] = s(f);
    }
    return a;
  }
  function i(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, i);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, i);
    const a = {};
    for (const c in o) {
      const f = o[c];
      typeof f != "object" || f === null ? a[c] = f : f.constructor !== Object && (r = t.get(f.constructor)) ? a[c] = r(f, i) : ArrayBuffer.isView(f) ? a[c] = Un(f) : a[c] = i(f);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return a;
  }
}
<<<<<<< HEAD
function eN(e) {
  const t = [], r = [], n = /* @__PURE__ */ new Map();
  if (n.set(Date, (c) => new Date(c)), n.set(Map, (c, u) => new Map(s(Array.from(c), u))), n.set(Set, (c, u) => new Set(s(Array.from(c), u))), e.constructorHandlers)
    for (const c of e.constructorHandlers)
      n.set(c[0], c[1]);
  let i = null;
  return e.proto ? a : o;
  function s(c, u) {
    const l = Object.keys(c), f = new Array(l.length);
    for (let m = 0; m < l.length; m++) {
      const p = l[m], d = c[p];
      if (typeof d != "object" || d === null)
        f[p] = d;
      else if (d.constructor !== Object && (i = n.get(d.constructor)))
        f[p] = i(d, u);
      else if (ArrayBuffer.isView(d))
        f[p] = As(d);
      else {
        const h = t.indexOf(d);
        h !== -1 ? f[p] = r[h] : f[p] = u(d);
      }
    }
    return f;
  }
  function o(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return s(c, o);
    if (c.constructor !== Object && (i = n.get(c.constructor)))
      return i(c, o);
    const u = {};
    t.push(c), r.push(u);
    for (const l in c) {
      if (Object.hasOwnProperty.call(c, l) === !1) continue;
      const f = c[l];
      if (typeof f != "object" || f === null)
        u[l] = f;
      else if (f.constructor !== Object && (i = n.get(f.constructor)))
        u[l] = i(f, o);
      else if (ArrayBuffer.isView(f))
        u[l] = As(f);
      else {
        const m = t.indexOf(f);
        m !== -1 ? u[l] = r[m] : u[l] = o(f);
      }
    }
    return t.pop(), r.pop(), u;
  }
  function a(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return s(c, a);
    if (c.constructor !== Object && (i = n.get(c.constructor)))
      return i(c, a);
    const u = {};
    t.push(c), r.push(u);
    for (const l in c) {
      const f = c[l];
      if (typeof f != "object" || f === null)
        u[l] = f;
      else if (f.constructor !== Object && (i = n.get(f.constructor)))
        u[l] = i(f, a);
      else if (ArrayBuffer.isView(f))
        u[l] = As(f);
      else {
        const m = t.indexOf(f);
        m !== -1 ? u[l] = r[m] : u[l] = a(f);
      }
    }
    return t.pop(), r.pop(), u;
  }
}
const tN = vm({ circles: !1, proto: !0 }), { kSchemaVisited: a0, kSchemaResponse: rN } = Ft, ch = Symbol.for("fluent-schema-object"), {
  FST_ERR_SCH_MISSING_ID: nN,
  FST_ERR_SCH_ALREADY_PRESENT: iN,
  FST_ERR_SCH_DUPLICATE: sN,
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: c0
} = Wt, Ex = ["params", "body", "querystring", "query", "headers"];
function Ou(e) {
  this.store = e || {};
}
Ou.prototype.add = function(e) {
  const t = tN(
    e.isFluentSchema || e.isFluentJSONSchema || e[ch] ? e.valueOf() : e
  ), r = t.$id;
  if (!r)
    throw new nN();
  if (this.store[r])
    throw new iN(r);
  this.store[r] = t;
};
Ou.prototype.getSchemas = function() {
  return Object.assign({}, this.store);
};
Ou.prototype.getSchema = function(e) {
  return this.store[e];
};
function l0(e) {
  return typeof e == "object" && Object.getPrototypeOf(e) !== Object.prototype;
}
function oN(e, t) {
  if (e[a0])
    return e;
  if (e.query) {
    if (e.querystring)
      throw new sN("querystring");
    e.querystring = e.query;
  }
  aN(e);
  for (const r of Ex) {
    const n = e[r];
    if (n && !l0(n) && r === "body" && n.content) {
      const i = n.content, s = Object.keys(i);
      for (let o = 0; o < s.length; o++) {
        const a = s[o];
        if (!i[a].schema)
          throw new c0(a);
=======
function tR(e) {
  const t = [], r = [], n = /* @__PURE__ */ new Map();
  if (n.set(Date, (c) => new Date(c)), n.set(Map, (c, f) => new Map(i(Array.from(c), f))), n.set(Set, (c, f) => new Set(i(Array.from(c), f))), e.constructorHandlers)
    for (const c of e.constructorHandlers)
      n.set(c[0], c[1]);
  let s = null;
  return e.proto ? a : o;
  function i(c, f) {
    const l = Object.keys(c), d = new Array(l.length);
    for (let g = 0; g < l.length; g++) {
      const p = l[g], u = c[p];
      if (typeof u != "object" || u === null)
        d[p] = u;
      else if (u.constructor !== Object && (s = n.get(u.constructor)))
        d[p] = s(u, f);
      else if (ArrayBuffer.isView(u))
        d[p] = Un(u);
      else {
        const h = t.indexOf(u);
        h !== -1 ? d[p] = r[h] : d[p] = f(u);
      }
    }
    return d;
  }
  function o(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return i(c, o);
    if (c.constructor !== Object && (s = n.get(c.constructor)))
      return s(c, o);
    const f = {};
    t.push(c), r.push(f);
    for (const l in c) {
      if (Object.hasOwnProperty.call(c, l) === !1) continue;
      const d = c[l];
      if (typeof d != "object" || d === null)
        f[l] = d;
      else if (d.constructor !== Object && (s = n.get(d.constructor)))
        f[l] = s(d, o);
      else if (ArrayBuffer.isView(d))
        f[l] = Un(d);
      else {
        const g = t.indexOf(d);
        g !== -1 ? f[l] = r[g] : f[l] = o(d);
      }
    }
    return t.pop(), r.pop(), f;
  }
  function a(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return i(c, a);
    if (c.constructor !== Object && (s = n.get(c.constructor)))
      return s(c, a);
    const f = {};
    t.push(c), r.push(f);
    for (const l in c) {
      const d = c[l];
      if (typeof d != "object" || d === null)
        f[l] = d;
      else if (d.constructor !== Object && (s = n.get(d.constructor)))
        f[l] = s(d, a);
      else if (ArrayBuffer.isView(d))
        f[l] = Un(d);
      else {
        const g = t.indexOf(d);
        g !== -1 ? f[l] = r[g] : f[l] = a(d);
      }
    }
    return t.pop(), r.pop(), f;
  }
}
const rR = ef({ circles: !1, proto: !0 }), { kSchemaVisited: mh, kSchemaResponse: nR } = ht, nu = Symbol.for("fluent-schema-object"), {
  FST_ERR_SCH_MISSING_ID: sR,
  FST_ERR_SCH_ALREADY_PRESENT: iR,
  FST_ERR_SCH_DUPLICATE: oR,
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: yh
} = _t, ab = ["params", "body", "querystring", "query", "headers"];
function la(e) {
  this.store = e || {};
}
la.prototype.add = function(e) {
  const t = rR(
    e.isFluentSchema || e.isFluentJSONSchema || e[nu] ? e.valueOf() : e
  ), r = t.$id;
  if (!r)
    throw new sR();
  if (this.store[r])
    throw new iR(r);
  this.store[r] = t;
};
la.prototype.getSchemas = function() {
  return Object.assign({}, this.store);
};
la.prototype.getSchema = function(e) {
  return this.store[e];
};
function gh(e) {
  return typeof e == "object" && Object.getPrototypeOf(e) !== Object.prototype;
}
function aR(e, t) {
  if (e[mh])
    return e;
  if (e.query) {
    if (e.querystring)
      throw new oR("querystring");
    e.querystring = e.query;
  }
  cR(e);
  for (const r of ab) {
    const n = e[r];
    if (n && !gh(n) && r === "body" && n.content) {
      const s = n.content, i = Object.keys(s);
      for (let o = 0; o < i.length; o++) {
        const a = i[o];
        if (!s[a].schema)
          throw new yh(a);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      continue;
    }
  }
  if (e.response) {
    const r = Object.keys(e.response);
    for (const n of r) {
<<<<<<< HEAD
      if (l0(e.response[n]))
        continue;
      const i = e.response[n].content;
      if (i) {
        const s = Object.keys(i);
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (!i[a].schema)
            throw new c0(a);
=======
      if (gh(e.response[n]))
        continue;
      const s = e.response[n].content;
      if (s) {
        const i = Object.keys(s);
        for (let o = 0; o < i.length; o++) {
          const a = i[o];
          if (!s[a].schema)
            throw new yh(a);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
    }
  }
<<<<<<< HEAD
  return e[a0] = !0, e;
}
function aN(e) {
  for (const t of Ex)
    e[t] && (e[t].isFluentSchema || e[t][ch]) && (e[t] = e[t].valueOf());
  if (e.response) {
    const t = Object.keys(e.response);
    for (const r of t)
      (e.response[r].isFluentSchema || e.response[r][ch]) && (e.response[r] = e.response[r].valueOf());
  }
}
function cN(e, t, r) {
  const n = e[rN];
=======
  return e[mh] = !0, e;
}
function cR(e) {
  for (const t of ab)
    e[t] && (e[t].isFluentSchema || e[t][nu]) && (e[t] = e[t].valueOf());
  if (e.response) {
    const t = Object.keys(e.response);
    for (const r of t)
      (e.response[r].isFluentSchema || e.response[r][nu]) && (e.response[r] = e.response[r].valueOf());
  }
}
function lR(e, t, r) {
  const n = e[nR];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!n)
    return !1;
  if (n[t]) {
    if (n[t].constructor === Object && r) {
<<<<<<< HEAD
      const s = r.split(";", 1)[0];
      return n[t][s] ? n[t][s] : n[t]["*/*"] ? n[t]["*/*"] : !1;
    }
    return n[t];
  }
  const i = (t + "")[0] + "xx";
  if (n[i]) {
    if (n[i].constructor === Object && r) {
      const s = r.split(";", 1)[0];
      return n[i][s] ? n[i][s] : n[i]["*/*"] ? n[i]["*/*"] : !1;
    }
    return n[i];
  }
  if (n.default) {
    if (n.default.constructor === Object && r) {
      const s = r.split(";", 1)[0];
      return n.default[s] ? n.default[s] : n.default["*/*"] ? n.default["*/*"] : !1;
=======
      const i = r.split(";", 1)[0];
      return n[t][i] ? n[t][i] : n[t]["*/*"] ? n[t]["*/*"] : !1;
    }
    return n[t];
  }
  const s = (t + "")[0] + "xx";
  if (n[s]) {
    if (n[s].constructor === Object && r) {
      const i = r.split(";", 1)[0];
      return n[s][i] ? n[s][i] : n[s]["*/*"] ? n[s]["*/*"] : !1;
    }
    return n[s];
  }
  if (n.default) {
    if (n.default.constructor === Object && r) {
      const i = r.split(";", 1)[0];
      return n.default[i] ? n.default[i] : n.default["*/*"] ? n.default["*/*"] : !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return n.default;
  }
  return !1;
}
<<<<<<< HEAD
var Pu = {
  buildSchemas(e) {
    return new Ou(e);
  },
  getSchemaSerializer: cN,
  normalizeSchema: oN
};
const lN = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
var _m = class wx {
=======
var ua = {
  buildSchemas(e) {
    return new la(e);
  },
  getSchemaSerializer: lR,
  normalizeSchema: aR
};
const uR = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
var tf = class cb {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t) {
    switch (t && t.rounding) {
      case "floor":
        this.parseInteger = Math.floor;
        break;
      case "ceil":
        this.parseInteger = Math.ceil;
        break;
      case "round":
        this.parseInteger = Math.round;
        break;
      case "trunc":
      default:
        this.parseInteger = Math.trunc;
        break;
    }
    this._options = t;
  }
  asInteger(t) {
    if (Number.isInteger(t))
      return "" + t;
    if (typeof t == "bigint")
      return t.toString();
    const r = this.parseInteger(t);
    if (r === 1 / 0 || r === -1 / 0 || r !== r)
      throw new Error(`The value "${t}" cannot be converted to an integer.`);
    return "" + r;
  }
  asNumber(t) {
    const r = Number(t);
    if (r !== r)
      throw new Error(`The value "${t}" cannot be converted to a number.`);
    return r === 1 / 0 || r === -1 / 0 ? "null" : "" + r;
  }
  asBoolean(t) {
    return t && "true" || "false";
  }
  asDateTime(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + t.toISOString() + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date-time.`);
  }
  asDate(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date.`);
  }
  asTime(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a time.`);
  }
  asString(t) {
    const r = t.length;
    if (r < 42) {
<<<<<<< HEAD
      let n = "", i = -1, s = 255;
      for (let o = 0; o < r; o++)
        if (s = t.charCodeAt(o), s === 34 || // '"'
        s === 92)
          i === -1 && (i = 0), n += t.slice(i, o) + "\\", i = o;
        else if (s < 32 || s >= 55296 && s <= 57343)
          return JSON.stringify(t);
      return i === -1 && '"' + t + '"' || '"' + n + t.slice(i) + '"';
    } else return r < 5e3 && lN.test(t) === !1 ? '"' + t + '"' : JSON.stringify(t);
=======
      let n = "", s = -1, i = 255;
      for (let o = 0; o < r; o++)
        if (i = t.charCodeAt(o), i === 34 || // '"'
        i === 92)
          s === -1 && (s = 0), n += t.slice(s, o) + "\\", s = o;
        else if (i < 32 || i >= 55296 && i <= 57343)
          return JSON.stringify(t);
      return s === -1 && '"' + t + '"' || '"' + n + t.slice(s) + '"';
    } else return r < 5e3 && uR.test(t) === !1 ? '"' + t + '"' : JSON.stringify(t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  asUnsafeString(t) {
    return '"' + t + '"';
  }
  getState() {
    return this._options;
  }
  static restoreFromState(t) {
<<<<<<< HEAD
    return new wx(t);
  }
};
const uN = _m, fN = { mode: "standalone" }, dN = uN.restoreFromState(fN), pN = null;
var hN = function(t, r) {
  const n = "{", i = "}", s = ",", o = '"', a = n + i, c = o + o;
  function u(f) {
    const m = f && typeof f.toJSON == "function" ? f.toJSON() : f;
    if (m === null) return a;
    let p, d = n, h = !1;
    return p = m.statusCode, p !== void 0 && (!h && (h = !0) || (d += s), d += '"statusCode":', d += r.asNumber(p)), p = m.code, p !== void 0 && (!h && (h = !0) || (d += s), d += '"code":', typeof p != "string" ? p === null ? d += c : p instanceof Date ? d += o + p.toISOString() + o : p instanceof RegExp ? d += r.asString(p.source) : d += r.asString(p.toString()) : d += r.asString(p)), p = m.error, p !== void 0 && (!h && (h = !0) || (d += s), d += '"error":', typeof p != "string" ? p === null ? d += c : p instanceof Date ? d += o + p.toISOString() + o : p instanceof RegExp ? d += r.asString(p.source) : d += r.asString(p.toString()) : d += r.asString(p)), p = m.message, p !== void 0 && (!h && (h = !0) || (d += s), d += '"message":', typeof p != "string" ? p === null ? d += c : p instanceof Date ? d += o + p.toISOString() + o : p instanceof RegExp ? d += r.asString(p.source) : d += r.asString(p.toString()) : d += r.asString(p)), d + i;
  }
  return u;
}(pN, dN);
const u0 = mu.STATUS_CODES, mN = ax, {
  kReplyHeaders: Pi,
  kReplyNextErrorHandler: $c,
  kReplyIsRunningOnErrorHook: gN,
  kReplyHasStatusCode: yN,
  kRouteContext: Sx,
  kDisableRequestLogging: Nl
} = Ft, {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: vN,
  FST_ERR_FAILED_ERROR_SERIALIZATION: _N
} = Wt, { getSchemaSerializer: bN } = Pu, Sd = hN, EN = {
  func: SN,
=======
    return new cb(t);
  }
};
const fR = tf, dR = { mode: "standalone" }, pR = fR.restoreFromState(dR), hR = null;
var mR = function(t, r) {
  const n = "{", s = "}", i = ",", o = '"', a = n + s, c = o + o;
  function f(d) {
    const g = d && typeof d.toJSON == "function" ? d.toJSON() : d;
    if (g === null) return a;
    let p, u = n, h = !1;
    return p = g.statusCode, p !== void 0 && (!h && (h = !0) || (u += i), u += '"statusCode":', u += r.asNumber(p)), p = g.code, p !== void 0 && (!h && (h = !0) || (u += i), u += '"code":', typeof p != "string" ? p === null ? u += c : p instanceof Date ? u += o + p.toISOString() + o : p instanceof RegExp ? u += r.asString(p.source) : u += r.asString(p.toString()) : u += r.asString(p)), p = g.error, p !== void 0 && (!h && (h = !0) || (u += i), u += '"error":', typeof p != "string" ? p === null ? u += c : p instanceof Date ? u += o + p.toISOString() + o : p instanceof RegExp ? u += r.asString(p.source) : u += r.asString(p.toString()) : u += r.asString(p)), p = g.message, p !== void 0 && (!h && (h = !0) || (u += i), u += '"message":', typeof p != "string" ? p === null ? u += c : p instanceof Date ? u += o + p.toISOString() + o : p instanceof RegExp ? u += r.asString(p.source) : u += r.asString(p.toString()) : u += r.asString(p)), u + s;
  }
  return f;
}(hR, pR);
const vh = ea.STATUS_CODES, yR = Wv, {
  kReplyHeaders: on,
  kReplyNextErrorHandler: Ai,
  kReplyIsRunningOnErrorHook: gR,
  kReplyHasStatusCode: vR,
  kRouteContext: lb,
  kDisableRequestLogging: Po
} = ht, {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: bR,
  FST_ERR_FAILED_ERROR_SERIALIZATION: _R
} = _t, { getSchemaSerializer: ER } = ua, Mc = mR, SR = {
  func: wR,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  toJSON() {
    return this.func.name.toString() + "()";
  }
};
<<<<<<< HEAD
function wN(e, t, r) {
  e[gN] = !1;
  const n = e[Sx];
  if (e[$c] === !1) {
    f0(t, e, function(o, a) {
      try {
        o.raw.writeHead(o.raw.statusCode, o[Pi]);
      } catch (c) {
        o.log[Nl] || o.log.warn(
=======
function xR(e, t, r) {
  e[gR] = !1;
  const n = e[lb];
  if (e[Ai] === !1) {
    bh(t, e, function(o, a) {
      try {
        o.raw.writeHead(o.raw.statusCode, o[on]);
      } catch (c) {
        o.log[Po] || o.log.warn(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          { req: o.request, res: o, err: c },
          c && c.message
        ), o.raw.writeHead(o.raw.statusCode);
      }
      o.raw.end(a);
    });
    return;
  }
<<<<<<< HEAD
  const i = e[$c] || n.errorHandler;
  e[$c] = Object.getPrototypeOf(i), delete e[Pi]["content-type"], delete e[Pi]["content-length"];
  const s = i.func;
  if (!s) {
    e[$c] = !1, f0(t, e, r);
    return;
  }
  try {
    const o = s(t, e.request, e);
    o !== void 0 && (o !== null && typeof o.then == "function" ? mN(o, e) : e.send(o));
=======
  const s = e[Ai] || n.errorHandler;
  e[Ai] = Object.getPrototypeOf(s), delete e[on]["content-type"], delete e[on]["content-length"];
  const i = s.func;
  if (!i) {
    e[Ai] = !1, bh(t, e, r);
    return;
  }
  try {
    const o = i(t, e.request, e);
    o !== void 0 && (o !== null && typeof o.then == "function" ? yR(o, e) : e.send(o));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch (o) {
    e.send(o);
  }
}
<<<<<<< HEAD
function SN(e, t, r) {
  if (RN(e, r), !r[yN] || r.statusCode === 200) {
    const n = e.statusCode || e.status;
    r.code(n >= 400 ? n : 500);
  }
  r.statusCode < 500 ? r.log[Nl] || r.log.info(
    { res: r, err: e },
    e && e.message
  ) : r.log[Nl] || r.log.error(
=======
function wR(e, t, r) {
  if ($R(e, r), !r[vR] || r.statusCode === 200) {
    const n = e.statusCode || e.status;
    r.code(n >= 400 ? n : 500);
  }
  r.statusCode < 500 ? r.log[Po] || r.log.info(
    { res: r, err: e },
    e && e.message
  ) : r.log[Po] || r.log.error(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    { req: t, res: r, err: e },
    e && e.message
  ), r.send(e);
}
<<<<<<< HEAD
function f0(e, t, r) {
  const n = t.raw, i = t.statusCode;
  t[Pi]["content-type"] = t[Pi]["content-type"] ?? "application/json; charset=utf-8";
  let s;
  try {
    const o = bN(t[Sx], i, t[Pi]["content-type"]);
    o === !1 ? s = Sd({
      error: u0[i + ""],
      code: e.code,
      message: e.message,
      statusCode: i
    }) : s = o(Object.create(e, {
      error: { value: u0[i + ""] },
      message: { value: e.message },
      statusCode: { value: i }
    }));
  } catch (o) {
    t.log[Nl] || t.log.error({ err: o, statusCode: n.statusCode }, "The serializer for the given status code failed"), t.code(500), s = Sd(new _N(o.message, e.message));
  }
  typeof s != "string" && !Buffer.isBuffer(s) && (s = Sd(new vN(typeof s))), t[Pi]["content-length"] = "" + Buffer.byteLength(s), r(t, s);
}
function xN(e = EN, t) {
=======
function bh(e, t, r) {
  const n = t.raw, s = t.statusCode;
  t[on]["content-type"] = t[on]["content-type"] ?? "application/json; charset=utf-8";
  let i;
  try {
    const o = ER(t[lb], s, t[on]["content-type"]);
    o === !1 ? i = Mc({
      error: vh[s + ""],
      code: e.code,
      message: e.message,
      statusCode: s
    }) : i = o(Object.create(e, {
      error: { value: vh[s + ""] },
      message: { value: e.message },
      statusCode: { value: s }
    }));
  } catch (o) {
    t.log[Po] || t.log.error({ err: o, statusCode: n.statusCode }, "The serializer for the given status code failed"), t.code(500), i = Mc(new _R(o.message, e.message));
  }
  typeof i != "string" && !Buffer.isBuffer(i) && (i = Mc(new bR(typeof i))), t[on]["content-length"] = "" + Buffer.byteLength(i), r(t, i);
}
function RR(e = SR, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!t)
    return e;
  const r = Object.create(e);
  return r.func = t, r;
}
<<<<<<< HEAD
function RN(e, t) {
=======
function $R(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = t.raw;
  let n = r.statusCode;
  n = n >= 400 ? n : 500, e != null && (e.headers !== void 0 && t.headers(e.headers), e.status >= 400 ? n = e.status : e.statusCode >= 400 && (n = e.statusCode)), r.statusCode = n;
}
<<<<<<< HEAD
var Cu = {
  buildErrorHandler: xN,
  handleError: wN
};
const lh = Na.finished, $N = Na.Readable, {
  kFourOhFourContext: d0,
  kReplyErrorHandlerCalled: xx,
  kReplyHijacked: bm,
  kReplyStartTime: na,
  kReplyEndTime: Em,
  kReplySerializer: vn,
  kReplySerializerDefault: kl,
  kReplyIsError: Dl,
  kReplyHeaders: Be,
  kReplyTrailers: St,
  kReplyHasStatusCode: wm,
  kReplyIsRunningOnErrorHook: Sm,
  kReplyNextErrorHandler: TN,
  kDisableRequestLogging: Rx,
  kSchemaResponse: Ll,
  kReplyCacheSerializeFns: Un,
  kSchemaController: xd,
  kOptions: ON,
  kRouteContext: $e
} = Ft, {
  onSendHookRunner: $x,
  onResponseHookRunner: PN,
  preHandlerHookRunner: CN,
  preSerializationHookRunner: AN
} = Wi, p0 = cx[Symbol.for("internals")], IN = Tu, uh = IN.now, { handleError: h0 } = Cu, { getSchemaSerializer: NN } = Pu, Rd = {
=======
var fa = {
  buildErrorHandler: RR,
  handleError: xR
};
const su = ri.finished, TR = ri.Readable, {
  kFourOhFourContext: _h,
  kReplyErrorHandlerCalled: ub,
  kReplyHijacked: rf,
  kReplyStartTime: Us,
  kReplyEndTime: nf,
  kReplySerializer: Sr,
  kReplySerializerDefault: Io,
  kReplyIsError: No,
  kReplyHeaders: Ne,
  kReplyTrailers: it,
  kReplyHasStatusCode: sf,
  kReplyIsRunningOnErrorHook: of,
  kReplyNextErrorHandler: OR,
  kDisableRequestLogging: fb,
  kSchemaResponse: Ao,
  kReplyCacheSerializeFns: Lr,
  kSchemaController: zc,
  kOptions: CR,
  kRouteContext: ge
} = ht, {
  onSendHookRunner: db,
  onResponseHookRunner: PR,
  preHandlerHookRunner: IR,
  preSerializationHookRunner: NR
} = bn, Eh = Kv[Symbol.for("internals")], AR = ca, iu = AR.now, { handleError: Sh } = fa, { getSchemaSerializer: kR } = ua, Uc = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  JSON: "application/json; charset=utf-8",
  PLAIN: "text/plain; charset=utf-8",
  OCTET: "application/octet-stream"
}, {
<<<<<<< HEAD
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: kN,
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: DN,
  FST_ERR_REP_READABLE_STREAM_LOCKED: LN,
  FST_ERR_REP_ALREADY_SENT: FN,
  FST_ERR_SEND_INSIDE_ONERR: jN,
  FST_ERR_BAD_STATUS_CODE: UN,
  FST_ERR_BAD_TRAILER_NAME: MN,
  FST_ERR_BAD_TRAILER_VALUE: HN,
  FST_ERR_MISSING_SERIALIZATION_FN: qN,
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: BN
} = Wt, Tx = Object.prototype.toString;
function He(e, t, r) {
  this.raw = e, this[vn] = null, this[xx] = !1, this[Dl] = !1, this[Sm] = !1, this.request = t, this[Be] = {}, this[St] = null, this[wm] = !1, this[na] = void 0, this.log = r;
}
He.props = [];
Object.defineProperties(He.prototype, {
  [$e]: {
    get() {
      return this.request[$e];
=======
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: LR,
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: jR,
  FST_ERR_REP_READABLE_STREAM_LOCKED: DR,
  FST_ERR_REP_ALREADY_SENT: FR,
  FST_ERR_SEND_INSIDE_ONERR: MR,
  FST_ERR_BAD_STATUS_CODE: zR,
  FST_ERR_BAD_TRAILER_NAME: UR,
  FST_ERR_BAD_TRAILER_VALUE: qR,
  FST_ERR_MISSING_SERIALIZATION_FN: HR,
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: BR
} = _t, pb = Object.prototype.toString;
function Ie(e, t, r) {
  this.raw = e, this[Sr] = null, this[ub] = !1, this[No] = !1, this[of] = !1, this.request = t, this[Ne] = {}, this[it] = null, this[sf] = !1, this[Us] = void 0, this.log = r;
}
Ie.props = [];
Object.defineProperties(Ie.prototype, {
  [ge]: {
    get() {
      return this.request[ge];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  elapsedTime: {
    get() {
<<<<<<< HEAD
      return this[na] === void 0 ? 0 : (this[Em] || uh()) - this[na];
=======
      return this[Us] === void 0 ? 0 : (this[nf] || iu()) - this[Us];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  server: {
    get() {
<<<<<<< HEAD
      return this.request[$e].server;
=======
      return this.request[ge].server;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  sent: {
    enumerable: !0,
    get() {
<<<<<<< HEAD
      return (this[bm] || this.raw.writableEnded) === !0;
=======
      return (this[rf] || this.raw.writableEnded) === !0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  statusCode: {
    get() {
      return this.raw.statusCode;
    },
    set(e) {
      this.code(e);
    }
  },
  routeOptions: {
    get() {
      return this.request.routeOptions;
    }
  }
});
<<<<<<< HEAD
He.prototype.writeEarlyHints = function(e, t) {
  return this.raw.writeEarlyHints(e, t), this;
};
He.prototype.hijack = function() {
  return this[bm] = !0, this;
};
He.prototype.send = function(e) {
  if (this[Sm] === !0)
    throw new jN();
  if (this.sent)
    return this.log.warn({ err: new FN(this.request.url, this.request.method) }), this;
  if (e instanceof Error || this[Dl] === !0)
    return this[Dl] = !1, ia(this, e, bi), this;
  if (e === void 0)
    return bi(this, e), this;
=======
Ie.prototype.writeEarlyHints = function(e, t) {
  return this.raw.writeEarlyHints(e, t), this;
};
Ie.prototype.hijack = function() {
  return this[rf] = !0, this;
};
Ie.prototype.send = function(e) {
  if (this[of] === !0)
    throw new MR();
  if (this.sent)
    return this.log.warn({ err: new FR(this.request.url, this.request.method) }), this;
  if (e instanceof Error || this[No] === !0)
    return this[No] = !1, qs(this, e, Qr), this;
  if (e === void 0)
    return Qr(this, e), this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = this.getHeader("content-type"), r = t !== void 0;
  if (e !== null) {
    if (
      // node:stream
      typeof e.pipe == "function" || // node:stream/web
      typeof e.getReader == "function" || // Response
<<<<<<< HEAD
      Tx.call(e) === "[object Response]"
    )
      return bi(this, e), this;
    if ((e == null ? void 0 : e.buffer) instanceof ArrayBuffer) {
      r === !1 && (this[Be]["content-type"] = Rd.OCTET);
      const n = Buffer.isBuffer(e) ? e : Buffer.from(e.buffer, e.byteOffset, e.byteLength);
      return bi(this, n), this;
    }
    if (r === !1 && typeof e == "string")
      return this[Be]["content-type"] = Rd.PLAIN, bi(this, e), this;
  }
  if (this[vn] !== null) {
    if (typeof e != "string")
      return m0(this, e), this;
    e = this[vn](e);
  } else if (r === !1 || t.indexOf("json") > -1) {
    if (r === !1)
      this[Be]["content-type"] = Rd.JSON;
    else if (t.indexOf("charset") === -1) {
      const n = t.trim();
      n.endsWith(";") ? this[Be]["content-type"] = `${n} charset=utf-8` : this[Be]["content-type"] = `${n}; charset=utf-8`;
    }
    if (typeof e != "string")
      return m0(this, e), this;
  }
  return bi(this, e), this;
};
He.prototype.getHeader = function(e) {
  e = e.toLowerCase();
  const t = this.raw;
  let r = this[Be][e];
  return r === void 0 && t.hasHeader(e) && (r = t.getHeader(e)), r;
};
He.prototype.getHeaders = function() {
  return {
    ...this.raw.getHeaders(),
    ...this[Be]
  };
};
He.prototype.hasHeader = function(e) {
  return e = e.toLowerCase(), this[Be][e] !== void 0 || this.raw.hasHeader(e);
};
He.prototype.removeHeader = function(e) {
  return delete this[Be][e.toLowerCase()], this;
};
He.prototype.header = function(e, t = "") {
  return e = e.toLowerCase(), this[Be][e] && e === "set-cookie" ? (typeof this[Be][e] == "string" && (this[Be][e] = [this[Be][e]]), Array.isArray(t) ? Array.prototype.push.apply(this[Be][e], t) : this[Be][e].push(t)) : this[Be][e] = t, this;
};
He.prototype.headers = function(e) {
=======
      pb.call(e) === "[object Response]"
    )
      return Qr(this, e), this;
    if ((e == null ? void 0 : e.buffer) instanceof ArrayBuffer) {
      r === !1 && (this[Ne]["content-type"] = Uc.OCTET);
      const n = Buffer.isBuffer(e) ? e : Buffer.from(e.buffer, e.byteOffset, e.byteLength);
      return Qr(this, n), this;
    }
    if (r === !1 && typeof e == "string")
      return this[Ne]["content-type"] = Uc.PLAIN, Qr(this, e), this;
  }
  if (this[Sr] !== null) {
    if (typeof e != "string")
      return xh(this, e), this;
    e = this[Sr](e);
  } else if (r === !1 || t.indexOf("json") > -1) {
    if (r === !1)
      this[Ne]["content-type"] = Uc.JSON;
    else if (t.indexOf("charset") === -1) {
      const n = t.trim();
      n.endsWith(";") ? this[Ne]["content-type"] = `${n} charset=utf-8` : this[Ne]["content-type"] = `${n}; charset=utf-8`;
    }
    if (typeof e != "string")
      return xh(this, e), this;
  }
  return Qr(this, e), this;
};
Ie.prototype.getHeader = function(e) {
  e = e.toLowerCase();
  const t = this.raw;
  let r = this[Ne][e];
  return r === void 0 && t.hasHeader(e) && (r = t.getHeader(e)), r;
};
Ie.prototype.getHeaders = function() {
  return {
    ...this.raw.getHeaders(),
    ...this[Ne]
  };
};
Ie.prototype.hasHeader = function(e) {
  return e = e.toLowerCase(), this[Ne][e] !== void 0 || this.raw.hasHeader(e);
};
Ie.prototype.removeHeader = function(e) {
  return delete this[Ne][e.toLowerCase()], this;
};
Ie.prototype.header = function(e, t = "") {
  return e = e.toLowerCase(), this[Ne][e] && e === "set-cookie" ? (typeof this[Ne][e] == "string" && (this[Ne][e] = [this[Ne][e]]), Array.isArray(t) ? Array.prototype.push.apply(this[Ne][e], t) : this[Ne][e].push(t)) : this[Ne][e] = t, this;
};
Ie.prototype.headers = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = Object.keys(e);
  for (let r = 0; r !== t.length; ++r) {
    const n = t[r];
    this.header(n, e[n]);
  }
  return this;
};
<<<<<<< HEAD
const zN = /* @__PURE__ */ new Set([
=======
const VR = /* @__PURE__ */ new Set([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "transfer-encoding",
  "content-length",
  "host",
  "cache-control",
  "max-forwards",
  "te",
  "authorization",
  "set-cookie",
  "content-encoding",
  "content-type",
  "content-range",
  "trailer"
]);
<<<<<<< HEAD
He.prototype.trailer = function(e, t) {
  if (e = e.toLowerCase(), zN.has(e))
    throw new MN(e);
  if (typeof t != "function")
    throw new HN(e, typeof t);
  return this[St] === null && (this[St] = {}), this[St][e] = t, this;
};
He.prototype.hasTrailer = function(e) {
  var t;
  return ((t = this[St]) == null ? void 0 : t[e.toLowerCase()]) !== void 0;
};
He.prototype.removeTrailer = function(e) {
  return this[St] === null ? this : (this[St][e.toLowerCase()] = void 0, this);
};
He.prototype.code = function(e) {
  const t = Number(e);
  if (isNaN(t) || t < 100 || t > 599)
    throw new UN(e || String(e));
  return this.raw.statusCode = t, this[wm] = !0, this;
};
He.prototype.status = He.prototype.code;
He.prototype.getSerializationFunction = function(e, t) {
  var n, i, s, o;
  let r;
  return typeof e == "string" || typeof e == "number" ? typeof t == "string" ? r = (i = (n = this[$e][Ll]) == null ? void 0 : n[e]) == null ? void 0 : i[t] : r = (s = this[$e][Ll]) == null ? void 0 : s[e] : typeof e == "object" && (r = (o = this[$e][Un]) == null ? void 0 : o.get(e)), r;
};
He.prototype.compileSerializationSchema = function(e, t = null, r = null) {
  var c;
  const { request: n } = this, { method: i, url: s } = n;
  if ((c = this[$e][Un]) != null && c.has(e))
    return this[$e][Un].get(e);
  const a = (this[$e].serializerCompiler || this.server[xd].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
  // nor set
  this.server[xd].setupSerializer(this.server[ON]) || this.server[xd].serializerCompiler)({
    schema: e,
    method: i,
    url: s,
    httpStatus: t,
    contentType: r
  });
  return this[$e][Un] == null && (this[$e][Un] = /* @__PURE__ */ new WeakMap()), this[$e][Un].set(e, a), a;
};
He.prototype.serializeInput = function(e, t, r, n) {
  var o, a, c, u;
  const i = r;
  let s;
  if (r = typeof t == "string" || typeof t == "number" ? t : r, n = r && i !== r ? i : n, r != null) {
    if (n != null ? s = (a = (o = this[$e][Ll]) == null ? void 0 : o[r]) == null ? void 0 : a[n] : s = (c = this[$e][Ll]) == null ? void 0 : c[r], s == null)
      throw n ? new BN(r, n) : new qN(r);
  } else
    (u = this[$e][Un]) != null && u.has(t) ? s = this[$e][Un].get(t) : s = this.compileSerializationSchema(t, r, n);
  return s(e);
};
He.prototype.serialize = function(e) {
  return this[vn] !== null ? this[vn](e) : this[$e] && this[$e][kl] ? this[$e][kl](e, this.raw.statusCode) : Cx(this[$e], e, this.raw.statusCode);
};
He.prototype.serializer = function(e) {
  return this[vn] = e, this;
};
He.prototype.type = function(e) {
  return this[Be]["content-type"] = e, this;
};
He.prototype.redirect = function(e, t) {
  return t || (t = this[wm] ? this.raw.statusCode : 302), this.header("location", e).code(t).send();
};
He.prototype.callNotFound = function() {
  return XN(this), this;
};
He.prototype.then = function(e, t) {
=======
Ie.prototype.trailer = function(e, t) {
  if (e = e.toLowerCase(), VR.has(e))
    throw new UR(e);
  if (typeof t != "function")
    throw new qR(e, typeof t);
  return this[it] === null && (this[it] = {}), this[it][e] = t, this;
};
Ie.prototype.hasTrailer = function(e) {
  var t;
  return ((t = this[it]) == null ? void 0 : t[e.toLowerCase()]) !== void 0;
};
Ie.prototype.removeTrailer = function(e) {
  return this[it] === null ? this : (this[it][e.toLowerCase()] = void 0, this);
};
Ie.prototype.code = function(e) {
  const t = Number(e);
  if (isNaN(t) || t < 100 || t > 599)
    throw new zR(e || String(e));
  return this.raw.statusCode = t, this[sf] = !0, this;
};
Ie.prototype.status = Ie.prototype.code;
Ie.prototype.getSerializationFunction = function(e, t) {
  var n, s, i, o;
  let r;
  return typeof e == "string" || typeof e == "number" ? typeof t == "string" ? r = (s = (n = this[ge][Ao]) == null ? void 0 : n[e]) == null ? void 0 : s[t] : r = (i = this[ge][Ao]) == null ? void 0 : i[e] : typeof e == "object" && (r = (o = this[ge][Lr]) == null ? void 0 : o.get(e)), r;
};
Ie.prototype.compileSerializationSchema = function(e, t = null, r = null) {
  var c;
  const { request: n } = this, { method: s, url: i } = n;
  if ((c = this[ge][Lr]) != null && c.has(e))
    return this[ge][Lr].get(e);
  const a = (this[ge].serializerCompiler || this.server[zc].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
  // nor set
  this.server[zc].setupSerializer(this.server[CR]) || this.server[zc].serializerCompiler)({
    schema: e,
    method: s,
    url: i,
    httpStatus: t,
    contentType: r
  });
  return this[ge][Lr] == null && (this[ge][Lr] = /* @__PURE__ */ new WeakMap()), this[ge][Lr].set(e, a), a;
};
Ie.prototype.serializeInput = function(e, t, r, n) {
  var o, a, c, f;
  const s = r;
  let i;
  if (r = typeof t == "string" || typeof t == "number" ? t : r, n = r && s !== r ? s : n, r != null) {
    if (n != null ? i = (a = (o = this[ge][Ao]) == null ? void 0 : o[r]) == null ? void 0 : a[n] : i = (c = this[ge][Ao]) == null ? void 0 : c[r], i == null)
      throw n ? new BR(r, n) : new HR(r);
  } else
    (f = this[ge][Lr]) != null && f.has(t) ? i = this[ge][Lr].get(t) : i = this.compileSerializationSchema(t, r, n);
  return i(e);
};
Ie.prototype.serialize = function(e) {
  return this[Sr] !== null ? this[Sr](e) : this[ge] && this[ge][Io] ? this[ge][Io](e, this.raw.statusCode) : yb(this[ge], e, this.raw.statusCode);
};
Ie.prototype.serializer = function(e) {
  return this[Sr] = e, this;
};
Ie.prototype.type = function(e) {
  return this[Ne]["content-type"] = e, this;
};
Ie.prototype.redirect = function(e, t) {
  return t || (t = this[sf] ? this.raw.statusCode : 302), this.header("location", e).code(t).send();
};
Ie.prototype.callNotFound = function() {
  return ZR(this), this;
};
Ie.prototype.then = function(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (this.sent) {
    e();
    return;
  }
<<<<<<< HEAD
  lh(this.raw, (r) => {
    r && r.code !== "ERR_STREAM_PREMATURE_CLOSE" ? t ? t(r) : this.log && this.log.warn("unhandled rejection on reply.then") : e();
  });
};
function m0(e, t) {
  e[$e].preSerialization !== null ? AN(
    e[$e].preSerialization,
    e.request,
    e,
    t,
    g0
  ) : g0(null, e.request, e, t);
}
function g0(e, t, r, n) {
  if (e != null) {
    ia(r, e);
    return;
  }
  try {
    r[vn] !== null ? n = r[vn](n) : r[$e] && r[$e][kl] ? n = r[$e][kl](n, r.raw.statusCode) : n = Cx(r[$e], n, r.raw.statusCode, r[Be]["content-type"]);
  } catch (i) {
    VN(i, r), ia(r, i);
    return;
  }
  bi(r, n);
}
function VN(e, t) {
  e.serialization = t[$e].config;
}
function bi(e, t) {
  e[$e].onSend !== null ? $x(
    e[$e].onSend,
    e.request,
    e,
    t,
    GN
  ) : Ox(e, t);
}
function GN(e, t, r, n) {
  e != null ? ia(r, e) : Ox(r, n);
}
function $d(e, t) {
  const r = e.raw;
  try {
    r.writeHead(t, e[Be]);
=======
  su(this.raw, (r) => {
    r && r.code !== "ERR_STREAM_PREMATURE_CLOSE" ? t ? t(r) : this.log && this.log.warn("unhandled rejection on reply.then") : e();
  });
};
function xh(e, t) {
  e[ge].preSerialization !== null ? NR(
    e[ge].preSerialization,
    e.request,
    e,
    t,
    wh
  ) : wh(null, e.request, e, t);
}
function wh(e, t, r, n) {
  if (e != null) {
    qs(r, e);
    return;
  }
  try {
    r[Sr] !== null ? n = r[Sr](n) : r[ge] && r[ge][Io] ? n = r[ge][Io](n, r.raw.statusCode) : n = yb(r[ge], n, r.raw.statusCode, r[Ne]["content-type"]);
  } catch (s) {
    GR(s, r), qs(r, s);
    return;
  }
  Qr(r, n);
}
function GR(e, t) {
  e.serialization = t[ge].config;
}
function Qr(e, t) {
  e[ge].onSend !== null ? db(
    e[ge].onSend,
    e.request,
    e,
    t,
    WR
  ) : hb(e, t);
}
function WR(e, t, r, n) {
  e != null ? qs(r, e) : hb(r, n);
}
function qc(e, t) {
  const r = e.raw;
  try {
    r.writeHead(t, e[Ne]);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch (n) {
    throw n.code === "ERR_HTTP_HEADERS_SENT" && e.log.warn(`Reply was already sent, did you forget to "return reply" in the "${e.request.raw.url}" (${e.request.raw.method}) route?`), n;
  }
}
<<<<<<< HEAD
function Ox(e, t) {
  const r = e.raw, n = e.request;
  if (e[St] !== null) {
    const s = Object.keys(e[St]);
    let o = "";
    for (const a of s)
      typeof e[St][a] == "function" && (o += " ", o += a);
    e.header("Transfer-Encoding", "chunked"), e.header("Trailer", o.trim());
  }
  if (Tx.call(t) === "[object Response]") {
    if (typeof t.status == "number" && e.code(t.status), typeof t.headers == "object" && typeof t.headers.forEach == "function")
      for (const [s, o] of t.headers)
        e.header(s, o);
    if (t.body !== null && t.bodyUsed)
      throw new DN();
    t = t.body;
  }
  const i = r.statusCode;
  if (t == null) {
    i >= 200 && i !== 204 && i !== 304 && n.method !== "HEAD" && e[St] === null && (e[Be]["content-length"] = "0"), $d(e, i), ul(t, r, e);
    return;
  }
  if (i >= 100 && i < 200 || i === 204) {
    e.removeHeader("content-type"), e.removeHeader("content-length"), $d(e, i), ul(void 0, r, e), typeof t.resume == "function" && (t.on("error", Ax), t.resume());
    return;
  }
  if (typeof t.pipe == "function") {
    Px(t, r, e);
    return;
  }
  if (typeof t.getReader == "function") {
    WN(t, r, e);
    return;
  }
  if (typeof t != "string" && !Buffer.isBuffer(t))
    throw new kN(typeof t);
  if (e[St] === null) {
    const s = e[Be]["content-length"];
    (!s || n.raw.method !== "HEAD" && Number(s) !== Buffer.byteLength(t)) && (e[Be]["content-length"] = "" + Buffer.byteLength(t));
  }
  $d(e, i), r.write(t), ul(t, r, e);
}
function y0(e, t, r) {
  t.code === "ERR_STREAM_PREMATURE_CLOSE" ? e[Rx] || e.info({ res: r }, "stream closed prematurely") : e.warn({ err: t }, "response terminated with an error with headers already sent");
}
function WN(e, t, r) {
  if (e.locked)
    throw LN();
  const n = $N.fromWeb(e);
  Px(n, t, r);
}
function Px(e, t, r) {
  let n = !0, i = !1;
  if (KN(e, t, r), lh(e, { readable: !0, writable: !1 }, function(s) {
    n = !1, s != null && (t.headersSent || r.request.raw.aborted === !0 ? (i || (i = !0, y0(r.log, s, r)), t.destroy()) : ia(r, s));
  }), lh(t, function(s) {
    n && (s != null && t.headersSent && !i && (i = !0, y0(r.log, s, t)), typeof e.destroy == "function" ? e.destroy() : typeof e.close == "function" ? e.close(Ax) : typeof e.abort == "function" ? e.abort() : r.log.warn("stream payload does not end properly"));
  }), t.headersSent)
    r.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
  else
    for (const s in r[Be])
      t.setHeader(s, r[Be][s]);
  e.pipe(t);
}
function ul(e, t, r) {
  if (r[St] === null) {
    t.end(null, null, null);
    return;
  }
  const n = Object.keys(r[St]), i = {};
  let s = 0, o = !0;
  function a() {
    s === 0 && (t.addTrailers(i), t.end(null, null, null));
  }
  for (const c of n) {
    let u = function(f, m) {
      s++, f ? r.log.debug(f) : i[c] = m, process.nextTick(a);
    };
    if (typeof r[St][c] != "function") continue;
    o = !1, s--;
    const l = r[St][c](r, e, u);
    typeof l == "object" && typeof l.then == "function" && l.then((f) => u(null, f), u);
  }
  o && t.end(null, null, null);
}
function KN(e, t, r) {
  r[St] !== null && e.on("end", () => ul(null, t, r));
}
function ia(e, t, r) {
  e[$e].onError !== null && !e[TN] ? (e[Sm] = !0, $x(
    e[$e].onError,
    e.request,
    e,
    t,
    () => h0(e, t, r)
  )) : h0(e, t, r);
}
function YN(e) {
  e[na] = uh();
  const t = (r) => {
    e[Em] = uh(), e.raw.removeListener("finish", t), e.raw.removeListener("error", t);
    const n = e[$e];
    n && n.onResponse !== null ? PN(
      n.onResponse,
      e.request,
      e,
      v0
    ) : v0(r, e.request, e);
  };
  e.raw.on("finish", t), e.raw.on("error", t);
}
function v0(e, t, r) {
  if (r.log[Rx])
=======
function hb(e, t) {
  const r = e.raw, n = e.request;
  if (e[it] !== null) {
    const i = Object.keys(e[it]);
    let o = "";
    for (const a of i)
      typeof e[it][a] == "function" && (o += " ", o += a);
    e.header("Transfer-Encoding", "chunked"), e.header("Trailer", o.trim());
  }
  if (pb.call(t) === "[object Response]") {
    if (typeof t.status == "number" && e.code(t.status), typeof t.headers == "object" && typeof t.headers.forEach == "function")
      for (const [i, o] of t.headers)
        e.header(i, o);
    if (t.body !== null && t.bodyUsed)
      throw new jR();
    t = t.body;
  }
  const s = r.statusCode;
  if (t == null) {
    s >= 200 && s !== 204 && s !== 304 && n.method !== "HEAD" && e[it] === null && (e[Ne]["content-length"] = "0"), qc(e, s), uo(t, r, e);
    return;
  }
  if (s >= 100 && s < 200 || s === 204) {
    e.removeHeader("content-type"), e.removeHeader("content-length"), qc(e, s), uo(void 0, r, e), typeof t.resume == "function" && (t.on("error", gb), t.resume());
    return;
  }
  if (typeof t.pipe == "function") {
    mb(t, r, e);
    return;
  }
  if (typeof t.getReader == "function") {
    KR(t, r, e);
    return;
  }
  if (typeof t != "string" && !Buffer.isBuffer(t))
    throw new LR(typeof t);
  if (e[it] === null) {
    const i = e[Ne]["content-length"];
    (!i || n.raw.method !== "HEAD" && Number(i) !== Buffer.byteLength(t)) && (e[Ne]["content-length"] = "" + Buffer.byteLength(t));
  }
  qc(e, s), r.write(t), uo(t, r, e);
}
function Rh(e, t, r) {
  t.code === "ERR_STREAM_PREMATURE_CLOSE" ? e[fb] || e.info({ res: r }, "stream closed prematurely") : e.warn({ err: t }, "response terminated with an error with headers already sent");
}
function KR(e, t, r) {
  if (e.locked)
    throw DR();
  const n = TR.fromWeb(e);
  mb(n, t, r);
}
function mb(e, t, r) {
  let n = !0, s = !1;
  if (JR(e, t, r), su(e, { readable: !0, writable: !1 }, function(i) {
    n = !1, i != null && (t.headersSent || r.request.raw.aborted === !0 ? (s || (s = !0, Rh(r.log, i, r)), t.destroy()) : qs(r, i));
  }), su(t, function(i) {
    n && (i != null && t.headersSent && !s && (s = !0, Rh(r.log, i, t)), typeof e.destroy == "function" ? e.destroy() : typeof e.close == "function" ? e.close(gb) : typeof e.abort == "function" ? e.abort() : r.log.warn("stream payload does not end properly"));
  }), t.headersSent)
    r.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
  else
    for (const i in r[Ne])
      t.setHeader(i, r[Ne][i]);
  e.pipe(t);
}
function uo(e, t, r) {
  if (r[it] === null) {
    t.end(null, null, null);
    return;
  }
  const n = Object.keys(r[it]), s = {};
  let i = 0, o = !0;
  function a() {
    i === 0 && (t.addTrailers(s), t.end(null, null, null));
  }
  for (const c of n) {
    let f = function(d, g) {
      i++, d ? r.log.debug(d) : s[c] = g, process.nextTick(a);
    };
    if (typeof r[it][c] != "function") continue;
    o = !1, i--;
    const l = r[it][c](r, e, f);
    typeof l == "object" && typeof l.then == "function" && l.then((d) => f(null, d), f);
  }
  o && t.end(null, null, null);
}
function JR(e, t, r) {
  r[it] !== null && e.on("end", () => uo(null, t, r));
}
function qs(e, t, r) {
  e[ge].onError !== null && !e[OR] ? (e[of] = !0, db(
    e[ge].onError,
    e.request,
    e,
    t,
    () => Sh(e, t, r)
  )) : Sh(e, t, r);
}
function YR(e) {
  e[Us] = iu();
  const t = (r) => {
    e[nf] = iu(), e.raw.removeListener("finish", t), e.raw.removeListener("error", t);
    const n = e[ge];
    n && n.onResponse !== null ? PR(
      n.onResponse,
      e.request,
      e,
      $h
    ) : $h(r, e.request, e);
  };
  e.raw.on("finish", t), e.raw.on("error", t);
}
function $h(e, t, r) {
  if (r.log[fb])
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return;
  const n = r.elapsedTime;
  if (e != null) {
    r.log.error({
      res: r,
      err: e,
      responseTime: n
    }, "request errored");
    return;
  }
  r.log.info({
    res: r,
    responseTime: n
  }, "request completed");
}
<<<<<<< HEAD
function JN(e) {
  const t = e.props.slice();
  function r(n, i, s) {
    this.raw = n, this[Dl] = !1, this[xx] = !1, this[bm] = !1, this[vn] = null, this.request = i, this[Be] = {}, this[St] = null, this[na] = void 0, this[Em] = void 0, this.log = s;
=======
function XR(e) {
  const t = e.props.slice();
  function r(n, s, i) {
    this.raw = n, this[No] = !1, this[ub] = !1, this[rf] = !1, this[Sr] = null, this.request = s, this[Ne] = {}, this[it] = null, this[Us] = void 0, this[nf] = void 0, this.log = i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    let o;
    for (let a = 0; a < t.length; a++)
      o = t[a], this[o.key] = o.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.parent = e, r.props = t, r;
}
<<<<<<< HEAD
function XN(e) {
  if (e[$e][d0] === null) {
    e.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response."), e.code(404).send("404 Not Found");
    return;
  }
  e.request[$e] = e[$e][d0], e[$e].preHandler !== null ? CN(
    e[$e].preHandler,
    e.request,
    e,
    p0.preHandlerCallback
  ) : p0.preHandlerCallback(null, e.request, e);
}
function Cx(e, t, r, n) {
  const i = NN(e, r, n);
  return i ? i(t) : JSON.stringify(t);
}
function Ax() {
}
Ru.exports = He;
Ru.exports.buildReply = JN;
Ru.exports.setupResponseListeners = YN;
var xm = Ru.exports, Rm = { exports: {} }, Zs = { exports: {} }, Au = { exports: {} };
=======
function ZR(e) {
  if (e[ge][_h] === null) {
    e.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response."), e.code(404).send("404 Not Found");
    return;
  }
  e.request[ge] = e[ge][_h], e[ge].preHandler !== null ? IR(
    e[ge].preHandler,
    e.request,
    e,
    Eh.preHandlerCallback
  ) : Eh.preHandlerCallback(null, e.request, e);
}
function yb(e, t, r, n) {
  const s = kR(e, r, n);
  return s ? s(t) : JSON.stringify(t);
}
function gb() {
}
oa.exports = Ie;
oa.exports.buildReply = XR;
oa.exports.setupResponseListeners = YR;
var af = oa.exports, cf = { exports: {} }, rs = { exports: {} }, da = { exports: {} };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
function $m(e) {
=======
function lf(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!e)
    throw new TypeError("argument req is required");
  const t = e.headers["x-forwarded-for"], r = e.socket.remoteAddress;
  if (!t || typeof t != "string")
    return [r];
  if (t.indexOf(",") === -1) {
    const n = t.trim();
    return n.length ? [r, n] : [r];
  } else
<<<<<<< HEAD
    return ZN(t, r);
}
function ZN(e, t) {
  const r = [t];
  let n = e.length, i = n, s, o;
  for (o = n - 1; o >= 0; --o)
    s = e[o], s === " " ? i === n && (i = n = o) : s === "," ? (i !== n && r.push(e.slice(i, n)), i = n = o) : i = o;
  return i !== n && r.push(e.substring(i, n)), r;
}
Au.exports = $m;
Au.exports.default = $m;
Au.exports.forwarded = $m;
var QN = Au.exports, Ix = { exports: {} };
=======
    return QR(t, r);
}
function QR(e, t) {
  const r = [t];
  let n = e.length, s = n, i, o;
  for (o = n - 1; o >= 0; --o)
    i = e[o], i === " " ? s === n && (s = n = o) : i === "," ? (s !== n && r.push(e.slice(s, n)), s = n = o) : s = o;
  return s !== n && r.push(e.substring(s, n)), r;
}
da.exports = lf;
da.exports.default = lf;
da.exports.forwarded = lf;
var e$ = da.exports, vb = { exports: {} };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
(function(e) {
  (function(t) {
    const r = "(0?\\d+|0x[a-f0-9]+)", n = {
      fourOctet: new RegExp(`^${r}\\.${r}\\.${r}\\.${r}$`, "i"),
      threeOctet: new RegExp(`^${r}\\.${r}\\.${r}$`, "i"),
      twoOctet: new RegExp(`^${r}\\.${r}$`, "i"),
      longValue: new RegExp(`^${r}$`, "i")
<<<<<<< HEAD
    }, i = new RegExp("^0[0-7]+$", "i"), s = new RegExp("^0x[a-f0-9]+$", "i"), o = "%[0-9a-z]{1,}", a = "(?:[0-9a-f]+::?)+", c = {
=======
    }, s = new RegExp("^0[0-7]+$", "i"), i = new RegExp("^0x[a-f0-9]+$", "i"), o = "%[0-9a-z]{1,}", a = "(?:[0-9a-f]+::?)+", c = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      zoneIndex: new RegExp(o, "i"),
      native: new RegExp(`^(::)?(${a})?([0-9a-f]+)?(::)?(${o})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${r}\\.${r}\\.${r}\\.${r}(${o})?)$`, "i"),
      transitional: new RegExp(`^((?:${a})|(?:::)(?:${a})?)${r}\\.${r}\\.${r}\\.${r}(${o})?$`, "i")
    };
<<<<<<< HEAD
    function u(d, h) {
      if (d.indexOf("::") !== d.lastIndexOf("::"))
        return null;
      let _ = 0, g = -1, v = (d.match(c.zoneIndex) || [])[0], y, E;
      for (v && (v = v.substring(1), d = d.replace(/%.+$/, "")); (g = d.indexOf(":", g + 1)) >= 0; )
        _++;
      if (d.substr(0, 2) === "::" && _--, d.substr(-2, 2) === "::" && _--, _ > h)
        return null;
      for (E = h - _, y = ":"; E--; )
        y += "0:";
      return d = d.replace("::", y), d[0] === ":" && (d = d.slice(1)), d[d.length - 1] === ":" && (d = d.slice(0, -1)), h = function() {
        const R = d.split(":"), w = [];
        for (let C = 0; C < R.length; C++)
          w.push(parseInt(R[C], 16));
        return w;
=======
    function f(u, h) {
      if (u.indexOf("::") !== u.lastIndexOf("::"))
        return null;
      let b = 0, m = -1, v = (u.match(c.zoneIndex) || [])[0], y, _;
      for (v && (v = v.substring(1), u = u.replace(/%.+$/, "")); (m = u.indexOf(":", m + 1)) >= 0; )
        b++;
      if (u.substr(0, 2) === "::" && b--, u.substr(-2, 2) === "::" && b--, b > h)
        return null;
      for (_ = h - b, y = ":"; _--; )
        y += "0:";
      return u = u.replace("::", y), u[0] === ":" && (u = u.slice(1)), u[u.length - 1] === ":" && (u = u.slice(0, -1)), h = function() {
        const R = u.split(":"), E = [];
        for (let O = 0; O < R.length; O++)
          E.push(parseInt(R[O], 16));
        return E;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }(), {
        parts: h,
        zoneId: v
      };
    }
<<<<<<< HEAD
    function l(d, h, _, g) {
      if (d.length !== h.length)
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      let v = 0, y;
      for (; g > 0; ) {
        if (y = _ - g, y < 0 && (y = 0), d[v] >> y !== h[v] >> y)
          return !1;
        g -= _, v += 1;
      }
      return !0;
    }
    function f(d) {
      if (s.test(d))
        return parseInt(d, 16);
      if (d[0] === "0" && !isNaN(parseInt(d[1], 10))) {
        if (i.test(d))
          return parseInt(d, 8);
        throw new Error(`ipaddr: cannot parse ${d} as octal`);
      }
      return parseInt(d, 10);
    }
    function m(d, h) {
      for (; d.length < h; )
        d = `0${d}`;
      return d;
    }
    const p = {};
    p.IPv4 = function() {
      function d(h) {
        if (h.length !== 4)
          throw new Error("ipaddr: ipv4 octet count should be 4");
        let _, g;
        for (_ = 0; _ < h.length; _++)
          if (g = h[_], !(0 <= g && g <= 255))
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        this.octets = h;
      }
      return d.prototype.SpecialRanges = {
        unspecified: [[new d([0, 0, 0, 0]), 8]],
        broadcast: [[new d([255, 255, 255, 255]), 32]],
        // RFC3171
        multicast: [[new d([224, 0, 0, 0]), 4]],
        // RFC3927
        linkLocal: [[new d([169, 254, 0, 0]), 16]],
        // RFC5735
        loopback: [[new d([127, 0, 0, 0]), 8]],
        // RFC6598
        carrierGradeNat: [[new d([100, 64, 0, 0]), 10]],
        // RFC1918
        private: [
          [new d([10, 0, 0, 0]), 8],
          [new d([172, 16, 0, 0]), 12],
          [new d([192, 168, 0, 0]), 16]
        ],
        // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
        reserved: [
          [new d([192, 0, 0, 0]), 24],
          [new d([192, 0, 2, 0]), 24],
          [new d([192, 88, 99, 0]), 24],
          [new d([198, 18, 0, 0]), 15],
          [new d([198, 51, 100, 0]), 24],
          [new d([203, 0, 113, 0]), 24],
          [new d([240, 0, 0, 0]), 4]
        ],
        // RFC7534, RFC7535
        as112: [
          [new d([192, 175, 48, 0]), 24],
          [new d([192, 31, 196, 0]), 24]
        ],
        // RFC7450
        amt: [
          [new d([192, 52, 193, 0]), 24]
        ]
      }, d.prototype.kind = function() {
        return "ipv4";
      }, d.prototype.match = function(h, _) {
        let g;
        if (_ === void 0 && (g = h, h = g[0], _ = g[1]), h.kind() !== "ipv4")
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        return l(this.octets, h.octets, 8, _);
      }, d.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, _ = !1;
        const g = {
=======
    function l(u, h, b, m) {
      if (u.length !== h.length)
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      let v = 0, y;
      for (; m > 0; ) {
        if (y = b - m, y < 0 && (y = 0), u[v] >> y !== h[v] >> y)
          return !1;
        m -= b, v += 1;
      }
      return !0;
    }
    function d(u) {
      if (i.test(u))
        return parseInt(u, 16);
      if (u[0] === "0" && !isNaN(parseInt(u[1], 10))) {
        if (s.test(u))
          return parseInt(u, 8);
        throw new Error(`ipaddr: cannot parse ${u} as octal`);
      }
      return parseInt(u, 10);
    }
    function g(u, h) {
      for (; u.length < h; )
        u = `0${u}`;
      return u;
    }
    const p = {};
    p.IPv4 = function() {
      function u(h) {
        if (h.length !== 4)
          throw new Error("ipaddr: ipv4 octet count should be 4");
        let b, m;
        for (b = 0; b < h.length; b++)
          if (m = h[b], !(0 <= m && m <= 255))
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        this.octets = h;
      }
      return u.prototype.SpecialRanges = {
        unspecified: [[new u([0, 0, 0, 0]), 8]],
        broadcast: [[new u([255, 255, 255, 255]), 32]],
        // RFC3171
        multicast: [[new u([224, 0, 0, 0]), 4]],
        // RFC3927
        linkLocal: [[new u([169, 254, 0, 0]), 16]],
        // RFC5735
        loopback: [[new u([127, 0, 0, 0]), 8]],
        // RFC6598
        carrierGradeNat: [[new u([100, 64, 0, 0]), 10]],
        // RFC1918
        private: [
          [new u([10, 0, 0, 0]), 8],
          [new u([172, 16, 0, 0]), 12],
          [new u([192, 168, 0, 0]), 16]
        ],
        // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
        reserved: [
          [new u([192, 0, 0, 0]), 24],
          [new u([192, 0, 2, 0]), 24],
          [new u([192, 88, 99, 0]), 24],
          [new u([198, 18, 0, 0]), 15],
          [new u([198, 51, 100, 0]), 24],
          [new u([203, 0, 113, 0]), 24],
          [new u([240, 0, 0, 0]), 4]
        ],
        // RFC7534, RFC7535
        as112: [
          [new u([192, 175, 48, 0]), 24],
          [new u([192, 31, 196, 0]), 24]
        ],
        // RFC7450
        amt: [
          [new u([192, 52, 193, 0]), 24]
        ]
      }, u.prototype.kind = function() {
        return "ipv4";
      }, u.prototype.match = function(h, b) {
        let m;
        if (b === void 0 && (m = h, h = m[0], b = m[1]), h.kind() !== "ipv4")
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        return l(this.octets, h.octets, 8, b);
      }, u.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, b = !1;
        const m = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
<<<<<<< HEAD
        let v, y, E;
        for (v = 3; v >= 0; v -= 1)
          if (y = this.octets[v], y in g) {
            if (E = g[y], _ && E !== 0)
              return null;
            E !== 8 && (_ = !0), h += E;
          } else
            return null;
        return 32 - h;
      }, d.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, d.prototype.toByteArray = function() {
        return this.octets.slice(0);
      }, d.prototype.toIPv4MappedAddress = function() {
        return p.IPv6.parse(`::ffff:${this.toString()}`);
      }, d.prototype.toNormalizedString = function() {
        return this.toString();
      }, d.prototype.toString = function() {
        return this.octets.join(".");
      }, d;
    }(), p.IPv4.broadcastAddressFromCIDR = function(d) {
      try {
        const h = this.parseCIDR(d), _ = h[0].toByteArray(), g = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 4; )
          v.push(parseInt(_[y], 10) | parseInt(g[y], 10) ^ 255), y++;
=======
        let v, y, _;
        for (v = 3; v >= 0; v -= 1)
          if (y = this.octets[v], y in m) {
            if (_ = m[y], b && _ !== 0)
              return null;
            _ !== 8 && (b = !0), h += _;
          } else
            return null;
        return 32 - h;
      }, u.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, u.prototype.toByteArray = function() {
        return this.octets.slice(0);
      }, u.prototype.toIPv4MappedAddress = function() {
        return p.IPv6.parse(`::ffff:${this.toString()}`);
      }, u.prototype.toNormalizedString = function() {
        return this.toString();
      }, u.prototype.toString = function() {
        return this.octets.join(".");
      }, u;
    }(), p.IPv4.broadcastAddressFromCIDR = function(u) {
      try {
        const h = this.parseCIDR(u), b = h[0].toByteArray(), m = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 4; )
          v.push(parseInt(b[y], 10) | parseInt(m[y], 10) ^ 255), y++;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
<<<<<<< HEAD
    }, p.IPv4.isIPv4 = function(d) {
      return this.parser(d) !== null;
    }, p.IPv4.isValid = function(d) {
      try {
        return new this(this.parser(d)), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidCIDR = function(d) {
      try {
        return this.parseCIDR(d), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidFourPartDecimal = function(d) {
      return !!(p.IPv4.isValid(d) && d.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
    }, p.IPv4.networkAddressFromCIDR = function(d) {
      let h, _, g, v, y;
      try {
        for (h = this.parseCIDR(d), g = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], _ = 0; _ < 4; )
          v.push(parseInt(g[_], 10) & parseInt(y[_], 10)), _++;
=======
    }, p.IPv4.isIPv4 = function(u) {
      return this.parser(u) !== null;
    }, p.IPv4.isValid = function(u) {
      try {
        return new this(this.parser(u)), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidCIDR = function(u) {
      try {
        return this.parseCIDR(u), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidFourPartDecimal = function(u) {
      return !!(p.IPv4.isValid(u) && u.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
    }, p.IPv4.networkAddressFromCIDR = function(u) {
      let h, b, m, v, y;
      try {
        for (h = this.parseCIDR(u), m = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], b = 0; b < 4; )
          v.push(parseInt(m[b], 10) & parseInt(y[b], 10)), b++;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
<<<<<<< HEAD
    }, p.IPv4.parse = function(d) {
      const h = this.parser(d);
      if (h === null)
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      return new this(h);
    }, p.IPv4.parseCIDR = function(d) {
      let h;
      if (h = d.match(/^(.+)\/(\d+)$/)) {
        const _ = parseInt(h[2]);
        if (_ >= 0 && _ <= 32) {
          const g = [this.parse(h[1]), _];
          return Object.defineProperty(g, "toString", {
            value: function() {
              return this.join("/");
            }
          }), g;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    }, p.IPv4.parser = function(d) {
      let h, _, g;
      if (h = d.match(n.fourOctet))
        return function() {
          const v = h.slice(1, 6), y = [];
          for (let E = 0; E < v.length; E++)
            _ = v[E], y.push(f(_));
          return y;
        }();
      if (h = d.match(n.longValue)) {
        if (g = f(h[1]), g > 4294967295 || g < 0)
=======
    }, p.IPv4.parse = function(u) {
      const h = this.parser(u);
      if (h === null)
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      return new this(h);
    }, p.IPv4.parseCIDR = function(u) {
      let h;
      if (h = u.match(/^(.+)\/(\d+)$/)) {
        const b = parseInt(h[2]);
        if (b >= 0 && b <= 32) {
          const m = [this.parse(h[1]), b];
          return Object.defineProperty(m, "toString", {
            value: function() {
              return this.join("/");
            }
          }), m;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    }, p.IPv4.parser = function(u) {
      let h, b, m;
      if (h = u.match(n.fourOctet))
        return function() {
          const v = h.slice(1, 6), y = [];
          for (let _ = 0; _ < v.length; _++)
            b = v[_], y.push(d(b));
          return y;
        }();
      if (h = u.match(n.longValue)) {
        if (m = d(h[1]), m > 4294967295 || m < 0)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          throw new Error("ipaddr: address outside defined range");
        return function() {
          const v = [];
          let y;
          for (y = 0; y <= 24; y += 8)
<<<<<<< HEAD
            v.push(g >> y & 255);
          return v;
        }().reverse();
      } else return (h = d.match(n.twoOctet)) ? function() {
        const v = h.slice(1, 4), y = [];
        if (g = f(v[1]), g > 16777215 || g < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(f(v[0])), y.push(g >> 16 & 255), y.push(g >> 8 & 255), y.push(g & 255), y;
      }() : (h = d.match(n.threeOctet)) ? function() {
        const v = h.slice(1, 5), y = [];
        if (g = f(v[2]), g > 65535 || g < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(f(v[0])), y.push(f(v[1])), y.push(g >> 8 & 255), y.push(g & 255), y;
      }() : null;
    }, p.IPv4.subnetMaskFromPrefixLength = function(d) {
      if (d = parseInt(d), d < 0 || d > 32)
        throw new Error("ipaddr: invalid IPv4 prefix length");
      const h = [0, 0, 0, 0];
      let _ = 0;
      const g = Math.floor(d / 8);
      for (; _ < g; )
        h[_] = 255, _++;
      return g < 4 && (h[g] = Math.pow(2, d % 8) - 1 << 8 - d % 8), new this(h);
    }, p.IPv6 = function() {
      function d(h, _) {
        let g, v;
        if (h.length === 16)
          for (this.parts = [], g = 0; g <= 14; g += 2)
            this.parts.push(h[g] << 8 | h[g + 1]);
=======
            v.push(m >> y & 255);
          return v;
        }().reverse();
      } else return (h = u.match(n.twoOctet)) ? function() {
        const v = h.slice(1, 4), y = [];
        if (m = d(v[1]), m > 16777215 || m < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(d(v[0])), y.push(m >> 16 & 255), y.push(m >> 8 & 255), y.push(m & 255), y;
      }() : (h = u.match(n.threeOctet)) ? function() {
        const v = h.slice(1, 5), y = [];
        if (m = d(v[2]), m > 65535 || m < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(d(v[0])), y.push(d(v[1])), y.push(m >> 8 & 255), y.push(m & 255), y;
      }() : null;
    }, p.IPv4.subnetMaskFromPrefixLength = function(u) {
      if (u = parseInt(u), u < 0 || u > 32)
        throw new Error("ipaddr: invalid IPv4 prefix length");
      const h = [0, 0, 0, 0];
      let b = 0;
      const m = Math.floor(u / 8);
      for (; b < m; )
        h[b] = 255, b++;
      return m < 4 && (h[m] = Math.pow(2, u % 8) - 1 << 8 - u % 8), new this(h);
    }, p.IPv6 = function() {
      function u(h, b) {
        let m, v;
        if (h.length === 16)
          for (this.parts = [], m = 0; m <= 14; m += 2)
            this.parts.push(h[m] << 8 | h[m + 1]);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        else if (h.length === 8)
          this.parts = h;
        else
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
<<<<<<< HEAD
        for (g = 0; g < this.parts.length; g++)
          if (v = this.parts[g], !(0 <= v && v <= 65535))
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        _ && (this.zoneId = _);
      }
      return d.prototype.SpecialRanges = {
        // RFC4291, here and after
        unspecified: [new d([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new d([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new d([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new d([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new d([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new d([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        // RFC6666
        discard: [new d([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        // RFC6145
        rfc6145: [new d([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        // RFC6052
        rfc6052: [new d([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        // RFC3056
        "6to4": [new d([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        // RFC6052, RFC6146
        teredo: [new d([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        // RFC5180
        benchmarking: [new d([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        // RFC7450
        amt: [new d([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new d([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new d([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new d([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new d([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new d([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          // RFC3849
          [new d([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          // RFC2928
          [new d([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      }, d.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      }, d.prototype.kind = function() {
        return "ipv6";
      }, d.prototype.match = function(h, _) {
        let g;
        if (_ === void 0 && (g = h, h = g[0], _ = g[1]), h.kind() !== "ipv6")
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        return l(this.parts, h.parts, 16, _);
      }, d.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, _ = !1;
        const g = {
=======
        for (m = 0; m < this.parts.length; m++)
          if (v = this.parts[m], !(0 <= v && v <= 65535))
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        b && (this.zoneId = b);
      }
      return u.prototype.SpecialRanges = {
        // RFC4291, here and after
        unspecified: [new u([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new u([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new u([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new u([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new u([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new u([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        // RFC6666
        discard: [new u([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        // RFC6145
        rfc6145: [new u([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        // RFC6052
        rfc6052: [new u([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        // RFC3056
        "6to4": [new u([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        // RFC6052, RFC6146
        teredo: [new u([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        // RFC5180
        benchmarking: [new u([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        // RFC7450
        amt: [new u([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new u([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new u([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new u([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new u([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new u([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          // RFC3849
          [new u([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          // RFC2928
          [new u([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      }, u.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      }, u.prototype.kind = function() {
        return "ipv6";
      }, u.prototype.match = function(h, b) {
        let m;
        if (b === void 0 && (m = h, h = m[0], b = m[1]), h.kind() !== "ipv6")
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        return l(this.parts, h.parts, 16, b);
      }, u.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, b = !1;
        const m = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let v, y;
<<<<<<< HEAD
        for (let E = 7; E >= 0; E -= 1)
          if (v = this.parts[E], v in g) {
            if (y = g[v], _ && y !== 0)
              return null;
            y !== 16 && (_ = !0), h += y;
          } else
            return null;
        return 128 - h;
      }, d.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, d.prototype.toByteArray = function() {
        let h;
        const _ = [], g = this.parts;
        for (let v = 0; v < g.length; v++)
          h = g[v], _.push(h >> 8), _.push(h & 255);
        return _;
      }, d.prototype.toFixedLengthString = function() {
        const h = (function() {
          const g = [];
          for (let v = 0; v < this.parts.length; v++)
            g.push(m(this.parts[v].toString(16), 4));
          return g;
        }).call(this).join(":");
        let _ = "";
        return this.zoneId && (_ = `%${this.zoneId}`), h + _;
      }, d.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress())
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        const h = this.parts.slice(-2), _ = h[0], g = h[1];
        return new p.IPv4([_ >> 8, _ & 255, g >> 8, g & 255]);
      }, d.prototype.toNormalizedString = function() {
        const h = (function() {
          const g = [];
          for (let v = 0; v < this.parts.length; v++)
            g.push(this.parts[v].toString(16));
          return g;
        }).call(this).join(":");
        let _ = "";
        return this.zoneId && (_ = `%${this.zoneId}`), h + _;
      }, d.prototype.toRFC5952String = function() {
        const h = /((^|:)(0(:|$)){2,})/g, _ = this.toNormalizedString();
        let g = 0, v = -1, y;
        for (; y = h.exec(_); )
          y[0].length > v && (g = y.index, v = y[0].length);
        return v < 0 ? _ : `${_.substring(0, g)}::${_.substring(g + v)}`;
      }, d.prototype.toString = function() {
        return this.toRFC5952String();
      }, d;
    }(), p.IPv6.broadcastAddressFromCIDR = function(d) {
      try {
        const h = this.parseCIDR(d), _ = h[0].toByteArray(), g = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 16; )
          v.push(parseInt(_[y], 10) | parseInt(g[y], 10) ^ 255), y++;
=======
        for (let _ = 7; _ >= 0; _ -= 1)
          if (v = this.parts[_], v in m) {
            if (y = m[v], b && y !== 0)
              return null;
            y !== 16 && (b = !0), h += y;
          } else
            return null;
        return 128 - h;
      }, u.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, u.prototype.toByteArray = function() {
        let h;
        const b = [], m = this.parts;
        for (let v = 0; v < m.length; v++)
          h = m[v], b.push(h >> 8), b.push(h & 255);
        return b;
      }, u.prototype.toFixedLengthString = function() {
        const h = (function() {
          const m = [];
          for (let v = 0; v < this.parts.length; v++)
            m.push(g(this.parts[v].toString(16), 4));
          return m;
        }).call(this).join(":");
        let b = "";
        return this.zoneId && (b = `%${this.zoneId}`), h + b;
      }, u.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress())
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        const h = this.parts.slice(-2), b = h[0], m = h[1];
        return new p.IPv4([b >> 8, b & 255, m >> 8, m & 255]);
      }, u.prototype.toNormalizedString = function() {
        const h = (function() {
          const m = [];
          for (let v = 0; v < this.parts.length; v++)
            m.push(this.parts[v].toString(16));
          return m;
        }).call(this).join(":");
        let b = "";
        return this.zoneId && (b = `%${this.zoneId}`), h + b;
      }, u.prototype.toRFC5952String = function() {
        const h = /((^|:)(0(:|$)){2,})/g, b = this.toNormalizedString();
        let m = 0, v = -1, y;
        for (; y = h.exec(b); )
          y[0].length > v && (m = y.index, v = y[0].length);
        return v < 0 ? b : `${b.substring(0, m)}::${b.substring(m + v)}`;
      }, u.prototype.toString = function() {
        return this.toRFC5952String();
      }, u;
    }(), p.IPv6.broadcastAddressFromCIDR = function(u) {
      try {
        const h = this.parseCIDR(u), b = h[0].toByteArray(), m = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 16; )
          v.push(parseInt(b[y], 10) | parseInt(m[y], 10) ^ 255), y++;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return new this(v);
      } catch (h) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${h})`);
      }
<<<<<<< HEAD
    }, p.IPv6.isIPv6 = function(d) {
      return this.parser(d) !== null;
    }, p.IPv6.isValid = function(d) {
      if (typeof d == "string" && d.indexOf(":") === -1)
        return !1;
      try {
        const h = this.parser(d);
=======
    }, p.IPv6.isIPv6 = function(u) {
      return this.parser(u) !== null;
    }, p.IPv6.isValid = function(u) {
      if (typeof u == "string" && u.indexOf(":") === -1)
        return !1;
      try {
        const h = this.parser(u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return new this(h.parts, h.zoneId), !0;
      } catch {
        return !1;
      }
<<<<<<< HEAD
    }, p.IPv6.isValidCIDR = function(d) {
      if (typeof d == "string" && d.indexOf(":") === -1)
        return !1;
      try {
        return this.parseCIDR(d), !0;
      } catch {
        return !1;
      }
    }, p.IPv6.networkAddressFromCIDR = function(d) {
      let h, _, g, v, y;
      try {
        for (h = this.parseCIDR(d), g = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], _ = 0; _ < 16; )
          v.push(parseInt(g[_], 10) & parseInt(y[_], 10)), _++;
        return new this(v);
      } catch (E) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${E})`);
      }
    }, p.IPv6.parse = function(d) {
      const h = this.parser(d);
      if (h.parts === null)
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      return new this(h.parts, h.zoneId);
    }, p.IPv6.parseCIDR = function(d) {
      let h, _, g;
      if ((_ = d.match(/^(.+)\/(\d+)$/)) && (h = parseInt(_[2]), h >= 0 && h <= 128))
        return g = [this.parse(_[1]), h], Object.defineProperty(g, "toString", {
          value: function() {
            return this.join("/");
          }
        }), g;
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    }, p.IPv6.parser = function(d) {
      let h, _, g, v, y, E;
      if (g = d.match(c.deprecatedTransitional))
        return this.parser(`::ffff:${g[1]}`);
      if (c.native.test(d))
        return u(d, 8);
      if ((g = d.match(c.transitional)) && (E = g[6] || "", h = g[1], g[1].endsWith("::") || (h = h.slice(0, -1)), h = u(h + E, 6), h.parts)) {
        for (y = [
          parseInt(g[2]),
          parseInt(g[3]),
          parseInt(g[4]),
          parseInt(g[5])
        ], _ = 0; _ < y.length; _++)
          if (v = y[_], !(0 <= v && v <= 255))
=======
    }, p.IPv6.isValidCIDR = function(u) {
      if (typeof u == "string" && u.indexOf(":") === -1)
        return !1;
      try {
        return this.parseCIDR(u), !0;
      } catch {
        return !1;
      }
    }, p.IPv6.networkAddressFromCIDR = function(u) {
      let h, b, m, v, y;
      try {
        for (h = this.parseCIDR(u), m = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], b = 0; b < 16; )
          v.push(parseInt(m[b], 10) & parseInt(y[b], 10)), b++;
        return new this(v);
      } catch (_) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${_})`);
      }
    }, p.IPv6.parse = function(u) {
      const h = this.parser(u);
      if (h.parts === null)
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      return new this(h.parts, h.zoneId);
    }, p.IPv6.parseCIDR = function(u) {
      let h, b, m;
      if ((b = u.match(/^(.+)\/(\d+)$/)) && (h = parseInt(b[2]), h >= 0 && h <= 128))
        return m = [this.parse(b[1]), h], Object.defineProperty(m, "toString", {
          value: function() {
            return this.join("/");
          }
        }), m;
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    }, p.IPv6.parser = function(u) {
      let h, b, m, v, y, _;
      if (m = u.match(c.deprecatedTransitional))
        return this.parser(`::ffff:${m[1]}`);
      if (c.native.test(u))
        return f(u, 8);
      if ((m = u.match(c.transitional)) && (_ = m[6] || "", h = m[1], m[1].endsWith("::") || (h = h.slice(0, -1)), h = f(h + _, 6), h.parts)) {
        for (y = [
          parseInt(m[2]),
          parseInt(m[3]),
          parseInt(m[4]),
          parseInt(m[5])
        ], b = 0; b < y.length; b++)
          if (v = y[b], !(0 <= v && v <= 255))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            return null;
        return h.parts.push(y[0] << 8 | y[1]), h.parts.push(y[2] << 8 | y[3]), {
          parts: h.parts,
          zoneId: h.zoneId
        };
      }
      return null;
<<<<<<< HEAD
    }, p.IPv6.subnetMaskFromPrefixLength = function(d) {
      if (d = parseInt(d), d < 0 || d > 128)
        throw new Error("ipaddr: invalid IPv6 prefix length");
      const h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let _ = 0;
      const g = Math.floor(d / 8);
      for (; _ < g; )
        h[_] = 255, _++;
      return g < 16 && (h[g] = Math.pow(2, d % 8) - 1 << 8 - d % 8), new this(h);
    }, p.fromByteArray = function(d) {
      const h = d.length;
      if (h === 4)
        return new p.IPv4(d);
      if (h === 16)
        return new p.IPv6(d);
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }, p.isValid = function(d) {
      return p.IPv6.isValid(d) || p.IPv4.isValid(d);
    }, p.isValidCIDR = function(d) {
      return p.IPv6.isValidCIDR(d) || p.IPv4.isValidCIDR(d);
    }, p.parse = function(d) {
      if (p.IPv6.isValid(d))
        return p.IPv6.parse(d);
      if (p.IPv4.isValid(d))
        return p.IPv4.parse(d);
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }, p.parseCIDR = function(d) {
      try {
        return p.IPv6.parseCIDR(d);
      } catch {
        try {
          return p.IPv4.parseCIDR(d);
=======
    }, p.IPv6.subnetMaskFromPrefixLength = function(u) {
      if (u = parseInt(u), u < 0 || u > 128)
        throw new Error("ipaddr: invalid IPv6 prefix length");
      const h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let b = 0;
      const m = Math.floor(u / 8);
      for (; b < m; )
        h[b] = 255, b++;
      return m < 16 && (h[m] = Math.pow(2, u % 8) - 1 << 8 - u % 8), new this(h);
    }, p.fromByteArray = function(u) {
      const h = u.length;
      if (h === 4)
        return new p.IPv4(u);
      if (h === 16)
        return new p.IPv6(u);
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }, p.isValid = function(u) {
      return p.IPv6.isValid(u) || p.IPv4.isValid(u);
    }, p.isValidCIDR = function(u) {
      return p.IPv6.isValidCIDR(u) || p.IPv4.isValidCIDR(u);
    }, p.parse = function(u) {
      if (p.IPv6.isValid(u))
        return p.IPv6.parse(u);
      if (p.IPv4.isValid(u))
        return p.IPv4.parse(u);
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }, p.parseCIDR = function(u) {
      try {
        return p.IPv6.parseCIDR(u);
      } catch {
        try {
          return p.IPv4.parseCIDR(u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        } catch {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
<<<<<<< HEAD
    }, p.process = function(d) {
      const h = this.parse(d);
      return h.kind() === "ipv6" && h.isIPv4MappedAddress() ? h.toIPv4Address() : h;
    }, p.subnetMatch = function(d, h, _) {
      let g, v, y, E;
      _ == null && (_ = "unicast");
      for (v in h)
        if (Object.prototype.hasOwnProperty.call(h, v)) {
          for (y = h[v], y[0] && !(y[0] instanceof Array) && (y = [y]), g = 0; g < y.length; g++)
            if (E = y[g], d.kind() === E[0].kind() && d.match.apply(d, E))
              return v;
        }
      return _;
    }, e.exports ? e.exports = p : t.ipaddr = p;
  })(me);
})(Ix);
var ek = Ix.exports;
=======
    }, p.process = function(u) {
      const h = this.parse(u);
      return h.kind() === "ipv6" && h.isIPv4MappedAddress() ? h.toIPv4Address() : h;
    }, p.subnetMatch = function(u, h, b) {
      let m, v, y, _;
      b == null && (b = "unicast");
      for (v in h)
        if (Object.prototype.hasOwnProperty.call(h, v)) {
          for (y = h[v], y[0] && !(y[0] instanceof Array) && (y = [y]), m = 0; m < y.length; m++)
            if (_ = y[m], u.kind() === _[0].kind() && u.match.apply(u, _))
              return v;
        }
      return b;
    }, e.exports ? e.exports = p : t.ipaddr = p;
  })(_e);
})(vb);
var t$ = vb.exports;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
/*!
 * proxy-addr
 * Copyright(c) 2021 Fastify collaborators
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
Zs.exports = Tm;
Zs.exports.default = Tm;
Zs.exports.proxyaddr = Tm;
Zs.exports.all = kx;
Zs.exports.compile = Dx;
const tk = QN, Nx = ek, rk = /^\d+$/u, Fl = Nx.isValid, Iu = Nx.parse, _0 = {
=======
rs.exports = uf;
rs.exports.default = uf;
rs.exports.proxyaddr = uf;
rs.exports.all = _b;
rs.exports.compile = Eb;
const r$ = e$, bb = t$, n$ = /^\d+$/u, ko = bb.isValid, pa = bb.parse, Th = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
<<<<<<< HEAD
function kx(e, t) {
  const r = tk(e);
  if (!t)
    return r;
  typeof t != "function" && (t = Dx(t));
=======
function _b(e, t) {
  const r = r$(e);
  if (!t)
    return r;
  typeof t != "function" && (t = Eb(t));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  for (var n = 0; n < r.length - 1; n++)
    t(r[n], n) || (r.length = n + 1);
  return r;
}
<<<<<<< HEAD
function Dx(e) {
=======
function Eb(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!e)
    throw new TypeError("argument is required");
  let t;
  if (typeof e == "string")
    t = [e];
  else if (Array.isArray(e))
    t = e.slice();
  else
    throw new TypeError("unsupported trust argument");
  for (var r = 0; r < t.length; r++)
<<<<<<< HEAD
    e = t[r], Object.prototype.hasOwnProperty.call(_0, e) && (e = _0[e], t.splice.apply(t, [r, 1].concat(e)), r += e.length - 1);
  return ik(nk(t));
}
function nk(e) {
  const t = new Array(e.length);
  for (var r = 0; r < e.length; r++)
    t[r] = sk(e[r]);
  return t;
}
function ik(e) {
  const t = e.length;
  return t === 0 ? ak : t === 1 ? lk(e[0]) : ck(e);
}
function sk(e) {
  const t = e.lastIndexOf("/"), r = t !== -1 ? e.substring(0, t) : e;
  if (!Fl(r))
    throw new TypeError("invalid IP address: " + r);
  let n = Iu(r);
  t === -1 && n.kind() === "ipv6" && n.isIPv4MappedAddress() && (n = n.toIPv4Address());
  const i = n.kind() === "ipv6" ? 128 : 32;
  let s = t !== -1 ? e.substring(t + 1, e.length) : null;
  if (s === null ? s = i : rk.test(s) ? s = parseInt(s, 10) : n.kind() === "ipv4" && Fl(s) ? s = ok(s) : s = null, s <= 0 || s > i)
    throw new TypeError("invalid range on address: " + e);
  return [n, s];
}
function ok(e) {
  const t = Iu(e);
  return t.kind() === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
}
function Tm(e, t) {
=======
    e = t[r], Object.prototype.hasOwnProperty.call(Th, e) && (e = Th[e], t.splice.apply(t, [r, 1].concat(e)), r += e.length - 1);
  return i$(s$(t));
}
function s$(e) {
  const t = new Array(e.length);
  for (var r = 0; r < e.length; r++)
    t[r] = o$(e[r]);
  return t;
}
function i$(e) {
  const t = e.length;
  return t === 0 ? c$ : t === 1 ? u$(e[0]) : l$(e);
}
function o$(e) {
  const t = e.lastIndexOf("/"), r = t !== -1 ? e.substring(0, t) : e;
  if (!ko(r))
    throw new TypeError("invalid IP address: " + r);
  let n = pa(r);
  t === -1 && n.kind() === "ipv6" && n.isIPv4MappedAddress() && (n = n.toIPv4Address());
  const s = n.kind() === "ipv6" ? 128 : 32;
  let i = t !== -1 ? e.substring(t + 1, e.length) : null;
  if (i === null ? i = s : n$.test(i) ? i = parseInt(i, 10) : n.kind() === "ipv4" && ko(i) ? i = a$(i) : i = null, i <= 0 || i > s)
    throw new TypeError("invalid range on address: " + e);
  return [n, i];
}
function a$(e) {
  const t = pa(e);
  return t.kind() === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
}
function uf(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!e)
    throw new TypeError("req argument is required");
  if (!t)
    throw new TypeError("trust argument is required");
<<<<<<< HEAD
  const r = kx(e, t);
  return r[r.length - 1];
}
function ak() {
  return !1;
}
function ck(e) {
  return function(r) {
    if (!Fl(r)) return !1;
    const n = Iu(r);
    let i;
    const s = n.kind();
    for (var o = 0; o < e.length; o++) {
      const a = e[o], c = a[0], u = c.kind(), l = a[1];
      let f = n;
      if (s !== u) {
        if (u === "ipv4" && !n.isIPv4MappedAddress())
          continue;
        i || (i = u === "ipv4" ? n.toIPv4Address() : n.toIPv4MappedAddress()), f = i;
      }
      if (f.match(c, l))
=======
  const r = _b(e, t);
  return r[r.length - 1];
}
function c$() {
  return !1;
}
function l$(e) {
  return function(r) {
    if (!ko(r)) return !1;
    const n = pa(r);
    let s;
    const i = n.kind();
    for (var o = 0; o < e.length; o++) {
      const a = e[o], c = a[0], f = c.kind(), l = a[1];
      let d = n;
      if (i !== f) {
        if (f === "ipv4" && !n.isIPv4MappedAddress())
          continue;
        s || (s = f === "ipv4" ? n.toIPv4Address() : n.toIPv4MappedAddress()), d = s;
      }
      if (d.match(c, l))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return !0;
    }
    return !1;
  };
}
<<<<<<< HEAD
function lk(e) {
  const t = e[0], r = t.kind(), n = r === "ipv4", i = e[1];
  return function(o) {
    if (!Fl(o)) return !1;
    let a = Iu(o);
=======
function u$(e) {
  const t = e[0], r = t.kind(), n = r === "ipv4", s = e[1];
  return function(o) {
    if (!ko(o)) return !1;
    let a = pa(o);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (a.kind() !== r) {
      if (n && !a.isIPv4MappedAddress())
        return !1;
      a = n ? a.toIPv4Address() : a.toIPv4MappedAddress();
    }
<<<<<<< HEAD
    return a.match(t, i);
  };
}
var uk = Zs.exports;
const jl = uk, {
  kHasBeenDecorated: fk,
  kSchemaBody: dk,
  kSchemaHeaders: pk,
  kSchemaParams: hk,
  kSchemaQuerystring: b0,
  kSchemaController: Td,
  kOptions: mk,
  kRequestCacheValidateFns: An,
  kRouteContext: zt,
  kRequestOriginalUrl: Od
} = Ft, { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: gk } = Wt, E0 = {
  body: dk,
  headers: pk,
  params: hk,
  querystring: b0,
  query: b0
};
function Om(e, t, r, n, i, s) {
  this.id = e, this[zt] = s, this.params = t, this.raw = r, this.query = n, this.log = i, this.body = void 0;
}
Om.props = [];
function yk(e) {
=======
    return a.match(t, s);
  };
}
var f$ = rs.exports;
const Lo = f$, {
  kHasBeenDecorated: d$,
  kSchemaBody: p$,
  kSchemaHeaders: h$,
  kSchemaParams: m$,
  kSchemaQuerystring: Oh,
  kSchemaController: Hc,
  kOptions: y$,
  kRequestCacheValidateFns: Cr,
  kRouteContext: gt,
  kRequestOriginalUrl: Bc
} = ht, { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: g$ } = _t, Ch = {
  body: p$,
  headers: h$,
  params: m$,
  querystring: Oh,
  query: Oh
};
function ff(e, t, r, n, s, i) {
  this.id = e, this[gt] = i, this.params = t, this.raw = r, this.query = n, this.log = s, this.body = void 0;
}
ff.props = [];
function v$(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (typeof e == "function")
    return e;
  if (e === !0)
    return null;
  if (typeof e == "number")
    return function(t, r) {
      return r < e;
    };
  if (typeof e == "string") {
    const t = e.split(",").map((r) => r.trim());
<<<<<<< HEAD
    return jl.compile(t);
  }
  return jl.compile(e);
}
function vk(e, t) {
  return t ? _k(e, t) : Lx(e);
}
function Lx(e) {
  const t = e.props.slice();
  function r(n, i, s, o, a, c) {
    this.id = n, this[zt] = c, this.params = i, this.raw = s, this.query = o, this.log = a, this.body = void 0;
    let u;
    for (let l = 0; l < t.length; l++)
      u = t[l], this[u.key] = u.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.props = t, r.parent = e, r;
}
function w0(e) {
  const t = e.lastIndexOf(",");
  return t === -1 ? e.trim() : e.slice(t + 1).trim();
}
function _k(e, t) {
  const r = Lx(e), n = yk(t);
  return r[fk] = !0, Object.defineProperties(r.prototype, {
    ip: {
      get() {
        const i = jl.all(this.raw, n);
        return i[i.length - 1];
=======
    return Lo.compile(t);
  }
  return Lo.compile(e);
}
function b$(e, t) {
  return t ? _$(e, t) : Sb(e);
}
function Sb(e) {
  const t = e.props.slice();
  function r(n, s, i, o, a, c) {
    this.id = n, this[gt] = c, this.params = s, this.raw = i, this.query = o, this.log = a, this.body = void 0;
    let f;
    for (let l = 0; l < t.length; l++)
      f = t[l], this[f.key] = f.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.props = t, r.parent = e, r;
}
function Ph(e) {
  const t = e.lastIndexOf(",");
  return t === -1 ? e.trim() : e.slice(t + 1).trim();
}
function _$(e, t) {
  const r = Sb(e), n = v$(t);
  return r[d$] = !0, Object.defineProperties(r.prototype, {
    ip: {
      get() {
        const s = Lo.all(this.raw, n);
        return s[s.length - 1];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    ips: {
      get() {
<<<<<<< HEAD
        return jl.all(this.raw, n);
=======
        return Lo.all(this.raw, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    host: {
      get() {
<<<<<<< HEAD
        return this.ip !== void 0 && this.headers["x-forwarded-host"] ? w0(this.headers["x-forwarded-host"]) : this.headers.host ?? this.headers[":authority"] ?? "";
=======
        return this.ip !== void 0 && this.headers["x-forwarded-host"] ? Ph(this.headers["x-forwarded-host"]) : this.headers.host ?? this.headers[":authority"] ?? "";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    protocol: {
      get() {
        if (this.headers["x-forwarded-proto"])
<<<<<<< HEAD
          return w0(this.headers["x-forwarded-proto"]);
=======
          return Ph(this.headers["x-forwarded-proto"]);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        if (this.socket)
          return this.socket.encrypted ? "https" : "http";
      }
    }
  }), r;
}
<<<<<<< HEAD
Object.defineProperties(Om.prototype, {
  server: {
    get() {
      return this[zt].server;
=======
Object.defineProperties(ff.prototype, {
  server: {
    get() {
      return this[gt].server;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  url: {
    get() {
      return this.raw.url;
    }
  },
  originalUrl: {
    get() {
<<<<<<< HEAD
      return this[Od] || (this[Od] = this.raw.originalUrl || this.raw.url), this[Od];
=======
      return this[Bc] || (this[Bc] = this.raw.originalUrl || this.raw.url), this[Bc];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  method: {
    get() {
      return this.raw.method;
    }
  },
  routeOptions: {
    get() {
<<<<<<< HEAD
      var s, o;
      const e = this[zt], t = e._parserOptions.limit, r = e.server.initialConfig.bodyLimit, n = e.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0, i = {
        method: (s = e.config) == null ? void 0 : s.method,
=======
      var i, o;
      const e = this[gt], t = e._parserOptions.limit, r = e.server.initialConfig.bodyLimit, n = e.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0, s = {
        method: (i = e.config) == null ? void 0 : i.method,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        url: (o = e.config) == null ? void 0 : o.url,
        bodyLimit: t || r,
        attachValidation: e.attachValidation,
        logLevel: e.logLevel,
        exposeHeadRoute: e.exposeHeadRoute,
        prefixTrailingSlash: e.prefixTrailingSlash,
        handler: e.handler,
        version: n
      };
<<<<<<< HEAD
      return Object.defineProperties(i, {
=======
      return Object.defineProperties(s, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        config: {
          get: () => e.config
        },
        schema: {
          get: () => e.schema
        }
<<<<<<< HEAD
      }), Object.freeze(i);
=======
      }), Object.freeze(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  is404: {
    get() {
      var e;
<<<<<<< HEAD
      return ((e = this[zt].config) == null ? void 0 : e.url) === void 0;
=======
      return ((e = this[gt].config) == null ? void 0 : e.url) === void 0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  socket: {
    get() {
      return this.raw.socket;
    }
  },
  ip: {
    get() {
      if (this.socket)
        return this.socket.remoteAddress;
    }
  },
  host: {
    get() {
      return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
    }
  },
  hostname: {
    get() {
      return this.host.split(":", 1)[0];
    }
  },
  port: {
    get() {
      const e = parseInt(this.host.split(":").slice(-1)[0]);
      if (!isNaN(e))
        return e;
      const t = this.headers.host ?? this.headers[":authority"] ?? "", r = parseInt(t.split(":").slice(-1)[0]);
      return isNaN(r) ? null : r;
    }
  },
  protocol: {
    get() {
      if (this.socket)
        return this.socket.encrypted ? "https" : "http";
    }
  },
  headers: {
    get() {
      return this.additionalHeaders ? Object.assign({}, this.raw.headers, this.additionalHeaders) : this.raw.headers;
    },
    set(e) {
      this.additionalHeaders = e;
    }
  },
  getValidationFunction: {
    value: function(e) {
      var t;
      if (typeof e == "string") {
<<<<<<< HEAD
        const r = E0[e];
        return this[zt][r];
      } else if (typeof e == "object")
        return (t = this[zt][An]) == null ? void 0 : t.get(e);
=======
        const r = Ch[e];
        return this[gt][r];
      } else if (typeof e == "object")
        return (t = this[gt][Cr]) == null ? void 0 : t.get(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  compileValidationSchema: {
    value: function(e, t = null) {
      var o;
      const { method: r, url: n } = this;
<<<<<<< HEAD
      if ((o = this[zt][An]) != null && o.has(e))
        return this[zt][An].get(e);
      const s = (this[zt].validatorCompiler || this.server[Td].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
      // nor set
      this.server[Td].setupValidator(this.server[mk]) || this.server[Td].validatorCompiler)({
=======
      if ((o = this[gt][Cr]) != null && o.has(e))
        return this[gt][Cr].get(e);
      const i = (this[gt].validatorCompiler || this.server[Hc].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
      // nor set
      this.server[Hc].setupValidator(this.server[y$]) || this.server[Hc].validatorCompiler)({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        schema: e,
        method: r,
        url: n,
        httpPart: t
      });
<<<<<<< HEAD
      return this[zt][An] == null && (this[zt][An] = /* @__PURE__ */ new WeakMap()), this[zt][An].set(e, s), s;
=======
      return this[gt][Cr] == null && (this[gt][Cr] = /* @__PURE__ */ new WeakMap()), this[gt][Cr].set(e, i), i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  },
  validateInput: {
    value: function(e, t, r) {
<<<<<<< HEAD
      var s;
      r = typeof t == "string" ? t : r;
      const n = r != null && typeof r == "string" && E0[r];
      let i;
      if (n && (i = this[zt][n]), i == null && (t == null || typeof t != "object" || Array.isArray(t)))
        throw new gk(r);
      return i == null && ((s = this[zt][An]) != null && s.has(t) ? i = this[zt][An].get(t) : i = this.compileValidationSchema(t, r)), i(e);
    }
  }
});
Rm.exports = Om;
Rm.exports.buildRequest = vk;
var Pm = Rm.exports;
const {
  kFourOhFourContext: bk,
  kReplySerializerDefault: Ek,
  kSchemaErrorFormatter: wk,
  kErrorHandler: Sk,
  kChildLoggerFactory: xk,
  kOptions: Rk,
  kReply: $k,
  kRequest: Tk,
  kBodyLimit: Ok,
  kLogLevel: Pk,
  kContentTypeParser: Ck,
  kRouteByFastify: Ak,
  kRequestCacheValidateFns: Ik,
  kReplyCacheSerializeFns: Nk
} = Ft;
function kk({
=======
      var i;
      r = typeof t == "string" ? t : r;
      const n = r != null && typeof r == "string" && Ch[r];
      let s;
      if (n && (s = this[gt][n]), s == null && (t == null || typeof t != "object" || Array.isArray(t)))
        throw new g$(r);
      return s == null && ((i = this[gt][Cr]) != null && i.has(t) ? s = this[gt][Cr].get(t) : s = this.compileValidationSchema(t, r)), s(e);
    }
  }
});
cf.exports = ff;
cf.exports.buildRequest = b$;
var df = cf.exports;
const {
  kFourOhFourContext: E$,
  kReplySerializerDefault: S$,
  kSchemaErrorFormatter: x$,
  kErrorHandler: w$,
  kChildLoggerFactory: R$,
  kOptions: $$,
  kReply: T$,
  kRequest: O$,
  kBodyLimit: C$,
  kLogLevel: P$,
  kContentTypeParser: I$,
  kRouteByFastify: N$,
  kRequestCacheValidateFns: A$,
  kReplyCacheSerializeFns: k$
} = ht;
function L$({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  schema: e,
  handler: t,
  config: r,
  requestIdLogLabel: n,
<<<<<<< HEAD
  childLoggerFactory: i,
  errorHandler: s,
  bodyLimit: o,
  logLevel: a,
  logSerializers: c,
  attachValidation: u,
  validatorCompiler: l,
  serializerCompiler: f,
  replySerializer: m,
  schemaErrorFormatter: p,
  exposeHeadRoute: d,
  prefixTrailingSlash: h,
  server: _,
  isFastify: g
}) {
  this.schema = e, this.handler = t, this.Reply = _[$k], this.Request = _[Tk], this.contentTypeParser = _[Ck], this.onRequest = null, this.onSend = null, this.onError = null, this.onTimeout = null, this.preHandler = null, this.onResponse = null, this.preSerialization = null, this.onRequestAbort = null, this.config = r, this.errorHandler = s || _[Sk], this.requestIdLogLabel = n || _[Rk].requestIdLogLabel, this.childLoggerFactory = i || _[xk], this._middie = null, this._parserOptions = {
    limit: o || _[Ok]
  }, this.exposeHeadRoute = d, this.prefixTrailingSlash = h, this.logLevel = a || _[Pk], this.logSerializers = c, this[bk] = null, this.attachValidation = u, this[Ek] = m, this.schemaErrorFormatter = p || _[wk] || Dk, this[Ak] = g, this[Ik] = null, this[Nk] = null, this.validatorCompiler = l || null, this.serializerCompiler = f || null, this.server = _;
}
function Dk(e, t) {
  let r = "";
  const n = ", ";
  for (let i = 0; i !== e.length; ++i) {
    const s = e[i];
    r += t + (s.instancePath || "") + " " + s.message + n;
  }
  return new Error(r.slice(0, -n.length));
}
var Cm = kk;
const {
  kReply: fh,
  kRequest: dh,
  kState: Lk,
  kHasBeenDecorated: Fk
} = Ft, {
  FST_ERR_DEC_ALREADY_PRESENT: Fx,
  FST_ERR_DEC_MISSING_DEPENDENCY: jk,
  FST_ERR_DEC_AFTER_START: Uk,
  FST_ERR_DEC_REFERENCE_TYPE: Mk,
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: Hk
} = Wt;
function qk(e, t, r, n) {
  if (Object.hasOwn(e, t))
    throw new Fx(t);
  Mx(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(e, t, {
=======
  childLoggerFactory: s,
  errorHandler: i,
  bodyLimit: o,
  logLevel: a,
  logSerializers: c,
  attachValidation: f,
  validatorCompiler: l,
  serializerCompiler: d,
  replySerializer: g,
  schemaErrorFormatter: p,
  exposeHeadRoute: u,
  prefixTrailingSlash: h,
  server: b,
  isFastify: m
}) {
  this.schema = e, this.handler = t, this.Reply = b[T$], this.Request = b[O$], this.contentTypeParser = b[I$], this.onRequest = null, this.onSend = null, this.onError = null, this.onTimeout = null, this.preHandler = null, this.onResponse = null, this.preSerialization = null, this.onRequestAbort = null, this.config = r, this.errorHandler = i || b[w$], this.requestIdLogLabel = n || b[$$].requestIdLogLabel, this.childLoggerFactory = s || b[R$], this._middie = null, this._parserOptions = {
    limit: o || b[C$]
  }, this.exposeHeadRoute = u, this.prefixTrailingSlash = h, this.logLevel = a || b[P$], this.logSerializers = c, this[E$] = null, this.attachValidation = f, this[S$] = g, this.schemaErrorFormatter = p || b[x$] || j$, this[N$] = m, this[A$] = null, this[k$] = null, this.validatorCompiler = l || null, this.serializerCompiler = d || null, this.server = b;
}
function j$(e, t) {
  let r = "";
  const n = ", ";
  for (let s = 0; s !== e.length; ++s) {
    const i = e[s];
    r += t + (i.instancePath || "") + " " + i.message + n;
  }
  return new Error(r.slice(0, -n.length));
}
var pf = L$;
const {
  kReply: ou,
  kRequest: au,
  kState: D$,
  kHasBeenDecorated: F$
} = ht, {
  FST_ERR_DEC_ALREADY_PRESENT: xb,
  FST_ERR_DEC_MISSING_DEPENDENCY: M$,
  FST_ERR_DEC_AFTER_START: z$,
  FST_ERR_DEC_REFERENCE_TYPE: U$,
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: q$
} = _t;
function H$(e, t, r, n) {
  if (Object.hasOwn(e, t))
    throw new xb(t);
  $b(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(e, t, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    get: r.getter,
    set: r.setter
  }) : e[t] = r;
}
<<<<<<< HEAD
function jx(e, t, r, n) {
  const i = e.prototype;
  if (Object.hasOwn(i, t) || ku(e, t))
    throw new Fx(t);
  e[Fk] = !0, Mx(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(i, t, {
    get: r.getter,
    set: r.setter
  }) : typeof r == "function" ? i[t] = r : e.props.push({ key: t, value: r });
}
function Ux(e, t) {
  if (typeof t == "object" && t && !(typeof t.getter == "function" || typeof t.setter == "function"))
    throw new Mk(e, typeof t);
}
function Bk(e, t, r) {
  return Am(this, e), qk(this, e, t, r), this;
}
function Nu(e, t) {
  return t ? t in e || e.prototype && t in e.prototype || ku(e, t) : e in this;
}
function ku(e, t) {
  return e.props ? e.props.find(({ key: r }) => r === t) : !1;
}
function zk(e) {
  return e && ku(this[dh], e) ? !0 : Nu(this[dh].prototype, e);
}
function Vk(e) {
  return e && ku(this[fh], e) ? !0 : Nu(this[fh].prototype, e);
}
function Mx(e, t, r) {
  if (r != null) {
    if (!Array.isArray(r))
      throw new Hk(t);
    for (let n = 0; n !== r.length; ++n)
      if (!Nu(e, r[n]))
        throw new jk(r[n]);
  }
}
function Gk(e, t, r) {
  return Am(this, e), Ux(e, t), jx(this[fh], e, t, r), this;
}
function Wk(e, t, r) {
  return Am(this, e), Ux(e, t), jx(this[dh], e, t, r), this;
}
function Am(e, t) {
  if (e[Lk].started)
    throw new Uk(t);
}
var Hx = {
  add: Bk,
  exist: Nu,
  existRequest: zk,
  existReply: Vk,
  decorateReply: Gk,
  decorateRequest: Wk
}, qx = { exports: {} }, sn = {};
=======
function wb(e, t, r, n) {
  const s = e.prototype;
  if (Object.hasOwn(s, t) || ma(e, t))
    throw new xb(t);
  e[F$] = !0, $b(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(s, t, {
    get: r.getter,
    set: r.setter
  }) : typeof r == "function" ? s[t] = r : e.props.push({ key: t, value: r });
}
function Rb(e, t) {
  if (typeof t == "object" && t && !(typeof t.getter == "function" || typeof t.setter == "function"))
    throw new U$(e, typeof t);
}
function B$(e, t, r) {
  return hf(this, e), H$(this, e, t, r), this;
}
function ha(e, t) {
  return t ? t in e || e.prototype && t in e.prototype || ma(e, t) : e in this;
}
function ma(e, t) {
  return e.props ? e.props.find(({ key: r }) => r === t) : !1;
}
function V$(e) {
  return e && ma(this[au], e) ? !0 : ha(this[au].prototype, e);
}
function G$(e) {
  return e && ma(this[ou], e) ? !0 : ha(this[ou].prototype, e);
}
function $b(e, t, r) {
  if (r != null) {
    if (!Array.isArray(r))
      throw new q$(t);
    for (let n = 0; n !== r.length; ++n)
      if (!ha(e, r[n]))
        throw new M$(r[n]);
  }
}
function W$(e, t, r) {
  return hf(this, e), Rb(e, t), wb(this[ou], e, t, r), this;
}
function K$(e, t, r) {
  return hf(this, e), Rb(e, t), wb(this[au], e, t, r), this;
}
function hf(e, t) {
  if (e[D$].started)
    throw new z$(t);
}
var Tb = {
  add: B$,
  exist: ha,
  existRequest: V$,
  existReply: G$,
  decorateReply: W$,
  decorateRequest: K$
}, Ob = { exports: {} }, hr = {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */
<<<<<<< HEAD
class Kk {
=======
class J$ {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ new Map(), this.last = null, this.max = t, this.ttl = r;
  }
  get size() {
    return this.items.size;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map(), this.first = null, this.last = null;
  }
  delete(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      this.items.delete(t), r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      this.items.delete(t.key), this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (this.items.has(t))
      return this.items.get(t).expiry;
  }
  get(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return this.items.keys();
  }
  set(t, r) {
    if (this.items.has(t)) {
<<<<<<< HEAD
      const i = this.items.get(t);
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
=======
      const s = this.items.get(t);
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items.set(t, n), this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
<<<<<<< HEAD
class Yk {
=======
class Y$ {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ new Map(), this.last = null, this.max = t, this.ttl = r;
  }
  get size() {
    return this.items.size;
  }
  bumpLru(t) {
    if (this.last === t)
      return;
<<<<<<< HEAD
    const r = this.last, n = t.next, i = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, i !== null && (i.next = n), n !== null && (n.prev = i), this.last = t;
=======
    const r = this.last, n = t.next, s = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, s !== null && (s.next = n), n !== null && (n.prev = s), this.last = t;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  clear() {
    this.items = /* @__PURE__ */ new Map(), this.first = null, this.last = null;
  }
  delete(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      this.items.delete(t), r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      this.items.delete(t.key), this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (this.items.has(t))
      return this.items.get(t).expiry;
  }
  get(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.bumpLru(r), r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return this.items.keys();
  }
  set(t, r) {
    if (this.items.has(t)) {
<<<<<<< HEAD
      const i = this.items.get(t);
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== i && this.bumpLru(i);
=======
      const s = this.items.get(t);
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== s && this.bumpLru(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items.set(t, n), this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
<<<<<<< HEAD
class Im {
=======
class mf {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this.max = t, this.ttl = r;
  }
  bumpLru(t) {
    if (this.last === t)
      return;
<<<<<<< HEAD
    const r = this.last, n = t.next, i = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, i !== null && (i.next = n), n !== null && (n.prev = i), this.last = t;
=======
    const r = this.last, n = t.next, s = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, s !== null && (s.next = n), n !== null && (n.prev = s), this.last = t;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null), this.first = null, this.last = null, this.size = 0;
  }
  delete(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      delete this.items[t], this.size--, r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t))
      return this.items[t].expiry;
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.bumpLru(r), r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(t, r) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
<<<<<<< HEAD
      const i = this.items[t];
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== i && this.bumpLru(i);
=======
      const s = this.items[t];
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== s && this.bumpLru(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items[t] = n, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
<<<<<<< HEAD
class Bx {
=======
class Cb {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    this.records = {};
  }
  initForCache(t, r) {
    this.records[t] = {
      [r]: {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      }
    };
  }
  resetForCache(t) {
    for (let r of Object.keys(this.records[t]))
      this.records[t][r] = {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      };
  }
  getStatistics() {
    return this.records;
  }
}
<<<<<<< HEAD
function S0(e) {
  return `${e.getFullYear()}-${(e.getMonth() + 1).toString().padStart(2, "0")}-${e.getDate().toString().padStart(2, "0")}`;
}
class Jk {
  constructor(t, r, n) {
    this.cacheId = t, this.statisticTtlInHours = r, this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = S0(this.collectionStart), this.records = n || new Bx(), this.records.initForCache(this.cacheId, this.currentTimeStamp);
=======
function Ih(e) {
  return `${e.getFullYear()}-${(e.getMonth() + 1).toString().padStart(2, "0")}-${e.getDate().toString().padStart(2, "0")}`;
}
class X$ {
  constructor(t, r, n) {
    this.cacheId = t, this.statisticTtlInHours = r, this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = Ih(this.collectionStart), this.records = n || new Cb(), this.records.initForCache(this.cacheId, this.currentTimeStamp);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  get currentRecord() {
    return this.records.records[this.cacheId][this.currentTimeStamp] || (this.records.records[this.cacheId][this.currentTimeStamp] = {
      cacheSize: 0,
      hits: 0,
      falsyHits: 0,
      emptyHits: 0,
      misses: 0,
      expirations: 0,
      evictions: 0,
      sets: 0,
      invalidateOne: 0,
      invalidateAll: 0
    }), this.records.records[this.cacheId][this.currentTimeStamp];
  }
  hoursPassed() {
    return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
  }
  addHit() {
    this.archiveIfNeeded(), this.currentRecord.hits++;
  }
  addFalsyHit() {
    this.archiveIfNeeded(), this.currentRecord.falsyHits++;
  }
  addEmptyHit() {
    this.archiveIfNeeded(), this.currentRecord.emptyHits++;
  }
  addMiss() {
    this.archiveIfNeeded(), this.currentRecord.misses++;
  }
  addEviction() {
    this.archiveIfNeeded(), this.currentRecord.evictions++;
  }
  setCacheSize(t) {
    this.archiveIfNeeded(), this.currentRecord.cacheSize = t;
  }
  addExpiration() {
    this.archiveIfNeeded(), this.currentRecord.expirations++;
  }
  addSet() {
    this.archiveIfNeeded(), this.currentRecord.sets++;
  }
  addInvalidateOne() {
    this.archiveIfNeeded(), this.currentRecord.invalidateOne++;
  }
  addInvalidateAll() {
    this.archiveIfNeeded(), this.currentRecord.invalidateAll++;
  }
  getStatistics() {
    return this.records.getStatistics();
  }
  archiveIfNeeded() {
<<<<<<< HEAD
    this.hoursPassed() >= this.statisticTtlInHours && (this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = S0(this.collectionStart), this.records.initForCache(this.cacheId, this.currentTimeStamp));
  }
}
class zx extends Im {
  constructor(t, r, n, i, s) {
    if (super(t || 1e3, r || 0), !n)
      throw new Error("Cache id is mandatory");
    this.hitStatistics = new Jk(
      n,
      s !== void 0 ? s : 24,
      i
=======
    this.hoursPassed() >= this.statisticTtlInHours && (this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = Ih(this.collectionStart), this.records.initForCache(this.cacheId, this.currentTimeStamp));
  }
}
class Pb extends mf {
  constructor(t, r, n, s, i) {
    if (super(t || 1e3, r || 0), !n)
      throw new Error("Cache id is mandatory");
    this.hitStatistics = new X$(
      n,
      i !== void 0 ? i : 24,
      s
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    );
  }
  getStatistics() {
    return this.hitStatistics.getStatistics();
  }
  set(t, r) {
    super.set(t, r), this.hitStatistics.addSet(), this.hitStatistics.setCacheSize(this.size);
  }
  evict() {
    super.evict(), this.hitStatistics.addEviction(), this.hitStatistics.setCacheSize(this.size);
  }
  delete(t, r = !1) {
    super.delete(t), r || this.hitStatistics.addInvalidateOne(), this.hitStatistics.setCacheSize(this.size);
  }
  clear() {
    super.clear(), this.hitStatistics.addInvalidateAll(), this.hitStatistics.setCacheSize(this.size);
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t, !0), this.hitStatistics.addExpiration();
        return;
      }
      return this.bumpLru(r), r.value || this.hitStatistics.addFalsyHit(), (r.value === void 0 || r.value === null || r.value === "") && this.hitStatistics.addEmptyHit(), this.hitStatistics.addHit(), r.value;
    }
    this.hitStatistics.addMiss();
  }
}
<<<<<<< HEAD
class Vx {
=======
class Ib {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this.max = t, this.ttl = r;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null), this.first = null, this.last = null, this.size = 0;
  }
  delete(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      delete this.items[t], this.size--, r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t))
      return this.items[t].expiry;
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(t, r) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
<<<<<<< HEAD
      const i = this.items[t];
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
=======
      const s = this.items[t];
      s.value = r, s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items[t] = n, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
<<<<<<< HEAD
sn.Fifo = Vx;
sn.FifoMap = Kk;
sn.FifoObject = Vx;
sn.HitStatisticsRecord = Bx;
sn.Lru = Im;
sn.LruHitStatistics = zx;
sn.LruMap = Yk;
sn.LruObject = Im;
sn.LruObjectHitStatistics = zx;
var Qs = { exports: {} };
const Xk = typeof Buffer < "u", x0 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, R0 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function Gx(e, t, r) {
  r == null && t !== null && typeof t == "object" && (r = t, t = void 0), Xk && Buffer.isBuffer(e) && (e = e.toString()), e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
  const n = JSON.parse(e, t);
  if (n === null || typeof n != "object")
    return n;
  const i = r && r.protoAction || "error", s = r && r.constructorAction || "error";
  if (i === "ignore" && s === "ignore")
    return n;
  if (i !== "ignore" && s !== "ignore") {
    if (x0.test(e) === !1 && R0.test(e) === !1)
      return n;
  } else if (i !== "ignore" && s === "ignore") {
    if (x0.test(e) === !1)
      return n;
  } else if (R0.test(e) === !1)
    return n;
  return Wx(n, { protoAction: i, constructorAction: s, safe: r && r.safe });
}
function Wx(e, { protoAction: t = "error", constructorAction: r = "error", safe: n } = {}) {
  let i = [e];
  for (; i.length; ) {
    const s = i;
    i = [];
    for (const o of s) {
=======
hr.Fifo = Ib;
hr.FifoMap = J$;
hr.FifoObject = Ib;
hr.HitStatisticsRecord = Cb;
hr.Lru = mf;
hr.LruHitStatistics = Pb;
hr.LruMap = Y$;
hr.LruObject = mf;
hr.LruObjectHitStatistics = Pb;
var ns = { exports: {} };
const Z$ = typeof Buffer < "u", Nh = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, Ah = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function Nb(e, t, r) {
  r == null && t !== null && typeof t == "object" && (r = t, t = void 0), Z$ && Buffer.isBuffer(e) && (e = e.toString()), e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
  const n = JSON.parse(e, t);
  if (n === null || typeof n != "object")
    return n;
  const s = r && r.protoAction || "error", i = r && r.constructorAction || "error";
  if (s === "ignore" && i === "ignore")
    return n;
  if (s !== "ignore" && i !== "ignore") {
    if (Nh.test(e) === !1 && Ah.test(e) === !1)
      return n;
  } else if (s !== "ignore" && i === "ignore") {
    if (Nh.test(e) === !1)
      return n;
  } else if (Ah.test(e) === !1)
    return n;
  return Ab(n, { protoAction: s, constructorAction: i, safe: r && r.safe });
}
function Ab(e, { protoAction: t = "error", constructorAction: r = "error", safe: n } = {}) {
  let s = [e];
  for (; s.length; ) {
    const i = s;
    s = [];
    for (const o of i) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (t !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
        if (n === !0)
          return null;
        if (t === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.__proto__;
      }
      if (r !== "ignore" && Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype")) {
        if (n === !0)
          return null;
        if (r === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.constructor;
      }
      for (const a in o) {
        const c = o[a];
<<<<<<< HEAD
        c && typeof c == "object" && i.push(c);
=======
        c && typeof c == "object" && s.push(c);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
  return e;
}
<<<<<<< HEAD
function Nm(e, t, r) {
  const { stackTraceLimit: n } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Gx(e, t, r);
=======
function yf(e, t, r) {
  const { stackTraceLimit: n } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Nb(e, t, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } finally {
    Error.stackTraceLimit = n;
  }
}
<<<<<<< HEAD
function Zk(e, t) {
  const { stackTraceLimit: r } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Gx(e, t, { safe: !0 });
=======
function Q$(e, t) {
  const { stackTraceLimit: r } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Nb(e, t, { safe: !0 });
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return null;
  } finally {
    Error.stackTraceLimit = r;
  }
}
<<<<<<< HEAD
Qs.exports = Nm;
Qs.exports.default = Nm;
Qs.exports.parse = Nm;
Qs.exports.safeParse = Zk;
Qs.exports.scan = Wx;
var Qk = Qs.exports;
(function(e) {
  const { AsyncResource: t } = bC, { FifoMap: r } = sn, { parse: n } = Qk, {
    kDefaultJsonParse: i,
    kContentTypeParser: s,
    kBodyLimit: o,
    kRequestPayloadStream: a,
    kState: c,
    kTestInternals: u,
    kReplyIsError: l,
    kRouteContext: f
  } = Ft, {
    FST_ERR_CTP_INVALID_TYPE: m,
    FST_ERR_CTP_EMPTY_TYPE: p,
    FST_ERR_CTP_ALREADY_PRESENT: d,
    FST_ERR_CTP_INVALID_HANDLER: h,
    FST_ERR_CTP_INVALID_PARSE_TYPE: _,
    FST_ERR_CTP_BODY_TOO_LARGE: g,
    FST_ERR_CTP_INVALID_MEDIA_TYPE: v,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: y,
    FST_ERR_CTP_EMPTY_JSON_BODY: E,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: R
  } = Wt, { FSTSEC001: w } = hm;
  function C(I, L, j) {
    this[i] = b(L, j), this.customParsers = /* @__PURE__ */ new Map(), this.customParsers.set("application/json", new H(!0, !1, I, this[i])), this.customParsers.set("text/plain", new H(!0, !1, I, F)), this.parserList = ["application/json", "text/plain"], this.parserRegExpList = [], this.cache = new r(100);
  }
  C.prototype.add = function(I, L, j) {
    const k = typeof I == "string";
    if (k) {
      if (I = I.trim().toLowerCase(), I.length === 0) throw new p();
    } else if (!(I instanceof RegExp))
      throw new m();
    if (typeof j != "function")
      throw new h();
    if (this.existingParser(I))
      throw new d(I);
    if (L.parseAs !== void 0 && L.parseAs !== "string" && L.parseAs !== "buffer")
      throw new _(L.parseAs);
    const U = new H(
      L.parseAs === "string",
      L.parseAs === "buffer",
      L.bodyLimit,
      j
    );
    I === "*" ? this.customParsers.set("", U) : k ? (this.parserList.unshift(I), this.customParsers.set(I, U)) : (D(I), this.parserRegExpList.unshift(I), this.customParsers.set(I.toString(), U));
  }, C.prototype.hasParser = function(I) {
    if (typeof I == "string")
      I = I.trim().toLowerCase();
    else {
      if (!(I instanceof RegExp)) throw new m();
      I = I.toString();
    }
    return this.customParsers.has(I);
  }, C.prototype.existingParser = function(I) {
    return I === "application/json" && this.customParsers.has(I) ? this.customParsers.get(I).fn !== this[i] : I === "text/plain" && this.customParsers.has(I) ? this.customParsers.get(I).fn !== F : this.hasParser(I);
  }, C.prototype.getParser = function(I) {
    let L = this.customParsers.get(I);
    if (L !== void 0 || (L = this.cache.get(I), L !== void 0)) return L;
    const j = I.toLowerCase();
    for (let k = 0; k !== this.parserList.length; ++k) {
      const U = this.parserList[k];
      if (j.slice(0, U.length) === U && (j.length === U.length || j.charCodeAt(U.length) === 59 || j.charCodeAt(U.length) === 32))
        return L = this.customParsers.get(U), this.cache.set(I, L), L;
    }
    for (let k = 0; k !== this.parserRegExpList.length; ++k) {
      const U = this.parserRegExpList[k];
      if (U.test(I))
        return L = this.customParsers.get(U.toString()), this.cache.set(I, L), L;
    }
    return this.customParsers.get("");
  }, C.prototype.removeAll = function() {
    this.customParsers = /* @__PURE__ */ new Map(), this.parserRegExpList = [], this.parserList = [], this.cache = new r(100);
  }, C.prototype.remove = function(I) {
    let L;
    if (typeof I == "string")
      I = I.trim().toLowerCase(), L = this.parserList;
    else {
      if (!(I instanceof RegExp)) throw new m();
      I = I.toString(), L = this.parserRegExpList;
    }
    const j = this.customParsers.delete(I), k = L.findIndex((U) => U.toString() === I);
    return k > -1 && L.splice(k, 1), j || k > -1;
  }, C.prototype.run = function(I, L, j, k) {
    const U = this.getParser(I);
    if (U === void 0) {
      j.is404 ? L(j, k) : k.send(new v(I || void 0));
      return;
    }
    const M = new t("content-type-parser:run", j);
    if (U.asString === !0 || U.asBuffer === !0)
      V(
        j,
        k,
        k[f]._parserOptions,
        U,
        T
      );
    else {
      const N = U.fn(j, j[a], T);
      N && typeof N.then == "function" && N.then((G) => T(null, G), T);
    }
    function T(N, G) {
      M.runInAsyncScope(() => {
        M.emitDestroy(), N ? (k[l] = !0, k.send(N)) : (j.body = G, L(j, k));
      });
    }
  };
  function V(I, L, j, k, U) {
    const M = k.asString, T = j.limit === null ? k.bodyLimit : j.limit, N = Number(I.headers["content-length"]);
    if (N > T) {
      L.header("connection", "close"), L.send(new g());
      return;
    }
    let G = 0, O = M === !0 ? "" : [];
    const S = I[a] || I.raw;
    M === !0 && S.setEncoding("utf8"), S.on("data", W), S.on("end", z), S.on("error", z), S.resume();
    function W(Q) {
      G += Q.length;
      const { receivedEncodedLength: K = 0 } = S;
      if (G > T || K > T) {
        S.removeListener("data", W), S.removeListener("end", z), S.removeListener("error", z), L.send(new g());
        return;
      }
      M === !0 ? O += Q : O.push(Q);
    }
    function z(Q) {
      if (S.removeListener("data", W), S.removeListener("end", z), S.removeListener("error", z), Q !== void 0) {
        typeof Q.statusCode == "number" && Q.statusCode >= 400 || (Q.statusCode = 400), L[l] = !0, L.code(Q.statusCode).send(Q);
        return;
      }
      if (M === !0 && (G = Buffer.byteLength(O)), !Number.isNaN(N) && (S.receivedEncodedLength || G) !== N) {
        L.header("connection", "close"), L.send(new y());
        return;
      }
      M === !1 && (O = Buffer.concat(O));
      const K = k.fn(I, O, U);
      K && typeof K.then == "function" && K.then((X) => U(null, X), U);
    }
  }
  function b(I, L) {
    return j;
    function j(k, U, M) {
      if (U.length === 0) {
        M(new E(), void 0);
        return;
      }
      try {
        M(null, n(U, { protoAction: I, constructorAction: L }));
      } catch (T) {
        T.statusCode = 400, M(T, void 0);
      }
    }
  }
  function F(I, L, j) {
    j(null, L);
  }
  function H(I, L, j, k) {
    this.asString = I, this.asBuffer = L, this.bodyLimit = j, this.fn = k;
  }
  function q(I) {
    const L = new C();
    return L[i] = I[i], L.customParsers = new Map(I.customParsers.entries()), L.parserList = I.parserList.slice(), L.parserRegExpList = I.parserRegExpList.slice(), L;
  }
  function $(I, L, j) {
    if (this[c].started)
      throw new R("addContentTypeParser");
    return typeof L == "function" && (j = L, L = {}), L || (L = {}), L.bodyLimit || (L.bodyLimit = this[o]), Array.isArray(I) ? I.forEach((k) => this[s].add(k, L, j)) : this[s].add(I, L, j), this;
  }
  function x(I) {
    return this[s].hasParser(I);
  }
  function A(I) {
    if (this[c].started)
      throw new R("removeContentTypeParser");
    if (Array.isArray(I))
      for (const L of I)
        this[s].remove(L);
    else
      this[s].remove(I);
  }
  function P() {
    if (this[c].started)
      throw new R("removeAllContentTypeParsers");
    this[s].removeAll();
  }
  function D(I) {
    I.source[0] !== "^" && I.source.includes(";?") === !1 && w(I.source);
  }
  e.exports = C, e.exports.helpers = {
    buildContentTypeParser: q,
    addContentTypeParser: $,
    hasContentTypeParser: x,
    removeContentTypeParser: A,
    removeAllContentTypeParsers: P
  }, e.exports.defaultParsers = {
    getDefaultJsonParser: b,
    defaultTextParser: F
  }, e.exports[u] = { rawBody: V };
})(qx);
var Kx = qx.exports, qa = { exports: {} }, Du = {}, eo = { exports: {} }, Lu = {}, $0 = Object.prototype.hasOwnProperty;
function T0(e, t, r) {
  for (r of e.keys())
    if (Wo(r, t)) return r;
}
function Wo(e, t) {
  var r, n, i;
=======
ns.exports = yf;
ns.exports.default = yf;
ns.exports.parse = yf;
ns.exports.safeParse = Q$;
ns.exports.scan = Ab;
var e1 = ns.exports;
(function(e) {
  const { AsyncResource: t } = SS, { FifoMap: r } = hr, { parse: n } = e1, {
    kDefaultJsonParse: s,
    kContentTypeParser: i,
    kBodyLimit: o,
    kRequestPayloadStream: a,
    kState: c,
    kTestInternals: f,
    kReplyIsError: l,
    kRouteContext: d
  } = ht, {
    FST_ERR_CTP_INVALID_TYPE: g,
    FST_ERR_CTP_EMPTY_TYPE: p,
    FST_ERR_CTP_ALREADY_PRESENT: u,
    FST_ERR_CTP_INVALID_HANDLER: h,
    FST_ERR_CTP_INVALID_PARSE_TYPE: b,
    FST_ERR_CTP_BODY_TOO_LARGE: m,
    FST_ERR_CTP_INVALID_MEDIA_TYPE: v,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: y,
    FST_ERR_CTP_EMPTY_JSON_BODY: _,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: R
  } = _t, { FSTSEC001: E } = Yu;
  function O(C, A, k) {
    this[s] = S(A, k), this.customParsers = /* @__PURE__ */ new Map(), this.customParsers.set("application/json", new M(!0, !1, C, this[s])), this.customParsers.set("text/plain", new M(!0, !1, C, L)), this.parserList = ["application/json", "text/plain"], this.parserRegExpList = [], this.cache = new r(100);
  }
  O.prototype.add = function(C, A, k) {
    const P = typeof C == "string";
    if (P) {
      if (C = C.trim().toLowerCase(), C.length === 0) throw new p();
    } else if (!(C instanceof RegExp))
      throw new g();
    if (typeof k != "function")
      throw new h();
    if (this.existingParser(C))
      throw new u(C);
    if (A.parseAs !== void 0 && A.parseAs !== "string" && A.parseAs !== "buffer")
      throw new b(A.parseAs);
    const D = new M(
      A.parseAs === "string",
      A.parseAs === "buffer",
      A.bodyLimit,
      k
    );
    C === "*" ? this.customParsers.set("", D) : P ? (this.parserList.unshift(C), this.customParsers.set(C, D)) : (j(C), this.parserRegExpList.unshift(C), this.customParsers.set(C.toString(), D));
  }, O.prototype.hasParser = function(C) {
    if (typeof C == "string")
      C = C.trim().toLowerCase();
    else {
      if (!(C instanceof RegExp)) throw new g();
      C = C.toString();
    }
    return this.customParsers.has(C);
  }, O.prototype.existingParser = function(C) {
    return C === "application/json" && this.customParsers.has(C) ? this.customParsers.get(C).fn !== this[s] : C === "text/plain" && this.customParsers.has(C) ? this.customParsers.get(C).fn !== L : this.hasParser(C);
  }, O.prototype.getParser = function(C) {
    let A = this.customParsers.get(C);
    if (A !== void 0 || (A = this.cache.get(C), A !== void 0)) return A;
    const k = C.toLowerCase();
    for (let P = 0; P !== this.parserList.length; ++P) {
      const D = this.parserList[P];
      if (k.slice(0, D.length) === D && (k.length === D.length || k.charCodeAt(D.length) === 59 || k.charCodeAt(D.length) === 32))
        return A = this.customParsers.get(D), this.cache.set(C, A), A;
    }
    for (let P = 0; P !== this.parserRegExpList.length; ++P) {
      const D = this.parserRegExpList[P];
      if (D.test(C))
        return A = this.customParsers.get(D.toString()), this.cache.set(C, A), A;
    }
    return this.customParsers.get("");
  }, O.prototype.removeAll = function() {
    this.customParsers = /* @__PURE__ */ new Map(), this.parserRegExpList = [], this.parserList = [], this.cache = new r(100);
  }, O.prototype.remove = function(C) {
    let A;
    if (typeof C == "string")
      C = C.trim().toLowerCase(), A = this.parserList;
    else {
      if (!(C instanceof RegExp)) throw new g();
      C = C.toString(), A = this.parserRegExpList;
    }
    const k = this.customParsers.delete(C), P = A.findIndex((D) => D.toString() === C);
    return P > -1 && A.splice(P, 1), k || P > -1;
  }, O.prototype.run = function(C, A, k, P) {
    const D = this.getParser(C);
    if (D === void 0) {
      k.is404 ? A(k, P) : P.send(new v(C || void 0));
      return;
    }
    const F = new t("content-type-parser:run", k);
    if (D.asString === !0 || D.asBuffer === !0)
      z(
        k,
        P,
        P[d]._parserOptions,
        D,
        w
      );
    else {
      const N = D.fn(k, k[a], w);
      N && typeof N.then == "function" && N.then((q) => w(null, q), w);
    }
    function w(N, q) {
      F.runInAsyncScope(() => {
        F.emitDestroy(), N ? (P[l] = !0, P.send(N)) : (k.body = q, A(k, P));
      });
    }
  };
  function z(C, A, k, P, D) {
    const F = P.asString, w = k.limit === null ? P.bodyLimit : k.limit, N = Number(C.headers["content-length"]);
    if (N > w) {
      A.header("connection", "close"), A.send(new m());
      return;
    }
    let q = 0, K = F === !0 ? "" : [];
    const V = C[a] || C.raw;
    F === !0 && V.setEncoding("utf8"), V.on("data", Z), V.on("end", Y), V.on("error", Y), V.resume();
    function Z(J) {
      q += J.length;
      const { receivedEncodedLength: H = 0 } = V;
      if (q > w || H > w) {
        V.removeListener("data", Z), V.removeListener("end", Y), V.removeListener("error", Y), A.send(new m());
        return;
      }
      F === !0 ? K += J : K.push(J);
    }
    function Y(J) {
      if (V.removeListener("data", Z), V.removeListener("end", Y), V.removeListener("error", Y), J !== void 0) {
        typeof J.statusCode == "number" && J.statusCode >= 400 || (J.statusCode = 400), A[l] = !0, A.code(J.statusCode).send(J);
        return;
      }
      if (F === !0 && (q = Buffer.byteLength(K)), !Number.isNaN(N) && (V.receivedEncodedLength || q) !== N) {
        A.header("connection", "close"), A.send(new y());
        return;
      }
      F === !1 && (K = Buffer.concat(K));
      const H = P.fn(C, K, D);
      H && typeof H.then == "function" && H.then((W) => D(null, W), D);
    }
  }
  function S(C, A) {
    return k;
    function k(P, D, F) {
      if (D.length === 0) {
        F(new _(), void 0);
        return;
      }
      try {
        F(null, n(D, { protoAction: C, constructorAction: A }));
      } catch (w) {
        w.statusCode = 400, F(w, void 0);
      }
    }
  }
  function L(C, A, k) {
    k(null, A);
  }
  function M(C, A, k, P) {
    this.asString = C, this.asBuffer = A, this.bodyLimit = k, this.fn = P;
  }
  function U(C) {
    const A = new O();
    return A[s] = C[s], A.customParsers = new Map(C.customParsers.entries()), A.parserList = C.parserList.slice(), A.parserRegExpList = C.parserRegExpList.slice(), A;
  }
  function $(C, A, k) {
    if (this[c].started)
      throw new R("addContentTypeParser");
    return typeof A == "function" && (k = A, A = {}), A || (A = {}), A.bodyLimit || (A.bodyLimit = this[o]), Array.isArray(C) ? C.forEach((P) => this[i].add(P, A, k)) : this[i].add(C, A, k), this;
  }
  function x(C) {
    return this[i].hasParser(C);
  }
  function I(C) {
    if (this[c].started)
      throw new R("removeContentTypeParser");
    if (Array.isArray(C))
      for (const A of C)
        this[i].remove(A);
    else
      this[i].remove(C);
  }
  function T() {
    if (this[c].started)
      throw new R("removeAllContentTypeParsers");
    this[i].removeAll();
  }
  function j(C) {
    C.source[0] !== "^" && C.source.includes(";?") === !1 && E(C.source);
  }
  e.exports = O, e.exports.helpers = {
    buildContentTypeParser: U,
    addContentTypeParser: $,
    hasContentTypeParser: x,
    removeContentTypeParser: I,
    removeAllContentTypeParsers: T
  }, e.exports.defaultParsers = {
    getDefaultJsonParser: S,
    defaultTextParser: L
  }, e.exports[f] = { rawBody: z };
})(Ob);
var kb = Ob.exports, fi = { exports: {} }, ya = {}, ss = { exports: {} }, ga = {}, kh = Object.prototype.hasOwnProperty;
function Lh(e, t, r) {
  for (r of e.keys())
    if (Ls(r, t)) return r;
}
function Ls(e, t) {
  var r, n, s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (e === t) return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date) return e.getTime() === t.getTime();
    if (r === RegExp) return e.toString() === t.toString();
    if (r === Array) {
      if ((n = e.length) === t.length)
<<<<<<< HEAD
        for (; n-- && Wo(e[n], t[n]); ) ;
=======
        for (; n-- && Ls(e[n], t[n]); ) ;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return n === -1;
    }
    if (r === Set) {
      if (e.size !== t.size)
        return !1;
      for (n of e)
<<<<<<< HEAD
        if (i = n, i && typeof i == "object" && (i = T0(t, i), !i) || !t.has(i)) return !1;
=======
        if (s = n, s && typeof s == "object" && (s = Lh(t, s), !s) || !t.has(s)) return !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return !0;
    }
    if (r === Map) {
      if (e.size !== t.size)
        return !1;
      for (n of e)
<<<<<<< HEAD
        if (i = n[0], i && typeof i == "object" && (i = T0(t, i), !i) || !Wo(n[1], t.get(i)))
=======
        if (s = n[0], s && typeof s == "object" && (s = Lh(t, s), !s) || !Ls(n[1], t.get(s)))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          return !1;
      return !0;
    }
    if (r === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (r === DataView) {
      if ((n = e.byteLength) === t.byteLength)
        for (; n-- && e.getInt8(n) === t.getInt8(n); ) ;
      return n === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((n = e.byteLength) === t.byteLength)
        for (; n-- && e[n] === t[n]; ) ;
      return n === -1;
    }
    if (!r || typeof e == "object") {
      n = 0;
      for (r in e)
<<<<<<< HEAD
        if ($0.call(e, r) && ++n && !$0.call(t, r) || !(r in t) || !Wo(e[r], t[r])) return !1;
=======
        if (kh.call(e, r) && ++n && !kh.call(t, r) || !(r in t) || !Ls(e[r], t[r])) return !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return Object.keys(t).length === n;
    }
  }
  return e !== e && t !== t;
}
<<<<<<< HEAD
Lu.dequal = Wo;
const { dequal: O0 } = Lu, eD = Symbol.for("json-schema-ref");
var gr, Fr, Ca, Aa, Ia, ot, ph, fl, hh, mh, Yx, gh, Jx, PS;
let tD = (PS = class {
  constructor(t = {}) {
    fi(this, ot);
    fi(this, gr);
    fi(this, Fr);
    fi(this, Ca);
    fi(this, Aa);
    fi(this, Ia);
    ts(this, gr, {}), ts(this, Fr, {}), ts(this, Ca, t.insertRefSymbol ?? !1), ts(this, Aa, t.allowEqualDuplicates ?? !0), ts(this, Ia, t.cloneSchemaWithoutRefs ?? !1);
  }
  addSchema(t, r, n = !0) {
    n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : or(this, ot, mh).call(this, t, r));
    const i = t.$id;
    i !== void 0 && typeof i == "string" && (i.charAt(0) === "#" ? or(this, ot, Yx).call(this, t, r, i) : (or(this, ot, mh).call(this, t, i), r = i));
    const s = t.$ref;
    if (s !== void 0 && typeof s == "string") {
      const { refSchemaId: o, refJsonPointer: a } = or(this, ot, ph).call(this, s, r);
      pt(this, gr)[r].refs.push({
=======
ga.dequal = Ls;
const { dequal: jh } = ga, t1 = Symbol.for("json-schema-ref");
var At, Kt, Qs, ei, ti, He, cu, fo, lu, uu, Lb, fu, jb, pv;
let r1 = (pv = class {
  constructor(t = {}) {
    Vr(this, He);
    Vr(this, At);
    Vr(this, Kt);
    Vr(this, Qs);
    Vr(this, ei);
    Vr(this, ti);
    wn(this, At, {}), wn(this, Kt, {}), wn(this, Qs, t.insertRefSymbol ?? !1), wn(this, ei, t.allowEqualDuplicates ?? !0), wn(this, ti, t.cloneSchemaWithoutRefs ?? !1);
  }
  addSchema(t, r, n = !0) {
    n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : Rt(this, He, uu).call(this, t, r));
    const s = t.$id;
    s !== void 0 && typeof s == "string" && (s.charAt(0) === "#" ? Rt(this, He, Lb).call(this, t, r, s) : (Rt(this, He, uu).call(this, t, s), r = s));
    const i = t.$ref;
    if (i !== void 0 && typeof i == "string") {
      const { refSchemaId: o, refJsonPointer: a } = Rt(this, He, cu).call(this, i, r);
      Xe(this, At)[r].refs.push({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        schemaId: o,
        jsonPointer: a
      });
    }
    for (const o in t)
      typeof t[o] == "object" && t[o] !== null && this.addSchema(t[o], r, !1);
  }
  getSchema(t, r = "#") {
<<<<<<< HEAD
    const n = pt(this, gr)[t];
=======
    const n = Xe(this, At)[t];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (n === void 0)
      throw new Error(
        `Cannot resolve ref "${t}${r}". Schema with id "${t}" is not found.`
      );
<<<<<<< HEAD
    return n.anchors[r] !== void 0 ? n.anchors[r] : P0(n.schema, r);
  }
  hasSchema(t) {
    return pt(this, gr)[t] !== void 0;
  }
  getSchemaRefs(t) {
    const r = pt(this, gr)[t];
=======
    return n.anchors[r] !== void 0 ? n.anchors[r] : Dh(n.schema, r);
  }
  hasSchema(t) {
    return Xe(this, At)[t] !== void 0;
  }
  getSchemaRefs(t) {
    const r = Xe(this, At)[t];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    return r.refs;
  }
  getSchemaDependencies(t, r = {}) {
<<<<<<< HEAD
    const n = pt(this, gr)[t];
    for (const i of n.refs) {
      const s = i.schemaId;
      s === t || r[s] !== void 0 || (r[s] = this.getSchema(s), this.getSchemaDependencies(s, r));
=======
    const n = Xe(this, At)[t];
    for (const s of n.refs) {
      const i = s.schemaId;
      i === t || r[i] !== void 0 || (r[i] = this.getSchema(i), this.getSchemaDependencies(i, r));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return r;
  }
  derefSchema(t) {
<<<<<<< HEAD
    if (pt(this, Fr)[t] !== void 0) return;
    const r = pt(this, gr)[t];
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    !pt(this, Ia) && r.refs.length === 0 && (pt(this, Fr)[t] = {
=======
    if (Xe(this, Kt)[t] !== void 0) return;
    const r = Xe(this, At)[t];
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    !Xe(this, ti) && r.refs.length === 0 && (Xe(this, Kt)[t] = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      schema: r.schema,
      anchors: r.anchors
    });
    const n = [];
<<<<<<< HEAD
    or(this, ot, fl).call(this, r.schema, t, !0, n);
    const i = this.getSchemaDependencies(t);
    for (const s in i) {
      const o = i[s];
      or(this, ot, fl).call(this, o, s, !0, n);
    }
    for (const s of n) {
      const {
        refSchemaId: o,
        refJsonPointer: a
      } = or(this, ot, ph).call(this, s.ref, s.sourceSchemaId), c = this.getDerefSchema(o, a);
      if (c === null)
        throw new Error(
          `Cannot resolve ref "${s.ref}". Ref "${a}" is not found in schema "${o}".`
        );
      s.targetSchema = c, s.targetSchemaId = o;
    }
    for (const s of n)
      or(this, ot, hh).call(this, s, n);
  }
  getDerefSchema(t, r = "#") {
    let n = pt(this, Fr)[t];
    return n === void 0 && (this.derefSchema(t), n = pt(this, Fr)[t]), n.anchors[r] !== void 0 ? n.anchors[r] : P0(n.schema, r);
  }
}, gr = new WeakMap(), Fr = new WeakMap(), Ca = new WeakMap(), Aa = new WeakMap(), Ia = new WeakMap(), ot = new WeakSet(), ph = function(t, r) {
=======
    Rt(this, He, fo).call(this, r.schema, t, !0, n);
    const s = this.getSchemaDependencies(t);
    for (const i in s) {
      const o = s[i];
      Rt(this, He, fo).call(this, o, i, !0, n);
    }
    for (const i of n) {
      const {
        refSchemaId: o,
        refJsonPointer: a
      } = Rt(this, He, cu).call(this, i.ref, i.sourceSchemaId), c = this.getDerefSchema(o, a);
      if (c === null)
        throw new Error(
          `Cannot resolve ref "${i.ref}". Ref "${a}" is not found in schema "${o}".`
        );
      i.targetSchema = c, i.targetSchemaId = o;
    }
    for (const i of n)
      Rt(this, He, lu).call(this, i, n);
  }
  getDerefSchema(t, r = "#") {
    let n = Xe(this, Kt)[t];
    return n === void 0 && (this.derefSchema(t), n = Xe(this, Kt)[t]), n.anchors[r] !== void 0 ? n.anchors[r] : Dh(n.schema, r);
  }
}, At = new WeakMap(), Kt = new WeakMap(), Qs = new WeakMap(), ei = new WeakMap(), ti = new WeakMap(), He = new WeakSet(), cu = function(t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const n = t.indexOf("#");
  return n === -1 ? { refSchemaId: t, refJsonPointer: "#" } : n === 0 ? { refSchemaId: r, refJsonPointer: t } : {
    refSchemaId: t.slice(0, n),
    refJsonPointer: t.slice(n)
  };
<<<<<<< HEAD
}, fl = function(t, r, n, i = []) {
  const s = Array.isArray(t) ? [...t] : { ...t };
  n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : or(this, ot, gh).call(this, s, r));
  const o = s.$id;
  o !== void 0 && typeof o == "string" && (o.charAt(0) === "#" ? or(this, ot, Jx).call(this, s, r, o) : (or(this, ot, gh).call(this, s, o), r = o)), s.$ref !== void 0 && i.push({
    ref: s.$ref,
    sourceSchemaId: r,
    sourceSchema: s
  });
  for (const a in s) {
    const c = s[a];
    typeof c == "object" && c !== null && (s[a] = or(this, ot, fl).call(this, c, r, !1, i));
  }
  return s;
}, hh = function(t, r) {
  const { sourceSchema: n, targetSchema: i } = t;
  if (n.$ref) {
    if (pt(this, Ca) && (n[eD] = n.$ref), delete n.$ref, i.$ref) {
      const s = r.find((o) => o.sourceSchema === i);
      or(this, ot, hh).call(this, s, r);
    }
    for (const s in i)
      if (s !== "$id") {
        if (n[s] !== void 0) {
          if (O0(n[s], i[s])) continue;
          throw new Error(
            `Cannot resolve ref "${t.ref}". Property "${s}" already exists in schema "${t.sourceSchemaId}".`
          );
        }
        n[s] = i[s];
      }
    t.isResolved = !0;
  }
}, mh = function(t, r) {
  const n = pt(this, gr)[r];
  if (n !== void 0) {
    if (pt(this, Aa) && O0(t, n.schema)) return;
    throw new Error(`There is already another schema with id "${r}".`);
  }
  pt(this, gr)[r] = { schema: t, anchors: {}, refs: [] };
}, Yx = function(t, r, n) {
  const { anchors: i } = pt(this, gr)[r];
  if (i[n] !== void 0)
    throw new Error(`There is already another anchor "${n}" in schema "${r}".`);
  i[n] = t;
}, gh = function(t, r) {
  pt(this, Fr)[r] === void 0 && (pt(this, Fr)[r] = { schema: t, anchors: {} });
}, Jx = function(t, r, n) {
  const { anchors: i } = pt(this, Fr)[r];
  i[n] = t;
}, PS);
function P0(e, t) {
  const r = t.split("/");
  let n = e;
  for (const i of r)
    if (!(i === "" || i === "#")) {
      if (typeof n != "object" || n === null)
        return null;
      n = n[i];
    }
  return n ?? null;
}
var rD = { RefResolver: tD }, yh = { exports: {} }, km = {}, Pr = {}, Ms = {}, Ba = {}, he = {}, Hs = {};
=======
}, fo = function(t, r, n, s = []) {
  const i = Array.isArray(t) ? [...t] : { ...t };
  n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : Rt(this, He, fu).call(this, i, r));
  const o = i.$id;
  o !== void 0 && typeof o == "string" && (o.charAt(0) === "#" ? Rt(this, He, jb).call(this, i, r, o) : (Rt(this, He, fu).call(this, i, o), r = o)), i.$ref !== void 0 && s.push({
    ref: i.$ref,
    sourceSchemaId: r,
    sourceSchema: i
  });
  for (const a in i) {
    const c = i[a];
    typeof c == "object" && c !== null && (i[a] = Rt(this, He, fo).call(this, c, r, !1, s));
  }
  return i;
}, lu = function(t, r) {
  const { sourceSchema: n, targetSchema: s } = t;
  if (n.$ref) {
    if (Xe(this, Qs) && (n[t1] = n.$ref), delete n.$ref, s.$ref) {
      const i = r.find((o) => o.sourceSchema === s);
      Rt(this, He, lu).call(this, i, r);
    }
    for (const i in s)
      if (i !== "$id") {
        if (n[i] !== void 0) {
          if (jh(n[i], s[i])) continue;
          throw new Error(
            `Cannot resolve ref "${t.ref}". Property "${i}" already exists in schema "${t.sourceSchemaId}".`
          );
        }
        n[i] = s[i];
      }
    t.isResolved = !0;
  }
}, uu = function(t, r) {
  const n = Xe(this, At)[r];
  if (n !== void 0) {
    if (Xe(this, ei) && jh(t, n.schema)) return;
    throw new Error(`There is already another schema with id "${r}".`);
  }
  Xe(this, At)[r] = { schema: t, anchors: {}, refs: [] };
}, Lb = function(t, r, n) {
  const { anchors: s } = Xe(this, At)[r];
  if (s[n] !== void 0)
    throw new Error(`There is already another anchor "${n}" in schema "${r}".`);
  s[n] = t;
}, fu = function(t, r) {
  Xe(this, Kt)[r] === void 0 && (Xe(this, Kt)[r] = { schema: t, anchors: {} });
}, jb = function(t, r, n) {
  const { anchors: s } = Xe(this, Kt)[r];
  s[n] = t;
}, pv);
function Dh(e, t) {
  const r = t.split("/");
  let n = e;
  for (const s of r)
    if (!(s === "" || s === "#")) {
      if (typeof n != "object" || n === null)
        return null;
      n = n[s];
    }
  return n ?? null;
}
var n1 = { RefResolver: r1 }, du = { exports: {} }, gf = {}, Ut = {}, Kn = {}, di = {}, ae = {}, Jn = {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(v) {
      if (super(), !e.IDENTIFIER.test(v))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(v) {
      super(), this._items = typeof v == "string" ? [v] : v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const v = this._items[0];
      return v === "" || v === '""';
    }
    get str() {
      var v;
<<<<<<< HEAD
      return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((y, E) => `${y}${E}`, "");
    }
    get names() {
      var v;
      return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((y, E) => (E instanceof r && (y[E.str] = (y[E.str] || 0) + 1), y), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function i(g, ...v) {
    const y = [g[0]];
    let E = 0;
    for (; E < v.length; )
      a(y, v[E]), y.push(g[++E]);
    return new n(y);
  }
  e._ = i;
  const s = new n("+");
  function o(g, ...v) {
    const y = [p(g[0])];
    let E = 0;
    for (; E < v.length; )
      y.push(s), a(y, v[E]), y.push(s, p(g[++E]));
    return c(y), new n(y);
  }
  e.str = o;
  function a(g, v) {
    v instanceof n ? g.push(...v._items) : v instanceof r ? g.push(v) : g.push(f(v));
  }
  e.addCodeArg = a;
  function c(g) {
    let v = 1;
    for (; v < g.length - 1; ) {
      if (g[v] === s) {
        const y = u(g[v - 1], g[v + 1]);
        if (y !== void 0) {
          g.splice(v - 1, 3, y);
          continue;
        }
        g[v++] = "+";
=======
      return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((y, _) => `${y}${_}`, "");
    }
    get names() {
      var v;
      return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((y, _) => (_ instanceof r && (y[_.str] = (y[_.str] || 0) + 1), y), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function s(m, ...v) {
    const y = [m[0]];
    let _ = 0;
    for (; _ < v.length; )
      a(y, v[_]), y.push(m[++_]);
    return new n(y);
  }
  e._ = s;
  const i = new n("+");
  function o(m, ...v) {
    const y = [p(m[0])];
    let _ = 0;
    for (; _ < v.length; )
      y.push(i), a(y, v[_]), y.push(i, p(m[++_]));
    return c(y), new n(y);
  }
  e.str = o;
  function a(m, v) {
    v instanceof n ? m.push(...v._items) : v instanceof r ? m.push(v) : m.push(d(v));
  }
  e.addCodeArg = a;
  function c(m) {
    let v = 1;
    for (; v < m.length - 1; ) {
      if (m[v] === i) {
        const y = f(m[v - 1], m[v + 1]);
        if (y !== void 0) {
          m.splice(v - 1, 3, y);
          continue;
        }
        m[v++] = "+";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      v++;
    }
  }
<<<<<<< HEAD
  function u(g, v) {
    if (v === '""')
      return g;
    if (g === '""')
      return v;
    if (typeof g == "string")
      return v instanceof r || g[g.length - 1] !== '"' ? void 0 : typeof v != "string" ? `${g.slice(0, -1)}${v}"` : v[0] === '"' ? g.slice(0, -1) + v.slice(1) : void 0;
    if (typeof v == "string" && v[0] === '"' && !(g instanceof r))
      return `"${g}${v.slice(1)}`;
  }
  function l(g, v) {
    return v.emptyStr() ? g : g.emptyStr() ? v : o`${g}${v}`;
  }
  e.strConcat = l;
  function f(g) {
    return typeof g == "number" || typeof g == "boolean" || g === null ? g : p(Array.isArray(g) ? g.join(",") : g);
  }
  function m(g) {
    return new n(p(g));
  }
  e.stringify = m;
  function p(g) {
    return JSON.stringify(g).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function d(g) {
    return typeof g == "string" && e.IDENTIFIER.test(g) ? new n(`.${g}`) : i`[${g}]`;
  }
  e.getProperty = d;
  function h(g) {
    if (typeof g == "string" && e.IDENTIFIER.test(g))
      return new n(`${g}`);
    throw new Error(`CodeGen: invalid export name: ${g}, use explicit $id name mapping`);
  }
  e.getEsmExportName = h;
  function _(g) {
    return new n(g.toString());
  }
  e.regexpCode = _;
})(Hs);
var Ul = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = Hs;
  class r extends Error {
    constructor(u) {
      super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
=======
  function f(m, v) {
    if (v === '""')
      return m;
    if (m === '""')
      return v;
    if (typeof m == "string")
      return v instanceof r || m[m.length - 1] !== '"' ? void 0 : typeof v != "string" ? `${m.slice(0, -1)}${v}"` : v[0] === '"' ? m.slice(0, -1) + v.slice(1) : void 0;
    if (typeof v == "string" && v[0] === '"' && !(m instanceof r))
      return `"${m}${v.slice(1)}`;
  }
  function l(m, v) {
    return v.emptyStr() ? m : m.emptyStr() ? v : o`${m}${v}`;
  }
  e.strConcat = l;
  function d(m) {
    return typeof m == "number" || typeof m == "boolean" || m === null ? m : p(Array.isArray(m) ? m.join(",") : m);
  }
  function g(m) {
    return new n(p(m));
  }
  e.stringify = g;
  function p(m) {
    return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function u(m) {
    return typeof m == "string" && e.IDENTIFIER.test(m) ? new n(`.${m}`) : s`[${m}]`;
  }
  e.getProperty = u;
  function h(m) {
    if (typeof m == "string" && e.IDENTIFIER.test(m))
      return new n(`${m}`);
    throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`);
  }
  e.getEsmExportName = h;
  function b(m) {
    return new n(m.toString());
  }
  e.regexpCode = b;
})(Jn);
var jo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = Jn;
  class r extends Error {
    constructor(f) {
      super(`CodeGen: "code" for ${f} not defined`), this.value = f.value;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  }
  var n;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(n || (e.UsedValueState = n = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
<<<<<<< HEAD
  class i {
    constructor({ prefixes: u, parent: l } = {}) {
      this._names = {}, this._prefixes = u, this._parent = l;
    }
    toName(u) {
      return u instanceof t.Name ? u : this.name(u);
    }
    name(u) {
      return new t.Name(this._newName(u));
    }
    _newName(u) {
      const l = this._names[u] || this._nameGroup(u);
      return `${u}${l.index++}`;
    }
    _nameGroup(u) {
      var l, f;
      if (!((f = (l = this._parent) === null || l === void 0 ? void 0 : l._prefixes) === null || f === void 0) && f.has(u) || this._prefixes && !this._prefixes.has(u))
        throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
      return this._names[u] = { prefix: u, index: 0 };
    }
  }
  e.Scope = i;
  class s extends t.Name {
    constructor(u, l) {
      super(l), this.prefix = u;
    }
    setValue(u, { property: l, itemIndex: f }) {
      this.value = u, this.scopePath = (0, t._)`.${new t.Name(l)}[${f}]`;
    }
  }
  e.ValueScopeName = s;
  const o = (0, t._)`\n`;
  class a extends i {
    constructor(u) {
      super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? o : t.nil };
=======
  class s {
    constructor({ prefixes: f, parent: l } = {}) {
      this._names = {}, this._prefixes = f, this._parent = l;
    }
    toName(f) {
      return f instanceof t.Name ? f : this.name(f);
    }
    name(f) {
      return new t.Name(this._newName(f));
    }
    _newName(f) {
      const l = this._names[f] || this._nameGroup(f);
      return `${f}${l.index++}`;
    }
    _nameGroup(f) {
      var l, d;
      if (!((d = (l = this._parent) === null || l === void 0 ? void 0 : l._prefixes) === null || d === void 0) && d.has(f) || this._prefixes && !this._prefixes.has(f))
        throw new Error(`CodeGen: prefix "${f}" is not allowed in this scope`);
      return this._names[f] = { prefix: f, index: 0 };
    }
  }
  e.Scope = s;
  class i extends t.Name {
    constructor(f, l) {
      super(l), this.prefix = f;
    }
    setValue(f, { property: l, itemIndex: d }) {
      this.value = f, this.scopePath = (0, t._)`.${new t.Name(l)}[${d}]`;
    }
  }
  e.ValueScopeName = i;
  const o = (0, t._)`\n`;
  class a extends s {
    constructor(f) {
      super(f), this._values = {}, this._scope = f.scope, this.opts = { ...f, _n: f.lines ? o : t.nil };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    get() {
      return this._scope;
    }
<<<<<<< HEAD
    name(u) {
      return new s(u, this._newName(u));
    }
    value(u, l) {
      var f;
      if (l.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const m = this.toName(u), { prefix: p } = m, d = (f = l.key) !== null && f !== void 0 ? f : l.ref;
      let h = this._values[p];
      if (h) {
        const v = h.get(d);
=======
    name(f) {
      return new i(f, this._newName(f));
    }
    value(f, l) {
      var d;
      if (l.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const g = this.toName(f), { prefix: p } = g, u = (d = l.key) !== null && d !== void 0 ? d : l.ref;
      let h = this._values[p];
      if (h) {
        const v = h.get(u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        if (v)
          return v;
      } else
        h = this._values[p] = /* @__PURE__ */ new Map();
<<<<<<< HEAD
      h.set(d, m);
      const _ = this._scope[p] || (this._scope[p] = []), g = _.length;
      return _[g] = l.ref, m.setValue(l, { property: p, itemIndex: g }), m;
    }
    getValue(u, l) {
      const f = this._values[u];
      if (f)
        return f.get(l);
    }
    scopeRefs(u, l = this._values) {
      return this._reduceValues(l, (f) => {
        if (f.scopePath === void 0)
          throw new Error(`CodeGen: name "${f}" has no value`);
        return (0, t._)`${u}${f.scopePath}`;
      });
    }
    scopeCode(u = this._values, l, f) {
      return this._reduceValues(u, (m) => {
        if (m.value === void 0)
          throw new Error(`CodeGen: name "${m}" has no value`);
        return m.value.code;
      }, l, f);
    }
    _reduceValues(u, l, f = {}, m) {
      let p = t.nil;
      for (const d in u) {
        const h = u[d];
        if (!h)
          continue;
        const _ = f[d] = f[d] || /* @__PURE__ */ new Map();
        h.forEach((g) => {
          if (_.has(g))
            return;
          _.set(g, n.Started);
          let v = l(g);
          if (v) {
            const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${y} ${g} = ${v};${this.opts._n}`;
          } else if (v = m == null ? void 0 : m(g))
            p = (0, t._)`${p}${v}${this.opts._n}`;
          else
            throw new r(g);
          _.set(g, n.Completed);
=======
      h.set(u, g);
      const b = this._scope[p] || (this._scope[p] = []), m = b.length;
      return b[m] = l.ref, g.setValue(l, { property: p, itemIndex: m }), g;
    }
    getValue(f, l) {
      const d = this._values[f];
      if (d)
        return d.get(l);
    }
    scopeRefs(f, l = this._values) {
      return this._reduceValues(l, (d) => {
        if (d.scopePath === void 0)
          throw new Error(`CodeGen: name "${d}" has no value`);
        return (0, t._)`${f}${d.scopePath}`;
      });
    }
    scopeCode(f = this._values, l, d) {
      return this._reduceValues(f, (g) => {
        if (g.value === void 0)
          throw new Error(`CodeGen: name "${g}" has no value`);
        return g.value.code;
      }, l, d);
    }
    _reduceValues(f, l, d = {}, g) {
      let p = t.nil;
      for (const u in f) {
        const h = f[u];
        if (!h)
          continue;
        const b = d[u] = d[u] || /* @__PURE__ */ new Map();
        h.forEach((m) => {
          if (b.has(m))
            return;
          b.set(m, n.Started);
          let v = l(m);
          if (v) {
            const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${y} ${m} = ${v};${this.opts._n}`;
          } else if (v = g == null ? void 0 : g(m))
            p = (0, t._)`${p}${v}${this.opts._n}`;
          else
            throw new r(m);
          b.set(m, n.Completed);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      }
      return p;
    }
  }
  e.ValueScope = a;
<<<<<<< HEAD
})(Ul);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = Hs, r = Ul;
  var n = Hs;
=======
})(jo);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = Jn, r = jo;
  var n = Jn;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
<<<<<<< HEAD
  var i = Ul;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return i.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return i.varKinds;
=======
  var s = jo;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return s.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return s.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return s.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return s.varKinds;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
<<<<<<< HEAD
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(T, N) {
      return this;
    }
  }
  class o extends s {
    constructor(T, N, G) {
      super(), this.varKind = T, this.name = N, this.rhs = G;
    }
    render({ es5: T, _n: N }) {
      const G = T ? r.varKinds.var : this.varKind, O = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${G} ${this.name}${O};` + N;
    }
    optimizeNames(T, N) {
      if (T[this.name.str])
        return this.rhs && (this.rhs = x(this.rhs, T, N)), this;
=======
  class i {
    optimizeNodes() {
      return this;
    }
    optimizeNames(w, N) {
      return this;
    }
  }
  class o extends i {
    constructor(w, N, q) {
      super(), this.varKind = w, this.name = N, this.rhs = q;
    }
    render({ es5: w, _n: N }) {
      const q = w ? r.varKinds.var : this.varKind, K = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${q} ${this.name}${K};` + N;
    }
    optimizeNames(w, N) {
      if (w[this.name.str])
        return this.rhs && (this.rhs = x(this.rhs, w, N)), this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
<<<<<<< HEAD
  class a extends s {
    constructor(T, N, G) {
      super(), this.lhs = T, this.rhs = N, this.sideEffects = G;
    }
    render({ _n: T }) {
      return `${this.lhs} = ${this.rhs};` + T;
    }
    optimizeNames(T, N) {
      if (!(this.lhs instanceof t.Name && !T[this.lhs.str] && !this.sideEffects))
        return this.rhs = x(this.rhs, T, N), this;
    }
    get names() {
      const T = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return $(T, this.rhs);
    }
  }
  class c extends a {
    constructor(T, N, G, O) {
      super(T, G, O), this.op = N;
    }
    render({ _n: T }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + T;
    }
  }
  class u extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `${this.label}:` + T;
    }
  }
  class l extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `break${this.label ? ` ${this.label}` : ""};` + T;
    }
  }
  class f extends s {
    constructor(T) {
      super(), this.error = T;
    }
    render({ _n: T }) {
      return `throw ${this.error};` + T;
=======
  class a extends i {
    constructor(w, N, q) {
      super(), this.lhs = w, this.rhs = N, this.sideEffects = q;
    }
    render({ _n: w }) {
      return `${this.lhs} = ${this.rhs};` + w;
    }
    optimizeNames(w, N) {
      if (!(this.lhs instanceof t.Name && !w[this.lhs.str] && !this.sideEffects))
        return this.rhs = x(this.rhs, w, N), this;
    }
    get names() {
      const w = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return $(w, this.rhs);
    }
  }
  class c extends a {
    constructor(w, N, q, K) {
      super(w, q, K), this.op = N;
    }
    render({ _n: w }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + w;
    }
  }
  class f extends i {
    constructor(w) {
      super(), this.label = w, this.names = {};
    }
    render({ _n: w }) {
      return `${this.label}:` + w;
    }
  }
  class l extends i {
    constructor(w) {
      super(), this.label = w, this.names = {};
    }
    render({ _n: w }) {
      return `break${this.label ? ` ${this.label}` : ""};` + w;
    }
  }
  class d extends i {
    constructor(w) {
      super(), this.error = w;
    }
    render({ _n: w }) {
      return `throw ${this.error};` + w;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    get names() {
      return this.error.names;
    }
  }
<<<<<<< HEAD
  class m extends s {
    constructor(T) {
      super(), this.code = T;
    }
    render({ _n: T }) {
      return `${this.code};` + T;
=======
  class g extends i {
    constructor(w) {
      super(), this.code = w;
    }
    render({ _n: w }) {
      return `${this.code};` + w;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
<<<<<<< HEAD
    optimizeNames(T, N) {
      return this.code = x(this.code, T, N), this;
=======
    optimizeNames(w, N) {
      return this.code = x(this.code, w, N), this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
<<<<<<< HEAD
  class p extends s {
    constructor(T = []) {
      super(), this.nodes = T;
    }
    render(T) {
      return this.nodes.reduce((N, G) => N + G.render(T), "");
    }
    optimizeNodes() {
      const { nodes: T } = this;
      let N = T.length;
      for (; N--; ) {
        const G = T[N].optimizeNodes();
        Array.isArray(G) ? T.splice(N, 1, ...G) : G ? T[N] = G : T.splice(N, 1);
      }
      return T.length > 0 ? this : void 0;
    }
    optimizeNames(T, N) {
      const { nodes: G } = this;
      let O = G.length;
      for (; O--; ) {
        const S = G[O];
        S.optimizeNames(T, N) || (A(T, S.names), G.splice(O, 1));
      }
      return G.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((T, N) => q(T, N.names), {});
    }
  }
  class d extends p {
    render(T) {
      return "{" + T._n + super.render(T) + "}" + T._n;
=======
  class p extends i {
    constructor(w = []) {
      super(), this.nodes = w;
    }
    render(w) {
      return this.nodes.reduce((N, q) => N + q.render(w), "");
    }
    optimizeNodes() {
      const { nodes: w } = this;
      let N = w.length;
      for (; N--; ) {
        const q = w[N].optimizeNodes();
        Array.isArray(q) ? w.splice(N, 1, ...q) : q ? w[N] = q : w.splice(N, 1);
      }
      return w.length > 0 ? this : void 0;
    }
    optimizeNames(w, N) {
      const { nodes: q } = this;
      let K = q.length;
      for (; K--; ) {
        const V = q[K];
        V.optimizeNames(w, N) || (I(w, V.names), q.splice(K, 1));
      }
      return q.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((w, N) => U(w, N.names), {});
    }
  }
  class u extends p {
    render(w) {
      return "{" + w._n + super.render(w) + "}" + w._n;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  }
  class h extends p {
  }
<<<<<<< HEAD
  class _ extends d {
  }
  _.kind = "else";
  class g extends d {
    constructor(T, N) {
      super(N), this.condition = T;
    }
    render(T) {
      let N = `if(${this.condition})` + super.render(T);
      return this.else && (N += "else " + this.else.render(T)), N;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const T = this.condition;
      if (T === !0)
        return this.nodes;
      let N = this.else;
      if (N) {
        const G = N.optimizeNodes();
        N = this.else = Array.isArray(G) ? new _(G) : G;
      }
      if (N)
        return T === !1 ? N instanceof g ? N : N.nodes : this.nodes.length ? this : new g(P(T), N instanceof g ? [N] : N.nodes);
      if (!(T === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(T, N) {
      var G;
      if (this.else = (G = this.else) === null || G === void 0 ? void 0 : G.optimizeNames(T, N), !!(super.optimizeNames(T, N) || this.else))
        return this.condition = x(this.condition, T, N), this;
    }
    get names() {
      const T = super.names;
      return $(T, this.condition), this.else && q(T, this.else.names), T;
    }
  }
  g.kind = "if";
  class v extends d {
  }
  v.kind = "for";
  class y extends v {
    constructor(T) {
      super(), this.iteration = T;
    }
    render(T) {
      return `for(${this.iteration})` + super.render(T);
    }
    optimizeNames(T, N) {
      if (super.optimizeNames(T, N))
        return this.iteration = x(this.iteration, T, N), this;
    }
    get names() {
      return q(super.names, this.iteration.names);
    }
  }
  class E extends v {
    constructor(T, N, G, O) {
      super(), this.varKind = T, this.name = N, this.from = G, this.to = O;
    }
    render(T) {
      const N = T.es5 ? r.varKinds.var : this.varKind, { name: G, from: O, to: S } = this;
      return `for(${N} ${G}=${O}; ${G}<${S}; ${G}++)` + super.render(T);
    }
    get names() {
      const T = $(super.names, this.from);
      return $(T, this.to);
    }
  }
  class R extends v {
    constructor(T, N, G, O) {
      super(), this.loop = T, this.varKind = N, this.name = G, this.iterable = O;
    }
    render(T) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(T);
    }
    optimizeNames(T, N) {
      if (super.optimizeNames(T, N))
        return this.iterable = x(this.iterable, T, N), this;
    }
    get names() {
      return q(super.names, this.iterable.names);
    }
  }
  class w extends d {
    constructor(T, N, G) {
      super(), this.name = T, this.args = N, this.async = G;
    }
    render(T) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(T);
    }
  }
  w.kind = "func";
  class C extends p {
    render(T) {
      return "return " + super.render(T);
    }
  }
  C.kind = "return";
  class V extends d {
    render(T) {
      let N = "try" + super.render(T);
      return this.catch && (N += this.catch.render(T)), this.finally && (N += this.finally.render(T)), N;
    }
    optimizeNodes() {
      var T, N;
      return super.optimizeNodes(), (T = this.catch) === null || T === void 0 || T.optimizeNodes(), (N = this.finally) === null || N === void 0 || N.optimizeNodes(), this;
    }
    optimizeNames(T, N) {
      var G, O;
      return super.optimizeNames(T, N), (G = this.catch) === null || G === void 0 || G.optimizeNames(T, N), (O = this.finally) === null || O === void 0 || O.optimizeNames(T, N), this;
    }
    get names() {
      const T = super.names;
      return this.catch && q(T, this.catch.names), this.finally && q(T, this.finally.names), T;
    }
  }
  class b extends d {
    constructor(T) {
      super(), this.error = T;
    }
    render(T) {
      return `catch(${this.error})` + super.render(T);
    }
  }
  b.kind = "catch";
  class F extends d {
    render(T) {
      return "finally" + super.render(T);
    }
  }
  F.kind = "finally";
  class H {
    constructor(T, N = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...N, _n: N.lines ? `
` : "" }, this._extScope = T, this._scope = new r.Scope({ parent: T }), this._nodes = [new h()];
=======
  class b extends u {
  }
  b.kind = "else";
  class m extends u {
    constructor(w, N) {
      super(N), this.condition = w;
    }
    render(w) {
      let N = `if(${this.condition})` + super.render(w);
      return this.else && (N += "else " + this.else.render(w)), N;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const w = this.condition;
      if (w === !0)
        return this.nodes;
      let N = this.else;
      if (N) {
        const q = N.optimizeNodes();
        N = this.else = Array.isArray(q) ? new b(q) : q;
      }
      if (N)
        return w === !1 ? N instanceof m ? N : N.nodes : this.nodes.length ? this : new m(T(w), N instanceof m ? [N] : N.nodes);
      if (!(w === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(w, N) {
      var q;
      if (this.else = (q = this.else) === null || q === void 0 ? void 0 : q.optimizeNames(w, N), !!(super.optimizeNames(w, N) || this.else))
        return this.condition = x(this.condition, w, N), this;
    }
    get names() {
      const w = super.names;
      return $(w, this.condition), this.else && U(w, this.else.names), w;
    }
  }
  m.kind = "if";
  class v extends u {
  }
  v.kind = "for";
  class y extends v {
    constructor(w) {
      super(), this.iteration = w;
    }
    render(w) {
      return `for(${this.iteration})` + super.render(w);
    }
    optimizeNames(w, N) {
      if (super.optimizeNames(w, N))
        return this.iteration = x(this.iteration, w, N), this;
    }
    get names() {
      return U(super.names, this.iteration.names);
    }
  }
  class _ extends v {
    constructor(w, N, q, K) {
      super(), this.varKind = w, this.name = N, this.from = q, this.to = K;
    }
    render(w) {
      const N = w.es5 ? r.varKinds.var : this.varKind, { name: q, from: K, to: V } = this;
      return `for(${N} ${q}=${K}; ${q}<${V}; ${q}++)` + super.render(w);
    }
    get names() {
      const w = $(super.names, this.from);
      return $(w, this.to);
    }
  }
  class R extends v {
    constructor(w, N, q, K) {
      super(), this.loop = w, this.varKind = N, this.name = q, this.iterable = K;
    }
    render(w) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(w);
    }
    optimizeNames(w, N) {
      if (super.optimizeNames(w, N))
        return this.iterable = x(this.iterable, w, N), this;
    }
    get names() {
      return U(super.names, this.iterable.names);
    }
  }
  class E extends u {
    constructor(w, N, q) {
      super(), this.name = w, this.args = N, this.async = q;
    }
    render(w) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(w);
    }
  }
  E.kind = "func";
  class O extends p {
    render(w) {
      return "return " + super.render(w);
    }
  }
  O.kind = "return";
  class z extends u {
    render(w) {
      let N = "try" + super.render(w);
      return this.catch && (N += this.catch.render(w)), this.finally && (N += this.finally.render(w)), N;
    }
    optimizeNodes() {
      var w, N;
      return super.optimizeNodes(), (w = this.catch) === null || w === void 0 || w.optimizeNodes(), (N = this.finally) === null || N === void 0 || N.optimizeNodes(), this;
    }
    optimizeNames(w, N) {
      var q, K;
      return super.optimizeNames(w, N), (q = this.catch) === null || q === void 0 || q.optimizeNames(w, N), (K = this.finally) === null || K === void 0 || K.optimizeNames(w, N), this;
    }
    get names() {
      const w = super.names;
      return this.catch && U(w, this.catch.names), this.finally && U(w, this.finally.names), w;
    }
  }
  class S extends u {
    constructor(w) {
      super(), this.error = w;
    }
    render(w) {
      return `catch(${this.error})` + super.render(w);
    }
  }
  S.kind = "catch";
  class L extends u {
    render(w) {
      return "finally" + super.render(w);
    }
  }
  L.kind = "finally";
  class M {
    constructor(w, N = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...N, _n: N.lines ? `
` : "" }, this._extScope = w, this._scope = new r.Scope({ parent: w }), this._nodes = [new h()];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
<<<<<<< HEAD
    name(T) {
      return this._scope.name(T);
    }
    // reserves unique name in the external scope
    scopeName(T) {
      return this._extScope.name(T);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(T, N) {
      const G = this._extScope.value(T, N);
      return (this._values[G.prefix] || (this._values[G.prefix] = /* @__PURE__ */ new Set())).add(G), G;
    }
    getScopeValue(T, N) {
      return this._extScope.getValue(T, N);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(T) {
      return this._extScope.scopeRefs(T, this._values);
=======
    name(w) {
      return this._scope.name(w);
    }
    // reserves unique name in the external scope
    scopeName(w) {
      return this._extScope.name(w);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(w, N) {
      const q = this._extScope.value(w, N);
      return (this._values[q.prefix] || (this._values[q.prefix] = /* @__PURE__ */ new Set())).add(q), q;
    }
    getScopeValue(w, N) {
      return this._extScope.getValue(w, N);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(w) {
      return this._extScope.scopeRefs(w, this._values);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
<<<<<<< HEAD
    _def(T, N, G, O) {
      const S = this._scope.toName(N);
      return G !== void 0 && O && (this._constants[S.str] = G), this._leafNode(new o(T, S, G)), S;
    }
    // `const` declaration (`var` in es5 mode)
    const(T, N, G) {
      return this._def(r.varKinds.const, T, N, G);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(T, N, G) {
      return this._def(r.varKinds.let, T, N, G);
    }
    // `var` declaration with optional assignment
    var(T, N, G) {
      return this._def(r.varKinds.var, T, N, G);
    }
    // assignment code
    assign(T, N, G) {
      return this._leafNode(new a(T, N, G));
    }
    // `+=` code
    add(T, N) {
      return this._leafNode(new c(T, e.operators.ADD, N));
    }
    // appends passed SafeExpr to code or executes Block
    code(T) {
      return typeof T == "function" ? T() : T !== t.nil && this._leafNode(new m(T)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...T) {
      const N = ["{"];
      for (const [G, O] of T)
        N.length > 1 && N.push(","), N.push(G), (G !== O || this.opts.es5) && (N.push(":"), (0, t.addCodeArg)(N, O));
      return N.push("}"), new t._Code(N);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(T, N, G) {
      if (this._blockNode(new g(T)), N && G)
        this.code(N).else().code(G).endIf();
      else if (N)
        this.code(N).endIf();
      else if (G)
=======
    _def(w, N, q, K) {
      const V = this._scope.toName(N);
      return q !== void 0 && K && (this._constants[V.str] = q), this._leafNode(new o(w, V, q)), V;
    }
    // `const` declaration (`var` in es5 mode)
    const(w, N, q) {
      return this._def(r.varKinds.const, w, N, q);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(w, N, q) {
      return this._def(r.varKinds.let, w, N, q);
    }
    // `var` declaration with optional assignment
    var(w, N, q) {
      return this._def(r.varKinds.var, w, N, q);
    }
    // assignment code
    assign(w, N, q) {
      return this._leafNode(new a(w, N, q));
    }
    // `+=` code
    add(w, N) {
      return this._leafNode(new c(w, e.operators.ADD, N));
    }
    // appends passed SafeExpr to code or executes Block
    code(w) {
      return typeof w == "function" ? w() : w !== t.nil && this._leafNode(new g(w)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...w) {
      const N = ["{"];
      for (const [q, K] of w)
        N.length > 1 && N.push(","), N.push(q), (q !== K || this.opts.es5) && (N.push(":"), (0, t.addCodeArg)(N, K));
      return N.push("}"), new t._Code(N);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(w, N, q) {
      if (this._blockNode(new m(w)), N && q)
        this.code(N).else().code(q).endIf();
      else if (N)
        this.code(N).endIf();
      else if (q)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
<<<<<<< HEAD
    elseIf(T) {
      return this._elseNode(new g(T));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new _());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(g, _);
    }
    _for(T, N) {
      return this._blockNode(T), N && this.code(N).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(T, N) {
      return this._for(new y(T), N);
    }
    // `for` statement for a range of values
    forRange(T, N, G, O, S = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const W = this._scope.toName(T);
      return this._for(new E(S, W, N, G), () => O(W));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(T, N, G, O = r.varKinds.const) {
      const S = this._scope.toName(T);
      if (this.opts.es5) {
        const W = N instanceof t.Name ? N : this.var("_arr", N);
        return this.forRange("_i", 0, (0, t._)`${W}.length`, (z) => {
          this.var(S, (0, t._)`${W}[${z}]`), G(S);
        });
      }
      return this._for(new R("of", O, S, N), () => G(S));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(T, N, G, O = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(T, (0, t._)`Object.keys(${N})`, G);
      const S = this._scope.toName(T);
      return this._for(new R("in", O, S, N), () => G(S));
=======
    elseIf(w) {
      return this._elseNode(new m(w));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new b());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(m, b);
    }
    _for(w, N) {
      return this._blockNode(w), N && this.code(N).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(w, N) {
      return this._for(new y(w), N);
    }
    // `for` statement for a range of values
    forRange(w, N, q, K, V = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Z = this._scope.toName(w);
      return this._for(new _(V, Z, N, q), () => K(Z));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(w, N, q, K = r.varKinds.const) {
      const V = this._scope.toName(w);
      if (this.opts.es5) {
        const Z = N instanceof t.Name ? N : this.var("_arr", N);
        return this.forRange("_i", 0, (0, t._)`${Z}.length`, (Y) => {
          this.var(V, (0, t._)`${Z}[${Y}]`), q(V);
        });
      }
      return this._for(new R("of", K, V, N), () => q(V));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(w, N, q, K = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(w, (0, t._)`Object.keys(${N})`, q);
      const V = this._scope.toName(w);
      return this._for(new R("in", K, V, N), () => q(V));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(v);
    }
    // `label` statement
<<<<<<< HEAD
    label(T) {
      return this._leafNode(new u(T));
    }
    // `break` statement
    break(T) {
      return this._leafNode(new l(T));
    }
    // `return` statement
    return(T) {
      const N = new C();
      if (this._blockNode(N), this.code(T), N.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(C);
    }
    // `try` statement
    try(T, N, G) {
      if (!N && !G)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const O = new V();
      if (this._blockNode(O), this.code(T), N) {
        const S = this.name("e");
        this._currNode = O.catch = new b(S), N(S);
      }
      return G && (this._currNode = O.finally = new F(), this.code(G)), this._endBlockNode(b, F);
    }
    // `throw` statement
    throw(T) {
      return this._leafNode(new f(T));
    }
    // start self-balancing block
    block(T, N) {
      return this._blockStarts.push(this._nodes.length), T && this.code(T).endBlock(N), this;
    }
    // end the current self-balancing block
    endBlock(T) {
      const N = this._blockStarts.pop();
      if (N === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const G = this._nodes.length - N;
      if (G < 0 || T !== void 0 && G !== T)
        throw new Error(`CodeGen: wrong number of nodes: ${G} vs ${T} expected`);
      return this._nodes.length = N, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(T, N = t.nil, G, O) {
      return this._blockNode(new w(T, N, G)), O && this.code(O).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(w);
    }
    optimize(T = 1) {
      for (; T-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(T) {
      return this._currNode.nodes.push(T), this;
    }
    _blockNode(T) {
      this._currNode.nodes.push(T), this._nodes.push(T);
    }
    _endBlockNode(T, N) {
      const G = this._currNode;
      if (G instanceof T || N && G instanceof N)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${N ? `${T.kind}/${N.kind}` : T.kind}"`);
    }
    _elseNode(T) {
      const N = this._currNode;
      if (!(N instanceof g))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = N.else = T, this;
=======
    label(w) {
      return this._leafNode(new f(w));
    }
    // `break` statement
    break(w) {
      return this._leafNode(new l(w));
    }
    // `return` statement
    return(w) {
      const N = new O();
      if (this._blockNode(N), this.code(w), N.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(O);
    }
    // `try` statement
    try(w, N, q) {
      if (!N && !q)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const K = new z();
      if (this._blockNode(K), this.code(w), N) {
        const V = this.name("e");
        this._currNode = K.catch = new S(V), N(V);
      }
      return q && (this._currNode = K.finally = new L(), this.code(q)), this._endBlockNode(S, L);
    }
    // `throw` statement
    throw(w) {
      return this._leafNode(new d(w));
    }
    // start self-balancing block
    block(w, N) {
      return this._blockStarts.push(this._nodes.length), w && this.code(w).endBlock(N), this;
    }
    // end the current self-balancing block
    endBlock(w) {
      const N = this._blockStarts.pop();
      if (N === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const q = this._nodes.length - N;
      if (q < 0 || w !== void 0 && q !== w)
        throw new Error(`CodeGen: wrong number of nodes: ${q} vs ${w} expected`);
      return this._nodes.length = N, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(w, N = t.nil, q, K) {
      return this._blockNode(new E(w, N, q)), K && this.code(K).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(E);
    }
    optimize(w = 1) {
      for (; w-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(w) {
      return this._currNode.nodes.push(w), this;
    }
    _blockNode(w) {
      this._currNode.nodes.push(w), this._nodes.push(w);
    }
    _endBlockNode(w, N) {
      const q = this._currNode;
      if (q instanceof w || N && q instanceof N)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${N ? `${w.kind}/${N.kind}` : w.kind}"`);
    }
    _elseNode(w) {
      const N = this._currNode;
      if (!(N instanceof m))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = N.else = w, this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
<<<<<<< HEAD
      const T = this._nodes;
      return T[T.length - 1];
    }
    set _currNode(T) {
      const N = this._nodes;
      N[N.length - 1] = T;
    }
  }
  e.CodeGen = H;
  function q(M, T) {
    for (const N in T)
      M[N] = (M[N] || 0) + (T[N] || 0);
    return M;
  }
  function $(M, T) {
    return T instanceof t._CodeOrName ? q(M, T.names) : M;
  }
  function x(M, T, N) {
    if (M instanceof t.Name)
      return G(M);
    if (!O(M))
      return M;
    return new t._Code(M._items.reduce((S, W) => (W instanceof t.Name && (W = G(W)), W instanceof t._Code ? S.push(...W._items) : S.push(W), S), []));
    function G(S) {
      const W = N[S.str];
      return W === void 0 || T[S.str] !== 1 ? S : (delete T[S.str], W);
    }
    function O(S) {
      return S instanceof t._Code && S._items.some((W) => W instanceof t.Name && T[W.str] === 1 && N[W.str] !== void 0);
    }
  }
  function A(M, T) {
    for (const N in T)
      M[N] = (M[N] || 0) - (T[N] || 0);
  }
  function P(M) {
    return typeof M == "boolean" || typeof M == "number" || M === null ? !M : (0, t._)`!${U(M)}`;
  }
  e.not = P;
  const D = k(e.operators.AND);
  function I(...M) {
    return M.reduce(D);
  }
  e.and = I;
  const L = k(e.operators.OR);
  function j(...M) {
    return M.reduce(L);
  }
  e.or = j;
  function k(M) {
    return (T, N) => T === t.nil ? N : N === t.nil ? T : (0, t._)`${U(T)} ${M} ${U(N)}`;
  }
  function U(M) {
    return M instanceof t.Name ? M : (0, t._)`(${M})`;
  }
})(he);
var se = {};
Object.defineProperty(se, "__esModule", { value: !0 });
se.checkStrictMode = se.getErrorPath = se.Type = se.useFunc = se.setEvaluated = se.evaluatedPropsToName = se.mergeEvaluated = se.eachItem = se.unescapeJsonPointer = se.escapeJsonPointer = se.escapeFragment = se.unescapeFragment = se.schemaRefOrVal = se.schemaHasRulesButRef = se.schemaHasRules = se.checkUnknownRules = se.alwaysValidSchema = se.toHash = void 0;
const Ue = he, nD = Hs;
function iD(e) {
=======
      const w = this._nodes;
      return w[w.length - 1];
    }
    set _currNode(w) {
      const N = this._nodes;
      N[N.length - 1] = w;
    }
  }
  e.CodeGen = M;
  function U(F, w) {
    for (const N in w)
      F[N] = (F[N] || 0) + (w[N] || 0);
    return F;
  }
  function $(F, w) {
    return w instanceof t._CodeOrName ? U(F, w.names) : F;
  }
  function x(F, w, N) {
    if (F instanceof t.Name)
      return q(F);
    if (!K(F))
      return F;
    return new t._Code(F._items.reduce((V, Z) => (Z instanceof t.Name && (Z = q(Z)), Z instanceof t._Code ? V.push(...Z._items) : V.push(Z), V), []));
    function q(V) {
      const Z = N[V.str];
      return Z === void 0 || w[V.str] !== 1 ? V : (delete w[V.str], Z);
    }
    function K(V) {
      return V instanceof t._Code && V._items.some((Z) => Z instanceof t.Name && w[Z.str] === 1 && N[Z.str] !== void 0);
    }
  }
  function I(F, w) {
    for (const N in w)
      F[N] = (F[N] || 0) - (w[N] || 0);
  }
  function T(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null ? !F : (0, t._)`!${D(F)}`;
  }
  e.not = T;
  const j = P(e.operators.AND);
  function C(...F) {
    return F.reduce(j);
  }
  e.and = C;
  const A = P(e.operators.OR);
  function k(...F) {
    return F.reduce(A);
  }
  e.or = k;
  function P(F) {
    return (w, N) => w === t.nil ? N : N === t.nil ? w : (0, t._)`${D(w)} ${F} ${D(N)}`;
  }
  function D(F) {
    return F instanceof t.Name ? F : (0, t._)`(${F})`;
  }
})(ae);
var re = {};
Object.defineProperty(re, "__esModule", { value: !0 });
re.checkStrictMode = re.getErrorPath = re.Type = re.useFunc = re.setEvaluated = re.evaluatedPropsToName = re.mergeEvaluated = re.eachItem = re.unescapeJsonPointer = re.escapeJsonPointer = re.escapeFragment = re.unescapeFragment = re.schemaRefOrVal = re.schemaHasRulesButRef = re.schemaHasRules = re.checkUnknownRules = re.alwaysValidSchema = re.toHash = void 0;
const Pe = ae, s1 = Jn;
function i1(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = {};
  for (const r of e)
    t[r] = !0;
  return t;
}
<<<<<<< HEAD
se.toHash = iD;
function sD(e, t) {
  return typeof t == "boolean" ? t : Object.keys(t).length === 0 ? !0 : (Xx(e, t), !Zx(t, e.self.RULES.all));
}
se.alwaysValidSchema = sD;
function Xx(e, t = e.schema) {
  const { opts: r, self: n } = e;
  if (!r.strictSchema || typeof t == "boolean")
    return;
  const i = n.RULES.keywords;
  for (const s in t)
    i[s] || tR(e, `unknown keyword: "${s}"`);
}
se.checkUnknownRules = Xx;
function Zx(e, t) {
=======
re.toHash = i1;
function o1(e, t) {
  return typeof t == "boolean" ? t : Object.keys(t).length === 0 ? !0 : (Db(e, t), !Fb(t, e.self.RULES.all));
}
re.alwaysValidSchema = o1;
function Db(e, t = e.schema) {
  const { opts: r, self: n } = e;
  if (!r.strictSchema || typeof t == "boolean")
    return;
  const s = n.RULES.keywords;
  for (const i in t)
    s[i] || Ub(e, `unknown keyword: "${i}"`);
}
re.checkUnknownRules = Db;
function Fb(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t[r])
      return !0;
  return !1;
}
<<<<<<< HEAD
se.schemaHasRules = Zx;
function oD(e, t) {
=======
re.schemaHasRules = Fb;
function a1(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (r !== "$ref" && t.all[r])
      return !0;
  return !1;
}
<<<<<<< HEAD
se.schemaHasRulesButRef = oD;
function aD({ topSchemaRef: e, schemaPath: t }, r, n, i) {
  if (!i) {
    if (typeof r == "number" || typeof r == "boolean")
      return r;
    if (typeof r == "string")
      return (0, Ue._)`${r}`;
  }
  return (0, Ue._)`${e}${t}${(0, Ue.getProperty)(n)}`;
}
se.schemaRefOrVal = aD;
function cD(e) {
  return Qx(decodeURIComponent(e));
}
se.unescapeFragment = cD;
function lD(e) {
  return encodeURIComponent(Dm(e));
}
se.escapeFragment = lD;
function Dm(e) {
  return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
se.escapeJsonPointer = Dm;
function Qx(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
se.unescapeJsonPointer = Qx;
function uD(e, t) {
=======
re.schemaHasRulesButRef = a1;
function c1({ topSchemaRef: e, schemaPath: t }, r, n, s) {
  if (!s) {
    if (typeof r == "number" || typeof r == "boolean")
      return r;
    if (typeof r == "string")
      return (0, Pe._)`${r}`;
  }
  return (0, Pe._)`${e}${t}${(0, Pe.getProperty)(n)}`;
}
re.schemaRefOrVal = c1;
function l1(e) {
  return Mb(decodeURIComponent(e));
}
re.unescapeFragment = l1;
function u1(e) {
  return encodeURIComponent(vf(e));
}
re.escapeFragment = u1;
function vf(e) {
  return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
re.escapeJsonPointer = vf;
function Mb(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
re.unescapeJsonPointer = Mb;
function f1(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (Array.isArray(e))
    for (const r of e)
      t(r);
  else
    t(e);
}
<<<<<<< HEAD
se.eachItem = uD;
function C0({ mergeNames: e, mergeToName: t, mergeValues: r, resultToName: n }) {
  return (i, s, o, a) => {
    const c = o === void 0 ? s : o instanceof Ue.Name ? (s instanceof Ue.Name ? e(i, s, o) : t(i, s, o), o) : s instanceof Ue.Name ? (t(i, o, s), s) : r(s, o);
    return a === Ue.Name && !(c instanceof Ue.Name) ? n(i, c) : c;
  };
}
se.mergeEvaluated = {
  props: C0({
    mergeNames: (e, t, r) => e.if((0, Ue._)`${r} !== true && ${t} !== undefined`, () => {
      e.if((0, Ue._)`${t} === true`, () => e.assign(r, !0), () => e.assign(r, (0, Ue._)`${r} || {}`).code((0, Ue._)`Object.assign(${r}, ${t})`));
    }),
    mergeToName: (e, t, r) => e.if((0, Ue._)`${r} !== true`, () => {
      t === !0 ? e.assign(r, !0) : (e.assign(r, (0, Ue._)`${r} || {}`), Lm(e, r, t));
    }),
    mergeValues: (e, t) => e === !0 ? !0 : { ...e, ...t },
    resultToName: eR
  }),
  items: C0({
    mergeNames: (e, t, r) => e.if((0, Ue._)`${r} !== true && ${t} !== undefined`, () => e.assign(r, (0, Ue._)`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)),
    mergeToName: (e, t, r) => e.if((0, Ue._)`${r} !== true`, () => e.assign(r, t === !0 ? !0 : (0, Ue._)`${r} > ${t} ? ${r} : ${t}`)),
=======
re.eachItem = f1;
function Fh({ mergeNames: e, mergeToName: t, mergeValues: r, resultToName: n }) {
  return (s, i, o, a) => {
    const c = o === void 0 ? i : o instanceof Pe.Name ? (i instanceof Pe.Name ? e(s, i, o) : t(s, i, o), o) : i instanceof Pe.Name ? (t(s, o, i), i) : r(i, o);
    return a === Pe.Name && !(c instanceof Pe.Name) ? n(s, c) : c;
  };
}
re.mergeEvaluated = {
  props: Fh({
    mergeNames: (e, t, r) => e.if((0, Pe._)`${r} !== true && ${t} !== undefined`, () => {
      e.if((0, Pe._)`${t} === true`, () => e.assign(r, !0), () => e.assign(r, (0, Pe._)`${r} || {}`).code((0, Pe._)`Object.assign(${r}, ${t})`));
    }),
    mergeToName: (e, t, r) => e.if((0, Pe._)`${r} !== true`, () => {
      t === !0 ? e.assign(r, !0) : (e.assign(r, (0, Pe._)`${r} || {}`), bf(e, r, t));
    }),
    mergeValues: (e, t) => e === !0 ? !0 : { ...e, ...t },
    resultToName: zb
  }),
  items: Fh({
    mergeNames: (e, t, r) => e.if((0, Pe._)`${r} !== true && ${t} !== undefined`, () => e.assign(r, (0, Pe._)`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)),
    mergeToName: (e, t, r) => e.if((0, Pe._)`${r} !== true`, () => e.assign(r, t === !0 ? !0 : (0, Pe._)`${r} > ${t} ? ${r} : ${t}`)),
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    mergeValues: (e, t) => e === !0 ? !0 : Math.max(e, t),
    resultToName: (e, t) => e.var("items", t)
  })
};
<<<<<<< HEAD
function eR(e, t) {
  if (t === !0)
    return e.var("props", !0);
  const r = e.var("props", (0, Ue._)`{}`);
  return t !== void 0 && Lm(e, r, t), r;
}
se.evaluatedPropsToName = eR;
function Lm(e, t, r) {
  Object.keys(r).forEach((n) => e.assign((0, Ue._)`${t}${(0, Ue.getProperty)(n)}`, !0));
}
se.setEvaluated = Lm;
const A0 = {};
function fD(e, t) {
  return e.scopeValue("func", {
    ref: t,
    code: A0[t.code] || (A0[t.code] = new nD._Code(t.code))
  });
}
se.useFunc = fD;
var vh;
(function(e) {
  e[e.Num = 0] = "Num", e[e.Str = 1] = "Str";
})(vh || (se.Type = vh = {}));
function dD(e, t, r) {
  if (e instanceof Ue.Name) {
    const n = t === vh.Num;
    return r ? n ? (0, Ue._)`"[" + ${e} + "]"` : (0, Ue._)`"['" + ${e} + "']"` : n ? (0, Ue._)`"/" + ${e}` : (0, Ue._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return r ? (0, Ue.getProperty)(e).toString() : "/" + Dm(e);
}
se.getErrorPath = dD;
function tR(e, t, r = e.opts.strictSchema) {
=======
function zb(e, t) {
  if (t === !0)
    return e.var("props", !0);
  const r = e.var("props", (0, Pe._)`{}`);
  return t !== void 0 && bf(e, r, t), r;
}
re.evaluatedPropsToName = zb;
function bf(e, t, r) {
  Object.keys(r).forEach((n) => e.assign((0, Pe._)`${t}${(0, Pe.getProperty)(n)}`, !0));
}
re.setEvaluated = bf;
const Mh = {};
function d1(e, t) {
  return e.scopeValue("func", {
    ref: t,
    code: Mh[t.code] || (Mh[t.code] = new s1._Code(t.code))
  });
}
re.useFunc = d1;
var pu;
(function(e) {
  e[e.Num = 0] = "Num", e[e.Str = 1] = "Str";
})(pu || (re.Type = pu = {}));
function p1(e, t, r) {
  if (e instanceof Pe.Name) {
    const n = t === pu.Num;
    return r ? n ? (0, Pe._)`"[" + ${e} + "]"` : (0, Pe._)`"['" + ${e} + "']"` : n ? (0, Pe._)`"/" + ${e}` : (0, Pe._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return r ? (0, Pe.getProperty)(e).toString() : "/" + vf(e);
}
re.getErrorPath = p1;
function Ub(e, t, r = e.opts.strictSchema) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (r) {
    if (t = `strict mode: ${t}`, r === !0)
      throw new Error(t);
    e.self.logger.warn(t);
  }
}
<<<<<<< HEAD
se.checkStrictMode = tR;
var _r = {};
Object.defineProperty(_r, "__esModule", { value: !0 });
const Bt = he, pD = {
  // validation function arguments
  data: new Bt.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new Bt.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new Bt.Name("instancePath"),
  parentData: new Bt.Name("parentData"),
  parentDataProperty: new Bt.Name("parentDataProperty"),
  rootData: new Bt.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new Bt.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new Bt.Name("vErrors"),
  // null or array of validation errors
  errors: new Bt.Name("errors"),
  // counter of validation errors
  this: new Bt.Name("this"),
  // "globals"
  self: new Bt.Name("self"),
  scope: new Bt.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new Bt.Name("json"),
  jsonPos: new Bt.Name("jsonPos"),
  jsonLen: new Bt.Name("jsonLen"),
  jsonPart: new Bt.Name("jsonPart")
};
_r.default = pD;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = he, r = se, n = _r;
  e.keywordError = {
    message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: _, schemaType: g }) => g ? (0, t.str)`"${_}" keyword must be ${g} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
  };
  function i(_, g = e.keywordError, v, y) {
    const { it: E } = _, { gen: R, compositeRule: w, allErrors: C } = E, V = f(_, g, v);
    y ?? (w || C) ? c(R, V) : u(E, (0, t._)`[${V}]`);
  }
  e.reportError = i;
  function s(_, g = e.keywordError, v) {
    const { it: y } = _, { gen: E, compositeRule: R, allErrors: w } = y, C = f(_, g, v);
    c(E, C), R || w || u(y, n.default.vErrors);
  }
  e.reportExtraError = s;
  function o(_, g) {
    _.assign(n.default.errors, g), _.if((0, t._)`${n.default.vErrors} !== null`, () => _.if(g, () => _.assign((0, t._)`${n.default.vErrors}.length`, g), () => _.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = o;
  function a({ gen: _, keyword: g, schemaValue: v, data: y, errsCount: E, it: R }) {
    if (E === void 0)
      throw new Error("ajv implementation error");
    const w = _.name("err");
    _.forRange("i", E, n.default.errors, (C) => {
      _.const(w, (0, t._)`${n.default.vErrors}[${C}]`), _.if((0, t._)`${w}.instancePath === undefined`, () => _.assign((0, t._)`${w}.instancePath`, (0, t.strConcat)(n.default.instancePath, R.errorPath))), _.assign((0, t._)`${w}.schemaPath`, (0, t.str)`${R.errSchemaPath}/${g}`), R.opts.verbose && (_.assign((0, t._)`${w}.schema`, v), _.assign((0, t._)`${w}.data`, y));
    });
  }
  e.extendErrors = a;
  function c(_, g) {
    const v = _.const("err", g);
    _.if((0, t._)`${n.default.vErrors} === null`, () => _.assign(n.default.vErrors, (0, t._)`[${v}]`), (0, t._)`${n.default.vErrors}.push(${v})`), _.code((0, t._)`${n.default.errors}++`);
  }
  function u(_, g) {
    const { gen: v, validateName: y, schemaEnv: E } = _;
    E.$async ? v.throw((0, t._)`new ${_.ValidationError}(${g})`) : (v.assign((0, t._)`${y}.errors`, g), v.return(!1));
=======
re.checkStrictMode = Ub;
var jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
const yt = ae, h1 = {
  // validation function arguments
  data: new yt.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new yt.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new yt.Name("instancePath"),
  parentData: new yt.Name("parentData"),
  parentDataProperty: new yt.Name("parentDataProperty"),
  rootData: new yt.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new yt.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new yt.Name("vErrors"),
  // null or array of validation errors
  errors: new yt.Name("errors"),
  // counter of validation errors
  this: new yt.Name("this"),
  // "globals"
  self: new yt.Name("self"),
  scope: new yt.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new yt.Name("json"),
  jsonPos: new yt.Name("jsonPos"),
  jsonLen: new yt.Name("jsonLen"),
  jsonPart: new yt.Name("jsonPart")
};
jt.default = h1;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = ae, r = re, n = jt;
  e.keywordError = {
    message: ({ keyword: b }) => (0, t.str)`must pass "${b}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: b, schemaType: m }) => m ? (0, t.str)`"${b}" keyword must be ${m} ($data)` : (0, t.str)`"${b}" keyword is invalid ($data)`
  };
  function s(b, m = e.keywordError, v, y) {
    const { it: _ } = b, { gen: R, compositeRule: E, allErrors: O } = _, z = d(b, m, v);
    y ?? (E || O) ? c(R, z) : f(_, (0, t._)`[${z}]`);
  }
  e.reportError = s;
  function i(b, m = e.keywordError, v) {
    const { it: y } = b, { gen: _, compositeRule: R, allErrors: E } = y, O = d(b, m, v);
    c(_, O), R || E || f(y, n.default.vErrors);
  }
  e.reportExtraError = i;
  function o(b, m) {
    b.assign(n.default.errors, m), b.if((0, t._)`${n.default.vErrors} !== null`, () => b.if(m, () => b.assign((0, t._)`${n.default.vErrors}.length`, m), () => b.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = o;
  function a({ gen: b, keyword: m, schemaValue: v, data: y, errsCount: _, it: R }) {
    if (_ === void 0)
      throw new Error("ajv implementation error");
    const E = b.name("err");
    b.forRange("i", _, n.default.errors, (O) => {
      b.const(E, (0, t._)`${n.default.vErrors}[${O}]`), b.if((0, t._)`${E}.instancePath === undefined`, () => b.assign((0, t._)`${E}.instancePath`, (0, t.strConcat)(n.default.instancePath, R.errorPath))), b.assign((0, t._)`${E}.schemaPath`, (0, t.str)`${R.errSchemaPath}/${m}`), R.opts.verbose && (b.assign((0, t._)`${E}.schema`, v), b.assign((0, t._)`${E}.data`, y));
    });
  }
  e.extendErrors = a;
  function c(b, m) {
    const v = b.const("err", m);
    b.if((0, t._)`${n.default.vErrors} === null`, () => b.assign(n.default.vErrors, (0, t._)`[${v}]`), (0, t._)`${n.default.vErrors}.push(${v})`), b.code((0, t._)`${n.default.errors}++`);
  }
  function f(b, m) {
    const { gen: v, validateName: y, schemaEnv: _ } = b;
    _.$async ? v.throw((0, t._)`new ${b.ValidationError}(${m})`) : (v.assign((0, t._)`${y}.errors`, m), v.return(!1));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  const l = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    // also used in JTD errors
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
<<<<<<< HEAD
  function f(_, g, v) {
    const { createErrors: y } = _.it;
    return y === !1 ? (0, t._)`{}` : m(_, g, v);
  }
  function m(_, g, v = {}) {
    const { gen: y, it: E } = _, R = [
      p(E, v),
      d(_, v)
    ];
    return h(_, g, R), y.object(...R);
  }
  function p({ errorPath: _ }, { instancePath: g }) {
    const v = g ? (0, t.str)`${_}${(0, r.getErrorPath)(g, r.Type.Str)}` : _;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, v)];
  }
  function d({ keyword: _, it: { errSchemaPath: g } }, { schemaPath: v, parentSchema: y }) {
    let E = y ? g : (0, t.str)`${g}/${_}`;
    return v && (E = (0, t.str)`${E}${(0, r.getErrorPath)(v, r.Type.Str)}`), [l.schemaPath, E];
  }
  function h(_, { params: g, message: v }, y) {
    const { keyword: E, data: R, schemaValue: w, it: C } = _, { opts: V, propertyName: b, topSchemaRef: F, schemaPath: H } = C;
    y.push([l.keyword, E], [l.params, typeof g == "function" ? g(_) : g || (0, t._)`{}`]), V.messages && y.push([l.message, typeof v == "function" ? v(_) : v]), V.verbose && y.push([l.schema, w], [l.parentSchema, (0, t._)`${F}${H}`], [n.default.data, R]), b && y.push([l.propertyName, b]);
  }
})(Ba);
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.boolOrEmptySchema = Ms.topBoolOrEmptySchema = void 0;
const hD = Ba, mD = he, gD = _r, yD = {
  message: "boolean schema is false"
};
function vD(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? rR(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(gD.default.data) : (t.assign((0, mD._)`${n}.errors`, null), t.return(!0));
}
Ms.topBoolOrEmptySchema = vD;
function _D(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), rR(e)) : r.var(t, !0);
}
Ms.boolOrEmptySchema = _D;
function rR(e, t) {
  const { gen: r, data: n } = e, i = {
=======
  function d(b, m, v) {
    const { createErrors: y } = b.it;
    return y === !1 ? (0, t._)`{}` : g(b, m, v);
  }
  function g(b, m, v = {}) {
    const { gen: y, it: _ } = b, R = [
      p(_, v),
      u(b, v)
    ];
    return h(b, m, R), y.object(...R);
  }
  function p({ errorPath: b }, { instancePath: m }) {
    const v = m ? (0, t.str)`${b}${(0, r.getErrorPath)(m, r.Type.Str)}` : b;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, v)];
  }
  function u({ keyword: b, it: { errSchemaPath: m } }, { schemaPath: v, parentSchema: y }) {
    let _ = y ? m : (0, t.str)`${m}/${b}`;
    return v && (_ = (0, t.str)`${_}${(0, r.getErrorPath)(v, r.Type.Str)}`), [l.schemaPath, _];
  }
  function h(b, { params: m, message: v }, y) {
    const { keyword: _, data: R, schemaValue: E, it: O } = b, { opts: z, propertyName: S, topSchemaRef: L, schemaPath: M } = O;
    y.push([l.keyword, _], [l.params, typeof m == "function" ? m(b) : m || (0, t._)`{}`]), z.messages && y.push([l.message, typeof v == "function" ? v(b) : v]), z.verbose && y.push([l.schema, E], [l.parentSchema, (0, t._)`${L}${M}`], [n.default.data, R]), S && y.push([l.propertyName, S]);
  }
})(di);
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.boolOrEmptySchema = Kn.topBoolOrEmptySchema = void 0;
const m1 = di, y1 = ae, g1 = jt, v1 = {
  message: "boolean schema is false"
};
function b1(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? qb(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(g1.default.data) : (t.assign((0, y1._)`${n}.errors`, null), t.return(!0));
}
Kn.topBoolOrEmptySchema = b1;
function _1(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), qb(e)) : r.var(t, !0);
}
Kn.boolOrEmptySchema = _1;
function qb(e, t) {
  const { gen: r, data: n } = e, s = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
<<<<<<< HEAD
  (0, hD.reportError)(i, yD, void 0, t);
}
var yt = {}, Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.getRules = Ui.isJSONType = void 0;
const bD = ["string", "number", "integer", "boolean", "null", "object", "array"], ED = new Set(bD);
function wD(e) {
  return typeof e == "string" && ED.has(e);
}
Ui.isJSONType = wD;
function SD() {
=======
  (0, m1.reportError)(s, v1, void 0, t);
}
var tt = {}, dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.getRules = dn.isJSONType = void 0;
const E1 = ["string", "number", "integer", "boolean", "null", "object", "array"], S1 = new Set(E1);
function x1(e) {
  return typeof e == "string" && S1.has(e);
}
dn.isJSONType = x1;
function w1() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
<<<<<<< HEAD
Ui.getRules = SD;
var mn = {};
Object.defineProperty(mn, "__esModule", { value: !0 });
mn.shouldUseRule = mn.shouldUseGroup = mn.schemaHasRulesForType = void 0;
function xD({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && nR(e, n);
}
mn.schemaHasRulesForType = xD;
function nR(e, t) {
  return t.rules.some((r) => iR(e, r));
}
mn.shouldUseGroup = nR;
function iR(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
mn.shouldUseRule = iR;
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.reportTypeError = yt.checkDataTypes = yt.checkDataType = yt.coerceAndCheckDataType = yt.getJSONTypes = yt.getSchemaTypes = yt.DataType = void 0;
const RD = Ui, $D = mn, TD = Ba, Ee = he, sR = se;
var Is;
(function(e) {
  e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong";
})(Is || (yt.DataType = Is = {}));
function OD(e) {
  const t = oR(e.type);
=======
dn.getRules = w1;
var br = {};
Object.defineProperty(br, "__esModule", { value: !0 });
br.shouldUseRule = br.shouldUseGroup = br.schemaHasRulesForType = void 0;
function R1({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && Hb(e, n);
}
br.schemaHasRulesForType = R1;
function Hb(e, t) {
  return t.rules.some((r) => Bb(e, r));
}
br.shouldUseGroup = Hb;
function Bb(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
br.shouldUseRule = Bb;
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.reportTypeError = tt.checkDataTypes = tt.checkDataType = tt.coerceAndCheckDataType = tt.getJSONTypes = tt.getSchemaTypes = tt.DataType = void 0;
const $1 = dn, T1 = br, O1 = di, de = ae, Vb = re;
var qn;
(function(e) {
  e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong";
})(qn || (tt.DataType = qn = {}));
function C1(e) {
  const t = Gb(e.type);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (t.includes("null")) {
    if (e.nullable === !1)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!t.length && e.nullable !== void 0)
      throw new Error('"nullable" cannot be used without "type"');
    e.nullable === !0 && t.push("null");
  }
  return t;
}
<<<<<<< HEAD
yt.getSchemaTypes = OD;
function oR(e) {
  const t = Array.isArray(e) ? e : e ? [e] : [];
  if (t.every(RD.isJSONType))
    return t;
  throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
}
yt.getJSONTypes = oR;
function PD(e, t) {
  const { gen: r, data: n, opts: i } = e, s = CD(t, i.coerceTypes), o = t.length > 0 && !(s.length === 0 && t.length === 1 && (0, $D.schemaHasRulesForType)(e, t[0]));
  if (o) {
    const a = Fm(t, n, i.strictNumbers, Is.Wrong);
    r.if(a, () => {
      s.length ? AD(e, t, s) : jm(e);
=======
tt.getSchemaTypes = C1;
function Gb(e) {
  const t = Array.isArray(e) ? e : e ? [e] : [];
  if (t.every($1.isJSONType))
    return t;
  throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
}
tt.getJSONTypes = Gb;
function P1(e, t) {
  const { gen: r, data: n, opts: s } = e, i = I1(t, s.coerceTypes), o = t.length > 0 && !(i.length === 0 && t.length === 1 && (0, T1.schemaHasRulesForType)(e, t[0]));
  if (o) {
    const a = _f(t, n, s.strictNumbers, qn.Wrong);
    r.if(a, () => {
      i.length ? N1(e, t, i) : Ef(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    });
  }
  return o;
}
<<<<<<< HEAD
yt.coerceAndCheckDataType = PD;
const aR = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function CD(e, t) {
  return t ? e.filter((r) => aR.has(r) || t === "array" && r === "array") : [];
}
function AD(e, t, r) {
  const { gen: n, data: i, opts: s } = e, o = n.let("dataType", (0, Ee._)`typeof ${i}`), a = n.let("coerced", (0, Ee._)`undefined`);
  s.coerceTypes === "array" && n.if((0, Ee._)`${o} == 'object' && Array.isArray(${i}) && ${i}.length == 1`, () => n.assign(i, (0, Ee._)`${i}[0]`).assign(o, (0, Ee._)`typeof ${i}`).if(Fm(t, i, s.strictNumbers), () => n.assign(a, i))), n.if((0, Ee._)`${a} !== undefined`);
  for (const u of r)
    (aR.has(u) || u === "array" && s.coerceTypes === "array") && c(u);
  n.else(), jm(e), n.endIf(), n.if((0, Ee._)`${a} !== undefined`, () => {
    n.assign(i, a), ID(e, a);
  });
  function c(u) {
    switch (u) {
      case "string":
        n.elseIf((0, Ee._)`${o} == "number" || ${o} == "boolean"`).assign(a, (0, Ee._)`"" + ${i}`).elseIf((0, Ee._)`${i} === null`).assign(a, (0, Ee._)`""`);
        return;
      case "number":
        n.elseIf((0, Ee._)`${o} == "boolean" || ${i} === null
              || (${o} == "string" && ${i} && ${i} == +${i})`).assign(a, (0, Ee._)`+${i}`);
        return;
      case "integer":
        n.elseIf((0, Ee._)`${o} === "boolean" || ${i} === null
              || (${o} === "string" && ${i} && ${i} == +${i} && !(${i} % 1))`).assign(a, (0, Ee._)`+${i}`);
        return;
      case "boolean":
        n.elseIf((0, Ee._)`${i} === "false" || ${i} === 0 || ${i} === null`).assign(a, !1).elseIf((0, Ee._)`${i} === "true" || ${i} === 1`).assign(a, !0);
        return;
      case "null":
        n.elseIf((0, Ee._)`${i} === "" || ${i} === 0 || ${i} === false`), n.assign(a, null);
        return;
      case "array":
        n.elseIf((0, Ee._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${i} === null`).assign(a, (0, Ee._)`[${i}]`);
    }
  }
}
function ID({ gen: e, parentData: t, parentDataProperty: r }, n) {
  e.if((0, Ee._)`${t} !== undefined`, () => e.assign((0, Ee._)`${t}[${r}]`, n));
}
function _h(e, t, r, n = Is.Correct) {
  const i = n === Is.Correct ? Ee.operators.EQ : Ee.operators.NEQ;
  let s;
  switch (e) {
    case "null":
      return (0, Ee._)`${t} ${i} null`;
    case "array":
      s = (0, Ee._)`Array.isArray(${t})`;
      break;
    case "object":
      s = (0, Ee._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
      break;
    case "integer":
      s = o((0, Ee._)`!(${t} % 1) && !isNaN(${t})`);
      break;
    case "number":
      s = o();
      break;
    default:
      return (0, Ee._)`typeof ${t} ${i} ${e}`;
  }
  return n === Is.Correct ? s : (0, Ee.not)(s);
  function o(a = Ee.nil) {
    return (0, Ee.and)((0, Ee._)`typeof ${t} == "number"`, a, r ? (0, Ee._)`isFinite(${t})` : Ee.nil);
  }
}
yt.checkDataType = _h;
function Fm(e, t, r, n) {
  if (e.length === 1)
    return _h(e[0], t, r, n);
  let i;
  const s = (0, sR.toHash)(e);
  if (s.array && s.object) {
    const o = (0, Ee._)`typeof ${t} != "object"`;
    i = s.null ? o : (0, Ee._)`!${t} || ${o}`, delete s.null, delete s.array, delete s.object;
  } else
    i = Ee.nil;
  s.number && delete s.integer;
  for (const o in s)
    i = (0, Ee.and)(i, _h(o, t, r, n));
  return i;
}
yt.checkDataTypes = Fm;
const ND = {
  message: ({ schema: e }) => `must be ${e}`,
  params: ({ schema: e, schemaValue: t }) => typeof e == "string" ? (0, Ee._)`{type: ${e}}` : (0, Ee._)`{type: ${t}}`
};
function jm(e) {
  const t = kD(e);
  (0, TD.reportError)(t, ND);
}
yt.reportTypeError = jm;
function kD(e) {
  const { gen: t, data: r, schema: n } = e, i = (0, sR.schemaRefOrVal)(e, n, "type");
=======
tt.coerceAndCheckDataType = P1;
const Wb = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function I1(e, t) {
  return t ? e.filter((r) => Wb.has(r) || t === "array" && r === "array") : [];
}
function N1(e, t, r) {
  const { gen: n, data: s, opts: i } = e, o = n.let("dataType", (0, de._)`typeof ${s}`), a = n.let("coerced", (0, de._)`undefined`);
  i.coerceTypes === "array" && n.if((0, de._)`${o} == 'object' && Array.isArray(${s}) && ${s}.length == 1`, () => n.assign(s, (0, de._)`${s}[0]`).assign(o, (0, de._)`typeof ${s}`).if(_f(t, s, i.strictNumbers), () => n.assign(a, s))), n.if((0, de._)`${a} !== undefined`);
  for (const f of r)
    (Wb.has(f) || f === "array" && i.coerceTypes === "array") && c(f);
  n.else(), Ef(e), n.endIf(), n.if((0, de._)`${a} !== undefined`, () => {
    n.assign(s, a), A1(e, a);
  });
  function c(f) {
    switch (f) {
      case "string":
        n.elseIf((0, de._)`${o} == "number" || ${o} == "boolean"`).assign(a, (0, de._)`"" + ${s}`).elseIf((0, de._)`${s} === null`).assign(a, (0, de._)`""`);
        return;
      case "number":
        n.elseIf((0, de._)`${o} == "boolean" || ${s} === null
              || (${o} == "string" && ${s} && ${s} == +${s})`).assign(a, (0, de._)`+${s}`);
        return;
      case "integer":
        n.elseIf((0, de._)`${o} === "boolean" || ${s} === null
              || (${o} === "string" && ${s} && ${s} == +${s} && !(${s} % 1))`).assign(a, (0, de._)`+${s}`);
        return;
      case "boolean":
        n.elseIf((0, de._)`${s} === "false" || ${s} === 0 || ${s} === null`).assign(a, !1).elseIf((0, de._)`${s} === "true" || ${s} === 1`).assign(a, !0);
        return;
      case "null":
        n.elseIf((0, de._)`${s} === "" || ${s} === 0 || ${s} === false`), n.assign(a, null);
        return;
      case "array":
        n.elseIf((0, de._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${s} === null`).assign(a, (0, de._)`[${s}]`);
    }
  }
}
function A1({ gen: e, parentData: t, parentDataProperty: r }, n) {
  e.if((0, de._)`${t} !== undefined`, () => e.assign((0, de._)`${t}[${r}]`, n));
}
function hu(e, t, r, n = qn.Correct) {
  const s = n === qn.Correct ? de.operators.EQ : de.operators.NEQ;
  let i;
  switch (e) {
    case "null":
      return (0, de._)`${t} ${s} null`;
    case "array":
      i = (0, de._)`Array.isArray(${t})`;
      break;
    case "object":
      i = (0, de._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
      break;
    case "integer":
      i = o((0, de._)`!(${t} % 1) && !isNaN(${t})`);
      break;
    case "number":
      i = o();
      break;
    default:
      return (0, de._)`typeof ${t} ${s} ${e}`;
  }
  return n === qn.Correct ? i : (0, de.not)(i);
  function o(a = de.nil) {
    return (0, de.and)((0, de._)`typeof ${t} == "number"`, a, r ? (0, de._)`isFinite(${t})` : de.nil);
  }
}
tt.checkDataType = hu;
function _f(e, t, r, n) {
  if (e.length === 1)
    return hu(e[0], t, r, n);
  let s;
  const i = (0, Vb.toHash)(e);
  if (i.array && i.object) {
    const o = (0, de._)`typeof ${t} != "object"`;
    s = i.null ? o : (0, de._)`!${t} || ${o}`, delete i.null, delete i.array, delete i.object;
  } else
    s = de.nil;
  i.number && delete i.integer;
  for (const o in i)
    s = (0, de.and)(s, hu(o, t, r, n));
  return s;
}
tt.checkDataTypes = _f;
const k1 = {
  message: ({ schema: e }) => `must be ${e}`,
  params: ({ schema: e, schemaValue: t }) => typeof e == "string" ? (0, de._)`{type: ${e}}` : (0, de._)`{type: ${t}}`
};
function Ef(e) {
  const t = L1(e);
  (0, O1.reportError)(t, k1);
}
tt.reportTypeError = Ef;
function L1(e) {
  const { gen: t, data: r, schema: n } = e, s = (0, Vb.schemaRefOrVal)(e, n, "type");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    gen: t,
    keyword: "type",
    data: r,
    schema: n.type,
<<<<<<< HEAD
    schemaCode: i,
    schemaValue: i,
=======
    schemaCode: s,
    schemaValue: s,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    parentSchema: n,
    params: {},
    it: e
  };
}
<<<<<<< HEAD
var Fu = {};
Object.defineProperty(Fu, "__esModule", { value: !0 });
Fu.assignDefaults = void 0;
const rs = he, DD = se;
function LD(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const i in r)
      I0(e, i, r[i].default);
  else t === "array" && Array.isArray(n) && n.forEach((i, s) => I0(e, s, i.default));
}
Fu.assignDefaults = LD;
function I0(e, t, r) {
  const { gen: n, compositeRule: i, data: s, opts: o } = e;
  if (r === void 0)
    return;
  const a = (0, rs._)`${s}${(0, rs.getProperty)(t)}`;
  if (i) {
    (0, DD.checkStrictMode)(e, `default is ignored for: ${a}`);
    return;
  }
  let c = (0, rs._)`${a} === undefined`;
  o.useDefaults === "empty" && (c = (0, rs._)`${c} || ${a} === null || ${a} === ""`), n.if(c, (0, rs._)`${a} = ${(0, rs.stringify)(r)}`);
}
var Zr = {}, _e = {};
Object.defineProperty(_e, "__esModule", { value: !0 });
_e.validateUnion = _e.validateArray = _e.usePattern = _e.callValidateCode = _e.schemaProperties = _e.allSchemaProperties = _e.noPropertyInData = _e.propertyInData = _e.isOwnProperty = _e.hasPropFunc = _e.reportMissingProp = _e.checkMissingProp = _e.checkReportMissingProp = void 0;
const Ge = he, Um = se, In = _r, FD = se;
function jD(e, t) {
  const { gen: r, data: n, it: i } = e;
  r.if(Hm(r, n, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, Ge._)`${t}` }, !0), e.error();
  });
}
_e.checkReportMissingProp = jD;
function UD({ gen: e, data: t, it: { opts: r } }, n, i) {
  return (0, Ge.or)(...n.map((s) => (0, Ge.and)(Hm(e, t, s, r.ownProperties), (0, Ge._)`${i} = ${s}`)));
}
_e.checkMissingProp = UD;
function MD(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
_e.reportMissingProp = MD;
function cR(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, Ge._)`Object.prototype.hasOwnProperty`
  });
}
_e.hasPropFunc = cR;
function Mm(e, t, r) {
  return (0, Ge._)`${cR(e)}.call(${t}, ${r})`;
}
_e.isOwnProperty = Mm;
function HD(e, t, r, n) {
  const i = (0, Ge._)`${t}${(0, Ge.getProperty)(r)} !== undefined`;
  return n ? (0, Ge._)`${i} && ${Mm(e, t, r)}` : i;
}
_e.propertyInData = HD;
function Hm(e, t, r, n) {
  const i = (0, Ge._)`${t}${(0, Ge.getProperty)(r)} === undefined`;
  return n ? (0, Ge.or)(i, (0, Ge.not)(Mm(e, t, r))) : i;
}
_e.noPropertyInData = Hm;
function lR(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
_e.allSchemaProperties = lR;
function qD(e, t) {
  return lR(t).filter((r) => !(0, Um.alwaysValidSchema)(e, t[r]));
}
_e.schemaProperties = qD;
function BD({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: i, errorPath: s }, it: o }, a, c, u) {
  const l = u ? (0, Ge._)`${e}, ${t}, ${n}${i}` : t, f = [
    [In.default.instancePath, (0, Ge.strConcat)(In.default.instancePath, s)],
    [In.default.parentData, o.parentData],
    [In.default.parentDataProperty, o.parentDataProperty],
    [In.default.rootData, In.default.rootData]
  ];
  o.opts.dynamicRef && f.push([In.default.dynamicAnchors, In.default.dynamicAnchors]);
  const m = (0, Ge._)`${l}, ${r.object(...f)}`;
  return c !== Ge.nil ? (0, Ge._)`${a}.call(${c}, ${m})` : (0, Ge._)`${a}(${m})`;
}
_e.callValidateCode = BD;
const zD = (0, Ge._)`new RegExp`;
function VD({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: i } = t.code, s = i(r, n);
  return e.scopeValue("pattern", {
    key: s.toString(),
    ref: s,
    code: (0, Ge._)`${i.code === "new RegExp" ? zD : (0, FD.useFunc)(e, i)}(${r}, ${n})`
  });
}
_e.usePattern = VD;
function GD(e) {
  const { gen: t, data: r, keyword: n, it: i } = e, s = t.name("valid");
  if (i.allErrors) {
    const a = t.let("valid", !0);
    return o(() => t.assign(a, !1)), a;
  }
  return t.var(s, !0), o(() => t.break()), s;
  function o(a) {
    const c = t.const("len", (0, Ge._)`${r}.length`);
    t.forRange("i", 0, c, (u) => {
      e.subschema({
        keyword: n,
        dataProp: u,
        dataPropType: Um.Type.Num
      }, s), t.if((0, Ge.not)(s), a);
    });
  }
}
_e.validateArray = GD;
function WD(e) {
  const { gen: t, schema: r, keyword: n, it: i } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, Um.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const o = t.let("valid", !1), a = t.name("_valid");
  t.block(() => r.forEach((c, u) => {
    const l = e.subschema({
      keyword: n,
      schemaProp: u,
      compositeRule: !0
    }, a);
    t.assign(o, (0, Ge._)`${o} || ${a}`), e.mergeValidEvaluated(l, a) || t.if((0, Ge.not)(o));
  })), e.result(o, () => e.reset(), () => e.error(!0));
}
_e.validateUnion = WD;
Object.defineProperty(Zr, "__esModule", { value: !0 });
Zr.validateKeywordUsage = Zr.validSchemaType = Zr.funcKeywordCode = Zr.macroKeywordCode = void 0;
const Zt = he, xi = _r, KD = _e, YD = Ba;
function JD(e, t) {
  const { gen: r, keyword: n, schema: i, parentSchema: s, it: o } = e, a = t.macro.call(o.self, i, s, o), c = uR(r, n, a);
  o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
  const u = r.name("valid");
  e.subschema({
    schema: a,
    schemaPath: Zt.nil,
    errSchemaPath: `${o.errSchemaPath}/${n}`,
    topSchemaRef: c,
    compositeRule: !0
  }, u), e.pass(u, () => e.error(!0));
}
Zr.macroKeywordCode = JD;
function XD(e, t) {
  var r;
  const { gen: n, keyword: i, schema: s, parentSchema: o, $data: a, it: c } = e;
  QD(c, t);
  const u = !a && t.compile ? t.compile.call(c.self, s, o, c) : t.validate, l = uR(n, i, u), f = n.let("valid");
  e.block$data(f, m), e.ok((r = t.valid) !== null && r !== void 0 ? r : f);
  function m() {
    if (t.errors === !1)
      h(), t.modifying && N0(e), _(() => e.error());
    else {
      const g = t.async ? p() : d();
      t.modifying && N0(e), _(() => ZD(e, g));
    }
  }
  function p() {
    const g = n.let("ruleErrs", null);
    return n.try(() => h((0, Zt._)`await `), (v) => n.assign(f, !1).if((0, Zt._)`${v} instanceof ${c.ValidationError}`, () => n.assign(g, (0, Zt._)`${v}.errors`), () => n.throw(v))), g;
  }
  function d() {
    const g = (0, Zt._)`${l}.errors`;
    return n.assign(g, null), h(Zt.nil), g;
  }
  function h(g = t.async ? (0, Zt._)`await ` : Zt.nil) {
    const v = c.opts.passContext ? xi.default.this : xi.default.self, y = !("compile" in t && !a || t.schema === !1);
    n.assign(f, (0, Zt._)`${g}${(0, KD.callValidateCode)(e, l, v, y)}`, t.modifying);
  }
  function _(g) {
    var v;
    n.if((0, Zt.not)((v = t.valid) !== null && v !== void 0 ? v : f), g);
  }
}
Zr.funcKeywordCode = XD;
function N0(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, Zt._)`${n.parentData}[${n.parentDataProperty}]`));
}
function ZD(e, t) {
  const { gen: r } = e;
  r.if((0, Zt._)`Array.isArray(${t})`, () => {
    r.assign(xi.default.vErrors, (0, Zt._)`${xi.default.vErrors} === null ? ${t} : ${xi.default.vErrors}.concat(${t})`).assign(xi.default.errors, (0, Zt._)`${xi.default.vErrors}.length`), (0, YD.extendErrors)(e);
  }, () => e.error());
}
function QD({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function uR(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, Zt.stringify)(r) });
}
function eL(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
Zr.validSchemaType = eL;
function tL({ schema: e, opts: t, self: r, errSchemaPath: n }, i, s) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(s) : i.keyword !== s)
    throw new Error("ajv implementation error");
  const o = i.dependencies;
  if (o != null && o.some((a) => !Object.prototype.hasOwnProperty.call(e, a)))
    throw new Error(`parent schema must have dependencies of ${s}: ${o.join(",")}`);
  if (i.validateSchema && !i.validateSchema(e[s])) {
    const c = `keyword "${s}" value is invalid at path "${n}": ` + r.errorsText(i.validateSchema.errors);
=======
var va = {};
Object.defineProperty(va, "__esModule", { value: !0 });
va.assignDefaults = void 0;
const Rn = ae, j1 = re;
function D1(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const s in r)
      zh(e, s, r[s].default);
  else t === "array" && Array.isArray(n) && n.forEach((s, i) => zh(e, i, s.default));
}
va.assignDefaults = D1;
function zh(e, t, r) {
  const { gen: n, compositeRule: s, data: i, opts: o } = e;
  if (r === void 0)
    return;
  const a = (0, Rn._)`${i}${(0, Rn.getProperty)(t)}`;
  if (s) {
    (0, j1.checkStrictMode)(e, `default is ignored for: ${a}`);
    return;
  }
  let c = (0, Rn._)`${a} === undefined`;
  o.useDefaults === "empty" && (c = (0, Rn._)`${c} || ${a} === null || ${a} === ""`), n.if(c, (0, Rn._)`${a} = ${(0, Rn.stringify)(r)}`);
}
var cr = {}, fe = {};
Object.defineProperty(fe, "__esModule", { value: !0 });
fe.validateUnion = fe.validateArray = fe.usePattern = fe.callValidateCode = fe.schemaProperties = fe.allSchemaProperties = fe.noPropertyInData = fe.propertyInData = fe.isOwnProperty = fe.hasPropFunc = fe.reportMissingProp = fe.checkMissingProp = fe.checkReportMissingProp = void 0;
const ke = ae, Sf = re, Pr = jt, F1 = re;
function M1(e, t) {
  const { gen: r, data: n, it: s } = e;
  r.if(wf(r, n, t, s.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, ke._)`${t}` }, !0), e.error();
  });
}
fe.checkReportMissingProp = M1;
function z1({ gen: e, data: t, it: { opts: r } }, n, s) {
  return (0, ke.or)(...n.map((i) => (0, ke.and)(wf(e, t, i, r.ownProperties), (0, ke._)`${s} = ${i}`)));
}
fe.checkMissingProp = z1;
function U1(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
fe.reportMissingProp = U1;
function Kb(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, ke._)`Object.prototype.hasOwnProperty`
  });
}
fe.hasPropFunc = Kb;
function xf(e, t, r) {
  return (0, ke._)`${Kb(e)}.call(${t}, ${r})`;
}
fe.isOwnProperty = xf;
function q1(e, t, r, n) {
  const s = (0, ke._)`${t}${(0, ke.getProperty)(r)} !== undefined`;
  return n ? (0, ke._)`${s} && ${xf(e, t, r)}` : s;
}
fe.propertyInData = q1;
function wf(e, t, r, n) {
  const s = (0, ke._)`${t}${(0, ke.getProperty)(r)} === undefined`;
  return n ? (0, ke.or)(s, (0, ke.not)(xf(e, t, r))) : s;
}
fe.noPropertyInData = wf;
function Jb(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
fe.allSchemaProperties = Jb;
function H1(e, t) {
  return Jb(t).filter((r) => !(0, Sf.alwaysValidSchema)(e, t[r]));
}
fe.schemaProperties = H1;
function B1({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: s, errorPath: i }, it: o }, a, c, f) {
  const l = f ? (0, ke._)`${e}, ${t}, ${n}${s}` : t, d = [
    [Pr.default.instancePath, (0, ke.strConcat)(Pr.default.instancePath, i)],
    [Pr.default.parentData, o.parentData],
    [Pr.default.parentDataProperty, o.parentDataProperty],
    [Pr.default.rootData, Pr.default.rootData]
  ];
  o.opts.dynamicRef && d.push([Pr.default.dynamicAnchors, Pr.default.dynamicAnchors]);
  const g = (0, ke._)`${l}, ${r.object(...d)}`;
  return c !== ke.nil ? (0, ke._)`${a}.call(${c}, ${g})` : (0, ke._)`${a}(${g})`;
}
fe.callValidateCode = B1;
const V1 = (0, ke._)`new RegExp`;
function G1({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: s } = t.code, i = s(r, n);
  return e.scopeValue("pattern", {
    key: i.toString(),
    ref: i,
    code: (0, ke._)`${s.code === "new RegExp" ? V1 : (0, F1.useFunc)(e, s)}(${r}, ${n})`
  });
}
fe.usePattern = G1;
function W1(e) {
  const { gen: t, data: r, keyword: n, it: s } = e, i = t.name("valid");
  if (s.allErrors) {
    const a = t.let("valid", !0);
    return o(() => t.assign(a, !1)), a;
  }
  return t.var(i, !0), o(() => t.break()), i;
  function o(a) {
    const c = t.const("len", (0, ke._)`${r}.length`);
    t.forRange("i", 0, c, (f) => {
      e.subschema({
        keyword: n,
        dataProp: f,
        dataPropType: Sf.Type.Num
      }, i), t.if((0, ke.not)(i), a);
    });
  }
}
fe.validateArray = W1;
function K1(e) {
  const { gen: t, schema: r, keyword: n, it: s } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, Sf.alwaysValidSchema)(s, c)) && !s.opts.unevaluated)
    return;
  const o = t.let("valid", !1), a = t.name("_valid");
  t.block(() => r.forEach((c, f) => {
    const l = e.subschema({
      keyword: n,
      schemaProp: f,
      compositeRule: !0
    }, a);
    t.assign(o, (0, ke._)`${o} || ${a}`), e.mergeValidEvaluated(l, a) || t.if((0, ke.not)(o));
  })), e.result(o, () => e.reset(), () => e.error(!0));
}
fe.validateUnion = K1;
Object.defineProperty(cr, "__esModule", { value: !0 });
cr.validateKeywordUsage = cr.validSchemaType = cr.funcKeywordCode = cr.macroKeywordCode = void 0;
const xt = ae, tn = jt, J1 = fe, Y1 = di;
function X1(e, t) {
  const { gen: r, keyword: n, schema: s, parentSchema: i, it: o } = e, a = t.macro.call(o.self, s, i, o), c = Yb(r, n, a);
  o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
  const f = r.name("valid");
  e.subschema({
    schema: a,
    schemaPath: xt.nil,
    errSchemaPath: `${o.errSchemaPath}/${n}`,
    topSchemaRef: c,
    compositeRule: !0
  }, f), e.pass(f, () => e.error(!0));
}
cr.macroKeywordCode = X1;
function Z1(e, t) {
  var r;
  const { gen: n, keyword: s, schema: i, parentSchema: o, $data: a, it: c } = e;
  eT(c, t);
  const f = !a && t.compile ? t.compile.call(c.self, i, o, c) : t.validate, l = Yb(n, s, f), d = n.let("valid");
  e.block$data(d, g), e.ok((r = t.valid) !== null && r !== void 0 ? r : d);
  function g() {
    if (t.errors === !1)
      h(), t.modifying && Uh(e), b(() => e.error());
    else {
      const m = t.async ? p() : u();
      t.modifying && Uh(e), b(() => Q1(e, m));
    }
  }
  function p() {
    const m = n.let("ruleErrs", null);
    return n.try(() => h((0, xt._)`await `), (v) => n.assign(d, !1).if((0, xt._)`${v} instanceof ${c.ValidationError}`, () => n.assign(m, (0, xt._)`${v}.errors`), () => n.throw(v))), m;
  }
  function u() {
    const m = (0, xt._)`${l}.errors`;
    return n.assign(m, null), h(xt.nil), m;
  }
  function h(m = t.async ? (0, xt._)`await ` : xt.nil) {
    const v = c.opts.passContext ? tn.default.this : tn.default.self, y = !("compile" in t && !a || t.schema === !1);
    n.assign(d, (0, xt._)`${m}${(0, J1.callValidateCode)(e, l, v, y)}`, t.modifying);
  }
  function b(m) {
    var v;
    n.if((0, xt.not)((v = t.valid) !== null && v !== void 0 ? v : d), m);
  }
}
cr.funcKeywordCode = Z1;
function Uh(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, xt._)`${n.parentData}[${n.parentDataProperty}]`));
}
function Q1(e, t) {
  const { gen: r } = e;
  r.if((0, xt._)`Array.isArray(${t})`, () => {
    r.assign(tn.default.vErrors, (0, xt._)`${tn.default.vErrors} === null ? ${t} : ${tn.default.vErrors}.concat(${t})`).assign(tn.default.errors, (0, xt._)`${tn.default.vErrors}.length`), (0, Y1.extendErrors)(e);
  }, () => e.error());
}
function eT({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function Yb(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, xt.stringify)(r) });
}
function tT(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
cr.validSchemaType = tT;
function rT({ schema: e, opts: t, self: r, errSchemaPath: n }, s, i) {
  if (Array.isArray(s.keyword) ? !s.keyword.includes(i) : s.keyword !== i)
    throw new Error("ajv implementation error");
  const o = s.dependencies;
  if (o != null && o.some((a) => !Object.prototype.hasOwnProperty.call(e, a)))
    throw new Error(`parent schema must have dependencies of ${i}: ${o.join(",")}`);
  if (s.validateSchema && !s.validateSchema(e[i])) {
    const c = `keyword "${i}" value is invalid at path "${n}": ` + r.errorsText(s.validateSchema.errors);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (t.validateSchema === "log")
      r.logger.error(c);
    else
      throw new Error(c);
  }
}
<<<<<<< HEAD
Zr.validateKeywordUsage = tL;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.extendSubschemaMode = Wn.extendSubschemaData = Wn.getSubschema = void 0;
const Xr = he, fR = se;
function rL(e, { keyword: t, schemaProp: r, schema: n, schemaPath: i, errSchemaPath: s, topSchemaRef: o }) {
=======
cr.validateKeywordUsage = rT;
var zr = {};
Object.defineProperty(zr, "__esModule", { value: !0 });
zr.extendSubschemaMode = zr.extendSubschemaData = zr.getSubschema = void 0;
const ar = ae, Xb = re;
function nT(e, { keyword: t, schemaProp: r, schema: n, schemaPath: s, errSchemaPath: i, topSchemaRef: o }) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const a = e.schema[t];
    return r === void 0 ? {
      schema: a,
<<<<<<< HEAD
      schemaPath: (0, Xr._)`${e.schemaPath}${(0, Xr.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: a[r],
      schemaPath: (0, Xr._)`${e.schemaPath}${(0, Xr.getProperty)(t)}${(0, Xr.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, fR.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (i === void 0 || s === void 0 || o === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: i,
      topSchemaRef: o,
      errSchemaPath: s
=======
      schemaPath: (0, ar._)`${e.schemaPath}${(0, ar.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: a[r],
      schemaPath: (0, ar._)`${e.schemaPath}${(0, ar.getProperty)(t)}${(0, ar.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, Xb.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (s === void 0 || i === void 0 || o === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: s,
      topSchemaRef: o,
      errSchemaPath: i
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
<<<<<<< HEAD
Wn.getSubschema = rL;
function nL(e, t, { dataProp: r, dataPropType: n, data: i, dataTypes: s, propertyName: o }) {
  if (i !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = t;
  if (r !== void 0) {
    const { errorPath: u, dataPathArr: l, opts: f } = t, m = a.let("data", (0, Xr._)`${t.data}${(0, Xr.getProperty)(r)}`, !0);
    c(m), e.errorPath = (0, Xr.str)`${u}${(0, fR.getErrorPath)(r, n, f.jsPropertySyntax)}`, e.parentDataProperty = (0, Xr._)`${r}`, e.dataPathArr = [...l, e.parentDataProperty];
  }
  if (i !== void 0) {
    const u = i instanceof Xr.Name ? i : a.let("data", i, !0);
    c(u), o !== void 0 && (e.propertyName = o);
  }
  s && (e.dataTypes = s);
  function c(u) {
    e.data = u, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, u];
  }
}
Wn.extendSubschemaData = nL;
function iL(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: i, allErrors: s }) {
  n !== void 0 && (e.compositeRule = n), i !== void 0 && (e.createErrors = i), s !== void 0 && (e.allErrors = s), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
Wn.extendSubschemaMode = iL;
var Nt = {}, ju = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var n, i, s;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length) return !1;
      for (i = n; i-- !== 0; )
        if (!e(t[i], r[i])) return !1;
=======
zr.getSubschema = nT;
function sT(e, t, { dataProp: r, dataPropType: n, data: s, dataTypes: i, propertyName: o }) {
  if (s !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = t;
  if (r !== void 0) {
    const { errorPath: f, dataPathArr: l, opts: d } = t, g = a.let("data", (0, ar._)`${t.data}${(0, ar.getProperty)(r)}`, !0);
    c(g), e.errorPath = (0, ar.str)`${f}${(0, Xb.getErrorPath)(r, n, d.jsPropertySyntax)}`, e.parentDataProperty = (0, ar._)`${r}`, e.dataPathArr = [...l, e.parentDataProperty];
  }
  if (s !== void 0) {
    const f = s instanceof ar.Name ? s : a.let("data", s, !0);
    c(f), o !== void 0 && (e.propertyName = o);
  }
  i && (e.dataTypes = i);
  function c(f) {
    e.data = f, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, f];
  }
}
zr.extendSubschemaData = sT;
function iT(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: s, allErrors: i }) {
  n !== void 0 && (e.compositeRule = n), s !== void 0 && (e.createErrors = s), i !== void 0 && (e.allErrors = i), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
zr.extendSubschemaMode = iT;
var ft = {}, ba = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var n, s, i;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length) return !1;
      for (s = n; s-- !== 0; )
        if (!e(t[s], r[s])) return !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return !0;
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
<<<<<<< HEAD
    if (s = Object.keys(t), n = s.length, n !== Object.keys(r).length) return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, s[i])) return !1;
    for (i = n; i-- !== 0; ) {
      var o = s[i];
=======
    if (i = Object.keys(t), n = i.length, n !== Object.keys(r).length) return !1;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, i[s])) return !1;
    for (s = n; s-- !== 0; ) {
      var o = i[s];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (!e(t[o], r[o])) return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
<<<<<<< HEAD
}, dR = { exports: {} }, qn = dR.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, i = r.post || function() {
  };
  dl(t, n, i, e, "", e);
};
qn.keywords = {
=======
}, Zb = { exports: {} }, Dr = Zb.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, s = r.post || function() {
  };
  po(t, n, s, e, "", e);
};
Dr.keywords = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
<<<<<<< HEAD
qn.arrayKeywords = {
=======
Dr.arrayKeywords = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
<<<<<<< HEAD
qn.propsKeywords = {
=======
Dr.propsKeywords = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
<<<<<<< HEAD
qn.skipKeywords = {
=======
Dr.skipKeywords = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
<<<<<<< HEAD
function dl(e, t, r, n, i, s, o, a, c, u) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, i, s, o, a, c, u);
    for (var l in n) {
      var f = n[l];
      if (Array.isArray(f)) {
        if (l in qn.arrayKeywords)
          for (var m = 0; m < f.length; m++)
            dl(e, t, r, f[m], i + "/" + l + "/" + m, s, i, l, n, m);
      } else if (l in qn.propsKeywords) {
        if (f && typeof f == "object")
          for (var p in f)
            dl(e, t, r, f[p], i + "/" + l + "/" + sL(p), s, i, l, n, p);
      } else (l in qn.keywords || e.allKeys && !(l in qn.skipKeywords)) && dl(e, t, r, f, i + "/" + l, s, i, l, n);
    }
    r(n, i, s, o, a, c, u);
  }
}
function sL(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var oL = dR.exports;
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.getSchemaRefs = Nt.resolveUrl = Nt.normalizeId = Nt._getFullPath = Nt.getFullPath = Nt.inlineRef = void 0;
const aL = se, cL = ju, lL = oL, uL = /* @__PURE__ */ new Set([
=======
function po(e, t, r, n, s, i, o, a, c, f) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, s, i, o, a, c, f);
    for (var l in n) {
      var d = n[l];
      if (Array.isArray(d)) {
        if (l in Dr.arrayKeywords)
          for (var g = 0; g < d.length; g++)
            po(e, t, r, d[g], s + "/" + l + "/" + g, i, s, l, n, g);
      } else if (l in Dr.propsKeywords) {
        if (d && typeof d == "object")
          for (var p in d)
            po(e, t, r, d[p], s + "/" + l + "/" + oT(p), i, s, l, n, p);
      } else (l in Dr.keywords || e.allKeys && !(l in Dr.skipKeywords)) && po(e, t, r, d, s + "/" + l, i, s, l, n);
    }
    r(n, s, i, o, a, c, f);
  }
}
function oT(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var aT = Zb.exports;
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.getSchemaRefs = ft.resolveUrl = ft.normalizeId = ft._getFullPath = ft.getFullPath = ft.inlineRef = void 0;
const cT = re, lT = ba, uT = aT, fT = /* @__PURE__ */ new Set([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
<<<<<<< HEAD
function fL(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !bh(e) : t ? pR(e) <= t : !1;
}
Nt.inlineRef = fL;
const dL = /* @__PURE__ */ new Set([
=======
function dT(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !mu(e) : t ? Qb(e) <= t : !1;
}
ft.inlineRef = dT;
const pT = /* @__PURE__ */ new Set([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
<<<<<<< HEAD
function bh(e) {
  for (const t in e) {
    if (dL.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(bh) || typeof r == "object" && bh(r))
=======
function mu(e) {
  for (const t in e) {
    if (pT.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(mu) || typeof r == "object" && mu(r))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return !0;
  }
  return !1;
}
<<<<<<< HEAD
function pR(e) {
=======
function Qb(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
<<<<<<< HEAD
    if (t++, !uL.has(r) && (typeof e[r] == "object" && (0, aL.eachItem)(e[r], (n) => t += pR(n)), t === 1 / 0))
=======
    if (t++, !fT.has(r) && (typeof e[r] == "object" && (0, cT.eachItem)(e[r], (n) => t += Qb(n)), t === 1 / 0))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return 1 / 0;
  }
  return t;
}
<<<<<<< HEAD
function hR(e, t = "", r) {
  r !== !1 && (t = Ns(t));
  const n = e.parse(t);
  return mR(e, n);
}
Nt.getFullPath = hR;
function mR(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
Nt._getFullPath = mR;
const pL = /#\/?$/;
function Ns(e) {
  return e ? e.replace(pL, "") : "";
}
Nt.normalizeId = Ns;
function hL(e, t, r) {
  return r = Ns(r), e.resolve(t, r);
}
Nt.resolveUrl = hL;
const mL = /^[a-z_][-a-z0-9._]*$/i;
function gL(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, i = Ns(e[r] || t), s = { "": i }, o = hR(n, i, !1), a = {}, c = /* @__PURE__ */ new Set();
  return lL(e, { allKeys: !0 }, (f, m, p, d) => {
    if (d === void 0)
      return;
    const h = o + m;
    let _ = s[d];
    typeof f[r] == "string" && (_ = g.call(this, f[r])), v.call(this, f.$anchor), v.call(this, f.$dynamicAnchor), s[m] = _;
    function g(y) {
      const E = this.opts.uriResolver.resolve;
      if (y = Ns(_ ? E(_, y) : y), c.has(y))
        throw l(y);
      c.add(y);
      let R = this.refs[y];
      return typeof R == "string" && (R = this.refs[R]), typeof R == "object" ? u(f, R.schema, y) : y !== Ns(h) && (y[0] === "#" ? (u(f, a[y], y), a[y] = f) : this.refs[y] = h), y;
    }
    function v(y) {
      if (typeof y == "string") {
        if (!mL.test(y))
          throw new Error(`invalid anchor "${y}"`);
        g.call(this, `#${y}`);
      }
    }
  }), a;
  function u(f, m, p) {
    if (m !== void 0 && !cL(f, m))
      throw l(p);
  }
  function l(f) {
    return new Error(`reference "${f}" resolves to more than one schema`);
  }
}
Nt.getSchemaRefs = gL;
Object.defineProperty(Pr, "__esModule", { value: !0 });
Pr.getData = Pr.KeywordCxt = Pr.validateFunctionCode = void 0;
const gR = Ms, k0 = yt, qm = mn, Ml = yt, yL = Fu, Ko = Zr, Pd = Wn, ue = he, ge = _r, vL = Nt, gn = se, So = Ba;
function _L(e) {
  if (_R(e) && (bR(e), vR(e))) {
    wL(e);
    return;
  }
  yR(e, () => (0, gR.topBoolOrEmptySchema)(e));
}
Pr.validateFunctionCode = _L;
function yR({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: i }, s) {
  i.code.es5 ? e.func(t, (0, ue._)`${ge.default.data}, ${ge.default.valCxt}`, n.$async, () => {
    e.code((0, ue._)`"use strict"; ${D0(r, i)}`), EL(e, i), e.code(s);
  }) : e.func(t, (0, ue._)`${ge.default.data}, ${bL(i)}`, n.$async, () => e.code(D0(r, i)).code(s));
}
function bL(e) {
  return (0, ue._)`{${ge.default.instancePath}="", ${ge.default.parentData}, ${ge.default.parentDataProperty}, ${ge.default.rootData}=${ge.default.data}${e.dynamicRef ? (0, ue._)`, ${ge.default.dynamicAnchors}={}` : ue.nil}}={}`;
}
function EL(e, t) {
  e.if(ge.default.valCxt, () => {
    e.var(ge.default.instancePath, (0, ue._)`${ge.default.valCxt}.${ge.default.instancePath}`), e.var(ge.default.parentData, (0, ue._)`${ge.default.valCxt}.${ge.default.parentData}`), e.var(ge.default.parentDataProperty, (0, ue._)`${ge.default.valCxt}.${ge.default.parentDataProperty}`), e.var(ge.default.rootData, (0, ue._)`${ge.default.valCxt}.${ge.default.rootData}`), t.dynamicRef && e.var(ge.default.dynamicAnchors, (0, ue._)`${ge.default.valCxt}.${ge.default.dynamicAnchors}`);
  }, () => {
    e.var(ge.default.instancePath, (0, ue._)`""`), e.var(ge.default.parentData, (0, ue._)`undefined`), e.var(ge.default.parentDataProperty, (0, ue._)`undefined`), e.var(ge.default.rootData, ge.default.data), t.dynamicRef && e.var(ge.default.dynamicAnchors, (0, ue._)`{}`);
  });
}
function wL(e) {
  const { schema: t, opts: r, gen: n } = e;
  yR(e, () => {
    r.$comment && t.$comment && wR(e), TL(e), n.let(ge.default.vErrors, null), n.let(ge.default.errors, 0), r.unevaluated && SL(e), ER(e), CL(e);
  });
}
function SL(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, ue._)`${r}.evaluated`), t.if((0, ue._)`${e.evaluated}.dynamicProps`, () => t.assign((0, ue._)`${e.evaluated}.props`, (0, ue._)`undefined`)), t.if((0, ue._)`${e.evaluated}.dynamicItems`, () => t.assign((0, ue._)`${e.evaluated}.items`, (0, ue._)`undefined`));
}
function D0(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, ue._)`/*# sourceURL=${r} */` : ue.nil;
}
function xL(e, t) {
  if (_R(e) && (bR(e), vR(e))) {
    RL(e, t);
    return;
  }
  (0, gR.boolOrEmptySchema)(e, t);
}
function vR({ schema: e, self: t }) {
=======
function e0(e, t = "", r) {
  r !== !1 && (t = Hn(t));
  const n = e.parse(t);
  return t0(e, n);
}
ft.getFullPath = e0;
function t0(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
ft._getFullPath = t0;
const hT = /#\/?$/;
function Hn(e) {
  return e ? e.replace(hT, "") : "";
}
ft.normalizeId = Hn;
function mT(e, t, r) {
  return r = Hn(r), e.resolve(t, r);
}
ft.resolveUrl = mT;
const yT = /^[a-z_][-a-z0-9._]*$/i;
function gT(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, s = Hn(e[r] || t), i = { "": s }, o = e0(n, s, !1), a = {}, c = /* @__PURE__ */ new Set();
  return uT(e, { allKeys: !0 }, (d, g, p, u) => {
    if (u === void 0)
      return;
    const h = o + g;
    let b = i[u];
    typeof d[r] == "string" && (b = m.call(this, d[r])), v.call(this, d.$anchor), v.call(this, d.$dynamicAnchor), i[g] = b;
    function m(y) {
      const _ = this.opts.uriResolver.resolve;
      if (y = Hn(b ? _(b, y) : y), c.has(y))
        throw l(y);
      c.add(y);
      let R = this.refs[y];
      return typeof R == "string" && (R = this.refs[R]), typeof R == "object" ? f(d, R.schema, y) : y !== Hn(h) && (y[0] === "#" ? (f(d, a[y], y), a[y] = d) : this.refs[y] = h), y;
    }
    function v(y) {
      if (typeof y == "string") {
        if (!yT.test(y))
          throw new Error(`invalid anchor "${y}"`);
        m.call(this, `#${y}`);
      }
    }
  }), a;
  function f(d, g, p) {
    if (g !== void 0 && !lT(d, g))
      throw l(p);
  }
  function l(d) {
    return new Error(`reference "${d}" resolves to more than one schema`);
  }
}
ft.getSchemaRefs = gT;
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.getData = Ut.KeywordCxt = Ut.validateFunctionCode = void 0;
const r0 = Kn, qh = tt, Rf = br, Do = tt, vT = va, js = cr, Vc = zr, ie = ae, ue = jt, bT = ft, _r = re, gs = di;
function _T(e) {
  if (i0(e) && (o0(e), s0(e))) {
    xT(e);
    return;
  }
  n0(e, () => (0, r0.topBoolOrEmptySchema)(e));
}
Ut.validateFunctionCode = _T;
function n0({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: s }, i) {
  s.code.es5 ? e.func(t, (0, ie._)`${ue.default.data}, ${ue.default.valCxt}`, n.$async, () => {
    e.code((0, ie._)`"use strict"; ${Hh(r, s)}`), ST(e, s), e.code(i);
  }) : e.func(t, (0, ie._)`${ue.default.data}, ${ET(s)}`, n.$async, () => e.code(Hh(r, s)).code(i));
}
function ET(e) {
  return (0, ie._)`{${ue.default.instancePath}="", ${ue.default.parentData}, ${ue.default.parentDataProperty}, ${ue.default.rootData}=${ue.default.data}${e.dynamicRef ? (0, ie._)`, ${ue.default.dynamicAnchors}={}` : ie.nil}}={}`;
}
function ST(e, t) {
  e.if(ue.default.valCxt, () => {
    e.var(ue.default.instancePath, (0, ie._)`${ue.default.valCxt}.${ue.default.instancePath}`), e.var(ue.default.parentData, (0, ie._)`${ue.default.valCxt}.${ue.default.parentData}`), e.var(ue.default.parentDataProperty, (0, ie._)`${ue.default.valCxt}.${ue.default.parentDataProperty}`), e.var(ue.default.rootData, (0, ie._)`${ue.default.valCxt}.${ue.default.rootData}`), t.dynamicRef && e.var(ue.default.dynamicAnchors, (0, ie._)`${ue.default.valCxt}.${ue.default.dynamicAnchors}`);
  }, () => {
    e.var(ue.default.instancePath, (0, ie._)`""`), e.var(ue.default.parentData, (0, ie._)`undefined`), e.var(ue.default.parentDataProperty, (0, ie._)`undefined`), e.var(ue.default.rootData, ue.default.data), t.dynamicRef && e.var(ue.default.dynamicAnchors, (0, ie._)`{}`);
  });
}
function xT(e) {
  const { schema: t, opts: r, gen: n } = e;
  n0(e, () => {
    r.$comment && t.$comment && c0(e), OT(e), n.let(ue.default.vErrors, null), n.let(ue.default.errors, 0), r.unevaluated && wT(e), a0(e), IT(e);
  });
}
function wT(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, ie._)`${r}.evaluated`), t.if((0, ie._)`${e.evaluated}.dynamicProps`, () => t.assign((0, ie._)`${e.evaluated}.props`, (0, ie._)`undefined`)), t.if((0, ie._)`${e.evaluated}.dynamicItems`, () => t.assign((0, ie._)`${e.evaluated}.items`, (0, ie._)`undefined`));
}
function Hh(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, ie._)`/*# sourceURL=${r} */` : ie.nil;
}
function RT(e, t) {
  if (i0(e) && (o0(e), s0(e))) {
    $T(e, t);
    return;
  }
  (0, r0.boolOrEmptySchema)(e, t);
}
function s0({ schema: e, self: t }) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
<<<<<<< HEAD
function _R(e) {
  return typeof e.schema != "boolean";
}
function RL(e, t) {
  const { schema: r, gen: n, opts: i } = e;
  i.$comment && r.$comment && wR(e), OL(e), PL(e);
  const s = n.const("_errs", ge.default.errors);
  ER(e, s), n.var(t, (0, ue._)`${s} === ${ge.default.errors}`);
}
function bR(e) {
  (0, gn.checkUnknownRules)(e), $L(e);
}
function ER(e, t) {
  if (e.opts.jtd)
    return L0(e, [], !1, t);
  const r = (0, k0.getSchemaTypes)(e.schema), n = (0, k0.coerceAndCheckDataType)(e, r);
  L0(e, r, !n, t);
}
function $L(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: i } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, gn.schemaHasRulesButRef)(t, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function TL(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, gn.checkStrictMode)(e, "default is ignored in the schema root");
}
function OL(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, vL.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function PL(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function wR({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: i }) {
  const s = r.$comment;
  if (i.$comment === !0)
    e.code((0, ue._)`${ge.default.self}.logger.log(${s})`);
  else if (typeof i.$comment == "function") {
    const o = (0, ue.str)`${n}/$comment`, a = e.scopeValue("root", { ref: t.root });
    e.code((0, ue._)`${ge.default.self}.opts.$comment(${s}, ${o}, ${a}.schema)`);
  }
}
function CL(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: i, opts: s } = e;
  r.$async ? t.if((0, ue._)`${ge.default.errors} === 0`, () => t.return(ge.default.data), () => t.throw((0, ue._)`new ${i}(${ge.default.vErrors})`)) : (t.assign((0, ue._)`${n}.errors`, ge.default.vErrors), s.unevaluated && AL(e), t.return((0, ue._)`${ge.default.errors} === 0`));
}
function AL({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof ue.Name && e.assign((0, ue._)`${t}.props`, r), n instanceof ue.Name && e.assign((0, ue._)`${t}.items`, n);
}
function L0(e, t, r, n) {
  const { gen: i, schema: s, data: o, allErrors: a, opts: c, self: u } = e, { RULES: l } = u;
  if (s.$ref && (c.ignoreKeywordsWithRef || !(0, gn.schemaHasRulesButRef)(s, l))) {
    i.block(() => RR(e, "$ref", l.all.$ref.definition));
    return;
  }
  c.jtd || IL(e, t), i.block(() => {
    for (const m of l.rules)
      f(m);
    f(l.post);
  });
  function f(m) {
    (0, qm.shouldUseGroup)(s, m) && (m.type ? (i.if((0, Ml.checkDataType)(m.type, o, c.strictNumbers)), F0(e, m), t.length === 1 && t[0] === m.type && r && (i.else(), (0, Ml.reportTypeError)(e)), i.endIf()) : F0(e, m), a || i.if((0, ue._)`${ge.default.errors} === ${n || 0}`));
  }
}
function F0(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: i } } = e;
  i && (0, yL.assignDefaults)(e, t.type), r.block(() => {
    for (const s of t.rules)
      (0, qm.shouldUseRule)(n, s) && RR(e, s.keyword, s.definition, t.type);
  });
}
function IL(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (NL(e, t), e.opts.allowUnionTypes || kL(e, t), DL(e, e.dataTypes));
}
function NL(e, t) {
=======
function i0(e) {
  return typeof e.schema != "boolean";
}
function $T(e, t) {
  const { schema: r, gen: n, opts: s } = e;
  s.$comment && r.$comment && c0(e), CT(e), PT(e);
  const i = n.const("_errs", ue.default.errors);
  a0(e, i), n.var(t, (0, ie._)`${i} === ${ue.default.errors}`);
}
function o0(e) {
  (0, _r.checkUnknownRules)(e), TT(e);
}
function a0(e, t) {
  if (e.opts.jtd)
    return Bh(e, [], !1, t);
  const r = (0, qh.getSchemaTypes)(e.schema), n = (0, qh.coerceAndCheckDataType)(e, r);
  Bh(e, r, !n, t);
}
function TT(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: s } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, _r.schemaHasRulesButRef)(t, s.RULES) && s.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function OT(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, _r.checkStrictMode)(e, "default is ignored in the schema root");
}
function CT(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, bT.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function PT(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function c0({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: s }) {
  const i = r.$comment;
  if (s.$comment === !0)
    e.code((0, ie._)`${ue.default.self}.logger.log(${i})`);
  else if (typeof s.$comment == "function") {
    const o = (0, ie.str)`${n}/$comment`, a = e.scopeValue("root", { ref: t.root });
    e.code((0, ie._)`${ue.default.self}.opts.$comment(${i}, ${o}, ${a}.schema)`);
  }
}
function IT(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: s, opts: i } = e;
  r.$async ? t.if((0, ie._)`${ue.default.errors} === 0`, () => t.return(ue.default.data), () => t.throw((0, ie._)`new ${s}(${ue.default.vErrors})`)) : (t.assign((0, ie._)`${n}.errors`, ue.default.vErrors), i.unevaluated && NT(e), t.return((0, ie._)`${ue.default.errors} === 0`));
}
function NT({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof ie.Name && e.assign((0, ie._)`${t}.props`, r), n instanceof ie.Name && e.assign((0, ie._)`${t}.items`, n);
}
function Bh(e, t, r, n) {
  const { gen: s, schema: i, data: o, allErrors: a, opts: c, self: f } = e, { RULES: l } = f;
  if (i.$ref && (c.ignoreKeywordsWithRef || !(0, _r.schemaHasRulesButRef)(i, l))) {
    s.block(() => f0(e, "$ref", l.all.$ref.definition));
    return;
  }
  c.jtd || AT(e, t), s.block(() => {
    for (const g of l.rules)
      d(g);
    d(l.post);
  });
  function d(g) {
    (0, Rf.shouldUseGroup)(i, g) && (g.type ? (s.if((0, Do.checkDataType)(g.type, o, c.strictNumbers)), Vh(e, g), t.length === 1 && t[0] === g.type && r && (s.else(), (0, Do.reportTypeError)(e)), s.endIf()) : Vh(e, g), a || s.if((0, ie._)`${ue.default.errors} === ${n || 0}`));
  }
}
function Vh(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: s } } = e;
  s && (0, vT.assignDefaults)(e, t.type), r.block(() => {
    for (const i of t.rules)
      (0, Rf.shouldUseRule)(n, i) && f0(e, i.keyword, i.definition, t.type);
  });
}
function AT(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (kT(e, t), e.opts.allowUnionTypes || LT(e, t), jT(e, e.dataTypes));
}
function kT(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
<<<<<<< HEAD
      SR(e.dataTypes, r) || Bm(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), FL(e, t);
  }
}
function kL(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && Bm(e, "use allowUnionTypes to allow union type keyword");
}
function DL(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const i = r[n];
    if (typeof i == "object" && (0, qm.shouldUseRule)(e.schema, i)) {
      const { type: s } = i.definition;
      s.length && !s.some((o) => LL(t, o)) && Bm(e, `missing type "${s.join(",")}" for keyword "${n}"`);
    }
  }
}
function LL(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function SR(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function FL(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    SR(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function Bm(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, gn.checkStrictMode)(e, t, e.opts.strictTypes);
}
class xR {
  constructor(t, r, n) {
    if ((0, Ko.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, gn.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", $R(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Ko.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", ge.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, ue.not)(t), r, n);
=======
      l0(e.dataTypes, r) || $f(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), FT(e, t);
  }
}
function LT(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && $f(e, "use allowUnionTypes to allow union type keyword");
}
function jT(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const s = r[n];
    if (typeof s == "object" && (0, Rf.shouldUseRule)(e.schema, s)) {
      const { type: i } = s.definition;
      i.length && !i.some((o) => DT(t, o)) && $f(e, `missing type "${i.join(",")}" for keyword "${n}"`);
    }
  }
}
function DT(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function l0(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function FT(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    l0(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function $f(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, _r.checkStrictMode)(e, t, e.opts.strictTypes);
}
class u0 {
  constructor(t, r, n) {
    if ((0, js.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, _r.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", d0(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, js.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", ue.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, ie.not)(t), r, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
<<<<<<< HEAD
    this.failResult((0, ue.not)(t), void 0, r);
=======
    this.failResult((0, ie.not)(t), void 0, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
<<<<<<< HEAD
    this.fail((0, ue._)`${r} !== undefined && (${(0, ue.or)(this.invalid$data(), t)})`);
=======
    this.fail((0, ie._)`${r} !== undefined && (${(0, ie.or)(this.invalid$data(), t)})`);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
<<<<<<< HEAD
    (t ? So.reportExtraError : So.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, So.reportError)(this, this.def.$dataError || So.keyword$DataError);
=======
    (t ? gs.reportExtraError : gs.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, gs.reportError)(this, this.def.$dataError || gs.keyword$DataError);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
<<<<<<< HEAD
    (0, So.resetErrorsCount)(this.gen, this.errsCount);
=======
    (0, gs.resetErrorsCount)(this.gen, this.errsCount);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
<<<<<<< HEAD
  block$data(t, r, n = ue.nil) {
=======
  block$data(t, r, n = ie.nil) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
<<<<<<< HEAD
  check$data(t = ue.nil, r = ue.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: i, schemaType: s, def: o } = this;
    n.if((0, ue.or)((0, ue._)`${i} === undefined`, r)), t !== ue.nil && n.assign(t, !0), (s.length || o.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== ue.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: i, it: s } = this;
    return (0, ue.or)(o(), a());
    function o() {
      if (n.length) {
        if (!(r instanceof ue.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(n) ? n : [n];
        return (0, ue._)`${(0, Ml.checkDataTypes)(c, r, s.opts.strictNumbers, Ml.DataType.Wrong)}`;
      }
      return ue.nil;
    }
    function a() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, ue._)`!${c}(${r})`;
      }
      return ue.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Pd.getSubschema)(this.it, t);
    (0, Pd.extendSubschemaData)(n, this.it, t), (0, Pd.extendSubschemaMode)(n, t);
    const i = { ...this.it, ...n, items: void 0, props: void 0 };
    return xL(i, r), i;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: i } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = gn.mergeEvaluated.props(i, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = gn.mergeEvaluated.items(i, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: i } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return i.if(r, () => this.mergeEvaluated(t, ue.Name)), !0;
  }
}
Pr.KeywordCxt = xR;
function RR(e, t, r, n) {
  const i = new xR(e, r, t);
  "code" in r ? r.code(i, n) : i.$data && r.validate ? (0, Ko.funcKeywordCode)(i, r) : "macro" in r ? (0, Ko.macroKeywordCode)(i, r) : (r.compile || r.validate) && (0, Ko.funcKeywordCode)(i, r);
}
const jL = /^\/(?:[^~]|~0|~1)*$/, UL = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function $R(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let i, s;
  if (e === "")
    return ge.default.rootData;
  if (e[0] === "/") {
    if (!jL.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    i = e, s = ge.default.rootData;
  } else {
    const u = UL.exec(e);
    if (!u)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const l = +u[1];
    if (i = u[2], i === "#") {
=======
  check$data(t = ie.nil, r = ie.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: s, schemaType: i, def: o } = this;
    n.if((0, ie.or)((0, ie._)`${s} === undefined`, r)), t !== ie.nil && n.assign(t, !0), (i.length || o.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== ie.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: s, it: i } = this;
    return (0, ie.or)(o(), a());
    function o() {
      if (n.length) {
        if (!(r instanceof ie.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(n) ? n : [n];
        return (0, ie._)`${(0, Do.checkDataTypes)(c, r, i.opts.strictNumbers, Do.DataType.Wrong)}`;
      }
      return ie.nil;
    }
    function a() {
      if (s.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: s.validateSchema });
        return (0, ie._)`!${c}(${r})`;
      }
      return ie.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Vc.getSubschema)(this.it, t);
    (0, Vc.extendSubschemaData)(n, this.it, t), (0, Vc.extendSubschemaMode)(n, t);
    const s = { ...this.it, ...n, items: void 0, props: void 0 };
    return RT(s, r), s;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: s } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = _r.mergeEvaluated.props(s, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = _r.mergeEvaluated.items(s, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: s } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return s.if(r, () => this.mergeEvaluated(t, ie.Name)), !0;
  }
}
Ut.KeywordCxt = u0;
function f0(e, t, r, n) {
  const s = new u0(e, r, t);
  "code" in r ? r.code(s, n) : s.$data && r.validate ? (0, js.funcKeywordCode)(s, r) : "macro" in r ? (0, js.macroKeywordCode)(s, r) : (r.compile || r.validate) && (0, js.funcKeywordCode)(s, r);
}
const MT = /^\/(?:[^~]|~0|~1)*$/, zT = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function d0(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let s, i;
  if (e === "")
    return ue.default.rootData;
  if (e[0] === "/") {
    if (!MT.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    s = e, i = ue.default.rootData;
  } else {
    const f = zT.exec(e);
    if (!f)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const l = +f[1];
    if (s = f[2], s === "#") {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (l >= t)
        throw new Error(c("property/index", l));
      return n[t - l];
    }
    if (l > t)
      throw new Error(c("data", l));
<<<<<<< HEAD
    if (s = r[t - l], !i)
      return s;
  }
  let o = s;
  const a = i.split("/");
  for (const u of a)
    u && (s = (0, ue._)`${s}${(0, ue.getProperty)((0, gn.unescapeJsonPointer)(u))}`, o = (0, ue._)`${o} && ${s}`);
  return o;
  function c(u, l) {
    return `Cannot access ${u} ${l} levels up, current level is ${t}`;
  }
}
Pr.getData = $R;
var to = {};
Object.defineProperty(to, "__esModule", { value: !0 });
class ML extends Error {
=======
    if (i = r[t - l], !s)
      return i;
  }
  let o = i;
  const a = s.split("/");
  for (const f of a)
    f && (i = (0, ie._)`${i}${(0, ie.getProperty)((0, _r.unescapeJsonPointer)(f))}`, o = (0, ie._)`${o} && ${i}`);
  return o;
  function c(f, l) {
    return `Cannot access ${f} ${l} levels up, current level is ${t}`;
  }
}
Ut.getData = d0;
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
class UT extends Error {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
<<<<<<< HEAD
to.default = ML;
var on = {};
Object.defineProperty(on, "__esModule", { value: !0 });
const Cd = Nt;
class HL extends Error {
  constructor(t, r, n, i) {
    super(i || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, Cd.resolveUrl)(t, r, n), this.missingSchema = (0, Cd.normalizeId)((0, Cd.getFullPath)(t, this.missingRef));
  }
}
on.default = HL;
var kt = {};
Object.defineProperty(kt, "__esModule", { value: !0 });
kt.resolveSchema = kt.getCompilingSchema = kt.resolveRef = kt.compileSchema = kt.SchemaEnv = void 0;
const Dr = he, qL = to, di = _r, Ur = Nt, j0 = se, BL = Pr;
class Uu {
=======
is.default = UT;
var mr = {};
Object.defineProperty(mr, "__esModule", { value: !0 });
const Gc = ft;
class qT extends Error {
  constructor(t, r, n, s) {
    super(s || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, Gc.resolveUrl)(t, r, n), this.missingSchema = (0, Gc.normalizeId)((0, Gc.getFullPath)(t, this.missingRef));
  }
}
mr.default = qT;
var dt = {};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.resolveSchema = dt.getCompilingSchema = dt.resolveRef = dt.compileSchema = dt.SchemaEnv = void 0;
const Gt = ae, HT = is, Gr = jt, Jt = ft, Gh = re, BT = Ut;
class _a {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
<<<<<<< HEAD
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Ur.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
kt.SchemaEnv = Uu;
function zm(e) {
  const t = TR.call(this, e);
  if (t)
    return t;
  const r = (0, Ur.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new Dr.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s });
  let a;
  e.$async && (a = o.scopeValue("Error", {
    ref: qL.default,
    code: (0, Dr._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = o.scopeName("validate");
  e.validateName = c;
  const u = {
    gen: o,
    allErrors: this.opts.allErrors,
    data: di.default.data,
    parentData: di.default.parentData,
    parentDataProperty: di.default.parentDataProperty,
    dataNames: [di.default.data],
    dataPathArr: [Dr.nil],
=======
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Jt.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
dt.SchemaEnv = _a;
function Tf(e) {
  const t = p0.call(this, e);
  if (t)
    return t;
  const r = (0, Jt.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, o = new Gt.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i });
  let a;
  e.$async && (a = o.scopeValue("Error", {
    ref: HT.default,
    code: (0, Gt._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = o.scopeName("validate");
  e.validateName = c;
  const f = {
    gen: o,
    allErrors: this.opts.allErrors,
    data: Gr.default.data,
    parentData: Gr.default.parentData,
    parentDataProperty: Gr.default.parentDataProperty,
    dataNames: [Gr.default.data],
    dataPathArr: [Gt.nil],
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
<<<<<<< HEAD
    topSchemaRef: o.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, Dr.stringify)(e.schema) } : { ref: e.schema }),
=======
    topSchemaRef: o.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, Gt.stringify)(e.schema) } : { ref: e.schema }),
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    validateName: c,
    ValidationError: a,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
<<<<<<< HEAD
    schemaPath: Dr.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Dr._)`""`,
=======
    schemaPath: Gt.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Gt._)`""`,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    opts: this.opts,
    self: this
  };
  let l;
  try {
<<<<<<< HEAD
    this._compilations.add(e), (0, BL.validateFunctionCode)(u), o.optimize(this.opts.code.optimize);
    const f = o.toString();
    l = `${o.scopeRefs(di.default.scope)}return ${f}`, this.opts.code.process && (l = this.opts.code.process(l, e));
    const p = new Function(`${di.default.self}`, `${di.default.scope}`, l)(this, this.scope.get());
    if (this.scope.value(c, { ref: p }), p.errors = null, p.schema = e.schema, p.schemaEnv = e, e.$async && (p.$async = !0), this.opts.code.source === !0 && (p.source = { validateName: c, validateCode: f, scopeValues: o._values }), this.opts.unevaluated) {
      const { props: d, items: h } = u;
      p.evaluated = {
        props: d instanceof Dr.Name ? void 0 : d,
        items: h instanceof Dr.Name ? void 0 : h,
        dynamicProps: d instanceof Dr.Name,
        dynamicItems: h instanceof Dr.Name
      }, p.source && (p.source.evaluated = (0, Dr.stringify)(p.evaluated));
    }
    return e.validate = p, e;
  } catch (f) {
    throw delete e.validate, delete e.validateName, l && this.logger.error("Error compiling schema, function code:", l), f;
=======
    this._compilations.add(e), (0, BT.validateFunctionCode)(f), o.optimize(this.opts.code.optimize);
    const d = o.toString();
    l = `${o.scopeRefs(Gr.default.scope)}return ${d}`, this.opts.code.process && (l = this.opts.code.process(l, e));
    const p = new Function(`${Gr.default.self}`, `${Gr.default.scope}`, l)(this, this.scope.get());
    if (this.scope.value(c, { ref: p }), p.errors = null, p.schema = e.schema, p.schemaEnv = e, e.$async && (p.$async = !0), this.opts.code.source === !0 && (p.source = { validateName: c, validateCode: d, scopeValues: o._values }), this.opts.unevaluated) {
      const { props: u, items: h } = f;
      p.evaluated = {
        props: u instanceof Gt.Name ? void 0 : u,
        items: h instanceof Gt.Name ? void 0 : h,
        dynamicProps: u instanceof Gt.Name,
        dynamicItems: h instanceof Gt.Name
      }, p.source && (p.source.evaluated = (0, Gt.stringify)(p.evaluated));
    }
    return e.validate = p, e;
  } catch (d) {
    throw delete e.validate, delete e.validateName, l && this.logger.error("Error compiling schema, function code:", l), d;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } finally {
    this._compilations.delete(e);
  }
}
<<<<<<< HEAD
kt.compileSchema = zm;
function zL(e, t, r) {
  var n;
  r = (0, Ur.resolveUrl)(this.opts.uriResolver, t, r);
  const i = e.refs[r];
  if (i)
    return i;
  let s = WL.call(this, e, r);
  if (s === void 0) {
    const o = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: a } = this.opts;
    o && (s = new Uu({ schema: o, schemaId: a, root: e, baseId: t }));
  }
  if (s !== void 0)
    return e.refs[r] = VL.call(this, s);
}
kt.resolveRef = zL;
function VL(e) {
  return (0, Ur.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : zm.call(this, e);
}
function TR(e) {
  for (const t of this._compilations)
    if (GL(t, e))
      return t;
}
kt.getCompilingSchema = TR;
function GL(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function WL(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Mu.call(this, e, t);
}
function Mu(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, Ur._getFullPath)(this.opts.uriResolver, r);
  let i = (0, Ur.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === i)
    return Ad.call(this, r, e);
  const s = (0, Ur.normalizeId)(n), o = this.refs[s] || this.schemas[s];
  if (typeof o == "string") {
    const a = Mu.call(this, e, o);
    return typeof (a == null ? void 0 : a.schema) != "object" ? void 0 : Ad.call(this, r, a);
  }
  if (typeof (o == null ? void 0 : o.schema) == "object") {
    if (o.validate || zm.call(this, o), s === (0, Ur.normalizeId)(t)) {
      const { schema: a } = o, { schemaId: c } = this.opts, u = a[c];
      return u && (i = (0, Ur.resolveUrl)(this.opts.uriResolver, i, u)), new Uu({ schema: a, schemaId: c, root: e, baseId: i });
    }
    return Ad.call(this, r, o);
  }
}
kt.resolveSchema = Mu;
const KL = /* @__PURE__ */ new Set([
=======
dt.compileSchema = Tf;
function VT(e, t, r) {
  var n;
  r = (0, Jt.resolveUrl)(this.opts.uriResolver, t, r);
  const s = e.refs[r];
  if (s)
    return s;
  let i = KT.call(this, e, r);
  if (i === void 0) {
    const o = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: a } = this.opts;
    o && (i = new _a({ schema: o, schemaId: a, root: e, baseId: t }));
  }
  if (i !== void 0)
    return e.refs[r] = GT.call(this, i);
}
dt.resolveRef = VT;
function GT(e) {
  return (0, Jt.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : Tf.call(this, e);
}
function p0(e) {
  for (const t of this._compilations)
    if (WT(t, e))
      return t;
}
dt.getCompilingSchema = p0;
function WT(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function KT(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Ea.call(this, e, t);
}
function Ea(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, Jt._getFullPath)(this.opts.uriResolver, r);
  let s = (0, Jt.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === s)
    return Wc.call(this, r, e);
  const i = (0, Jt.normalizeId)(n), o = this.refs[i] || this.schemas[i];
  if (typeof o == "string") {
    const a = Ea.call(this, e, o);
    return typeof (a == null ? void 0 : a.schema) != "object" ? void 0 : Wc.call(this, r, a);
  }
  if (typeof (o == null ? void 0 : o.schema) == "object") {
    if (o.validate || Tf.call(this, o), i === (0, Jt.normalizeId)(t)) {
      const { schema: a } = o, { schemaId: c } = this.opts, f = a[c];
      return f && (s = (0, Jt.resolveUrl)(this.opts.uriResolver, s, f)), new _a({ schema: a, schemaId: c, root: e, baseId: s });
    }
    return Wc.call(this, r, o);
  }
}
dt.resolveSchema = Ea;
const JT = /* @__PURE__ */ new Set([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
<<<<<<< HEAD
function Ad(e, { baseId: t, schema: r, root: n }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
=======
function Wc(e, { baseId: t, schema: r, root: n }) {
  var s;
  if (((s = e.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/")
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return;
  for (const a of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
<<<<<<< HEAD
    const c = r[(0, j0.unescapeFragment)(a)];
    if (c === void 0)
      return;
    r = c;
    const u = typeof r == "object" && r[this.opts.schemaId];
    !KL.has(a) && u && (t = (0, Ur.resolveUrl)(this.opts.uriResolver, t, u));
  }
  let s;
  if (typeof r != "boolean" && r.$ref && !(0, j0.schemaHasRulesButRef)(r, this.RULES)) {
    const a = (0, Ur.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    s = Mu.call(this, n, a);
  }
  const { schemaId: o } = this.opts;
  if (s = s || new Uu({ schema: r, schemaId: o, root: n, baseId: t }), s.schema !== s.root.schema)
    return s;
}
const YL = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", JL = "Meta-schema for $data reference (JSON AnySchema extension proposal)", XL = "object", ZL = [
  "$data"
], QL = {
=======
    const c = r[(0, Gh.unescapeFragment)(a)];
    if (c === void 0)
      return;
    r = c;
    const f = typeof r == "object" && r[this.opts.schemaId];
    !JT.has(a) && f && (t = (0, Jt.resolveUrl)(this.opts.uriResolver, t, f));
  }
  let i;
  if (typeof r != "boolean" && r.$ref && !(0, Gh.schemaHasRulesButRef)(r, this.RULES)) {
    const a = (0, Jt.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    i = Ea.call(this, n, a);
  }
  const { schemaId: o } = this.opts;
  if (i = i || new _a({ schema: r, schemaId: o, root: n, baseId: t }), i.schema !== i.root.schema)
    return i;
}
const YT = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", XT = "Meta-schema for $data reference (JSON AnySchema extension proposal)", ZT = "object", QT = [
  "$data"
], eO = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
<<<<<<< HEAD
}, eF = !1, tF = {
  $id: YL,
  description: JL,
  type: XL,
  required: ZL,
  properties: QL,
  additionalProperties: eF
};
var Vm = {}, Hu = { exports: {} };
const rF = {
=======
}, tO = !1, rO = {
  $id: YT,
  description: XT,
  type: ZT,
  required: QT,
  properties: eO,
  additionalProperties: tO
};
var Of = {}, Sa = { exports: {} };
const nO = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
<<<<<<< HEAD
var nF = {
  HEX: rF
};
const { HEX: iF } = nF, sF = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
function OR(e) {
  if (CR(e, ".") < 3)
    return { host: e, isIPV4: !1 };
  const t = e.match(sF) || [], [r] = t;
  return r ? { host: aF(r, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
}
function U0(e, t = !1) {
  let r = "", n = !0;
  for (const i of e) {
    if (iF[i] === void 0) return;
    i !== "0" && n === !0 && (n = !1), n || (r += i);
  }
  return t && r.length === 0 && (r = "0"), r;
}
function oF(e) {
  let t = 0;
  const r = { error: !1, address: "", zone: "" }, n = [], i = [];
  let s = !1, o = !1, a = !1;
  function c() {
    if (i.length) {
      if (s === !1) {
        const u = U0(i);
        if (u !== void 0)
          n.push(u);
        else
          return r.error = !0, !1;
      }
      i.length = 0;
    }
    return !0;
  }
  for (let u = 0; u < e.length; u++) {
    const l = e[u];
=======
var sO = {
  HEX: nO
};
const { HEX: iO } = sO, oO = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
function h0(e) {
  if (y0(e, ".") < 3)
    return { host: e, isIPV4: !1 };
  const t = e.match(oO) || [], [r] = t;
  return r ? { host: cO(r, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
}
function Wh(e, t = !1) {
  let r = "", n = !0;
  for (const s of e) {
    if (iO[s] === void 0) return;
    s !== "0" && n === !0 && (n = !1), n || (r += s);
  }
  return t && r.length === 0 && (r = "0"), r;
}
function aO(e) {
  let t = 0;
  const r = { error: !1, address: "", zone: "" }, n = [], s = [];
  let i = !1, o = !1, a = !1;
  function c() {
    if (s.length) {
      if (i === !1) {
        const f = Wh(s);
        if (f !== void 0)
          n.push(f);
        else
          return r.error = !0, !1;
      }
      s.length = 0;
    }
    return !0;
  }
  for (let f = 0; f < e.length; f++) {
    const l = e[f];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (!(l === "[" || l === "]"))
      if (l === ":") {
        if (o === !0 && (a = !0), !c())
          break;
        if (t++, n.push(":"), t > 7) {
          r.error = !0;
          break;
        }
<<<<<<< HEAD
        u - 1 >= 0 && e[u - 1] === ":" && (o = !0);
=======
        f - 1 >= 0 && e[f - 1] === ":" && (o = !0);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        continue;
      } else if (l === "%") {
        if (!c())
          break;
<<<<<<< HEAD
        s = !0;
      } else {
        i.push(l);
        continue;
      }
  }
  return i.length && (s ? r.zone = i.join("") : a ? n.push(i.join("")) : n.push(U0(i))), r.address = n.join(""), r;
}
function PR(e) {
  if (CR(e, ":") < 2)
    return { host: e, isIPV6: !1 };
  const t = oF(e);
=======
        i = !0;
      } else {
        s.push(l);
        continue;
      }
  }
  return s.length && (i ? r.zone = s.join("") : a ? n.push(s.join("")) : n.push(Wh(s))), r.address = n.join(""), r;
}
function m0(e) {
  if (y0(e, ":") < 2)
    return { host: e, isIPV6: !1 };
  const t = aO(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (t.error)
    return { host: e, isIPV6: !1 };
  {
    let r = t.address, n = t.address;
    return t.zone && (r += "%" + t.zone, n += "%25" + t.zone), { host: r, escapedHost: n, isIPV6: !0 };
  }
}
<<<<<<< HEAD
function aF(e, t) {
  let r = "", n = !0;
  const i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    o === "0" && n ? (s + 1 <= i && e[s + 1] === t || s + 1 === i) && (r += o, n = !1) : (o === t ? n = !0 : n = !1, r += o);
  }
  return r;
}
function CR(e, t) {
=======
function cO(e, t) {
  let r = "", n = !0;
  const s = e.length;
  for (let i = 0; i < s; i++) {
    const o = e[i];
    o === "0" && n ? (i + 1 <= s && e[i + 1] === t || i + 1 === s) && (r += o, n = !1) : (o === t ? n = !0 : n = !1, r += o);
  }
  return r;
}
function y0(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let r = 0;
  for (let n = 0; n < e.length; n++)
    e[n] === t && r++;
  return r;
}
<<<<<<< HEAD
const M0 = /^\.\.?\//u, H0 = /^\/\.(?:\/|$)/u, q0 = /^\/\.\.(?:\/|$)/u, cF = /^\/?(?:.|\n)*?(?=\/|$)/u;
function lF(e) {
  const t = [];
  for (; e.length; )
    if (e.match(M0))
      e = e.replace(M0, "");
    else if (e.match(H0))
      e = e.replace(H0, "/");
    else if (e.match(q0))
      e = e.replace(q0, "/"), t.pop();
    else if (e === "." || e === "..")
      e = "";
    else {
      const r = e.match(cF);
=======
const Kh = /^\.\.?\//u, Jh = /^\/\.(?:\/|$)/u, Yh = /^\/\.\.(?:\/|$)/u, lO = /^\/?(?:.|\n)*?(?=\/|$)/u;
function uO(e) {
  const t = [];
  for (; e.length; )
    if (e.match(Kh))
      e = e.replace(Kh, "");
    else if (e.match(Jh))
      e = e.replace(Jh, "/");
    else if (e.match(Yh))
      e = e.replace(Yh, "/"), t.pop();
    else if (e === "." || e === "..")
      e = "";
    else {
      const r = e.match(lO);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (r) {
        const n = r[0];
        e = e.slice(n.length), t.push(n);
      } else
        throw new Error("Unexpected dot segment condition");
    }
  return t.join("");
}
<<<<<<< HEAD
function uF(e, t) {
  const r = t !== !0 ? escape : unescape;
  return e.scheme !== void 0 && (e.scheme = r(e.scheme)), e.userinfo !== void 0 && (e.userinfo = r(e.userinfo)), e.host !== void 0 && (e.host = r(e.host)), e.path !== void 0 && (e.path = r(e.path)), e.query !== void 0 && (e.query = r(e.query)), e.fragment !== void 0 && (e.fragment = r(e.fragment)), e;
}
function fF(e) {
  const t = [];
  if (e.userinfo !== void 0 && (t.push(e.userinfo), t.push("@")), e.host !== void 0) {
    let r = unescape(e.host);
    const n = OR(r);
    if (n.isIPV4)
      r = n.host;
    else {
      const i = PR(n.host);
      i.isIPV6 === !0 ? r = `[${i.escapedHost}]` : r = e.host;
=======
function fO(e, t) {
  const r = t !== !0 ? escape : unescape;
  return e.scheme !== void 0 && (e.scheme = r(e.scheme)), e.userinfo !== void 0 && (e.userinfo = r(e.userinfo)), e.host !== void 0 && (e.host = r(e.host)), e.path !== void 0 && (e.path = r(e.path)), e.query !== void 0 && (e.query = r(e.query)), e.fragment !== void 0 && (e.fragment = r(e.fragment)), e;
}
function dO(e) {
  const t = [];
  if (e.userinfo !== void 0 && (t.push(e.userinfo), t.push("@")), e.host !== void 0) {
    let r = unescape(e.host);
    const n = h0(r);
    if (n.isIPV4)
      r = n.host;
    else {
      const s = m0(n.host);
      s.isIPV6 === !0 ? r = `[${s.escapedHost}]` : r = e.host;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    t.push(r);
  }
  return (typeof e.port == "number" || typeof e.port == "string") && (t.push(":"), t.push(String(e.port))), t.length ? t.join("") : void 0;
}
<<<<<<< HEAD
var dF = {
  recomposeAuthority: fF,
  normalizeComponentEncoding: uF,
  removeDotSegments: lF,
  normalizeIPv4: OR,
  normalizeIPv6: PR
};
const pF = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, hF = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function AR(e) {
  return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
}
function IR(e) {
  return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
}
function NR(e) {
  const t = String(e.scheme).toLowerCase() === "https";
  return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e;
}
function mF(e) {
  return e.secure = AR(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e;
}
function gF(e) {
  if ((e.port === (AR(e) ? 443 : 80) || e.port === "") && (e.port = void 0), typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
=======
var pO = {
  recomposeAuthority: dO,
  normalizeComponentEncoding: fO,
  removeDotSegments: uO,
  normalizeIPv4: h0,
  normalizeIPv6: m0
};
const hO = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, mO = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function g0(e) {
  return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
}
function v0(e) {
  return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
}
function b0(e) {
  const t = String(e.scheme).toLowerCase() === "https";
  return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e;
}
function yO(e) {
  return e.secure = g0(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e;
}
function gO(e) {
  if ((e.port === (g0(e) ? 443 : 80) || e.port === "") && (e.port = void 0), typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const [t, r] = e.resourceName.split("?");
    e.path = t && t !== "/" ? t : void 0, e.query = r, e.resourceName = void 0;
  }
  return e.fragment = void 0, e;
}
<<<<<<< HEAD
function yF(e, t) {
  if (!e.path)
    return e.error = "URN can not be parsed", e;
  const r = e.path.match(hF);
  if (r) {
    const n = t.scheme || e.scheme || "urn";
    e.nid = r[1].toLowerCase(), e.nss = r[2];
    const i = `${n}:${t.nid || e.nid}`, s = Gm[i];
    e.path = void 0, s && (e = s.parse(e, t));
=======
function vO(e, t) {
  if (!e.path)
    return e.error = "URN can not be parsed", e;
  const r = e.path.match(mO);
  if (r) {
    const n = t.scheme || e.scheme || "urn";
    e.nid = r[1].toLowerCase(), e.nss = r[2];
    const s = `${n}:${t.nid || e.nid}`, i = Cf[s];
    e.path = void 0, i && (e = i.parse(e, t));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } else
    e.error = e.error || "URN can not be parsed.";
  return e;
}
<<<<<<< HEAD
function vF(e, t) {
  const r = t.scheme || e.scheme || "urn", n = e.nid.toLowerCase(), i = `${r}:${t.nid || n}`, s = Gm[i];
  s && (e = s.serialize(e, t));
  const o = e, a = e.nss;
  return o.path = `${n || t.nid}:${a}`, t.skipEscape = !0, o;
}
function _F(e, t) {
  const r = e;
  return r.uuid = r.nss, r.nss = void 0, !t.tolerant && (!r.uuid || !pF.test(r.uuid)) && (r.error = r.error || "UUID is not valid."), r;
}
function bF(e) {
  const t = e;
  return t.nss = (e.uuid || "").toLowerCase(), t;
}
const kR = {
  scheme: "http",
  domainHost: !0,
  parse: IR,
  serialize: NR
}, EF = {
  scheme: "https",
  domainHost: kR.domainHost,
  parse: IR,
  serialize: NR
}, pl = {
  scheme: "ws",
  domainHost: !0,
  parse: mF,
  serialize: gF
}, wF = {
  scheme: "wss",
  domainHost: pl.domainHost,
  parse: pl.parse,
  serialize: pl.serialize
}, SF = {
  scheme: "urn",
  parse: yF,
  serialize: vF,
  skipNormalize: !0
}, xF = {
  scheme: "urn:uuid",
  parse: _F,
  serialize: bF,
  skipNormalize: !0
}, Gm = {
  http: kR,
  https: EF,
  ws: pl,
  wss: wF,
  urn: SF,
  "urn:uuid": xF
};
var RF = Gm;
const { normalizeIPv6: $F, normalizeIPv4: TF, removeDotSegments: qo, recomposeAuthority: OF, normalizeComponentEncoding: Tc } = dF, Wm = RF;
function PF(e, t) {
  return typeof e == "string" ? e = Qr(_n(e, t), t) : typeof e == "object" && (e = _n(Qr(e, t), t)), e;
}
function CF(e, t, r) {
  const n = Object.assign({ scheme: "null" }, r), i = DR(_n(e, n), _n(t, n), n, !0);
  return Qr(i, { ...n, skipEscape: !0 });
}
function DR(e, t, r, n) {
  const i = {};
  return n || (e = _n(Qr(e, r), r), t = _n(Qr(t, r), r)), r = r || {}, !r.tolerant && t.scheme ? (i.scheme = t.scheme, i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = qo(t.path || ""), i.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = qo(t.path || ""), i.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? i.path = qo(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? i.path = "/" + t.path : e.path ? i.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : i.path = t.path, i.path = qo(i.path)), i.query = t.query) : (i.path = e.path, t.query !== void 0 ? i.query = t.query : i.query = e.query), i.userinfo = e.userinfo, i.host = e.host, i.port = e.port), i.scheme = e.scheme), i.fragment = t.fragment, i;
}
function AF(e, t, r) {
  return typeof e == "string" ? (e = unescape(e), e = Qr(Tc(_n(e, r), !0), { ...r, skipEscape: !0 })) : typeof e == "object" && (e = Qr(Tc(e, !0), { ...r, skipEscape: !0 })), typeof t == "string" ? (t = unescape(t), t = Qr(Tc(_n(t, r), !0), { ...r, skipEscape: !0 })) : typeof t == "object" && (t = Qr(Tc(t, !0), { ...r, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase();
}
function Qr(e, t) {
=======
function bO(e, t) {
  const r = t.scheme || e.scheme || "urn", n = e.nid.toLowerCase(), s = `${r}:${t.nid || n}`, i = Cf[s];
  i && (e = i.serialize(e, t));
  const o = e, a = e.nss;
  return o.path = `${n || t.nid}:${a}`, t.skipEscape = !0, o;
}
function _O(e, t) {
  const r = e;
  return r.uuid = r.nss, r.nss = void 0, !t.tolerant && (!r.uuid || !hO.test(r.uuid)) && (r.error = r.error || "UUID is not valid."), r;
}
function EO(e) {
  const t = e;
  return t.nss = (e.uuid || "").toLowerCase(), t;
}
const _0 = {
  scheme: "http",
  domainHost: !0,
  parse: v0,
  serialize: b0
}, SO = {
  scheme: "https",
  domainHost: _0.domainHost,
  parse: v0,
  serialize: b0
}, ho = {
  scheme: "ws",
  domainHost: !0,
  parse: yO,
  serialize: gO
}, xO = {
  scheme: "wss",
  domainHost: ho.domainHost,
  parse: ho.parse,
  serialize: ho.serialize
}, wO = {
  scheme: "urn",
  parse: vO,
  serialize: bO,
  skipNormalize: !0
}, RO = {
  scheme: "urn:uuid",
  parse: _O,
  serialize: EO,
  skipNormalize: !0
}, Cf = {
  http: _0,
  https: SO,
  ws: ho,
  wss: xO,
  urn: wO,
  "urn:uuid": RO
};
var $O = Cf;
const { normalizeIPv6: TO, normalizeIPv4: OO, removeDotSegments: Ns, recomposeAuthority: CO, normalizeComponentEncoding: ki } = pO, Pf = $O;
function PO(e, t) {
  return typeof e == "string" ? e = lr(xr(e, t), t) : typeof e == "object" && (e = xr(lr(e, t), t)), e;
}
function IO(e, t, r) {
  const n = Object.assign({ scheme: "null" }, r), s = E0(xr(e, n), xr(t, n), n, !0);
  return lr(s, { ...n, skipEscape: !0 });
}
function E0(e, t, r, n) {
  const s = {};
  return n || (e = xr(lr(e, r), r), t = xr(lr(t, r), r)), r = r || {}, !r.tolerant && t.scheme ? (s.scheme = t.scheme, s.userinfo = t.userinfo, s.host = t.host, s.port = t.port, s.path = Ns(t.path || ""), s.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (s.userinfo = t.userinfo, s.host = t.host, s.port = t.port, s.path = Ns(t.path || ""), s.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? s.path = Ns(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? s.path = "/" + t.path : e.path ? s.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : s.path = t.path, s.path = Ns(s.path)), s.query = t.query) : (s.path = e.path, t.query !== void 0 ? s.query = t.query : s.query = e.query), s.userinfo = e.userinfo, s.host = e.host, s.port = e.port), s.scheme = e.scheme), s.fragment = t.fragment, s;
}
function NO(e, t, r) {
  return typeof e == "string" ? (e = unescape(e), e = lr(ki(xr(e, r), !0), { ...r, skipEscape: !0 })) : typeof e == "object" && (e = lr(ki(e, !0), { ...r, skipEscape: !0 })), typeof t == "string" ? (t = unescape(t), t = lr(ki(xr(t, r), !0), { ...r, skipEscape: !0 })) : typeof t == "object" && (t = lr(ki(t, !0), { ...r, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase();
}
function lr(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = {
    host: e.host,
    scheme: e.scheme,
    userinfo: e.userinfo,
    port: e.port,
    path: e.path,
    query: e.query,
    nid: e.nid,
    nss: e.nss,
    uuid: e.uuid,
    fragment: e.fragment,
    reference: e.reference,
    resourceName: e.resourceName,
    secure: e.secure,
    error: ""
<<<<<<< HEAD
  }, n = Object.assign({}, t), i = [], s = Wm[(n.scheme || r.scheme || "").toLowerCase()];
  s && s.serialize && s.serialize(r, n), r.path !== void 0 && (n.skipEscape ? r.path = unescape(r.path) : (r.path = escape(r.path), r.scheme !== void 0 && (r.path = r.path.split("%3A").join(":")))), n.reference !== "suffix" && r.scheme && i.push(r.scheme, ":");
  const o = OF(r);
  if (o !== void 0 && (n.reference !== "suffix" && i.push("//"), i.push(o), r.path && r.path.charAt(0) !== "/" && i.push("/")), r.path !== void 0) {
    let a = r.path;
    !n.absolutePath && (!s || !s.absolutePath) && (a = qo(a)), o === void 0 && (a = a.replace(/^\/\//u, "/%2F")), i.push(a);
  }
  return r.query !== void 0 && i.push("?", r.query), r.fragment !== void 0 && i.push("#", r.fragment), i.join("");
}
const IF = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
function NF(e) {
  let t = 0;
  for (let r = 0, n = e.length; r < n; ++r)
    if (t = e.charCodeAt(r), t > 126 || IF[t])
      return !0;
  return !1;
}
const kF = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function _n(e, t) {
=======
  }, n = Object.assign({}, t), s = [], i = Pf[(n.scheme || r.scheme || "").toLowerCase()];
  i && i.serialize && i.serialize(r, n), r.path !== void 0 && (n.skipEscape ? r.path = unescape(r.path) : (r.path = escape(r.path), r.scheme !== void 0 && (r.path = r.path.split("%3A").join(":")))), n.reference !== "suffix" && r.scheme && s.push(r.scheme, ":");
  const o = CO(r);
  if (o !== void 0 && (n.reference !== "suffix" && s.push("//"), s.push(o), r.path && r.path.charAt(0) !== "/" && s.push("/")), r.path !== void 0) {
    let a = r.path;
    !n.absolutePath && (!i || !i.absolutePath) && (a = Ns(a)), o === void 0 && (a = a.replace(/^\/\//u, "/%2F")), s.push(a);
  }
  return r.query !== void 0 && s.push("?", r.query), r.fragment !== void 0 && s.push("#", r.fragment), s.join("");
}
const AO = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
function kO(e) {
  let t = 0;
  for (let r = 0, n = e.length; r < n; ++r)
    if (t = e.charCodeAt(r), t > 126 || AO[t])
      return !0;
  return !1;
}
const LO = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function xr(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = Object.assign({}, t), n = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
<<<<<<< HEAD
  }, i = e.indexOf("%") !== -1;
  let s = !1;
  r.reference === "suffix" && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e);
  const o = e.match(kF);
  if (o) {
    if (n.scheme = o[1], n.userinfo = o[3], n.host = o[4], n.port = parseInt(o[5], 10), n.path = o[6] || "", n.query = o[7], n.fragment = o[8], isNaN(n.port) && (n.port = o[5]), n.host) {
      const c = TF(n.host);
      if (c.isIPV4 === !1) {
        const u = $F(c.host);
        n.host = u.host.toLowerCase(), s = u.isIPV6;
      } else
        n.host = c.host, s = !0;
    }
    n.scheme === void 0 && n.userinfo === void 0 && n.host === void 0 && n.port === void 0 && n.query === void 0 && !n.path ? n.reference = "same-document" : n.scheme === void 0 ? n.reference = "relative" : n.fragment === void 0 ? n.reference = "absolute" : n.reference = "uri", r.reference && r.reference !== "suffix" && r.reference !== n.reference && (n.error = n.error || "URI is not a " + r.reference + " reference.");
    const a = Wm[(r.scheme || n.scheme || "").toLowerCase()];
    if (!r.unicodeSupport && (!a || !a.unicodeSupport) && n.host && (r.domainHost || a && a.domainHost) && s === !1 && NF(n.host))
=======
  }, s = e.indexOf("%") !== -1;
  let i = !1;
  r.reference === "suffix" && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e);
  const o = e.match(LO);
  if (o) {
    if (n.scheme = o[1], n.userinfo = o[3], n.host = o[4], n.port = parseInt(o[5], 10), n.path = o[6] || "", n.query = o[7], n.fragment = o[8], isNaN(n.port) && (n.port = o[5]), n.host) {
      const c = OO(n.host);
      if (c.isIPV4 === !1) {
        const f = TO(c.host);
        n.host = f.host.toLowerCase(), i = f.isIPV6;
      } else
        n.host = c.host, i = !0;
    }
    n.scheme === void 0 && n.userinfo === void 0 && n.host === void 0 && n.port === void 0 && n.query === void 0 && !n.path ? n.reference = "same-document" : n.scheme === void 0 ? n.reference = "relative" : n.fragment === void 0 ? n.reference = "absolute" : n.reference = "uri", r.reference && r.reference !== "suffix" && r.reference !== n.reference && (n.error = n.error || "URI is not a " + r.reference + " reference.");
    const a = Pf[(r.scheme || n.scheme || "").toLowerCase()];
    if (!r.unicodeSupport && (!a || !a.unicodeSupport) && n.host && (r.domainHost || a && a.domainHost) && i === !1 && kO(n.host))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      try {
        n.host = URL.domainToASCII(n.host.toLowerCase());
      } catch (c) {
        n.error = n.error || "Host's domain name can not be converted to ASCII: " + c;
      }
<<<<<<< HEAD
    (!a || a && !a.skipNormalize) && (i && n.scheme !== void 0 && (n.scheme = unescape(n.scheme)), i && n.host !== void 0 && (n.host = unescape(n.host)), n.path && (n.path = escape(unescape(n.path))), n.fragment && (n.fragment = encodeURI(decodeURIComponent(n.fragment)))), a && a.parse && a.parse(n, r);
=======
    (!a || a && !a.skipNormalize) && (s && n.scheme !== void 0 && (n.scheme = unescape(n.scheme)), s && n.host !== void 0 && (n.host = unescape(n.host)), n.path && (n.path = escape(unescape(n.path))), n.fragment && (n.fragment = encodeURI(decodeURIComponent(n.fragment)))), a && a.parse && a.parse(n, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } else
    n.error = n.error || "URI can not be parsed.";
  return n;
}
<<<<<<< HEAD
const Km = {
  SCHEMES: Wm,
  normalize: PF,
  resolve: CF,
  resolveComponents: DR,
  equal: AF,
  serialize: Qr,
  parse: _n
};
Hu.exports = Km;
Hu.exports.default = Km;
Hu.exports.fastUri = Km;
var Ym = Hu.exports;
Object.defineProperty(Vm, "__esModule", { value: !0 });
const LR = Ym;
LR.code = 'require("ajv/dist/runtime/uri").default';
Vm.default = LR;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Pr;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = he;
=======
const If = {
  SCHEMES: Pf,
  normalize: PO,
  resolve: IO,
  resolveComponents: E0,
  equal: NO,
  serialize: lr,
  parse: xr
};
Sa.exports = If;
Sa.exports.default = If;
Sa.exports.fastUri = If;
var Nf = Sa.exports;
Object.defineProperty(Of, "__esModule", { value: !0 });
const S0 = Nf;
S0.code = 'require("ajv/dist/runtime/uri").default';
Of.default = S0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Ut;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = ae;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
<<<<<<< HEAD
  const n = to, i = on, s = Ui, o = kt, a = he, c = Nt, u = yt, l = se, f = tF, m = Vm, p = (j, k) => new RegExp(j, k);
  p.code = "new RegExp";
  const d = ["removeAdditional", "useDefaults", "coerceTypes"], h = /* @__PURE__ */ new Set([
=======
  const n = is, s = mr, i = dn, o = dt, a = ae, c = ft, f = tt, l = re, d = rO, g = Of, p = (k, P) => new RegExp(k, P);
  p.code = "new RegExp";
  const u = ["removeAdditional", "useDefaults", "coerceTypes"], h = /* @__PURE__ */ new Set([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
<<<<<<< HEAD
  ]), _ = {
=======
  ]), b = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
<<<<<<< HEAD
  }, g = {
=======
  }, m = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, v = 200;
<<<<<<< HEAD
  function y(j) {
    var k, U, M, T, N, G, O, S, W, z, Q, K, X, J, re, fe, ee, le, Se, ye, ve, qe, Ae, $t, Rn;
    const Le = j.strict, Ut = (k = j.code) === null || k === void 0 ? void 0 : k.optimize, br = Ut === !0 || Ut === void 0 ? 1 : Ut || 0, Ne = (M = (U = j.code) === null || U === void 0 ? void 0 : U.regExp) !== null && M !== void 0 ? M : p, je = (T = j.uriResolver) !== null && T !== void 0 ? T : m.default;
    return {
      strictSchema: (G = (N = j.strictSchema) !== null && N !== void 0 ? N : Le) !== null && G !== void 0 ? G : !0,
      strictNumbers: (S = (O = j.strictNumbers) !== null && O !== void 0 ? O : Le) !== null && S !== void 0 ? S : !0,
      strictTypes: (z = (W = j.strictTypes) !== null && W !== void 0 ? W : Le) !== null && z !== void 0 ? z : "log",
      strictTuples: (K = (Q = j.strictTuples) !== null && Q !== void 0 ? Q : Le) !== null && K !== void 0 ? K : "log",
      strictRequired: (J = (X = j.strictRequired) !== null && X !== void 0 ? X : Le) !== null && J !== void 0 ? J : !1,
      code: j.code ? { ...j.code, optimize: br, regExp: Ne } : { optimize: br, regExp: Ne },
      loopRequired: (re = j.loopRequired) !== null && re !== void 0 ? re : v,
      loopEnum: (fe = j.loopEnum) !== null && fe !== void 0 ? fe : v,
      meta: (ee = j.meta) !== null && ee !== void 0 ? ee : !0,
      messages: (le = j.messages) !== null && le !== void 0 ? le : !0,
      inlineRefs: (Se = j.inlineRefs) !== null && Se !== void 0 ? Se : !0,
      schemaId: (ye = j.schemaId) !== null && ye !== void 0 ? ye : "$id",
      addUsedSchema: (ve = j.addUsedSchema) !== null && ve !== void 0 ? ve : !0,
      validateSchema: (qe = j.validateSchema) !== null && qe !== void 0 ? qe : !0,
      validateFormats: (Ae = j.validateFormats) !== null && Ae !== void 0 ? Ae : !0,
      unicodeRegExp: ($t = j.unicodeRegExp) !== null && $t !== void 0 ? $t : !0,
      int32range: (Rn = j.int32range) !== null && Rn !== void 0 ? Rn : !0,
      uriResolver: je
    };
  }
  class E {
    constructor(k = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), k = this.opts = { ...k, ...y(k) };
      const { es5: U, lines: M } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: h, es5: U, lines: M }), this.logger = q(k.logger);
      const T = k.validateFormats;
      k.validateFormats = !1, this.RULES = (0, s.getRules)(), R.call(this, _, k, "NOT SUPPORTED"), R.call(this, g, k, "DEPRECATED", "warn"), this._metaOpts = F.call(this), k.formats && V.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), k.keywords && b.call(this, k.keywords), typeof k.meta == "object" && this.addMetaSchema(k.meta), C.call(this), k.validateFormats = T;
=======
  function y(k) {
    var P, D, F, w, N, q, K, V, Z, Y, J, H, W, G, ee, le, X, ce, Ee, pe, me, We, we, Et, Sn;
    const Ce = k.strict, Bt = (P = k.code) === null || P === void 0 ? void 0 : P.optimize, $r = Bt === !0 || Bt === void 0 ? 1 : Bt || 0, Te = (F = (D = k.code) === null || D === void 0 ? void 0 : D.regExp) !== null && F !== void 0 ? F : p, ot = (w = k.uriResolver) !== null && w !== void 0 ? w : g.default;
    return {
      strictSchema: (q = (N = k.strictSchema) !== null && N !== void 0 ? N : Ce) !== null && q !== void 0 ? q : !0,
      strictNumbers: (V = (K = k.strictNumbers) !== null && K !== void 0 ? K : Ce) !== null && V !== void 0 ? V : !0,
      strictTypes: (Y = (Z = k.strictTypes) !== null && Z !== void 0 ? Z : Ce) !== null && Y !== void 0 ? Y : "log",
      strictTuples: (H = (J = k.strictTuples) !== null && J !== void 0 ? J : Ce) !== null && H !== void 0 ? H : "log",
      strictRequired: (G = (W = k.strictRequired) !== null && W !== void 0 ? W : Ce) !== null && G !== void 0 ? G : !1,
      code: k.code ? { ...k.code, optimize: $r, regExp: Te } : { optimize: $r, regExp: Te },
      loopRequired: (ee = k.loopRequired) !== null && ee !== void 0 ? ee : v,
      loopEnum: (le = k.loopEnum) !== null && le !== void 0 ? le : v,
      meta: (X = k.meta) !== null && X !== void 0 ? X : !0,
      messages: (ce = k.messages) !== null && ce !== void 0 ? ce : !0,
      inlineRefs: (Ee = k.inlineRefs) !== null && Ee !== void 0 ? Ee : !0,
      schemaId: (pe = k.schemaId) !== null && pe !== void 0 ? pe : "$id",
      addUsedSchema: (me = k.addUsedSchema) !== null && me !== void 0 ? me : !0,
      validateSchema: (We = k.validateSchema) !== null && We !== void 0 ? We : !0,
      validateFormats: (we = k.validateFormats) !== null && we !== void 0 ? we : !0,
      unicodeRegExp: (Et = k.unicodeRegExp) !== null && Et !== void 0 ? Et : !0,
      int32range: (Sn = k.int32range) !== null && Sn !== void 0 ? Sn : !0,
      uriResolver: ot
    };
  }
  class _ {
    constructor(P = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), P = this.opts = { ...P, ...y(P) };
      const { es5: D, lines: F } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: h, es5: D, lines: F }), this.logger = U(P.logger);
      const w = P.validateFormats;
      P.validateFormats = !1, this.RULES = (0, i.getRules)(), R.call(this, b, P, "NOT SUPPORTED"), R.call(this, m, P, "DEPRECATED", "warn"), this._metaOpts = L.call(this), P.formats && z.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), P.keywords && S.call(this, P.keywords), typeof P.meta == "object" && this.addMetaSchema(P.meta), O.call(this), P.validateFormats = w;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
<<<<<<< HEAD
      const { $data: k, meta: U, schemaId: M } = this.opts;
      let T = f;
      M === "id" && (T = { ...f }, T.id = T.$id, delete T.$id), U && k && this.addMetaSchema(T, T[M], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: U } = this.opts;
      return this.opts.defaultMeta = typeof k == "object" ? k[U] || k : void 0;
    }
    validate(k, U) {
      let M;
      if (typeof k == "string") {
        if (M = this.getSchema(k), !M)
          throw new Error(`no schema with key or ref "${k}"`);
      } else
        M = this.compile(k);
      const T = M(U);
      return "$async" in M || (this.errors = M.errors), T;
    }
    compile(k, U) {
      const M = this._addSchema(k, U);
      return M.validate || this._compileSchemaEnv(M);
    }
    compileAsync(k, U) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: M } = this.opts;
      return T.call(this, k, U);
      async function T(z, Q) {
        await N.call(this, z.$schema);
        const K = this._addSchema(z, Q);
        return K.validate || G.call(this, K);
      }
      async function N(z) {
        z && !this.getSchema(z) && await T.call(this, { $ref: z }, !0);
      }
      async function G(z) {
        try {
          return this._compileSchemaEnv(z);
        } catch (Q) {
          if (!(Q instanceof i.default))
            throw Q;
          return O.call(this, Q), await S.call(this, Q.missingSchema), G.call(this, z);
        }
      }
      function O({ missingSchema: z, missingRef: Q }) {
        if (this.refs[z])
          throw new Error(`AnySchema ${z} is loaded but ${Q} cannot be resolved`);
      }
      async function S(z) {
        const Q = await W.call(this, z);
        this.refs[z] || await N.call(this, Q.$schema), this.refs[z] || this.addSchema(Q, z, U);
      }
      async function W(z) {
        const Q = this._loading[z];
        if (Q)
          return Q;
        try {
          return await (this._loading[z] = M(z));
        } finally {
          delete this._loading[z];
=======
      const { $data: P, meta: D, schemaId: F } = this.opts;
      let w = d;
      F === "id" && (w = { ...d }, w.id = w.$id, delete w.$id), D && P && this.addMetaSchema(w, w[F], !1);
    }
    defaultMeta() {
      const { meta: P, schemaId: D } = this.opts;
      return this.opts.defaultMeta = typeof P == "object" ? P[D] || P : void 0;
    }
    validate(P, D) {
      let F;
      if (typeof P == "string") {
        if (F = this.getSchema(P), !F)
          throw new Error(`no schema with key or ref "${P}"`);
      } else
        F = this.compile(P);
      const w = F(D);
      return "$async" in F || (this.errors = F.errors), w;
    }
    compile(P, D) {
      const F = this._addSchema(P, D);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(P, D) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return w.call(this, P, D);
      async function w(Y, J) {
        await N.call(this, Y.$schema);
        const H = this._addSchema(Y, J);
        return H.validate || q.call(this, H);
      }
      async function N(Y) {
        Y && !this.getSchema(Y) && await w.call(this, { $ref: Y }, !0);
      }
      async function q(Y) {
        try {
          return this._compileSchemaEnv(Y);
        } catch (J) {
          if (!(J instanceof s.default))
            throw J;
          return K.call(this, J), await V.call(this, J.missingSchema), q.call(this, Y);
        }
      }
      function K({ missingSchema: Y, missingRef: J }) {
        if (this.refs[Y])
          throw new Error(`AnySchema ${Y} is loaded but ${J} cannot be resolved`);
      }
      async function V(Y) {
        const J = await Z.call(this, Y);
        this.refs[Y] || await N.call(this, J.$schema), this.refs[Y] || this.addSchema(J, Y, D);
      }
      async function Z(Y) {
        const J = this._loading[Y];
        if (J)
          return J;
        try {
          return await (this._loading[Y] = F(Y));
        } finally {
          delete this._loading[Y];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
    }
    // Adds schema to the instance
<<<<<<< HEAD
    addSchema(k, U, M, T = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const G of k)
          this.addSchema(G, void 0, M, T);
        return this;
      }
      let N;
      if (typeof k == "object") {
        const { schemaId: G } = this.opts;
        if (N = k[G], N !== void 0 && typeof N != "string")
          throw new Error(`schema ${G} must be string`);
      }
      return U = (0, c.normalizeId)(U || N), this._checkUnique(U), this.schemas[U] = this._addSchema(k, M, U, T, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(k, U, M = this.opts.validateSchema) {
      return this.addSchema(k, U, !0, M), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(k, U) {
      if (typeof k == "boolean")
        return !0;
      let M;
      if (M = k.$schema, M !== void 0 && typeof M != "string")
        throw new Error("$schema must be a string");
      if (M = M || this.opts.defaultMeta || this.defaultMeta(), !M)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const T = this.validate(M, k);
      if (!T && U) {
=======
    addSchema(P, D, F, w = this.opts.validateSchema) {
      if (Array.isArray(P)) {
        for (const q of P)
          this.addSchema(q, void 0, F, w);
        return this;
      }
      let N;
      if (typeof P == "object") {
        const { schemaId: q } = this.opts;
        if (N = P[q], N !== void 0 && typeof N != "string")
          throw new Error(`schema ${q} must be string`);
      }
      return D = (0, c.normalizeId)(D || N), this._checkUnique(D), this.schemas[D] = this._addSchema(P, F, D, w, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(P, D, F = this.opts.validateSchema) {
      return this.addSchema(P, D, !0, F), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(P, D) {
      if (typeof P == "boolean")
        return !0;
      let F;
      if (F = P.$schema, F !== void 0 && typeof F != "string")
        throw new Error("$schema must be a string");
      if (F = F || this.opts.defaultMeta || this.defaultMeta(), !F)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const w = this.validate(F, P);
      if (!w && D) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        const N = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(N);
        else
          throw new Error(N);
      }
<<<<<<< HEAD
      return T;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(k) {
      let U;
      for (; typeof (U = w.call(this, k)) == "string"; )
        k = U;
      if (U === void 0) {
        const { schemaId: M } = this.opts, T = new o.SchemaEnv({ schema: {}, schemaId: M });
        if (U = o.resolveSchema.call(this, T, k), !U)
          return;
        this.refs[k] = U;
      }
      return U.validate || this._compileSchemaEnv(U);
=======
      return w;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(P) {
      let D;
      for (; typeof (D = E.call(this, P)) == "string"; )
        P = D;
      if (D === void 0) {
        const { schemaId: F } = this.opts, w = new o.SchemaEnv({ schema: {}, schemaId: F });
        if (D = o.resolveSchema.call(this, w, P), !D)
          return;
        this.refs[P] = D;
      }
      return D.validate || this._compileSchemaEnv(D);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
<<<<<<< HEAD
    removeSchema(k) {
      if (k instanceof RegExp)
        return this._removeAllSchemas(this.schemas, k), this._removeAllSchemas(this.refs, k), this;
      switch (typeof k) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const U = w.call(this, k);
          return typeof U == "object" && this._cache.delete(U.schema), delete this.schemas[k], delete this.refs[k], this;
        }
        case "object": {
          const U = k;
          this._cache.delete(U);
          let M = k[this.opts.schemaId];
          return M && (M = (0, c.normalizeId)(M), delete this.schemas[M], delete this.refs[M]), this;
=======
    removeSchema(P) {
      if (P instanceof RegExp)
        return this._removeAllSchemas(this.schemas, P), this._removeAllSchemas(this.refs, P), this;
      switch (typeof P) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const D = E.call(this, P);
          return typeof D == "object" && this._cache.delete(D.schema), delete this.schemas[P], delete this.refs[P], this;
        }
        case "object": {
          const D = P;
          this._cache.delete(D);
          let F = P[this.opts.schemaId];
          return F && (F = (0, c.normalizeId)(F), delete this.schemas[F], delete this.refs[F]), this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
<<<<<<< HEAD
    addVocabulary(k) {
      for (const U of k)
        this.addKeyword(U);
      return this;
    }
    addKeyword(k, U) {
      let M;
      if (typeof k == "string")
        M = k, typeof U == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), U.keyword = M);
      else if (typeof k == "object" && U === void 0) {
        if (U = k, M = U.keyword, Array.isArray(M) && !M.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (x.call(this, M, U), !U)
        return (0, l.eachItem)(M, (N) => A.call(this, N)), this;
      D.call(this, U);
      const T = {
        ...U,
        type: (0, u.getJSONTypes)(U.type),
        schemaType: (0, u.getJSONTypes)(U.schemaType)
      };
      return (0, l.eachItem)(M, T.type.length === 0 ? (N) => A.call(this, N, T) : (N) => T.type.forEach((G) => A.call(this, N, T, G))), this;
    }
    getKeyword(k) {
      const U = this.RULES.all[k];
      return typeof U == "object" ? U.definition : !!U;
    }
    // Remove keyword
    removeKeyword(k) {
      const { RULES: U } = this;
      delete U.keywords[k], delete U.all[k];
      for (const M of U.rules) {
        const T = M.rules.findIndex((N) => N.keyword === k);
        T >= 0 && M.rules.splice(T, 1);
=======
    addVocabulary(P) {
      for (const D of P)
        this.addKeyword(D);
      return this;
    }
    addKeyword(P, D) {
      let F;
      if (typeof P == "string")
        F = P, typeof D == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), D.keyword = F);
      else if (typeof P == "object" && D === void 0) {
        if (D = P, F = D.keyword, Array.isArray(F) && !F.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (x.call(this, F, D), !D)
        return (0, l.eachItem)(F, (N) => I.call(this, N)), this;
      j.call(this, D);
      const w = {
        ...D,
        type: (0, f.getJSONTypes)(D.type),
        schemaType: (0, f.getJSONTypes)(D.schemaType)
      };
      return (0, l.eachItem)(F, w.type.length === 0 ? (N) => I.call(this, N, w) : (N) => w.type.forEach((q) => I.call(this, N, w, q))), this;
    }
    getKeyword(P) {
      const D = this.RULES.all[P];
      return typeof D == "object" ? D.definition : !!D;
    }
    // Remove keyword
    removeKeyword(P) {
      const { RULES: D } = this;
      delete D.keywords[P], delete D.all[P];
      for (const F of D.rules) {
        const w = F.rules.findIndex((N) => N.keyword === P);
        w >= 0 && F.rules.splice(w, 1);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      return this;
    }
    // Add format
<<<<<<< HEAD
    addFormat(k, U) {
      return typeof U == "string" && (U = new RegExp(U)), this.formats[k] = U, this;
    }
    errorsText(k = this.errors, { separator: U = ", ", dataVar: M = "data" } = {}) {
      return !k || k.length === 0 ? "No errors" : k.map((T) => `${M}${T.instancePath} ${T.message}`).reduce((T, N) => T + U + N);
    }
    $dataMetaSchema(k, U) {
      const M = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const T of U) {
        const N = T.split("/").slice(1);
        let G = k;
        for (const O of N)
          G = G[O];
        for (const O in M) {
          const S = M[O];
          if (typeof S != "object")
            continue;
          const { $data: W } = S.definition, z = G[O];
          W && z && (G[O] = L(z));
        }
      }
      return k;
    }
    _removeAllSchemas(k, U) {
      for (const M in k) {
        const T = k[M];
        (!U || U.test(M)) && (typeof T == "string" ? delete k[M] : T && !T.meta && (this._cache.delete(T.schema), delete k[M]));
      }
    }
    _addSchema(k, U, M, T = this.opts.validateSchema, N = this.opts.addUsedSchema) {
      let G;
      const { schemaId: O } = this.opts;
      if (typeof k == "object")
        G = k[O];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let S = this._cache.get(k);
      if (S !== void 0)
        return S;
      M = (0, c.normalizeId)(G || M);
      const W = c.getSchemaRefs.call(this, k, M);
      return S = new o.SchemaEnv({ schema: k, schemaId: O, meta: U, baseId: M, localRefs: W }), this._cache.set(S.schema, S), N && !M.startsWith("#") && (M && this._checkUnique(M), this.refs[M] = S), T && this.validateSchema(k, !0), S;
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (k.meta ? this._compileMetaSchema(k) : o.compileSchema.call(this, k), !k.validate)
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const U = this.opts;
      this.opts = this._metaOpts;
      try {
        o.compileSchema.call(this, k);
      } finally {
        this.opts = U;
      }
    }
  }
  E.ValidationError = n.default, E.MissingRefError = i.default, e.default = E;
  function R(j, k, U, M = "error") {
    for (const T in j) {
      const N = T;
      N in k && this.logger[M](`${U}: option ${T}. ${j[N]}`);
    }
  }
  function w(j) {
    return j = (0, c.normalizeId)(j), this.schemas[j] || this.refs[j];
  }
  function C() {
    const j = this.opts.schemas;
    if (j)
      if (Array.isArray(j))
        this.addSchema(j);
      else
        for (const k in j)
          this.addSchema(j[k], k);
  }
  function V() {
    for (const j in this.opts.formats) {
      const k = this.opts.formats[j];
      k && this.addFormat(j, k);
    }
  }
  function b(j) {
    if (Array.isArray(j)) {
      this.addVocabulary(j);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in j) {
      const U = j[k];
      U.keyword || (U.keyword = k), this.addKeyword(U);
    }
  }
  function F() {
    const j = { ...this.opts };
    for (const k of d)
      delete j[k];
    return j;
  }
  const H = { log() {
  }, warn() {
  }, error() {
  } };
  function q(j) {
    if (j === !1)
      return H;
    if (j === void 0)
      return console;
    if (j.log && j.warn && j.error)
      return j;
    throw new Error("logger must implement log, warn and error methods");
  }
  const $ = /^[a-z_$][a-z0-9_$:-]*$/i;
  function x(j, k) {
    const { RULES: U } = this;
    if ((0, l.eachItem)(j, (M) => {
      if (U.keywords[M])
        throw new Error(`Keyword ${M} is already defined`);
      if (!$.test(M))
        throw new Error(`Keyword ${M} has invalid name`);
    }), !!k && k.$data && !("code" in k || "validate" in k))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function A(j, k, U) {
    var M;
    const T = k == null ? void 0 : k.post;
    if (U && T)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: N } = this;
    let G = T ? N.post : N.rules.find(({ type: S }) => S === U);
    if (G || (G = { type: U, rules: [] }, N.rules.push(G)), N.keywords[j] = !0, !k)
      return;
    const O = {
      keyword: j,
      definition: {
        ...k,
        type: (0, u.getJSONTypes)(k.type),
        schemaType: (0, u.getJSONTypes)(k.schemaType)
      }
    };
    k.before ? P.call(this, G, O, k.before) : G.rules.push(O), N.all[j] = O, (M = k.implements) === null || M === void 0 || M.forEach((S) => this.addKeyword(S));
  }
  function P(j, k, U) {
    const M = j.rules.findIndex((T) => T.keyword === U);
    M >= 0 ? j.rules.splice(M, 0, k) : (j.rules.push(k), this.logger.warn(`rule ${U} is not defined`));
  }
  function D(j) {
    let { metaSchema: k } = j;
    k !== void 0 && (j.$data && this.opts.$data && (k = L(k)), j.validateSchema = this.compile(k, !0));
  }
  const I = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function L(j) {
    return { anyOf: [j, I] };
  }
})(km);
var Jm = {}, Xm = {}, Zm = {};
Object.defineProperty(Zm, "__esModule", { value: !0 });
const DF = {
=======
    addFormat(P, D) {
      return typeof D == "string" && (D = new RegExp(D)), this.formats[P] = D, this;
    }
    errorsText(P = this.errors, { separator: D = ", ", dataVar: F = "data" } = {}) {
      return !P || P.length === 0 ? "No errors" : P.map((w) => `${F}${w.instancePath} ${w.message}`).reduce((w, N) => w + D + N);
    }
    $dataMetaSchema(P, D) {
      const F = this.RULES.all;
      P = JSON.parse(JSON.stringify(P));
      for (const w of D) {
        const N = w.split("/").slice(1);
        let q = P;
        for (const K of N)
          q = q[K];
        for (const K in F) {
          const V = F[K];
          if (typeof V != "object")
            continue;
          const { $data: Z } = V.definition, Y = q[K];
          Z && Y && (q[K] = A(Y));
        }
      }
      return P;
    }
    _removeAllSchemas(P, D) {
      for (const F in P) {
        const w = P[F];
        (!D || D.test(F)) && (typeof w == "string" ? delete P[F] : w && !w.meta && (this._cache.delete(w.schema), delete P[F]));
      }
    }
    _addSchema(P, D, F, w = this.opts.validateSchema, N = this.opts.addUsedSchema) {
      let q;
      const { schemaId: K } = this.opts;
      if (typeof P == "object")
        q = P[K];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof P != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let V = this._cache.get(P);
      if (V !== void 0)
        return V;
      F = (0, c.normalizeId)(q || F);
      const Z = c.getSchemaRefs.call(this, P, F);
      return V = new o.SchemaEnv({ schema: P, schemaId: K, meta: D, baseId: F, localRefs: Z }), this._cache.set(V.schema, V), N && !F.startsWith("#") && (F && this._checkUnique(F), this.refs[F] = V), w && this.validateSchema(P, !0), V;
    }
    _checkUnique(P) {
      if (this.schemas[P] || this.refs[P])
        throw new Error(`schema with key or id "${P}" already exists`);
    }
    _compileSchemaEnv(P) {
      if (P.meta ? this._compileMetaSchema(P) : o.compileSchema.call(this, P), !P.validate)
        throw new Error("ajv implementation error");
      return P.validate;
    }
    _compileMetaSchema(P) {
      const D = this.opts;
      this.opts = this._metaOpts;
      try {
        o.compileSchema.call(this, P);
      } finally {
        this.opts = D;
      }
    }
  }
  _.ValidationError = n.default, _.MissingRefError = s.default, e.default = _;
  function R(k, P, D, F = "error") {
    for (const w in k) {
      const N = w;
      N in P && this.logger[F](`${D}: option ${w}. ${k[N]}`);
    }
  }
  function E(k) {
    return k = (0, c.normalizeId)(k), this.schemas[k] || this.refs[k];
  }
  function O() {
    const k = this.opts.schemas;
    if (k)
      if (Array.isArray(k))
        this.addSchema(k);
      else
        for (const P in k)
          this.addSchema(k[P], P);
  }
  function z() {
    for (const k in this.opts.formats) {
      const P = this.opts.formats[k];
      P && this.addFormat(k, P);
    }
  }
  function S(k) {
    if (Array.isArray(k)) {
      this.addVocabulary(k);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const P in k) {
      const D = k[P];
      D.keyword || (D.keyword = P), this.addKeyword(D);
    }
  }
  function L() {
    const k = { ...this.opts };
    for (const P of u)
      delete k[P];
    return k;
  }
  const M = { log() {
  }, warn() {
  }, error() {
  } };
  function U(k) {
    if (k === !1)
      return M;
    if (k === void 0)
      return console;
    if (k.log && k.warn && k.error)
      return k;
    throw new Error("logger must implement log, warn and error methods");
  }
  const $ = /^[a-z_$][a-z0-9_$:-]*$/i;
  function x(k, P) {
    const { RULES: D } = this;
    if ((0, l.eachItem)(k, (F) => {
      if (D.keywords[F])
        throw new Error(`Keyword ${F} is already defined`);
      if (!$.test(F))
        throw new Error(`Keyword ${F} has invalid name`);
    }), !!P && P.$data && !("code" in P || "validate" in P))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function I(k, P, D) {
    var F;
    const w = P == null ? void 0 : P.post;
    if (D && w)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: N } = this;
    let q = w ? N.post : N.rules.find(({ type: V }) => V === D);
    if (q || (q = { type: D, rules: [] }, N.rules.push(q)), N.keywords[k] = !0, !P)
      return;
    const K = {
      keyword: k,
      definition: {
        ...P,
        type: (0, f.getJSONTypes)(P.type),
        schemaType: (0, f.getJSONTypes)(P.schemaType)
      }
    };
    P.before ? T.call(this, q, K, P.before) : q.rules.push(K), N.all[k] = K, (F = P.implements) === null || F === void 0 || F.forEach((V) => this.addKeyword(V));
  }
  function T(k, P, D) {
    const F = k.rules.findIndex((w) => w.keyword === D);
    F >= 0 ? k.rules.splice(F, 0, P) : (k.rules.push(P), this.logger.warn(`rule ${D} is not defined`));
  }
  function j(k) {
    let { metaSchema: P } = k;
    P !== void 0 && (k.$data && this.opts.$data && (P = A(P)), k.validateSchema = this.compile(P, !0));
  }
  const C = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function A(k) {
    return { anyOf: [k, C] };
  }
})(gf);
var Af = {}, kf = {}, Lf = {};
Object.defineProperty(Lf, "__esModule", { value: !0 });
const jO = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
<<<<<<< HEAD
Zm.default = DF;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.callRef = Jn.getValidate = void 0;
const LF = on, B0 = _e, cr = he, ns = _r, z0 = kt, Oc = se, FF = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: i, schemaEnv: s, validateName: o, opts: a, self: c } = n, { root: u } = s;
    if ((r === "#" || r === "#/") && i === u.baseId)
      return f();
    const l = z0.resolveRef.call(c, u, i, r);
    if (l === void 0)
      throw new LF.default(n.opts.uriResolver, i, r);
    if (l instanceof z0.SchemaEnv)
      return m(l);
    return p(l);
    function f() {
      if (s === u)
        return hl(e, o, s, s.$async);
      const d = t.scopeValue("root", { ref: u });
      return hl(e, (0, cr._)`${d}.validate`, u, u.$async);
    }
    function m(d) {
      const h = FR(e, d);
      hl(e, h, d, d.$async);
    }
    function p(d) {
      const h = t.scopeValue("schema", a.code.source === !0 ? { ref: d, code: (0, cr.stringify)(d) } : { ref: d }), _ = t.name("valid"), g = e.subschema({
        schema: d,
        dataTypes: [],
        schemaPath: cr.nil,
        topSchemaRef: h,
        errSchemaPath: r
      }, _);
      e.mergeEvaluated(g), e.ok(_);
    }
  }
};
function FR(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, cr._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
Jn.getValidate = FR;
function hl(e, t, r, n) {
  const { gen: i, it: s } = e, { allErrors: o, schemaEnv: a, opts: c } = s, u = c.passContext ? ns.default.this : cr.nil;
  n ? l() : f();
  function l() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const d = i.let("valid");
    i.try(() => {
      i.code((0, cr._)`await ${(0, B0.callValidateCode)(e, t, u)}`), p(t), o || i.assign(d, !0);
    }, (h) => {
      i.if((0, cr._)`!(${h} instanceof ${s.ValidationError})`, () => i.throw(h)), m(h), o || i.assign(d, !1);
    }), e.ok(d);
  }
  function f() {
    e.result((0, B0.callValidateCode)(e, t, u), () => p(t), () => m(t));
  }
  function m(d) {
    const h = (0, cr._)`${d}.errors`;
    i.assign(ns.default.vErrors, (0, cr._)`${ns.default.vErrors} === null ? ${h} : ${ns.default.vErrors}.concat(${h})`), i.assign(ns.default.errors, (0, cr._)`${ns.default.vErrors}.length`);
  }
  function p(d) {
    var h;
    if (!s.opts.unevaluated)
      return;
    const _ = (h = r == null ? void 0 : r.validate) === null || h === void 0 ? void 0 : h.evaluated;
    if (s.props !== !0)
      if (_ && !_.dynamicProps)
        _.props !== void 0 && (s.props = Oc.mergeEvaluated.props(i, _.props, s.props));
      else {
        const g = i.var("props", (0, cr._)`${d}.evaluated.props`);
        s.props = Oc.mergeEvaluated.props(i, g, s.props, cr.Name);
      }
    if (s.items !== !0)
      if (_ && !_.dynamicItems)
        _.items !== void 0 && (s.items = Oc.mergeEvaluated.items(i, _.items, s.items));
      else {
        const g = i.var("items", (0, cr._)`${d}.evaluated.items`);
        s.items = Oc.mergeEvaluated.items(i, g, s.items, cr.Name);
      }
  }
}
Jn.callRef = hl;
Jn.default = FF;
Object.defineProperty(Xm, "__esModule", { value: !0 });
const jF = Zm, UF = Jn, MF = [
=======
Lf.default = jO;
var qr = {};
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.callRef = qr.getValidate = void 0;
const DO = mr, Xh = fe, Tt = ae, $n = jt, Zh = dt, Li = re, FO = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: s, schemaEnv: i, validateName: o, opts: a, self: c } = n, { root: f } = i;
    if ((r === "#" || r === "#/") && s === f.baseId)
      return d();
    const l = Zh.resolveRef.call(c, f, s, r);
    if (l === void 0)
      throw new DO.default(n.opts.uriResolver, s, r);
    if (l instanceof Zh.SchemaEnv)
      return g(l);
    return p(l);
    function d() {
      if (i === f)
        return mo(e, o, i, i.$async);
      const u = t.scopeValue("root", { ref: f });
      return mo(e, (0, Tt._)`${u}.validate`, f, f.$async);
    }
    function g(u) {
      const h = x0(e, u);
      mo(e, h, u, u.$async);
    }
    function p(u) {
      const h = t.scopeValue("schema", a.code.source === !0 ? { ref: u, code: (0, Tt.stringify)(u) } : { ref: u }), b = t.name("valid"), m = e.subschema({
        schema: u,
        dataTypes: [],
        schemaPath: Tt.nil,
        topSchemaRef: h,
        errSchemaPath: r
      }, b);
      e.mergeEvaluated(m), e.ok(b);
    }
  }
};
function x0(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Tt._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
qr.getValidate = x0;
function mo(e, t, r, n) {
  const { gen: s, it: i } = e, { allErrors: o, schemaEnv: a, opts: c } = i, f = c.passContext ? $n.default.this : Tt.nil;
  n ? l() : d();
  function l() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const u = s.let("valid");
    s.try(() => {
      s.code((0, Tt._)`await ${(0, Xh.callValidateCode)(e, t, f)}`), p(t), o || s.assign(u, !0);
    }, (h) => {
      s.if((0, Tt._)`!(${h} instanceof ${i.ValidationError})`, () => s.throw(h)), g(h), o || s.assign(u, !1);
    }), e.ok(u);
  }
  function d() {
    e.result((0, Xh.callValidateCode)(e, t, f), () => p(t), () => g(t));
  }
  function g(u) {
    const h = (0, Tt._)`${u}.errors`;
    s.assign($n.default.vErrors, (0, Tt._)`${$n.default.vErrors} === null ? ${h} : ${$n.default.vErrors}.concat(${h})`), s.assign($n.default.errors, (0, Tt._)`${$n.default.vErrors}.length`);
  }
  function p(u) {
    var h;
    if (!i.opts.unevaluated)
      return;
    const b = (h = r == null ? void 0 : r.validate) === null || h === void 0 ? void 0 : h.evaluated;
    if (i.props !== !0)
      if (b && !b.dynamicProps)
        b.props !== void 0 && (i.props = Li.mergeEvaluated.props(s, b.props, i.props));
      else {
        const m = s.var("props", (0, Tt._)`${u}.evaluated.props`);
        i.props = Li.mergeEvaluated.props(s, m, i.props, Tt.Name);
      }
    if (i.items !== !0)
      if (b && !b.dynamicItems)
        b.items !== void 0 && (i.items = Li.mergeEvaluated.items(s, b.items, i.items));
      else {
        const m = s.var("items", (0, Tt._)`${u}.evaluated.items`);
        i.items = Li.mergeEvaluated.items(s, m, i.items, Tt.Name);
      }
  }
}
qr.callRef = mo;
qr.default = FO;
Object.defineProperty(kf, "__esModule", { value: !0 });
const MO = Lf, zO = qr, UO = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
<<<<<<< HEAD
  jF.default,
  UF.default
];
Xm.default = MF;
var Qm = {}, eg = {};
Object.defineProperty(eg, "__esModule", { value: !0 });
const Hl = he, Nn = Hl.operators, ql = {
  maximum: { okStr: "<=", ok: Nn.LTE, fail: Nn.GT },
  minimum: { okStr: ">=", ok: Nn.GTE, fail: Nn.LT },
  exclusiveMaximum: { okStr: "<", ok: Nn.LT, fail: Nn.GTE },
  exclusiveMinimum: { okStr: ">", ok: Nn.GT, fail: Nn.LTE }
}, HF = {
  message: ({ keyword: e, schemaCode: t }) => (0, Hl.str)`must be ${ql[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, Hl._)`{comparison: ${ql[e].okStr}, limit: ${t}}`
}, qF = {
  keyword: Object.keys(ql),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: HF,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, Hl._)`${r} ${ql[t].fail} ${n} || isNaN(${r})`);
  }
};
eg.default = qF;
var tg = {};
Object.defineProperty(tg, "__esModule", { value: !0 });
const Yo = he, BF = {
  message: ({ schemaCode: e }) => (0, Yo.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, Yo._)`{multipleOf: ${e}}`
}, zF = {
=======
  MO.default,
  zO.default
];
kf.default = UO;
var jf = {}, Df = {};
Object.defineProperty(Df, "__esModule", { value: !0 });
const Fo = ae, Ir = Fo.operators, Mo = {
  maximum: { okStr: "<=", ok: Ir.LTE, fail: Ir.GT },
  minimum: { okStr: ">=", ok: Ir.GTE, fail: Ir.LT },
  exclusiveMaximum: { okStr: "<", ok: Ir.LT, fail: Ir.GTE },
  exclusiveMinimum: { okStr: ">", ok: Ir.GT, fail: Ir.LTE }
}, qO = {
  message: ({ keyword: e, schemaCode: t }) => (0, Fo.str)`must be ${Mo[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, Fo._)`{comparison: ${Mo[e].okStr}, limit: ${t}}`
}, HO = {
  keyword: Object.keys(Mo),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: qO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, Fo._)`${r} ${Mo[t].fail} ${n} || isNaN(${r})`);
  }
};
Df.default = HO;
var Ff = {};
Object.defineProperty(Ff, "__esModule", { value: !0 });
const Ds = ae, BO = {
  message: ({ schemaCode: e }) => (0, Ds.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, Ds._)`{multipleOf: ${e}}`
}, VO = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
<<<<<<< HEAD
  error: BF,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: i } = e, s = i.opts.multipleOfPrecision, o = t.let("res"), a = s ? (0, Yo._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${s}` : (0, Yo._)`${o} !== parseInt(${o})`;
    e.fail$data((0, Yo._)`(${n} === 0 || (${o} = ${r}/${n}, ${a}))`);
  }
};
tg.default = zF;
var rg = {}, ng = {};
Object.defineProperty(ng, "__esModule", { value: !0 });
function jR(e) {
  const t = e.length;
  let r = 0, n = 0, i;
  for (; n < t; )
    r++, i = e.charCodeAt(n++), i >= 55296 && i <= 56319 && n < t && (i = e.charCodeAt(n), (i & 64512) === 56320 && n++);
  return r;
}
ng.default = jR;
jR.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(rg, "__esModule", { value: !0 });
const Ri = he, VF = se, GF = ng, WF = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, Ri.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, Ri._)`{limit: ${e}}`
}, KF = {
=======
  error: BO,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: s } = e, i = s.opts.multipleOfPrecision, o = t.let("res"), a = i ? (0, Ds._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${i}` : (0, Ds._)`${o} !== parseInt(${o})`;
    e.fail$data((0, Ds._)`(${n} === 0 || (${o} = ${r}/${n}, ${a}))`);
  }
};
Ff.default = VO;
var Mf = {}, zf = {};
Object.defineProperty(zf, "__esModule", { value: !0 });
function w0(e) {
  const t = e.length;
  let r = 0, n = 0, s;
  for (; n < t; )
    r++, s = e.charCodeAt(n++), s >= 55296 && s <= 56319 && n < t && (s = e.charCodeAt(n), (s & 64512) === 56320 && n++);
  return r;
}
zf.default = w0;
w0.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Mf, "__esModule", { value: !0 });
const rn = ae, GO = re, WO = zf, KO = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, rn.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, rn._)`{limit: ${e}}`
}, JO = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
<<<<<<< HEAD
  error: WF,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: i } = e, s = t === "maxLength" ? Ri.operators.GT : Ri.operators.LT, o = i.opts.unicode === !1 ? (0, Ri._)`${r}.length` : (0, Ri._)`${(0, VF.useFunc)(e.gen, GF.default)}(${r})`;
    e.fail$data((0, Ri._)`${o} ${s} ${n}`);
  }
};
rg.default = KF;
var ig = {};
Object.defineProperty(ig, "__esModule", { value: !0 });
const YF = _e, Bl = he, JF = {
  message: ({ schemaCode: e }) => (0, Bl.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, Bl._)`{pattern: ${e}}`
}, XF = {
=======
  error: KO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: s } = e, i = t === "maxLength" ? rn.operators.GT : rn.operators.LT, o = s.opts.unicode === !1 ? (0, rn._)`${r}.length` : (0, rn._)`${(0, GO.useFunc)(e.gen, WO.default)}(${r})`;
    e.fail$data((0, rn._)`${o} ${i} ${n}`);
  }
};
Mf.default = JO;
var Uf = {};
Object.defineProperty(Uf, "__esModule", { value: !0 });
const YO = fe, zo = ae, XO = {
  message: ({ schemaCode: e }) => (0, zo.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, zo._)`{pattern: ${e}}`
}, ZO = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
<<<<<<< HEAD
  error: JF,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: i, it: s } = e, o = s.opts.unicodeRegExp ? "u" : "", a = r ? (0, Bl._)`(new RegExp(${i}, ${o}))` : (0, YF.usePattern)(e, n);
    e.fail$data((0, Bl._)`!${a}.test(${t})`);
  }
};
ig.default = XF;
var sg = {};
Object.defineProperty(sg, "__esModule", { value: !0 });
const Jo = he, ZF = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Jo.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Jo._)`{limit: ${e}}`
}, QF = {
=======
  error: XO,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: s, it: i } = e, o = i.opts.unicodeRegExp ? "u" : "", a = r ? (0, zo._)`(new RegExp(${s}, ${o}))` : (0, YO.usePattern)(e, n);
    e.fail$data((0, zo._)`!${a}.test(${t})`);
  }
};
Uf.default = ZO;
var qf = {};
Object.defineProperty(qf, "__esModule", { value: !0 });
const Fs = ae, QO = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Fs.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Fs._)`{limit: ${e}}`
}, eC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
<<<<<<< HEAD
  error: ZF,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxProperties" ? Jo.operators.GT : Jo.operators.LT;
    e.fail$data((0, Jo._)`Object.keys(${r}).length ${i} ${n}`);
  }
};
sg.default = QF;
var og = {};
Object.defineProperty(og, "__esModule", { value: !0 });
const xo = _e, Xo = he, ej = se, tj = {
  message: ({ params: { missingProperty: e } }) => (0, Xo.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, Xo._)`{missingProperty: ${e}}`
}, rj = {
=======
  error: QO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, s = t === "maxProperties" ? Fs.operators.GT : Fs.operators.LT;
    e.fail$data((0, Fs._)`Object.keys(${r}).length ${s} ${n}`);
  }
};
qf.default = eC;
var Hf = {};
Object.defineProperty(Hf, "__esModule", { value: !0 });
const vs = fe, Ms = ae, tC = re, rC = {
  message: ({ params: { missingProperty: e } }) => (0, Ms.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, Ms._)`{missingProperty: ${e}}`
}, nC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
<<<<<<< HEAD
  error: tj,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: i, $data: s, it: o } = e, { opts: a } = o;
    if (!s && r.length === 0)
      return;
    const c = r.length >= a.loopRequired;
    if (o.allErrors ? u() : l(), a.strictRequired) {
      const p = e.parentSchema.properties, { definedProperties: d } = e.it;
      for (const h of r)
        if ((p == null ? void 0 : p[h]) === void 0 && !d.has(h)) {
          const _ = o.schemaEnv.baseId + o.errSchemaPath, g = `required property "${h}" is not defined at "${_}" (strictRequired)`;
          (0, ej.checkStrictMode)(o, g, o.opts.strictRequired);
        }
    }
    function u() {
      if (c || s)
        e.block$data(Xo.nil, f);
      else
        for (const p of r)
          (0, xo.checkReportMissingProp)(e, p);
    }
    function l() {
      const p = t.let("missing");
      if (c || s) {
        const d = t.let("valid", !0);
        e.block$data(d, () => m(p, d)), e.ok(d);
      } else
        t.if((0, xo.checkMissingProp)(e, r, p)), (0, xo.reportMissingProp)(e, p), t.else();
    }
    function f() {
      t.forOf("prop", n, (p) => {
        e.setParams({ missingProperty: p }), t.if((0, xo.noPropertyInData)(t, i, p, a.ownProperties), () => e.error());
      });
    }
    function m(p, d) {
      e.setParams({ missingProperty: p }), t.forOf(p, n, () => {
        t.assign(d, (0, xo.propertyInData)(t, i, p, a.ownProperties)), t.if((0, Xo.not)(d), () => {
          e.error(), t.break();
        });
      }, Xo.nil);
    }
  }
};
og.default = rj;
var ag = {};
Object.defineProperty(ag, "__esModule", { value: !0 });
const Zo = he, nj = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, Zo.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, Zo._)`{limit: ${e}}`
}, ij = {
=======
  error: rC,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: s, $data: i, it: o } = e, { opts: a } = o;
    if (!i && r.length === 0)
      return;
    const c = r.length >= a.loopRequired;
    if (o.allErrors ? f() : l(), a.strictRequired) {
      const p = e.parentSchema.properties, { definedProperties: u } = e.it;
      for (const h of r)
        if ((p == null ? void 0 : p[h]) === void 0 && !u.has(h)) {
          const b = o.schemaEnv.baseId + o.errSchemaPath, m = `required property "${h}" is not defined at "${b}" (strictRequired)`;
          (0, tC.checkStrictMode)(o, m, o.opts.strictRequired);
        }
    }
    function f() {
      if (c || i)
        e.block$data(Ms.nil, d);
      else
        for (const p of r)
          (0, vs.checkReportMissingProp)(e, p);
    }
    function l() {
      const p = t.let("missing");
      if (c || i) {
        const u = t.let("valid", !0);
        e.block$data(u, () => g(p, u)), e.ok(u);
      } else
        t.if((0, vs.checkMissingProp)(e, r, p)), (0, vs.reportMissingProp)(e, p), t.else();
    }
    function d() {
      t.forOf("prop", n, (p) => {
        e.setParams({ missingProperty: p }), t.if((0, vs.noPropertyInData)(t, s, p, a.ownProperties), () => e.error());
      });
    }
    function g(p, u) {
      e.setParams({ missingProperty: p }), t.forOf(p, n, () => {
        t.assign(u, (0, vs.propertyInData)(t, s, p, a.ownProperties)), t.if((0, Ms.not)(u), () => {
          e.error(), t.break();
        });
      }, Ms.nil);
    }
  }
};
Hf.default = nC;
var Bf = {};
Object.defineProperty(Bf, "__esModule", { value: !0 });
const zs = ae, sC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, zs.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, zs._)`{limit: ${e}}`
}, iC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
<<<<<<< HEAD
  error: nj,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxItems" ? Zo.operators.GT : Zo.operators.LT;
    e.fail$data((0, Zo._)`${r}.length ${i} ${n}`);
  }
};
ag.default = ij;
var cg = {}, ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
const UR = ju;
UR.code = 'require("ajv/dist/runtime/equal").default';
ro.default = UR;
Object.defineProperty(cg, "__esModule", { value: !0 });
const Id = yt, Pt = he, sj = se, oj = ro, aj = {
  message: ({ params: { i: e, j: t } }) => (0, Pt.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, Pt._)`{i: ${e}, j: ${t}}`
}, cj = {
=======
  error: sC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, s = t === "maxItems" ? zs.operators.GT : zs.operators.LT;
    e.fail$data((0, zs._)`${r}.length ${s} ${n}`);
  }
};
Bf.default = iC;
var Vf = {}, os = {};
Object.defineProperty(os, "__esModule", { value: !0 });
const R0 = ba;
R0.code = 'require("ajv/dist/runtime/equal").default';
os.default = R0;
Object.defineProperty(Vf, "__esModule", { value: !0 });
const Kc = tt, ct = ae, oC = re, aC = os, cC = {
  message: ({ params: { i: e, j: t } }) => (0, ct.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, ct._)`{i: ${e}, j: ${t}}`
}, lC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
<<<<<<< HEAD
  error: aj,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, parentSchema: s, schemaCode: o, it: a } = e;
    if (!n && !i)
      return;
    const c = t.let("valid"), u = s.items ? (0, Id.getSchemaTypes)(s.items) : [];
    e.block$data(c, l, (0, Pt._)`${o} === false`), e.ok(c);
    function l() {
      const d = t.let("i", (0, Pt._)`${r}.length`), h = t.let("j");
      e.setParams({ i: d, j: h }), t.assign(c, !0), t.if((0, Pt._)`${d} > 1`, () => (f() ? m : p)(d, h));
    }
    function f() {
      return u.length > 0 && !u.some((d) => d === "object" || d === "array");
    }
    function m(d, h) {
      const _ = t.name("item"), g = (0, Id.checkDataTypes)(u, _, a.opts.strictNumbers, Id.DataType.Wrong), v = t.const("indices", (0, Pt._)`{}`);
      t.for((0, Pt._)`;${d}--;`, () => {
        t.let(_, (0, Pt._)`${r}[${d}]`), t.if(g, (0, Pt._)`continue`), u.length > 1 && t.if((0, Pt._)`typeof ${_} == "string"`, (0, Pt._)`${_} += "_"`), t.if((0, Pt._)`typeof ${v}[${_}] == "number"`, () => {
          t.assign(h, (0, Pt._)`${v}[${_}]`), e.error(), t.assign(c, !1).break();
        }).code((0, Pt._)`${v}[${_}] = ${d}`);
      });
    }
    function p(d, h) {
      const _ = (0, sj.useFunc)(t, oj.default), g = t.name("outer");
      t.label(g).for((0, Pt._)`;${d}--;`, () => t.for((0, Pt._)`${h} = ${d}; ${h}--;`, () => t.if((0, Pt._)`${_}(${r}[${d}], ${r}[${h}])`, () => {
        e.error(), t.assign(c, !1).break(g);
=======
  error: cC,
  code(e) {
    const { gen: t, data: r, $data: n, schema: s, parentSchema: i, schemaCode: o, it: a } = e;
    if (!n && !s)
      return;
    const c = t.let("valid"), f = i.items ? (0, Kc.getSchemaTypes)(i.items) : [];
    e.block$data(c, l, (0, ct._)`${o} === false`), e.ok(c);
    function l() {
      const u = t.let("i", (0, ct._)`${r}.length`), h = t.let("j");
      e.setParams({ i: u, j: h }), t.assign(c, !0), t.if((0, ct._)`${u} > 1`, () => (d() ? g : p)(u, h));
    }
    function d() {
      return f.length > 0 && !f.some((u) => u === "object" || u === "array");
    }
    function g(u, h) {
      const b = t.name("item"), m = (0, Kc.checkDataTypes)(f, b, a.opts.strictNumbers, Kc.DataType.Wrong), v = t.const("indices", (0, ct._)`{}`);
      t.for((0, ct._)`;${u}--;`, () => {
        t.let(b, (0, ct._)`${r}[${u}]`), t.if(m, (0, ct._)`continue`), f.length > 1 && t.if((0, ct._)`typeof ${b} == "string"`, (0, ct._)`${b} += "_"`), t.if((0, ct._)`typeof ${v}[${b}] == "number"`, () => {
          t.assign(h, (0, ct._)`${v}[${b}]`), e.error(), t.assign(c, !1).break();
        }).code((0, ct._)`${v}[${b}] = ${u}`);
      });
    }
    function p(u, h) {
      const b = (0, oC.useFunc)(t, aC.default), m = t.name("outer");
      t.label(m).for((0, ct._)`;${u}--;`, () => t.for((0, ct._)`${h} = ${u}; ${h}--;`, () => t.if((0, ct._)`${b}(${r}[${u}], ${r}[${h}])`, () => {
        e.error(), t.assign(c, !1).break(m);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      })));
    }
  }
};
<<<<<<< HEAD
cg.default = cj;
var lg = {};
Object.defineProperty(lg, "__esModule", { value: !0 });
const Eh = he, lj = se, uj = ro, fj = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, Eh._)`{allowedValue: ${e}}`
}, dj = {
  keyword: "const",
  $data: !0,
  error: fj,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: i, schema: s } = e;
    n || s && typeof s == "object" ? e.fail$data((0, Eh._)`!${(0, lj.useFunc)(t, uj.default)}(${r}, ${i})`) : e.fail((0, Eh._)`${s} !== ${r}`);
  }
};
lg.default = dj;
var ug = {};
Object.defineProperty(ug, "__esModule", { value: !0 });
const Bo = he, pj = se, hj = ro, mj = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Bo._)`{allowedValues: ${e}}`
}, gj = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: mj,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, schemaCode: s, it: o } = e;
    if (!n && i.length === 0)
      throw new Error("enum must have non-empty array");
    const a = i.length >= o.opts.loopEnum;
    let c;
    const u = () => c ?? (c = (0, pj.useFunc)(t, hj.default));
    let l;
    if (a || n)
      l = t.let("valid"), e.block$data(l, f);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const p = t.const("vSchema", s);
      l = (0, Bo.or)(...i.map((d, h) => m(p, h)));
    }
    e.pass(l);
    function f() {
      t.assign(l, !1), t.forOf("v", s, (p) => t.if((0, Bo._)`${u()}(${r}, ${p})`, () => t.assign(l, !0).break()));
    }
    function m(p, d) {
      const h = i[d];
      return typeof h == "object" && h !== null ? (0, Bo._)`${u()}(${r}, ${p}[${d}])` : (0, Bo._)`${r} === ${h}`;
    }
  }
};
ug.default = gj;
Object.defineProperty(Qm, "__esModule", { value: !0 });
const yj = eg, vj = tg, _j = rg, bj = ig, Ej = sg, wj = og, Sj = ag, xj = cg, Rj = lg, $j = ug, Tj = [
  // number
  yj.default,
  vj.default,
  // string
  _j.default,
  bj.default,
  // object
  Ej.default,
  wj.default,
  // array
  Sj.default,
  xj.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  Rj.default,
  $j.default
];
Qm.default = Tj;
var fg = {}, no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.validateAdditionalItems = void 0;
const $i = he, wh = se, Oj = {
  message: ({ params: { len: e } }) => (0, $i.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, $i._)`{limit: ${e}}`
}, Pj = {
=======
Vf.default = lC;
var Gf = {};
Object.defineProperty(Gf, "__esModule", { value: !0 });
const yu = ae, uC = re, fC = os, dC = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, yu._)`{allowedValue: ${e}}`
}, pC = {
  keyword: "const",
  $data: !0,
  error: dC,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: s, schema: i } = e;
    n || i && typeof i == "object" ? e.fail$data((0, yu._)`!${(0, uC.useFunc)(t, fC.default)}(${r}, ${s})`) : e.fail((0, yu._)`${i} !== ${r}`);
  }
};
Gf.default = pC;
var Wf = {};
Object.defineProperty(Wf, "__esModule", { value: !0 });
const As = ae, hC = re, mC = os, yC = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, As._)`{allowedValues: ${e}}`
}, gC = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: yC,
  code(e) {
    const { gen: t, data: r, $data: n, schema: s, schemaCode: i, it: o } = e;
    if (!n && s.length === 0)
      throw new Error("enum must have non-empty array");
    const a = s.length >= o.opts.loopEnum;
    let c;
    const f = () => c ?? (c = (0, hC.useFunc)(t, mC.default));
    let l;
    if (a || n)
      l = t.let("valid"), e.block$data(l, d);
    else {
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const p = t.const("vSchema", i);
      l = (0, As.or)(...s.map((u, h) => g(p, h)));
    }
    e.pass(l);
    function d() {
      t.assign(l, !1), t.forOf("v", i, (p) => t.if((0, As._)`${f()}(${r}, ${p})`, () => t.assign(l, !0).break()));
    }
    function g(p, u) {
      const h = s[u];
      return typeof h == "object" && h !== null ? (0, As._)`${f()}(${r}, ${p}[${u}])` : (0, As._)`${r} === ${h}`;
    }
  }
};
Wf.default = gC;
Object.defineProperty(jf, "__esModule", { value: !0 });
const vC = Df, bC = Ff, _C = Mf, EC = Uf, SC = qf, xC = Hf, wC = Bf, RC = Vf, $C = Gf, TC = Wf, OC = [
  // number
  vC.default,
  bC.default,
  // string
  _C.default,
  EC.default,
  // object
  SC.default,
  xC.default,
  // array
  wC.default,
  RC.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  $C.default,
  TC.default
];
jf.default = OC;
var Kf = {}, as = {};
Object.defineProperty(as, "__esModule", { value: !0 });
as.validateAdditionalItems = void 0;
const nn = ae, gu = re, CC = {
  message: ({ params: { len: e } }) => (0, nn.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, nn._)`{limit: ${e}}`
}, PC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
<<<<<<< HEAD
  error: Oj,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, wh.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    MR(e, n);
  }
};
function MR(e, t) {
  const { gen: r, schema: n, data: i, keyword: s, it: o } = e;
  o.items = !0;
  const a = r.const("len", (0, $i._)`${i}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, $i._)`${a} <= ${t.length}`);
  else if (typeof n == "object" && !(0, wh.alwaysValidSchema)(o, n)) {
    const u = r.var("valid", (0, $i._)`${a} <= ${t.length}`);
    r.if((0, $i.not)(u), () => c(u)), e.ok(u);
  }
  function c(u) {
    r.forRange("i", t.length, a, (l) => {
      e.subschema({ keyword: s, dataProp: l, dataPropType: wh.Type.Num }, u), o.allErrors || r.if((0, $i.not)(u), () => r.break());
    });
  }
}
no.validateAdditionalItems = MR;
no.default = Pj;
var dg = {}, io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.validateTuple = void 0;
const V0 = he, ml = se, Cj = _e, Aj = {
=======
  error: CC,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, gu.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    $0(e, n);
  }
};
function $0(e, t) {
  const { gen: r, schema: n, data: s, keyword: i, it: o } = e;
  o.items = !0;
  const a = r.const("len", (0, nn._)`${s}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, nn._)`${a} <= ${t.length}`);
  else if (typeof n == "object" && !(0, gu.alwaysValidSchema)(o, n)) {
    const f = r.var("valid", (0, nn._)`${a} <= ${t.length}`);
    r.if((0, nn.not)(f), () => c(f)), e.ok(f);
  }
  function c(f) {
    r.forRange("i", t.length, a, (l) => {
      e.subschema({ keyword: i, dataProp: l, dataPropType: gu.Type.Num }, f), o.allErrors || r.if((0, nn.not)(f), () => r.break());
    });
  }
}
as.validateAdditionalItems = $0;
as.default = PC;
var Jf = {}, cs = {};
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.validateTuple = void 0;
const Qh = ae, yo = re, IC = fe, NC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
<<<<<<< HEAD
      return HR(e, "additionalItems", t);
    r.items = !0, !(0, ml.alwaysValidSchema)(r, t) && e.ok((0, Cj.validateArray)(e));
  }
};
function HR(e, t, r = e.schema) {
  const { gen: n, parentSchema: i, data: s, keyword: o, it: a } = e;
  l(i), a.opts.unevaluated && r.length && a.items !== !0 && (a.items = ml.mergeEvaluated.items(n, r.length, a.items));
  const c = n.name("valid"), u = n.const("len", (0, V0._)`${s}.length`);
  r.forEach((f, m) => {
    (0, ml.alwaysValidSchema)(a, f) || (n.if((0, V0._)`${u} > ${m}`, () => e.subschema({
      keyword: o,
      schemaProp: m,
      dataProp: m
    }, c)), e.ok(c));
  });
  function l(f) {
    const { opts: m, errSchemaPath: p } = a, d = r.length, h = d === f.minItems && (d === f.maxItems || f[t] === !1);
    if (m.strictTuples && !h) {
      const _ = `"${o}" is ${d}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, ml.checkStrictMode)(a, _, m.strictTuples);
    }
  }
}
io.validateTuple = HR;
io.default = Aj;
Object.defineProperty(dg, "__esModule", { value: !0 });
const Ij = io, Nj = {
=======
      return T0(e, "additionalItems", t);
    r.items = !0, !(0, yo.alwaysValidSchema)(r, t) && e.ok((0, IC.validateArray)(e));
  }
};
function T0(e, t, r = e.schema) {
  const { gen: n, parentSchema: s, data: i, keyword: o, it: a } = e;
  l(s), a.opts.unevaluated && r.length && a.items !== !0 && (a.items = yo.mergeEvaluated.items(n, r.length, a.items));
  const c = n.name("valid"), f = n.const("len", (0, Qh._)`${i}.length`);
  r.forEach((d, g) => {
    (0, yo.alwaysValidSchema)(a, d) || (n.if((0, Qh._)`${f} > ${g}`, () => e.subschema({
      keyword: o,
      schemaProp: g,
      dataProp: g
    }, c)), e.ok(c));
  });
  function l(d) {
    const { opts: g, errSchemaPath: p } = a, u = r.length, h = u === d.minItems && (u === d.maxItems || d[t] === !1);
    if (g.strictTuples && !h) {
      const b = `"${o}" is ${u}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, yo.checkStrictMode)(a, b, g.strictTuples);
    }
  }
}
cs.validateTuple = T0;
cs.default = NC;
Object.defineProperty(Jf, "__esModule", { value: !0 });
const AC = cs, kC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
<<<<<<< HEAD
  code: (e) => (0, Ij.validateTuple)(e, "items")
};
dg.default = Nj;
var pg = {};
Object.defineProperty(pg, "__esModule", { value: !0 });
const G0 = he, kj = se, Dj = _e, Lj = no, Fj = {
  message: ({ params: { len: e } }) => (0, G0.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, G0._)`{limit: ${e}}`
}, jj = {
=======
  code: (e) => (0, AC.validateTuple)(e, "items")
};
Jf.default = kC;
var Yf = {};
Object.defineProperty(Yf, "__esModule", { value: !0 });
const em = ae, LC = re, jC = fe, DC = as, FC = {
  message: ({ params: { len: e } }) => (0, em.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, em._)`{limit: ${e}}`
}, MC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
<<<<<<< HEAD
  error: Fj,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: i } = r;
    n.items = !0, !(0, kj.alwaysValidSchema)(n, t) && (i ? (0, Lj.validateAdditionalItems)(e, i) : e.ok((0, Dj.validateArray)(e)));
  }
};
pg.default = jj;
var hg = {};
Object.defineProperty(hg, "__esModule", { value: !0 });
const $r = he, Pc = se, Uj = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, $r.str)`must contain at least ${e} valid item(s)` : (0, $r.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, $r._)`{minContains: ${e}}` : (0, $r._)`{minContains: ${e}, maxContains: ${t}}`
}, Mj = {
=======
  error: FC,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: s } = r;
    n.items = !0, !(0, LC.alwaysValidSchema)(n, t) && (s ? (0, DC.validateAdditionalItems)(e, s) : e.ok((0, jC.validateArray)(e)));
  }
};
Yf.default = MC;
var Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 });
const Ft = ae, ji = re, zC = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ft.str)`must contain at least ${e} valid item(s)` : (0, Ft.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ft._)`{minContains: ${e}}` : (0, Ft._)`{minContains: ${e}, maxContains: ${t}}`
}, UC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
<<<<<<< HEAD
  error: Uj,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: s } = e;
    let o, a;
    const { minContains: c, maxContains: u } = n;
    s.opts.next ? (o = c === void 0 ? 1 : c, a = u) : o = 1;
    const l = t.const("len", (0, $r._)`${i}.length`);
    if (e.setParams({ min: o, max: a }), a === void 0 && o === 0) {
      (0, Pc.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && o > a) {
      (0, Pc.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, Pc.alwaysValidSchema)(s, r)) {
      let h = (0, $r._)`${l} >= ${o}`;
      a !== void 0 && (h = (0, $r._)`${h} && ${l} <= ${a}`), e.pass(h);
      return;
    }
    s.items = !0;
    const f = t.name("valid");
    a === void 0 && o === 1 ? p(f, () => t.if(f, () => t.break())) : o === 0 ? (t.let(f, !0), a !== void 0 && t.if((0, $r._)`${i}.length > 0`, m)) : (t.let(f, !1), m()), e.result(f, () => e.reset());
    function m() {
      const h = t.name("_valid"), _ = t.let("count", 0);
      p(h, () => t.if(h, () => d(_)));
    }
    function p(h, _) {
      t.forRange("i", 0, l, (g) => {
        e.subschema({
          keyword: "contains",
          dataProp: g,
          dataPropType: Pc.Type.Num,
          compositeRule: !0
        }, h), _();
      });
    }
    function d(h) {
      t.code((0, $r._)`${h}++`), a === void 0 ? t.if((0, $r._)`${h} >= ${o}`, () => t.assign(f, !0).break()) : (t.if((0, $r._)`${h} > ${a}`, () => t.assign(f, !1).break()), o === 1 ? t.assign(f, !0) : t.if((0, $r._)`${h} >= ${o}`, () => t.assign(f, !0)));
    }
  }
};
hg.default = Mj;
var qR = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = he, r = se, n = _e;
  e.error = {
    message: ({ params: { property: c, depsCount: u, deps: l } }) => {
      const f = u === 1 ? "property" : "properties";
      return (0, t.str)`must have ${f} ${l} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: u, deps: l, missingProperty: f } }) => (0, t._)`{property: ${c},
    missingProperty: ${f},
    depsCount: ${u},
    deps: ${l}}`
    // TODO change to reference
  };
  const i = {
=======
  error: zC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, it: i } = e;
    let o, a;
    const { minContains: c, maxContains: f } = n;
    i.opts.next ? (o = c === void 0 ? 1 : c, a = f) : o = 1;
    const l = t.const("len", (0, Ft._)`${s}.length`);
    if (e.setParams({ min: o, max: a }), a === void 0 && o === 0) {
      (0, ji.checkStrictMode)(i, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && o > a) {
      (0, ji.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, ji.alwaysValidSchema)(i, r)) {
      let h = (0, Ft._)`${l} >= ${o}`;
      a !== void 0 && (h = (0, Ft._)`${h} && ${l} <= ${a}`), e.pass(h);
      return;
    }
    i.items = !0;
    const d = t.name("valid");
    a === void 0 && o === 1 ? p(d, () => t.if(d, () => t.break())) : o === 0 ? (t.let(d, !0), a !== void 0 && t.if((0, Ft._)`${s}.length > 0`, g)) : (t.let(d, !1), g()), e.result(d, () => e.reset());
    function g() {
      const h = t.name("_valid"), b = t.let("count", 0);
      p(h, () => t.if(h, () => u(b)));
    }
    function p(h, b) {
      t.forRange("i", 0, l, (m) => {
        e.subschema({
          keyword: "contains",
          dataProp: m,
          dataPropType: ji.Type.Num,
          compositeRule: !0
        }, h), b();
      });
    }
    function u(h) {
      t.code((0, Ft._)`${h}++`), a === void 0 ? t.if((0, Ft._)`${h} >= ${o}`, () => t.assign(d, !0).break()) : (t.if((0, Ft._)`${h} > ${a}`, () => t.assign(d, !1).break()), o === 1 ? t.assign(d, !0) : t.if((0, Ft._)`${h} >= ${o}`, () => t.assign(d, !0)));
    }
  }
};
Xf.default = UC;
var O0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = ae, r = re, n = fe;
  e.error = {
    message: ({ params: { property: c, depsCount: f, deps: l } }) => {
      const d = f === 1 ? "property" : "properties";
      return (0, t.str)`must have ${d} ${l} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: f, deps: l, missingProperty: d } }) => (0, t._)`{property: ${c},
    missingProperty: ${d},
    depsCount: ${f},
    deps: ${l}}`
    // TODO change to reference
  };
  const s = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
<<<<<<< HEAD
      const [u, l] = s(c);
      o(c, u), a(c, l);
    }
  };
  function s({ schema: c }) {
    const u = {}, l = {};
    for (const f in c) {
      if (f === "__proto__")
        continue;
      const m = Array.isArray(c[f]) ? u : l;
      m[f] = c[f];
    }
    return [u, l];
  }
  function o(c, u = c.schema) {
    const { gen: l, data: f, it: m } = c;
    if (Object.keys(u).length === 0)
      return;
    const p = l.let("missing");
    for (const d in u) {
      const h = u[d];
      if (h.length === 0)
        continue;
      const _ = (0, n.propertyInData)(l, f, d, m.opts.ownProperties);
      c.setParams({
        property: d,
        depsCount: h.length,
        deps: h.join(", ")
      }), m.allErrors ? l.if(_, () => {
        for (const g of h)
          (0, n.checkReportMissingProp)(c, g);
      }) : (l.if((0, t._)`${_} && (${(0, n.checkMissingProp)(c, h, p)})`), (0, n.reportMissingProp)(c, p), l.else());
    }
  }
  e.validatePropertyDeps = o;
  function a(c, u = c.schema) {
    const { gen: l, data: f, keyword: m, it: p } = c, d = l.name("valid");
    for (const h in u)
      (0, r.alwaysValidSchema)(p, u[h]) || (l.if(
        (0, n.propertyInData)(l, f, h, p.opts.ownProperties),
        () => {
          const _ = c.subschema({ keyword: m, schemaProp: h }, d);
          c.mergeValidEvaluated(_, d);
        },
        () => l.var(d, !0)
        // TODO var
      ), c.ok(d));
  }
  e.validateSchemaDeps = a, e.default = i;
})(qR);
var mg = {};
Object.defineProperty(mg, "__esModule", { value: !0 });
const BR = he, Hj = se, qj = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, BR._)`{propertyName: ${e.propertyName}}`
}, Bj = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: qj,
  code(e) {
    const { gen: t, schema: r, data: n, it: i } = e;
    if ((0, Hj.alwaysValidSchema)(i, r))
      return;
    const s = t.name("valid");
=======
      const [f, l] = i(c);
      o(c, f), a(c, l);
    }
  };
  function i({ schema: c }) {
    const f = {}, l = {};
    for (const d in c) {
      if (d === "__proto__")
        continue;
      const g = Array.isArray(c[d]) ? f : l;
      g[d] = c[d];
    }
    return [f, l];
  }
  function o(c, f = c.schema) {
    const { gen: l, data: d, it: g } = c;
    if (Object.keys(f).length === 0)
      return;
    const p = l.let("missing");
    for (const u in f) {
      const h = f[u];
      if (h.length === 0)
        continue;
      const b = (0, n.propertyInData)(l, d, u, g.opts.ownProperties);
      c.setParams({
        property: u,
        depsCount: h.length,
        deps: h.join(", ")
      }), g.allErrors ? l.if(b, () => {
        for (const m of h)
          (0, n.checkReportMissingProp)(c, m);
      }) : (l.if((0, t._)`${b} && (${(0, n.checkMissingProp)(c, h, p)})`), (0, n.reportMissingProp)(c, p), l.else());
    }
  }
  e.validatePropertyDeps = o;
  function a(c, f = c.schema) {
    const { gen: l, data: d, keyword: g, it: p } = c, u = l.name("valid");
    for (const h in f)
      (0, r.alwaysValidSchema)(p, f[h]) || (l.if(
        (0, n.propertyInData)(l, d, h, p.opts.ownProperties),
        () => {
          const b = c.subschema({ keyword: g, schemaProp: h }, u);
          c.mergeValidEvaluated(b, u);
        },
        () => l.var(u, !0)
        // TODO var
      ), c.ok(u));
  }
  e.validateSchemaDeps = a, e.default = s;
})(O0);
var Zf = {};
Object.defineProperty(Zf, "__esModule", { value: !0 });
const C0 = ae, qC = re, HC = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, C0._)`{propertyName: ${e.propertyName}}`
}, BC = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: HC,
  code(e) {
    const { gen: t, schema: r, data: n, it: s } = e;
    if ((0, qC.alwaysValidSchema)(s, r))
      return;
    const i = t.name("valid");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    t.forIn("key", n, (o) => {
      e.setParams({ propertyName: o }), e.subschema({
        keyword: "propertyNames",
        data: o,
        dataTypes: ["string"],
        propertyName: o,
        compositeRule: !0
<<<<<<< HEAD
      }, s), t.if((0, BR.not)(s), () => {
        e.error(!0), i.allErrors || t.break();
      });
    }), e.ok(s);
  }
};
mg.default = Bj;
var qu = {};
Object.defineProperty(qu, "__esModule", { value: !0 });
const Cc = _e, Lr = he, zj = _r, Ac = se, Vj = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, Lr._)`{additionalProperty: ${e.additionalProperty}}`
}, Gj = {
=======
      }, i), t.if((0, C0.not)(i), () => {
        e.error(!0), s.allErrors || t.break();
      });
    }), e.ok(i);
  }
};
Zf.default = BC;
var xa = {};
Object.defineProperty(xa, "__esModule", { value: !0 });
const Di = fe, Wt = ae, VC = jt, Fi = re, GC = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, Wt._)`{additionalProperty: ${e.additionalProperty}}`
}, WC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
<<<<<<< HEAD
  error: Vj,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, errsCount: s, it: o } = e;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: c } = o;
    if (o.props = !0, c.removeAdditional !== "all" && (0, Ac.alwaysValidSchema)(o, r))
      return;
    const u = (0, Cc.allSchemaProperties)(n.properties), l = (0, Cc.allSchemaProperties)(n.patternProperties);
    f(), e.ok((0, Lr._)`${s} === ${zj.default.errors}`);
    function f() {
      t.forIn("key", i, (_) => {
        !u.length && !l.length ? d(_) : t.if(m(_), () => d(_));
      });
    }
    function m(_) {
      let g;
      if (u.length > 8) {
        const v = (0, Ac.schemaRefOrVal)(o, n.properties, "properties");
        g = (0, Cc.isOwnProperty)(t, v, _);
      } else u.length ? g = (0, Lr.or)(...u.map((v) => (0, Lr._)`${_} === ${v}`)) : g = Lr.nil;
      return l.length && (g = (0, Lr.or)(g, ...l.map((v) => (0, Lr._)`${(0, Cc.usePattern)(e, v)}.test(${_})`))), (0, Lr.not)(g);
    }
    function p(_) {
      t.code((0, Lr._)`delete ${i}[${_}]`);
    }
    function d(_) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        p(_);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: _ }), e.error(), a || t.break();
        return;
      }
      if (typeof r == "object" && !(0, Ac.alwaysValidSchema)(o, r)) {
        const g = t.name("valid");
        c.removeAdditional === "failing" ? (h(_, g, !1), t.if((0, Lr.not)(g), () => {
          e.reset(), p(_);
        })) : (h(_, g), a || t.if((0, Lr.not)(g), () => t.break()));
      }
    }
    function h(_, g, v) {
      const y = {
        keyword: "additionalProperties",
        dataProp: _,
        dataPropType: Ac.Type.Str
=======
  error: GC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: s, errsCount: i, it: o } = e;
    if (!i)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: c } = o;
    if (o.props = !0, c.removeAdditional !== "all" && (0, Fi.alwaysValidSchema)(o, r))
      return;
    const f = (0, Di.allSchemaProperties)(n.properties), l = (0, Di.allSchemaProperties)(n.patternProperties);
    d(), e.ok((0, Wt._)`${i} === ${VC.default.errors}`);
    function d() {
      t.forIn("key", s, (b) => {
        !f.length && !l.length ? u(b) : t.if(g(b), () => u(b));
      });
    }
    function g(b) {
      let m;
      if (f.length > 8) {
        const v = (0, Fi.schemaRefOrVal)(o, n.properties, "properties");
        m = (0, Di.isOwnProperty)(t, v, b);
      } else f.length ? m = (0, Wt.or)(...f.map((v) => (0, Wt._)`${b} === ${v}`)) : m = Wt.nil;
      return l.length && (m = (0, Wt.or)(m, ...l.map((v) => (0, Wt._)`${(0, Di.usePattern)(e, v)}.test(${b})`))), (0, Wt.not)(m);
    }
    function p(b) {
      t.code((0, Wt._)`delete ${s}[${b}]`);
    }
    function u(b) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        p(b);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: b }), e.error(), a || t.break();
        return;
      }
      if (typeof r == "object" && !(0, Fi.alwaysValidSchema)(o, r)) {
        const m = t.name("valid");
        c.removeAdditional === "failing" ? (h(b, m, !1), t.if((0, Wt.not)(m), () => {
          e.reset(), p(b);
        })) : (h(b, m), a || t.if((0, Wt.not)(m), () => t.break()));
      }
    }
    function h(b, m, v) {
      const y = {
        keyword: "additionalProperties",
        dataProp: b,
        dataPropType: Fi.Type.Str
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
      v === !1 && Object.assign(y, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
<<<<<<< HEAD
      }), e.subschema(y, g);
    }
  }
};
qu.default = Gj;
var gg = {};
Object.defineProperty(gg, "__esModule", { value: !0 });
const Wj = Pr, W0 = _e, Nd = se, K0 = qu, Kj = {
=======
      }), e.subschema(y, m);
    }
  }
};
xa.default = WC;
var Qf = {};
Object.defineProperty(Qf, "__esModule", { value: !0 });
const KC = Ut, tm = fe, Jc = re, rm = xa, JC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
<<<<<<< HEAD
    const { gen: t, schema: r, parentSchema: n, data: i, it: s } = e;
    s.opts.removeAdditional === "all" && n.additionalProperties === void 0 && K0.default.code(new Wj.KeywordCxt(s, K0.default, "additionalProperties"));
    const o = (0, W0.allSchemaProperties)(r);
    for (const f of o)
      s.definedProperties.add(f);
    s.opts.unevaluated && o.length && s.props !== !0 && (s.props = Nd.mergeEvaluated.props(t, (0, Nd.toHash)(o), s.props));
    const a = o.filter((f) => !(0, Nd.alwaysValidSchema)(s, r[f]));
    if (a.length === 0)
      return;
    const c = t.name("valid");
    for (const f of a)
      u(f) ? l(f) : (t.if((0, W0.propertyInData)(t, i, f, s.opts.ownProperties)), l(f), s.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(f), e.ok(c);
    function u(f) {
      return s.opts.useDefaults && !s.compositeRule && r[f].default !== void 0;
    }
    function l(f) {
      e.subschema({
        keyword: "properties",
        schemaProp: f,
        dataProp: f
=======
    const { gen: t, schema: r, parentSchema: n, data: s, it: i } = e;
    i.opts.removeAdditional === "all" && n.additionalProperties === void 0 && rm.default.code(new KC.KeywordCxt(i, rm.default, "additionalProperties"));
    const o = (0, tm.allSchemaProperties)(r);
    for (const d of o)
      i.definedProperties.add(d);
    i.opts.unevaluated && o.length && i.props !== !0 && (i.props = Jc.mergeEvaluated.props(t, (0, Jc.toHash)(o), i.props));
    const a = o.filter((d) => !(0, Jc.alwaysValidSchema)(i, r[d]));
    if (a.length === 0)
      return;
    const c = t.name("valid");
    for (const d of a)
      f(d) ? l(d) : (t.if((0, tm.propertyInData)(t, s, d, i.opts.ownProperties)), l(d), i.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(d), e.ok(c);
    function f(d) {
      return i.opts.useDefaults && !i.compositeRule && r[d].default !== void 0;
    }
    function l(d) {
      e.subschema({
        keyword: "properties",
        schemaProp: d,
        dataProp: d
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }, c);
    }
  }
};
<<<<<<< HEAD
gg.default = Kj;
var yg = {};
Object.defineProperty(yg, "__esModule", { value: !0 });
const Y0 = _e, Ic = he, J0 = se, X0 = se, Yj = {
=======
Qf.default = JC;
var ed = {};
Object.defineProperty(ed, "__esModule", { value: !0 });
const nm = fe, Mi = ae, sm = re, im = re, YC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
<<<<<<< HEAD
    const { gen: t, schema: r, data: n, parentSchema: i, it: s } = e, { opts: o } = s, a = (0, Y0.allSchemaProperties)(r), c = a.filter((h) => (0, J0.alwaysValidSchema)(s, r[h]));
    if (a.length === 0 || c.length === a.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const u = o.strictSchema && !o.allowMatchingProperties && i.properties, l = t.name("valid");
    s.props !== !0 && !(s.props instanceof Ic.Name) && (s.props = (0, X0.evaluatedPropsToName)(t, s.props));
    const { props: f } = s;
    m();
    function m() {
      for (const h of a)
        u && p(h), s.allErrors ? d(h) : (t.var(l, !0), d(h), t.if(l));
    }
    function p(h) {
      for (const _ in u)
        new RegExp(h).test(_) && (0, J0.checkStrictMode)(s, `property ${_} matches pattern ${h} (use allowMatchingProperties)`);
    }
    function d(h) {
      t.forIn("key", n, (_) => {
        t.if((0, Ic._)`${(0, Y0.usePattern)(e, h)}.test(${_})`, () => {
          const g = c.includes(h);
          g || e.subschema({
            keyword: "patternProperties",
            schemaProp: h,
            dataProp: _,
            dataPropType: X0.Type.Str
          }, l), s.opts.unevaluated && f !== !0 ? t.assign((0, Ic._)`${f}[${_}]`, !0) : !g && !s.allErrors && t.if((0, Ic.not)(l), () => t.break());
=======
    const { gen: t, schema: r, data: n, parentSchema: s, it: i } = e, { opts: o } = i, a = (0, nm.allSchemaProperties)(r), c = a.filter((h) => (0, sm.alwaysValidSchema)(i, r[h]));
    if (a.length === 0 || c.length === a.length && (!i.opts.unevaluated || i.props === !0))
      return;
    const f = o.strictSchema && !o.allowMatchingProperties && s.properties, l = t.name("valid");
    i.props !== !0 && !(i.props instanceof Mi.Name) && (i.props = (0, im.evaluatedPropsToName)(t, i.props));
    const { props: d } = i;
    g();
    function g() {
      for (const h of a)
        f && p(h), i.allErrors ? u(h) : (t.var(l, !0), u(h), t.if(l));
    }
    function p(h) {
      for (const b in f)
        new RegExp(h).test(b) && (0, sm.checkStrictMode)(i, `property ${b} matches pattern ${h} (use allowMatchingProperties)`);
    }
    function u(h) {
      t.forIn("key", n, (b) => {
        t.if((0, Mi._)`${(0, nm.usePattern)(e, h)}.test(${b})`, () => {
          const m = c.includes(h);
          m || e.subschema({
            keyword: "patternProperties",
            schemaProp: h,
            dataProp: b,
            dataPropType: im.Type.Str
          }, l), i.opts.unevaluated && d !== !0 ? t.assign((0, Mi._)`${d}[${b}]`, !0) : !m && !i.allErrors && t.if((0, Mi.not)(l), () => t.break());
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      });
    }
  }
};
<<<<<<< HEAD
yg.default = Yj;
var vg = {};
Object.defineProperty(vg, "__esModule", { value: !0 });
const Jj = se, Xj = {
=======
ed.default = YC;
var td = {};
Object.defineProperty(td, "__esModule", { value: !0 });
const XC = re, ZC = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
<<<<<<< HEAD
    if ((0, Jj.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const i = t.name("valid");
=======
    if ((0, XC.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const s = t.name("valid");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
<<<<<<< HEAD
    }, i), e.failResult(i, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
vg.default = Xj;
var _g = {};
Object.defineProperty(_g, "__esModule", { value: !0 });
const Zj = _e, Qj = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: Zj.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
_g.default = Qj;
var bg = {};
Object.defineProperty(bg, "__esModule", { value: !0 });
const gl = he, e2 = se, t2 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, gl._)`{passingSchemas: ${e.passing}}`
}, r2 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: t2,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && n.discriminator)
      return;
    const s = r, o = t.let("valid", !1), a = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: a }), t.block(u), e.result(o, () => e.reset(), () => e.error(!0));
    function u() {
      s.forEach((l, f) => {
        let m;
        (0, e2.alwaysValidSchema)(i, l) ? t.var(c, !0) : m = e.subschema({
          keyword: "oneOf",
          schemaProp: f,
          compositeRule: !0
        }, c), f > 0 && t.if((0, gl._)`${c} && ${o}`).assign(o, !1).assign(a, (0, gl._)`[${a}, ${f}]`).else(), t.if(c, () => {
          t.assign(o, !0), t.assign(a, f), m && e.mergeEvaluated(m, gl.Name);
=======
    }, s), e.failResult(s, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
td.default = ZC;
var rd = {};
Object.defineProperty(rd, "__esModule", { value: !0 });
const QC = fe, eP = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: QC.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
rd.default = eP;
var nd = {};
Object.defineProperty(nd, "__esModule", { value: !0 });
const go = ae, tP = re, rP = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, go._)`{passingSchemas: ${e.passing}}`
}, nP = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: rP,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: s } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (s.opts.discriminator && n.discriminator)
      return;
    const i = r, o = t.let("valid", !1), a = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: a }), t.block(f), e.result(o, () => e.reset(), () => e.error(!0));
    function f() {
      i.forEach((l, d) => {
        let g;
        (0, tP.alwaysValidSchema)(s, l) ? t.var(c, !0) : g = e.subschema({
          keyword: "oneOf",
          schemaProp: d,
          compositeRule: !0
        }, c), d > 0 && t.if((0, go._)`${c} && ${o}`).assign(o, !1).assign(a, (0, go._)`[${a}, ${d}]`).else(), t.if(c, () => {
          t.assign(o, !0), t.assign(a, d), g && e.mergeEvaluated(g, go.Name);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      });
    }
  }
};
<<<<<<< HEAD
bg.default = r2;
var Eg = {};
Object.defineProperty(Eg, "__esModule", { value: !0 });
const n2 = se, i2 = {
=======
nd.default = nP;
var sd = {};
Object.defineProperty(sd, "__esModule", { value: !0 });
const sP = re, iP = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
<<<<<<< HEAD
    const i = t.name("valid");
    r.forEach((s, o) => {
      if ((0, n2.alwaysValidSchema)(n, s))
        return;
      const a = e.subschema({ keyword: "allOf", schemaProp: o }, i);
      e.ok(i), e.mergeEvaluated(a);
    });
  }
};
Eg.default = i2;
var wg = {};
Object.defineProperty(wg, "__esModule", { value: !0 });
const zl = he, zR = se, s2 = {
  message: ({ params: e }) => (0, zl.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, zl._)`{failingKeyword: ${e.ifClause}}`
}, o2 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: s2,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, zR.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const i = Z0(n, "then"), s = Z0(n, "else");
    if (!i && !s)
      return;
    const o = t.let("valid", !0), a = t.name("_valid");
    if (c(), e.reset(), i && s) {
      const l = t.let("ifClause");
      e.setParams({ ifClause: l }), t.if(a, u("then", l), u("else", l));
    } else i ? t.if(a, u("then")) : t.if((0, zl.not)(a), u("else"));
=======
    const s = t.name("valid");
    r.forEach((i, o) => {
      if ((0, sP.alwaysValidSchema)(n, i))
        return;
      const a = e.subschema({ keyword: "allOf", schemaProp: o }, s);
      e.ok(s), e.mergeEvaluated(a);
    });
  }
};
sd.default = iP;
var id = {};
Object.defineProperty(id, "__esModule", { value: !0 });
const Uo = ae, P0 = re, oP = {
  message: ({ params: e }) => (0, Uo.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, Uo._)`{failingKeyword: ${e.ifClause}}`
}, aP = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: oP,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, P0.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const s = om(n, "then"), i = om(n, "else");
    if (!s && !i)
      return;
    const o = t.let("valid", !0), a = t.name("_valid");
    if (c(), e.reset(), s && i) {
      const l = t.let("ifClause");
      e.setParams({ ifClause: l }), t.if(a, f("then", l), f("else", l));
    } else s ? t.if(a, f("then")) : t.if((0, Uo.not)(a), f("else"));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    e.pass(o, () => e.error(!0));
    function c() {
      const l = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, a);
      e.mergeEvaluated(l);
    }
<<<<<<< HEAD
    function u(l, f) {
      return () => {
        const m = e.subschema({ keyword: l }, a);
        t.assign(o, a), e.mergeValidEvaluated(m, o), f ? t.assign(f, (0, zl._)`${l}`) : e.setParams({ ifClause: l });
=======
    function f(l, d) {
      return () => {
        const g = e.subschema({ keyword: l }, a);
        t.assign(o, a), e.mergeValidEvaluated(g, o), d ? t.assign(d, (0, Uo._)`${l}`) : e.setParams({ ifClause: l });
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
    }
  }
};
<<<<<<< HEAD
function Z0(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, zR.alwaysValidSchema)(e, r);
}
wg.default = o2;
var Sg = {};
Object.defineProperty(Sg, "__esModule", { value: !0 });
const a2 = se, c2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, a2.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
Sg.default = c2;
Object.defineProperty(fg, "__esModule", { value: !0 });
const l2 = no, u2 = dg, f2 = io, d2 = pg, p2 = hg, h2 = qR, m2 = mg, g2 = qu, y2 = gg, v2 = yg, _2 = vg, b2 = _g, E2 = bg, w2 = Eg, S2 = wg, x2 = Sg;
function R2(e = !1) {
  const t = [
    // any
    _2.default,
    b2.default,
    E2.default,
    w2.default,
    S2.default,
    x2.default,
    // object
    m2.default,
    g2.default,
    h2.default,
    y2.default,
    v2.default
  ];
  return e ? t.push(u2.default, d2.default) : t.push(l2.default, f2.default), t.push(p2.default), t;
}
fg.default = R2;
var xg = {}, Rg = {};
Object.defineProperty(Rg, "__esModule", { value: !0 });
const ft = he, $2 = {
  message: ({ schemaCode: e }) => (0, ft.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, ft._)`{format: ${e}}`
}, T2 = {
=======
function om(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, P0.alwaysValidSchema)(e, r);
}
id.default = aP;
var od = {};
Object.defineProperty(od, "__esModule", { value: !0 });
const cP = re, lP = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, cP.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
od.default = lP;
Object.defineProperty(Kf, "__esModule", { value: !0 });
const uP = as, fP = Jf, dP = cs, pP = Yf, hP = Xf, mP = O0, yP = Zf, gP = xa, vP = Qf, bP = ed, _P = td, EP = rd, SP = nd, xP = sd, wP = id, RP = od;
function $P(e = !1) {
  const t = [
    // any
    _P.default,
    EP.default,
    SP.default,
    xP.default,
    wP.default,
    RP.default,
    // object
    yP.default,
    gP.default,
    mP.default,
    vP.default,
    bP.default
  ];
  return e ? t.push(fP.default, pP.default) : t.push(uP.default, dP.default), t.push(hP.default), t;
}
Kf.default = $P;
var ad = {}, cd = {};
Object.defineProperty(cd, "__esModule", { value: !0 });
const Je = ae, TP = {
  message: ({ schemaCode: e }) => (0, Je.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, Je._)`{format: ${e}}`
}, OP = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
<<<<<<< HEAD
  error: $2,
  code(e, t) {
    const { gen: r, data: n, $data: i, schema: s, schemaCode: o, it: a } = e, { opts: c, errSchemaPath: u, schemaEnv: l, self: f } = a;
    if (!c.validateFormats)
      return;
    i ? m() : p();
    function m() {
      const d = r.scopeValue("formats", {
        ref: f.formats,
        code: c.code.formats
      }), h = r.const("fDef", (0, ft._)`${d}[${o}]`), _ = r.let("fType"), g = r.let("format");
      r.if((0, ft._)`typeof ${h} == "object" && !(${h} instanceof RegExp)`, () => r.assign(_, (0, ft._)`${h}.type || "string"`).assign(g, (0, ft._)`${h}.validate`), () => r.assign(_, (0, ft._)`"string"`).assign(g, h)), e.fail$data((0, ft.or)(v(), y()));
      function v() {
        return c.strictSchema === !1 ? ft.nil : (0, ft._)`${o} && !${g}`;
      }
      function y() {
        const E = l.$async ? (0, ft._)`(${h}.async ? await ${g}(${n}) : ${g}(${n}))` : (0, ft._)`${g}(${n})`, R = (0, ft._)`(typeof ${g} == "function" ? ${E} : ${g}.test(${n}))`;
        return (0, ft._)`${g} && ${g} !== true && ${_} === ${t} && !${R}`;
      }
    }
    function p() {
      const d = f.formats[s];
      if (!d) {
        v();
        return;
      }
      if (d === !0)
        return;
      const [h, _, g] = y(d);
      h === t && e.pass(E());
      function v() {
        if (c.strictSchema === !1) {
          f.logger.warn(R());
=======
  error: TP,
  code(e, t) {
    const { gen: r, data: n, $data: s, schema: i, schemaCode: o, it: a } = e, { opts: c, errSchemaPath: f, schemaEnv: l, self: d } = a;
    if (!c.validateFormats)
      return;
    s ? g() : p();
    function g() {
      const u = r.scopeValue("formats", {
        ref: d.formats,
        code: c.code.formats
      }), h = r.const("fDef", (0, Je._)`${u}[${o}]`), b = r.let("fType"), m = r.let("format");
      r.if((0, Je._)`typeof ${h} == "object" && !(${h} instanceof RegExp)`, () => r.assign(b, (0, Je._)`${h}.type || "string"`).assign(m, (0, Je._)`${h}.validate`), () => r.assign(b, (0, Je._)`"string"`).assign(m, h)), e.fail$data((0, Je.or)(v(), y()));
      function v() {
        return c.strictSchema === !1 ? Je.nil : (0, Je._)`${o} && !${m}`;
      }
      function y() {
        const _ = l.$async ? (0, Je._)`(${h}.async ? await ${m}(${n}) : ${m}(${n}))` : (0, Je._)`${m}(${n})`, R = (0, Je._)`(typeof ${m} == "function" ? ${_} : ${m}.test(${n}))`;
        return (0, Je._)`${m} && ${m} !== true && ${b} === ${t} && !${R}`;
      }
    }
    function p() {
      const u = d.formats[i];
      if (!u) {
        v();
        return;
      }
      if (u === !0)
        return;
      const [h, b, m] = y(u);
      h === t && e.pass(_());
      function v() {
        if (c.strictSchema === !1) {
          d.logger.warn(R());
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          return;
        }
        throw new Error(R());
        function R() {
<<<<<<< HEAD
          return `unknown format "${s}" ignored in schema at path "${u}"`;
        }
      }
      function y(R) {
        const w = R instanceof RegExp ? (0, ft.regexpCode)(R) : c.code.formats ? (0, ft._)`${c.code.formats}${(0, ft.getProperty)(s)}` : void 0, C = r.scopeValue("formats", { key: s, ref: R, code: w });
        return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, ft._)`${C}.validate`] : ["string", R, C];
      }
      function E() {
        if (typeof d == "object" && !(d instanceof RegExp) && d.async) {
          if (!l.$async)
            throw new Error("async format in sync schema");
          return (0, ft._)`await ${g}(${n})`;
        }
        return typeof _ == "function" ? (0, ft._)`${g}(${n})` : (0, ft._)`${g}.test(${n})`;
=======
          return `unknown format "${i}" ignored in schema at path "${f}"`;
        }
      }
      function y(R) {
        const E = R instanceof RegExp ? (0, Je.regexpCode)(R) : c.code.formats ? (0, Je._)`${c.code.formats}${(0, Je.getProperty)(i)}` : void 0, O = r.scopeValue("formats", { key: i, ref: R, code: E });
        return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, Je._)`${O}.validate`] : ["string", R, O];
      }
      function _() {
        if (typeof u == "object" && !(u instanceof RegExp) && u.async) {
          if (!l.$async)
            throw new Error("async format in sync schema");
          return (0, Je._)`await ${m}(${n})`;
        }
        return typeof b == "function" ? (0, Je._)`${m}(${n})` : (0, Je._)`${m}.test(${n})`;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
};
<<<<<<< HEAD
Rg.default = T2;
Object.defineProperty(xg, "__esModule", { value: !0 });
const O2 = Rg, P2 = [O2.default];
xg.default = P2;
var qs = {};
Object.defineProperty(qs, "__esModule", { value: !0 });
qs.contentVocabulary = qs.metadataVocabulary = void 0;
qs.metadataVocabulary = [
=======
cd.default = OP;
Object.defineProperty(ad, "__esModule", { value: !0 });
const CP = cd, PP = [CP.default];
ad.default = PP;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.contentVocabulary = Yn.metadataVocabulary = void 0;
Yn.metadataVocabulary = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
<<<<<<< HEAD
qs.contentVocabulary = [
=======
Yn.contentVocabulary = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
<<<<<<< HEAD
Object.defineProperty(Jm, "__esModule", { value: !0 });
const C2 = Xm, A2 = Qm, I2 = fg, N2 = xg, Q0 = qs, k2 = [
  C2.default,
  A2.default,
  (0, I2.default)(),
  N2.default,
  Q0.metadataVocabulary,
  Q0.contentVocabulary
];
Jm.default = k2;
var $g = {}, za = {};
Object.defineProperty(za, "__esModule", { value: !0 });
za.DiscrError = void 0;
var e_;
(function(e) {
  e.Tag = "tag", e.Mapping = "mapping";
})(e_ || (za.DiscrError = e_ = {}));
Object.defineProperty($g, "__esModule", { value: !0 });
const ys = he, Sh = za, t_ = kt, D2 = on, L2 = se, F2 = {
  message: ({ params: { discrError: e, tagName: t } }) => e === Sh.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, ys._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, j2 = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: F2,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: i, it: s } = e, { oneOf: o } = i;
    if (!s.opts.discriminator)
=======
Object.defineProperty(Af, "__esModule", { value: !0 });
const IP = kf, NP = jf, AP = Kf, kP = ad, am = Yn, LP = [
  IP.default,
  NP.default,
  (0, AP.default)(),
  kP.default,
  am.metadataVocabulary,
  am.contentVocabulary
];
Af.default = LP;
var ld = {}, pi = {};
Object.defineProperty(pi, "__esModule", { value: !0 });
pi.DiscrError = void 0;
var cm;
(function(e) {
  e.Tag = "tag", e.Mapping = "mapping";
})(cm || (pi.DiscrError = cm = {}));
Object.defineProperty(ld, "__esModule", { value: !0 });
const kn = ae, vu = pi, lm = dt, jP = mr, DP = re, FP = {
  message: ({ params: { discrError: e, tagName: t } }) => e === vu.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, kn._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, MP = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: FP,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: s, it: i } = e, { oneOf: o } = s;
    if (!i.opts.discriminator)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      throw new Error("discriminator: requires discriminator option");
    const a = n.propertyName;
    if (typeof a != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!o)
      throw new Error("discriminator: requires oneOf keyword");
<<<<<<< HEAD
    const c = t.let("valid", !1), u = t.const("tag", (0, ys._)`${r}${(0, ys.getProperty)(a)}`);
    t.if((0, ys._)`typeof ${u} == "string"`, () => l(), () => e.error(!1, { discrError: Sh.DiscrError.Tag, tag: u, tagName: a })), e.ok(c);
    function l() {
      const p = m();
      t.if(!1);
      for (const d in p)
        t.elseIf((0, ys._)`${u} === ${d}`), t.assign(c, f(p[d]));
      t.else(), e.error(!1, { discrError: Sh.DiscrError.Mapping, tag: u, tagName: a }), t.endIf();
    }
    function f(p) {
      const d = t.name("valid"), h = e.subschema({ keyword: "oneOf", schemaProp: p }, d);
      return e.mergeEvaluated(h, ys.Name), d;
    }
    function m() {
      var p;
      const d = {}, h = g(i);
      let _ = !0;
      for (let E = 0; E < o.length; E++) {
        let R = o[E];
        if (R != null && R.$ref && !(0, L2.schemaHasRulesButRef)(R, s.self.RULES)) {
          const C = R.$ref;
          if (R = t_.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, C), R instanceof t_.SchemaEnv && (R = R.schema), R === void 0)
            throw new D2.default(s.opts.uriResolver, s.baseId, C);
        }
        const w = (p = R == null ? void 0 : R.properties) === null || p === void 0 ? void 0 : p[a];
        if (typeof w != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        _ = _ && (h || g(R)), v(w, E);
      }
      if (!_)
        throw new Error(`discriminator: "${a}" must be required`);
      return d;
      function g({ required: E }) {
        return Array.isArray(E) && E.includes(a);
      }
      function v(E, R) {
        if (E.const)
          y(E.const, R);
        else if (E.enum)
          for (const w of E.enum)
            y(w, R);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function y(E, R) {
        if (typeof E != "string" || E in d)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        d[E] = R;
=======
    const c = t.let("valid", !1), f = t.const("tag", (0, kn._)`${r}${(0, kn.getProperty)(a)}`);
    t.if((0, kn._)`typeof ${f} == "string"`, () => l(), () => e.error(!1, { discrError: vu.DiscrError.Tag, tag: f, tagName: a })), e.ok(c);
    function l() {
      const p = g();
      t.if(!1);
      for (const u in p)
        t.elseIf((0, kn._)`${f} === ${u}`), t.assign(c, d(p[u]));
      t.else(), e.error(!1, { discrError: vu.DiscrError.Mapping, tag: f, tagName: a }), t.endIf();
    }
    function d(p) {
      const u = t.name("valid"), h = e.subschema({ keyword: "oneOf", schemaProp: p }, u);
      return e.mergeEvaluated(h, kn.Name), u;
    }
    function g() {
      var p;
      const u = {}, h = m(s);
      let b = !0;
      for (let _ = 0; _ < o.length; _++) {
        let R = o[_];
        if (R != null && R.$ref && !(0, DP.schemaHasRulesButRef)(R, i.self.RULES)) {
          const O = R.$ref;
          if (R = lm.resolveRef.call(i.self, i.schemaEnv.root, i.baseId, O), R instanceof lm.SchemaEnv && (R = R.schema), R === void 0)
            throw new jP.default(i.opts.uriResolver, i.baseId, O);
        }
        const E = (p = R == null ? void 0 : R.properties) === null || p === void 0 ? void 0 : p[a];
        if (typeof E != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        b = b && (h || m(R)), v(E, _);
      }
      if (!b)
        throw new Error(`discriminator: "${a}" must be required`);
      return u;
      function m({ required: _ }) {
        return Array.isArray(_) && _.includes(a);
      }
      function v(_, R) {
        if (_.const)
          y(_.const, R);
        else if (_.enum)
          for (const E of _.enum)
            y(E, R);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function y(_, R) {
        if (typeof _ != "string" || _ in u)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        u[_] = R;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
};
<<<<<<< HEAD
$g.default = j2;
const U2 = "http://json-schema.org/draft-07/schema#", M2 = "http://json-schema.org/draft-07/schema#", H2 = "Core schema meta-schema", q2 = {
=======
ld.default = MP;
const zP = "http://json-schema.org/draft-07/schema#", UP = "http://json-schema.org/draft-07/schema#", qP = "Core schema meta-schema", HP = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
<<<<<<< HEAD
}, B2 = [
  "object",
  "boolean"
], z2 = {
=======
}, BP = [
  "object",
  "boolean"
], VP = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
<<<<<<< HEAD
}, V2 = {
  $schema: U2,
  $id: M2,
  title: H2,
  definitions: q2,
  type: B2,
  properties: z2,
=======
}, GP = {
  $schema: zP,
  $id: UP,
  title: qP,
  definitions: HP,
  type: BP,
  properties: VP,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  default: !0
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
<<<<<<< HEAD
  const r = km, n = Jm, i = $g, s = V2, o = ["/properties"], a = "http://json-schema.org/draft-07/schema";
  class c extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((d) => this.addVocabulary(d)), this.opts.discriminator && this.addKeyword(i.default);
=======
  const r = gf, n = Af, s = ld, i = GP, o = ["/properties"], a = "http://json-schema.org/draft-07/schema";
  class c extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((u) => this.addVocabulary(u)), this.opts.discriminator && this.addKeyword(s.default);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
<<<<<<< HEAD
      const d = this.opts.$data ? this.$dataMetaSchema(s, o) : s;
      this.addMetaSchema(d, a, !1), this.refs["http://json-schema.org/schema"] = a;
=======
      const u = this.opts.$data ? this.$dataMetaSchema(i, o) : i;
      this.addMetaSchema(u, a, !1), this.refs["http://json-schema.org/schema"] = a;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
<<<<<<< HEAD
  var u = Pr;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return u.KeywordCxt;
  } });
  var l = he;
=======
  var f = Ut;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return f.KeywordCxt;
  } });
  var l = ae;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
<<<<<<< HEAD
  var f = to;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var m = on;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return m.default;
  } });
})(yh, yh.exports);
var Tg = yh.exports, Nc = { exports: {} }, Bu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(H, q) {
    return { validate: H, compare: q };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(s, o),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(c(!0), u),
    "date-time": t(m(!0), p),
    "iso-time": t(c(), l),
    "iso-date-time": t(m(), d),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: g,
=======
  var d = is;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var g = mr;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return g.default;
  } });
})(du, du.exports);
var ud = du.exports, zi = { exports: {} }, wa = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(M, U) {
    return { validate: M, compare: U };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(i, o),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(c(!0), f),
    "date-time": t(g(!0), p),
    "iso-time": t(c(), l),
    "iso-date-time": t(g(), u),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: m,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
<<<<<<< HEAD
    regex: F,
=======
    regex: L,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y,
    // signed 32 bit integer
<<<<<<< HEAD
    int32: { type: "number", validate: w },
    // signed 64 bit integer
    int64: { type: "number", validate: C },
    // C-type float
    float: { type: "number", validate: V },
    // C-type double
    double: { type: "number", validate: V },
=======
    int32: { type: "number", validate: E },
    // signed 64 bit integer
    int64: { type: "number", validate: O },
    // C-type float
    float: { type: "number", validate: z },
    // C-type double
    double: { type: "number", validate: z },
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, o),
<<<<<<< HEAD
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, u),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    "iso-time": t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, l),
    "iso-date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, d),
=======
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, f),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    "iso-time": t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, l),
    "iso-date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, u),
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
<<<<<<< HEAD
  function r(H) {
    return H % 4 === 0 && (H % 100 !== 0 || H % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function s(H) {
    const q = n.exec(H);
    if (!q)
      return !1;
    const $ = +q[1], x = +q[2], A = +q[3];
    return x >= 1 && x <= 12 && A >= 1 && A <= (x === 2 && r($) ? 29 : i[x]);
  }
  function o(H, q) {
    if (H && q)
      return H > q ? 1 : H < q ? -1 : 0;
  }
  const a = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function c(H) {
=======
  function r(M) {
    return M % 4 === 0 && (M % 100 !== 0 || M % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, s = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function i(M) {
    const U = n.exec(M);
    if (!U)
      return !1;
    const $ = +U[1], x = +U[2], I = +U[3];
    return x >= 1 && x <= 12 && I >= 1 && I <= (x === 2 && r($) ? 29 : s[x]);
  }
  function o(M, U) {
    if (M && U)
      return M > U ? 1 : M < U ? -1 : 0;
  }
  const a = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function c(M) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return function($) {
      const x = a.exec($);
      if (!x)
        return !1;
<<<<<<< HEAD
      const A = +x[1], P = +x[2], D = +x[3], I = x[4], L = x[5] === "-" ? -1 : 1, j = +(x[6] || 0), k = +(x[7] || 0);
      if (j > 23 || k > 59 || H && !I)
        return !1;
      if (A <= 23 && P <= 59 && D < 60)
        return !0;
      const U = P - k * L, M = A - j * L - (U < 0 ? 1 : 0);
      return (M === 23 || M === -1) && (U === 59 || U === -1) && D < 61;
    };
  }
  function u(H, q) {
    if (!(H && q))
      return;
    const $ = (/* @__PURE__ */ new Date("2020-01-01T" + H)).valueOf(), x = (/* @__PURE__ */ new Date("2020-01-01T" + q)).valueOf();
    if ($ && x)
      return $ - x;
  }
  function l(H, q) {
    if (!(H && q))
      return;
    const $ = a.exec(H), x = a.exec(q);
    if ($ && x)
      return H = $[1] + $[2] + $[3], q = x[1] + x[2] + x[3], H > q ? 1 : H < q ? -1 : 0;
  }
  const f = /t|\s/i;
  function m(H) {
    const q = c(H);
    return function(x) {
      const A = x.split(f);
      return A.length === 2 && s(A[0]) && q(A[1]);
    };
  }
  function p(H, q) {
    if (!(H && q))
      return;
    const $ = new Date(H).valueOf(), x = new Date(q).valueOf();
    if ($ && x)
      return $ - x;
  }
  function d(H, q) {
    if (!(H && q))
      return;
    const [$, x] = H.split(f), [A, P] = q.split(f), D = o($, A);
    if (D !== void 0)
      return D || u(x, P);
  }
  const h = /\/|:/, _ = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function g(H) {
    return h.test(H) && _.test(H);
  }
  const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(H) {
    return v.lastIndex = 0, v.test(H);
  }
  const E = -2147483648, R = 2 ** 31 - 1;
  function w(H) {
    return Number.isInteger(H) && H <= R && H >= E;
  }
  function C(H) {
    return Number.isInteger(H);
  }
  function V() {
    return !0;
  }
  const b = /[^\\]\\Z/;
  function F(H) {
    if (b.test(H))
      return !1;
    try {
      return new RegExp(H), !0;
=======
      const I = +x[1], T = +x[2], j = +x[3], C = x[4], A = x[5] === "-" ? -1 : 1, k = +(x[6] || 0), P = +(x[7] || 0);
      if (k > 23 || P > 59 || M && !C)
        return !1;
      if (I <= 23 && T <= 59 && j < 60)
        return !0;
      const D = T - P * A, F = I - k * A - (D < 0 ? 1 : 0);
      return (F === 23 || F === -1) && (D === 59 || D === -1) && j < 61;
    };
  }
  function f(M, U) {
    if (!(M && U))
      return;
    const $ = (/* @__PURE__ */ new Date("2020-01-01T" + M)).valueOf(), x = (/* @__PURE__ */ new Date("2020-01-01T" + U)).valueOf();
    if ($ && x)
      return $ - x;
  }
  function l(M, U) {
    if (!(M && U))
      return;
    const $ = a.exec(M), x = a.exec(U);
    if ($ && x)
      return M = $[1] + $[2] + $[3], U = x[1] + x[2] + x[3], M > U ? 1 : M < U ? -1 : 0;
  }
  const d = /t|\s/i;
  function g(M) {
    const U = c(M);
    return function(x) {
      const I = x.split(d);
      return I.length === 2 && i(I[0]) && U(I[1]);
    };
  }
  function p(M, U) {
    if (!(M && U))
      return;
    const $ = new Date(M).valueOf(), x = new Date(U).valueOf();
    if ($ && x)
      return $ - x;
  }
  function u(M, U) {
    if (!(M && U))
      return;
    const [$, x] = M.split(d), [I, T] = U.split(d), j = o($, I);
    if (j !== void 0)
      return j || f(x, T);
  }
  const h = /\/|:/, b = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function m(M) {
    return h.test(M) && b.test(M);
  }
  const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(M) {
    return v.lastIndex = 0, v.test(M);
  }
  const _ = -2147483648, R = 2 ** 31 - 1;
  function E(M) {
    return Number.isInteger(M) && M <= R && M >= _;
  }
  function O(M) {
    return Number.isInteger(M);
  }
  function z() {
    return !0;
  }
  const S = /[^\\]\\Z/;
  function L(M) {
    if (S.test(M))
      return !1;
    try {
      return new RegExp(M), !0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    } catch {
      return !1;
    }
  }
<<<<<<< HEAD
})(Bu);
var kd = {}, r_;
function G2() {
  return r_ || (r_ = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = Tg, r = he, n = r.operators, i = {
=======
})(wa);
var Yc = {}, um;
function WP() {
  return um || (um = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = ud, r = ae, n = r.operators, s = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
      formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
      formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
<<<<<<< HEAD
    }, s = {
      message: ({ keyword: a, schemaCode: c }) => (0, r.str)`should be ${i[a].okStr} ${c}`,
      params: ({ keyword: a, schemaCode: c }) => (0, r._)`{comparison: ${i[a].okStr}, limit: ${c}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(i),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: s,
      code(a) {
        const { gen: c, data: u, schemaCode: l, keyword: f, it: m } = a, { opts: p, self: d } = m;
        if (!p.validateFormats)
          return;
        const h = new t.KeywordCxt(m, d.RULES.all.format.definition, "format");
        h.$data ? _() : g();
        function _() {
          const y = c.scopeValue("formats", {
            ref: d.formats,
            code: p.code.formats
          }), E = c.const("fmt", (0, r._)`${y}[${h.schemaCode}]`);
          a.fail$data((0, r.or)((0, r._)`typeof ${E} != "object"`, (0, r._)`${E} instanceof RegExp`, (0, r._)`typeof ${E}.compare != "function"`, v(E)));
        }
        function g() {
          const y = h.schema, E = d.formats[y];
          if (!E || E === !0)
            return;
          if (typeof E != "object" || E instanceof RegExp || typeof E.compare != "function")
            throw new Error(`"${f}": format "${y}" does not define "compare" function`);
          const R = c.scopeValue("formats", {
            key: y,
            ref: E,
=======
    }, i = {
      message: ({ keyword: a, schemaCode: c }) => (0, r.str)`should be ${s[a].okStr} ${c}`,
      params: ({ keyword: a, schemaCode: c }) => (0, r._)`{comparison: ${s[a].okStr}, limit: ${c}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(s),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: i,
      code(a) {
        const { gen: c, data: f, schemaCode: l, keyword: d, it: g } = a, { opts: p, self: u } = g;
        if (!p.validateFormats)
          return;
        const h = new t.KeywordCxt(g, u.RULES.all.format.definition, "format");
        h.$data ? b() : m();
        function b() {
          const y = c.scopeValue("formats", {
            ref: u.formats,
            code: p.code.formats
          }), _ = c.const("fmt", (0, r._)`${y}[${h.schemaCode}]`);
          a.fail$data((0, r.or)((0, r._)`typeof ${_} != "object"`, (0, r._)`${_} instanceof RegExp`, (0, r._)`typeof ${_}.compare != "function"`, v(_)));
        }
        function m() {
          const y = h.schema, _ = u.formats[y];
          if (!_ || _ === !0)
            return;
          if (typeof _ != "object" || _ instanceof RegExp || typeof _.compare != "function")
            throw new Error(`"${d}": format "${y}" does not define "compare" function`);
          const R = c.scopeValue("formats", {
            key: y,
            ref: _,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            code: p.code.formats ? (0, r._)`${p.code.formats}${(0, r.getProperty)(y)}` : void 0
          });
          a.fail$data(v(R));
        }
        function v(y) {
<<<<<<< HEAD
          return (0, r._)`${y}.compare(${u}, ${l}) ${i[f].fail} 0`;
=======
          return (0, r._)`${y}.compare(${f}, ${l}) ${s[d].fail} 0`;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      },
      dependencies: ["format"]
    };
    const o = (a) => (a.addKeyword(e.formatLimitDefinition), a);
    e.default = o;
<<<<<<< HEAD
  }(kd)), kd;
}
var n_;
function VR() {
  return n_ || (n_ = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const r = Bu, n = G2(), i = he, s = new i.Name("fullFormats"), o = new i.Name("fastFormats"), a = (u, l = { keywords: !0 }) => {
      if (Array.isArray(l))
        return c(u, l, r.fullFormats, s), u;
      const [f, m] = l.mode === "fast" ? [r.fastFormats, o] : [r.fullFormats, s], p = l.formats || r.formatNames;
      return c(u, p, f, m), l.keywords && (0, n.default)(u), u;
    };
    a.get = (u, l = "full") => {
      const m = (l === "fast" ? r.fastFormats : r.fullFormats)[u];
      if (!m)
        throw new Error(`Unknown format "${u}"`);
      return m;
    };
    function c(u, l, f, m) {
      var p, d;
      (p = (d = u.opts.code).formats) !== null && p !== void 0 || (d.formats = (0, i._)`require("ajv-formats/dist/formats").${m}`);
      for (const h of l)
        u.addFormat(h, f[h]);
    }
    e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
  }(Nc, Nc.exports)), Nc.exports;
}
const W2 = Tg, K2 = Ym, Y2 = VR(), J2 = vm({ proto: !0 });
let X2 = class GR {
  constructor(t) {
    this.ajv = new W2({
=======
  }(Yc)), Yc;
}
var fm;
function I0() {
  return fm || (fm = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const r = wa, n = WP(), s = ae, i = new s.Name("fullFormats"), o = new s.Name("fastFormats"), a = (f, l = { keywords: !0 }) => {
      if (Array.isArray(l))
        return c(f, l, r.fullFormats, i), f;
      const [d, g] = l.mode === "fast" ? [r.fastFormats, o] : [r.fullFormats, i], p = l.formats || r.formatNames;
      return c(f, p, d, g), l.keywords && (0, n.default)(f), f;
    };
    a.get = (f, l = "full") => {
      const g = (l === "fast" ? r.fastFormats : r.fullFormats)[f];
      if (!g)
        throw new Error(`Unknown format "${f}"`);
      return g;
    };
    function c(f, l, d, g) {
      var p, u;
      (p = (u = f.opts.code).formats) !== null && p !== void 0 || (u.formats = (0, s._)`require("ajv-formats/dist/formats").${g}`);
      for (const h of l)
        f.addFormat(h, d[h]);
    }
    e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
  }(zi, zi.exports)), zi.exports;
}
const KP = ud, JP = Nf, YP = I0(), XP = ef({ proto: !0 });
let ZP = class N0 {
  constructor(t) {
    this.ajv = new KP({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      ...t,
      strictSchema: !1,
      validateSchema: !1,
      allowUnionTypes: !0,
<<<<<<< HEAD
      uriResolver: K2
    }), Y2(this.ajv), this.ajv.addKeyword({
=======
      uriResolver: JP
    }), YP(this.ajv), this.ajv.addKeyword({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      keyword: "fjs_type",
      type: "object",
      errors: !1,
      validate: (r, n) => n instanceof Date
    }), this._ajvSchemas = {}, this._ajvOptions = t || {};
  }
  addSchema(t, r) {
    let n = t.$id || r;
    if (t.$id !== void 0 && t.$id[0] === "#" && (n = r + t.$id), this.ajv.refs[n] === void 0 && this.ajv.schemas[n] === void 0) {
<<<<<<< HEAD
      const i = J2(t);
      this.convertSchemaToAjvFormat(i), this.ajv.addSchema(i, n), this._ajvSchemas[n] = t;
=======
      const s = XP(t);
      this.convertSchemaToAjvFormat(s), this.ajv.addSchema(s, n), this._ajvSchemas[n] = t;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  }
  validate(t, r) {
    return this.ajv.validate(t, r);
  }
  // Ajv does not support js date format. In order to properly validate objects containing a date,
  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
  // (see https://github.com/fastify/fast-json-stringify/pull/441)
  convertSchemaToAjvFormat(t) {
    if (t !== null) {
      t.type === "string" ? (t.fjs_type = "string", t.type = ["string", "object"]) : Array.isArray(t.type) && t.type.includes("string") && !t.type.includes("object") && (t.fjs_type = "string", t.type.push("object"));
      for (const r in t)
        typeof t[r] == "object" && this.convertSchemaToAjvFormat(t[r]);
    }
  }
  getState() {
    return {
      ajvOptions: this._ajvOptions,
      ajvSchemas: this._ajvSchemas
    };
  }
  static restoreFromState(t) {
<<<<<<< HEAD
    const r = new GR(t.ajvOptions);
    for (const [n, i] of Object.entries(t.ajvSchemas))
      r.ajv.addSchema(i, n);
    return r;
  }
};
var WR = X2;
let Z2 = class KR {
=======
    const r = new N0(t.ajvOptions);
    for (const [n, s] of Object.entries(t.ajvSchemas))
      r.ajv.addSchema(s, n);
    return r;
  }
};
var A0 = ZP;
let QP = class k0 {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t, r, n = "#") {
    this.schema = t, this.schemaId = r, this.jsonPointer = n;
  }
  getPropertyLocation(t) {
<<<<<<< HEAD
    return new KR(
=======
    return new k0(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      this.schema[t],
      this.schemaId,
      this.jsonPointer + "/" + t
    );
  }
  getSchemaRef() {
    return this.schemaId + this.jsonPointer;
  }
};
<<<<<<< HEAD
var Q2 = Z2, Og = { exports: {} };
Og.exports = ne;
Og.exports.default = ne;
const eU = { type: ["object", "boolean"] }, i_ = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, s_ = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, tU = Bu.fullFormats.uri, o_ = Bu.fullFormats.regex;
function Rr(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  return typeof e == "number" && !(e % 1) && !isNaN(e) && isFinite(e) ? typeof e == "number" && isFinite(e) && (e < 0 || isNaN(e)) ? (Rr.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1) : (Rr.errors = s, o === 0) : (Rr.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1);
}
const Dd = { validate: ne };
function Xt(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (o === 0)
    if (Array.isArray(e)) {
      if (e.length < 1)
        return Xt.errors = [{ instancePath: t, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
      {
        var a = !0;
        const c = e.length;
        for (let u = 0; u < c; u++) {
          const l = o;
          Dd.validate(e[u], { instancePath: t + "/" + u, parentData: e, parentDataProperty: u, rootData: i }) || (s = s === null ? Dd.validate.errors : s.concat(Dd.validate.errors), o = s.length);
=======
var eI = QP, fd = { exports: {} };
fd.exports = Q;
fd.exports.default = Q;
const tI = { type: ["object", "boolean"] }, dm = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, pm = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, rI = wa.fullFormats.uri, hm = wa.fullFormats.regex;
function Dt(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  return typeof e == "number" && !(e % 1) && !isNaN(e) && isFinite(e) ? typeof e == "number" && isFinite(e) && (e < 0 || isNaN(e)) ? (Dt.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1) : (Dt.errors = i, o === 0) : (Dt.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1);
}
const Xc = { validate: Q };
function St(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  if (o === 0)
    if (Array.isArray(e)) {
      if (e.length < 1)
        return St.errors = [{ instancePath: t, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
      {
        var a = !0;
        const c = e.length;
        for (let f = 0; f < c; f++) {
          const l = o;
          Xc.validate(e[f], { instancePath: t + "/" + f, parentData: e, parentDataProperty: f, rootData: s }) || (i = i === null ? Xc.validate.errors : i.concat(Xc.validate.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          var a = l === o;
          if (!a)
            break;
        }
      }
    } else
<<<<<<< HEAD
      return Xt.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
  return Xt.errors = s, o === 0;
}
const a_ = ro.default;
function ne(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (!(e && typeof e == "object" && !Array.isArray(e)) && typeof e != "boolean")
    return ne.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: eU.type }, message: "must be object,boolean" }], !1;
  if (o === 0 && e && typeof e == "object" && !Array.isArray(e)) {
    if (e.$id !== void 0) {
      let y = e.$id;
      const E = o;
      if (o === E && o === E)
        if (typeof y == "string") {
          if (!s_.test(y))
            return ne.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
        } else
          return ne.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
      var a = E === o;
=======
      return St.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
  return St.errors = i, o === 0;
}
const mm = os.default;
function Q(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  if (!(e && typeof e == "object" && !Array.isArray(e)) && typeof e != "boolean")
    return Q.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: tI.type }, message: "must be object,boolean" }], !1;
  if (o === 0 && e && typeof e == "object" && !Array.isArray(e)) {
    if (e.$id !== void 0) {
      let y = e.$id;
      const _ = o;
      if (o === _ && o === _)
        if (typeof y == "string") {
          if (!pm.test(y))
            return Q.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
        } else
          return Q.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
      var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    } else
      var a = !0;
    if (a) {
      if (e.$schema !== void 0) {
        let y = e.$schema;
<<<<<<< HEAD
        const E = o;
        if (o === E && o === E)
          if (typeof y == "string") {
            if (!tU(y))
              return ne.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }], !1;
          } else
            return ne.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
        var a = E === o;
=======
        const _ = o;
        if (o === _ && o === _)
          if (typeof y == "string") {
            if (!rI(y))
              return Q.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }], !1;
          } else
            return Q.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
        var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      } else
        var a = !0;
      if (a) {
        if (e.$ref !== void 0) {
          let y = e.$ref;
<<<<<<< HEAD
          const E = o;
          if (o === E && o === E)
            if (typeof y == "string") {
              if (!s_.test(y))
                return ne.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
            } else
              return ne.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
          var a = E === o;
=======
          const _ = o;
          if (o === _ && o === _)
            if (typeof y == "string") {
              if (!pm.test(y))
                return Q.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
            } else
              return Q.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
          var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        } else
          var a = !0;
        if (a) {
          if (e.$comment !== void 0) {
            const y = o;
            if (typeof e.$comment != "string")
<<<<<<< HEAD
              return ne.errors = [{ instancePath: t + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
=======
              return Q.errors = [{ instancePath: t + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            var a = y === o;
          } else
            var a = !0;
          if (a) {
            if (e.title !== void 0) {
              const y = o;
              if (typeof e.title != "string")
<<<<<<< HEAD
                return ne.errors = [{ instancePath: t + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
=======
                return Q.errors = [{ instancePath: t + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
              var a = y === o;
            } else
              var a = !0;
            if (a) {
              if (e.description !== void 0) {
                const y = o;
                if (typeof e.description != "string")
<<<<<<< HEAD
                  return ne.errors = [{ instancePath: t + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
=======
                  return Q.errors = [{ instancePath: t + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                var a = y === o;
              } else
                var a = !0;
              if (a) {
                if (e.readOnly !== void 0) {
                  const y = o;
                  if (typeof e.readOnly != "boolean")
<<<<<<< HEAD
                    return ne.errors = [{ instancePath: t + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
=======
                    return Q.errors = [{ instancePath: t + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                  var a = y === o;
                } else
                  var a = !0;
                if (a) {
                  if (e.examples !== void 0) {
                    const y = o;
                    if (o === y && !Array.isArray(e.examples))
<<<<<<< HEAD
                      return ne.errors = [{ instancePath: t + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
=======
                      return Q.errors = [{ instancePath: t + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                    var a = y === o;
                  } else
                    var a = !0;
                  if (a) {
                    if (e.multipleOf !== void 0) {
                      let y = e.multipleOf;
<<<<<<< HEAD
                      const E = o;
                      if (o === E)
                        if (typeof y == "number" && isFinite(y)) {
                          if (y <= 0 || isNaN(y))
                            return ne.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }], !1;
                        } else
                          return ne.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                      var a = E === o;
=======
                      const _ = o;
                      if (o === _)
                        if (typeof y == "number" && isFinite(y)) {
                          if (y <= 0 || isNaN(y))
                            return Q.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }], !1;
                        } else
                          return Q.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                      var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                    } else
                      var a = !0;
                    if (a) {
                      if (e.maximum !== void 0) {
                        let y = e.maximum;
<<<<<<< HEAD
                        const E = o;
                        if (!(typeof y == "number" && isFinite(y)))
                          return ne.errors = [{ instancePath: t + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                        var a = E === o;
=======
                        const _ = o;
                        if (!(typeof y == "number" && isFinite(y)))
                          return Q.errors = [{ instancePath: t + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                        var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                      } else
                        var a = !0;
                      if (a) {
                        if (e.exclusiveMaximum !== void 0) {
                          let y = e.exclusiveMaximum;
<<<<<<< HEAD
                          const E = o;
                          if (!(typeof y == "number" && isFinite(y)))
                            return ne.errors = [{ instancePath: t + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                          var a = E === o;
=======
                          const _ = o;
                          if (!(typeof y == "number" && isFinite(y)))
                            return Q.errors = [{ instancePath: t + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                          var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                        } else
                          var a = !0;
                        if (a) {
                          if (e.minimum !== void 0) {
                            let y = e.minimum;
<<<<<<< HEAD
                            const E = o;
                            if (!(typeof y == "number" && isFinite(y)))
                              return ne.errors = [{ instancePath: t + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                            var a = E === o;
=======
                            const _ = o;
                            if (!(typeof y == "number" && isFinite(y)))
                              return Q.errors = [{ instancePath: t + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                            var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                          } else
                            var a = !0;
                          if (a) {
                            if (e.exclusiveMinimum !== void 0) {
                              let y = e.exclusiveMinimum;
<<<<<<< HEAD
                              const E = o;
                              if (!(typeof y == "number" && isFinite(y)))
                                return ne.errors = [{ instancePath: t + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                              var a = E === o;
=======
                              const _ = o;
                              if (!(typeof y == "number" && isFinite(y)))
                                return Q.errors = [{ instancePath: t + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                              var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                            } else
                              var a = !0;
                            if (a) {
                              if (e.maxLength !== void 0) {
                                let y = e.maxLength;
<<<<<<< HEAD
                                const E = o, R = o;
                                if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                  return ne.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                  return ne.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                var a = E === o;
=======
                                const _ = o, R = o;
                                if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                  return Q.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                  return Q.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                              } else
                                var a = !0;
                              if (a) {
                                if (e.minLength !== void 0) {
                                  const y = o;
<<<<<<< HEAD
                                  Rr(e.minLength, { instancePath: t + "/minLength", parentData: e, parentDataProperty: "minLength", rootData: i }) || (s = s === null ? Rr.errors : s.concat(Rr.errors), o = s.length);
=======
                                  Dt(e.minLength, { instancePath: t + "/minLength", parentData: e, parentDataProperty: "minLength", rootData: s }) || (i = i === null ? Dt.errors : i.concat(Dt.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                  var a = y === o;
                                } else
                                  var a = !0;
                                if (a) {
                                  if (e.pattern !== void 0) {
                                    let y = e.pattern;
<<<<<<< HEAD
                                    const E = o;
                                    if (o === E && o === E)
                                      if (typeof y == "string") {
                                        if (!o_(y))
                                          return ne.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }], !1;
                                      } else
                                        return ne.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                    var a = E === o;
=======
                                    const _ = o;
                                    if (o === _ && o === _)
                                      if (typeof y == "string") {
                                        if (!hm(y))
                                          return Q.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }], !1;
                                      } else
                                        return Q.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                    var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                  } else
                                    var a = !0;
                                  if (a) {
                                    if (e.additionalItems !== void 0) {
                                      const y = o;
<<<<<<< HEAD
                                      ne(e.additionalItems, { instancePath: t + "/additionalItems", parentData: e, parentDataProperty: "additionalItems", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                      Q(e.additionalItems, { instancePath: t + "/additionalItems", parentData: e, parentDataProperty: "additionalItems", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                      var a = y === o;
                                    } else
                                      var a = !0;
                                    if (a) {
                                      if (e.items !== void 0) {
                                        let y = e.items;
<<<<<<< HEAD
                                        const E = o, R = o;
                                        let w = !1;
                                        const C = o;
                                        ne(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                        var c = C === o;
                                        if (w = w || c, !w) {
                                          const b = o;
                                          Xt(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: i }) || (s = s === null ? Xt.errors : s.concat(Xt.errors), o = s.length);
                                          var c = b === o;
                                          w = w || c;
                                        }
                                        if (w)
                                          o = R, s !== null && (R ? s.length = R : s = null);
                                        else {
                                          const b = { instancePath: t + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                          return s === null ? s = [b] : s.push(b), o++, ne.errors = s, !1;
                                        }
                                        var a = E === o;
=======
                                        const _ = o, R = o;
                                        let E = !1;
                                        const O = o;
                                        Q(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                        var c = O === o;
                                        if (E = E || c, !E) {
                                          const S = o;
                                          St(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: s }) || (i = i === null ? St.errors : i.concat(St.errors), o = i.length);
                                          var c = S === o;
                                          E = E || c;
                                        }
                                        if (E)
                                          o = R, i !== null && (R ? i.length = R : i = null);
                                        else {
                                          const S = { instancePath: t + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                          return i === null ? i = [S] : i.push(S), o++, Q.errors = i, !1;
                                        }
                                        var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                      } else
                                        var a = !0;
                                      if (a) {
                                        if (e.maxItems !== void 0) {
                                          let y = e.maxItems;
<<<<<<< HEAD
                                          const E = o, R = o;
                                          if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                            return ne.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                            return ne.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                          var a = E === o;
=======
                                          const _ = o, R = o;
                                          if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                            return Q.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                            return Q.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                          var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                        } else
                                          var a = !0;
                                        if (a) {
                                          if (e.minItems !== void 0) {
                                            const y = o;
<<<<<<< HEAD
                                            Rr(e.minItems, { instancePath: t + "/minItems", parentData: e, parentDataProperty: "minItems", rootData: i }) || (s = s === null ? Rr.errors : s.concat(Rr.errors), o = s.length);
=======
                                            Dt(e.minItems, { instancePath: t + "/minItems", parentData: e, parentDataProperty: "minItems", rootData: s }) || (i = i === null ? Dt.errors : i.concat(Dt.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                            var a = y === o;
                                          } else
                                            var a = !0;
                                          if (a) {
                                            if (e.uniqueItems !== void 0) {
                                              const y = o;
                                              if (typeof e.uniqueItems != "boolean")
<<<<<<< HEAD
                                                return ne.errors = [{ instancePath: t + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
=======
                                                return Q.errors = [{ instancePath: t + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                              var a = y === o;
                                            } else
                                              var a = !0;
                                            if (a) {
                                              if (e.contains !== void 0) {
                                                const y = o;
<<<<<<< HEAD
                                                ne(e.contains, { instancePath: t + "/contains", parentData: e, parentDataProperty: "contains", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                Q(e.contains, { instancePath: t + "/contains", parentData: e, parentDataProperty: "contains", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                var a = y === o;
                                              } else
                                                var a = !0;
                                              if (a) {
                                                if (e.maxProperties !== void 0) {
                                                  let y = e.maxProperties;
<<<<<<< HEAD
                                                  const E = o, R = o;
                                                  if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                                    return ne.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                  if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                                    return ne.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                                  var a = E === o;
=======
                                                  const _ = o, R = o;
                                                  if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                                    return Q.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                  if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                                    return Q.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                                  var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                } else
                                                  var a = !0;
                                                if (a) {
                                                  if (e.minProperties !== void 0) {
                                                    const y = o;
<<<<<<< HEAD
                                                    Rr(e.minProperties, { instancePath: t + "/minProperties", parentData: e, parentDataProperty: "minProperties", rootData: i }) || (s = s === null ? Rr.errors : s.concat(Rr.errors), o = s.length);
=======
                                                    Dt(e.minProperties, { instancePath: t + "/minProperties", parentData: e, parentDataProperty: "minProperties", rootData: s }) || (i = i === null ? Dt.errors : i.concat(Dt.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                    var a = y === o;
                                                  } else
                                                    var a = !0;
                                                  if (a) {
                                                    if (e.required !== void 0) {
                                                      let y = e.required;
<<<<<<< HEAD
                                                      const E = o;
                                                      if (o === o)
                                                        if (Array.isArray(y)) {
                                                          var u = !0;
                                                          const C = y.length;
                                                          for (let V = 0; V < C; V++) {
                                                            const b = o;
                                                            if (typeof y[V] != "string")
                                                              return ne.errors = [{ instancePath: t + "/required/" + V, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                            var u = b === o;
                                                            if (!u)
                                                              break;
                                                          }
                                                          if (u) {
                                                            let V = y.length, b;
                                                            if (V > 1) {
                                                              const F = {};
                                                              for (; V--; ) {
                                                                let H = y[V];
                                                                if (typeof H == "string") {
                                                                  if (typeof F[H] == "number")
                                                                    return b = F[H], ne.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: V, j: b }, message: "must NOT have duplicate items (items ## " + b + " and " + V + " are identical)" }], !1;
                                                                  F[H] = V;
=======
                                                      const _ = o;
                                                      if (o === o)
                                                        if (Array.isArray(y)) {
                                                          var f = !0;
                                                          const O = y.length;
                                                          for (let z = 0; z < O; z++) {
                                                            const S = o;
                                                            if (typeof y[z] != "string")
                                                              return Q.errors = [{ instancePath: t + "/required/" + z, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                            var f = S === o;
                                                            if (!f)
                                                              break;
                                                          }
                                                          if (f) {
                                                            let z = y.length, S;
                                                            if (z > 1) {
                                                              const L = {};
                                                              for (; z--; ) {
                                                                let M = y[z];
                                                                if (typeof M == "string") {
                                                                  if (typeof L[M] == "number")
                                                                    return S = L[M], Q.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: z, j: S }, message: "must NOT have duplicate items (items ## " + S + " and " + z + " are identical)" }], !1;
                                                                  L[M] = z;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                }
                                                              }
                                                            }
                                                          }
                                                        } else
<<<<<<< HEAD
                                                          return ne.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                      var a = E === o;
=======
                                                          return Q.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                      var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                    } else
                                                      var a = !0;
                                                    if (a) {
                                                      if (e.additionalProperties !== void 0) {
                                                        const y = o;
<<<<<<< HEAD
                                                        ne(e.additionalProperties, { instancePath: t + "/additionalProperties", parentData: e, parentDataProperty: "additionalProperties", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                        Q(e.additionalProperties, { instancePath: t + "/additionalProperties", parentData: e, parentDataProperty: "additionalProperties", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                        var a = y === o;
                                                      } else
                                                        var a = !0;
                                                      if (a) {
                                                        if (e.definitions !== void 0) {
                                                          let y = e.definitions;
<<<<<<< HEAD
                                                          const E = o;
                                                          if (o === E)
                                                            if (y && typeof y == "object" && !Array.isArray(y))
                                                              for (const w in y) {
                                                                const C = o;
                                                                ne(y[w], { instancePath: t + "/definitions/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                var l = C === o;
=======
                                                          const _ = o;
                                                          if (o === _)
                                                            if (y && typeof y == "object" && !Array.isArray(y))
                                                              for (const E in y) {
                                                                const O = o;
                                                                Q(y[E], { instancePath: t + "/definitions/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                var l = O === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                if (!l)
                                                                  break;
                                                              }
                                                            else
<<<<<<< HEAD
                                                              return ne.errors = [{ instancePath: t + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                          var a = E === o;
=======
                                                              return Q.errors = [{ instancePath: t + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                          var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                        } else
                                                          var a = !0;
                                                        if (a) {
                                                          if (e.properties !== void 0) {
                                                            let y = e.properties;
<<<<<<< HEAD
                                                            const E = o;
                                                            if (o === E)
                                                              if (y && typeof y == "object" && !Array.isArray(y))
                                                                for (const w in y) {
                                                                  const C = o;
                                                                  ne(y[w], { instancePath: t + "/properties/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                  var f = C === o;
                                                                  if (!f)
                                                                    break;
                                                                }
                                                              else
                                                                return ne.errors = [{ instancePath: t + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var a = E === o;
=======
                                                            const _ = o;
                                                            if (o === _)
                                                              if (y && typeof y == "object" && !Array.isArray(y))
                                                                for (const E in y) {
                                                                  const O = o;
                                                                  Q(y[E], { instancePath: t + "/properties/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                  var d = O === o;
                                                                  if (!d)
                                                                    break;
                                                                }
                                                              else
                                                                return Q.errors = [{ instancePath: t + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                          } else
                                                            var a = !0;
                                                          if (a) {
                                                            if (e.patternProperties !== void 0) {
                                                              let y = e.patternProperties;
<<<<<<< HEAD
                                                              const E = o;
                                                              if (o === E)
                                                                if (y && typeof y == "object" && !Array.isArray(y)) {
                                                                  for (const w in y) {
                                                                    const C = o;
                                                                    if (o === C && typeof w == "string" && !o_(w)) {
                                                                      const V = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: w };
                                                                      s === null ? s = [V] : s.push(V), o++;
                                                                    }
                                                                    var m = C === o;
                                                                    if (!m) {
                                                                      const V = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: w }, message: "property name must be valid" };
                                                                      return s === null ? s = [V] : s.push(V), o++, ne.errors = s, !1;
                                                                    }
                                                                  }
                                                                  if (m)
                                                                    for (const w in y) {
                                                                      const C = o;
                                                                      ne(y[w], { instancePath: t + "/patternProperties/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                      var p = C === o;
=======
                                                              const _ = o;
                                                              if (o === _)
                                                                if (y && typeof y == "object" && !Array.isArray(y)) {
                                                                  for (const E in y) {
                                                                    const O = o;
                                                                    if (o === O && typeof E == "string" && !hm(E)) {
                                                                      const z = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: E };
                                                                      i === null ? i = [z] : i.push(z), o++;
                                                                    }
                                                                    var g = O === o;
                                                                    if (!g) {
                                                                      const z = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: E }, message: "property name must be valid" };
                                                                      return i === null ? i = [z] : i.push(z), o++, Q.errors = i, !1;
                                                                    }
                                                                  }
                                                                  if (g)
                                                                    for (const E in y) {
                                                                      const O = o;
                                                                      Q(y[E], { instancePath: t + "/patternProperties/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                      var p = O === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                      if (!p)
                                                                        break;
                                                                    }
                                                                } else
<<<<<<< HEAD
                                                                  return ne.errors = [{ instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                              var a = E === o;
=======
                                                                  return Q.errors = [{ instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                              var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                            } else
                                                              var a = !0;
                                                            if (a) {
                                                              if (e.dependencies !== void 0) {
                                                                let y = e.dependencies;
<<<<<<< HEAD
                                                                const E = o;
                                                                if (o === E)
                                                                  if (y && typeof y == "object" && !Array.isArray(y))
                                                                    for (const w in y) {
                                                                      let C = y[w];
                                                                      const V = o, b = o;
                                                                      let F = !1;
                                                                      const H = o;
                                                                      ne(C, { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                      var d = H === o;
                                                                      if (F = F || d, !F) {
                                                                        const q = o;
                                                                        if (o === o)
                                                                          if (Array.isArray(C)) {
                                                                            var h = !0;
                                                                            const A = C.length;
                                                                            for (let P = 0; P < A; P++) {
                                                                              const D = o;
                                                                              if (typeof C[P] != "string") {
                                                                                const L = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + P, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                s === null ? s = [L] : s.push(L), o++;
                                                                              }
                                                                              var h = D === o;
=======
                                                                const _ = o;
                                                                if (o === _)
                                                                  if (y && typeof y == "object" && !Array.isArray(y))
                                                                    for (const E in y) {
                                                                      let O = y[E];
                                                                      const z = o, S = o;
                                                                      let L = !1;
                                                                      const M = o;
                                                                      Q(O, { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: E, rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
                                                                      var u = M === o;
                                                                      if (L = L || u, !L) {
                                                                        const U = o;
                                                                        if (o === o)
                                                                          if (Array.isArray(O)) {
                                                                            var h = !0;
                                                                            const I = O.length;
                                                                            for (let T = 0; T < I; T++) {
                                                                              const j = o;
                                                                              if (typeof O[T] != "string") {
                                                                                const A = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + T, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                i === null ? i = [A] : i.push(A), o++;
                                                                              }
                                                                              var h = j === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                              if (!h)
                                                                                break;
                                                                            }
                                                                            if (h) {
<<<<<<< HEAD
                                                                              let P = C.length, D;
                                                                              if (P > 1) {
                                                                                const I = {};
                                                                                for (; P--; ) {
                                                                                  let L = C[P];
                                                                                  if (typeof L == "string") {
                                                                                    if (typeof I[L] == "number") {
                                                                                      D = I[L];
                                                                                      const j = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: P, j: D }, message: "must NOT have duplicate items (items ## " + D + " and " + P + " are identical)" };
                                                                                      s === null ? s = [j] : s.push(j), o++;
                                                                                      break;
                                                                                    }
                                                                                    I[L] = P;
=======
                                                                              let T = O.length, j;
                                                                              if (T > 1) {
                                                                                const C = {};
                                                                                for (; T--; ) {
                                                                                  let A = O[T];
                                                                                  if (typeof A == "string") {
                                                                                    if (typeof C[A] == "number") {
                                                                                      j = C[A];
                                                                                      const k = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: T, j }, message: "must NOT have duplicate items (items ## " + j + " and " + T + " are identical)" };
                                                                                      i === null ? i = [k] : i.push(k), o++;
                                                                                      break;
                                                                                    }
                                                                                    C[A] = T;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          } else {
<<<<<<< HEAD
                                                                            const A = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            s === null ? s = [A] : s.push(A), o++;
                                                                          }
                                                                        var d = q === o;
                                                                        F = F || d;
                                                                      }
                                                                      if (F)
                                                                        o = b, s !== null && (b ? s.length = b : s = null);
                                                                      else {
                                                                        const q = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return s === null ? s = [q] : s.push(q), o++, ne.errors = s, !1;
                                                                      }
                                                                      var _ = V === o;
                                                                      if (!_)
                                                                        break;
                                                                    }
                                                                  else
                                                                    return ne.errors = [{ instancePath: t + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                var a = E === o;
=======
                                                                            const I = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            i === null ? i = [I] : i.push(I), o++;
                                                                          }
                                                                        var u = U === o;
                                                                        L = L || u;
                                                                      }
                                                                      if (L)
                                                                        o = S, i !== null && (S ? i.length = S : i = null);
                                                                      else {
                                                                        const U = { instancePath: t + "/dependencies/" + E.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return i === null ? i = [U] : i.push(U), o++, Q.errors = i, !1;
                                                                      }
                                                                      var b = z === o;
                                                                      if (!b)
                                                                        break;
                                                                    }
                                                                  else
                                                                    return Q.errors = [{ instancePath: t + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                              } else
                                                                var a = !0;
                                                              if (a) {
                                                                if (e.propertyNames !== void 0) {
                                                                  const y = o;
<<<<<<< HEAD
                                                                  ne(e.propertyNames, { instancePath: t + "/propertyNames", parentData: e, parentDataProperty: "propertyNames", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                                  Q(e.propertyNames, { instancePath: t + "/propertyNames", parentData: e, parentDataProperty: "propertyNames", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                  var a = y === o;
                                                                } else
                                                                  var a = !0;
                                                                if (a) {
                                                                  if (e.enum !== void 0) {
                                                                    let y = e.enum;
<<<<<<< HEAD
                                                                    const E = o;
                                                                    if (o === E)
                                                                      if (Array.isArray(y)) {
                                                                        if (y.length < 1)
                                                                          return ne.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
                                                                        {
                                                                          let w = y.length, C;
                                                                          if (w > 1) {
                                                                            for (; w--; )
                                                                              for (C = w; C--; )
                                                                                if (a_(y[w], y[C]))
                                                                                  return ne.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: w, j: C }, message: "must NOT have duplicate items (items ## " + C + " and " + w + " are identical)" }], !1;
                                                                          }
                                                                        }
                                                                      } else
                                                                        return ne.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                                    var a = E === o;
=======
                                                                    const _ = o;
                                                                    if (o === _)
                                                                      if (Array.isArray(y)) {
                                                                        if (y.length < 1)
                                                                          return Q.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
                                                                        {
                                                                          let E = y.length, O;
                                                                          if (E > 1) {
                                                                            for (; E--; )
                                                                              for (O = E; O--; )
                                                                                if (mm(y[E], y[O]))
                                                                                  return Q.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: E, j: O }, message: "must NOT have duplicate items (items ## " + O + " and " + E + " are identical)" }], !1;
                                                                          }
                                                                        }
                                                                      } else
                                                                        return Q.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                                    var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                  } else
                                                                    var a = !0;
                                                                  if (a) {
                                                                    if (e.type !== void 0) {
                                                                      let y = e.type;
<<<<<<< HEAD
                                                                      const E = o, R = o;
                                                                      let w = !1;
                                                                      const C = o;
                                                                      if (!(y === "array" || y === "boolean" || y === "integer" || y === "null" || y === "number" || y === "object" || y === "string")) {
                                                                        const b = { instancePath: t + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: i_.enum }, message: "must be equal to one of the allowed values" };
                                                                        s === null ? s = [b] : s.push(b), o++;
                                                                      }
                                                                      var g = C === o;
                                                                      if (w = w || g, !w) {
                                                                        const b = o;
                                                                        if (o === b)
                                                                          if (Array.isArray(y))
                                                                            if (y.length < 1) {
                                                                              const H = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                              s === null ? s = [H] : s.push(H), o++;
                                                                            } else {
                                                                              var v = !0;
                                                                              const H = y.length;
                                                                              for (let q = 0; q < H; q++) {
                                                                                let $ = y[q];
                                                                                const x = o;
                                                                                if (!($ === "array" || $ === "boolean" || $ === "integer" || $ === "null" || $ === "number" || $ === "object" || $ === "string")) {
                                                                                  const P = { instancePath: t + "/type/" + q, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: i_.enum }, message: "must be equal to one of the allowed values" };
                                                                                  s === null ? s = [P] : s.push(P), o++;
=======
                                                                      const _ = o, R = o;
                                                                      let E = !1;
                                                                      const O = o;
                                                                      if (!(y === "array" || y === "boolean" || y === "integer" || y === "null" || y === "number" || y === "object" || y === "string")) {
                                                                        const S = { instancePath: t + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: dm.enum }, message: "must be equal to one of the allowed values" };
                                                                        i === null ? i = [S] : i.push(S), o++;
                                                                      }
                                                                      var m = O === o;
                                                                      if (E = E || m, !E) {
                                                                        const S = o;
                                                                        if (o === S)
                                                                          if (Array.isArray(y))
                                                                            if (y.length < 1) {
                                                                              const M = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                              i === null ? i = [M] : i.push(M), o++;
                                                                            } else {
                                                                              var v = !0;
                                                                              const M = y.length;
                                                                              for (let U = 0; U < M; U++) {
                                                                                let $ = y[U];
                                                                                const x = o;
                                                                                if (!($ === "array" || $ === "boolean" || $ === "integer" || $ === "null" || $ === "number" || $ === "object" || $ === "string")) {
                                                                                  const T = { instancePath: t + "/type/" + U, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: dm.enum }, message: "must be equal to one of the allowed values" };
                                                                                  i === null ? i = [T] : i.push(T), o++;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                }
                                                                                var v = x === o;
                                                                                if (!v)
                                                                                  break;
                                                                              }
                                                                              if (v) {
<<<<<<< HEAD
                                                                                let q = y.length, $;
                                                                                if (q > 1) {
                                                                                  e:
                                                                                    for (; q--; )
                                                                                      for ($ = q; $--; )
                                                                                        if (a_(y[q], y[$])) {
                                                                                          const x = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: q, j: $ }, message: "must NOT have duplicate items (items ## " + $ + " and " + q + " are identical)" };
                                                                                          s === null ? s = [x] : s.push(x), o++;
=======
                                                                                let U = y.length, $;
                                                                                if (U > 1) {
                                                                                  e:
                                                                                    for (; U--; )
                                                                                      for ($ = U; $--; )
                                                                                        if (mm(y[U], y[$])) {
                                                                                          const x = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: U, j: $ }, message: "must NOT have duplicate items (items ## " + $ + " and " + U + " are identical)" };
                                                                                          i === null ? i = [x] : i.push(x), o++;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                          break e;
                                                                                        }
                                                                                }
                                                                              }
                                                                            }
                                                                          else {
<<<<<<< HEAD
                                                                            const H = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            s === null ? s = [H] : s.push(H), o++;
                                                                          }
                                                                        var g = b === o;
                                                                        w = w || g;
                                                                      }
                                                                      if (w)
                                                                        o = R, s !== null && (R ? s.length = R : s = null);
                                                                      else {
                                                                        const b = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return s === null ? s = [b] : s.push(b), o++, ne.errors = s, !1;
                                                                      }
                                                                      var a = E === o;
=======
                                                                            const M = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            i === null ? i = [M] : i.push(M), o++;
                                                                          }
                                                                        var m = S === o;
                                                                        E = E || m;
                                                                      }
                                                                      if (E)
                                                                        o = R, i !== null && (R ? i.length = R : i = null);
                                                                      else {
                                                                        const S = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return i === null ? i = [S] : i.push(S), o++, Q.errors = i, !1;
                                                                      }
                                                                      var a = _ === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                    } else
                                                                      var a = !0;
                                                                    if (a) {
                                                                      if (e.format !== void 0) {
                                                                        const y = o;
                                                                        if (typeof e.format != "string")
<<<<<<< HEAD
                                                                          return ne.errors = [{ instancePath: t + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
=======
                                                                          return Q.errors = [{ instancePath: t + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                        var a = y === o;
                                                                      } else
                                                                        var a = !0;
                                                                      if (a) {
                                                                        if (e.contentMediaType !== void 0) {
                                                                          const y = o;
                                                                          if (typeof e.contentMediaType != "string")
<<<<<<< HEAD
                                                                            return ne.errors = [{ instancePath: t + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
=======
                                                                            return Q.errors = [{ instancePath: t + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                          var a = y === o;
                                                                        } else
                                                                          var a = !0;
                                                                        if (a) {
                                                                          if (e.contentEncoding !== void 0) {
                                                                            const y = o;
                                                                            if (typeof e.contentEncoding != "string")
<<<<<<< HEAD
                                                                              return ne.errors = [{ instancePath: t + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
=======
                                                                              return Q.errors = [{ instancePath: t + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                            var a = y === o;
                                                                          } else
                                                                            var a = !0;
                                                                          if (a) {
                                                                            if (e.if !== void 0) {
                                                                              const y = o;
<<<<<<< HEAD
                                                                              ne(e.if, { instancePath: t + "/if", parentData: e, parentDataProperty: "if", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                                              Q(e.if, { instancePath: t + "/if", parentData: e, parentDataProperty: "if", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                              var a = y === o;
                                                                            } else
                                                                              var a = !0;
                                                                            if (a) {
                                                                              if (e.then !== void 0) {
                                                                                const y = o;
<<<<<<< HEAD
                                                                                ne(e.then, { instancePath: t + "/then", parentData: e, parentDataProperty: "then", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                                                Q(e.then, { instancePath: t + "/then", parentData: e, parentDataProperty: "then", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                var a = y === o;
                                                                              } else
                                                                                var a = !0;
                                                                              if (a) {
                                                                                if (e.else !== void 0) {
                                                                                  const y = o;
<<<<<<< HEAD
                                                                                  ne(e.else, { instancePath: t + "/else", parentData: e, parentDataProperty: "else", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                                                  Q(e.else, { instancePath: t + "/else", parentData: e, parentDataProperty: "else", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                  var a = y === o;
                                                                                } else
                                                                                  var a = !0;
                                                                                if (a) {
                                                                                  if (e.allOf !== void 0) {
                                                                                    const y = o;
<<<<<<< HEAD
                                                                                    Xt(e.allOf, { instancePath: t + "/allOf", parentData: e, parentDataProperty: "allOf", rootData: i }) || (s = s === null ? Xt.errors : s.concat(Xt.errors), o = s.length);
=======
                                                                                    St(e.allOf, { instancePath: t + "/allOf", parentData: e, parentDataProperty: "allOf", rootData: s }) || (i = i === null ? St.errors : i.concat(St.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                    var a = y === o;
                                                                                  } else
                                                                                    var a = !0;
                                                                                  if (a) {
                                                                                    if (e.anyOf !== void 0) {
                                                                                      const y = o;
<<<<<<< HEAD
                                                                                      Xt(e.anyOf, { instancePath: t + "/anyOf", parentData: e, parentDataProperty: "anyOf", rootData: i }) || (s = s === null ? Xt.errors : s.concat(Xt.errors), o = s.length);
=======
                                                                                      St(e.anyOf, { instancePath: t + "/anyOf", parentData: e, parentDataProperty: "anyOf", rootData: s }) || (i = i === null ? St.errors : i.concat(St.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                      var a = y === o;
                                                                                    } else
                                                                                      var a = !0;
                                                                                    if (a) {
                                                                                      if (e.oneOf !== void 0) {
                                                                                        const y = o;
<<<<<<< HEAD
                                                                                        Xt(e.oneOf, { instancePath: t + "/oneOf", parentData: e, parentDataProperty: "oneOf", rootData: i }) || (s = s === null ? Xt.errors : s.concat(Xt.errors), o = s.length);
=======
                                                                                        St(e.oneOf, { instancePath: t + "/oneOf", parentData: e, parentDataProperty: "oneOf", rootData: s }) || (i = i === null ? St.errors : i.concat(St.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                        var a = y === o;
                                                                                      } else
                                                                                        var a = !0;
                                                                                      if (a)
                                                                                        if (e.not !== void 0) {
                                                                                          const y = o;
<<<<<<< HEAD
                                                                                          ne(e.not, { instancePath: t + "/not", parentData: e, parentDataProperty: "not", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
=======
                                                                                          Q(e.not, { instancePath: t + "/not", parentData: e, parentDataProperty: "not", rootData: s }) || (i = i === null ? Q.errors : i.concat(Q.errors), o = i.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                                                          var a = y === o;
                                                                                        } else
                                                                                          var a = !0;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
<<<<<<< HEAD
  return ne.errors = s, o === 0;
}
var rU = Og.exports;
let nU = class extends Error {
=======
  return Q.errors = i, o === 0;
}
var nI = fd.exports;
let sI = class extends Error {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t, r) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Failed to merge "${t}" keyword schemas.`, this.schemas = r;
  }
};
<<<<<<< HEAD
class iU extends Error {
=======
class iI extends Error {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t, r) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Resolver for "${t}" keyword not found.`, this.schemas = r;
  }
}
<<<<<<< HEAD
class sU extends Error {
=======
class oI extends Error {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Invalid "onConflict" option: "${t}".`;
  }
}
<<<<<<< HEAD
var YR = {
  MergeError: nU,
  ResolverNotFoundError: iU,
  InvalidOnConflictOptionError: sU
};
const { dequal: oU } = Lu, { MergeError: Pg } = YR;
function JR(e) {
=======
var L0 = {
  MergeError: sI,
  ResolverNotFoundError: iI,
  InvalidOnConflictOptionError: oI
};
const { dequal: aI } = ga, { MergeError: dd } = L0;
function j0(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let t = e[0];
  for (let r = 1; r < e.length; r++)
    t = t.filter(
      (n) => e[r].includes(n)
    );
  return t;
}
<<<<<<< HEAD
function aU(e, t, r) {
  const n = JR(t);
  if (n.length === 0)
    throw new Pg(e, t);
  r[e] = n;
}
function cU(e, t, r) {
  for (let i = 0; i < t.length; i++)
    Array.isArray(t[i]) || (t[i] = [t[i]]);
  const n = JR(t);
  if (n.length === 0)
    throw new Pg(e, t);
  n.length === 1 ? r[e] = n[0] : r[e] = n;
}
function lU(e, t, r) {
  const n = [];
  for (const i of t)
    for (const s of i)
      n.includes(s) || n.push(s);
  r[e] = n;
}
function uU(e, t, r) {
  r[e] = Math.min(...t);
}
function fU(e, t, r) {
  r[e] = Math.max(...t);
}
function dU(e, t, r) {
  const n = (a, c) => c ? n(c, a % c) : a, i = (a, c) => a * c / n(a, c);
  let s = 1;
  for (const a of t)
    for (; a * s % 1 !== 0; )
      s *= 10;
  let o = t[0] * s;
  for (const a of t)
    o = i(o, a * s);
  r[e] = o / s;
}
function pU(e, t, r) {
  const n = t[0];
  for (let i = 1; i < t.length; i++)
    if (!oU(t[i], n))
      throw new Pg(e, t);
  r[e] = n;
}
function hU() {
}
function mU(e, t, r) {
=======
function cI(e, t, r) {
  const n = j0(t);
  if (n.length === 0)
    throw new dd(e, t);
  r[e] = n;
}
function lI(e, t, r) {
  for (let s = 0; s < t.length; s++)
    Array.isArray(t[s]) || (t[s] = [t[s]]);
  const n = j0(t);
  if (n.length === 0)
    throw new dd(e, t);
  n.length === 1 ? r[e] = n[0] : r[e] = n;
}
function uI(e, t, r) {
  const n = [];
  for (const s of t)
    for (const i of s)
      n.includes(i) || n.push(i);
  r[e] = n;
}
function fI(e, t, r) {
  r[e] = Math.min(...t);
}
function dI(e, t, r) {
  r[e] = Math.max(...t);
}
function pI(e, t, r) {
  const n = (a, c) => c ? n(c, a % c) : a, s = (a, c) => a * c / n(a, c);
  let i = 1;
  for (const a of t)
    for (; a * i % 1 !== 0; )
      i *= 10;
  let o = t[0] * i;
  for (const a of t)
    o = s(o, a * i);
  r[e] = o / i;
}
function hI(e, t, r) {
  const n = t[0];
  for (let s = 1; s < t.length; s++)
    if (!aI(t[s], n))
      throw new dd(e, t);
  r[e] = n;
}
function mI() {
}
function yI(e, t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  for (const n of t)
    if (n === !1) {
      r[e] = !1;
      return;
    }
  r[e] = !0;
}
<<<<<<< HEAD
function gU(e, t, r) {
=======
function gI(e, t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  for (const n of t)
    if (n === !0) {
      r[e] = !0;
      return;
    }
  r[e] = !1;
}
<<<<<<< HEAD
var yU = {
  arraysIntersection: aU,
  hybridArraysIntersection: cU,
  arraysUnion: lU,
  minNumber: uU,
  maxNumber: fU,
  commonMultiple: dU,
  allEqual: pU,
  booleanAnd: mU,
  booleanOr: gU,
  skip: hU
};
const { dequal: vU } = Lu, Xe = yU, Vl = YR, _U = {
  $id: Xe.skip,
  type: Xe.hybridArraysIntersection,
  enum: Xe.arraysIntersection,
  minLength: Xe.maxNumber,
  maxLength: Xe.minNumber,
  minimum: Xe.maxNumber,
  maximum: Xe.minNumber,
  multipleOf: Xe.commonMultiple,
  exclusiveMinimum: Xe.maxNumber,
  exclusiveMaximum: Xe.minNumber,
  minItems: Xe.maxNumber,
  maxItems: Xe.minNumber,
  maxProperties: Xe.minNumber,
  minProperties: Xe.maxNumber,
  const: Xe.allEqual,
  default: Xe.allEqual,
  format: Xe.allEqual,
  required: Xe.arraysUnion,
  properties: RU,
  patternProperties: Dc,
  additionalProperties: kc,
  items: wU,
  additionalItems: SU,
  definitions: Dc,
  $defs: Dc,
  nullable: Xe.booleanAnd,
  oneOf: c_,
  anyOf: c_,
  allOf: Xe.arraysUnion,
  not: kc,
  if: $U,
  then: Xe.skip,
  else: Xe.skip,
  dependencies: l_,
  dependentRequired: l_,
  dependentSchemas: Dc,
  propertyNames: kc,
  uniqueItems: Xe.booleanOr,
  contains: kc
};
function kc(e, t, r, n, i) {
  r[e] = Mr(t, i);
}
function bU(e) {
  let t = [[]];
  for (const r of e) {
    const n = [];
    for (const i of t)
      for (const s of r)
        n.push([...i, s]);
=======
var vI = {
  arraysIntersection: cI,
  hybridArraysIntersection: lI,
  arraysUnion: uI,
  minNumber: fI,
  maxNumber: dI,
  commonMultiple: pI,
  allEqual: hI,
  booleanAnd: yI,
  booleanOr: gI,
  skip: mI
};
const { dequal: bI } = ga, je = vI, qo = L0, _I = {
  $id: je.skip,
  type: je.hybridArraysIntersection,
  enum: je.arraysIntersection,
  minLength: je.maxNumber,
  maxLength: je.minNumber,
  minimum: je.maxNumber,
  maximum: je.minNumber,
  multipleOf: je.commonMultiple,
  exclusiveMinimum: je.maxNumber,
  exclusiveMaximum: je.minNumber,
  minItems: je.maxNumber,
  maxItems: je.minNumber,
  maxProperties: je.minNumber,
  minProperties: je.maxNumber,
  const: je.allEqual,
  default: je.allEqual,
  format: je.allEqual,
  required: je.arraysUnion,
  properties: $I,
  patternProperties: qi,
  additionalProperties: Ui,
  items: xI,
  additionalItems: wI,
  definitions: qi,
  $defs: qi,
  nullable: je.booleanAnd,
  oneOf: ym,
  anyOf: ym,
  allOf: je.arraysUnion,
  not: Ui,
  if: TI,
  then: je.skip,
  else: je.skip,
  dependencies: gm,
  dependentRequired: gm,
  dependentSchemas: qi,
  propertyNames: Ui,
  uniqueItems: je.booleanOr,
  contains: Ui
};
function Ui(e, t, r, n, s) {
  r[e] = Yt(t, s);
}
function EI(e) {
  let t = [[]];
  for (const r of e) {
    const n = [];
    for (const s of t)
      for (const i of r)
        n.push([...s, i]);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    t = n;
  }
  return t;
}
<<<<<<< HEAD
function c_(e, t, r, n, i) {
=======
function ym(e, t, r, n, s) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (t.length === 1) {
    r[e] = t[0];
    return;
  }
<<<<<<< HEAD
  const s = bU(t), o = [];
  for (const a of s)
    try {
      const c = Mr(a, i);
      c !== void 0 && o.push(c);
    } catch (c) {
      if (c instanceof Vl.MergeError) continue;
=======
  const i = EI(t), o = [];
  for (const a of i)
    try {
      const c = Yt(a, s);
      c !== void 0 && o.push(c);
    } catch (c) {
      if (c instanceof qo.MergeError) continue;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      throw c;
    }
  r[e] = o;
}
<<<<<<< HEAD
function EU(e, t) {
  const { items: r, additionalItems: n } = e;
  return Array.isArray(r) ? t < r.length ? r[t] : n : r !== void 0 ? r : n;
}
function wU(e, t, r, n, i) {
  let s = 0;
  for (const a of t)
    Array.isArray(a) && (s = Math.max(s, a.length));
  if (s === 0) {
    r[e] = Mr(t, i);
    return;
  }
  const o = [];
  for (let a = 0; a < s; a++) {
    const c = [];
    for (const u of n) {
      const l = EU(u, a);
      l !== void 0 && c.push(l);
    }
    o[a] = Mr(c, i);
  }
  r[e] = o;
}
function SU(e, t, r, n, i) {
  let s = !1;
  for (const a of n)
    if (Array.isArray(a.items)) {
      s = !0;
      break;
    }
  if (!s) {
    r[e] = Mr(t, i);
=======
function SI(e, t) {
  const { items: r, additionalItems: n } = e;
  return Array.isArray(r) ? t < r.length ? r[t] : n : r !== void 0 ? r : n;
}
function xI(e, t, r, n, s) {
  let i = 0;
  for (const a of t)
    Array.isArray(a) && (i = Math.max(i, a.length));
  if (i === 0) {
    r[e] = Yt(t, s);
    return;
  }
  const o = [];
  for (let a = 0; a < i; a++) {
    const c = [];
    for (const f of n) {
      const l = SI(f, a);
      l !== void 0 && c.push(l);
    }
    o[a] = Yt(c, s);
  }
  r[e] = o;
}
function wI(e, t, r, n, s) {
  let i = !1;
  for (const a of n)
    if (Array.isArray(a.items)) {
      i = !0;
      break;
    }
  if (!i) {
    r[e] = Yt(t, s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return;
  }
  const o = [];
  for (const a of n) {
    let c = a.additionalItems;
    c === void 0 && !Array.isArray(a.items) && (c = a.items), c !== void 0 && o.push(c);
  }
<<<<<<< HEAD
  r[e] = Mr(o, i);
}
function xU(e, t) {
  const { properties: r, patternProperties: n, additionalProperties: i } = e;
  if ((r == null ? void 0 : r[t]) !== void 0)
    return r[t];
  for (const s of Object.keys(n ?? {}))
    if (new RegExp(s).test(t))
      return n[s];
  return i;
}
function RU(e, t, r, n, i) {
  const s = {};
  for (const a of n) {
    const c = a.properties ?? {};
    for (const u of Object.keys(c)) {
      if (s[u] !== void 0) continue;
      const l = c[u];
      s[u] = [l];
      for (const f of n) {
        if (a === f) continue;
        const m = xU(f, u);
        m !== void 0 && s[u].push(m);
=======
  r[e] = Yt(o, s);
}
function RI(e, t) {
  const { properties: r, patternProperties: n, additionalProperties: s } = e;
  if ((r == null ? void 0 : r[t]) !== void 0)
    return r[t];
  for (const i of Object.keys(n ?? {}))
    if (new RegExp(i).test(t))
      return n[i];
  return s;
}
function $I(e, t, r, n, s) {
  const i = {};
  for (const a of n) {
    const c = a.properties ?? {};
    for (const f of Object.keys(c)) {
      if (i[f] !== void 0) continue;
      const l = c[f];
      i[f] = [l];
      for (const d of n) {
        if (a === d) continue;
        const g = RI(d, f);
        g !== void 0 && i[f].push(g);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
  const o = {};
<<<<<<< HEAD
  for (const a of Object.keys(s)) {
    const c = s[a];
    o[a] = Mr(c, i);
  }
  r[e] = o;
}
function Dc(e, t, r, n, i) {
  const s = {};
  for (const a of t)
    for (const c of Object.keys(a))
      s[c] === void 0 && (s[c] = []), s[c].push(a[c]);
  const o = {};
  for (const a of Object.keys(s)) {
    const c = s[a], u = Mr(c, i);
    o[a] = u;
  }
  r[e] = o;
}
function $U(e, t, r, n, i) {
  for (let s = 0; s < n.length; s++) {
    const o = {
      if: n[s].if,
      then: n[s].then,
      else: n[s].else
=======
  for (const a of Object.keys(i)) {
    const c = i[a];
    o[a] = Yt(c, s);
  }
  r[e] = o;
}
function qi(e, t, r, n, s) {
  const i = {};
  for (const a of t)
    for (const c of Object.keys(a))
      i[c] === void 0 && (i[c] = []), i[c].push(a[c]);
  const o = {};
  for (const a of Object.keys(i)) {
    const c = i[a], f = Yt(c, s);
    o[a] = f;
  }
  r[e] = o;
}
function TI(e, t, r, n, s) {
  for (let i = 0; i < n.length; i++) {
    const o = {
      if: n[i].if,
      then: n[i].then,
      else: n[i].else
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    };
    if (o.if !== void 0) {
      if (r.if === void 0) {
        r.if = o.if, o.then !== void 0 && (r.then = o.then), o.else !== void 0 && (r.else = o.else);
        continue;
      }
<<<<<<< HEAD
      r.then !== void 0 && (r.then = Mr([r.then, o], i)), r.else !== void 0 && (r.else = Mr([r.else, o], i));
    }
  }
}
function l_(e, t, r) {
  const n = {};
  for (const i of t)
    for (const s of Object.keys(i)) {
      n[s] === void 0 && (n[s] = []);
      const o = n[s];
      for (const a of i[s])
=======
      r.then !== void 0 && (r.then = Yt([r.then, o], s)), r.else !== void 0 && (r.else = Yt([r.else, o], s));
    }
  }
}
function gm(e, t, r) {
  const n = {};
  for (const s of t)
    for (const i of Object.keys(s)) {
      n[i] === void 0 && (n[i] = []);
      const o = n[i];
      for (const a of s[i])
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        o.includes(a) || o.push(a);
    }
  r[e] = n;
}
<<<<<<< HEAD
function Mr(e, t) {
  if (e.length === 0) return {};
  if (e.length === 1) return e[0];
  const r = {}, n = {};
  let i = !0;
  for (const s of e) {
    if (s === !1) return !1;
    if (s !== !0) {
      i = !1;
      for (const o of Object.keys(s))
        n[o] === void 0 && (n[o] = []), n[o].push(s[o]);
    }
  }
  if (i) return !0;
  for (const s of Object.keys(n)) {
    const o = n[s];
    (t.resolvers[s] ?? t.defaultResolver)(s, o, r, e, t);
  }
  return r;
}
function TU(e, t, r, n, i) {
  const s = i.onConflict ?? "throw";
  if (t.length === 1 || s === "first") {
=======
function Yt(e, t) {
  if (e.length === 0) return {};
  if (e.length === 1) return e[0];
  const r = {}, n = {};
  let s = !0;
  for (const i of e) {
    if (i === !1) return !1;
    if (i !== !0) {
      s = !1;
      for (const o of Object.keys(i))
        n[o] === void 0 && (n[o] = []), n[o].push(i[o]);
    }
  }
  if (s) return !0;
  for (const i of Object.keys(n)) {
    const o = n[i];
    (t.resolvers[i] ?? t.defaultResolver)(i, o, r, e, t);
  }
  return r;
}
function OI(e, t, r, n, s) {
  const i = s.onConflict ?? "throw";
  if (t.length === 1 || i === "first") {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    r[e] = t[0];
    return;
  }
  let o = !0;
  for (let a = 1; a < t.length; a++)
<<<<<<< HEAD
    if (!vU(t[a], t[0])) {
=======
    if (!bI(t[a], t[0])) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      o = !1;
      break;
    }
  if (o) {
    r[e] = t[0];
    return;
  }
<<<<<<< HEAD
  if (s === "throw")
    throw new Vl.ResolverNotFoundError(e, t);
  if (s !== "skip")
    throw new Vl.InvalidOnConflictOptionError(s);
}
function OU(e, t = {}) {
  return t.defaultResolver === void 0 && (t.defaultResolver = TU), t.resolvers = { ..._U, ...t.resolvers }, Mr(e, t);
}
var PU = { mergeSchemas: OU, ...Vl };
const { mergeSchemas: CU } = PU;
function AU(e) {
  return CU(e, { onConflict: "skip" });
}
var IU = AU, Lc = { exports: {} }, u_;
function NU() {
  if (u_) return Lc.exports;
  u_ = 1;
  function e(t, r, n, i) {
    let s = "";
    r.validatorSchemasIds.size > 0 ? (s += `const Validator = require('fast-json-stringify/lib/validator')
`, s += `const validatorState = ${JSON.stringify(i.getState())}
`, s += `const validator = Validator.restoreFromState(validatorState)
`) : s += `const validator = null
=======
  if (i === "throw")
    throw new qo.ResolverNotFoundError(e, t);
  if (i !== "skip")
    throw new qo.InvalidOnConflictOptionError(i);
}
function CI(e, t = {}) {
  return t.defaultResolver === void 0 && (t.defaultResolver = OI), t.resolvers = { ..._I, ...t.resolvers }, Yt(e, t);
}
var PI = { mergeSchemas: CI, ...qo };
const { mergeSchemas: II } = PI;
function NI(e) {
  return II(e, { onConflict: "skip" });
}
var AI = NI, Hi = { exports: {} }, vm;
function kI() {
  if (vm) return Hi.exports;
  vm = 1;
  function e(t, r, n, s) {
    let i = "";
    r.validatorSchemasIds.size > 0 ? (i += `const Validator = require('fast-json-stringify/lib/validator')
`, i += `const validatorState = ${JSON.stringify(s.getState())}
`, i += `const validator = Validator.restoreFromState(validatorState)
`) : i += `const validator = null
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
`;
    const { schema: o, ...a } = n.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(a)}
  const serializer = Serializer.restoreFromState(serializerState)

<<<<<<< HEAD
  ${s}

  module.exports = ${t.toString()}(validator, serializer)`;
  }
  return Lc.exports = e, Lc.exports.dependencies = {
    Serializer: _m,
    Validator: WR
  }, Lc.exports;
}
const { RefResolver: kU } = rD, DU = _m, LU = WR, Ki = Q2, f_ = rU, FU = IU, jU = /'/g;
let yl = 2e4, XR = "default";
const UU = [
=======
  ${i}

  module.exports = ${t.toString()}(validator, serializer)`;
  }
  return Hi.exports = e, Hi.exports.dependencies = {
    Serializer: tf,
    Validator: A0
  }, Hi.exports;
}
const { RefResolver: LI } = n1, jI = tf, DI = A0, _n = eI, bm = nI, FI = AI, MI = /'/g;
let vo = 2e4, D0 = "default";
const zI = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "floor",
  "ceil",
  "round",
  "trunc"
<<<<<<< HEAD
], ZR = [
  "default",
  "json-stringify"
];
let sa = 0;
function xh(e, t) {
  if (!f_(e)) {
    t ? t = `"${t}" ` : t = "";
    const r = f_.errors[0], n = new Error(`${t}schema is invalid: data${r.instancePath} ${r.message}`);
    throw n.errors = xh.errors, n;
  }
}
function Va(e, t) {
  const r = t.schema.$ref;
  let n = r.indexOf("#");
  n === -1 && (n = r.length);
  const i = r.slice(0, n) || t.schemaId, s = r.slice(n) || "#", o = e.refResolver.getSchema(i, s);
  if (o === null)
    throw new Error(`Cannot find reference "${r}"`);
  const a = new Ki(o, i, s);
  return o.$ref !== void 0 ? Va(e, a) : a;
}
function Gl(e, t) {
  const r = e.refResolver.getSchema(t, "#");
  return new Ki(r, t, "#");
}
function d_(e, t) {
  return e.$id && e.$id.charAt(0) !== "#" ? e.$id : t;
}
function Cg(e, t) {
  xh(e), t = t || {};
=======
], F0 = [
  "default",
  "json-stringify"
];
let Hs = 0;
function bu(e, t) {
  if (!bm(e)) {
    t ? t = `"${t}" ` : t = "";
    const r = bm.errors[0], n = new Error(`${t}schema is invalid: data${r.instancePath} ${r.message}`);
    throw n.errors = bu.errors, n;
  }
}
function hi(e, t) {
  const r = t.schema.$ref;
  let n = r.indexOf("#");
  n === -1 && (n = r.length);
  const s = r.slice(0, n) || t.schemaId, i = r.slice(n) || "#", o = e.refResolver.getSchema(s, i);
  if (o === null)
    throw new Error(`Cannot find reference "${r}"`);
  const a = new _n(o, s, i);
  return o.$ref !== void 0 ? hi(e, a) : a;
}
function Ho(e, t) {
  const r = e.refResolver.getSchema(t, "#");
  return new _n(r, t, "#");
}
function _m(e, t) {
  return e.$id && e.$id.charAt(0) !== "#" ? e.$id : t;
}
function pd(e, t) {
  bu(e), t = t || {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = {
    functions: [],
    functionsCounter: 0,
    functionsNamesBySchema: /* @__PURE__ */ new Map(),
    options: t,
<<<<<<< HEAD
    refResolver: new kU(),
    rootSchemaId: e.$id || `__fjs_root_${sa++}`,
    validatorSchemasIds: /* @__PURE__ */ new Set(),
    mergedSchemasIds: /* @__PURE__ */ new Map()
  }, n = d_(e, r.rootSchemaId);
  if (r.refResolver.hasSchema(n) || r.refResolver.addSchema(e, r.rootSchemaId), t.schema)
    for (const l in t.schema) {
      const f = t.schema[l], m = d_(f, l);
      r.refResolver.hasSchema(m) || (xh(f, l), r.refResolver.addSchema(f, l));
    }
  if (t.rounding && !UU.includes(t.rounding))
    throw new Error(`Unsupported integer rounding method ${t.rounding}`);
  if (t.largeArrayMechanism)
    if (ZR.includes(t.largeArrayMechanism))
      XR = t.largeArrayMechanism;
=======
    refResolver: new LI(),
    rootSchemaId: e.$id || `__fjs_root_${Hs++}`,
    validatorSchemasIds: /* @__PURE__ */ new Set(),
    mergedSchemasIds: /* @__PURE__ */ new Map()
  }, n = _m(e, r.rootSchemaId);
  if (r.refResolver.hasSchema(n) || r.refResolver.addSchema(e, r.rootSchemaId), t.schema)
    for (const l in t.schema) {
      const d = t.schema[l], g = _m(d, l);
      r.refResolver.hasSchema(g) || (bu(d, l), r.refResolver.addSchema(d, l));
    }
  if (t.rounding && !zI.includes(t.rounding))
    throw new Error(`Unsupported integer rounding method ${t.rounding}`);
  if (t.largeArrayMechanism)
    if (F0.includes(t.largeArrayMechanism))
      D0 = t.largeArrayMechanism;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    else
      throw new Error(`Unsupported large array mechanism ${t.largeArrayMechanism}`);
  if (t.largeArraySize)
    if (typeof t.largeArraySize == "string" && Number.isFinite(Number.parseInt(t.largeArraySize, 10)))
<<<<<<< HEAD
      yl = Number.parseInt(t.largeArraySize, 10);
    else if (typeof t.largeArraySize == "number" && Number.isInteger(t.largeArraySize))
      yl = t.largeArraySize;
    else if (typeof t.largeArraySize == "bigint")
      yl = Number(t.largeArraySize);
    else
      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof t.largeArraySize} with value ${t.largeArraySize}`);
  const i = new Ki(e, r.rootSchemaId), s = yr(r, i, "input");
=======
      vo = Number.parseInt(t.largeArraySize, 10);
    else if (typeof t.largeArraySize == "number" && Number.isInteger(t.largeArraySize))
      vo = t.largeArraySize;
    else if (typeof t.largeArraySize == "bigint")
      vo = Number(t.largeArraySize);
    else
      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof t.largeArraySize} with value ${t.largeArraySize}`);
  const s = new _n(e, r.rootSchemaId), i = kt(r, s, "input");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let o = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
<<<<<<< HEAD
  s === "json += anonymous0(input)" ? o += `
=======
  i === "json += anonymous0(input)" ? o += `
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    ${r.functions.join(`
`)}
    const main = anonymous0
    return main
    ` : o += `
    function main (input) {
      let json = ''
<<<<<<< HEAD
      ${s}
=======
      ${i}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return json
    }
    ${r.functions.join(`
`)}
    return main
    `;
<<<<<<< HEAD
  const a = new DU(t), c = new LU(t.ajv);
  for (const l of r.validatorSchemasIds) {
    const f = r.refResolver.getSchema(l);
    c.addSchema(f, l);
    const m = r.refResolver.getSchemaDependencies(l);
    for (const [p, d] of Object.entries(m))
      c.addSchema(d, p);
=======
  const a = new jI(t), c = new DI(t.ajv);
  for (const l of r.validatorSchemasIds) {
    const d = r.refResolver.getSchema(l);
    c.addSchema(d, l);
    const g = r.refResolver.getSchemaDependencies(l);
    for (const [p, u] of Object.entries(g))
      c.addSchema(u, p);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  if (t.debugMode && (t.mode = "debug"), t.mode === "debug")
    return {
      validator: c,
      serializer: a,
      code: `validator
serializer
${o}`,
      ajv: c.ajv
    };
<<<<<<< HEAD
  const u = new Function("validator", "serializer", o);
  return t.mode === "standalone" ? NU()(u, r, a, c) : u(c, a);
}
const MU = [
=======
  const f = new Function("validator", "serializer", o);
  return t.mode === "standalone" ? kI()(f, r, a, c) : f(c, a);
}
const UI = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "maxProperties",
  "minProperties",
  "dependencies"
<<<<<<< HEAD
], HU = [
=======
], qI = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "items",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "contains"
<<<<<<< HEAD
], qU = [
  "maxLength",
  "minLength",
  "pattern"
], BU = [
=======
], HI = [
  "maxLength",
  "minLength",
  "pattern"
], BI = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum"
];
<<<<<<< HEAD
function zU(e) {
  for (const t of MU)
    if (t in e) return "object";
  for (const t of HU)
    if (t in e) return "array";
  for (const t of qU)
    if (t in e) return "string";
  for (const t of BU)
    if (t in e) return "number";
  return e.type;
}
function VU(e, t, r) {
  const n = t.schema, i = Object.keys(n.properties || {});
  let s = `
    const propertiesKeys = ${JSON.stringify(i)}
=======
function VI(e) {
  for (const t of UI)
    if (t in e) return "object";
  for (const t of qI)
    if (t in e) return "array";
  for (const t of HI)
    if (t in e) return "string";
  for (const t of BI)
    if (t in e) return "number";
  return e.type;
}
function GI(e, t, r) {
  const n = t.schema, s = Object.keys(n.properties || {});
  let i = `
    const propertiesKeys = ${JSON.stringify(s)}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
  const o = t.getPropertyLocation("patternProperties"), a = o.schema;
  if (a !== void 0)
    for (const l in a) {
<<<<<<< HEAD
      const f = o.getPropertyLocation(l);
      s += `
        if (/${l.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${r}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${yr(e, f, "value")}
=======
      const d = o.getPropertyLocation(l);
      i += `
        if (/${l.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${r}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${kt(e, d, "value")}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          continue
        }
      `;
    }
<<<<<<< HEAD
  const u = t.getPropertyLocation("additionalProperties").schema;
  if (u !== void 0)
    if (u === !0)
      s += `
=======
  const f = t.getPropertyLocation("additionalProperties").schema;
  if (f !== void 0)
    if (f === !0)
      i += `
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
    else {
      const l = t.getPropertyLocation("additionalProperties");
<<<<<<< HEAD
      s += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${yr(e, l, "value")}
      `;
    }
  return s += `
    }
  `, s;
}
function GU(e, t) {
  const r = t.schema, n = t.getPropertyLocation("properties"), i = r.required || [], s = Object.keys(r.properties || {}).sort(
    (u, l) => {
      const f = i.includes(u), m = i.includes(l);
      return f === m ? 0 : f ? -1 : 1;
    }
  ), o = i.includes(s[0]);
  let a = `let value
`;
  for (const u of i)
    if (!s.includes(u)) {
      const l = JSON.stringify(u);
=======
      i += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${kt(e, l, "value")}
      `;
    }
  return i += `
    }
  `, i;
}
function WI(e, t) {
  const r = t.schema, n = t.getPropertyLocation("properties"), s = r.required || [], i = Object.keys(r.properties || {}).sort(
    (f, l) => {
      const d = s.includes(f), g = s.includes(l);
      return d === g ? 0 : d ? -1 : 1;
    }
  ), o = s.includes(i[0]);
  let a = `let value
`;
  for (const f of s)
    if (!i.includes(f)) {
      const l = JSON.stringify(f);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      a += `if (obj[${l}] === undefined) throw new Error('${l.replace(/'/g, "\\'")} is required!')
`;
    }
  a += `let json = JSON_STR_BEGIN_OBJECT
`;
  let c = "";
  o || (a += `let addComma = false
`, c = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)");
<<<<<<< HEAD
  for (const u of s) {
    let l = n.getPropertyLocation(u);
    l.schema.$ref && (l = Va(e, l));
    const f = JSON.stringify(u), m = l.schema.default, p = i.includes(u);
    a += `
      value = obj[${f}]
      if (value !== undefined) {
        ${c}
        json += ${JSON.stringify(f + ":")}
        ${yr(e, l, "value")}
      }`, m !== void 0 ? a += ` else {
        ${c}
        json += ${JSON.stringify(f + ":" + JSON.stringify(m))}
      }
      ` : p ? a += ` else {
        throw new Error('${f.replace(/'/g, "\\'")} is required!')
=======
  for (const f of i) {
    let l = n.getPropertyLocation(f);
    l.schema.$ref && (l = hi(e, l));
    const d = JSON.stringify(f), g = l.schema.default, p = s.includes(f);
    a += `
      value = obj[${d}]
      if (value !== undefined) {
        ${c}
        json += ${JSON.stringify(d + ":")}
        ${kt(e, l, "value")}
      }`, g !== void 0 ? a += ` else {
        ${c}
        json += ${JSON.stringify(d + ":" + JSON.stringify(g))}
      }
      ` : p ? a += ` else {
        throw new Error('${d.replace(/'/g, "\\'")} is required!')
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      ` : a += `
`, o && (c = "json += ','");
  }
<<<<<<< HEAD
  return (r.patternProperties || r.additionalProperties) && (a += VU(e, t, c)), a += `
    return json + JSON_STR_END_OBJECT
  `, a;
}
function Wl(e, t, r) {
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    a.schema.$ref && (r[o] = Va(e, a));
  }
  const n = [];
  for (const o of r) {
    const a = QR(e, o.schema, o.schemaId);
    delete a.$id, n.push(a);
  }
  const i = FU(n), s = new Ki(i, t);
  return e.refResolver.addSchema(i, t), s;
}
function QR(e, t, r) {
  const n = Array.isArray(t) ? [] : {};
  t.$id !== void 0 && t.$id.charAt(0) !== "#" && (r = t.$id);
  const i = e.mergedSchemasIds.get(t);
  i && e.mergedSchemasIds.set(n, i);
  for (const s in t) {
    let o = t[s];
    s === "$ref" && typeof o == "string" && o.charAt(0) === "#" && (o = r + o), typeof o == "object" && o !== null && (o = QR(e, o, r)), n[s] = o;
  }
  return n;
}
function WU(e) {
=======
  return (r.patternProperties || r.additionalProperties) && (a += GI(e, t, c)), a += `
    return json + JSON_STR_END_OBJECT
  `, a;
}
function Bo(e, t, r) {
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    a.schema.$ref && (r[o] = hi(e, a));
  }
  const n = [];
  for (const o of r) {
    const a = M0(e, o.schema, o.schemaId);
    delete a.$id, n.push(a);
  }
  const s = FI(n), i = new _n(s, t);
  return e.refResolver.addSchema(s, t), i;
}
function M0(e, t, r) {
  const n = Array.isArray(t) ? [] : {};
  t.$id !== void 0 && t.$id.charAt(0) !== "#" && (r = t.$id);
  const s = e.mergedSchemasIds.get(t);
  s && e.mergedSchemasIds.set(n, s);
  for (const i in t) {
    let o = t[i];
    i === "$ref" && typeof o == "string" && o.charAt(0) === "#" && (o = r + o), typeof o == "object" && o !== null && (o = M0(e, o, r)), n[i] = o;
  }
  return n;
}
function KI(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return `(${e} && typeof ${e}.toJSON === 'function')
    ? ${e}.toJSON()
    : ${e}
  `;
}
<<<<<<< HEAD
function KU(e, t) {
  const r = t.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const n = t$(e);
  e.functionsNamesBySchema.set(r, n);
  let i = t.getSchemaRef();
  i.startsWith(e.rootSchemaId) && (i = i.replace(e.rootSchemaId, ""));
  let s = `
  `;
  const o = r.nullable === !0;
  return s += `
    // ${i}
    function ${n} (input) {
      const obj = ${WU("input")}
      ${o ? "" : "if (obj === null) return JSON_STR_EMPTY_OBJECT"}

      ${GU(e, t)}
    }
  `, e.functions.push(s), n;
}
function YU(e, t) {
  const r = t.schema;
  let n = t.getPropertyLocation("items");
  n.schema = n.schema || {}, n.schema.$ref && (n = Va(e, n));
  const i = n.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const s = t$(e);
  e.functionsNamesBySchema.set(r, s);
  let o = t.getSchemaRef();
  o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, ""));
  let a = `
    function ${s} (obj) {
=======
function JI(e, t) {
  const r = t.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const n = U0(e);
  e.functionsNamesBySchema.set(r, n);
  let s = t.getSchemaRef();
  s.startsWith(e.rootSchemaId) && (s = s.replace(e.rootSchemaId, ""));
  let i = `
  `;
  const o = r.nullable === !0;
  return i += `
    // ${s}
    function ${n} (input) {
      const obj = ${KI("input")}
      ${o ? "" : "if (obj === null) return JSON_STR_EMPTY_OBJECT"}

      ${WI(e, t)}
    }
  `, e.functions.push(i), n;
}
function YI(e, t) {
  const r = t.schema;
  let n = t.getPropertyLocation("items");
  n.schema = n.schema || {}, n.schema.$ref && (n = hi(e, n));
  const s = n.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const i = U0(e);
  e.functionsNamesBySchema.set(r, i);
  let o = t.getSchemaRef();
  o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, ""));
  let a = `
    function ${i} (obj) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      // ${o}
  `;
  const c = r.nullable === !0;
  if (a += `
    ${c ? "" : "if (obj === null) return JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
<<<<<<< HEAD
  `, !r.additionalItems && Array.isArray(i) && (a += `
      if (arrayLength > ${i.length}) {
        throw new Error(\`Item at ${i.length} does not match schema definition.\`)
      }
    `), XR === "json-stringify" && (a += `if (arrayLength >= ${yl}) return JSON.stringify(obj)
=======
  `, !r.additionalItems && Array.isArray(s) && (a += `
      if (arrayLength > ${s.length}) {
        throw new Error(\`Item at ${s.length} does not match schema definition.\`)
      }
    `), D0 === "json-stringify" && (a += `if (arrayLength >= ${vo}) return JSON.stringify(obj)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
`), a += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
<<<<<<< HEAD
  `, Array.isArray(i)) {
    for (let u = 0; u < i.length; u++) {
      const l = i[u];
      a += `value = obj[${u}]`;
      const f = yr(e, n.getPropertyLocation(u), "value");
      a += `
        if (${u} < arrayLength) {
          if (${e$(l.type)}) {
            ${f}
            if (${u} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${u} does not match schema definition.\`)
=======
  `, Array.isArray(s)) {
    for (let f = 0; f < s.length; f++) {
      const l = s[f];
      a += `value = obj[${f}]`;
      const d = kt(e, n.getPropertyLocation(f), "value");
      a += `
        if (${f} < arrayLength) {
          if (${z0(l.type)}) {
            ${d}
            if (${f} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${f} does not match schema definition.\`)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          }
        }
        `;
    }
    r.additionalItems && (a += `
<<<<<<< HEAD
        for (let i = ${i.length}; i < arrayLength; i++) {
=======
        for (let i = ${s.length}; i < arrayLength; i++) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`);
  } else {
<<<<<<< HEAD
    const u = yr(e, n, "obj[i]");
    a += `
      for (let i = 0; i < arrayLength; i++) {
        ${u}
=======
    const f = kt(e, n, "obj[i]");
    a += `
      for (let i = 0; i < arrayLength; i++) {
        ${f}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
  }
  return a += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
<<<<<<< HEAD
  }`, e.functions.push(a), s;
}
function e$(e, t) {
=======
  }`, e.functions.push(a), i;
}
function z0(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let r;
  switch (e) {
    case "null":
      r = "value === null";
      break;
    case "string":
      r = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
      break;
    case "integer":
      r = "Number.isInteger(value)";
      break;
    case "number":
      r = "Number.isFinite(value)";
      break;
    case "boolean":
      r = "typeof value === 'boolean'";
      break;
    case "object":
      r = "value && typeof value === 'object' && value.constructor === Object";
      break;
    case "array":
      r = "Array.isArray(value)";
      break;
    default:
<<<<<<< HEAD
      Array.isArray(e) && (r = `(${e.map((i) => e$(i)).join(" || ")})`);
  }
  return r;
}
function t$(e) {
  return "anonymous" + e.functionsCounter++;
}
function JU(e, t, r) {
  const i = t.schema.type.sort((a) => a === "null" ? -1 : 1);
  let s = "";
  i.forEach((a, c) => {
    t.schema = { ...t.schema, type: a };
    const u = r$(e, t, r), l = c === 0 ? "if" : "else if";
    switch (a) {
      case "null":
        s += `
          ${l} (${r} === null)
            ${u}
          `;
        break;
      case "string": {
        s += `
=======
      Array.isArray(e) && (r = `(${e.map((s) => z0(s)).join(" || ")})`);
  }
  return r;
}
function U0(e) {
  return "anonymous" + e.functionsCounter++;
}
function XI(e, t, r) {
  const s = t.schema.type.sort((a) => a === "null" ? -1 : 1);
  let i = "";
  s.forEach((a, c) => {
    t.schema = { ...t.schema, type: a };
    const f = q0(e, t, r), l = c === 0 ? "if" : "else if";
    switch (a) {
      case "null":
        i += `
          ${l} (${r} === null)
            ${f}
          `;
        break;
      case "string": {
        i += `
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          ${l}(
            typeof ${r} === "string" ||
            ${r} === null ||
            ${r} instanceof Date ||
            ${r} instanceof RegExp ||
            (
              typeof ${r} === "object" &&
              typeof ${r}.toString === "function" &&
              ${r}.toString !== Object.prototype.toString
            )
          )
<<<<<<< HEAD
            ${u}
=======
            ${f}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        `;
        break;
      }
      case "array": {
<<<<<<< HEAD
        s += `
          ${l}(Array.isArray(${r}))
            ${u}
=======
        i += `
          ${l}(Array.isArray(${r}))
            ${f}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        `;
        break;
      }
      case "integer": {
<<<<<<< HEAD
        s += `
          ${l}(Number.isInteger(${r}) || ${r} === null)
            ${u}
=======
        i += `
          ${l}(Number.isInteger(${r}) || ${r} === null)
            ${f}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        `;
        break;
      }
      default: {
<<<<<<< HEAD
        s += `
          ${l}(typeof ${r} === "${a}" || ${r} === null)
            ${u}
=======
        i += `
          ${l}(typeof ${r} === "${a}" || ${r} === null)
            ${f}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        `;
        break;
      }
    }
  });
  let o = t.getSchemaRef();
<<<<<<< HEAD
  return o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, "")), s += `
    else throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
  `, s;
}
function r$(e, t, r) {
=======
  return o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, "")), i += `
    else throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
  `, i;
}
function q0(e, t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const n = t.schema;
  switch (n.type) {
    case "null":
      return "json += JSON_STR_NULL";
    case "string":
      return n.format === "date-time" ? `json += serializer.asDateTime(${r})` : n.format === "date" ? `json += serializer.asDate(${r})` : n.format === "time" ? `json += serializer.asTime(${r})` : n.format === "unsafe" ? `json += serializer.asUnsafeString(${r})` : `
        if (typeof ${r} !== 'string') {
          if (${r} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${r} instanceof Date) {
            json += JSON_STR_QUOTE + ${r}.toISOString() + JSON_STR_QUOTE
          } else if (${r} instanceof RegExp) {
            json += serializer.asString(${r}.source)
          } else {
            json += serializer.asString(${r}.toString())
          }
        } else {
          json += serializer.asString(${r})
        }
        `;
    case "integer":
      return `json += serializer.asInteger(${r})`;
    case "number":
      return `json += serializer.asNumber(${r})`;
    case "boolean":
      return `json += serializer.asBoolean(${r})`;
    case "object":
<<<<<<< HEAD
      return `json += ${KU(e, t)}(${r})`;
    case "array":
      return `json += ${YU(e, t)}(${r})`;
=======
      return `json += ${JI(e, t)}(${r})`;
    case "array":
      return `json += ${YI(e, t)}(${r})`;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    case void 0:
      return `json += JSON.stringify(${r})`;
    default:
      throw new Error(`${n.type} unsupported`);
  }
}
<<<<<<< HEAD
function XU(e, t) {
  const r = e.schema, n = r.type, i = Array.isArray(n) && n.includes("null");
  let s = "";
  return i && (s += `
      if (${t} === null) {
        json += JSON_STR_NULL
      } else {
    `), s += `json += '${JSON.stringify(r.const).replace(jU, "\\'")}'`, i && (s += `
      }
    `), s;
}
function ZU(e, t, r) {
  const n = t.schema;
  let i = e.mergedSchemasIds.get(n);
  if (i) {
    const l = Gl(e, i);
    return yr(e, l, r);
  }
  i = `__fjs_merged_${sa++}`, e.mergedSchemasIds.set(n, i);
  const { allOf: s, ...o } = t.schema, a = [
    new Ki(
=======
function ZI(e, t) {
  const r = e.schema, n = r.type, s = Array.isArray(n) && n.includes("null");
  let i = "";
  return s && (i += `
      if (${t} === null) {
        json += JSON_STR_NULL
      } else {
    `), i += `json += '${JSON.stringify(r.const).replace(MI, "\\'")}'`, s && (i += `
      }
    `), i;
}
function QI(e, t, r) {
  const n = t.schema;
  let s = e.mergedSchemasIds.get(n);
  if (s) {
    const l = Ho(e, s);
    return kt(e, l, r);
  }
  s = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(n, s);
  const { allOf: i, ...o } = t.schema, a = [
    new _n(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      o,
      t.schemaId,
      t.jsonPointer
    )
  ], c = t.getPropertyLocation("allOf");
<<<<<<< HEAD
  for (let l = 0; l < s.length; l++)
    a.push(c.getPropertyLocation(l));
  const u = Wl(e, i, a);
  return yr(e, u, r);
}
function QU(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const i = t.schema.anyOf ? "anyOf" : "oneOf", { [i]: s, ...o } = t.schema, a = new Ki(
    o,
    t.schemaId,
    t.jsonPointer
  ), c = t.getPropertyLocation(i);
  let u = "";
  for (let f = 0; f < s.length; f++) {
    const m = c.getPropertyLocation(f), p = m.schema;
    let d = e.mergedSchemasIds.get(p), h = null;
    d ? h = Gl(e, d) : (d = `__fjs_merged_${sa++}`, e.mergedSchemasIds.set(p, d), h = Wl(e, d, [
      a,
      m
    ]));
    const _ = yr(e, h, r), g = m.getSchemaRef();
    u += `
      ${f === 0 ? "if" : "else if"}(validator.validate("${g}", ${r}))
        ${_}
    `;
  }
  let l = t.getSchemaRef();
  return l.startsWith(e.rootSchemaId) && (l = l.replace(e.rootSchemaId, "")), u += `
    else throw new TypeError(\`The value of '${l}' does not match schema definition.\`)
  `, u;
}
function eM(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const {
    if: n,
    then: i,
    else: s,
    ...o
  } = t.schema, a = new Ki(
    o,
    t.schemaId,
    t.jsonPointer
  ), u = t.getPropertyLocation("if").getSchemaRef(), l = t.getPropertyLocation("then");
  let f = e.mergedSchemasIds.get(i), m = null;
  if (f ? m = Gl(e, f) : (f = `__fjs_merged_${sa++}`, e.mergedSchemasIds.set(i, f), m = Wl(e, f, [
    a,
    l
  ])), !s)
    return `
      if (validator.validate("${u}", ${r})) {
        ${yr(e, m, r)}
      } else {
        ${yr(e, a, r)}
      }
    `;
  const p = t.getPropertyLocation("else");
  let d = e.mergedSchemasIds.get(s), h = null;
  return d ? h = Gl(e, d) : (d = `__fjs_merged_${sa++}`, e.mergedSchemasIds.set(s, d), h = Wl(e, d, [
    a,
    p
  ])), `
    if (validator.validate("${u}", ${r})) {
      ${yr(e, m, r)}
    } else {
      ${yr(e, h, r)}
    }
  `;
}
function yr(e, t, r) {
  let n = t.schema;
  if (typeof n == "boolean")
    return `json += JSON.stringify(${r})`;
  if (n.$ref && (t = Va(e, t), n = t.schema), n.allOf)
    return ZU(e, t, r);
  if (n.anyOf || n.oneOf)
    return QU(e, t, r);
  if (n.if && n.then)
    return eM(e, t, r);
  if (n.type === void 0) {
    const a = zU(n);
    a && (n.type = a);
  }
  let i = "";
  const s = n.type, o = n.nullable === !0;
  return o && (i += `
      if (${r} === null) {
        json += JSON_STR_NULL
      } else {
    `), n.const !== void 0 ? i += XU(t, r) : Array.isArray(s) ? i += JU(e, t, r) : i += r$(e, t, r), o && (i += `
      }
    `), i;
}
eo.exports = Cg;
eo.exports.default = Cg;
eo.exports.build = Cg;
eo.exports.validLargeArrayMechanisms = ZR;
eo.exports.restore = function({ code: e, validator: t, serializer: r }) {
  return Function.apply(null, ["validator", "serializer", e]).apply(null, [t, r]);
};
var tM = eo.exports;
const rM = tM;
function n$() {
  return function(t, r) {
    const n = Object.assign({}, r, { schema: t });
    return nM.bind(null, n);
  };
}
function nM(e, {
  schema: t
  /* method, url, httpStatus */
}) {
  return e.schema && t.$id && e.schema[t.$id] && (e.schema = { ...e.schema }, delete e.schema[t.$id]), rM(t, e);
}
function i$(e = { readMode: !0 }) {
=======
  for (let l = 0; l < i.length; l++)
    a.push(c.getPropertyLocation(l));
  const f = Bo(e, s, a);
  return kt(e, f, r);
}
function eN(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const s = t.schema.anyOf ? "anyOf" : "oneOf", { [s]: i, ...o } = t.schema, a = new _n(
    o,
    t.schemaId,
    t.jsonPointer
  ), c = t.getPropertyLocation(s);
  let f = "";
  for (let d = 0; d < i.length; d++) {
    const g = c.getPropertyLocation(d), p = g.schema;
    let u = e.mergedSchemasIds.get(p), h = null;
    u ? h = Ho(e, u) : (u = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(p, u), h = Bo(e, u, [
      a,
      g
    ]));
    const b = kt(e, h, r), m = g.getSchemaRef();
    f += `
      ${d === 0 ? "if" : "else if"}(validator.validate("${m}", ${r}))
        ${b}
    `;
  }
  let l = t.getSchemaRef();
  return l.startsWith(e.rootSchemaId) && (l = l.replace(e.rootSchemaId, "")), f += `
    else throw new TypeError(\`The value of '${l}' does not match schema definition.\`)
  `, f;
}
function tN(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const {
    if: n,
    then: s,
    else: i,
    ...o
  } = t.schema, a = new _n(
    o,
    t.schemaId,
    t.jsonPointer
  ), f = t.getPropertyLocation("if").getSchemaRef(), l = t.getPropertyLocation("then");
  let d = e.mergedSchemasIds.get(s), g = null;
  if (d ? g = Ho(e, d) : (d = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(s, d), g = Bo(e, d, [
    a,
    l
  ])), !i)
    return `
      if (validator.validate("${f}", ${r})) {
        ${kt(e, g, r)}
      } else {
        ${kt(e, a, r)}
      }
    `;
  const p = t.getPropertyLocation("else");
  let u = e.mergedSchemasIds.get(i), h = null;
  return u ? h = Ho(e, u) : (u = `__fjs_merged_${Hs++}`, e.mergedSchemasIds.set(i, u), h = Bo(e, u, [
    a,
    p
  ])), `
    if (validator.validate("${f}", ${r})) {
      ${kt(e, g, r)}
    } else {
      ${kt(e, h, r)}
    }
  `;
}
function kt(e, t, r) {
  let n = t.schema;
  if (typeof n == "boolean")
    return `json += JSON.stringify(${r})`;
  if (n.$ref && (t = hi(e, t), n = t.schema), n.allOf)
    return QI(e, t, r);
  if (n.anyOf || n.oneOf)
    return eN(e, t, r);
  if (n.if && n.then)
    return tN(e, t, r);
  if (n.type === void 0) {
    const a = VI(n);
    a && (n.type = a);
  }
  let s = "";
  const i = n.type, o = n.nullable === !0;
  return o && (s += `
      if (${r} === null) {
        json += JSON_STR_NULL
      } else {
    `), n.const !== void 0 ? s += ZI(t, r) : Array.isArray(i) ? s += XI(e, t, r) : s += q0(e, t, r), o && (s += `
      }
    `), s;
}
ss.exports = pd;
ss.exports.default = pd;
ss.exports.build = pd;
ss.exports.validLargeArrayMechanisms = F0;
ss.exports.restore = function({ code: e, validator: t, serializer: r }) {
  return Function.apply(null, ["validator", "serializer", e]).apply(null, [t, r]);
};
var rN = ss.exports;
const nN = rN;
function H0() {
  return function(t, r) {
    const n = Object.assign({}, r, { schema: t });
    return sN.bind(null, n);
  };
}
function sN(e, {
  schema: t
  /* method, url, httpStatus */
}) {
  return e.schema && t.$id && e.schema[t.$id] && (e.schema = { ...e.schema }, delete e.schema[t.$id]), nN(t, e);
}
function B0(e = { readMode: !0 }) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (e.readMode === !0 && typeof e.restoreFunction != "function")
    throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
  if (e.readMode !== !0 && typeof e.storeFunction != "function")
    throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
  if (e.readMode === !0)
    return function() {
      return function(n) {
        return e.restoreFunction(n);
      };
    };
<<<<<<< HEAD
  const t = n$();
  return function(n, i = {}) {
    i.mode = "standalone";
    const s = t(n, i);
    return function(o) {
      const a = s(o);
=======
  const t = H0();
  return function(n, s = {}) {
    s.mode = "standalone";
    const i = t(n, s);
    return function(o) {
      const a = i(o);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return e.storeFunction(o, a), new Function(a);
    };
  };
}
<<<<<<< HEAD
Du.SerializerSelector = n$;
Du.StandaloneSerializer = i$;
Du.default = i$;
const { SerializerSelector: Ag, StandaloneSerializer: iM } = Du;
qa.exports = Ag;
qa.exports.default = Ag;
qa.exports.SerializerSelector = Ag;
qa.exports.StandaloneSerializer = iM;
var sM = qa.exports, pi = { exports: {} }, Rh = { exports: {} }, Ig = {}, Yi = {}, Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.checkMetadata = void 0;
const oM = se, aM = {
  keyword: "metadata",
  schemaType: "object",
  code(e) {
    s$(e);
    const { gen: t, schema: r, it: n } = e;
    if ((0, oM.alwaysValidSchema)(n, r))
      return;
    const i = t.name("valid");
    e.subschema({ keyword: "metadata", jtdMetadata: !0 }, i), e.ok(i);
  }
};
function s$({ it: e, keyword: t }, r) {
  if (e.jtdMetadata !== r)
    throw new Error(`JTD: "${t}" cannot be used in this schema location`);
}
Ar.checkMetadata = s$;
Ar.default = aM;
Object.defineProperty(Yi, "__esModule", { value: !0 });
Yi.hasRef = void 0;
const p_ = kt, Ro = he, cM = on, h_ = _r, m_ = Jn, lM = Ar, uM = {
  keyword: "ref",
  schemaType: "string",
  code(e) {
    (0, lM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: i, it: s } = e, { schemaEnv: { root: o } } = s, a = t.name("valid");
    i.nullable ? (t.var(a, (0, Ro._)`${r} === null`), t.if((0, Ro.not)(a), c)) : (t.var(a, !1), c()), e.ok(a);
    function c() {
      var f;
      const m = (f = o.schema.definitions) === null || f === void 0 ? void 0 : f[n];
      if (!m)
        throw new cM.default(s.opts.uriResolver, "", n, `No definition ${n}`);
      Ng(m) || !s.opts.inlineRefs ? u(m) : l(m);
    }
    function u(f) {
      const m = p_.compileSchema.call(s.self, new p_.SchemaEnv({ schema: f, root: o, schemaPath: `/definitions/${n}` })), p = (0, m_.getValidate)(e, m), d = t.const("_errs", h_.default.errors);
      (0, m_.callRef)(e, p, m, m.$async), t.assign(a, (0, Ro._)`${d} === ${h_.default.errors}`);
    }
    function l(f) {
      const m = t.scopeValue("schema", s.opts.code.source === !0 ? { ref: f, code: (0, Ro.stringify)(f) } : { ref: f });
      e.subschema({
        schema: f,
        dataTypes: [],
        schemaPath: Ro.nil,
        topSchemaRef: m,
=======
ya.SerializerSelector = H0;
ya.StandaloneSerializer = B0;
ya.default = B0;
const { SerializerSelector: hd, StandaloneSerializer: iN } = ya;
fi.exports = hd;
fi.exports.default = hd;
fi.exports.SerializerSelector = hd;
fi.exports.StandaloneSerializer = iN;
var oN = fi.exports, Wr = { exports: {} }, _u = { exports: {} }, md = {}, En = {}, Ht = {};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.checkMetadata = void 0;
const aN = re, cN = {
  keyword: "metadata",
  schemaType: "object",
  code(e) {
    V0(e);
    const { gen: t, schema: r, it: n } = e;
    if ((0, aN.alwaysValidSchema)(n, r))
      return;
    const s = t.name("valid");
    e.subschema({ keyword: "metadata", jtdMetadata: !0 }, s), e.ok(s);
  }
};
function V0({ it: e, keyword: t }, r) {
  if (e.jtdMetadata !== r)
    throw new Error(`JTD: "${t}" cannot be used in this schema location`);
}
Ht.checkMetadata = V0;
Ht.default = cN;
Object.defineProperty(En, "__esModule", { value: !0 });
En.hasRef = void 0;
const Em = dt, bs = ae, lN = mr, Sm = jt, xm = qr, uN = Ht, fN = {
  keyword: "ref",
  schemaType: "string",
  code(e) {
    (0, uN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: s, it: i } = e, { schemaEnv: { root: o } } = i, a = t.name("valid");
    s.nullable ? (t.var(a, (0, bs._)`${r} === null`), t.if((0, bs.not)(a), c)) : (t.var(a, !1), c()), e.ok(a);
    function c() {
      var d;
      const g = (d = o.schema.definitions) === null || d === void 0 ? void 0 : d[n];
      if (!g)
        throw new lN.default(i.opts.uriResolver, "", n, `No definition ${n}`);
      yd(g) || !i.opts.inlineRefs ? f(g) : l(g);
    }
    function f(d) {
      const g = Em.compileSchema.call(i.self, new Em.SchemaEnv({ schema: d, root: o, schemaPath: `/definitions/${n}` })), p = (0, xm.getValidate)(e, g), u = t.const("_errs", Sm.default.errors);
      (0, xm.callRef)(e, p, g, g.$async), t.assign(a, (0, bs._)`${u} === ${Sm.default.errors}`);
    }
    function l(d) {
      const g = t.scopeValue("schema", i.opts.code.source === !0 ? { ref: d, code: (0, bs.stringify)(d) } : { ref: d });
      e.subschema({
        schema: d,
        dataTypes: [],
        schemaPath: bs.nil,
        topSchemaRef: g,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        errSchemaPath: `/definitions/${n}`
      }, a);
    }
  }
};
<<<<<<< HEAD
function Ng(e) {
  for (const t in e) {
    let r;
    if (t === "ref" || typeof (r = e[t]) == "object" && Ng(r))
=======
function yd(e) {
  for (const t in e) {
    let r;
    if (t === "ref" || typeof (r = e[t]) == "object" && yd(r))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return !0;
  }
  return !1;
}
<<<<<<< HEAD
Yi.hasRef = Ng;
Yi.default = uM;
var kg = {}, zu = {};
Object.defineProperty(zu, "__esModule", { value: !0 });
const fM = /t|\s/i, dM = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, pM = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i, hM = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function o$(e, t) {
  const r = e.split(fM);
  return r.length === 2 && g_(r[0]) && mM(r[1]) || t && r.length === 1 && g_(r[0]);
}
zu.default = o$;
function g_(e) {
  const t = dM.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], i = +t[3];
  return n >= 1 && n <= 12 && i >= 1 && (i <= hM[n] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
  n === 2 && i === 29 && (r % 100 === 0 ? r % 400 === 0 : r % 4 === 0));
}
function mM(e) {
  const t = pM.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], i = +t[3], s = +(t[4] || 0), o = +(t[5] || 0);
  return r <= 23 && n <= 59 && i <= 59 || // leap second
  r - s === 23 && n - o === 59 && i === 60;
}
o$.code = 'require("ajv/dist/runtime/timestamp").default';
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.typeErrorParams = Cr.typeErrorMessage = Cr.typeError = void 0;
const gM = he;
function yM(e) {
  return {
    message: (t) => a$(t, e),
    params: (t) => c$(t, e)
  };
}
Cr.typeError = yM;
function a$({ parentSchema: e }, t) {
  return e != null && e.nullable ? `must be ${t} or null` : `must be ${t}`;
}
Cr.typeErrorMessage = a$;
function c$({ parentSchema: e }, t) {
  return (0, gM._)`{type: ${t}, nullable: ${!!(e != null && e.nullable)}}`;
}
Cr.typeErrorParams = c$;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intRange = void 0;
  const t = he, r = zu, n = se, i = Ar, s = Cr;
=======
En.hasRef = yd;
En.default = fN;
var gd = {}, Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
const dN = /t|\s/i, pN = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, hN = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i, mN = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function G0(e, t) {
  const r = e.split(dN);
  return r.length === 2 && wm(r[0]) && yN(r[1]) || t && r.length === 1 && wm(r[0]);
}
Ra.default = G0;
function wm(e) {
  const t = pN.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], s = +t[3];
  return n >= 1 && n <= 12 && s >= 1 && (s <= mN[n] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
  n === 2 && s === 29 && (r % 100 === 0 ? r % 400 === 0 : r % 4 === 0));
}
function yN(e) {
  const t = hN.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], s = +t[3], i = +(t[4] || 0), o = +(t[5] || 0);
  return r <= 23 && n <= 59 && s <= 59 || // leap second
  r - i === 23 && n - o === 59 && s === 60;
}
G0.code = 'require("ajv/dist/runtime/timestamp").default';
var qt = {};
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.typeErrorParams = qt.typeErrorMessage = qt.typeError = void 0;
const gN = ae;
function vN(e) {
  return {
    message: (t) => W0(t, e),
    params: (t) => K0(t, e)
  };
}
qt.typeError = vN;
function W0({ parentSchema: e }, t) {
  return e != null && e.nullable ? `must be ${t} or null` : `must be ${t}`;
}
qt.typeErrorMessage = W0;
function K0({ parentSchema: e }, t) {
  return (0, gN._)`{type: ${t}, nullable: ${!!(e != null && e.nullable)}}`;
}
qt.typeErrorParams = K0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intRange = void 0;
  const t = ae, r = Ra, n = re, s = Ht, i = qt;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  e.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10]
  };
  const o = {
<<<<<<< HEAD
    message: (u) => (0, s.typeErrorMessage)(u, u.schema),
    params: (u) => (0, s.typeErrorParams)(u, u.schema)
  };
  function a(u) {
    const { gen: l, data: f, it: m } = u, { timestamp: p, allowDate: d } = m.opts;
    if (p === "date")
      return (0, t._)`${f} instanceof Date `;
    const h = (0, n.useFunc)(l, r.default), _ = d ? (0, t._)`, true` : t.nil, g = (0, t._)`typeof ${f} == "string" && ${h}(${f}${_})`;
    return p === "string" ? g : (0, t.or)((0, t._)`${f} instanceof Date`, g);
=======
    message: (f) => (0, i.typeErrorMessage)(f, f.schema),
    params: (f) => (0, i.typeErrorParams)(f, f.schema)
  };
  function a(f) {
    const { gen: l, data: d, it: g } = f, { timestamp: p, allowDate: u } = g.opts;
    if (p === "date")
      return (0, t._)`${d} instanceof Date `;
    const h = (0, n.useFunc)(l, r.default), b = u ? (0, t._)`, true` : t.nil, m = (0, t._)`typeof ${d} == "string" && ${h}(${d}${b})`;
    return p === "string" ? m : (0, t.or)((0, t._)`${d} instanceof Date`, m);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  const c = {
    keyword: "type",
    schemaType: "string",
    error: o,
<<<<<<< HEAD
    code(u) {
      (0, i.checkMetadata)(u);
      const { data: l, schema: f, parentSchema: m, it: p } = u;
      let d;
      switch (f) {
        case "boolean":
        case "string":
          d = (0, t._)`typeof ${l} == ${f}`;
          break;
        case "timestamp": {
          d = a(u);
=======
    code(f) {
      (0, s.checkMetadata)(f);
      const { data: l, schema: d, parentSchema: g, it: p } = f;
      let u;
      switch (d) {
        case "boolean":
        case "string":
          u = (0, t._)`typeof ${l} == ${d}`;
          break;
        case "timestamp": {
          u = a(f);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          break;
        }
        case "float32":
        case "float64":
<<<<<<< HEAD
          d = (0, t._)`typeof ${l} == "number"`;
          break;
        default: {
          const h = f;
          if (d = (0, t._)`typeof ${l} == "number" && isFinite(${l}) && !(${l} % 1)`, !p.opts.int32range && (h === "int32" || h === "uint32"))
            h === "uint32" && (d = (0, t._)`${d} && ${l} >= 0`);
          else {
            const [_, g] = e.intRange[h];
            d = (0, t._)`${d} && ${l} >= ${_} && ${l} <= ${g}`;
          }
        }
      }
      u.pass(m.nullable ? (0, t.or)((0, t._)`${l} === null`, d) : d);
    }
  };
  e.default = c;
})(kg);
var Dg = {}, rn = {};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.checkNullableObject = rn.checkNullable = void 0;
const vl = he;
function l$({ gen: e, data: t, parentSchema: r }, n = vl.nil) {
  const i = e.name("valid");
  return r.nullable ? (e.let(i, (0, vl._)`${t} === null`), n = (0, vl.not)(i)) : e.let(i, !1), [i, n];
}
rn.checkNullable = l$;
function vM(e, t) {
  const [r, n] = l$(e, t);
  return [r, (0, vl._)`${n} && typeof ${e.data} == "object" && !Array.isArray(${e.data})`];
}
rn.checkNullableObject = vM;
Object.defineProperty(Dg, "__esModule", { value: !0 });
const Ln = he, _M = Ar, bM = rn, EM = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Ln._)`{allowedValues: ${e}}`
}, wM = {
  keyword: "enum",
  schemaType: "array",
  error: EM,
  code(e) {
    (0, _M.checkMetadata)(e);
    const { gen: t, data: r, schema: n, schemaValue: i, parentSchema: s, it: o } = e;
=======
          u = (0, t._)`typeof ${l} == "number"`;
          break;
        default: {
          const h = d;
          if (u = (0, t._)`typeof ${l} == "number" && isFinite(${l}) && !(${l} % 1)`, !p.opts.int32range && (h === "int32" || h === "uint32"))
            h === "uint32" && (u = (0, t._)`${u} && ${l} >= 0`);
          else {
            const [b, m] = e.intRange[h];
            u = (0, t._)`${u} && ${l} >= ${b} && ${l} <= ${m}`;
          }
        }
      }
      f.pass(g.nullable ? (0, t.or)((0, t._)`${l} === null`, u) : u);
    }
  };
  e.default = c;
})(gd);
var vd = {}, dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.checkNullableObject = dr.checkNullable = void 0;
const bo = ae;
function J0({ gen: e, data: t, parentSchema: r }, n = bo.nil) {
  const s = e.name("valid");
  return r.nullable ? (e.let(s, (0, bo._)`${t} === null`), n = (0, bo.not)(s)) : e.let(s, !1), [s, n];
}
dr.checkNullable = J0;
function bN(e, t) {
  const [r, n] = J0(e, t);
  return [r, (0, bo._)`${n} && typeof ${e.data} == "object" && !Array.isArray(${e.data})`];
}
dr.checkNullableObject = bN;
Object.defineProperty(vd, "__esModule", { value: !0 });
const Ar = ae, _N = Ht, EN = dr, SN = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Ar._)`{allowedValues: ${e}}`
}, xN = {
  keyword: "enum",
  schemaType: "array",
  error: SN,
  code(e) {
    (0, _N.checkMetadata)(e);
    const { gen: t, data: r, schema: n, schemaValue: s, parentSchema: i, it: o } = e;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (n.length === 0)
      throw new Error("enum must have non-empty array");
    if (n.length !== new Set(n).size)
      throw new Error("enum items must be unique");
    let a;
<<<<<<< HEAD
    const c = (0, Ln._)`typeof ${r} == "string"`;
    if (n.length >= o.opts.loopEnum) {
      let l;
      [a, l] = (0, bM.checkNullable)(e, c), t.if(l, u);
    } else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      a = (0, Ln.and)(c, (0, Ln.or)(...n.map((l) => (0, Ln._)`${r} === ${l}`))), s.nullable && (a = (0, Ln.or)((0, Ln._)`${r} === null`, a));
    }
    e.pass(a);
    function u() {
      t.forOf("v", i, (l) => t.if((0, Ln._)`${a} = ${r} === ${l}`, () => t.break()));
    }
  }
};
Dg.default = wM;
var Lg = {};
Object.defineProperty(Lg, "__esModule", { value: !0 });
const SM = se, xM = _e, y_ = he, RM = Ar, $M = rn, TM = Cr, OM = {
  keyword: "elements",
  schemaType: "object",
  error: (0, TM.typeError)("array"),
  code(e) {
    (0, RM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: i } = e;
    if ((0, SM.alwaysValidSchema)(i, n))
      return;
    const [s] = (0, $M.checkNullable)(e);
    t.if((0, y_.not)(s), () => t.if((0, y_._)`Array.isArray(${r})`, () => t.assign(s, (0, xM.validateArray)(e)), () => e.error())), e.ok(s);
  }
};
Lg.default = OM;
var Fg = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateProperties = e.error = void 0;
  const t = _e, r = se, n = he, i = Ar, s = rn, o = Cr;
=======
    const c = (0, Ar._)`typeof ${r} == "string"`;
    if (n.length >= o.opts.loopEnum) {
      let l;
      [a, l] = (0, EN.checkNullable)(e, c), t.if(l, f);
    } else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      a = (0, Ar.and)(c, (0, Ar.or)(...n.map((l) => (0, Ar._)`${r} === ${l}`))), i.nullable && (a = (0, Ar.or)((0, Ar._)`${r} === null`, a));
    }
    e.pass(a);
    function f() {
      t.forOf("v", s, (l) => t.if((0, Ar._)`${a} = ${r} === ${l}`, () => t.break()));
    }
  }
};
vd.default = xN;
var bd = {};
Object.defineProperty(bd, "__esModule", { value: !0 });
const wN = re, RN = fe, Rm = ae, $N = Ht, TN = dr, ON = qt, CN = {
  keyword: "elements",
  schemaType: "object",
  error: (0, ON.typeError)("array"),
  code(e) {
    (0, $N.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: s } = e;
    if ((0, wN.alwaysValidSchema)(s, n))
      return;
    const [i] = (0, TN.checkNullable)(e);
    t.if((0, Rm.not)(i), () => t.if((0, Rm._)`Array.isArray(${r})`, () => t.assign(i, (0, RN.validateArray)(e)), () => e.error())), e.ok(i);
  }
};
bd.default = CN;
var _d = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateProperties = e.error = void 0;
  const t = fe, r = re, n = ae, s = Ht, i = dr, o = qt;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var a;
  (function(l) {
    l.Additional = "additional", l.Missing = "missing";
  })(a || (a = {})), e.error = {
    message: (l) => {
<<<<<<< HEAD
      const { params: f } = l;
      return f.propError ? f.propError === a.Additional ? "must NOT have additional properties" : `must have property '${f.missingProperty}'` : (0, o.typeErrorMessage)(l, "object");
    },
    params: (l) => {
      const { params: f } = l;
      return f.propError ? f.propError === a.Additional ? (0, n._)`{error: ${f.propError}, additionalProperty: ${f.additionalProperty}}` : (0, n._)`{error: ${f.propError}, missingProperty: ${f.missingProperty}}` : (0, o.typeErrorParams)(l, "object");
=======
      const { params: d } = l;
      return d.propError ? d.propError === a.Additional ? "must NOT have additional properties" : `must have property '${d.missingProperty}'` : (0, o.typeErrorMessage)(l, "object");
    },
    params: (l) => {
      const { params: d } = l;
      return d.propError ? d.propError === a.Additional ? (0, n._)`{error: ${d.propError}, additionalProperty: ${d.additionalProperty}}` : (0, n._)`{error: ${d.propError}, missingProperty: ${d.missingProperty}}` : (0, o.typeErrorParams)(l, "object");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  };
  const c = {
    keyword: "properties",
    schemaType: "object",
    error: e.error,
<<<<<<< HEAD
    code: u
  };
  function u(l) {
    (0, i.checkMetadata)(l);
    const { gen: f, data: m, parentSchema: p, it: d } = l, { additionalProperties: h, nullable: _ } = p;
    if (d.jtdDiscriminator && _)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (C())
      throw new Error("JTD: properties and optionalProperties have common members");
    const [g, v] = V("properties"), [y, E] = V("optionalProperties");
    if (v.length === 0 && E.length === 0 && h)
      return;
    const [R, w] = d.jtdDiscriminator === void 0 ? (0, s.checkNullableObject)(l, m) : [f.let("valid", !1), !0];
    f.if(w, () => f.assign(R, !0).block(() => {
      b(v, "properties", !0), b(E, "optionalProperties"), h || H();
    })), l.pass(R);
    function C() {
      const $ = p.properties, x = p.optionalProperties;
      if (!($ && x))
        return !1;
      for (const A in $)
        if (Object.prototype.hasOwnProperty.call(x, A))
          return !0;
      return !1;
    }
    function V($) {
      const x = p[$], A = x ? (0, t.allSchemaProperties)(x) : [];
      if (d.jtdDiscriminator && A.some((D) => D === d.jtdDiscriminator))
        throw new Error(`JTD: discriminator tag used in ${$}`);
      const P = A.filter((D) => !(0, r.alwaysValidSchema)(d, x[D]));
      return [A, P];
    }
    function b($, x, A) {
      const P = f.var("valid");
      for (const I of $)
        f.if((0, t.propertyInData)(f, m, I, d.opts.ownProperties), () => F(I, x, P), () => D(I)), l.ok(P);
      function D(I) {
        A ? (f.assign(P, !1), l.error(!1, { propError: a.Missing, missingProperty: I }, { schemaPath: I })) : f.assign(P, !0);
      }
    }
    function F($, x, A) {
=======
    code: f
  };
  function f(l) {
    (0, s.checkMetadata)(l);
    const { gen: d, data: g, parentSchema: p, it: u } = l, { additionalProperties: h, nullable: b } = p;
    if (u.jtdDiscriminator && b)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (O())
      throw new Error("JTD: properties and optionalProperties have common members");
    const [m, v] = z("properties"), [y, _] = z("optionalProperties");
    if (v.length === 0 && _.length === 0 && h)
      return;
    const [R, E] = u.jtdDiscriminator === void 0 ? (0, i.checkNullableObject)(l, g) : [d.let("valid", !1), !0];
    d.if(E, () => d.assign(R, !0).block(() => {
      S(v, "properties", !0), S(_, "optionalProperties"), h || M();
    })), l.pass(R);
    function O() {
      const $ = p.properties, x = p.optionalProperties;
      if (!($ && x))
        return !1;
      for (const I in $)
        if (Object.prototype.hasOwnProperty.call(x, I))
          return !0;
      return !1;
    }
    function z($) {
      const x = p[$], I = x ? (0, t.allSchemaProperties)(x) : [];
      if (u.jtdDiscriminator && I.some((j) => j === u.jtdDiscriminator))
        throw new Error(`JTD: discriminator tag used in ${$}`);
      const T = I.filter((j) => !(0, r.alwaysValidSchema)(u, x[j]));
      return [I, T];
    }
    function S($, x, I) {
      const T = d.var("valid");
      for (const C of $)
        d.if((0, t.propertyInData)(d, g, C, u.opts.ownProperties), () => L(C, x, T), () => j(C)), l.ok(T);
      function j(C) {
        I ? (d.assign(T, !1), l.error(!1, { propError: a.Missing, missingProperty: C }, { schemaPath: C })) : d.assign(T, !0);
      }
    }
    function L($, x, I) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      l.subschema({
        keyword: x,
        schemaProp: $,
        dataProp: $
<<<<<<< HEAD
      }, A);
    }
    function H() {
      f.forIn("key", m, ($) => {
        const x = q($, g, "properties", d.jtdDiscriminator), A = q($, y, "optionalProperties"), P = x === !0 ? A : A === !0 ? x : (0, n.and)(x, A);
        f.if(P, () => {
          d.opts.removeAdditional ? f.code((0, n._)`delete ${m}[${$}]`) : (l.error(!1, { propError: a.Additional, additionalProperty: $ }, { instancePath: $, parentSchema: !0 }), d.opts.allErrors || f.break());
        });
      });
    }
    function q($, x, A, P) {
      let D;
      if (x.length > 8) {
        const I = (0, r.schemaRefOrVal)(d, p[A], A);
        D = (0, n.not)((0, t.isOwnProperty)(f, I, $)), P !== void 0 && (D = (0, n.and)(D, (0, n._)`${$} !== ${P}`));
      } else if (x.length || P !== void 0) {
        const I = P === void 0 ? x : [P].concat(x);
        D = (0, n.and)(...I.map((L) => (0, n._)`${$} !== ${L}`));
      } else
        D = !0;
      return D;
    }
  }
  e.validateProperties = u, e.default = c;
})(Fg);
var jg = {};
Object.defineProperty(jg, "__esModule", { value: !0 });
const v_ = Fg, PM = {
  keyword: "optionalProperties",
  schemaType: "object",
  error: v_.error,
  code(e) {
    e.parentSchema.properties || (0, v_.validateProperties)(e);
  }
};
jg.default = PM;
var Ug = {};
Object.defineProperty(Ug, "__esModule", { value: !0 });
const Ei = he, CM = Ar, AM = rn, __ = Cr, _l = za, IM = {
  message: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? r.discrError === _l.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in mapping` : (0, __.typeErrorMessage)(e, "object");
  },
  params: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? (0, Ei._)`{error: ${r.discrError}, tag: ${t}, tagValue: ${r.tag}}` : (0, __.typeErrorParams)(e, "object");
  }
}, NM = {
  keyword: "discriminator",
  schemaType: "string",
  implements: ["mapping"],
  error: IM,
  code(e) {
    (0, CM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: i } = e, [s, o] = (0, AM.checkNullableObject)(e, r);
    t.if(o), a(), t.elseIf((0, Ei.not)(s)), e.error(), t.endIf(), e.ok(s);
    function a() {
      const l = t.const("tag", (0, Ei._)`${r}${(0, Ei.getProperty)(n)}`);
      t.if((0, Ei._)`${l} === undefined`), e.error(!1, { discrError: _l.DiscrError.Tag, tag: l }), t.elseIf((0, Ei._)`typeof ${l} == "string"`), c(l), t.else(), e.error(!1, { discrError: _l.DiscrError.Tag, tag: l }, { instancePath: n }), t.endIf();
    }
    function c(l) {
      t.if(!1);
      for (const f in i.mapping)
        t.elseIf((0, Ei._)`${l} === ${f}`), t.assign(s, u(f));
      t.else(), e.error(!1, { discrError: _l.DiscrError.Mapping, tag: l }, { instancePath: n, schemaPath: "mapping", parentSchema: !0 }), t.endIf();
    }
    function u(l) {
      const f = t.name("valid");
=======
      }, I);
    }
    function M() {
      d.forIn("key", g, ($) => {
        const x = U($, m, "properties", u.jtdDiscriminator), I = U($, y, "optionalProperties"), T = x === !0 ? I : I === !0 ? x : (0, n.and)(x, I);
        d.if(T, () => {
          u.opts.removeAdditional ? d.code((0, n._)`delete ${g}[${$}]`) : (l.error(!1, { propError: a.Additional, additionalProperty: $ }, { instancePath: $, parentSchema: !0 }), u.opts.allErrors || d.break());
        });
      });
    }
    function U($, x, I, T) {
      let j;
      if (x.length > 8) {
        const C = (0, r.schemaRefOrVal)(u, p[I], I);
        j = (0, n.not)((0, t.isOwnProperty)(d, C, $)), T !== void 0 && (j = (0, n.and)(j, (0, n._)`${$} !== ${T}`));
      } else if (x.length || T !== void 0) {
        const C = T === void 0 ? x : [T].concat(x);
        j = (0, n.and)(...C.map((A) => (0, n._)`${$} !== ${A}`));
      } else
        j = !0;
      return j;
    }
  }
  e.validateProperties = f, e.default = c;
})(_d);
var Ed = {};
Object.defineProperty(Ed, "__esModule", { value: !0 });
const $m = _d, PN = {
  keyword: "optionalProperties",
  schemaType: "object",
  error: $m.error,
  code(e) {
    e.parentSchema.properties || (0, $m.validateProperties)(e);
  }
};
Ed.default = PN;
var Sd = {};
Object.defineProperty(Sd, "__esModule", { value: !0 });
const en = ae, IN = Ht, NN = dr, Tm = qt, _o = pi, AN = {
  message: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? r.discrError === _o.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in mapping` : (0, Tm.typeErrorMessage)(e, "object");
  },
  params: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? (0, en._)`{error: ${r.discrError}, tag: ${t}, tagValue: ${r.tag}}` : (0, Tm.typeErrorParams)(e, "object");
  }
}, kN = {
  keyword: "discriminator",
  schemaType: "string",
  implements: ["mapping"],
  error: AN,
  code(e) {
    (0, IN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: s } = e, [i, o] = (0, NN.checkNullableObject)(e, r);
    t.if(o), a(), t.elseIf((0, en.not)(i)), e.error(), t.endIf(), e.ok(i);
    function a() {
      const l = t.const("tag", (0, en._)`${r}${(0, en.getProperty)(n)}`);
      t.if((0, en._)`${l} === undefined`), e.error(!1, { discrError: _o.DiscrError.Tag, tag: l }), t.elseIf((0, en._)`typeof ${l} == "string"`), c(l), t.else(), e.error(!1, { discrError: _o.DiscrError.Tag, tag: l }, { instancePath: n }), t.endIf();
    }
    function c(l) {
      t.if(!1);
      for (const d in s.mapping)
        t.elseIf((0, en._)`${l} === ${d}`), t.assign(i, f(d));
      t.else(), e.error(!1, { discrError: _o.DiscrError.Mapping, tag: l }, { instancePath: n, schemaPath: "mapping", parentSchema: !0 }), t.endIf();
    }
    function f(l) {
      const d = t.name("valid");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return e.subschema({
        keyword: "mapping",
        schemaProp: l,
        jtdDiscriminator: n
<<<<<<< HEAD
      }, f), f;
    }
  }
};
Ug.default = NM;
var Mg = {};
Object.defineProperty(Mg, "__esModule", { value: !0 });
const b_ = se, Fc = he, kM = Ar, DM = rn, LM = Cr, FM = {
  keyword: "values",
  schemaType: "object",
  error: (0, LM.typeError)("object"),
  code(e) {
    (0, kM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: i } = e, [s, o] = (0, DM.checkNullableObject)(e, r);
    (0, b_.alwaysValidSchema)(i, n) ? t.if((0, Fc.not)((0, Fc.or)(o, s)), () => e.error()) : (t.if(o), t.assign(s, a()), t.elseIf((0, Fc.not)(s)), e.error(), t.endIf()), e.ok(s);
    function a() {
      const c = t.name("valid");
      if (i.allErrors) {
        const l = t.let("valid", !0);
        return u(() => t.assign(l, !1)), l;
      }
      return t.var(c, !0), u(() => t.break()), c;
      function u(l) {
        t.forIn("key", r, (f) => {
          e.subschema({
            keyword: "values",
            dataProp: f,
            dataPropType: b_.Type.Str
          }, c), t.if((0, Fc.not)(c), l);
=======
      }, d), d;
    }
  }
};
Sd.default = kN;
var xd = {};
Object.defineProperty(xd, "__esModule", { value: !0 });
const Om = re, Bi = ae, LN = Ht, jN = dr, DN = qt, FN = {
  keyword: "values",
  schemaType: "object",
  error: (0, DN.typeError)("object"),
  code(e) {
    (0, LN.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: s } = e, [i, o] = (0, jN.checkNullableObject)(e, r);
    (0, Om.alwaysValidSchema)(s, n) ? t.if((0, Bi.not)((0, Bi.or)(o, i)), () => e.error()) : (t.if(o), t.assign(i, a()), t.elseIf((0, Bi.not)(i)), e.error(), t.endIf()), e.ok(i);
    function a() {
      const c = t.name("valid");
      if (s.allErrors) {
        const l = t.let("valid", !0);
        return f(() => t.assign(l, !1)), l;
      }
      return t.var(c, !0), f(() => t.break()), c;
      function f(l) {
        t.forIn("key", r, (d) => {
          e.subschema({
            keyword: "values",
            dataProp: d,
            dataPropType: Om.Type.Str
          }, c), t.if((0, Bi.not)(c), l);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      }
    }
  }
};
<<<<<<< HEAD
Mg.default = FM;
var Hg = {};
Object.defineProperty(Hg, "__esModule", { value: !0 });
const jM = _e, UM = {
  keyword: "union",
  schemaType: "array",
  trackErrors: !0,
  code: jM.validateUnion,
  error: { message: "must match a schema in union" }
};
Hg.default = UM;
Object.defineProperty(Ig, "__esModule", { value: !0 });
const MM = Yi, HM = kg, qM = Dg, BM = Lg, zM = Fg, VM = jg, GM = Ug, WM = Mg, KM = Hg, YM = Ar, JM = [
  "definitions",
  MM.default,
  HM.default,
  qM.default,
  BM.default,
  zM.default,
  VM.default,
  GM.default,
  WM.default,
  KM.default,
  YM.default,
  { keyword: "additionalProperties", schemaType: "boolean" },
  { keyword: "nullable", schemaType: "boolean" }
];
Ig.default = JM;
var qg = {};
Object.defineProperty(qg, "__esModule", { value: !0 });
const Sn = (e) => {
=======
xd.default = FN;
var wd = {};
Object.defineProperty(wd, "__esModule", { value: !0 });
const MN = fe, zN = {
  keyword: "union",
  schemaType: "array",
  trackErrors: !0,
  code: MN.validateUnion,
  error: { message: "must match a schema in union" }
};
wd.default = zN;
Object.defineProperty(md, "__esModule", { value: !0 });
const UN = En, qN = gd, HN = vd, BN = bd, VN = _d, GN = Ed, WN = Sd, KN = xd, JN = wd, YN = Ht, XN = [
  "definitions",
  UN.default,
  qN.default,
  HN.default,
  BN.default,
  VN.default,
  GN.default,
  WN.default,
  KN.default,
  JN.default,
  YN.default,
  { keyword: "additionalProperties", schemaType: "boolean" },
  { keyword: "nullable", schemaType: "boolean" }
];
md.default = XN;
var Rd = {};
Object.defineProperty(Rd, "__esModule", { value: !0 });
const Rr = (e) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = {
    nullable: { type: "boolean" },
    metadata: {
      optionalProperties: {
        union: { elements: { ref: "schema" } }
      },
      additionalProperties: !0
    }
  };
  return e && (t.definitions = { values: { ref: "schema" } }), t;
<<<<<<< HEAD
}, XM = (e) => ({
  optionalProperties: Sn(e)
}), ZM = (e) => ({
  properties: {
    ref: { type: "string" }
  },
  optionalProperties: Sn(e)
}), QM = (e) => ({
=======
}, ZN = (e) => ({
  optionalProperties: Rr(e)
}), QN = (e) => ({
  properties: {
    ref: { type: "string" }
  },
  optionalProperties: Rr(e)
}), eA = (e) => ({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  properties: {
    type: {
      enum: [
        "boolean",
        "timestamp",
        "string",
        "float32",
        "float64",
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32"
      ]
    }
  },
<<<<<<< HEAD
  optionalProperties: Sn(e)
}), eH = (e) => ({
  properties: {
    enum: { elements: { type: "string" } }
  },
  optionalProperties: Sn(e)
}), tH = (e) => ({
  properties: {
    elements: { ref: "schema" }
  },
  optionalProperties: Sn(e)
}), u$ = (e) => ({
=======
  optionalProperties: Rr(e)
}), tA = (e) => ({
  properties: {
    enum: { elements: { type: "string" } }
  },
  optionalProperties: Rr(e)
}), rA = (e) => ({
  properties: {
    elements: { ref: "schema" }
  },
  optionalProperties: Rr(e)
}), Y0 = (e) => ({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  properties: {
    properties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    optionalProperties: { values: { ref: "schema" } },
    additionalProperties: { type: "boolean" },
<<<<<<< HEAD
    ...Sn(e)
  }
}), f$ = (e) => ({
=======
    ...Rr(e)
  }
}), X0 = (e) => ({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  properties: {
    optionalProperties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    additionalProperties: { type: "boolean" },
<<<<<<< HEAD
    ...Sn(e)
  }
}), rH = (e) => ({
=======
    ...Rr(e)
  }
}), nA = (e) => ({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  properties: {
    discriminator: { type: "string" },
    mapping: {
      values: {
        metadata: {
<<<<<<< HEAD
          union: [u$(!1), f$(!1)]
=======
          union: [Y0(!1), X0(!1)]
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
    }
  },
<<<<<<< HEAD
  optionalProperties: Sn(e)
}), nH = (e) => ({
  properties: {
    values: { ref: "schema" }
  },
  optionalProperties: Sn(e)
}), E_ = (e) => ({
  metadata: {
    union: [
      XM,
      ZM,
      QM,
      eH,
      tH,
      u$,
      f$,
      rH,
      nH
    ].map((t) => t(e))
  }
}), iH = {
  definitions: {
    schema: E_(!1)
  },
  ...E_(!0)
};
qg.default = iH;
var Bg = {}, Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.jtdForms = void 0;
Ga.jtdForms = [
=======
  optionalProperties: Rr(e)
}), sA = (e) => ({
  properties: {
    values: { ref: "schema" }
  },
  optionalProperties: Rr(e)
}), Cm = (e) => ({
  metadata: {
    union: [
      ZN,
      QN,
      eA,
      tA,
      rA,
      Y0,
      X0,
      nA,
      sA
    ].map((t) => t(e))
  }
}), iA = {
  definitions: {
    schema: Cm(!1)
  },
  ...Cm(!0)
};
Rd.default = iA;
var $d = {}, mi = {};
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.jtdForms = void 0;
mi.jtdForms = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "elements",
  "values",
  "discriminator",
  "properties",
  "optionalProperties",
  "enum",
  "type",
  "ref"
];
<<<<<<< HEAD
var zg = {};
Object.defineProperty(zg, "__esModule", { value: !0 });
const Ld = (
  // eslint-disable-next-line no-control-regex, no-misleading-character-class
  /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
), sH = {
=======
var Td = {};
Object.defineProperty(Td, "__esModule", { value: !0 });
const Zc = (
  // eslint-disable-next-line no-control-regex, no-misleading-character-class
  /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
), oA = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};
<<<<<<< HEAD
function d$(e) {
  return Ld.lastIndex = 0, '"' + (Ld.test(e) ? e.replace(Ld, (t) => {
    const r = sH[t];
    return typeof r == "string" ? r : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
  }) : e) + '"';
}
zg.default = d$;
d$.code = 'require("ajv/dist/runtime/quote").default';
Object.defineProperty(Bg, "__esModule", { value: !0 });
const oH = Ga, p$ = kt, Pe = he, aH = on, ze = _r, cH = _e, lH = Yi, uH = se, fH = zg, dH = {
  elements: hH,
  values: mH,
  discriminator: gH,
  properties: w_,
  optionalProperties: w_,
  enum: oa,
  type: yH,
  ref: _H
};
function h$(e, t) {
  const r = p$.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new Pe.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s }), a = o.scopeName("serialize"), c = {
=======
function Z0(e) {
  return Zc.lastIndex = 0, '"' + (Zc.test(e) ? e.replace(Zc, (t) => {
    const r = oA[t];
    return typeof r == "string" ? r : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
  }) : e) + '"';
}
Td.default = Z0;
Z0.code = 'require("ajv/dist/runtime/quote").default';
Object.defineProperty($d, "__esModule", { value: !0 });
const aA = mi, Q0 = dt, be = ae, cA = mr, Ae = jt, lA = fe, uA = En, fA = re, dA = Td, pA = {
  elements: mA,
  values: yA,
  discriminator: gA,
  properties: Pm,
  optionalProperties: Pm,
  enum: Bs,
  type: vA,
  ref: _A
};
function e_(e, t) {
  const r = Q0.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, o = new be.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }), a = o.scopeName("serialize"), c = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    self: this,
    gen: o,
    schema: e.schema,
    schemaEnv: e,
    definitions: t,
<<<<<<< HEAD
    data: ze.default.data
  };
  let u;
  try {
    this._compilations.add(e), e.serializeName = a, o.func(a, ze.default.data, !1, () => {
      o.let(ze.default.json, (0, Pe.str)``), Wa(c), o.return(ze.default.json);
    }), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    u = `${o.scopeRefs(ze.default.scope)}return ${l}`;
    const m = new Function(`${ze.default.scope}`, u)(this.scope.get());
    this.scope.value(a, { ref: m }), e.serialize = m;
  } catch (l) {
    throw u && this.logger.error("Error compiling serializer, function code:", u), delete e.serialize, delete e.serializeName, l;
=======
    data: Ae.default.data
  };
  let f;
  try {
    this._compilations.add(e), e.serializeName = a, o.func(a, Ae.default.data, !1, () => {
      o.let(Ae.default.json, (0, be.str)``), yi(c), o.return(Ae.default.json);
    }), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    f = `${o.scopeRefs(Ae.default.scope)}return ${l}`;
    const g = new Function(`${Ae.default.scope}`, f)(this.scope.get());
    this.scope.value(a, { ref: g }), e.serialize = g;
  } catch (l) {
    throw f && this.logger.error("Error compiling serializer, function code:", f), delete e.serialize, delete e.serializeName, l;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } finally {
    this._compilations.delete(e);
  }
  return e;
}
<<<<<<< HEAD
Bg.default = h$;
function Wa(e) {
  let t;
  for (const r of oH.jtdForms)
=======
$d.default = e_;
function yi(e) {
  let t;
  for (const r of aA.jtdForms)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (r in e.schema) {
      t = r;
      break;
    }
<<<<<<< HEAD
  pH(e, t ? dH[t] : EH);
}
function pH(e, t) {
  const { gen: r, schema: n, data: i } = e;
  if (!n.nullable)
    return t(e);
  r.if((0, Pe._)`${i} === undefined || ${i} === null`, () => r.add(ze.default.json, (0, Pe._)`"null"`), () => t(e));
}
function hH(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(ze.default.json, (0, Pe.str)`[`);
  const i = t.let("first", !0);
  t.forOf("el", n, (s) => {
    Vg(e, i), Wa({ ...e, schema: r.elements, data: s });
  }), t.add(ze.default.json, (0, Pe.str)`]`);
}
function mH(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(ze.default.json, (0, Pe.str)`{`);
  const i = t.let("first", !0);
  t.forIn("key", n, (s) => m$(e, s, r.values, i)), t.add(ze.default.json, (0, Pe.str)`}`);
}
function m$(e, t, r, n) {
  const { gen: i, data: s } = e;
  Vg(e, n), oa({ ...e, data: t }), i.add(ze.default.json, (0, Pe.str)`:`);
  const o = i.const("value", (0, Pe._)`${s}${(0, Pe.getProperty)(t)}`);
  Wa({ ...e, schema: r, data: o });
}
function gH(e) {
  const { gen: t, schema: r, data: n } = e, { discriminator: i } = r;
  t.add(ze.default.json, (0, Pe.str)`{${JSON.stringify(i)}:`);
  const s = t.const("tag", (0, Pe._)`${n}${(0, Pe.getProperty)(i)}`);
  oa({ ...e, data: s }), t.if(!1);
  for (const o in r.mapping) {
    t.elseIf((0, Pe._)`${s} === ${o}`);
    const a = r.mapping[o];
    g$({ ...e, schema: a }, i);
  }
  t.endIf(), t.add(ze.default.json, (0, Pe.str)`}`);
}
function w_(e) {
  const { gen: t } = e;
  t.add(ze.default.json, (0, Pe.str)`{`), g$(e), t.add(ze.default.json, (0, Pe.str)`}`);
}
function g$(e, t) {
  const { gen: r, schema: n, data: i } = e, { properties: s, optionalProperties: o } = n, a = m(s), c = m(o), u = p(a.concat(c));
  let l = !t, f;
  for (const g of a)
    l ? l = !1 : r.add(ze.default.json, (0, Pe.str)`,`), h(g, s[g], d(g));
  l && (f = r.let("first", !0));
  for (const g of c) {
    const v = d(g);
    r.if((0, Pe.and)((0, Pe._)`${v} !== undefined`, (0, cH.isOwnProperty)(r, i, g)), () => {
      Vg(e, f), h(g, o[g], v);
    });
  }
  n.additionalProperties && r.forIn("key", i, (g) => r.if(_(g, u), () => m$(e, g, {}, f)));
  function m(g) {
    return g ? Object.keys(g) : [];
  }
  function p(g) {
    if (t && g.push(t), new Set(g).size !== g.length)
      throw new Error("JTD: properties/optionalProperties/disciminator overlap");
    return g;
  }
  function d(g) {
    return r.const("value", (0, Pe._)`${i}${(0, Pe.getProperty)(g)}`);
  }
  function h(g, v, y) {
    r.add(ze.default.json, (0, Pe.str)`${JSON.stringify(g)}:`), Wa({ ...e, schema: v, data: y });
  }
  function _(g, v) {
    return v.length ? (0, Pe.and)(...v.map((y) => (0, Pe._)`${g} !== ${y}`)) : !0;
  }
}
function yH(e) {
  const { gen: t, schema: r, data: n } = e;
  switch (r.type) {
    case "boolean":
      t.add(ze.default.json, (0, Pe._)`${n} ? "true" : "false"`);
      break;
    case "string":
      oa(e);
      break;
    case "timestamp":
      t.if((0, Pe._)`${n} instanceof Date`, () => t.add(ze.default.json, (0, Pe._)`'"' + ${n}.toISOString() + '"'`), () => oa(e));
      break;
    default:
      vH(e);
  }
}
function oa({ gen: e, data: t }) {
  e.add(ze.default.json, (0, Pe._)`${(0, uH.useFunc)(e, fH.default)}(${t})`);
}
function vH({ gen: e, data: t }) {
  e.add(ze.default.json, (0, Pe._)`"" + ${t}`);
}
function _H(e) {
  const { gen: t, self: r, data: n, definitions: i, schema: s, schemaEnv: o } = e, { ref: a } = s, c = i[a];
  if (!c)
    throw new aH.default(r.opts.uriResolver, "", a, `No definition ${a}`);
  if (!(0, lH.hasRef)(c))
    return Wa({ ...e, schema: c });
  const { root: u } = o, l = h$.call(r, new p$.SchemaEnv({ schema: c, root: u }), i);
  t.add(ze.default.json, (0, Pe._)`${bH(t, l)}(${n})`);
}
function bH(e, t) {
  return t.serialize ? e.scopeValue("serialize", { ref: t.serialize }) : (0, Pe._)`${e.scopeValue("wrapper", { ref: t })}.serialize`;
}
function EH({ gen: e, data: t }) {
  e.add(ze.default.json, (0, Pe._)`JSON.stringify(${t})`);
}
function Vg({ gen: e }, t) {
  t ? e.if(t, () => e.assign(t, !1), () => e.add(ze.default.json, (0, Pe.str)`,`)) : e.add(ze.default.json, (0, Pe.str)`,`);
}
var Gg = {}, Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.parseJsonString = Kn.parseJsonNumber = Kn.parseJson = void 0;
const wH = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
function dn(e, t) {
  let r;
  dn.message = void 0;
  let n;
  t && (e = e.slice(t));
  try {
    return dn.position = t + e.length, JSON.parse(e);
  } catch (i) {
    if (n = wH.exec(i.message), !n) {
      dn.message = "unexpected end";
      return;
    }
    r = +n[1];
    const s = e[r];
    e = e.slice(0, r), dn.position = t + r;
    try {
      return JSON.parse(e);
    } catch {
      dn.message = `unexpected token ${s}`;
=======
  hA(e, t ? pA[t] : SA);
}
function hA(e, t) {
  const { gen: r, schema: n, data: s } = e;
  if (!n.nullable)
    return t(e);
  r.if((0, be._)`${s} === undefined || ${s} === null`, () => r.add(Ae.default.json, (0, be._)`"null"`), () => t(e));
}
function mA(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(Ae.default.json, (0, be.str)`[`);
  const s = t.let("first", !0);
  t.forOf("el", n, (i) => {
    Od(e, s), yi({ ...e, schema: r.elements, data: i });
  }), t.add(Ae.default.json, (0, be.str)`]`);
}
function yA(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(Ae.default.json, (0, be.str)`{`);
  const s = t.let("first", !0);
  t.forIn("key", n, (i) => t_(e, i, r.values, s)), t.add(Ae.default.json, (0, be.str)`}`);
}
function t_(e, t, r, n) {
  const { gen: s, data: i } = e;
  Od(e, n), Bs({ ...e, data: t }), s.add(Ae.default.json, (0, be.str)`:`);
  const o = s.const("value", (0, be._)`${i}${(0, be.getProperty)(t)}`);
  yi({ ...e, schema: r, data: o });
}
function gA(e) {
  const { gen: t, schema: r, data: n } = e, { discriminator: s } = r;
  t.add(Ae.default.json, (0, be.str)`{${JSON.stringify(s)}:`);
  const i = t.const("tag", (0, be._)`${n}${(0, be.getProperty)(s)}`);
  Bs({ ...e, data: i }), t.if(!1);
  for (const o in r.mapping) {
    t.elseIf((0, be._)`${i} === ${o}`);
    const a = r.mapping[o];
    r_({ ...e, schema: a }, s);
  }
  t.endIf(), t.add(Ae.default.json, (0, be.str)`}`);
}
function Pm(e) {
  const { gen: t } = e;
  t.add(Ae.default.json, (0, be.str)`{`), r_(e), t.add(Ae.default.json, (0, be.str)`}`);
}
function r_(e, t) {
  const { gen: r, schema: n, data: s } = e, { properties: i, optionalProperties: o } = n, a = g(i), c = g(o), f = p(a.concat(c));
  let l = !t, d;
  for (const m of a)
    l ? l = !1 : r.add(Ae.default.json, (0, be.str)`,`), h(m, i[m], u(m));
  l && (d = r.let("first", !0));
  for (const m of c) {
    const v = u(m);
    r.if((0, be.and)((0, be._)`${v} !== undefined`, (0, lA.isOwnProperty)(r, s, m)), () => {
      Od(e, d), h(m, o[m], v);
    });
  }
  n.additionalProperties && r.forIn("key", s, (m) => r.if(b(m, f), () => t_(e, m, {}, d)));
  function g(m) {
    return m ? Object.keys(m) : [];
  }
  function p(m) {
    if (t && m.push(t), new Set(m).size !== m.length)
      throw new Error("JTD: properties/optionalProperties/disciminator overlap");
    return m;
  }
  function u(m) {
    return r.const("value", (0, be._)`${s}${(0, be.getProperty)(m)}`);
  }
  function h(m, v, y) {
    r.add(Ae.default.json, (0, be.str)`${JSON.stringify(m)}:`), yi({ ...e, schema: v, data: y });
  }
  function b(m, v) {
    return v.length ? (0, be.and)(...v.map((y) => (0, be._)`${m} !== ${y}`)) : !0;
  }
}
function vA(e) {
  const { gen: t, schema: r, data: n } = e;
  switch (r.type) {
    case "boolean":
      t.add(Ae.default.json, (0, be._)`${n} ? "true" : "false"`);
      break;
    case "string":
      Bs(e);
      break;
    case "timestamp":
      t.if((0, be._)`${n} instanceof Date`, () => t.add(Ae.default.json, (0, be._)`'"' + ${n}.toISOString() + '"'`), () => Bs(e));
      break;
    default:
      bA(e);
  }
}
function Bs({ gen: e, data: t }) {
  e.add(Ae.default.json, (0, be._)`${(0, fA.useFunc)(e, dA.default)}(${t})`);
}
function bA({ gen: e, data: t }) {
  e.add(Ae.default.json, (0, be._)`"" + ${t}`);
}
function _A(e) {
  const { gen: t, self: r, data: n, definitions: s, schema: i, schemaEnv: o } = e, { ref: a } = i, c = s[a];
  if (!c)
    throw new cA.default(r.opts.uriResolver, "", a, `No definition ${a}`);
  if (!(0, uA.hasRef)(c))
    return yi({ ...e, schema: c });
  const { root: f } = o, l = e_.call(r, new Q0.SchemaEnv({ schema: c, root: f }), s);
  t.add(Ae.default.json, (0, be._)`${EA(t, l)}(${n})`);
}
function EA(e, t) {
  return t.serialize ? e.scopeValue("serialize", { ref: t.serialize }) : (0, be._)`${e.scopeValue("wrapper", { ref: t })}.serialize`;
}
function SA({ gen: e, data: t }) {
  e.add(Ae.default.json, (0, be._)`JSON.stringify(${t})`);
}
function Od({ gen: e }, t) {
  t ? e.if(t, () => e.assign(t, !1), () => e.add(Ae.default.json, (0, be.str)`,`)) : e.add(Ae.default.json, (0, be.str)`,`);
}
var Cd = {}, Ur = {};
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.parseJsonString = Ur.parseJsonNumber = Ur.parseJson = void 0;
const xA = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
function yr(e, t) {
  let r;
  yr.message = void 0;
  let n;
  t && (e = e.slice(t));
  try {
    return yr.position = t + e.length, JSON.parse(e);
  } catch (s) {
    if (n = xA.exec(s.message), !n) {
      yr.message = "unexpected end";
      return;
    }
    r = +n[1];
    const i = e[r];
    e = e.slice(0, r), yr.position = t + r;
    try {
      return JSON.parse(e);
    } catch {
      yr.message = `unexpected token ${i}`;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
  }
}
<<<<<<< HEAD
Kn.parseJson = dn;
dn.message = void 0;
dn.position = 0;
dn.code = 'require("ajv/dist/runtime/parseJson").parseJson';
function pn(e, t, r) {
  let n = "", i;
  if (pn.message = void 0, e[t] === "-" && (n += "-", t++), e[t] === "0")
    n += "0", t++;
  else if (!s(r)) {
=======
Ur.parseJson = yr;
yr.message = void 0;
yr.position = 0;
yr.code = 'require("ajv/dist/runtime/parseJson").parseJson';
function gr(e, t, r) {
  let n = "", s;
  if (gr.message = void 0, e[t] === "-" && (n += "-", t++), e[t] === "0")
    n += "0", t++;
  else if (!i(r)) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    o();
    return;
  }
  if (r)
<<<<<<< HEAD
    return pn.position = t, +n;
  if (e[t] === "." && (n += ".", t++, !s())) {
    o();
    return;
  }
  if (i = e[t], (i === "e" || i === "E") && (n += "e", t++, i = e[t], (i === "+" || i === "-") && (n += i, t++), !s())) {
    o();
    return;
  }
  return pn.position = t, +n;
  function s(a) {
    let c = !1;
    for (; i = e[t], i >= "0" && i <= "9" && (a === void 0 || a-- > 0); )
      c = !0, n += i, t++;
    return c;
  }
  function o() {
    pn.position = t, pn.message = t < e.length ? `unexpected token ${e[t]}` : "unexpected end";
  }
}
Kn.parseJsonNumber = pn;
pn.message = void 0;
pn.position = 0;
pn.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
const S_ = {
=======
    return gr.position = t, +n;
  if (e[t] === "." && (n += ".", t++, !i())) {
    o();
    return;
  }
  if (s = e[t], (s === "e" || s === "E") && (n += "e", t++, s = e[t], (s === "+" || s === "-") && (n += s, t++), !i())) {
    o();
    return;
  }
  return gr.position = t, +n;
  function i(a) {
    let c = !1;
    for (; s = e[t], s >= "0" && s <= "9" && (a === void 0 || a-- > 0); )
      c = !0, n += s, t++;
    return c;
  }
  function o() {
    gr.position = t, gr.message = t < e.length ? `unexpected token ${e[t]}` : "unexpected end";
  }
}
Ur.parseJsonNumber = gr;
gr.message = void 0;
gr.position = 0;
gr.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
const Im = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	",
  '"': '"',
  "/": "/",
  "\\": "\\"
<<<<<<< HEAD
}, SH = 97, xH = 48;
function Bn(e, t) {
  let r = "", n;
  for (Bn.message = void 0; n = e[t++], n !== '"'; )
    if (n === "\\")
      if (n = e[t], n in S_)
        r += S_[n], t++;
      else if (n === "u") {
        t++;
        let s = 4, o = 0;
        for (; s--; ) {
          if (o <<= 4, n = e[t], n === void 0) {
            i("unexpected end");
            return;
          }
          if (n = n.toLowerCase(), n >= "a" && n <= "f")
            o += n.charCodeAt(0) - SH + 10;
          else if (n >= "0" && n <= "9")
            o += n.charCodeAt(0) - xH;
          else {
            i(`unexpected token ${n}`);
=======
}, wA = 97, RA = 48;
function Fr(e, t) {
  let r = "", n;
  for (Fr.message = void 0; n = e[t++], n !== '"'; )
    if (n === "\\")
      if (n = e[t], n in Im)
        r += Im[n], t++;
      else if (n === "u") {
        t++;
        let i = 4, o = 0;
        for (; i--; ) {
          if (o <<= 4, n = e[t], n === void 0) {
            s("unexpected end");
            return;
          }
          if (n = n.toLowerCase(), n >= "a" && n <= "f")
            o += n.charCodeAt(0) - wA + 10;
          else if (n >= "0" && n <= "9")
            o += n.charCodeAt(0) - RA;
          else {
            s(`unexpected token ${n}`);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            return;
          }
          t++;
        }
        r += String.fromCharCode(o);
      } else {
<<<<<<< HEAD
        i(`unexpected token ${n}`);
        return;
      }
    else if (n === void 0) {
      i("unexpected end");
=======
        s(`unexpected token ${n}`);
        return;
      }
    else if (n === void 0) {
      s("unexpected end");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    } else if (n.charCodeAt(0) >= 32)
      r += n;
    else {
<<<<<<< HEAD
      i(`unexpected token ${n}`);
      return;
    }
  return Bn.position = t, r;
  function i(s) {
    Bn.position = t, Bn.message = s;
  }
}
Kn.parseJsonString = Bn;
Bn.message = void 0;
Bn.position = 0;
Bn.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
Object.defineProperty(Gg, "__esModule", { value: !0 });
const RH = Ga, y$ = kt, de = he, $H = on, Re = _r, TH = _e, OH = Yi, PH = kg, Wg = Kn, v$ = se, CH = zu, AH = {
  elements: DH,
  values: LH,
  discriminator: jH,
  properties: x_,
  optionalProperties: x_,
  enum: MH,
  type: UH,
  ref: HH
};
function _$(e, t) {
  const r = y$.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new de.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s }), a = o.scopeName("parse"), c = {
=======
      s(`unexpected token ${n}`);
      return;
    }
  return Fr.position = t, r;
  function s(i) {
    Fr.position = t, Fr.message = i;
  }
}
Ur.parseJsonString = Fr;
Fr.message = void 0;
Fr.position = 0;
Fr.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
Object.defineProperty(Cd, "__esModule", { value: !0 });
const $A = mi, n_ = dt, oe = ae, TA = mr, ye = jt, OA = fe, CA = En, PA = gd, Pd = Ur, s_ = re, IA = Ra, NA = {
  elements: jA,
  values: DA,
  discriminator: MA,
  properties: Nm,
  optionalProperties: Nm,
  enum: UA,
  type: zA,
  ref: qA
};
function i_(e, t) {
  const r = n_.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, o = new oe.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i }), a = o.scopeName("parse"), c = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    self: this,
    gen: o,
    schema: e.schema,
    schemaEnv: e,
    definitions: t,
<<<<<<< HEAD
    data: Re.default.data,
    parseName: a,
    char: o.name("c")
  };
  let u;
  try {
    this._compilations.add(e), e.parseName = a, IH(c), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    u = `${o.scopeRefs(Re.default.scope)}return ${l}`;
    const m = new Function(`${Re.default.scope}`, u)(this.scope.get());
    this.scope.value(a, { ref: m }), e.parse = m;
  } catch (l) {
    throw u && this.logger.error("Error compiling parser, function code:", u), delete e.parse, delete e.parseName, l;
=======
    data: ye.default.data,
    parseName: a,
    char: o.name("c")
  };
  let f;
  try {
    this._compilations.add(e), e.parseName = a, AA(c), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    f = `${o.scopeRefs(ye.default.scope)}return ${l}`;
    const g = new Function(`${ye.default.scope}`, f)(this.scope.get());
    this.scope.value(a, { ref: g }), e.parse = g;
  } catch (l) {
    throw f && this.logger.error("Error compiling parser, function code:", f), delete e.parse, delete e.parseName, l;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } finally {
    this._compilations.delete(e);
  }
  return e;
}
<<<<<<< HEAD
Gg.default = _$;
const $h = (0, de._)`undefined`;
function IH(e) {
  const { gen: t, parseName: r, char: n } = e;
  t.func(r, (0, de._)`${Re.default.json}, ${Re.default.jsonPos}, ${Re.default.jsonPart}`, !1, () => {
    t.let(Re.default.data), t.let(n), t.assign((0, de._)`${r}.message`, $h), t.assign((0, de._)`${r}.position`, $h), t.assign(Re.default.jsonPos, (0, de._)`${Re.default.jsonPos} || 0`), t.const(Re.default.jsonLen, (0, de._)`${Re.default.json}.length`), Vu(e), Xg(e), t.if(Re.default.jsonPart, () => {
      t.assign((0, de._)`${r}.position`, Re.default.jsonPos), t.return(Re.default.data);
    }), t.if((0, de._)`${Re.default.jsonPos} === ${Re.default.jsonLen}`, () => t.return(Re.default.data)), so(e);
  });
}
function Vu(e) {
  let t;
  for (const r of RH.jtdForms)
=======
Cd.default = i_;
const Eu = (0, oe._)`undefined`;
function AA(e) {
  const { gen: t, parseName: r, char: n } = e;
  t.func(r, (0, oe._)`${ye.default.json}, ${ye.default.jsonPos}, ${ye.default.jsonPart}`, !1, () => {
    t.let(ye.default.data), t.let(n), t.assign((0, oe._)`${r}.message`, Eu), t.assign((0, oe._)`${r}.position`, Eu), t.assign(ye.default.jsonPos, (0, oe._)`${ye.default.jsonPos} || 0`), t.const(ye.default.jsonLen, (0, oe._)`${ye.default.json}.length`), $a(e), kd(e), t.if(ye.default.jsonPart, () => {
      t.assign((0, oe._)`${r}.position`, ye.default.jsonPos), t.return(ye.default.data);
    }), t.if((0, oe._)`${ye.default.jsonPos} === ${ye.default.jsonLen}`, () => t.return(ye.default.data)), ls(e);
  });
}
function $a(e) {
  let t;
  for (const r of $A.jtdForms)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (r in e.schema) {
      t = r;
      break;
    }
<<<<<<< HEAD
  t ? kH(e, AH[t]) : Yg(e);
}
const NH = $_(!0, $_(!1, so));
function kH(e, t) {
  const { gen: r, schema: n, data: i } = e;
  if (!n.nullable)
    return t(e);
  aa(e, "null", t, () => r.assign(i, null));
}
function DH(e) {
  const { gen: t, schema: r, data: n } = e;
  nn(e, "[");
  const i = t.let("i", 0);
  t.assign(n, (0, de._)`[]`), Kg(e, "]", () => {
    const s = t.let("el");
    Vu({ ...e, schema: r.elements, data: s }), t.assign((0, de._)`${n}[${i}++]`, s);
  });
}
function LH(e) {
  const { gen: t, schema: r, data: n } = e;
  nn(e, "{"), t.assign(n, (0, de._)`{}`), Kg(e, "}", () => FH(e, r.values));
}
function Kg(e, t, r) {
  b$(e, t, r), nn(e, t);
}
function b$(e, t, r) {
  const { gen: n } = e;
  n.for((0, de._)`;${Re.default.jsonPos}<${Re.default.jsonLen} && ${Gu(1)}!==${t};`, () => {
    r(), aa(e, ",", () => n.break(), i);
  });
  function i() {
    aa(e, t, () => {
    }, so);
  }
}
function FH(e, t) {
  const { gen: r } = e, n = r.let("key");
  Mi({ ...e, data: n }), nn(e, ":"), w$(e, n, t);
}
function jH(e) {
  const { gen: t, data: r, schema: n } = e, { discriminator: i, mapping: s } = n;
  nn(e, "{"), t.assign(r, (0, de._)`{}`);
  const o = t.const("pos", Re.default.jsonPos), a = t.let("value"), c = t.let("tag");
  b$(e, "}", () => {
    const u = t.let("key");
    Mi({ ...e, data: u }), nn(e, ":"), t.if(
      (0, de._)`${u} === ${i}`,
      () => {
        Mi({ ...e, data: c }), t.assign((0, de._)`${r}[${u}]`, c), t.break();
      },
      () => Yg({ ...e, data: a })
      // can be discarded/skipped
    );
  }), t.assign(Re.default.jsonPos, o), t.if((0, de._)`${c} === undefined`), yn(e, (0, de.str)`discriminator tag not found`);
  for (const u in s)
    t.elseIf((0, de._)`${c} === ${u}`), E$({ ...e, schema: s[u] }, i);
  t.else(), yn(e, (0, de.str)`discriminator value not in schema`), t.endIf();
}
function x_(e) {
  const { gen: t, data: r } = e;
  nn(e, "{"), t.assign(r, (0, de._)`{}`), E$(e);
}
function E$(e, t) {
  const { gen: r, schema: n, data: i } = e, { properties: s, optionalProperties: o, additionalProperties: a } = n;
  if (Kg(e, "}", () => {
    const c = r.let("key");
    if (Mi({ ...e, data: c }), nn(e, ":"), r.if(!1), R_(e, c, s), R_(e, c, o), t) {
      r.elseIf((0, de._)`${c} === ${t}`);
      const u = r.let("tag");
      Mi({ ...e, data: u });
    }
    r.else(), a ? Yg({ ...e, data: (0, de._)`${i}[${c}]` }) : yn(e, (0, de.str)`property ${c} not allowed`), r.endIf();
  }), s) {
    const c = (0, TH.hasPropFunc)(r), u = (0, de.and)(...Object.keys(s).map((l) => (0, de._)`${c}.call(${i}, ${l})`));
    r.if((0, de.not)(u), () => yn(e, (0, de.str)`missing required properties`));
  }
}
function R_(e, t, r = {}) {
  const { gen: n } = e;
  for (const i in r)
    n.elseIf((0, de._)`${t} === ${i}`), w$(e, t, r[i]);
}
function w$(e, t, r) {
  Vu({ ...e, schema: r, data: (0, de._)`${e.data}[${t}]` });
}
function UH(e) {
  const { gen: t, schema: r, data: n, self: i } = e;
  switch (r.type) {
    case "boolean":
      NH(e);
      break;
    case "string":
      Mi(e);
      break;
    case "timestamp": {
      Mi(e);
      const s = (0, v$.useFunc)(t, CH.default), { allowDate: o, parseDate: a } = i.opts, c = o ? (0, de._)`!${s}(${n}, true)` : (0, de._)`!${s}(${n})`, u = a ? (0, de.or)(c, (0, de._)`(${n} = new Date(${n}), false)`, (0, de._)`isNaN(${n}.valueOf())`) : c;
      t.if(u, () => yn(e, (0, de.str)`invalid timestamp`));
=======
  t ? LA(e, NA[t]) : Nd(e);
}
const kA = km(!0, km(!1, ls));
function LA(e, t) {
  const { gen: r, schema: n, data: s } = e;
  if (!n.nullable)
    return t(e);
  Vs(e, "null", t, () => r.assign(s, null));
}
function jA(e) {
  const { gen: t, schema: r, data: n } = e;
  pr(e, "[");
  const s = t.let("i", 0);
  t.assign(n, (0, oe._)`[]`), Id(e, "]", () => {
    const i = t.let("el");
    $a({ ...e, schema: r.elements, data: i }), t.assign((0, oe._)`${n}[${s}++]`, i);
  });
}
function DA(e) {
  const { gen: t, schema: r, data: n } = e;
  pr(e, "{"), t.assign(n, (0, oe._)`{}`), Id(e, "}", () => FA(e, r.values));
}
function Id(e, t, r) {
  o_(e, t, r), pr(e, t);
}
function o_(e, t, r) {
  const { gen: n } = e;
  n.for((0, oe._)`;${ye.default.jsonPos}<${ye.default.jsonLen} && ${Ta(1)}!==${t};`, () => {
    r(), Vs(e, ",", () => n.break(), s);
  });
  function s() {
    Vs(e, t, () => {
    }, ls);
  }
}
function FA(e, t) {
  const { gen: r } = e, n = r.let("key");
  pn({ ...e, data: n }), pr(e, ":"), c_(e, n, t);
}
function MA(e) {
  const { gen: t, data: r, schema: n } = e, { discriminator: s, mapping: i } = n;
  pr(e, "{"), t.assign(r, (0, oe._)`{}`);
  const o = t.const("pos", ye.default.jsonPos), a = t.let("value"), c = t.let("tag");
  o_(e, "}", () => {
    const f = t.let("key");
    pn({ ...e, data: f }), pr(e, ":"), t.if(
      (0, oe._)`${f} === ${s}`,
      () => {
        pn({ ...e, data: c }), t.assign((0, oe._)`${r}[${f}]`, c), t.break();
      },
      () => Nd({ ...e, data: a })
      // can be discarded/skipped
    );
  }), t.assign(ye.default.jsonPos, o), t.if((0, oe._)`${c} === undefined`), Er(e, (0, oe.str)`discriminator tag not found`);
  for (const f in i)
    t.elseIf((0, oe._)`${c} === ${f}`), a_({ ...e, schema: i[f] }, s);
  t.else(), Er(e, (0, oe.str)`discriminator value not in schema`), t.endIf();
}
function Nm(e) {
  const { gen: t, data: r } = e;
  pr(e, "{"), t.assign(r, (0, oe._)`{}`), a_(e);
}
function a_(e, t) {
  const { gen: r, schema: n, data: s } = e, { properties: i, optionalProperties: o, additionalProperties: a } = n;
  if (Id(e, "}", () => {
    const c = r.let("key");
    if (pn({ ...e, data: c }), pr(e, ":"), r.if(!1), Am(e, c, i), Am(e, c, o), t) {
      r.elseIf((0, oe._)`${c} === ${t}`);
      const f = r.let("tag");
      pn({ ...e, data: f });
    }
    r.else(), a ? Nd({ ...e, data: (0, oe._)`${s}[${c}]` }) : Er(e, (0, oe.str)`property ${c} not allowed`), r.endIf();
  }), i) {
    const c = (0, OA.hasPropFunc)(r), f = (0, oe.and)(...Object.keys(i).map((l) => (0, oe._)`${c}.call(${s}, ${l})`));
    r.if((0, oe.not)(f), () => Er(e, (0, oe.str)`missing required properties`));
  }
}
function Am(e, t, r = {}) {
  const { gen: n } = e;
  for (const s in r)
    n.elseIf((0, oe._)`${t} === ${s}`), c_(e, t, r[s]);
}
function c_(e, t, r) {
  $a({ ...e, schema: r, data: (0, oe._)`${e.data}[${t}]` });
}
function zA(e) {
  const { gen: t, schema: r, data: n, self: s } = e;
  switch (r.type) {
    case "boolean":
      kA(e);
      break;
    case "string":
      pn(e);
      break;
    case "timestamp": {
      pn(e);
      const i = (0, s_.useFunc)(t, IA.default), { allowDate: o, parseDate: a } = s.opts, c = o ? (0, oe._)`!${i}(${n}, true)` : (0, oe._)`!${i}(${n})`, f = a ? (0, oe.or)(c, (0, oe._)`(${n} = new Date(${n}), false)`, (0, oe._)`isNaN(${n}.valueOf())`) : c;
      t.if(f, () => Er(e, (0, oe.str)`invalid timestamp`));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      break;
    }
    case "float32":
    case "float64":
<<<<<<< HEAD
      Fd(e);
      break;
    default: {
      const s = r.type;
      if (!i.opts.int32range && (s === "int32" || s === "uint32"))
        Fd(e, 16), s === "uint32" && t.if((0, de._)`${n} < 0`, () => yn(e, (0, de.str)`integer out of range`));
      else {
        const [o, a, c] = PH.intRange[s];
        Fd(e, c), t.if((0, de._)`${n} < ${o} || ${n} > ${a}`, () => yn(e, (0, de.str)`integer out of range`));
=======
      Qc(e);
      break;
    default: {
      const i = r.type;
      if (!s.opts.int32range && (i === "int32" || i === "uint32"))
        Qc(e, 16), i === "uint32" && t.if((0, oe._)`${n} < 0`, () => Er(e, (0, oe.str)`integer out of range`));
      else {
        const [o, a, c] = PA.intRange[i];
        Qc(e, c), t.if((0, oe._)`${n} < ${o} || ${n} > ${a}`, () => Er(e, (0, oe.str)`integer out of range`));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
}
<<<<<<< HEAD
function Mi(e) {
  nn(e, '"'), Jg(e, Wg.parseJsonString);
}
function MH(e) {
  const { gen: t, data: r, schema: n } = e, i = n.enum;
  nn(e, '"'), t.if(!1);
  for (const s of i) {
    const o = JSON.stringify(s).slice(1);
    t.elseIf((0, de._)`${Gu(o.length)} === ${o}`), t.assign(r, (0, de.str)`${s}`), t.add(Re.default.jsonPos, o.length);
  }
  t.else(), so(e), t.endIf();
}
function Fd(e, t) {
  const { gen: r } = e;
  Xg(e), r.if((0, de._)`"-0123456789".indexOf(${Gu(1)}) < 0`, () => so(e), () => Jg(e, Wg.parseJsonNumber, t));
}
function $_(e, t) {
  return (r) => {
    const { gen: n, data: i } = r;
    aa(r, `${e}`, () => t(r), () => n.assign(i, e));
  };
}
function HH(e) {
  const { gen: t, self: r, definitions: n, schema: i, schemaEnv: s } = e, { ref: o } = i, a = n[o];
  if (!a)
    throw new $H.default(r.opts.uriResolver, "", o, `No definition ${o}`);
  if (!(0, OH.hasRef)(a))
    return Vu({ ...e, schema: a });
  const { root: c } = s, u = _$.call(r, new y$.SchemaEnv({ schema: a, root: c }), n);
  S$(e, qH(t, u), !0);
}
function qH(e, t) {
  return t.parse ? e.scopeValue("parse", { ref: t.parse }) : (0, de._)`${e.scopeValue("wrapper", { ref: t })}.parse`;
}
function Yg(e) {
  Jg(e, Wg.parseJson);
}
function Jg(e, t, r) {
  S$(e, (0, v$.useFunc)(e.gen, t), r);
}
function S$(e, t, r) {
  const { gen: n, data: i } = e;
  n.assign(i, (0, de._)`${t}(${Re.default.json}, ${Re.default.jsonPos}${r ? (0, de._)`, ${r}` : de.nil})`), n.assign(Re.default.jsonPos, (0, de._)`${t}.position`), n.if((0, de._)`${i} === undefined`, () => yn(e, (0, de._)`${t}.message`));
}
function nn(e, t) {
  aa(e, t, so);
}
function aa(e, t, r, n) {
  const { gen: i } = e, s = t.length;
  Xg(e), i.if((0, de._)`${Gu(s)} === ${t}`, () => {
    i.add(Re.default.jsonPos, s), n == null || n(e);
  }, () => r(e));
}
function Xg({ gen: e, char: t }) {
  e.code((0, de._)`while((${t}=${Re.default.json}[${Re.default.jsonPos}],${t}===" "||${t}==="\\n"||${t}==="\\r"||${t}==="\\t"))${Re.default.jsonPos}++;`);
}
function Gu(e) {
  return e === 1 ? (0, de._)`${Re.default.json}[${Re.default.jsonPos}]` : (0, de._)`${Re.default.json}.slice(${Re.default.jsonPos}, ${Re.default.jsonPos}+${e})`;
}
function so(e) {
  yn(e, (0, de._)`"unexpected token " + ${Re.default.json}[${Re.default.jsonPos}]`);
}
function yn({ gen: e, parseName: t }, r) {
  e.assign((0, de._)`${t}.message`, r), e.assign((0, de._)`${t}.position`, Re.default.jsonPos), e.return($h);
}
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const r = km, n = Ig, i = qg, s = Bg, o = Gg, a = "JTD-meta-schema";
  class c extends r.default {
    constructor(d = {}) {
      super({
        ...d,
=======
function pn(e) {
  pr(e, '"'), Ad(e, Pd.parseJsonString);
}
function UA(e) {
  const { gen: t, data: r, schema: n } = e, s = n.enum;
  pr(e, '"'), t.if(!1);
  for (const i of s) {
    const o = JSON.stringify(i).slice(1);
    t.elseIf((0, oe._)`${Ta(o.length)} === ${o}`), t.assign(r, (0, oe.str)`${i}`), t.add(ye.default.jsonPos, o.length);
  }
  t.else(), ls(e), t.endIf();
}
function Qc(e, t) {
  const { gen: r } = e;
  kd(e), r.if((0, oe._)`"-0123456789".indexOf(${Ta(1)}) < 0`, () => ls(e), () => Ad(e, Pd.parseJsonNumber, t));
}
function km(e, t) {
  return (r) => {
    const { gen: n, data: s } = r;
    Vs(r, `${e}`, () => t(r), () => n.assign(s, e));
  };
}
function qA(e) {
  const { gen: t, self: r, definitions: n, schema: s, schemaEnv: i } = e, { ref: o } = s, a = n[o];
  if (!a)
    throw new TA.default(r.opts.uriResolver, "", o, `No definition ${o}`);
  if (!(0, CA.hasRef)(a))
    return $a({ ...e, schema: a });
  const { root: c } = i, f = i_.call(r, new n_.SchemaEnv({ schema: a, root: c }), n);
  l_(e, HA(t, f), !0);
}
function HA(e, t) {
  return t.parse ? e.scopeValue("parse", { ref: t.parse }) : (0, oe._)`${e.scopeValue("wrapper", { ref: t })}.parse`;
}
function Nd(e) {
  Ad(e, Pd.parseJson);
}
function Ad(e, t, r) {
  l_(e, (0, s_.useFunc)(e.gen, t), r);
}
function l_(e, t, r) {
  const { gen: n, data: s } = e;
  n.assign(s, (0, oe._)`${t}(${ye.default.json}, ${ye.default.jsonPos}${r ? (0, oe._)`, ${r}` : oe.nil})`), n.assign(ye.default.jsonPos, (0, oe._)`${t}.position`), n.if((0, oe._)`${s} === undefined`, () => Er(e, (0, oe._)`${t}.message`));
}
function pr(e, t) {
  Vs(e, t, ls);
}
function Vs(e, t, r, n) {
  const { gen: s } = e, i = t.length;
  kd(e), s.if((0, oe._)`${Ta(i)} === ${t}`, () => {
    s.add(ye.default.jsonPos, i), n == null || n(e);
  }, () => r(e));
}
function kd({ gen: e, char: t }) {
  e.code((0, oe._)`while((${t}=${ye.default.json}[${ye.default.jsonPos}],${t}===" "||${t}==="\\n"||${t}==="\\r"||${t}==="\\t"))${ye.default.jsonPos}++;`);
}
function Ta(e) {
  return e === 1 ? (0, oe._)`${ye.default.json}[${ye.default.jsonPos}]` : (0, oe._)`${ye.default.json}.slice(${ye.default.jsonPos}, ${ye.default.jsonPos}+${e})`;
}
function ls(e) {
  Er(e, (0, oe._)`"unexpected token " + ${ye.default.json}[${ye.default.jsonPos}]`);
}
function Er({ gen: e, parseName: t }, r) {
  e.assign((0, oe._)`${t}.message`, r), e.assign((0, oe._)`${t}.position`, ye.default.jsonPos), e.return(Eu);
}
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const r = gf, n = md, s = Rd, i = $d, o = Cd, a = "JTD-meta-schema";
  class c extends r.default {
    constructor(u = {}) {
      super({
        ...u,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        jtd: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), this.addVocabulary(n.default);
    }
    _addDefaultMetaSchema() {
<<<<<<< HEAD
      super._addDefaultMetaSchema(), this.opts.meta && this.addMetaSchema(i.default, a, !1);
=======
      super._addDefaultMetaSchema(), this.opts.meta && this.addMetaSchema(s.default, a, !1);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
<<<<<<< HEAD
    compileSerializer(d) {
      const h = this._addSchema(d);
      return h.serialize || this._compileSerializer(h);
    }
    compileParser(d) {
      const h = this._addSchema(d);
      return h.parse || this._compileParser(h);
    }
    _compileSerializer(d) {
      if (s.default.call(this, d, d.schema.definitions || {}), !d.serialize)
        throw new Error("ajv implementation error");
      return d.serialize;
    }
    _compileParser(d) {
      if (o.default.call(this, d, d.schema.definitions || {}), !d.parse)
        throw new Error("ajv implementation error");
      return d.parse;
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var u = Pr;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return u.KeywordCxt;
  } });
  var l = he;
=======
    compileSerializer(u) {
      const h = this._addSchema(u);
      return h.serialize || this._compileSerializer(h);
    }
    compileParser(u) {
      const h = this._addSchema(u);
      return h.parse || this._compileParser(h);
    }
    _compileSerializer(u) {
      if (i.default.call(this, u, u.schema.definitions || {}), !u.serialize)
        throw new Error("ajv implementation error");
      return u.serialize;
    }
    _compileParser(u) {
      if (o.default.call(this, u, u.schema.definitions || {}), !u.parse)
        throw new Error("ajv implementation error");
      return u.parse;
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var f = Ut;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return f.KeywordCxt;
  } });
  var l = ae;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
<<<<<<< HEAD
  var f = to;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var m = on;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return m.default;
  } });
})(Rh, Rh.exports);
var x$ = Rh.exports;
const BH = Ym;
var R$ = Object.freeze({
  coerceTypes: "array",
  useDefaults: !0,
  removeAdditional: !0,
  uriResolver: BH,
=======
  var d = is;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return d.default;
  } });
  var g = mr;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return g.default;
  } });
})(_u, _u.exports);
var u_ = _u.exports;
const BA = Nf;
var f_ = Object.freeze({
  coerceTypes: "array",
  useDefaults: !0,
  removeAdditional: !0,
  uriResolver: BA,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  addUsedSchema: !1,
  // Explicitly set allErrors to `false`.
  // When set to `true`, a DoS attack is possible.
  allErrors: !1
});
<<<<<<< HEAD
const zH = Tg.default, VH = x$, T_ = R$;
class GH {
  constructor(t, r) {
    var s;
    r.mode === "JTD" ? this.ajv = new VH(Object.assign({}, T_, r.customOptions)) : this.ajv = new zH(Object.assign({}, T_, r.customOptions));
=======
const VA = ud.default, GA = u_, Lm = f_;
class WA {
  constructor(t, r) {
    var i;
    r.mode === "JTD" ? this.ajv = new GA(Object.assign({}, Lm, r.customOptions)) : this.ajv = new VA(Object.assign({}, Lm, r.customOptions));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    let n = !0;
    if (r.plugins && r.plugins.length > 0)
      for (const o of r.plugins)
        Array.isArray(o) ? (n = n && o[0].name !== "formatsPlugin", o[0](this.ajv, o[1])) : (n = n && o.name !== "formatsPlugin", o(this.ajv));
<<<<<<< HEAD
    n && VR()(this.ajv), (s = r.onCreate) == null || s.call(r, this.ajv);
    const i = Object.values(t);
    for (const o of i)
=======
    n && I0()(this.ajv), (i = r.onCreate) == null || i.call(r, this.ajv);
    const s = Object.values(t);
    for (const o of s)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      this.ajv.addSchema(o);
  }
  buildValidatorFunction({
    schema: t
    /*, method, url, httpPart */
  }) {
    if (t.$id) {
      const r = this.ajv.getSchema(t.$id);
      if (r)
        return r;
    }
    return this.ajv.compile(t);
  }
}
<<<<<<< HEAD
var WH = GH;
const KH = x$, YH = R$;
class JH {
  constructor(t, r) {
    this.ajv = new KH(Object.assign({}, YH, r));
=======
var KA = WA;
const JA = u_, YA = f_;
class XA {
  constructor(t, r) {
    this.ajv = new JA(Object.assign({}, YA, r));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  buildSerializerFunction({
    schema: t
    /*, method, url, httpStatus */
  }) {
    return this.ajv.compileSerializer(t);
  }
}
<<<<<<< HEAD
var XH = JH, Th = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = Ul, n = Hs;
  function i(s, o) {
    if (!s.opts.code.source)
      throw new Error("moduleCode: ajv instance must have code.source option");
    const { _n: a } = s.scope.opts;
    return typeof o == "function" ? u(o.source) : o !== void 0 ? l(o, c) : l(s.schemas, (m) => m.meta ? void 0 : s.compile(m.schema));
    function c(m) {
      const p = s.getSchema(m);
      if (!p)
        throw new Error(`moduleCode: no schema with id ${m}`);
      return p;
    }
    function u(m) {
      const p = {}, d = m == null ? void 0 : m.validateName, h = f(p, m);
      return s.opts.code.esm ? `"use strict";${a}export const validate = ${d};${a}export default ${d};${a}${h}` : `"use strict";${a}module.exports = ${d};${a}module.exports.default = ${d};${a}${h}`;
    }
    function l(m, p) {
      var d;
      const h = {};
      let _ = (0, n._)`"use strict";`;
      for (const g in m) {
        const v = p(m[g]);
        if (v) {
          const y = f(h, v.source), E = s.opts.code.esm ? (0, n._)`export const ${(0, n.getEsmExportName)(g)}` : (0, n._)`exports${(0, n.getProperty)(g)}`;
          _ = (0, n._)`${_}${a}${E} = ${(d = v.source) === null || d === void 0 ? void 0 : d.validateName};${a}${y}`;
        }
      }
      return `${_}`;
    }
    function f(m, p) {
      if (!p)
        throw new Error('moduleCode: function does not have "source" property');
      if (g(p.validateName) === r.UsedValueState.Completed)
        return n.nil;
      v(p.validateName, r.UsedValueState.Started);
      const d = s.scope.scopeCode(p.scopeValues, m, _), h = new n._Code(`${d}${a}${p.validateCode}`);
      return p.evaluated ? (0, n._)`${h}${p.validateName}.evaluated = ${p.evaluated};${a}` : h;
      function _(y) {
        var E;
        const R = (E = y.value) === null || E === void 0 ? void 0 : E.ref;
        if (y.prefix === "validate" && typeof R == "function")
          return f(m, R.source);
        if ((y.prefix === "root" || y.prefix === "wrapper") && typeof R == "object") {
          const { validate: w, validateName: C } = R;
          if (!C)
            throw new Error("ajv internal error");
          const V = s.opts.code.es5 ? r.varKinds.var : r.varKinds.const, b = (0, n._)`${V} ${y} = {validate: ${C}};`;
          if (g(C) === r.UsedValueState.Started)
            return b;
          const F = f(m, w == null ? void 0 : w.source);
          return (0, n._)`${b}${a}${F}`;
        }
      }
      function g(y) {
        var E;
        return (E = m[y.prefix]) === null || E === void 0 ? void 0 : E.get(y);
      }
      function v(y, E) {
        const { prefix: R } = y;
        (m[R] = m[R] || /* @__PURE__ */ new Map()).set(y, E);
      }
    }
  }
  e.exports = t = i, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = i;
})(Th, Th.exports);
var ZH = Th.exports, jd, O_;
function QH() {
  if (O_) return jd;
  O_ = 1;
  const e = $$(), t = ZH.default;
=======
var ZA = XA, Su = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = jo, n = Jn;
  function s(i, o) {
    if (!i.opts.code.source)
      throw new Error("moduleCode: ajv instance must have code.source option");
    const { _n: a } = i.scope.opts;
    return typeof o == "function" ? f(o.source) : o !== void 0 ? l(o, c) : l(i.schemas, (g) => g.meta ? void 0 : i.compile(g.schema));
    function c(g) {
      const p = i.getSchema(g);
      if (!p)
        throw new Error(`moduleCode: no schema with id ${g}`);
      return p;
    }
    function f(g) {
      const p = {}, u = g == null ? void 0 : g.validateName, h = d(p, g);
      return i.opts.code.esm ? `"use strict";${a}export const validate = ${u};${a}export default ${u};${a}${h}` : `"use strict";${a}module.exports = ${u};${a}module.exports.default = ${u};${a}${h}`;
    }
    function l(g, p) {
      var u;
      const h = {};
      let b = (0, n._)`"use strict";`;
      for (const m in g) {
        const v = p(g[m]);
        if (v) {
          const y = d(h, v.source), _ = i.opts.code.esm ? (0, n._)`export const ${(0, n.getEsmExportName)(m)}` : (0, n._)`exports${(0, n.getProperty)(m)}`;
          b = (0, n._)`${b}${a}${_} = ${(u = v.source) === null || u === void 0 ? void 0 : u.validateName};${a}${y}`;
        }
      }
      return `${b}`;
    }
    function d(g, p) {
      if (!p)
        throw new Error('moduleCode: function does not have "source" property');
      if (m(p.validateName) === r.UsedValueState.Completed)
        return n.nil;
      v(p.validateName, r.UsedValueState.Started);
      const u = i.scope.scopeCode(p.scopeValues, g, b), h = new n._Code(`${u}${a}${p.validateCode}`);
      return p.evaluated ? (0, n._)`${h}${p.validateName}.evaluated = ${p.evaluated};${a}` : h;
      function b(y) {
        var _;
        const R = (_ = y.value) === null || _ === void 0 ? void 0 : _.ref;
        if (y.prefix === "validate" && typeof R == "function")
          return d(g, R.source);
        if ((y.prefix === "root" || y.prefix === "wrapper") && typeof R == "object") {
          const { validate: E, validateName: O } = R;
          if (!O)
            throw new Error("ajv internal error");
          const z = i.opts.code.es5 ? r.varKinds.var : r.varKinds.const, S = (0, n._)`${z} ${y} = {validate: ${O}};`;
          if (m(O) === r.UsedValueState.Started)
            return S;
          const L = d(g, E == null ? void 0 : E.source);
          return (0, n._)`${S}${a}${L}`;
        }
      }
      function m(y) {
        var _;
        return (_ = g[y.prefix]) === null || _ === void 0 ? void 0 : _.get(y);
      }
      function v(y, _) {
        const { prefix: R } = y;
        (g[R] = g[R] || /* @__PURE__ */ new Map()).set(y, _);
      }
    }
  }
  e.exports = t = s, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
})(Su, Su.exports);
var QA = Su.exports, el, jm;
function ek() {
  if (jm) return el;
  jm = 1;
  const e = d_(), t = QA.default;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  function r(n = { readMode: !0 }) {
    if (n.readMode === !0 && !n.restoreFunction)
      throw new Error("You must provide a restoreFunction options when readMode ON");
    if (n.readMode !== !0 && !n.storeFunction)
      throw new Error("You must provide a storeFunction options when readMode OFF");
    if (n.readMode === !0)
      return function() {
        return function(o) {
          return n.restoreFunction(o);
        };
      };
<<<<<<< HEAD
    const i = e();
    return function(o, a = {}) {
      (!a.customOptions || !a.customOptions.code) && (a.customOptions = Object.assign({}, a.customOptions, { code: { source: !0 } }));
      const c = i(o, a);
      return function(u) {
        const l = c(u), f = t(c[e.AjvReference].ajv, l);
        return n.storeFunction(u, f), l;
      };
    };
  }
  return jd = r, jd;
}
var P_;
function $$() {
  if (P_) return pi.exports;
  P_ = 1;
  const e = Symbol.for("fastify.ajv-compiler.reference"), t = WH, r = XH;
  function n(s) {
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    return s && s.jtdSerializer === !0 ? function(u, l) {
      const f = i({}, l);
      if (a.has(f))
        return a.get(f);
      const m = new r(u, l), p = m.buildSerializerFunction.bind(m);
      return a.set(f, p), p;
    } : function(u, l) {
      const f = i(u, l.customOptions);
      if (o.has(f))
        return o.get(f);
      const m = new t(u, l), p = m.buildValidatorFunction.bind(m);
      return o.set(f, p), l.customOptions.code !== void 0 && (p[e] = m), p;
    };
  }
  function i(s, o) {
    const a = JSON.stringify(s), c = JSON.stringify(o);
    return `${a}${c}`;
  }
  return pi.exports = n, pi.exports.default = n, pi.exports.AjvCompiler = n, pi.exports.AjvReference = e, pi.exports.StandaloneValidator = QH(), pi.exports;
}
const { buildSchemas: eq } = Pu, tq = sM, rq = $$();
function nq(e, t) {
  var i, s;
  if (e)
    return new Kl(e, t);
=======
    const s = e();
    return function(o, a = {}) {
      (!a.customOptions || !a.customOptions.code) && (a.customOptions = Object.assign({}, a.customOptions, { code: { source: !0 } }));
      const c = s(o, a);
      return function(f) {
        const l = c(f), d = t(c[e.AjvReference].ajv, l);
        return n.storeFunction(f, d), l;
      };
    };
  }
  return el = r, el;
}
var Dm;
function d_() {
  if (Dm) return Wr.exports;
  Dm = 1;
  const e = Symbol.for("fastify.ajv-compiler.reference"), t = KA, r = ZA;
  function n(i) {
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    return i && i.jtdSerializer === !0 ? function(f, l) {
      const d = s({}, l);
      if (a.has(d))
        return a.get(d);
      const g = new r(f, l), p = g.buildSerializerFunction.bind(g);
      return a.set(d, p), p;
    } : function(f, l) {
      const d = s(f, l.customOptions);
      if (o.has(d))
        return o.get(d);
      const g = new t(f, l), p = g.buildValidatorFunction.bind(g);
      return o.set(d, p), l.customOptions.code !== void 0 && (p[e] = g), p;
    };
  }
  function s(i, o) {
    const a = JSON.stringify(i), c = JSON.stringify(o);
    return `${a}${c}`;
  }
  return Wr.exports = n, Wr.exports.default = n, Wr.exports.AjvCompiler = n, Wr.exports.AjvReference = e, Wr.exports.StandaloneValidator = ek(), Wr.exports;
}
const { buildSchemas: tk } = ua, rk = oN, nk = d_();
function sk(e, t) {
  var s, i;
  if (e)
    return new Vo(e, t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = Object.assign({
    buildValidator: null,
    buildSerializer: null
  }, t == null ? void 0 : t.compilersFactory);
<<<<<<< HEAD
  r.buildValidator || (r.buildValidator = rq()), r.buildSerializer || (r.buildSerializer = tq());
  const n = {
    bucket: t && t.bucket || eq,
    compilersFactory: r,
    isCustomValidatorCompiler: typeof ((i = t == null ? void 0 : t.compilersFactory) == null ? void 0 : i.buildValidator) == "function",
    isCustomSerializerCompiler: typeof ((s = t == null ? void 0 : t.compilersFactory) == null ? void 0 : s.buildValidator) == "function"
  };
  return new Kl(void 0, n);
}
let Kl = class {
=======
  r.buildValidator || (r.buildValidator = nk()), r.buildSerializer || (r.buildSerializer = rk());
  const n = {
    bucket: t && t.bucket || tk,
    compilersFactory: r,
    isCustomValidatorCompiler: typeof ((s = t == null ? void 0 : t.compilersFactory) == null ? void 0 : s.buildValidator) == "function",
    isCustomSerializerCompiler: typeof ((i = t == null ? void 0 : t.compilersFactory) == null ? void 0 : i.buildValidator) == "function"
  };
  return new Vo(void 0, n);
}
let Vo = class {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t, r) {
    this.opts = r || (t == null ? void 0 : t.opts), this.addedSchemas = !1, this.compilersFactory = this.opts.compilersFactory, t ? (this.schemaBucket = this.opts.bucket(t.getSchemas()), this.validatorCompiler = t.getValidatorCompiler(), this.serializerCompiler = t.getSerializerCompiler(), this.isCustomValidatorCompiler = t.isCustomValidatorCompiler, this.isCustomSerializerCompiler = t.isCustomSerializerCompiler, this.parent = t) : (this.schemaBucket = this.opts.bucket(), this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || !1, this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || !1);
  }
  // Bucket interface
  add(t) {
    return this.addedSchemas = !0, this.schemaBucket.add(t);
  }
  getSchema(t) {
    return this.schemaBucket.getSchema(t);
  }
  getSchemas() {
    return this.schemaBucket.getSchemas();
  }
  setValidatorCompiler(t) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildValidator: () => t }
    ), this.validatorCompiler = t, this.isCustomValidatorCompiler = !0;
  }
  setSerializerCompiler(t) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildSerializer: () => t }
    ), this.serializerCompiler = t, this.isCustomSerializerCompiler = !0;
  }
  getValidatorCompiler() {
    return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
  }
  getSerializerCompiler() {
    return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
  }
  getSerializerBuilder() {
    return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
  }
  getValidatorBuilder() {
    return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
  }
  /**
   * This method will be called when a validator must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupValidator(t) {
    this.validatorCompiler !== void 0 && !this.addedSchemas || (this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), t.ajv));
  }
  /**
   * This method will be called when a serializer must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupSerializer(t) {
    this.serializerCompiler !== void 0 && !this.addedSchemas || (this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), t.serializerOpts));
  }
};
<<<<<<< HEAD
Kl.buildSchemaController = nq;
var T$ = Kl, O$ = { exports: {} }, Oh = { exports: {} };
const iq = "2.0.0", P$ = 256, sq = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, oq = 16, aq = P$ - 6, cq = [
=======
Vo.buildSchemaController = sk;
var p_ = Vo, h_ = { exports: {} }, xu = { exports: {} };
const ik = "2.0.0", m_ = 256, ok = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, ak = 16, ck = m_ - 6, lk = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
<<<<<<< HEAD
var Wu = {
  MAX_LENGTH: P$,
  MAX_SAFE_COMPONENT_LENGTH: oq,
  MAX_SAFE_BUILD_LENGTH: aq,
  MAX_SAFE_INTEGER: sq,
  RELEASE_TYPES: cq,
  SEMVER_SPEC_VERSION: iq,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const lq = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Ku = lq;
=======
var Oa = {
  MAX_LENGTH: m_,
  MAX_SAFE_COMPONENT_LENGTH: ak,
  MAX_SAFE_BUILD_LENGTH: ck,
  MAX_SAFE_INTEGER: ok,
  RELEASE_TYPES: lk,
  SEMVER_SPEC_VERSION: ik,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const uk = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Ca = uk;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: n,
<<<<<<< HEAD
    MAX_LENGTH: i
  } = Wu, s = Ku;
  t = e.exports = {};
  const o = t.re = [], a = t.safeRe = [], c = t.src = [], u = t.safeSrc = [], l = t.t = {};
  let f = 0;
  const m = "[a-zA-Z0-9-]", p = [
    ["\\s", 1],
    ["\\d", i],
    [m, n]
  ], d = (_) => {
    for (const [g, v] of p)
      _ = _.split(`${g}*`).join(`${g}{0,${v}}`).split(`${g}+`).join(`${g}{1,${v}}`);
    return _;
  }, h = (_, g, v) => {
    const y = d(g), E = f++;
    s(_, E, g), l[_] = E, c[E] = g, u[E] = y, o[E] = new RegExp(g, v ? "g" : void 0), a[E] = new RegExp(y, v ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${m}*`), h("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${m}+`), h("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), h("FULL", `^${c[l.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), h("LOOSE", `^${c[l.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), h("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), h("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), h("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), h("COERCERTL", c[l.COERCE], !0), h("COERCERTLFULL", c[l.COERCEFULL], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Oh, Oh.exports);
var Ka = Oh.exports;
const uq = Object.freeze({ loose: !0 }), fq = Object.freeze({}), dq = (e) => e ? typeof e != "object" ? uq : e : fq;
var Zg = dq;
const C_ = /^[0-9]+$/, C$ = (e, t) => {
  const r = C_.test(e), n = C_.test(t);
  return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
}, pq = (e, t) => C$(t, e);
var A$ = {
  compareIdentifiers: C$,
  rcompareIdentifiers: pq
};
const jc = Ku, { MAX_LENGTH: A_, MAX_SAFE_INTEGER: Uc } = Wu, { safeRe: I_, safeSrc: N_, t: Mc } = Ka, hq = Zg, { compareIdentifiers: is } = A$;
let mq = class Jr {
  constructor(t, r) {
    if (r = hq(r), t instanceof Jr) {
=======
    MAX_LENGTH: s
  } = Oa, i = Ca;
  t = e.exports = {};
  const o = t.re = [], a = t.safeRe = [], c = t.src = [], f = t.safeSrc = [], l = t.t = {};
  let d = 0;
  const g = "[a-zA-Z0-9-]", p = [
    ["\\s", 1],
    ["\\d", s],
    [g, n]
  ], u = (b) => {
    for (const [m, v] of p)
      b = b.split(`${m}*`).join(`${m}{0,${v}}`).split(`${m}+`).join(`${m}{1,${v}}`);
    return b;
  }, h = (b, m, v) => {
    const y = u(m), _ = d++;
    i(b, _, m), l[b] = _, c[_] = m, f[_] = y, o[_] = new RegExp(m, v ? "g" : void 0), a[_] = new RegExp(y, v ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${g}*`), h("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${g}+`), h("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), h("FULL", `^${c[l.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), h("LOOSE", `^${c[l.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), h("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), h("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), h("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), h("COERCERTL", c[l.COERCE], !0), h("COERCERTLFULL", c[l.COERCEFULL], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(xu, xu.exports);
var gi = xu.exports;
const fk = Object.freeze({ loose: !0 }), dk = Object.freeze({}), pk = (e) => e ? typeof e != "object" ? fk : e : dk;
var Ld = pk;
const Fm = /^[0-9]+$/, y_ = (e, t) => {
  const r = Fm.test(e), n = Fm.test(t);
  return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
}, hk = (e, t) => y_(t, e);
var g_ = {
  compareIdentifiers: y_,
  rcompareIdentifiers: hk
};
const Vi = Ca, { MAX_LENGTH: Mm, MAX_SAFE_INTEGER: Gi } = Oa, { safeRe: zm, safeSrc: Um, t: Wi } = gi, mk = Ld, { compareIdentifiers: Tn } = g_;
let yk = class or {
  constructor(t, r) {
    if (r = mk(r), t instanceof or) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
<<<<<<< HEAD
    if (t.length > A_)
      throw new TypeError(
        `version is longer than ${A_} characters`
      );
    jc("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = t.trim().match(r.loose ? I_[Mc.LOOSE] : I_[Mc.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Uc || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Uc || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Uc || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const s = +i;
        if (s >= 0 && s < Uc)
          return s;
      }
      return i;
=======
    if (t.length > Mm)
      throw new TypeError(
        `version is longer than ${Mm} characters`
      );
    Vi("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = t.trim().match(r.loose ? zm[Wi.LOOSE] : zm[Wi.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Gi || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Gi || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Gi || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const i = +s;
        if (i >= 0 && i < Gi)
          return i;
      }
      return s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
<<<<<<< HEAD
    if (jc("SemVer.compare", this.version, this.options, t), !(t instanceof Jr)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new Jr(t, this.options);
=======
    if (Vi("SemVer.compare", this.version, this.options, t), !(t instanceof or)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new or(t, this.options);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
<<<<<<< HEAD
    return t instanceof Jr || (t = new Jr(t, this.options)), is(this.major, t.major) || is(this.minor, t.minor) || is(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof Jr || (t = new Jr(t, this.options)), this.prerelease.length && !t.prerelease.length)
=======
    return t instanceof or || (t = new or(t, this.options)), Tn(this.major, t.major) || Tn(this.minor, t.minor) || Tn(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof or || (t = new or(t, this.options)), this.prerelease.length && !t.prerelease.length)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
<<<<<<< HEAD
      const n = this.prerelease[r], i = t.prerelease[r];
      if (jc("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return is(n, i);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof Jr || (t = new Jr(t, this.options));
    let r = 0;
    do {
      const n = this.build[r], i = t.build[r];
      if (jc("build compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return is(n, i);
=======
      const n = this.prerelease[r], s = t.prerelease[r];
      if (Vi("prerelease compare", r, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Tn(n, s);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof or || (t = new or(t, this.options));
    let r = 0;
    do {
      const n = this.build[r], s = t.build[r];
      if (Vi("build compare", r, n, s), n === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === s)
        continue;
      return Tn(n, s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r, n) {
    if (t.startsWith("pre")) {
      if (!r && n === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (r) {
<<<<<<< HEAD
        const i = new RegExp(`^${this.options.loose ? N_[Mc.PRERELEASELOOSE] : N_[Mc.PRERELEASE]}$`), s = `-${r}`.match(i);
        if (!s || s[1] !== r)
=======
        const s = new RegExp(`^${this.options.loose ? Um[Wi.PRERELEASELOOSE] : Um[Wi.PRERELEASE]}$`), i = `-${r}`.match(s);
        if (!i || i[1] !== r)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          throw new Error(`invalid identifier: ${r}`);
      }
    }
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
<<<<<<< HEAD
        const i = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let s = this.prerelease.length;
          for (; --s >= 0; )
            typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
          if (s === -1) {
            if (r === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (r) {
          let s = [r, i];
          n === !1 && (s = [r]), is(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = s) : this.prerelease = s;
=======
        const s = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let i = this.prerelease.length;
          for (; --i >= 0; )
            typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
          if (i === -1) {
            if (r === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (r) {
          let i = [r, s];
          n === !1 && (i = [r]), Tn(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
<<<<<<< HEAD
var tr = mq;
const k_ = tr, gq = (e, t, r = !1) => {
  if (e instanceof k_)
    return e;
  try {
    return new k_(e, t);
=======
var wt = yk;
const qm = wt, gk = (e, t, r = !1) => {
  if (e instanceof qm)
    return e;
  try {
    return new qm(e, t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch (n) {
    if (!r)
      return null;
    throw n;
  }
};
<<<<<<< HEAD
var oo = gq;
const yq = oo, vq = (e, t) => {
  const r = yq(e, t);
  return r ? r.version : null;
};
var _q = vq;
const bq = oo, Eq = (e, t) => {
  const r = bq(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var wq = Eq;
const D_ = tr, Sq = (e, t, r, n, i) => {
  typeof r == "string" && (i = n, n = r, r = void 0);
  try {
    return new D_(
      e instanceof D_ ? e.version : e,
      r
    ).inc(t, n, i).version;
=======
var us = gk;
const vk = us, bk = (e, t) => {
  const r = vk(e, t);
  return r ? r.version : null;
};
var _k = bk;
const Ek = us, Sk = (e, t) => {
  const r = Ek(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var xk = Sk;
const Hm = wt, wk = (e, t, r, n, s) => {
  typeof r == "string" && (s = n, n = r, r = void 0);
  try {
    return new Hm(
      e instanceof Hm ? e.version : e,
      r
    ).inc(t, n, s).version;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return null;
  }
};
<<<<<<< HEAD
var xq = Sq;
const L_ = oo, Rq = (e, t) => {
  const r = L_(e, null, !0), n = L_(t, null, !0), i = r.compare(n);
  if (i === 0)
    return null;
  const s = i > 0, o = s ? r : n, a = s ? n : r, c = !!o.prerelease.length;
=======
var Rk = wk;
const Bm = us, $k = (e, t) => {
  const r = Bm(e, null, !0), n = Bm(t, null, !0), s = r.compare(n);
  if (s === 0)
    return null;
  const i = s > 0, o = i ? r : n, a = i ? n : r, c = !!o.prerelease.length;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!!a.prerelease.length && !c) {
    if (!a.patch && !a.minor)
      return "major";
    if (a.compareMain(o) === 0)
      return a.minor && !a.patch ? "minor" : "patch";
  }
  const l = c ? "pre" : "";
  return r.major !== n.major ? l + "major" : r.minor !== n.minor ? l + "minor" : r.patch !== n.patch ? l + "patch" : "prerelease";
};
<<<<<<< HEAD
var $q = Rq;
const Tq = tr, Oq = (e, t) => new Tq(e, t).major;
var Pq = Oq;
const Cq = tr, Aq = (e, t) => new Cq(e, t).minor;
var Iq = Aq;
const Nq = tr, kq = (e, t) => new Nq(e, t).patch;
var Dq = kq;
const Lq = oo, Fq = (e, t) => {
  const r = Lq(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var jq = Fq;
const F_ = tr, Uq = (e, t, r) => new F_(e, r).compare(new F_(t, r));
var qr = Uq;
const Mq = qr, Hq = (e, t, r) => Mq(t, e, r);
var qq = Hq;
const Bq = qr, zq = (e, t) => Bq(e, t, !0);
var Vq = zq;
const j_ = tr, Gq = (e, t, r) => {
  const n = new j_(e, r), i = new j_(t, r);
  return n.compare(i) || n.compareBuild(i);
};
var Qg = Gq;
const Wq = Qg, Kq = (e, t) => e.sort((r, n) => Wq(r, n, t));
var Yq = Kq;
const Jq = Qg, Xq = (e, t) => e.sort((r, n) => Jq(n, r, t));
var Zq = Xq;
const Qq = qr, eB = (e, t, r) => Qq(e, t, r) > 0;
var Yu = eB;
const tB = qr, rB = (e, t, r) => tB(e, t, r) < 0;
var ey = rB;
const nB = qr, iB = (e, t, r) => nB(e, t, r) === 0;
var I$ = iB;
const sB = qr, oB = (e, t, r) => sB(e, t, r) !== 0;
var N$ = oB;
const aB = qr, cB = (e, t, r) => aB(e, t, r) >= 0;
var ty = cB;
const lB = qr, uB = (e, t, r) => lB(e, t, r) <= 0;
var ry = uB;
const fB = I$, dB = N$, pB = Yu, hB = ty, mB = ey, gB = ry, yB = (e, t, r, n) => {
=======
var Tk = $k;
const Ok = wt, Ck = (e, t) => new Ok(e, t).major;
var Pk = Ck;
const Ik = wt, Nk = (e, t) => new Ik(e, t).minor;
var Ak = Nk;
const kk = wt, Lk = (e, t) => new kk(e, t).patch;
var jk = Lk;
const Dk = us, Fk = (e, t) => {
  const r = Dk(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var Mk = Fk;
const Vm = wt, zk = (e, t, r) => new Vm(e, r).compare(new Vm(t, r));
var Xt = zk;
const Uk = Xt, qk = (e, t, r) => Uk(t, e, r);
var Hk = qk;
const Bk = Xt, Vk = (e, t) => Bk(e, t, !0);
var Gk = Vk;
const Gm = wt, Wk = (e, t, r) => {
  const n = new Gm(e, r), s = new Gm(t, r);
  return n.compare(s) || n.compareBuild(s);
};
var jd = Wk;
const Kk = jd, Jk = (e, t) => e.sort((r, n) => Kk(r, n, t));
var Yk = Jk;
const Xk = jd, Zk = (e, t) => e.sort((r, n) => Xk(n, r, t));
var Qk = Zk;
const eL = Xt, tL = (e, t, r) => eL(e, t, r) > 0;
var Pa = tL;
const rL = Xt, nL = (e, t, r) => rL(e, t, r) < 0;
var Dd = nL;
const sL = Xt, iL = (e, t, r) => sL(e, t, r) === 0;
var v_ = iL;
const oL = Xt, aL = (e, t, r) => oL(e, t, r) !== 0;
var b_ = aL;
const cL = Xt, lL = (e, t, r) => cL(e, t, r) >= 0;
var Fd = lL;
const uL = Xt, fL = (e, t, r) => uL(e, t, r) <= 0;
var Md = fL;
const dL = v_, pL = b_, hL = Pa, mL = Fd, yL = Dd, gL = Md, vL = (e, t, r, n) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
<<<<<<< HEAD
      return fB(e, r, n);
    case "!=":
      return dB(e, r, n);
    case ">":
      return pB(e, r, n);
    case ">=":
      return hB(e, r, n);
    case "<":
      return mB(e, r, n);
    case "<=":
      return gB(e, r, n);
=======
      return dL(e, r, n);
    case "!=":
      return pL(e, r, n);
    case ">":
      return hL(e, r, n);
    case ">=":
      return mL(e, r, n);
    case "<":
      return yL(e, r, n);
    case "<=":
      return gL(e, r, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
<<<<<<< HEAD
var k$ = yB;
const vB = tr, _B = oo, { safeRe: Hc, t: qc } = Ka, bB = (e, t) => {
  if (e instanceof vB)
=======
var __ = vL;
const bL = wt, _L = us, { safeRe: Ki, t: Ji } = gi, EL = (e, t) => {
  if (e instanceof bL)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
<<<<<<< HEAD
    r = e.match(t.includePrerelease ? Hc[qc.COERCEFULL] : Hc[qc.COERCE]);
  else {
    const c = t.includePrerelease ? Hc[qc.COERCERTLFULL] : Hc[qc.COERCERTL];
    let u;
    for (; (u = c.exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || u.index + u[0].length !== r.index + r[0].length) && (r = u), c.lastIndex = u.index + u[1].length + u[2].length;
=======
    r = e.match(t.includePrerelease ? Ki[Ji.COERCEFULL] : Ki[Ji.COERCE]);
  else {
    const c = t.includePrerelease ? Ki[Ji.COERCERTLFULL] : Ki[Ji.COERCERTL];
    let f;
    for (; (f = c.exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || f.index + f[0].length !== r.index + r[0].length) && (r = f), c.lastIndex = f.index + f[1].length + f[2].length;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    c.lastIndex = -1;
  }
  if (r === null)
    return null;
<<<<<<< HEAD
  const n = r[2], i = r[3] || "0", s = r[4] || "0", o = t.includePrerelease && r[5] ? `-${r[5]}` : "", a = t.includePrerelease && r[6] ? `+${r[6]}` : "";
  return _B(`${n}.${i}.${s}${o}${a}`, t);
};
var EB = bB;
class wB {
=======
  const n = r[2], s = r[3] || "0", i = r[4] || "0", o = t.includePrerelease && r[5] ? `-${r[5]}` : "", a = t.includePrerelease && r[6] ? `+${r[6]}` : "";
  return _L(`${n}.${s}.${i}${o}${a}`, t);
};
var SL = EL;
class xL {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const r = this.map.get(t);
    if (r !== void 0)
      return this.map.delete(t), this.map.set(t, r), r;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, r) {
    if (!this.delete(t) && r !== void 0) {
      if (this.map.size >= this.max) {
<<<<<<< HEAD
        const i = this.map.keys().next().value;
        this.delete(i);
=======
        const s = this.map.keys().next().value;
        this.delete(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      this.map.set(t, r);
    }
    return this;
  }
}
<<<<<<< HEAD
var SB = wB, Ud, U_;
function Br() {
  if (U_) return Ud;
  U_ = 1;
  const e = /\s+/g;
  class t {
    constructor(A, P) {
      if (P = i(P), A instanceof t)
        return A.loose === !!P.loose && A.includePrerelease === !!P.includePrerelease ? A : new t(A.raw, P);
      if (A instanceof s)
        return this.raw = A.value, this.set = [[A]], this.formatted = void 0, this;
      if (this.options = P, this.loose = !!P.loose, this.includePrerelease = !!P.includePrerelease, this.raw = A.trim().replace(e, " "), this.set = this.raw.split("||").map((D) => this.parseRange(D.trim())).filter((D) => D.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const D = this.set[0];
        if (this.set = this.set.filter((I) => !h(I[0])), this.set.length === 0)
          this.set = [D];
        else if (this.set.length > 1) {
          for (const I of this.set)
            if (I.length === 1 && _(I[0])) {
              this.set = [I];
=======
var wL = xL, tl, Wm;
function Zt() {
  if (Wm) return tl;
  Wm = 1;
  const e = /\s+/g;
  class t {
    constructor(I, T) {
      if (T = s(T), I instanceof t)
        return I.loose === !!T.loose && I.includePrerelease === !!T.includePrerelease ? I : new t(I.raw, T);
      if (I instanceof i)
        return this.raw = I.value, this.set = [[I]], this.formatted = void 0, this;
      if (this.options = T, this.loose = !!T.loose, this.includePrerelease = !!T.includePrerelease, this.raw = I.trim().replace(e, " "), this.set = this.raw.split("||").map((j) => this.parseRange(j.trim())).filter((j) => j.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const j = this.set[0];
        if (this.set = this.set.filter((C) => !h(C[0])), this.set.length === 0)
          this.set = [j];
        else if (this.set.length > 1) {
          for (const C of this.set)
            if (C.length === 1 && b(C[0])) {
              this.set = [C];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
<<<<<<< HEAD
        for (let A = 0; A < this.set.length; A++) {
          A > 0 && (this.formatted += "||");
          const P = this.set[A];
          for (let D = 0; D < P.length; D++)
            D > 0 && (this.formatted += " "), this.formatted += P[D].toString().trim();
=======
        for (let I = 0; I < this.set.length; I++) {
          I > 0 && (this.formatted += "||");
          const T = this.set[I];
          for (let j = 0; j < T.length; j++)
            j > 0 && (this.formatted += " "), this.formatted += T[j].toString().trim();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
<<<<<<< HEAD
    parseRange(A) {
      const D = ((this.options.includePrerelease && p) | (this.options.loose && d)) + ":" + A, I = n.get(D);
      if (I)
        return I;
      const L = this.options.loose, j = L ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      A = A.replace(j, q(this.options.includePrerelease)), o("hyphen replace", A), A = A.replace(c[u.COMPARATORTRIM], l), o("comparator trim", A), A = A.replace(c[u.TILDETRIM], f), o("tilde trim", A), A = A.replace(c[u.CARETTRIM], m), o("caret trim", A);
      let k = A.split(" ").map((N) => v(N, this.options)).join(" ").split(/\s+/).map((N) => H(N, this.options));
      L && (k = k.filter((N) => (o("loose invalid filter", N, this.options), !!N.match(c[u.COMPARATORLOOSE])))), o("range list", k);
      const U = /* @__PURE__ */ new Map(), M = k.map((N) => new s(N, this.options));
      for (const N of M) {
        if (h(N))
          return [N];
        U.set(N.value, N);
      }
      U.size > 1 && U.has("") && U.delete("");
      const T = [...U.values()];
      return n.set(D, T), T;
    }
    intersects(A, P) {
      if (!(A instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((D) => g(D, P) && A.set.some((I) => g(I, P) && D.every((L) => I.every((j) => L.intersects(j, P)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(A) {
      if (!A)
        return !1;
      if (typeof A == "string")
        try {
          A = new a(A, this.options);
        } catch {
          return !1;
        }
      for (let P = 0; P < this.set.length; P++)
        if ($(this.set[P], A, this.options))
=======
    parseRange(I) {
      const j = ((this.options.includePrerelease && p) | (this.options.loose && u)) + ":" + I, C = n.get(j);
      if (C)
        return C;
      const A = this.options.loose, k = A ? c[f.HYPHENRANGELOOSE] : c[f.HYPHENRANGE];
      I = I.replace(k, U(this.options.includePrerelease)), o("hyphen replace", I), I = I.replace(c[f.COMPARATORTRIM], l), o("comparator trim", I), I = I.replace(c[f.TILDETRIM], d), o("tilde trim", I), I = I.replace(c[f.CARETTRIM], g), o("caret trim", I);
      let P = I.split(" ").map((N) => v(N, this.options)).join(" ").split(/\s+/).map((N) => M(N, this.options));
      A && (P = P.filter((N) => (o("loose invalid filter", N, this.options), !!N.match(c[f.COMPARATORLOOSE])))), o("range list", P);
      const D = /* @__PURE__ */ new Map(), F = P.map((N) => new i(N, this.options));
      for (const N of F) {
        if (h(N))
          return [N];
        D.set(N.value, N);
      }
      D.size > 1 && D.has("") && D.delete("");
      const w = [...D.values()];
      return n.set(j, w), w;
    }
    intersects(I, T) {
      if (!(I instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((j) => m(j, T) && I.set.some((C) => m(C, T) && j.every((A) => C.every((k) => A.intersects(k, T)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(I) {
      if (!I)
        return !1;
      if (typeof I == "string")
        try {
          I = new a(I, this.options);
        } catch {
          return !1;
        }
      for (let T = 0; T < this.set.length; T++)
        if ($(this.set[T], I, this.options))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          return !0;
      return !1;
    }
  }
<<<<<<< HEAD
  Ud = t;
  const r = SB, n = new r(), i = Zg, s = Ju(), o = Ku, a = tr, {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: f,
    caretTrimReplace: m
  } = Ka, { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: d } = Wu, h = (x) => x.value === "<0.0.0-0", _ = (x) => x.value === "", g = (x, A) => {
    let P = !0;
    const D = x.slice();
    let I = D.pop();
    for (; P && D.length; )
      P = D.every((L) => I.intersects(L, A)), I = D.pop();
    return P;
  }, v = (x, A) => (o("comp", x, A), x = w(x, A), o("caret", x), x = E(x, A), o("tildes", x), x = V(x, A), o("xrange", x), x = F(x, A), o("stars", x), x), y = (x) => !x || x.toLowerCase() === "x" || x === "*", E = (x, A) => x.trim().split(/\s+/).map((P) => R(P, A)).join(" "), R = (x, A) => {
    const P = A.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return x.replace(P, (D, I, L, j, k) => {
      o("tilde", x, D, I, L, j, k);
      let U;
      return y(I) ? U = "" : y(L) ? U = `>=${I}.0.0 <${+I + 1}.0.0-0` : y(j) ? U = `>=${I}.${L}.0 <${I}.${+L + 1}.0-0` : k ? (o("replaceTilde pr", k), U = `>=${I}.${L}.${j}-${k} <${I}.${+L + 1}.0-0`) : U = `>=${I}.${L}.${j} <${I}.${+L + 1}.0-0`, o("tilde return", U), U;
    });
  }, w = (x, A) => x.trim().split(/\s+/).map((P) => C(P, A)).join(" "), C = (x, A) => {
    o("caret", x, A);
    const P = A.loose ? c[u.CARETLOOSE] : c[u.CARET], D = A.includePrerelease ? "-0" : "";
    return x.replace(P, (I, L, j, k, U) => {
      o("caret", x, I, L, j, k, U);
      let M;
      return y(L) ? M = "" : y(j) ? M = `>=${L}.0.0${D} <${+L + 1}.0.0-0` : y(k) ? L === "0" ? M = `>=${L}.${j}.0${D} <${L}.${+j + 1}.0-0` : M = `>=${L}.${j}.0${D} <${+L + 1}.0.0-0` : U ? (o("replaceCaret pr", U), L === "0" ? j === "0" ? M = `>=${L}.${j}.${k}-${U} <${L}.${j}.${+k + 1}-0` : M = `>=${L}.${j}.${k}-${U} <${L}.${+j + 1}.0-0` : M = `>=${L}.${j}.${k}-${U} <${+L + 1}.0.0-0`) : (o("no pr"), L === "0" ? j === "0" ? M = `>=${L}.${j}.${k}${D} <${L}.${j}.${+k + 1}-0` : M = `>=${L}.${j}.${k}${D} <${L}.${+j + 1}.0-0` : M = `>=${L}.${j}.${k} <${+L + 1}.0.0-0`), o("caret return", M), M;
    });
  }, V = (x, A) => (o("replaceXRanges", x, A), x.split(/\s+/).map((P) => b(P, A)).join(" ")), b = (x, A) => {
    x = x.trim();
    const P = A.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return x.replace(P, (D, I, L, j, k, U) => {
      o("xRange", x, D, I, L, j, k, U);
      const M = y(L), T = M || y(j), N = T || y(k), G = N;
      return I === "=" && G && (I = ""), U = A.includePrerelease ? "-0" : "", M ? I === ">" || I === "<" ? D = "<0.0.0-0" : D = "*" : I && G ? (T && (j = 0), k = 0, I === ">" ? (I = ">=", T ? (L = +L + 1, j = 0, k = 0) : (j = +j + 1, k = 0)) : I === "<=" && (I = "<", T ? L = +L + 1 : j = +j + 1), I === "<" && (U = "-0"), D = `${I + L}.${j}.${k}${U}`) : T ? D = `>=${L}.0.0${U} <${+L + 1}.0.0-0` : N && (D = `>=${L}.${j}.0${U} <${L}.${+j + 1}.0-0`), o("xRange return", D), D;
    });
  }, F = (x, A) => (o("replaceStars", x, A), x.trim().replace(c[u.STAR], "")), H = (x, A) => (o("replaceGTE0", x, A), x.trim().replace(c[A.includePrerelease ? u.GTE0PRE : u.GTE0], "")), q = (x) => (A, P, D, I, L, j, k, U, M, T, N, G) => (y(D) ? P = "" : y(I) ? P = `>=${D}.0.0${x ? "-0" : ""}` : y(L) ? P = `>=${D}.${I}.0${x ? "-0" : ""}` : j ? P = `>=${P}` : P = `>=${P}${x ? "-0" : ""}`, y(M) ? U = "" : y(T) ? U = `<${+M + 1}.0.0-0` : y(N) ? U = `<${M}.${+T + 1}.0-0` : G ? U = `<=${M}.${T}.${N}-${G}` : x ? U = `<${M}.${T}.${+N + 1}-0` : U = `<=${U}`, `${P} ${U}`.trim()), $ = (x, A, P) => {
    for (let D = 0; D < x.length; D++)
      if (!x[D].test(A))
        return !1;
    if (A.prerelease.length && !P.includePrerelease) {
      for (let D = 0; D < x.length; D++)
        if (o(x[D].semver), x[D].semver !== s.ANY && x[D].semver.prerelease.length > 0) {
          const I = x[D].semver;
          if (I.major === A.major && I.minor === A.minor && I.patch === A.patch)
=======
  tl = t;
  const r = wL, n = new r(), s = Ld, i = Ia(), o = Ca, a = wt, {
    safeRe: c,
    t: f,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: g
  } = gi, { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: u } = Oa, h = (x) => x.value === "<0.0.0-0", b = (x) => x.value === "", m = (x, I) => {
    let T = !0;
    const j = x.slice();
    let C = j.pop();
    for (; T && j.length; )
      T = j.every((A) => C.intersects(A, I)), C = j.pop();
    return T;
  }, v = (x, I) => (o("comp", x, I), x = E(x, I), o("caret", x), x = _(x, I), o("tildes", x), x = z(x, I), o("xrange", x), x = L(x, I), o("stars", x), x), y = (x) => !x || x.toLowerCase() === "x" || x === "*", _ = (x, I) => x.trim().split(/\s+/).map((T) => R(T, I)).join(" "), R = (x, I) => {
    const T = I.loose ? c[f.TILDELOOSE] : c[f.TILDE];
    return x.replace(T, (j, C, A, k, P) => {
      o("tilde", x, j, C, A, k, P);
      let D;
      return y(C) ? D = "" : y(A) ? D = `>=${C}.0.0 <${+C + 1}.0.0-0` : y(k) ? D = `>=${C}.${A}.0 <${C}.${+A + 1}.0-0` : P ? (o("replaceTilde pr", P), D = `>=${C}.${A}.${k}-${P} <${C}.${+A + 1}.0-0`) : D = `>=${C}.${A}.${k} <${C}.${+A + 1}.0-0`, o("tilde return", D), D;
    });
  }, E = (x, I) => x.trim().split(/\s+/).map((T) => O(T, I)).join(" "), O = (x, I) => {
    o("caret", x, I);
    const T = I.loose ? c[f.CARETLOOSE] : c[f.CARET], j = I.includePrerelease ? "-0" : "";
    return x.replace(T, (C, A, k, P, D) => {
      o("caret", x, C, A, k, P, D);
      let F;
      return y(A) ? F = "" : y(k) ? F = `>=${A}.0.0${j} <${+A + 1}.0.0-0` : y(P) ? A === "0" ? F = `>=${A}.${k}.0${j} <${A}.${+k + 1}.0-0` : F = `>=${A}.${k}.0${j} <${+A + 1}.0.0-0` : D ? (o("replaceCaret pr", D), A === "0" ? k === "0" ? F = `>=${A}.${k}.${P}-${D} <${A}.${k}.${+P + 1}-0` : F = `>=${A}.${k}.${P}-${D} <${A}.${+k + 1}.0-0` : F = `>=${A}.${k}.${P}-${D} <${+A + 1}.0.0-0`) : (o("no pr"), A === "0" ? k === "0" ? F = `>=${A}.${k}.${P}${j} <${A}.${k}.${+P + 1}-0` : F = `>=${A}.${k}.${P}${j} <${A}.${+k + 1}.0-0` : F = `>=${A}.${k}.${P} <${+A + 1}.0.0-0`), o("caret return", F), F;
    });
  }, z = (x, I) => (o("replaceXRanges", x, I), x.split(/\s+/).map((T) => S(T, I)).join(" ")), S = (x, I) => {
    x = x.trim();
    const T = I.loose ? c[f.XRANGELOOSE] : c[f.XRANGE];
    return x.replace(T, (j, C, A, k, P, D) => {
      o("xRange", x, j, C, A, k, P, D);
      const F = y(A), w = F || y(k), N = w || y(P), q = N;
      return C === "=" && q && (C = ""), D = I.includePrerelease ? "-0" : "", F ? C === ">" || C === "<" ? j = "<0.0.0-0" : j = "*" : C && q ? (w && (k = 0), P = 0, C === ">" ? (C = ">=", w ? (A = +A + 1, k = 0, P = 0) : (k = +k + 1, P = 0)) : C === "<=" && (C = "<", w ? A = +A + 1 : k = +k + 1), C === "<" && (D = "-0"), j = `${C + A}.${k}.${P}${D}`) : w ? j = `>=${A}.0.0${D} <${+A + 1}.0.0-0` : N && (j = `>=${A}.${k}.0${D} <${A}.${+k + 1}.0-0`), o("xRange return", j), j;
    });
  }, L = (x, I) => (o("replaceStars", x, I), x.trim().replace(c[f.STAR], "")), M = (x, I) => (o("replaceGTE0", x, I), x.trim().replace(c[I.includePrerelease ? f.GTE0PRE : f.GTE0], "")), U = (x) => (I, T, j, C, A, k, P, D, F, w, N, q) => (y(j) ? T = "" : y(C) ? T = `>=${j}.0.0${x ? "-0" : ""}` : y(A) ? T = `>=${j}.${C}.0${x ? "-0" : ""}` : k ? T = `>=${T}` : T = `>=${T}${x ? "-0" : ""}`, y(F) ? D = "" : y(w) ? D = `<${+F + 1}.0.0-0` : y(N) ? D = `<${F}.${+w + 1}.0-0` : q ? D = `<=${F}.${w}.${N}-${q}` : x ? D = `<${F}.${w}.${+N + 1}-0` : D = `<=${D}`, `${T} ${D}`.trim()), $ = (x, I, T) => {
    for (let j = 0; j < x.length; j++)
      if (!x[j].test(I))
        return !1;
    if (I.prerelease.length && !T.includePrerelease) {
      for (let j = 0; j < x.length; j++)
        if (o(x[j].semver), x[j].semver !== i.ANY && x[j].semver.prerelease.length > 0) {
          const C = x[j].semver;
          if (C.major === I.major && C.minor === I.minor && C.patch === I.patch)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            return !0;
        }
      return !1;
    }
    return !0;
  };
<<<<<<< HEAD
  return Ud;
}
var Md, M_;
function Ju() {
  if (M_) return Md;
  M_ = 1;
=======
  return tl;
}
var rl, Km;
function Ia() {
  if (Km) return rl;
  Km = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
<<<<<<< HEAD
    constructor(l, f) {
      if (f = r(f), l instanceof t) {
        if (l.loose === !!f.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, f), this.options = f, this.loose = !!f.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const f = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], m = l.match(f);
      if (!m)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new a(m[2], this.options.loose) : this.semver = e;
=======
    constructor(l, d) {
      if (d = r(d), l instanceof t) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], g = l.match(d);
      if (!g)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = g[1] !== void 0 ? g[1] : "", this.operator === "=" && (this.operator = ""), g[2] ? this.semver = new a(g[2], this.options.loose) : this.semver = e;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (o("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new a(l, this.options);
        } catch {
          return !1;
        }
<<<<<<< HEAD
      return s(l, this.operator, this.semver, this.options);
    }
    intersects(l, f) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, f).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, f).test(l.semver) : (f = r(f), f.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || s(this.semver, "<", l.semver, f) && this.operator.startsWith(">") && l.operator.startsWith("<") || s(this.semver, ">", l.semver, f) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  Md = t;
  const r = Zg, { safeRe: n, t: i } = Ka, s = k$, o = Ku, a = tr, c = Br();
  return Md;
}
const xB = Br(), RB = (e, t, r) => {
  try {
    t = new xB(t, r);
=======
      return i(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = r(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || i(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || i(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  rl = t;
  const r = Ld, { safeRe: n, t: s } = gi, i = __, o = Ca, a = wt, c = Zt();
  return rl;
}
const RL = Zt(), $L = (e, t, r) => {
  try {
    t = new RL(t, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return !1;
  }
  return t.test(e);
};
<<<<<<< HEAD
var Xu = RB;
const $B = Br(), TB = (e, t) => new $B(e, t).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var OB = TB;
const PB = tr, CB = Br(), AB = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new CB(t, r);
=======
var Na = $L;
const TL = Zt(), OL = (e, t) => new TL(e, t).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var CL = OL;
const PL = wt, IL = Zt(), NL = (e, t, r) => {
  let n = null, s = null, i = null;
  try {
    i = new IL(t, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return null;
  }
  return e.forEach((o) => {
<<<<<<< HEAD
    s.test(o) && (!n || i.compare(o) === -1) && (n = o, i = new PB(n, r));
  }), n;
};
var IB = AB;
const NB = tr, kB = Br(), DB = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new kB(t, r);
=======
    i.test(o) && (!n || s.compare(o) === -1) && (n = o, s = new PL(n, r));
  }), n;
};
var AL = NL;
const kL = wt, LL = Zt(), jL = (e, t, r) => {
  let n = null, s = null, i = null;
  try {
    i = new LL(t, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return null;
  }
  return e.forEach((o) => {
<<<<<<< HEAD
    s.test(o) && (!n || i.compare(o) === 1) && (n = o, i = new NB(n, r));
  }), n;
};
var LB = DB;
const Hd = tr, FB = Br(), H_ = Yu, jB = (e, t) => {
  e = new FB(e, t);
  let r = new Hd("0.0.0");
  if (e.test(r) || (r = new Hd("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let n = 0; n < e.set.length; ++n) {
    const i = e.set[n];
    let s = null;
    i.forEach((o) => {
      const a = new Hd(o.semver.version);
=======
    i.test(o) && (!n || s.compare(o) === 1) && (n = o, s = new kL(n, r));
  }), n;
};
var DL = jL;
const nl = wt, FL = Zt(), Jm = Pa, ML = (e, t) => {
  e = new FL(e, t);
  let r = new nl("0.0.0");
  if (e.test(r) || (r = new nl("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let n = 0; n < e.set.length; ++n) {
    const s = e.set[n];
    let i = null;
    s.forEach((o) => {
      const a = new nl(o.semver.version);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      switch (o.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
<<<<<<< HEAD
          (!s || H_(a, s)) && (s = a);
=======
          (!i || Jm(a, i)) && (i = a);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
<<<<<<< HEAD
    }), s && (!r || H_(r, s)) && (r = s);
  }
  return r && e.test(r) ? r : null;
};
var UB = jB;
const MB = Br(), HB = (e, t) => {
  try {
    return new MB(e, t).range || "*";
=======
    }), i && (!r || Jm(r, i)) && (r = i);
  }
  return r && e.test(r) ? r : null;
};
var zL = ML;
const UL = Zt(), qL = (e, t) => {
  try {
    return new UL(e, t).range || "*";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return null;
  }
};
<<<<<<< HEAD
var qB = HB;
const BB = tr, D$ = Ju(), { ANY: zB } = D$, VB = Br(), GB = Xu, q_ = Yu, B_ = ey, WB = ry, KB = ty, YB = (e, t, r, n) => {
  e = new BB(e, n), t = new VB(t, n);
  let i, s, o, a, c;
  switch (r) {
    case ">":
      i = q_, s = WB, o = B_, a = ">", c = ">=";
      break;
    case "<":
      i = B_, s = KB, o = q_, a = "<", c = "<=";
=======
var HL = qL;
const BL = wt, E_ = Ia(), { ANY: VL } = E_, GL = Zt(), WL = Na, Ym = Pa, Xm = Dd, KL = Md, JL = Fd, YL = (e, t, r, n) => {
  e = new BL(e, n), t = new GL(t, n);
  let s, i, o, a, c;
  switch (r) {
    case ">":
      s = Ym, i = KL, o = Xm, a = ">", c = ">=";
      break;
    case "<":
      s = Xm, i = JL, o = Ym, a = "<", c = "<=";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
<<<<<<< HEAD
  if (GB(e, t, n))
    return !1;
  for (let u = 0; u < t.set.length; ++u) {
    const l = t.set[u];
    let f = null, m = null;
    if (l.forEach((p) => {
      p.semver === zB && (p = new D$(">=0.0.0")), f = f || p, m = m || p, i(p.semver, f.semver, n) ? f = p : o(p.semver, m.semver, n) && (m = p);
    }), f.operator === a || f.operator === c || (!m.operator || m.operator === a) && s(e, m.semver))
      return !1;
    if (m.operator === c && o(e, m.semver))
=======
  if (WL(e, t, n))
    return !1;
  for (let f = 0; f < t.set.length; ++f) {
    const l = t.set[f];
    let d = null, g = null;
    if (l.forEach((p) => {
      p.semver === VL && (p = new E_(">=0.0.0")), d = d || p, g = g || p, s(p.semver, d.semver, n) ? d = p : o(p.semver, g.semver, n) && (g = p);
    }), d.operator === a || d.operator === c || (!g.operator || g.operator === a) && i(e, g.semver))
      return !1;
    if (g.operator === c && o(e, g.semver))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return !1;
  }
  return !0;
};
<<<<<<< HEAD
var ny = YB;
const JB = ny, XB = (e, t, r) => JB(e, t, ">", r);
var ZB = XB;
const QB = ny, e3 = (e, t, r) => QB(e, t, "<", r);
var t3 = e3;
const z_ = Br(), r3 = (e, t, r) => (e = new z_(e, r), t = new z_(t, r), e.intersects(t, r));
var n3 = r3;
const i3 = Xu, s3 = qr;
var o3 = (e, t, r) => {
  const n = [];
  let i = null, s = null;
  const o = e.sort((l, f) => s3(l, f, r));
  for (const l of o)
    i3(l, t, r) ? (s = l, i || (i = l)) : (s && n.push([i, s]), s = null, i = null);
  i && n.push([i, null]);
  const a = [];
  for (const [l, f] of n)
    l === f ? a.push(l) : !f && l === o[0] ? a.push("*") : f ? l === o[0] ? a.push(`<=${f}`) : a.push(`${l} - ${f}`) : a.push(`>=${l}`);
  const c = a.join(" || "), u = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < u.length ? c : t;
};
const V_ = Br(), iy = Ju(), { ANY: qd } = iy, $o = Xu, sy = qr, a3 = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new V_(e, r), t = new V_(t, r);
  let n = !1;
  e: for (const i of e.set) {
    for (const s of t.set) {
      const o = l3(i, s, r);
=======
var zd = YL;
const XL = zd, ZL = (e, t, r) => XL(e, t, ">", r);
var QL = ZL;
const ej = zd, tj = (e, t, r) => ej(e, t, "<", r);
var rj = tj;
const Zm = Zt(), nj = (e, t, r) => (e = new Zm(e, r), t = new Zm(t, r), e.intersects(t, r));
var sj = nj;
const ij = Na, oj = Xt;
var aj = (e, t, r) => {
  const n = [];
  let s = null, i = null;
  const o = e.sort((l, d) => oj(l, d, r));
  for (const l of o)
    ij(l, t, r) ? (i = l, s || (s = l)) : (i && n.push([s, i]), i = null, s = null);
  s && n.push([s, null]);
  const a = [];
  for (const [l, d] of n)
    l === d ? a.push(l) : !d && l === o[0] ? a.push("*") : d ? l === o[0] ? a.push(`<=${d}`) : a.push(`${l} - ${d}`) : a.push(`>=${l}`);
  const c = a.join(" || "), f = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < f.length ? c : t;
};
const Qm = Zt(), Ud = Ia(), { ANY: sl } = Ud, _s = Na, qd = Xt, cj = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new Qm(e, r), t = new Qm(t, r);
  let n = !1;
  e: for (const s of e.set) {
    for (const i of t.set) {
      const o = uj(s, i, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (n = n || o !== null, o)
        continue e;
    }
    if (n)
      return !1;
  }
  return !0;
<<<<<<< HEAD
}, c3 = [new iy(">=0.0.0-0")], G_ = [new iy(">=0.0.0")], l3 = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === qd) {
    if (t.length === 1 && t[0].semver === qd)
      return !0;
    r.includePrerelease ? e = c3 : e = G_;
  }
  if (t.length === 1 && t[0].semver === qd) {
    if (r.includePrerelease)
      return !0;
    t = G_;
  }
  const n = /* @__PURE__ */ new Set();
  let i, s;
  for (const p of e)
    p.operator === ">" || p.operator === ">=" ? i = W_(i, p, r) : p.operator === "<" || p.operator === "<=" ? s = K_(s, p, r) : n.add(p.semver);
  if (n.size > 1)
    return null;
  let o;
  if (i && s) {
    if (o = sy(i.semver, s.semver, r), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || s.operator !== "<="))
      return null;
  }
  for (const p of n) {
    if (i && !$o(p, String(i), r) || s && !$o(p, String(s), r))
      return null;
    for (const d of t)
      if (!$o(p, String(d), r))
        return !1;
    return !0;
  }
  let a, c, u, l, f = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1, m = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  f && f.prerelease.length === 1 && s.operator === "<" && f.prerelease[0] === 0 && (f = !1);
  for (const p of t) {
    if (l = l || p.operator === ">" || p.operator === ">=", u = u || p.operator === "<" || p.operator === "<=", i) {
      if (m && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === m.major && p.semver.minor === m.minor && p.semver.patch === m.patch && (m = !1), p.operator === ">" || p.operator === ">=") {
        if (a = W_(i, p, r), a === p && a !== i)
          return !1;
      } else if (i.operator === ">=" && !$o(i.semver, String(p), r))
        return !1;
    }
    if (s) {
      if (f && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === f.major && p.semver.minor === f.minor && p.semver.patch === f.patch && (f = !1), p.operator === "<" || p.operator === "<=") {
        if (c = K_(s, p, r), c === p && c !== s)
          return !1;
      } else if (s.operator === "<=" && !$o(s.semver, String(p), r))
        return !1;
    }
    if (!p.operator && (s || i) && o !== 0)
      return !1;
  }
  return !(i && u && !s && o !== 0 || s && l && !i && o !== 0 || m || f);
}, W_ = (e, t, r) => {
  if (!e)
    return t;
  const n = sy(e.semver, t.semver, r);
  return n > 0 ? e : n < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, K_ = (e, t, r) => {
  if (!e)
    return t;
  const n = sy(e.semver, t.semver, r);
  return n < 0 ? e : n > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var u3 = a3;
const Bd = Ka, Y_ = Wu, f3 = tr, J_ = A$, d3 = oo, p3 = _q, h3 = wq, m3 = xq, g3 = $q, y3 = Pq, v3 = Iq, _3 = Dq, b3 = jq, E3 = qr, w3 = qq, S3 = Vq, x3 = Qg, R3 = Yq, $3 = Zq, T3 = Yu, O3 = ey, P3 = I$, C3 = N$, A3 = ty, I3 = ry, N3 = k$, k3 = EB, D3 = Ju(), L3 = Br(), F3 = Xu, j3 = OB, U3 = IB, M3 = LB, H3 = UB, q3 = qB, B3 = ny, z3 = ZB, V3 = t3, G3 = n3, W3 = o3, K3 = u3;
var oy = {
  parse: d3,
  valid: p3,
  clean: h3,
  inc: m3,
  diff: g3,
  major: y3,
  minor: v3,
  patch: _3,
  prerelease: b3,
  compare: E3,
  rcompare: w3,
  compareLoose: S3,
  compareBuild: x3,
  sort: R3,
  rsort: $3,
  gt: T3,
  lt: O3,
  eq: P3,
  neq: C3,
  gte: A3,
  lte: I3,
  cmp: N3,
  coerce: k3,
  Comparator: D3,
  Range: L3,
  satisfies: F3,
  toComparators: j3,
  maxSatisfying: U3,
  minSatisfying: M3,
  minVersion: H3,
  validRange: q3,
  outside: B3,
  gtr: z3,
  ltr: V3,
  intersects: G3,
  simplifyRange: W3,
  subset: K3,
  SemVer: f3,
  re: Bd.re,
  src: Bd.src,
  tokens: Bd.t,
  SEMVER_SPEC_VERSION: Y_.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: Y_.RELEASE_TYPES,
  compareIdentifiers: J_.compareIdentifiers,
  rcompareIdentifiers: J_.rcompareIdentifiers
};
(function(e) {
  const t = oy, r = Vi, n = Symbol.for("registered-plugin"), {
    kTestInternals: i
  } = Ft, { exist: s, existReply: o, existRequest: a } = Hx, {
    FST_ERR_PLUGIN_VERSION_MISMATCH: c,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: u,
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: l
  } = Wt, f = /-(?:rc|pre|alpha).+$/u;
  function m(b) {
    return b[Symbol.for("plugin-meta")];
  }
  function p(b) {
    const F = h(b);
    if (F)
      return F;
    const H = require.cache;
    if (H) {
      const q = Object.keys(H);
      for (let $ = 0; $ < q.length; $++) {
        const x = q[$];
        if (H[x].exports === b)
          return x;
      }
    }
    return b.name ? b.name : null;
  }
  function d(b) {
    return b.toString().split(`
`, 2).map((F) => F.trim()).join(" -- ");
  }
  function h(b) {
    return b[Symbol.for("fastify.display-name")];
  }
  function _(b) {
    return !!b[Symbol.for("skip-override")];
  }
  function g(b) {
    const F = m(b);
    if (!F) return;
    const H = F.dependencies;
    H && (r(Array.isArray(H), "The dependencies should be an array of strings"), H.forEach((q) => {
      r(
        this[n].indexOf(q) > -1,
        `The dependency '${q}' of plugin '${F.name}' is not registered`
      );
    }));
  }
  function v(b) {
    const F = m(b);
    if (!F) return;
    const { decorators: H, name: q } = F;
    H && (H.fastify && E(this, "Fastify", H.fastify, q), H.reply && E(this, "Reply", H.reply, q), H.request && E(this, "Request", H.request, q));
  }
  const y = {
    Fastify: s,
    Request: a,
    Reply: o
  };
  function E(b, F, H, q) {
    r(Array.isArray(H), "The decorators should be an array of strings"), H.forEach(($) => {
      const x = typeof q == "string" ? ` required by '${q}'` : "";
      if (!y[F].call(b, $))
        throw new u($, x, F);
    });
  }
  function R(b) {
    const F = m(b);
    if ((F == null ? void 0 : F.fastify) == null) return;
    const H = F.fastify, q = f.test(this.version);
    if (!(q === !0 && t.gt(this.version, t.coerce(H)) === !0) && H && t.satisfies(this.version, H, { includePrerelease: q }) === !1)
      throw new c(F.name, H, this.version);
  }
  function w(b) {
    const F = m(b);
    if (!F) return;
    const H = F.name;
    if (H)
      return this[n].push(H), H;
  }
  function C(b, F) {
    if (b.constructor.name === "AsyncFunction" && b.length === 3)
      throw new l(F);
  }
  function V(b) {
    const F = w.call(this, b) || p(b);
    return C.call(this, b, F), R.call(this, b), v.call(this, b), g.call(this, b), _(b);
  }
  e.exports = {
    getPluginName: p,
    getFuncPreview: d,
    kRegisteredPlugins: n,
    getDisplayName: h,
    registerPlugin: V
  }, e.exports[i] = {
    shouldSkipOverride: _,
    getMeta: m,
    checkDecorators: v,
    checkDependencies: g
  };
})(O$);
var L$ = O$.exports;
function Y3(e, t) {
  const r = t || X3();
  return e ? Z3(e, r) : r;
}
function J3(e, t) {
  return e.genReqId(t);
}
function X3() {
=======
}, lj = [new Ud(">=0.0.0-0")], ey = [new Ud(">=0.0.0")], uj = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === sl) {
    if (t.length === 1 && t[0].semver === sl)
      return !0;
    r.includePrerelease ? e = lj : e = ey;
  }
  if (t.length === 1 && t[0].semver === sl) {
    if (r.includePrerelease)
      return !0;
    t = ey;
  }
  const n = /* @__PURE__ */ new Set();
  let s, i;
  for (const p of e)
    p.operator === ">" || p.operator === ">=" ? s = ty(s, p, r) : p.operator === "<" || p.operator === "<=" ? i = ry(i, p, r) : n.add(p.semver);
  if (n.size > 1)
    return null;
  let o;
  if (s && i) {
    if (o = qd(s.semver, i.semver, r), o > 0)
      return null;
    if (o === 0 && (s.operator !== ">=" || i.operator !== "<="))
      return null;
  }
  for (const p of n) {
    if (s && !_s(p, String(s), r) || i && !_s(p, String(i), r))
      return null;
    for (const u of t)
      if (!_s(p, String(u), r))
        return !1;
    return !0;
  }
  let a, c, f, l, d = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1, g = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1;
  d && d.prerelease.length === 1 && i.operator === "<" && d.prerelease[0] === 0 && (d = !1);
  for (const p of t) {
    if (l = l || p.operator === ">" || p.operator === ">=", f = f || p.operator === "<" || p.operator === "<=", s) {
      if (g && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === g.major && p.semver.minor === g.minor && p.semver.patch === g.patch && (g = !1), p.operator === ">" || p.operator === ">=") {
        if (a = ty(s, p, r), a === p && a !== s)
          return !1;
      } else if (s.operator === ">=" && !_s(s.semver, String(p), r))
        return !1;
    }
    if (i) {
      if (d && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === d.major && p.semver.minor === d.minor && p.semver.patch === d.patch && (d = !1), p.operator === "<" || p.operator === "<=") {
        if (c = ry(i, p, r), c === p && c !== i)
          return !1;
      } else if (i.operator === "<=" && !_s(i.semver, String(p), r))
        return !1;
    }
    if (!p.operator && (i || s) && o !== 0)
      return !1;
  }
  return !(s && f && !i && o !== 0 || i && l && !s && o !== 0 || g || d);
}, ty = (e, t, r) => {
  if (!e)
    return t;
  const n = qd(e.semver, t.semver, r);
  return n > 0 ? e : n < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, ry = (e, t, r) => {
  if (!e)
    return t;
  const n = qd(e.semver, t.semver, r);
  return n < 0 ? e : n > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var fj = cj;
const il = gi, ny = Oa, dj = wt, sy = g_, pj = us, hj = _k, mj = xk, yj = Rk, gj = Tk, vj = Pk, bj = Ak, _j = jk, Ej = Mk, Sj = Xt, xj = Hk, wj = Gk, Rj = jd, $j = Yk, Tj = Qk, Oj = Pa, Cj = Dd, Pj = v_, Ij = b_, Nj = Fd, Aj = Md, kj = __, Lj = SL, jj = Ia(), Dj = Zt(), Fj = Na, Mj = CL, zj = AL, Uj = DL, qj = zL, Hj = HL, Bj = zd, Vj = QL, Gj = rj, Wj = sj, Kj = aj, Jj = fj;
var Yj = {
  parse: pj,
  valid: hj,
  clean: mj,
  inc: yj,
  diff: gj,
  major: vj,
  minor: bj,
  patch: _j,
  prerelease: Ej,
  compare: Sj,
  rcompare: xj,
  compareLoose: wj,
  compareBuild: Rj,
  sort: $j,
  rsort: Tj,
  gt: Oj,
  lt: Cj,
  eq: Pj,
  neq: Ij,
  gte: Nj,
  lte: Aj,
  cmp: kj,
  coerce: Lj,
  Comparator: jj,
  Range: Dj,
  satisfies: Fj,
  toComparators: Mj,
  maxSatisfying: zj,
  minSatisfying: Uj,
  minVersion: qj,
  validRange: Hj,
  outside: Bj,
  gtr: Vj,
  ltr: Gj,
  intersects: Wj,
  simplifyRange: Kj,
  subset: Jj,
  SemVer: dj,
  re: il.re,
  src: il.src,
  tokens: il.t,
  SEMVER_SPEC_VERSION: ny.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: ny.RELEASE_TYPES,
  compareIdentifiers: sy.compareIdentifiers,
  rcompareIdentifiers: sy.rcompareIdentifiers
};
(function(e) {
  const t = Yj, r = vn, n = Symbol.for("registered-plugin"), {
    kTestInternals: s
  } = ht, { exist: i, existReply: o, existRequest: a } = Tb, {
    FST_ERR_PLUGIN_VERSION_MISMATCH: c,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: f,
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: l
  } = _t, d = /-(?:rc|pre|alpha).+$/u;
  function g(S) {
    return S[Symbol.for("plugin-meta")];
  }
  function p(S) {
    const L = h(S);
    if (L)
      return L;
    const M = require.cache;
    if (M) {
      const U = Object.keys(M);
      for (let $ = 0; $ < U.length; $++) {
        const x = U[$];
        if (M[x].exports === S)
          return x;
      }
    }
    return S.name ? S.name : null;
  }
  function u(S) {
    return S.toString().split(`
`, 2).map((L) => L.trim()).join(" -- ");
  }
  function h(S) {
    return S[Symbol.for("fastify.display-name")];
  }
  function b(S) {
    return !!S[Symbol.for("skip-override")];
  }
  function m(S) {
    const L = g(S);
    if (!L) return;
    const M = L.dependencies;
    M && (r(Array.isArray(M), "The dependencies should be an array of strings"), M.forEach((U) => {
      r(
        this[n].indexOf(U) > -1,
        `The dependency '${U}' of plugin '${L.name}' is not registered`
      );
    }));
  }
  function v(S) {
    const L = g(S);
    if (!L) return;
    const { decorators: M, name: U } = L;
    M && (M.fastify && _(this, "Fastify", M.fastify, U), M.reply && _(this, "Reply", M.reply, U), M.request && _(this, "Request", M.request, U));
  }
  const y = {
    Fastify: i,
    Request: a,
    Reply: o
  };
  function _(S, L, M, U) {
    r(Array.isArray(M), "The decorators should be an array of strings"), M.forEach(($) => {
      const x = typeof U == "string" ? ` required by '${U}'` : "";
      if (!y[L].call(S, $))
        throw new f($, x, L);
    });
  }
  function R(S) {
    const L = g(S);
    if ((L == null ? void 0 : L.fastify) == null) return;
    const M = L.fastify, U = d.test(this.version);
    if (!(U === !0 && t.gt(this.version, t.coerce(M)) === !0) && M && t.satisfies(this.version, M, { includePrerelease: U }) === !1)
      throw new c(L.name, M, this.version);
  }
  function E(S) {
    const L = g(S);
    if (!L) return;
    const M = L.name;
    if (M)
      return this[n].push(M), M;
  }
  function O(S, L) {
    if (S.constructor.name === "AsyncFunction" && S.length === 3)
      throw new l(L);
  }
  function z(S) {
    const L = E.call(this, S) || p(S);
    return O.call(this, S, L), R.call(this, S), v.call(this, S), m.call(this, S), b(S);
  }
  e.exports = {
    getPluginName: p,
    getFuncPreview: u,
    kRegisteredPlugins: n,
    getDisplayName: h,
    registerPlugin: z
  }, e.exports[s] = {
    shouldSkipOverride: b,
    getMeta: g,
    checkDecorators: v,
    checkDependencies: m
  };
})(h_);
var S_ = h_.exports;
function Xj(e, t) {
  const r = t || Qj();
  return e ? eD(e, r) : r;
}
function Zj(e, t) {
  return e.genReqId(t);
}
function Qj() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let t = 0;
  return function() {
    return t = t + 1 & 2147483647, `req-${t.toString(36)}`;
  };
}
<<<<<<< HEAD
function Z3(e, t) {
=======
function eD(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return function(r) {
    return r.headers[e] || t(r);
  };
}
<<<<<<< HEAD
var ay = {
  getGenReqId: J3,
  reqIdGenFactory: Y3
}, Ya = { exports: {} }, X_ = 12, Q3 = 0, zd = [
=======
var Hd = {
  getGenReqId: Zj,
  reqIdGenFactory: Xj
}, vi = { exports: {} }, iy = 12, tD = 0, ol = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
<<<<<<< HEAD
function ez(e) {
  var t = e.indexOf("%");
  if (t === -1) return e;
  for (var r = e.length, n = "", i = 0, s = 0, o = t, a = X_; t > -1 && t < r; ) {
    var c = Z_(e[t + 1], 4), u = Z_(e[t + 2], 0), l = c | u, f = zd[l];
    if (a = zd[256 + a + f], s = s << 6 | l & zd[364 + f], a === X_)
      n += e.slice(i, o), n += s <= 65535 ? String.fromCharCode(s) : String.fromCharCode(
        55232 + (s >> 10),
        56320 + (s & 1023)
      ), s = 0, i = t + 3, t = o = e.indexOf("%", i);
    else {
      if (a === Q3)
=======
function rD(e) {
  var t = e.indexOf("%");
  if (t === -1) return e;
  for (var r = e.length, n = "", s = 0, i = 0, o = t, a = iy; t > -1 && t < r; ) {
    var c = oy(e[t + 1], 4), f = oy(e[t + 2], 0), l = c | f, d = ol[l];
    if (a = ol[256 + a + d], i = i << 6 | l & ol[364 + d], a === iy)
      n += e.slice(s, o), n += i <= 65535 ? String.fromCharCode(i) : String.fromCharCode(
        55232 + (i >> 10),
        56320 + (i & 1023)
      ), i = 0, s = t + 3, t = o = e.indexOf("%", s);
    else {
      if (a === tD)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return null;
      if (t += 3, t < r && e.charCodeAt(t) === 37) continue;
      return null;
    }
  }
<<<<<<< HEAD
  return n + e.slice(i);
}
var tz = {
=======
  return n + e.slice(s);
}
var nD = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
<<<<<<< HEAD
function Z_(e, t) {
  var r = tz[e];
  return r === void 0 ? 255 : r << t;
}
var rz = ez;
const Q_ = rz, eb = /\+/g, F$ = function() {
};
F$.prototype = /* @__PURE__ */ Object.create(null);
function nz(e) {
  const t = new F$();
  if (typeof e != "string")
    return t;
  let r = e.length, n = "", i = "", s = -1, o = -1, a = !1, c = !1, u = !1, l = !1, f = !1, m = 0;
  for (let p = 0; p < r + 1; p++)
    if (m = p !== r ? e.charCodeAt(p) : 38, m === 38) {
      if (f = o > s, f || (o = p), n = e.slice(s + 1, o), f || n.length > 0) {
        u && (n = n.replace(eb, " ")), a && (n = Q_(n) || n), f && (i = e.slice(o + 1, p), l && (i = i.replace(eb, " ")), c && (i = Q_(i) || i));
        const d = t[n];
        d === void 0 ? t[n] = i : d.pop ? d.push(i) : t[n] = [d, i];
      }
      i = "", s = p, o = p, a = !1, c = !1, u = !1, l = !1;
    } else m === 61 ? o <= s ? o = p : c = !0 : m === 43 ? o > s ? l = !0 : u = !0 : m === 37 && (o > s ? c = !0 : a = !0);
  return t;
}
var iz = nz;
const Wr = Array.from(
  { length: 256 },
  (e, t) => "%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase()
), sz = new Int8Array([
=======
function oy(e, t) {
  var r = nD[e];
  return r === void 0 ? 255 : r << t;
}
var sD = rD;
const ay = sD, cy = /\+/g, x_ = function() {
};
x_.prototype = /* @__PURE__ */ Object.create(null);
function iD(e) {
  const t = new x_();
  if (typeof e != "string")
    return t;
  let r = e.length, n = "", s = "", i = -1, o = -1, a = !1, c = !1, f = !1, l = !1, d = !1, g = 0;
  for (let p = 0; p < r + 1; p++)
    if (g = p !== r ? e.charCodeAt(p) : 38, g === 38) {
      if (d = o > i, d || (o = p), n = e.slice(i + 1, o), d || n.length > 0) {
        f && (n = n.replace(cy, " ")), a && (n = ay(n) || n), d && (s = e.slice(o + 1, p), l && (s = s.replace(cy, " ")), c && (s = ay(s) || s));
        const u = t[n];
        u === void 0 ? t[n] = s : u.pop ? u.push(s) : t[n] = [u, s];
      }
      s = "", i = p, o = p, a = !1, c = !1, f = !1, l = !1;
    } else g === 61 ? o <= i ? o = p : c = !0 : g === 43 ? o > i ? l = !0 : f = !0 : g === 37 && (o > i ? c = !0 : a = !0);
  return t;
}
var oD = iD;
const nr = Array.from(
  { length: 256 },
  (e, t) => "%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase()
), aD = new Int8Array([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  // 80 - 95
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
  // 112 - 127
]);
<<<<<<< HEAD
function oz(e) {
  const t = e.length;
  if (t === 0) return "";
  let r = "", n = 0, i = 0;
  e: for (; i < t; i++) {
    let s = e.charCodeAt(i);
    for (; s < 128; ) {
      if (sz[s] !== 1 && (n < i && (r += e.slice(n, i)), n = i + 1, r += Wr[s]), ++i === t) break e;
      s = e.charCodeAt(i);
    }
    if (n < i && (r += e.slice(n, i)), s < 2048) {
      n = i + 1, r += Wr[192 | s >> 6] + Wr[128 | s & 63];
      continue;
    }
    if (s < 55296 || s >= 57344) {
      n = i + 1, r += Wr[224 | s >> 12] + Wr[128 | s >> 6 & 63] + Wr[128 | s & 63];
      continue;
    }
    if (++i, i >= t)
      throw new Error("URI malformed");
    const o = e.charCodeAt(i) & 1023;
    n = i + 1, s = 65536 + ((s & 1023) << 10 | o), r += Wr[240 | s >> 18] + Wr[128 | s >> 12 & 63] + Wr[128 | s >> 6 & 63] + Wr[128 | s & 63];
  }
  return n === 0 ? e : n < t ? r + e.slice(n) : r;
}
var az = { encodeString: oz };
const { encodeString: Ph } = az;
function tb(e) {
  const t = typeof e;
  return t === "string" ? Ph(e) : t === "bigint" ? e.toString() : t === "boolean" ? e ? "true" : "false" : t === "number" && Number.isFinite(e) ? e < 1e21 ? "" + e : Ph("" + e) : "";
}
function cz(e) {
  let t = "";
  if (e === null || typeof e != "object")
    return t;
  const r = "&", n = Object.keys(e), i = n.length;
  let s = 0;
  for (let o = 0; o < i; o++) {
    const a = n[o], c = e[a], u = Ph(a) + "=";
    if (o && (t += r), Array.isArray(c)) {
      s = c.length;
      for (let l = 0; l < s; l++)
        l && (t += r), t += u, t += tb(c[l]);
    } else
      t += u, t += tb(c);
  }
  return t;
}
var lz = cz;
const j$ = iz, U$ = lz, M$ = {
  parse: j$,
  stringify: U$
};
Ya.exports = M$;
Ya.exports.default = M$;
Ya.exports.parse = j$;
Ya.exports.stringify = U$;
var uz = Ya.exports, Zu = { exports: {} }, Ch = { exports: {} }, bn = {}, H$ = {};
Object.defineProperty(H$, "__esModule", { value: !0 });
var q$ = {};
=======
function cD(e) {
  const t = e.length;
  if (t === 0) return "";
  let r = "", n = 0, s = 0;
  e: for (; s < t; s++) {
    let i = e.charCodeAt(s);
    for (; i < 128; ) {
      if (aD[i] !== 1 && (n < s && (r += e.slice(n, s)), n = s + 1, r += nr[i]), ++s === t) break e;
      i = e.charCodeAt(s);
    }
    if (n < s && (r += e.slice(n, s)), i < 2048) {
      n = s + 1, r += nr[192 | i >> 6] + nr[128 | i & 63];
      continue;
    }
    if (i < 55296 || i >= 57344) {
      n = s + 1, r += nr[224 | i >> 12] + nr[128 | i >> 6 & 63] + nr[128 | i & 63];
      continue;
    }
    if (++s, s >= t)
      throw new Error("URI malformed");
    const o = e.charCodeAt(s) & 1023;
    n = s + 1, i = 65536 + ((i & 1023) << 10 | o), r += nr[240 | i >> 18] + nr[128 | i >> 12 & 63] + nr[128 | i >> 6 & 63] + nr[128 | i & 63];
  }
  return n === 0 ? e : n < t ? r + e.slice(n) : r;
}
var lD = { encodeString: cD };
const { encodeString: wu } = lD;
function ly(e) {
  const t = typeof e;
  return t === "string" ? wu(e) : t === "bigint" ? e.toString() : t === "boolean" ? e ? "true" : "false" : t === "number" && Number.isFinite(e) ? e < 1e21 ? "" + e : wu("" + e) : "";
}
function uD(e) {
  let t = "";
  if (e === null || typeof e != "object")
    return t;
  const r = "&", n = Object.keys(e), s = n.length;
  let i = 0;
  for (let o = 0; o < s; o++) {
    const a = n[o], c = e[a], f = wu(a) + "=";
    if (o && (t += r), Array.isArray(c)) {
      i = c.length;
      for (let l = 0; l < i; l++)
        l && (t += r), t += f, t += ly(c[l]);
    } else
      t += f, t += ly(c);
  }
  return t;
}
var fD = uD;
const w_ = oD, R_ = fD, $_ = {
  parse: w_,
  stringify: R_
};
vi.exports = $_;
vi.exports.default = $_;
vi.exports.parse = w_;
vi.exports.stringify = R_;
var dD = vi.exports, Aa = { exports: {} }, Ru = { exports: {} }, wr = {}, T_ = {};
Object.defineProperty(T_, "__esModule", { value: !0 });
var O_ = {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.types = void 0, function(t) {
    t[t.ROOT = 0] = "ROOT", t[t.GROUP = 1] = "GROUP", t[t.POSITION = 2] = "POSITION", t[t.SET = 3] = "SET", t[t.RANGE = 4] = "RANGE", t[t.REPETITION = 5] = "REPETITION", t[t.REFERENCE = 6] = "REFERENCE", t[t.CHAR = 7] = "CHAR";
  }(e.types || (e.types = {}));
<<<<<<< HEAD
})(q$);
var B$ = {};
Object.defineProperty(B$, "__esModule", { value: !0 });
(function(e) {
  var t = me && me.__createBinding || (Object.create ? function(n, i, s, o) {
    o === void 0 && (o = s), Object.defineProperty(n, o, { enumerable: !0, get: function() {
      return i[s];
    } });
  } : function(n, i, s, o) {
    o === void 0 && (o = s), n[o] = i[s];
  }), r = me && me.__exportStar || function(n, i) {
    for (var s in n) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, n, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(H$, e), r(q$, e), r(B$, e);
})(bn);
var ca = {}, Bs = {}, wt = {};
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.anyChar = wt.notWhitespace = wt.whitespace = wt.notInts = wt.ints = wt.notWords = wt.words = void 0;
const ke = bn, z$ = () => [{ type: ke.types.RANGE, from: 48, to: 57 }], V$ = () => [
  { type: ke.types.CHAR, value: 95 },
  { type: ke.types.RANGE, from: 97, to: 122 },
  { type: ke.types.RANGE, from: 65, to: 90 },
  { type: ke.types.RANGE, from: 48, to: 57 }
], G$ = () => [
  { type: ke.types.CHAR, value: 9 },
  { type: ke.types.CHAR, value: 10 },
  { type: ke.types.CHAR, value: 11 },
  { type: ke.types.CHAR, value: 12 },
  { type: ke.types.CHAR, value: 13 },
  { type: ke.types.CHAR, value: 32 },
  { type: ke.types.CHAR, value: 160 },
  { type: ke.types.CHAR, value: 5760 },
  { type: ke.types.RANGE, from: 8192, to: 8202 },
  { type: ke.types.CHAR, value: 8232 },
  { type: ke.types.CHAR, value: 8233 },
  { type: ke.types.CHAR, value: 8239 },
  { type: ke.types.CHAR, value: 8287 },
  { type: ke.types.CHAR, value: 12288 },
  { type: ke.types.CHAR, value: 65279 }
], fz = () => [
  { type: ke.types.CHAR, value: 10 },
  { type: ke.types.CHAR, value: 13 },
  { type: ke.types.CHAR, value: 8232 },
  { type: ke.types.CHAR, value: 8233 }
];
wt.words = () => ({ type: ke.types.SET, set: V$(), not: !1 });
wt.notWords = () => ({ type: ke.types.SET, set: V$(), not: !0 });
wt.ints = () => ({ type: ke.types.SET, set: z$(), not: !1 });
wt.notInts = () => ({ type: ke.types.SET, set: z$(), not: !0 });
wt.whitespace = () => ({ type: ke.types.SET, set: G$(), not: !1 });
wt.notWhitespace = () => ({ type: ke.types.SET, set: G$(), not: !0 });
wt.anyChar = () => ({ type: ke.types.SET, set: fz(), not: !0 });
var dz = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
=======
})(O_);
var C_ = {};
Object.defineProperty(C_, "__esModule", { value: !0 });
(function(e) {
  var t = _e && _e.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i), Object.defineProperty(n, o, { enumerable: !0, get: function() {
      return s[i];
    } });
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), r = _e && _e.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && t(s, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(T_, e), r(O_, e), r(C_, e);
})(wr);
var Gs = {}, Xn = {}, st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.anyChar = st.notWhitespace = st.whitespace = st.notInts = st.ints = st.notWords = st.words = void 0;
const Re = wr, P_ = () => [{ type: Re.types.RANGE, from: 48, to: 57 }], I_ = () => [
  { type: Re.types.CHAR, value: 95 },
  { type: Re.types.RANGE, from: 97, to: 122 },
  { type: Re.types.RANGE, from: 65, to: 90 },
  { type: Re.types.RANGE, from: 48, to: 57 }
], N_ = () => [
  { type: Re.types.CHAR, value: 9 },
  { type: Re.types.CHAR, value: 10 },
  { type: Re.types.CHAR, value: 11 },
  { type: Re.types.CHAR, value: 12 },
  { type: Re.types.CHAR, value: 13 },
  { type: Re.types.CHAR, value: 32 },
  { type: Re.types.CHAR, value: 160 },
  { type: Re.types.CHAR, value: 5760 },
  { type: Re.types.RANGE, from: 8192, to: 8202 },
  { type: Re.types.CHAR, value: 8232 },
  { type: Re.types.CHAR, value: 8233 },
  { type: Re.types.CHAR, value: 8239 },
  { type: Re.types.CHAR, value: 8287 },
  { type: Re.types.CHAR, value: 12288 },
  { type: Re.types.CHAR, value: 65279 }
], pD = () => [
  { type: Re.types.CHAR, value: 10 },
  { type: Re.types.CHAR, value: 13 },
  { type: Re.types.CHAR, value: 8232 },
  { type: Re.types.CHAR, value: 8233 }
];
st.words = () => ({ type: Re.types.SET, set: I_(), not: !1 });
st.notWords = () => ({ type: Re.types.SET, set: I_(), not: !0 });
st.ints = () => ({ type: Re.types.SET, set: P_(), not: !1 });
st.notInts = () => ({ type: Re.types.SET, set: P_(), not: !0 });
st.whitespace = () => ({ type: Re.types.SET, set: N_(), not: !1 });
st.notWhitespace = () => ({ type: Re.types.SET, set: N_(), not: !0 });
st.anyChar = () => ({ type: Re.types.SET, set: pD(), not: !0 });
var hD = _e && _e.__createBinding || (Object.create ? function(e, t, r, n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
<<<<<<< HEAD
}), pz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), hz = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && dz(t, e, r);
  return pz(t, e), t;
};
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.tokenizeClass = Bs.strToChars = void 0;
const rb = bn, ss = hz(wt), mz = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
Bs.strToChars = (e) => {
  const t = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
  return e.replace(t, (r, n, i, s, o, a, c) => {
    if (i)
      return r;
    let u = n ? 8 : s ? parseInt(s, 16) : o ? parseInt(o, 16) : a ? mz.indexOf(a) : {
=======
}), mD = _e && _e.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), yD = _e && _e.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && hD(t, e, r);
  return mD(t, e), t;
};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.tokenizeClass = Xn.strToChars = void 0;
const uy = wr, On = yD(st), gD = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
Xn.strToChars = (e) => {
  const t = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
  return e.replace(t, (r, n, s, i, o, a, c) => {
    if (s)
      return r;
    let f = n ? 8 : i ? parseInt(i, 16) : o ? parseInt(o, 16) : a ? gD.indexOf(a) : {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      0: 0,
      t: 9,
      n: 10,
      v: 11,
      f: 12,
      r: 13
<<<<<<< HEAD
    }[c], l = String.fromCharCode(u);
    return /[[\]{}^$.|?*+()]/.test(l) ? `\\${l}` : l;
  });
};
Bs.tokenizeClass = (e, t) => {
  var r, n, i, s, o, a, c;
  let u = [], l, f;
  const m = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (l = m.exec(e)) !== null; ) {
    const p = (c = (a = (o = (s = (i = (n = (r = l[1] && ss.words()) !== null && r !== void 0 ? r : l[2] && ss.ints()) !== null && n !== void 0 ? n : l[3] && ss.whitespace()) !== null && i !== void 0 ? i : l[4] && ss.notWords()) !== null && s !== void 0 ? s : l[5] && ss.notInts()) !== null && o !== void 0 ? o : l[6] && ss.notWhitespace()) !== null && a !== void 0 ? a : l[7] && {
      type: rb.types.RANGE,
      from: (l[8] || l[9]).charCodeAt(0),
      to: (f = l[10]).charCodeAt(f.length - 1)
    }) !== null && c !== void 0 ? c : (f = l[16]) && { type: rb.types.CHAR, value: f.charCodeAt(0) };
    if (p)
      u.push(p);
    else
      return [u, m.lastIndex];
  }
  throw new SyntaxError(`Invalid regular expression: /${t}/: Unterminated character class`);
};
var gz = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
=======
    }[c], l = String.fromCharCode(f);
    return /[[\]{}^$.|?*+()]/.test(l) ? `\\${l}` : l;
  });
};
Xn.tokenizeClass = (e, t) => {
  var r, n, s, i, o, a, c;
  let f = [], l, d;
  const g = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (l = g.exec(e)) !== null; ) {
    const p = (c = (a = (o = (i = (s = (n = (r = l[1] && On.words()) !== null && r !== void 0 ? r : l[2] && On.ints()) !== null && n !== void 0 ? n : l[3] && On.whitespace()) !== null && s !== void 0 ? s : l[4] && On.notWords()) !== null && i !== void 0 ? i : l[5] && On.notInts()) !== null && o !== void 0 ? o : l[6] && On.notWhitespace()) !== null && a !== void 0 ? a : l[7] && {
      type: uy.types.RANGE,
      from: (l[8] || l[9]).charCodeAt(0),
      to: (d = l[10]).charCodeAt(d.length - 1)
    }) !== null && c !== void 0 ? c : (d = l[16]) && { type: uy.types.CHAR, value: d.charCodeAt(0) };
    if (p)
      f.push(p);
    else
      return [f, g.lastIndex];
  }
  throw new SyntaxError(`Invalid regular expression: /${t}/: Unterminated character class`);
};
var vD = _e && _e.__createBinding || (Object.create ? function(e, t, r, n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
<<<<<<< HEAD
}), yz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), W$ = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && gz(t, e, r);
  return yz(t, e), t;
};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.tokenizer = void 0;
const nb = W$(Bs), Ct = bn, hi = W$(wt), vz = /^[a-zA-Z_$]$/i, _z = /^[a-zA-Z0-9_$]$/i, ib = /\d/;
ca.tokenizer = (e) => {
  let t = 0, r, n = { type: Ct.types.ROOT, stack: [] }, i = n, s = n.stack, o = [], a = [], c = 0;
  const u = (f) => {
    throw new SyntaxError(`Invalid regular expression: /${e}/: Nothing to repeat at column ${f - 1}`);
  };
  let l = nb.strToChars(e);
=======
}), bD = _e && _e.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), A_ = _e && _e.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && vD(t, e, r);
  return bD(t, e), t;
};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.tokenizer = void 0;
const fy = A_(Xn), lt = wr, Kr = A_(st), _D = /^[a-zA-Z_$]$/i, ED = /^[a-zA-Z0-9_$]$/i, dy = /\d/;
Gs.tokenizer = (e) => {
  let t = 0, r, n = { type: lt.types.ROOT, stack: [] }, s = n, i = n.stack, o = [], a = [], c = 0;
  const f = (d) => {
    throw new SyntaxError(`Invalid regular expression: /${e}/: Nothing to repeat at column ${d - 1}`);
  };
  let l = fy.strToChars(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  for (; t < l.length; )
    switch (r = l[t++]) {
      case "\\":
        if (t === l.length)
          throw new SyntaxError(`Invalid regular expression: /${e}/: \\ at end of pattern`);
        switch (r = l[t++]) {
          case "b":
<<<<<<< HEAD
            s.push({ type: Ct.types.POSITION, value: "b" });
            break;
          case "B":
            s.push({ type: Ct.types.POSITION, value: "B" });
            break;
          case "w":
            s.push(hi.words());
            break;
          case "W":
            s.push(hi.notWords());
            break;
          case "d":
            s.push(hi.ints());
            break;
          case "D":
            s.push(hi.notInts());
            break;
          case "s":
            s.push(hi.whitespace());
            break;
          case "S":
            s.push(hi.notWhitespace());
            break;
          default:
            if (ib.test(r)) {
              let f = r;
              for (; t < l.length && ib.test(l[t]); )
                f += l[t++];
              let m = parseInt(f, 10);
              const p = { type: Ct.types.REFERENCE, value: m };
              s.push(p), a.push({ reference: p, stack: s, index: s.length - 1 });
            } else
              s.push({ type: Ct.types.CHAR, value: r.charCodeAt(0) });
        }
        break;
      case "^":
        s.push({ type: Ct.types.POSITION, value: "^" });
        break;
      case "$":
        s.push({ type: Ct.types.POSITION, value: "$" });
        break;
      case "[": {
        let f;
        l[t] === "^" ? (f = !0, t++) : f = !1;
        let m = nb.tokenizeClass(l.slice(t), e);
        t += m[1], s.push({
          type: Ct.types.SET,
          set: m[0],
          not: f
=======
            i.push({ type: lt.types.POSITION, value: "b" });
            break;
          case "B":
            i.push({ type: lt.types.POSITION, value: "B" });
            break;
          case "w":
            i.push(Kr.words());
            break;
          case "W":
            i.push(Kr.notWords());
            break;
          case "d":
            i.push(Kr.ints());
            break;
          case "D":
            i.push(Kr.notInts());
            break;
          case "s":
            i.push(Kr.whitespace());
            break;
          case "S":
            i.push(Kr.notWhitespace());
            break;
          default:
            if (dy.test(r)) {
              let d = r;
              for (; t < l.length && dy.test(l[t]); )
                d += l[t++];
              let g = parseInt(d, 10);
              const p = { type: lt.types.REFERENCE, value: g };
              i.push(p), a.push({ reference: p, stack: i, index: i.length - 1 });
            } else
              i.push({ type: lt.types.CHAR, value: r.charCodeAt(0) });
        }
        break;
      case "^":
        i.push({ type: lt.types.POSITION, value: "^" });
        break;
      case "$":
        i.push({ type: lt.types.POSITION, value: "$" });
        break;
      case "[": {
        let d;
        l[t] === "^" ? (d = !0, t++) : d = !1;
        let g = fy.tokenizeClass(l.slice(t), e);
        t += g[1], i.push({
          type: lt.types.SET,
          set: g[0],
          not: d
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
        break;
      }
      case ".":
<<<<<<< HEAD
        s.push(hi.anyChar());
        break;
      case "(": {
        let f = {
          type: Ct.types.GROUP,
=======
        i.push(Kr.anyChar());
        break;
      case "(": {
        let d = {
          type: lt.types.GROUP,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          stack: [],
          remember: !0
        };
        if (l[t] === "?")
          if (r = l[t + 1], t += 2, r === "=")
<<<<<<< HEAD
            f.followedBy = !0, f.remember = !1;
          else if (r === "!")
            f.notFollowedBy = !0, f.remember = !1;
          else if (r === "<") {
            let m = "";
            if (vz.test(l[t]))
              m += l[t], t++;
            else
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            for (; t < l.length && _z.test(l[t]); )
              m += l[t], t++;
            if (!m)
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            if (l[t] !== ">")
              throw new SyntaxError(`Invalid regular expression: /${e}/: Unclosed capture group name, expected '>', found '${l[t]}' at column ${t + 1}`);
            f.name = m, t++;
          } else if (r === ":")
            f.remember = !1;
=======
            d.followedBy = !0, d.remember = !1;
          else if (r === "!")
            d.notFollowedBy = !0, d.remember = !1;
          else if (r === "<") {
            let g = "";
            if (_D.test(l[t]))
              g += l[t], t++;
            else
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            for (; t < l.length && ED.test(l[t]); )
              g += l[t], t++;
            if (!g)
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            if (l[t] !== ">")
              throw new SyntaxError(`Invalid regular expression: /${e}/: Unclosed capture group name, expected '>', found '${l[t]}' at column ${t + 1}`);
            d.name = g, t++;
          } else if (r === ":")
            d.remember = !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          else
            throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid group, character '${r}' after '?' at column ${t - 1}`);
        else
          c += 1;
<<<<<<< HEAD
        s.push(f), o.push(i), i = f, s = f.stack;
=======
        i.push(d), o.push(s), s = d, i = d.stack;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        break;
      }
      case ")":
        if (o.length === 0)
          throw new SyntaxError(`Invalid regular expression: /${e}/: Unmatched ) at column ${t - 1}`);
<<<<<<< HEAD
        i = o.pop(), s = i.options ? i.options[i.options.length - 1] : i.stack;
        break;
      case "|": {
        i.options || (i.options = [i.stack], delete i.stack);
        let f = [];
        i.options.push(f), s = f;
        break;
      }
      case "{": {
        let f = /^(\d+)(,(\d+)?)?\}/.exec(l.slice(t)), m, p;
        f !== null ? (s.length === 0 && u(t), m = parseInt(f[1], 10), p = f[2] ? f[3] ? parseInt(f[3], 10) : 1 / 0 : m, t += f[0].length, s.push({
          type: Ct.types.REPETITION,
          min: m,
          max: p,
          value: s.pop()
        })) : s.push({
          type: Ct.types.CHAR,
=======
        s = o.pop(), i = s.options ? s.options[s.options.length - 1] : s.stack;
        break;
      case "|": {
        s.options || (s.options = [s.stack], delete s.stack);
        let d = [];
        s.options.push(d), i = d;
        break;
      }
      case "{": {
        let d = /^(\d+)(,(\d+)?)?\}/.exec(l.slice(t)), g, p;
        d !== null ? (i.length === 0 && f(t), g = parseInt(d[1], 10), p = d[2] ? d[3] ? parseInt(d[3], 10) : 1 / 0 : g, t += d[0].length, i.push({
          type: lt.types.REPETITION,
          min: g,
          max: p,
          value: i.pop()
        })) : i.push({
          type: lt.types.CHAR,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          value: 123
        });
        break;
      }
      case "?":
<<<<<<< HEAD
        s.length === 0 && u(t), s.push({
          type: Ct.types.REPETITION,
          min: 0,
          max: 1,
          value: s.pop()
        });
        break;
      case "+":
        s.length === 0 && u(t), s.push({
          type: Ct.types.REPETITION,
          min: 1,
          max: 1 / 0,
          value: s.pop()
        });
        break;
      case "*":
        s.length === 0 && u(t), s.push({
          type: Ct.types.REPETITION,
          min: 0,
          max: 1 / 0,
          value: s.pop()
        });
        break;
      default:
        s.push({
          type: Ct.types.CHAR,
=======
        i.length === 0 && f(t), i.push({
          type: lt.types.REPETITION,
          min: 0,
          max: 1,
          value: i.pop()
        });
        break;
      case "+":
        i.length === 0 && f(t), i.push({
          type: lt.types.REPETITION,
          min: 1,
          max: 1 / 0,
          value: i.pop()
        });
        break;
      case "*":
        i.length === 0 && f(t), i.push({
          type: lt.types.REPETITION,
          min: 0,
          max: 1 / 0,
          value: i.pop()
        });
        break;
      default:
        i.push({
          type: lt.types.CHAR,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          value: r.charCodeAt(0)
        });
    }
  if (o.length !== 0)
    throw new SyntaxError(`Invalid regular expression: /${e}/: Unterminated group`);
<<<<<<< HEAD
  return bz(a, c), n;
};
function bz(e, t) {
  for (const r of e.reverse())
    if (t < r.reference.value) {
      r.reference.type = Ct.types.CHAR;
      const n = r.reference.value.toString();
      if (r.reference.value = parseInt(n, 8), !/^[0-7]+$/.test(n)) {
        let i = 0;
        for (; n[i] !== "8" && n[i] !== "9"; )
          i += 1;
        if (i === 0 ? (r.reference.value = n.charCodeAt(0), i += 1) : r.reference.value = parseInt(n.slice(0, i), 8), n.length > i) {
          const s = r.stack.splice(r.index + 1);
          for (const o of n.slice(i))
            r.stack.push({
              type: Ct.types.CHAR,
              value: o.charCodeAt(0)
            });
          r.stack.push(...s);
=======
  return SD(a, c), n;
};
function SD(e, t) {
  for (const r of e.reverse())
    if (t < r.reference.value) {
      r.reference.type = lt.types.CHAR;
      const n = r.reference.value.toString();
      if (r.reference.value = parseInt(n, 8), !/^[0-7]+$/.test(n)) {
        let s = 0;
        for (; n[s] !== "8" && n[s] !== "9"; )
          s += 1;
        if (s === 0 ? (r.reference.value = n.charCodeAt(0), s += 1) : r.reference.value = parseInt(n.slice(0, s), 8), n.length > s) {
          const i = r.stack.splice(r.index + 1);
          for (const o of n.slice(s))
            r.stack.push({
              type: lt.types.CHAR,
              value: o.charCodeAt(0)
            });
          r.stack.push(...i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
    }
}
<<<<<<< HEAD
var Ah = {}, zs = {}, en = {}, Ez = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
=======
var $u = {}, Zn = {}, ur = {}, xD = _e && _e.__createBinding || (Object.create ? function(e, t, r, n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
<<<<<<< HEAD
}), wz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), Sz = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Ez(t, e, r);
  return wz(t, e), t;
};
Object.defineProperty(en, "__esModule", { value: !0 });
en.NOTANYCHAR = en.WHITESPACE = en.WORDS = en.INTS = void 0;
const Qu = Sz(wt), sb = bn;
function ef(e) {
  let t = {}, r = 0;
  for (const n of e)
    n.type === sb.types.CHAR && (t[n.value] = !0), n.type === sb.types.RANGE && (t[`${n.from}-${n.to}`] = !0), r += 1;
=======
}), wD = _e && _e.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), RD = _e && _e.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && xD(t, e, r);
  return wD(t, e), t;
};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.NOTANYCHAR = ur.WHITESPACE = ur.WORDS = ur.INTS = void 0;
const ka = RD(st), py = wr;
function La(e) {
  let t = {}, r = 0;
  for (const n of e)
    n.type === py.types.CHAR && (t[n.value] = !0), n.type === py.types.RANGE && (t[`${n.from}-${n.to}`] = !0), r += 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    lookup: () => Object.assign({}, t),
    len: r
  };
}
<<<<<<< HEAD
en.INTS = ef(Qu.ints().set);
en.WORDS = ef(Qu.words().set);
en.WHITESPACE = ef(Qu.whitespace().set);
en.NOTANYCHAR = ef(Qu.anyChar().set);
var xz = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
=======
ur.INTS = La(ka.ints().set);
ur.WORDS = La(ka.words().set);
ur.WHITESPACE = La(ka.whitespace().set);
ur.NOTANYCHAR = La(ka.anyChar().set);
var $D = _e && _e.__createBinding || (Object.create ? function(e, t, r, n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
<<<<<<< HEAD
}), Rz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), $z = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && xz(t, e, r);
  return Rz(t, e), t;
};
Object.defineProperty(zs, "__esModule", { value: !0 });
zs.writeSetTokens = zs.setChar = void 0;
const Yl = bn, Bc = $z(en);
function bl(e) {
  return e === 94 ? "\\^" : e === 92 ? "\\\\" : e === 93 ? "\\]" : e === 45 ? "\\-" : String.fromCharCode(e);
}
zs.setChar = bl;
function zc(e, { lookup: t, len: r }) {
  if (r !== e.length)
    return !1;
  const n = t();
  for (const i of e) {
    if (i.type === Yl.types.SET)
      return !1;
    const s = i.type === Yl.types.CHAR ? i.value : `${i.from}-${i.to}`;
    if (n[s])
      n[s] = !1;
=======
}), TD = _e && _e.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), OD = _e && _e.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && $D(t, e, r);
  return TD(t, e), t;
};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.writeSetTokens = Zn.setChar = void 0;
const Go = wr, Yi = OD(ur);
function Eo(e) {
  return e === 94 ? "\\^" : e === 92 ? "\\\\" : e === 93 ? "\\]" : e === 45 ? "\\-" : String.fromCharCode(e);
}
Zn.setChar = Eo;
function Xi(e, { lookup: t, len: r }) {
  if (r !== e.length)
    return !1;
  const n = t();
  for (const s of e) {
    if (s.type === Go.types.SET)
      return !1;
    const i = s.type === Go.types.CHAR ? s.value : `${s.from}-${s.to}`;
    if (n[i])
      n[i] = !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    else
      return !1;
  }
  return !0;
}
<<<<<<< HEAD
function K$(e, t = !1) {
  if (zc(e.set, Bc.INTS))
    return e.not ? "\\D" : "\\d";
  if (zc(e.set, Bc.WORDS))
    return e.not ? "\\W" : "\\w";
  if (e.not && zc(e.set, Bc.NOTANYCHAR))
    return ".";
  if (zc(e.set, Bc.WHITESPACE))
    return e.not ? "\\S" : "\\s";
  let r = "";
  for (let i = 0; i < e.set.length; i++) {
    const s = e.set[i];
    r += Tz(s);
=======
function k_(e, t = !1) {
  if (Xi(e.set, Yi.INTS))
    return e.not ? "\\D" : "\\d";
  if (Xi(e.set, Yi.WORDS))
    return e.not ? "\\W" : "\\w";
  if (e.not && Xi(e.set, Yi.NOTANYCHAR))
    return ".";
  if (Xi(e.set, Yi.WHITESPACE))
    return e.not ? "\\S" : "\\s";
  let r = "";
  for (let s = 0; s < e.set.length; s++) {
    const i = e.set[s];
    r += CD(i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  const n = `${e.not ? "^" : ""}${r}`;
  return t ? n : `[${n}]`;
}
<<<<<<< HEAD
zs.writeSetTokens = K$;
function Tz(e) {
  return e.type === Yl.types.CHAR ? bl(e.value) : e.type === Yl.types.RANGE ? `${bl(e.from)}-${bl(e.to)}` : K$(e, !0);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reconstruct = void 0;
  const t = bn, r = zs, n = (s) => s.map(e.reconstruct).join(""), i = (s) => {
    if ("options" in s)
      return s.options.map(n).join("|");
    if ("stack" in s)
      return n(s.stack);
    throw new Error("options or stack must be Root or Group token");
  };
  e.reconstruct = (s) => {
    switch (s.type) {
      case t.types.ROOT:
        return i(s);
      case t.types.CHAR: {
        const o = String.fromCharCode(s.value);
        return (/[[\\{}$^.|?*+()]/.test(o) ? "\\" : "") + o;
      }
      case t.types.POSITION:
        return s.value === "^" || s.value === "$" ? s.value : `\\${s.value}`;
      case t.types.REFERENCE:
        return `\\${s.value}`;
      case t.types.SET:
        return r.writeSetTokens(s);
      case t.types.GROUP:
        return `(${s.name ? `?<${s.name}>` : s.remember ? "" : s.followedBy ? "?=" : s.notFollowedBy ? "?!" : "?:"}${i(s)})`;
      case t.types.REPETITION: {
        const { min: o, max: a } = s;
        let c;
        return o === 0 && a === 1 ? c = "?" : o === 1 && a === 1 / 0 ? c = "+" : o === 0 && a === 1 / 0 ? c = "*" : a === 1 / 0 ? c = `{${o},}` : o === a ? c = `{${o}}` : c = `{${o},${a}}`, `${e.reconstruct(s.value)}${c}`;
      }
      case t.types.RANGE:
        return `${r.setChar(s.from)}-${r.setChar(s.to)}`;
      default:
        throw new Error(`Invalid token type ${s}`);
    }
  };
})(Ah);
(function(e, t) {
  var r = me && me.__createBinding || (Object.create ? function(a, c, u, l) {
    l === void 0 && (l = u), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return c[u];
    } });
  } : function(a, c, u, l) {
    l === void 0 && (l = u), a[l] = c[u];
  }), n = me && me.__exportStar || function(a, c) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(c, u) && r(c, a, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.types = void 0;
  const i = bn;
  Object.defineProperty(t, "types", { enumerable: !0, get: function() {
    return i.types;
  } }), n(ca, t), n(Ah, t);
  const s = ca, o = Ah;
  n(bn, t), t.default = s.tokenizer, e.exports = s.tokenizer, e.exports.types = i.types, e.exports.reconstruct = o.reconstruct;
})(Ch, Ch.exports);
var Oz = Ch.exports;
const Y$ = Oz, Pz = Y$.types;
function cy(e, t) {
  t || (t = {});
  const r = t.limit === void 0 ? 25 : t.limit;
  Cz(e) ? e = e.source : typeof e != "string" && (e = String(e));
  try {
    e = Y$(e);
=======
Zn.writeSetTokens = k_;
function CD(e) {
  return e.type === Go.types.CHAR ? Eo(e.value) : e.type === Go.types.RANGE ? `${Eo(e.from)}-${Eo(e.to)}` : k_(e, !0);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reconstruct = void 0;
  const t = wr, r = Zn, n = (i) => i.map(e.reconstruct).join(""), s = (i) => {
    if ("options" in i)
      return i.options.map(n).join("|");
    if ("stack" in i)
      return n(i.stack);
    throw new Error("options or stack must be Root or Group token");
  };
  e.reconstruct = (i) => {
    switch (i.type) {
      case t.types.ROOT:
        return s(i);
      case t.types.CHAR: {
        const o = String.fromCharCode(i.value);
        return (/[[\\{}$^.|?*+()]/.test(o) ? "\\" : "") + o;
      }
      case t.types.POSITION:
        return i.value === "^" || i.value === "$" ? i.value : `\\${i.value}`;
      case t.types.REFERENCE:
        return `\\${i.value}`;
      case t.types.SET:
        return r.writeSetTokens(i);
      case t.types.GROUP:
        return `(${i.name ? `?<${i.name}>` : i.remember ? "" : i.followedBy ? "?=" : i.notFollowedBy ? "?!" : "?:"}${s(i)})`;
      case t.types.REPETITION: {
        const { min: o, max: a } = i;
        let c;
        return o === 0 && a === 1 ? c = "?" : o === 1 && a === 1 / 0 ? c = "+" : o === 0 && a === 1 / 0 ? c = "*" : a === 1 / 0 ? c = `{${o},}` : o === a ? c = `{${o}}` : c = `{${o},${a}}`, `${e.reconstruct(i.value)}${c}`;
      }
      case t.types.RANGE:
        return `${r.setChar(i.from)}-${r.setChar(i.to)}`;
      default:
        throw new Error(`Invalid token type ${i}`);
    }
  };
})($u);
(function(e, t) {
  var r = _e && _e.__createBinding || (Object.create ? function(a, c, f, l) {
    l === void 0 && (l = f), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return c[f];
    } });
  } : function(a, c, f, l) {
    l === void 0 && (l = f), a[l] = c[f];
  }), n = _e && _e.__exportStar || function(a, c) {
    for (var f in a) f !== "default" && !Object.prototype.hasOwnProperty.call(c, f) && r(c, a, f);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.types = void 0;
  const s = wr;
  Object.defineProperty(t, "types", { enumerable: !0, get: function() {
    return s.types;
  } }), n(Gs, t), n($u, t);
  const i = Gs, o = $u;
  n(wr, t), t.default = i.tokenizer, e.exports = i.tokenizer, e.exports.types = s.types, e.exports.reconstruct = o.reconstruct;
})(Ru, Ru.exports);
var PD = Ru.exports;
const L_ = PD, ID = L_.types;
function Bd(e, t) {
  t || (t = {});
  const r = t.limit === void 0 ? 25 : t.limit;
  ND(e) ? e = e.source : typeof e != "string" && (e = String(e));
  try {
    e = L_(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  } catch {
    return !1;
  }
  let n = 0;
<<<<<<< HEAD
  return function i(s, o) {
    var f;
    let a, c, u;
    if (s.type === Pz.REPETITION && (o++, n++, o > 1 || n > r))
      return !1;
    if (s.options) {
      for (a = 0, u = s.options.length; a < u; a++)
        if (c = i({ stack: s.options[a] }, o), !c) return !1;
    }
    const l = s.stack || ((f = s.value) == null ? void 0 : f.stack);
    if (!l) return !0;
    for (a = 0; a < l.length; a++)
      if (c = i(l[a], o), !c) return !1;
    return !0;
  }(e, 0);
}
function Cz(e) {
  return {}.toString.call(e) === "[object RegExp]";
}
Zu.exports = cy;
Zu.exports.default = cy;
Zu.exports.safeRegex = cy;
var Az = Zu.exports, ly = {
=======
  return function s(i, o) {
    var d;
    let a, c, f;
    if (i.type === ID.REPETITION && (o++, n++, o > 1 || n > r))
      return !1;
    if (i.options) {
      for (a = 0, f = i.options.length; a < f; a++)
        if (c = s({ stack: i.options[a] }, o), !c) return !1;
    }
    const l = i.stack || ((d = i.value) == null ? void 0 : d.stack);
    if (!l) return !0;
    for (a = 0; a < l.length; a++)
      if (c = s(l[a], o), !c) return !1;
    return !0;
  }(e, 0);
}
function ND(e) {
  return {}.toString.call(e) === "[object RegExp]";
}
Aa.exports = Bd;
Aa.exports.default = Bd;
Aa.exports.safeRegex = Bd;
var AD = Aa.exports, Vd = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  name: "__fmw_internal_strategy_merged_tree_http_method__",
  storage: function() {
    const e = /* @__PURE__ */ new Map();
    return {
      get: (t) => e.get(t) || null,
      set: (t, r) => {
        e.set(t, r);
      }
    };
  },
  /* c8 ignore next 1 */
  deriveConstraint: (e) => e.method,
  mustMatchWhenDerived: !0
};
<<<<<<< HEAD
const ob = ju, ab = ly, J$ = Symbol("treeData");
function X$(e, t = "") {
  let r = "";
  const n = Object.keys(e);
  for (let i = 0; i < n.length; i++) {
    const s = n[i], o = e[s], a = i === n.length - 1, c = a ? "└── " : "├── ", u = a ? "    " : "│   ", f = (o[J$] || "").replaceAll(`
`, `
` + t + u);
    r += t + c + s + f + `
`, r += X$(o, t + u);
  }
  return r;
}
function Iz(e) {
  let t = e.name || "";
  return t = t.replace("bound", "").trim(), t = (t || "anonymous") + "()", t;
}
function Z$(e) {
  return Array.isArray(e) ? e.map((t) => Z$(t)) : typeof e == "symbol" ? e.toString() : typeof e == "function" ? Iz(e) : e;
}
function Nz(e, t) {
  if (!t.includeMeta) return {};
  const r = t.buildPrettyMeta(e), n = {};
  let i = t.includeMeta;
  Array.isArray(i) || (i = Reflect.ownKeys(r));
  for (const s of i) {
    if (!Object.prototype.hasOwnProperty.call(r, s)) continue;
    const o = s.toString(), a = r[s];
    if (a != null) {
      const c = JSON.stringify(Z$(a));
=======
const hy = ba, my = Vd, j_ = Symbol("treeData");
function D_(e, t = "") {
  let r = "";
  const n = Object.keys(e);
  for (let s = 0; s < n.length; s++) {
    const i = n[s], o = e[i], a = s === n.length - 1, c = a ? "└── " : "├── ", f = a ? "    " : "│   ", d = (o[j_] || "").replaceAll(`
`, `
` + t + f);
    r += t + c + i + d + `
`, r += D_(o, t + f);
  }
  return r;
}
function kD(e) {
  let t = e.name || "";
  return t = t.replace("bound", "").trim(), t = (t || "anonymous") + "()", t;
}
function F_(e) {
  return Array.isArray(e) ? e.map((t) => F_(t)) : typeof e == "symbol" ? e.toString() : typeof e == "function" ? kD(e) : e;
}
function LD(e, t) {
  if (!t.includeMeta) return {};
  const r = t.buildPrettyMeta(e), n = {};
  let s = t.includeMeta;
  Array.isArray(s) || (s = Reflect.ownKeys(r));
  for (const i of s) {
    if (!Object.prototype.hasOwnProperty.call(r, i)) continue;
    const o = i.toString(), a = r[i];
    if (a != null) {
      const c = JSON.stringify(F_(a));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      n[o] = c;
    }
  }
  return n;
}
<<<<<<< HEAD
function kz(e) {
=======
function jD(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let t = "";
  for (const [r, n] of Object.entries(e))
    t += `
• (${r}) ${n}`;
  return t;
}
<<<<<<< HEAD
function Dz(e) {
  const t = { ...e.opts.constraints }, r = t[ab.name];
  return delete t[ab.name], { ...e, method: r, opts: { constraints: t } };
}
function Lz(e) {
  let t = ` (${e.method})`;
  const r = e.opts.constraints || {};
  return Object.keys(r).length !== 0 && (t += " " + JSON.stringify(r)), t += kz(e.metaData), t;
}
function Fz(e) {
  return e.reduce((t, r) => {
    for (const n of t)
      if (ob(r.opts.constraints, n.opts.constraints) && ob(r.metaData, n.metaData))
=======
function DD(e) {
  const t = { ...e.opts.constraints }, r = t[my.name];
  return delete t[my.name], { ...e, method: r, opts: { constraints: t } };
}
function FD(e) {
  let t = ` (${e.method})`;
  const r = e.opts.constraints || {};
  return Object.keys(r).length !== 0 && (t += " " + JSON.stringify(r)), t += jD(e.metaData), t;
}
function MD(e) {
  return e.reduce((t, r) => {
    for (const n of t)
      if (hy(r.opts.constraints, n.opts.constraints) && hy(r.metaData, n.metaData))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return n.method += ", " + r.method, t;
    return t.push(r), t;
  }, []);
}
<<<<<<< HEAD
function jz(e, t, r) {
  let n = e.routes;
  return r.method === void 0 && (n = n.map(Dz)), n = n.map((i) => (i.metaData = Nz(i, r), i)), r.method === void 0 && (n = Fz(n)), n.map(Lz).join(`
${t}`);
}
function El(e, t, r, n) {
  if ((e.isLeafNode || n.commonPrefix !== !1) && (r = r || "(empty root node)", t = t[r] = {}, e.isLeafNode && (t[J$] = jz(e, r, n)), r = ""), e.staticChildren)
    for (const i of Object.values(e.staticChildren))
      El(i, t, r + i.prefix, n);
  if (e.parametricChildren)
    for (const i of Object.values(e.parametricChildren)) {
      const s = Array.from(i.nodePaths).join("|");
      El(i, t, r + s, n);
    }
  e.wildcardChild && El(e.wildcardChild, t, "*", n);
}
function Uz(e, t) {
  const r = {};
  return El(e, r, e.prefix, t), X$(r);
}
var Mz = { prettyPrintTree: Uz };
const Q$ = function() {
};
Q$.prototype = /* @__PURE__ */ Object.create(null);
var Hz = {
  NullObject: Q$
};
const { NullObject: qz } = Hz, Bz = ly;
let zz = class {
=======
function zD(e, t, r) {
  let n = e.routes;
  return r.method === void 0 && (n = n.map(DD)), n = n.map((s) => (s.metaData = LD(s, r), s)), r.method === void 0 && (n = MD(n)), n.map(FD).join(`
${t}`);
}
function So(e, t, r, n) {
  if ((e.isLeafNode || n.commonPrefix !== !1) && (r = r || "(empty root node)", t = t[r] = {}, e.isLeafNode && (t[j_] = zD(e, r, n)), r = ""), e.staticChildren)
    for (const s of Object.values(e.staticChildren))
      So(s, t, r + s.prefix, n);
  if (e.parametricChildren)
    for (const s of Object.values(e.parametricChildren)) {
      const i = Array.from(s.nodePaths).join("|");
      So(s, t, r + i, n);
    }
  e.wildcardChild && So(e.wildcardChild, t, "*", n);
}
function UD(e, t) {
  const r = {};
  return So(e, r, e.prefix, t), D_(r);
}
var qD = { prettyPrintTree: UD };
const M_ = function() {
};
M_.prototype = /* @__PURE__ */ Object.create(null);
var HD = {
  NullObject: M_
};
const { NullObject: BD } = HD, VD = Vd;
let GD = class {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    this.unconstrainedHandler = null, this.constraints = [], this.handlers = [], this.constrainedHandlerStores = null;
  }
  // This is the hot path for node handler finding -- change with care!
  getMatchingHandler(t) {
    return t === void 0 ? this.unconstrainedHandler : this._getHandlerMatchingConstraints(t);
  }
  addHandler(t, r) {
<<<<<<< HEAD
    const n = r.params, i = r.opts.constraints || {}, s = {
      params: n,
      constraints: i,
      handler: r.handler,
      store: r.store || null,
      _createParamsObject: this._compileCreateParamsObject(n)
    }, o = Object.keys(i);
    o.length === 0 && (this.unconstrainedHandler = s);
    for (const c of o)
      this.constraints.includes(c) || (c === "version" ? this.constraints.unshift(c) : this.constraints.push(c));
    const a = o.includes(Bz.name);
    if (!a && this.handlers.length >= 31)
      throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
    this.handlers.push(s), this.handlers.sort((c, u) => Object.keys(c.constraints).length - Object.keys(u.constraints).length), a || this._compileGetHandlerMatchingConstraints(t, i);
=======
    const n = r.params, s = r.opts.constraints || {}, i = {
      params: n,
      constraints: s,
      handler: r.handler,
      store: r.store || null,
      _createParamsObject: this._compileCreateParamsObject(n)
    }, o = Object.keys(s);
    o.length === 0 && (this.unconstrainedHandler = i);
    for (const c of o)
      this.constraints.includes(c) || (c === "version" ? this.constraints.unshift(c) : this.constraints.push(c));
    const a = o.includes(VD.name);
    if (!a && this.handlers.length >= 31)
      throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
    this.handlers.push(i), this.handlers.sort((c, f) => Object.keys(c.constraints).length - Object.keys(f.constraints).length), a || this._compileGetHandlerMatchingConstraints(t, s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  _compileCreateParamsObject(t) {
    const r = [];
    r.push("const fn = function _createParamsObject (paramsArray) {"), r.push("const params = new NullObject()");
    for (let n = 0; n < t.length; n++)
      r.push(`params['${t[n]}'] = paramsArray[${n}]`);
    return r.push("return params"), r.push("}"), r.push("return fn"), new Function("NullObject", r.join(`
<<<<<<< HEAD
`))(qz);
=======
`))(BD);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  _getHandlerMatchingConstraints() {
    return null;
  }
  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
  // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
  // The store's implementation comes from the strategies provided to the Router.
  _buildConstraintStore(t, r) {
    for (let n = 0; n < this.handlers.length; n++) {
<<<<<<< HEAD
      const s = this.handlers[n].constraints[r];
      if (s !== void 0) {
        let o = t.get(s) || 0;
        o |= 1 << n, t.set(s, o);
=======
      const i = this.handlers[n].constraints[r];
      if (i !== void 0) {
        let o = t.get(i) || 0;
        o |= 1 << n, t.set(i, o);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  }
  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
  _constrainedIndexBitmask(t) {
    let r = 0;
    for (let n = 0; n < this.handlers.length; n++)
      this.handlers[n].constraints[t] !== void 0 && (r |= 1 << n);
    return ~r;
  }
  // Compile a fast function to match the handlers for this node
  // The function implements a general case multi-constraint matching algorithm.
  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
  _compileGetHandlerMatchingConstraints(t) {
    this.constrainedHandlerStores = {};
    for (const n of this.constraints) {
<<<<<<< HEAD
      const i = t.newStoreForConstraint(n);
      this.constrainedHandlerStores[n] = i, this._buildConstraintStore(i, n);
=======
      const s = t.newStoreForConstraint(n);
      this.constrainedHandlerStores[n] = s, this._buildConstraintStore(s, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    const r = [];
    r.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
    for (const n of this.constraints) {
      r.push(`
      mask = ${this._constrainedIndexBitmask(n)}
      value = derivedConstraints.${n}
      `);
<<<<<<< HEAD
      const s = t.strategies[n].mustMatchWhenDerived ? "matches" : "(matches | mask)";
=======
      const i = t.strategies[n].mustMatchWhenDerived ? "matches" : "(matches | mask)";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      r.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${n}.get(value) || 0
<<<<<<< HEAD
        candidates &= ${s}
=======
        candidates &= ${i}
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      if (candidates === 0) return null;
      `);
    }
    for (const n in t.strategies)
      t.strategies[n].mustMatchWhenDerived && !this.constraints.includes(n) && r.push(`if (derivedConstraints.${n} !== undefined) return null`);
    r.push("return this.handlers[Math.floor(Math.log2(candidates))]"), this._getHandlerMatchingConstraints = new Function("derivedConstraints", r.join(`
`));
  }
};
<<<<<<< HEAD
var Vz = zz;
const Gz = Vz, tf = {
=======
var WD = GD;
const KD = WD, ja = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  STATIC: 0,
  PARAMETRIC: 1,
  WILDCARD: 2
};
<<<<<<< HEAD
class e1 {
=======
class z_ {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    this.isLeafNode = !1, this.routes = null, this.handlerStorage = null;
  }
  addRoute(t, r) {
<<<<<<< HEAD
    this.routes === null && (this.routes = []), this.handlerStorage === null && (this.handlerStorage = new Gz()), this.isLeafNode = !0, this.routes.push(t), this.handlerStorage.addHandler(r, t);
  }
}
class t1 extends e1 {
=======
    this.routes === null && (this.routes = []), this.handlerStorage === null && (this.handlerStorage = new KD()), this.isLeafNode = !0, this.routes.push(t), this.handlerStorage.addHandler(r, t);
  }
}
class U_ extends z_ {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    super(), this.staticChildren = {};
  }
  findStaticMatchingChild(t, r) {
    const n = this.staticChildren[t.charAt(r)];
    return n === void 0 || !n.matchPrefix(t, r) ? null : n;
  }
  getStaticChild(t, r = 0) {
    if (t.length === r)
      return this;
    const n = this.findStaticMatchingChild(t, r);
    return n ? n.getStaticChild(t, r + n.prefix.length) : null;
  }
  createStaticChild(t) {
    if (t.length === 0)
      return this;
    let r = this.staticChildren[t.charAt(0)];
    if (r) {
<<<<<<< HEAD
      let i = 1;
      for (; i < r.prefix.length; i++)
        if (t.charCodeAt(i) !== r.prefix.charCodeAt(i)) {
          r = r.split(this, i);
          break;
        }
      return r.createStaticChild(t.slice(i));
    }
    const n = t.charAt(0);
    return this.staticChildren[n] = new r1(t), this.staticChildren[n];
  }
}
let r1 = class n1 extends t1 {
  constructor(t) {
    super(), this.prefix = t, this.wildcardChild = null, this.parametricChildren = [], this.kind = tf.STATIC, this._compilePrefixMatch();
  }
  getParametricChild(t) {
    const r = t && t.source, n = this.parametricChildren.find((i) => (i.regex && i.regex.source) === r);
    return n || null;
  }
  createParametricChild(t, r, n) {
    let i = this.getParametricChild(t);
    return i ? (i.nodePaths.add(n), i) : (i = new Wz(t, r, n), this.parametricChildren.push(i), this.parametricChildren.sort((s, o) => s.isRegex ? o.isRegex ? s.staticSuffix === null ? 1 : o.staticSuffix === null ? -1 : o.staticSuffix.endsWith(s.staticSuffix) ? 1 : s.staticSuffix.endsWith(o.staticSuffix) ? -1 : 0 : -1 : 1), i);
=======
      let s = 1;
      for (; s < r.prefix.length; s++)
        if (t.charCodeAt(s) !== r.prefix.charCodeAt(s)) {
          r = r.split(this, s);
          break;
        }
      return r.createStaticChild(t.slice(s));
    }
    const n = t.charAt(0);
    return this.staticChildren[n] = new q_(t), this.staticChildren[n];
  }
}
let q_ = class H_ extends U_ {
  constructor(t) {
    super(), this.prefix = t, this.wildcardChild = null, this.parametricChildren = [], this.kind = ja.STATIC, this._compilePrefixMatch();
  }
  getParametricChild(t) {
    const r = t && t.source, n = this.parametricChildren.find((s) => (s.regex && s.regex.source) === r);
    return n || null;
  }
  createParametricChild(t, r, n) {
    let s = this.getParametricChild(t);
    return s ? (s.nodePaths.add(n), s) : (s = new JD(t, r, n), this.parametricChildren.push(s), this.parametricChildren.sort((i, o) => i.isRegex ? o.isRegex ? i.staticSuffix === null ? 1 : o.staticSuffix === null ? -1 : o.staticSuffix.endsWith(i.staticSuffix) ? 1 : i.staticSuffix.endsWith(o.staticSuffix) ? -1 : 0 : -1 : 1), s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  getWildcardChild() {
    return this.wildcardChild;
  }
  createWildcardChild() {
<<<<<<< HEAD
    return this.wildcardChild = this.getWildcardChild() || new Kz(), this.wildcardChild;
  }
  split(t, r) {
    const n = this.prefix.slice(0, r), i = this.prefix.slice(r);
    this.prefix = i, this._compilePrefixMatch();
    const s = new n1(n);
    return s.staticChildren[i.charAt(0)] = this, t.staticChildren[n.charAt(0)] = s, s;
  }
  getNextNode(t, r, n, i) {
    let s = this.findStaticMatchingChild(t, r), o = 0;
    if (s === null) {
      if (this.parametricChildren.length === 0)
        return this.wildcardChild;
      s = this.parametricChildren[0], o = 1;
    }
    this.wildcardChild !== null && n.push({
      paramsCount: i,
=======
    return this.wildcardChild = this.getWildcardChild() || new YD(), this.wildcardChild;
  }
  split(t, r) {
    const n = this.prefix.slice(0, r), s = this.prefix.slice(r);
    this.prefix = s, this._compilePrefixMatch();
    const i = new H_(n);
    return i.staticChildren[s.charAt(0)] = this, t.staticChildren[n.charAt(0)] = i, i;
  }
  getNextNode(t, r, n, s) {
    let i = this.findStaticMatchingChild(t, r), o = 0;
    if (i === null) {
      if (this.parametricChildren.length === 0)
        return this.wildcardChild;
      i = this.parametricChildren[0], o = 1;
    }
    this.wildcardChild !== null && n.push({
      paramsCount: s,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      brotherPathIndex: r,
      brotherNode: this.wildcardChild
    });
    for (let a = this.parametricChildren.length - 1; a >= o; a--)
      n.push({
<<<<<<< HEAD
        paramsCount: i,
        brotherPathIndex: r,
        brotherNode: this.parametricChildren[a]
      });
    return s;
=======
        paramsCount: s,
        brotherPathIndex: r,
        brotherNode: this.parametricChildren[a]
      });
    return i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  _compilePrefixMatch() {
    if (this.prefix.length === 1) {
      this.matchPrefix = () => !0;
      return;
    }
    const t = [];
    for (let r = 1; r < this.prefix.length; r++) {
      const n = this.prefix.charCodeAt(r);
      t.push(`path.charCodeAt(i + ${r}) === ${n}`);
    }
    this.matchPrefix = new Function("path", "i", `return ${t.join(" && ")}`);
  }
};
<<<<<<< HEAD
class Wz extends t1 {
  constructor(t, r, n) {
    super(), this.isRegex = !!t, this.regex = t || null, this.staticSuffix = r || null, this.kind = tf.PARAMETRIC, this.nodePaths = /* @__PURE__ */ new Set([n]);
=======
class JD extends U_ {
  constructor(t, r, n) {
    super(), this.isRegex = !!t, this.regex = t || null, this.staticSuffix = r || null, this.kind = ja.PARAMETRIC, this.nodePaths = /* @__PURE__ */ new Set([n]);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  getNextNode(t, r) {
    return this.findStaticMatchingChild(t, r);
  }
}
<<<<<<< HEAD
class Kz extends e1 {
  constructor() {
    super(), this.kind = tf.WILDCARD;
=======
class YD extends z_ {
  constructor() {
    super(), this.kind = ja.WILDCARD;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  getNextNode() {
    return null;
  }
}
<<<<<<< HEAD
var Yz = { StaticNode: r1, NODE_TYPES: tf };
const Jz = Vi;
function la() {
  if (!(this instanceof la))
    return new la();
  this.store = /* @__PURE__ */ new Map(), this.maxMajor = 0, this.maxMinors = {}, this.maxPatches = {};
}
la.prototype.set = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("Version should be a string");
  let [r, n, i] = e.split(".", 3);
  if (isNaN(r))
    throw new TypeError("Major version must be a numeric value");
  return r = Number(r), n = Number(n) || 0, i = Number(i) || 0, r >= this.maxMajor && (this.maxMajor = r, this.store.set("x", t), this.store.set("*", t), this.store.set("x.x", t), this.store.set("x.x.x", t)), n >= (this.maxMinors[r] || 0) && (this.maxMinors[r] = n, this.store.set(`${r}.x`, t), this.store.set(`${r}.x.x`, t)), i >= (this.maxPatches[`${r}.${n}`] || 0) && (this.maxPatches[`${r}.${n}`] = i, this.store.set(`${r}.${n}.x`, t)), this.store.set(`${r}.${n}.${i}`, t), this;
};
la.prototype.get = function(e) {
  return this.store.get(e);
};
var Xz = {
  name: "version",
  mustMatchWhenDerived: !0,
  storage: la,
  validate(e) {
    Jz(typeof e == "string", "Version should be a string");
  }
};
const Zz = Vi;
function Qz() {
=======
var XD = { StaticNode: q_, NODE_TYPES: ja };
const ZD = vn;
function Ws() {
  if (!(this instanceof Ws))
    return new Ws();
  this.store = /* @__PURE__ */ new Map(), this.maxMajor = 0, this.maxMinors = {}, this.maxPatches = {};
}
Ws.prototype.set = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("Version should be a string");
  let [r, n, s] = e.split(".", 3);
  if (isNaN(r))
    throw new TypeError("Major version must be a numeric value");
  return r = Number(r), n = Number(n) || 0, s = Number(s) || 0, r >= this.maxMajor && (this.maxMajor = r, this.store.set("x", t), this.store.set("*", t), this.store.set("x.x", t), this.store.set("x.x.x", t)), n >= (this.maxMinors[r] || 0) && (this.maxMinors[r] = n, this.store.set(`${r}.x`, t), this.store.set(`${r}.x.x`, t)), s >= (this.maxPatches[`${r}.${n}`] || 0) && (this.maxPatches[`${r}.${n}`] = s, this.store.set(`${r}.${n}.x`, t)), this.store.set(`${r}.${n}.${s}`, t), this;
};
Ws.prototype.get = function(e) {
  return this.store.get(e);
};
var QD = {
  name: "version",
  mustMatchWhenDerived: !0,
  storage: Ws,
  validate(e) {
    ZD(typeof e == "string", "Version should be a string");
  }
};
const eF = vn;
function tF() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = /* @__PURE__ */ new Map(), t = [];
  return {
    get: (r) => {
      const n = e.get(r);
      if (n)
        return n;
<<<<<<< HEAD
      for (const i of t)
        if (i.host.test(r))
          return i.value;
=======
      for (const s of t)
        if (s.host.test(r))
          return s.value;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    set: (r, n) => {
      r instanceof RegExp ? t.push({ host: r, value: n }) : e.set(r, n);
    }
  };
}
<<<<<<< HEAD
var e4 = {
  name: "host",
  mustMatchWhenDerived: !1,
  storage: Qz,
  validate(e) {
    Zz(typeof e == "string" || Object.prototype.toString.call(e) === "[object RegExp]", "Host should be a string or a RegExp");
  }
};
const t4 = Xz, r4 = e4, Vd = Vi;
let n4 = class {
  constructor(t) {
    if (this.strategies = {
      version: t4,
      host: r4
=======
var rF = {
  name: "host",
  mustMatchWhenDerived: !1,
  storage: tF,
  validate(e) {
    eF(typeof e == "string" || Object.prototype.toString.call(e) === "[object RegExp]", "Host should be a string or a RegExp");
  }
};
const nF = QD, sF = rF, al = vn;
let iF = class {
  constructor(t) {
    if (this.strategies = {
      version: nF,
      host: sF
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }, this.strategiesInUse = /* @__PURE__ */ new Set(), this.asyncStrategiesInUse = /* @__PURE__ */ new Set(), t)
      for (const r of Object.values(t))
        this.addConstraintStrategy(r);
  }
  isStrategyUsed(t) {
    return this.strategiesInUse.has(t) || this.asyncStrategiesInUse.has(t);
  }
  hasConstraintStrategy(t) {
    const r = this.strategies[t];
    return r !== void 0 ? r.isCustom || this.isStrategyUsed(t) : !1;
  }
  addConstraintStrategy(t) {
<<<<<<< HEAD
    if (Vd(typeof t.name == "string" && t.name !== "", "strategy.name is required."), Vd(t.storage && typeof t.storage == "function", "strategy.storage function is required."), Vd(t.deriveConstraint && typeof t.deriveConstraint == "function", "strategy.deriveConstraint function is required."), this.strategies[t.name] && this.strategies[t.name].isCustom)
=======
    if (al(typeof t.name == "string" && t.name !== "", "strategy.name is required."), al(t.storage && typeof t.storage == "function", "strategy.storage function is required."), al(t.deriveConstraint && typeof t.deriveConstraint == "function", "strategy.deriveConstraint function is required."), this.strategies[t.name] && this.strategies[t.name].isCustom)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      throw new Error(`There already exists a custom constraint with the name ${t.name}.`);
    if (this.isStrategyUsed(t.name))
      throw new Error(`There already exists a route with ${t.name} constraint.`);
    t.isCustom = !0, t.isAsync = t.deriveConstraint.length === 3, this.strategies[t.name] = t, t.mustMatchWhenDerived && this.noteUsage({ [t.name]: t });
  }
  deriveConstraints(t, r, n) {
<<<<<<< HEAD
    const i = this.deriveSyncConstraints(t, r);
    if (n === void 0)
      return i;
    this.deriveAsyncConstraints(i, t, r, n);
=======
    const s = this.deriveSyncConstraints(t, r);
    if (n === void 0)
      return s;
    this.deriveAsyncConstraints(s, t, r, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  deriveSyncConstraints(t, r) {
  }
  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
  noteUsage(t) {
    if (t) {
      const r = this.strategiesInUse.size;
      for (const n in t)
        this.strategies[n].isAsync ? this.asyncStrategiesInUse.add(n) : this.strategiesInUse.add(n);
      r !== this.strategiesInUse.size && this._buildDeriveConstraints();
    }
  }
  newStoreForConstraint(t) {
    if (!this.strategies[t])
      throw new Error(`No strategy registered for constraint key ${t}`);
    return this.strategies[t].storage();
  }
  validateConstraints(t) {
    for (const r in t) {
      const n = t[r];
      if (typeof n > "u")
        throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
<<<<<<< HEAD
      const i = this.strategies[r];
      if (!i)
        throw new Error(`No strategy registered for constraint key ${r}`);
      i.validate && i.validate(n);
    }
  }
  deriveAsyncConstraints(t, r, n, i) {
    let s = this.asyncStrategiesInUse.size;
    if (s === 0) {
      i(null, t);
=======
      const s = this.strategies[r];
      if (!s)
        throw new Error(`No strategy registered for constraint key ${r}`);
      s.validate && s.validate(n);
    }
  }
  deriveAsyncConstraints(t, r, n, s) {
    let i = this.asyncStrategiesInUse.size;
    if (i === 0) {
      s(null, t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    t = t || {};
    for (const o of this.asyncStrategiesInUse)
<<<<<<< HEAD
      this.strategies[o].deriveConstraint(r, n, (c, u) => {
        if (c !== null) {
          i(c);
          return;
        }
        t[o] = u, --s === 0 && i(null, t);
=======
      this.strategies[o].deriveConstraint(r, n, (c, f) => {
        if (c !== null) {
          s(c);
          return;
        }
        t[o] = f, --i === 0 && s(null, t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      });
  }
  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
  // This allows us to not allocate an object to hold constraint values if no constraints are defined.
  _buildDeriveConstraints() {
    if (this.strategiesInUse.size === 0) return;
    const t = ["return {"];
    for (const r of this.strategiesInUse) {
      const n = this.strategies[r];
      n.isCustom ? t.push(`  ${n.name}: this.strategies.${r}.deriveConstraint(req, ctx),`) : r === "version" ? t.push("   version: req.headers['accept-version'],") : t.push("   host: req.headers.host || req.headers[':authority'],");
    }
    t.push("}"), this.deriveSyncConstraints = new Function("req", "ctx", t.join(`
`)).bind(this);
  }
};
<<<<<<< HEAD
var i4 = n4;
const s4 = [
=======
var oF = iF;
const aF = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "ACL",
  "BIND",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LINK",
  "LOCK",
  "M-SEARCH",
  "MERGE",
  "MKACTIVITY",
  "MKCALENDAR",
  "MKCOL",
  "MOVE",
  "NOTIFY",
  "OPTIONS",
  "PATCH",
  "POST",
  "PROPFIND",
  "PROPPATCH",
  "PURGE",
  "PUT",
  "QUERY",
  "REBIND",
  "REPORT",
  "SEARCH",
  "SOURCE",
  "SUBSCRIBE",
  "TRACE",
  "UNBIND",
  "UNLINK",
  "UNLOCK",
  "UNSUBSCRIBE"
];
<<<<<<< HEAD
var o4 = s4;
function i1(e, t) {
  return e === 50 ? t === 53 ? "%" : t === 51 ? "#" : t === 52 ? "$" : t === 54 ? "&" : t === 66 || t === 98 ? "+" : t === 67 || t === 99 ? "," : t === 70 || t === 102 ? "/" : null : e === 51 ? t === 65 || t === 97 ? ":" : t === 66 || t === 98 ? ";" : t === 68 || t === 100 ? "=" : t === 70 || t === 102 ? "?" : null : e === 52 && t === 48 ? "@" : null;
}
function a4(e, t) {
  let r = !1, n = !1, i = "";
  for (let o = 1; o < e.length; o++) {
    const a = e.charCodeAt(o);
    if (a === 37) {
      const c = e.charCodeAt(o + 1), u = e.charCodeAt(o + 2);
      i1(c, u) === null ? r = !0 : (n = !0, c === 50 && u === 53 && (r = !0, e = e.slice(0, o + 1) + "25" + e.slice(o + 1), o += 2), o += 2);
    } else if (a === 63 || a === 35 || a === 59 && t) {
      i = e.slice(o + 1), e = e.slice(0, o);
      break;
    }
  }
  return { path: r ? decodeURI(e) : e, querystring: i, shouldDecodeParam: n };
}
function c4(e) {
  const t = e.indexOf("%");
  if (t === -1) return e;
  let r = "", n = t;
  for (let i = t; i < e.length; i++)
    if (e.charCodeAt(i) === 37) {
      const s = e.charCodeAt(i + 1), o = e.charCodeAt(i + 2), a = i1(s, o);
      r += e.slice(n, i) + a, n = i + 3;
    }
  return e.slice(0, t) + r + e.slice(n);
}
var l4 = { safeDecodeURI: a4, safeDecodeURIComponent: c4 };
const dt = Vi, u4 = uz, ao = Az, uy = ju, { prettyPrintTree: f4 } = Mz, { StaticNode: cb, NODE_TYPES: lb } = Yz, d4 = i4, ks = o4, Gd = ly, { safeDecodeURI: p4, safeDecodeURIComponent: ub } = l4, s1 = /^https?:\/\/.*?\//, Ii = /(\/:[^/()]*?)\?(\/?)/, o1 = /[.*+?^${}()|[\]\\]/g, a1 = /\/\/+/g;
if (!ao(s1))
  throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
if (!ao(Ii))
  throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
if (!ao(o1))
  throw new Error("the ESCAPE_REGEXP is not safe, update this module");
if (!ao(a1))
  throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
function at(e) {
  if (!(this instanceof at))
    return new at(e);
  e = e || {}, this._opts = e, e.defaultRoute ? (dt(typeof e.defaultRoute == "function", "The default route must be a function"), this.defaultRoute = e.defaultRoute) : this.defaultRoute = null, e.onBadUrl ? (dt(typeof e.onBadUrl == "function", "The bad url handler must be a function"), this.onBadUrl = e.onBadUrl) : this.onBadUrl = null, e.buildPrettyMeta ? (dt(typeof e.buildPrettyMeta == "function", "buildPrettyMeta must be a function"), this.buildPrettyMeta = e.buildPrettyMeta) : this.buildPrettyMeta = h4, e.querystringParser ? (dt(typeof e.querystringParser == "function", "querystringParser must be a function"), this.querystringParser = e.querystringParser) : this.querystringParser = (t) => t.length === 0 ? {} : u4.parse(t), this.caseSensitive = e.caseSensitive === void 0 ? !0 : e.caseSensitive, this.ignoreTrailingSlash = e.ignoreTrailingSlash || !1, this.ignoreDuplicateSlashes = e.ignoreDuplicateSlashes || !1, this.maxParamLength = e.maxParamLength || 100, this.allowUnsafeRegex = e.allowUnsafeRegex || !1, this.constrainer = new d4(e.constraints), this.useSemicolonDelimiter = e.useSemicolonDelimiter || !1, this.routes = [], this.trees = {};
}
at.prototype.on = function(t, r, n, i, s) {
  typeof n == "function" && (i !== void 0 && (s = i), i = n, n = {}), dt(typeof r == "string", "Path should be a string"), dt(r.length > 0, "The path could not be empty"), dt(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), dt(typeof i == "function", "Handler should be a function");
  const o = r.match(Ii);
  if (o) {
    dt(r.length === o.index + o[0].length, "Optional Parameter needs to be the last parameter of the path");
    const u = r.replace(Ii, "$1$2"), l = r.replace(Ii, "$2") || "/";
    this.on(t, u, n, i, s), this.on(t, l, n, i, s);
    return;
  }
  const a = r;
  this.ignoreDuplicateSlashes && (r = fy(r)), this.ignoreTrailingSlash && (r = dy(r));
  const c = Array.isArray(t) ? t : [t];
  for (const u of c)
    dt(typeof u == "string", "Method should be a string"), dt(ks.includes(u), `Method '${u}' is not an http method.`), this._on(u, r, n, i, s, a);
};
at.prototype._on = function(t, r, n, i, s) {
  let o = {};
  n.constraints !== void 0 && (dt(typeof n.constraints == "object" && n.constraints !== null, "Constraints should be an object"), Object.keys(n.constraints).length !== 0 && (o = n.constraints)), this.constrainer.validateConstraints(o), this.constrainer.noteUsage(o), this.trees[t] === void 0 && (this.trees[t] = new cb("/"));
  let a = r;
  if (a === "*" && this.trees[t].prefix.length !== 0) {
    const m = this.trees[t];
    this.trees[t] = new cb(""), this.trees[t].staticChildren["/"] = m;
  }
  let c = this.trees[t], u = c.prefix.length;
  const l = [];
  for (let m = 0; m <= a.length; m++) {
    if (a.charCodeAt(m) === 58 && a.charCodeAt(m + 1) === 58) {
      m++;
      continue;
    }
    const p = a.charCodeAt(m) === 58 && a.charCodeAt(m + 1) !== 58, d = a.charCodeAt(m) === 42;
    if (p || d || m === a.length && m !== u) {
      let h = a.slice(u, m);
      this.caseSensitive || (h = h.toLowerCase()), h = h.replaceAll("::", ":"), h = h.replaceAll("%", "%25"), c = c.createStaticChild(h);
    }
    if (p) {
      let h = !1, _ = !0, g = "";
      const v = [];
      let y = m + 1;
      for (let E = y; ; E++) {
        const R = a.charCodeAt(E), w = R === 40, C = R === 45 || R === 46, V = R === 47 || E === a.length;
        if (w || C || V) {
          const b = a.slice(y, E);
          if (l.push(b), h = h || w || C, w) {
            const q = f1(a, E), $ = a.slice(E, q + 1);
            this.allowUnsafeRegex || dt(ao(new RegExp($)), `The regex '${$}' is not safe!`), v.push(u1($)), E = q + 1, _ = !0;
          } else
            v.push(_ ? "(.*?)" : `(${g}|(?:(?!${g}).)*)`), _ = !1;
          const F = E;
          for (; E < a.length; E++) {
            const q = a.charCodeAt(E);
            if (q === 47) break;
            if (q === 58)
              if (a.charCodeAt(E + 1) === 58) E++;
              else break;
          }
          let H = a.slice(F, E);
          if (H && (H = H.replaceAll("::", ":"), H = H.replaceAll("%", "%25"), v.push(g = l1(H))), y = E + 1, V || a.charCodeAt(E) === 47 || E === a.length) {
            const q = h ? "()" + H : H, $ = a.slice(m, E);
            a = a.slice(0, m + 1) + q + a.slice(E), m += q.length;
            const x = h ? new RegExp("^" + v.join("") + "$") : null;
            c = c.createParametricChild(x, H || null, $), u = m + 1;
=======
var cF = aF;
function B_(e, t) {
  return e === 50 ? t === 53 ? "%" : t === 51 ? "#" : t === 52 ? "$" : t === 54 ? "&" : t === 66 || t === 98 ? "+" : t === 67 || t === 99 ? "," : t === 70 || t === 102 ? "/" : null : e === 51 ? t === 65 || t === 97 ? ":" : t === 66 || t === 98 ? ";" : t === 68 || t === 100 ? "=" : t === 70 || t === 102 ? "?" : null : e === 52 && t === 48 ? "@" : null;
}
function lF(e, t) {
  let r = !1, n = !1, s = "";
  for (let o = 1; o < e.length; o++) {
    const a = e.charCodeAt(o);
    if (a === 37) {
      const c = e.charCodeAt(o + 1), f = e.charCodeAt(o + 2);
      B_(c, f) === null ? r = !0 : (n = !0, c === 50 && f === 53 && (r = !0, e = e.slice(0, o + 1) + "25" + e.slice(o + 1), o += 2), o += 2);
    } else if (a === 63 || a === 35 || a === 59 && t) {
      s = e.slice(o + 1), e = e.slice(0, o);
      break;
    }
  }
  return { path: r ? decodeURI(e) : e, querystring: s, shouldDecodeParam: n };
}
function uF(e) {
  const t = e.indexOf("%");
  if (t === -1) return e;
  let r = "", n = t;
  for (let s = t; s < e.length; s++)
    if (e.charCodeAt(s) === 37) {
      const i = e.charCodeAt(s + 1), o = e.charCodeAt(s + 2), a = B_(i, o);
      r += e.slice(n, s) + a, n = s + 3;
    }
  return e.slice(0, t) + r + e.slice(n);
}
var fF = { safeDecodeURI: lF, safeDecodeURIComponent: uF };
const Ye = vn, dF = dD, fs = AD, Gd = ba, { prettyPrintTree: pF } = qD, { StaticNode: yy, NODE_TYPES: gy } = XD, hF = oF, Bn = cF, cl = Vd, { safeDecodeURI: mF, safeDecodeURIComponent: vy } = fF, V_ = /^https?:\/\/.*?\//, cn = /(\/:[^/()]*?)\?(\/?)/, G_ = /[.*+?^${}()|[\]\\]/g, W_ = /\/\/+/g;
if (!fs(V_))
  throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
if (!fs(cn))
  throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
if (!fs(G_))
  throw new Error("the ESCAPE_REGEXP is not safe, update this module");
if (!fs(W_))
  throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
function Be(e) {
  if (!(this instanceof Be))
    return new Be(e);
  e = e || {}, this._opts = e, e.defaultRoute ? (Ye(typeof e.defaultRoute == "function", "The default route must be a function"), this.defaultRoute = e.defaultRoute) : this.defaultRoute = null, e.onBadUrl ? (Ye(typeof e.onBadUrl == "function", "The bad url handler must be a function"), this.onBadUrl = e.onBadUrl) : this.onBadUrl = null, e.buildPrettyMeta ? (Ye(typeof e.buildPrettyMeta == "function", "buildPrettyMeta must be a function"), this.buildPrettyMeta = e.buildPrettyMeta) : this.buildPrettyMeta = yF, e.querystringParser ? (Ye(typeof e.querystringParser == "function", "querystringParser must be a function"), this.querystringParser = e.querystringParser) : this.querystringParser = (t) => t.length === 0 ? {} : dF.parse(t), this.caseSensitive = e.caseSensitive === void 0 ? !0 : e.caseSensitive, this.ignoreTrailingSlash = e.ignoreTrailingSlash || !1, this.ignoreDuplicateSlashes = e.ignoreDuplicateSlashes || !1, this.maxParamLength = e.maxParamLength || 100, this.allowUnsafeRegex = e.allowUnsafeRegex || !1, this.constrainer = new hF(e.constraints), this.useSemicolonDelimiter = e.useSemicolonDelimiter || !1, this.routes = [], this.trees = {};
}
Be.prototype.on = function(t, r, n, s, i) {
  typeof n == "function" && (s !== void 0 && (i = s), s = n, n = {}), Ye(typeof r == "string", "Path should be a string"), Ye(r.length > 0, "The path could not be empty"), Ye(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), Ye(typeof s == "function", "Handler should be a function");
  const o = r.match(cn);
  if (o) {
    Ye(r.length === o.index + o[0].length, "Optional Parameter needs to be the last parameter of the path");
    const f = r.replace(cn, "$1$2"), l = r.replace(cn, "$2") || "/";
    this.on(t, f, n, s, i), this.on(t, l, n, s, i);
    return;
  }
  const a = r;
  this.ignoreDuplicateSlashes && (r = Wd(r)), this.ignoreTrailingSlash && (r = Kd(r));
  const c = Array.isArray(t) ? t : [t];
  for (const f of c)
    Ye(typeof f == "string", "Method should be a string"), Ye(Bn.includes(f), `Method '${f}' is not an http method.`), this._on(f, r, n, s, i, a);
};
Be.prototype._on = function(t, r, n, s, i) {
  let o = {};
  n.constraints !== void 0 && (Ye(typeof n.constraints == "object" && n.constraints !== null, "Constraints should be an object"), Object.keys(n.constraints).length !== 0 && (o = n.constraints)), this.constrainer.validateConstraints(o), this.constrainer.noteUsage(o), this.trees[t] === void 0 && (this.trees[t] = new yy("/"));
  let a = r;
  if (a === "*" && this.trees[t].prefix.length !== 0) {
    const g = this.trees[t];
    this.trees[t] = new yy(""), this.trees[t].staticChildren["/"] = g;
  }
  let c = this.trees[t], f = c.prefix.length;
  const l = [];
  for (let g = 0; g <= a.length; g++) {
    if (a.charCodeAt(g) === 58 && a.charCodeAt(g + 1) === 58) {
      g++;
      continue;
    }
    const p = a.charCodeAt(g) === 58 && a.charCodeAt(g + 1) !== 58, u = a.charCodeAt(g) === 42;
    if (p || u || g === a.length && g !== f) {
      let h = a.slice(f, g);
      this.caseSensitive || (h = h.toLowerCase()), h = h.replaceAll("::", ":"), h = h.replaceAll("%", "%25"), c = c.createStaticChild(h);
    }
    if (p) {
      let h = !1, b = !0, m = "";
      const v = [];
      let y = g + 1;
      for (let _ = y; ; _++) {
        const R = a.charCodeAt(_), E = R === 40, O = R === 45 || R === 46, z = R === 47 || _ === a.length;
        if (E || O || z) {
          const S = a.slice(y, _);
          if (l.push(S), h = h || E || O, E) {
            const U = X_(a, _), $ = a.slice(_, U + 1);
            this.allowUnsafeRegex || Ye(fs(new RegExp($)), `The regex '${$}' is not safe!`), v.push(Y_($)), _ = U + 1, b = !0;
          } else
            v.push(b ? "(.*?)" : `(${m}|(?:(?!${m}).)*)`), b = !1;
          const L = _;
          for (; _ < a.length; _++) {
            const U = a.charCodeAt(_);
            if (U === 47) break;
            if (U === 58)
              if (a.charCodeAt(_ + 1) === 58) _++;
              else break;
          }
          let M = a.slice(L, _);
          if (M && (M = M.replaceAll("::", ":"), M = M.replaceAll("%", "%25"), v.push(m = J_(M))), y = _ + 1, z || a.charCodeAt(_) === 47 || _ === a.length) {
            const U = h ? "()" + M : M, $ = a.slice(g, _);
            a = a.slice(0, g + 1) + U + a.slice(_), g += U.length;
            const x = h ? new RegExp("^" + v.join("") + "$") : null;
            c = c.createParametricChild(x, M || null, $), f = g + 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
            break;
          }
        }
      }
<<<<<<< HEAD
    } else if (d && (l.push("*"), c = c.createWildcardChild(), u = m + 1, m !== a.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (a = a.toLowerCase()), a === "*" && (a = "/*");
  for (const m of this.routes) {
    const p = m.opts.constraints || {};
    if (m.method === t && m.pattern === a && uy(p, o))
      throw new Error(`Method '${t}' already declared for route '${a}' with constraints '${JSON.stringify(o)}'`);
  }
  const f = { method: t, path: r, pattern: a, params: l, opts: n, handler: i, store: s };
  this.routes.push(f), c.addRoute(f, this.constrainer);
};
at.prototype.hasRoute = function(t, r, n) {
  return this.findRoute(t, r, n) !== null;
};
at.prototype.findRoute = function(t, r, n = {}) {
  if (this.trees[t] === void 0)
    return null;
  let i = r, s = this.trees[t], o = s.prefix.length;
  for (let a = 0; a <= i.length; a++) {
    if (i.charCodeAt(a) === 58 && i.charCodeAt(a + 1) === 58) {
      a++;
      continue;
    }
    const c = i.charCodeAt(a) === 58 && i.charCodeAt(a + 1) !== 58, u = i.charCodeAt(a) === 42;
    if (c || u || a === i.length && a !== o) {
      let l = i.slice(o, a);
      if (this.caseSensitive || (l = l.toLowerCase()), l = l.replaceAll("::", ":"), l = l.replaceAll("%", "%25"), s = s.getStaticChild(l), s === null)
        return null;
    }
    if (c) {
      let l = !1, f = !0, m = "";
      const p = [];
      let d = a + 1;
      for (let h = d; ; h++) {
        const _ = i.charCodeAt(h), g = _ === 40, v = _ === 45 || _ === 46, y = _ === 47 || h === i.length;
        if (g || v || y) {
          if (i.slice(d, h), l = l || g || v, g) {
            const w = f1(i, h), C = i.slice(h, w + 1);
            this.allowUnsafeRegex || dt(ao(new RegExp(C)), `The regex '${C}' is not safe!`), p.push(u1(C)), h = w + 1, f = !1;
          } else
            p.push(f ? "(.*?)" : `(${m}|(?:(?!${m}).)*)`), f = !1;
          const E = h;
          for (; h < i.length; h++) {
            const w = i.charCodeAt(h);
            if (w === 47) break;
            if (w === 58)
              if (i.charCodeAt(h + 1) === 58) h++;
              else break;
          }
          let R = i.slice(E, h);
          if (R && (R = R.replaceAll("::", ":"), R = R.replaceAll("%", "%25"), p.push(m = l1(R))), d = h + 1, y || i.charCodeAt(h) === 47 || h === i.length) {
            const w = l ? "()" + R : R, C = i.slice(a, h);
            i = i.slice(0, a + 1) + w + i.slice(h), a += w.length;
            const V = l ? new RegExp("^" + p.join("") + "$") : null;
            if (s = s.getParametricChild(V, R || null, C), s === null)
=======
    } else if (u && (l.push("*"), c = c.createWildcardChild(), f = g + 1, g !== a.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (a = a.toLowerCase()), a === "*" && (a = "/*");
  for (const g of this.routes) {
    const p = g.opts.constraints || {};
    if (g.method === t && g.pattern === a && Gd(p, o))
      throw new Error(`Method '${t}' already declared for route '${a}' with constraints '${JSON.stringify(o)}'`);
  }
  const d = { method: t, path: r, pattern: a, params: l, opts: n, handler: s, store: i };
  this.routes.push(d), c.addRoute(d, this.constrainer);
};
Be.prototype.hasRoute = function(t, r, n) {
  return this.findRoute(t, r, n) !== null;
};
Be.prototype.findRoute = function(t, r, n = {}) {
  if (this.trees[t] === void 0)
    return null;
  let s = r, i = this.trees[t], o = i.prefix.length;
  for (let a = 0; a <= s.length; a++) {
    if (s.charCodeAt(a) === 58 && s.charCodeAt(a + 1) === 58) {
      a++;
      continue;
    }
    const c = s.charCodeAt(a) === 58 && s.charCodeAt(a + 1) !== 58, f = s.charCodeAt(a) === 42;
    if (c || f || a === s.length && a !== o) {
      let l = s.slice(o, a);
      if (this.caseSensitive || (l = l.toLowerCase()), l = l.replaceAll("::", ":"), l = l.replaceAll("%", "%25"), i = i.getStaticChild(l), i === null)
        return null;
    }
    if (c) {
      let l = !1, d = !0, g = "";
      const p = [];
      let u = a + 1;
      for (let h = u; ; h++) {
        const b = s.charCodeAt(h), m = b === 40, v = b === 45 || b === 46, y = b === 47 || h === s.length;
        if (m || v || y) {
          if (s.slice(u, h), l = l || m || v, m) {
            const E = X_(s, h), O = s.slice(h, E + 1);
            this.allowUnsafeRegex || Ye(fs(new RegExp(O)), `The regex '${O}' is not safe!`), p.push(Y_(O)), h = E + 1, d = !1;
          } else
            p.push(d ? "(.*?)" : `(${g}|(?:(?!${g}).)*)`), d = !1;
          const _ = h;
          for (; h < s.length; h++) {
            const E = s.charCodeAt(h);
            if (E === 47) break;
            if (E === 58)
              if (s.charCodeAt(h + 1) === 58) h++;
              else break;
          }
          let R = s.slice(_, h);
          if (R && (R = R.replaceAll("::", ":"), R = R.replaceAll("%", "%25"), p.push(g = J_(R))), u = h + 1, y || s.charCodeAt(h) === 47 || h === s.length) {
            const E = l ? "()" + R : R, O = s.slice(a, h);
            s = s.slice(0, a + 1) + E + s.slice(h), a += E.length;
            const z = l ? new RegExp("^" + p.join("") + "$") : null;
            if (i = i.getParametricChild(z, R || null, O), i === null)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
              return null;
            o = a + 1;
            break;
          }
        }
      }
<<<<<<< HEAD
    } else if (u && (s = s.getWildcardChild(), o = a + 1, a !== i.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (i = i.toLowerCase());
  for (const a of this.routes) {
    const c = a.opts.constraints || {};
    if (a.method === t && a.pattern === i && uy(c, n))
=======
    } else if (f && (i = i.getWildcardChild(), o = a + 1, a !== s.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (s = s.toLowerCase());
  for (const a of this.routes) {
    const c = a.opts.constraints || {};
    if (a.method === t && a.pattern === s && Gd(c, n))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return {
        handler: a.handler,
        store: a.store,
        params: a.params
      };
  }
  return null;
};
<<<<<<< HEAD
at.prototype.hasConstraintStrategy = function(e) {
  return this.constrainer.hasConstraintStrategy(e);
};
at.prototype.addConstraintStrategy = function(e) {
  this.constrainer.addConstraintStrategy(e), this._rebuild(this.routes);
};
at.prototype.reset = function() {
  this.trees = {}, this.routes = [];
};
at.prototype.off = function(t, r, n) {
  dt(typeof r == "string", "Path should be a string"), dt(r.length > 0, "The path could not be empty"), dt(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), dt(
    typeof n > "u" || typeof n == "object" && !Array.isArray(n) && n !== null,
    "Constraints should be an object or undefined."
  );
  const i = r.match(Ii);
  if (i) {
    dt(r.length === i.index + i[0].length, "Optional Parameter needs to be the last parameter of the path");
    const o = r.replace(Ii, "$1$2"), a = r.replace(Ii, "$2");
    this.off(t, o, n), this.off(t, a, n);
    return;
  }
  this.ignoreDuplicateSlashes && (r = fy(r)), this.ignoreTrailingSlash && (r = dy(r));
  const s = Array.isArray(t) ? t : [t];
  for (const o of s)
    this._off(o, r, n);
};
at.prototype._off = function(t, r, n) {
  dt(typeof t == "string", "Method should be a string"), dt(ks.includes(t), `Method '${t}' is not an http method.`);
  function i(c) {
    return t !== c.method || r !== c.path;
  }
  function s(c) {
    return i(c) || !uy(n, c.opts.constraints || {});
  }
  const o = n ? s : i, a = this.routes.filter(o);
  this._rebuild(a);
};
at.prototype.lookup = function(t, r, n, i) {
  if (typeof n == "function" && (i = n, n = void 0), i === void 0) {
    const s = this.constrainer.deriveConstraints(t, n), o = this.find(t.method, t.url, s);
    return this.callHandler(o, t, r, n);
  }
  this.constrainer.deriveConstraints(t, n, (s, o) => {
    if (s !== null) {
      i(s);
=======
Be.prototype.hasConstraintStrategy = function(e) {
  return this.constrainer.hasConstraintStrategy(e);
};
Be.prototype.addConstraintStrategy = function(e) {
  this.constrainer.addConstraintStrategy(e), this._rebuild(this.routes);
};
Be.prototype.reset = function() {
  this.trees = {}, this.routes = [];
};
Be.prototype.off = function(t, r, n) {
  Ye(typeof r == "string", "Path should be a string"), Ye(r.length > 0, "The path could not be empty"), Ye(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), Ye(
    typeof n > "u" || typeof n == "object" && !Array.isArray(n) && n !== null,
    "Constraints should be an object or undefined."
  );
  const s = r.match(cn);
  if (s) {
    Ye(r.length === s.index + s[0].length, "Optional Parameter needs to be the last parameter of the path");
    const o = r.replace(cn, "$1$2"), a = r.replace(cn, "$2");
    this.off(t, o, n), this.off(t, a, n);
    return;
  }
  this.ignoreDuplicateSlashes && (r = Wd(r)), this.ignoreTrailingSlash && (r = Kd(r));
  const i = Array.isArray(t) ? t : [t];
  for (const o of i)
    this._off(o, r, n);
};
Be.prototype._off = function(t, r, n) {
  Ye(typeof t == "string", "Method should be a string"), Ye(Bn.includes(t), `Method '${t}' is not an http method.`);
  function s(c) {
    return t !== c.method || r !== c.path;
  }
  function i(c) {
    return s(c) || !Gd(n, c.opts.constraints || {});
  }
  const o = n ? i : s, a = this.routes.filter(o);
  this._rebuild(a);
};
Be.prototype.lookup = function(t, r, n, s) {
  if (typeof n == "function" && (s = n, n = void 0), s === void 0) {
    const i = this.constrainer.deriveConstraints(t, n), o = this.find(t.method, t.url, i);
    return this.callHandler(o, t, r, n);
  }
  this.constrainer.deriveConstraints(t, n, (i, o) => {
    if (i !== null) {
      s(i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return;
    }
    try {
      const a = this.find(t.method, t.url, o), c = this.callHandler(a, t, r, n);
<<<<<<< HEAD
      i(null, c);
    } catch (a) {
      i(a);
    }
  });
};
at.prototype.callHandler = function(t, r, n, i) {
  return t === null ? this._defaultRoute(r, n, i) : i === void 0 ? t.handler(r, n, t.params, t.store, t.searchParams) : t.handler.call(i, r, n, t.params, t.store, t.searchParams);
};
at.prototype.find = function(t, r, n) {
  let i = this.trees[t];
  if (i === void 0) return null;
  r.charCodeAt(0) !== 47 && (r = r.replace(s1, "/")), this.ignoreDuplicateSlashes && (r = fy(r));
  let s, o, a;
  try {
    s = p4(r, this.useSemicolonDelimiter), r = s.path, o = s.querystring, a = s.shouldDecodeParam;
  } catch {
    return this._onBadUrl(r);
  }
  this.ignoreTrailingSlash && (r = dy(r));
  const c = r;
  this.caseSensitive === !1 && (r = r.toLowerCase());
  const u = this.maxParamLength;
  let l = i.prefix.length;
  const f = [], m = r.length, p = [];
  for (; ; ) {
    if (l === m && i.isLeafNode) {
      const g = i.handlerStorage.getMatchingHandler(n);
      if (g !== null)
        return {
          handler: g.handler,
          store: g.store,
          params: g._createParamsObject(f),
          searchParams: this.querystringParser(o)
        };
    }
    let d = i.getNextNode(r, l, p, f.length);
    if (d === null) {
      if (p.length === 0)
        return null;
      const g = p.pop();
      l = g.brotherPathIndex, f.splice(g.paramsCount), d = g.brotherNode;
    }
    if (i = d, i.kind === lb.STATIC) {
      l += i.prefix.length;
      continue;
    }
    if (i.kind === lb.WILDCARD) {
      let g = c.slice(l);
      a && (g = ub(g)), f.push(g), l = m;
      continue;
    }
    let h = c.indexOf("/", l);
    h === -1 && (h = m);
    let _ = c.slice(l, h);
    if (a && (_ = ub(_)), i.isRegex) {
      const g = i.regex.exec(_);
      if (g === null) continue;
      for (let v = 1; v < g.length; v++) {
        const y = g[v];
        if (y.length > u)
          return null;
        f.push(y);
      }
    } else {
      if (_.length > u)
        return null;
      f.push(_);
=======
      s(null, c);
    } catch (a) {
      s(a);
    }
  });
};
Be.prototype.callHandler = function(t, r, n, s) {
  return t === null ? this._defaultRoute(r, n, s) : s === void 0 ? t.handler(r, n, t.params, t.store, t.searchParams) : t.handler.call(s, r, n, t.params, t.store, t.searchParams);
};
Be.prototype.find = function(t, r, n) {
  let s = this.trees[t];
  if (s === void 0) return null;
  r.charCodeAt(0) !== 47 && (r = r.replace(V_, "/")), this.ignoreDuplicateSlashes && (r = Wd(r));
  let i, o, a;
  try {
    i = mF(r, this.useSemicolonDelimiter), r = i.path, o = i.querystring, a = i.shouldDecodeParam;
  } catch {
    return this._onBadUrl(r);
  }
  this.ignoreTrailingSlash && (r = Kd(r));
  const c = r;
  this.caseSensitive === !1 && (r = r.toLowerCase());
  const f = this.maxParamLength;
  let l = s.prefix.length;
  const d = [], g = r.length, p = [];
  for (; ; ) {
    if (l === g && s.isLeafNode) {
      const m = s.handlerStorage.getMatchingHandler(n);
      if (m !== null)
        return {
          handler: m.handler,
          store: m.store,
          params: m._createParamsObject(d),
          searchParams: this.querystringParser(o)
        };
    }
    let u = s.getNextNode(r, l, p, d.length);
    if (u === null) {
      if (p.length === 0)
        return null;
      const m = p.pop();
      l = m.brotherPathIndex, d.splice(m.paramsCount), u = m.brotherNode;
    }
    if (s = u, s.kind === gy.STATIC) {
      l += s.prefix.length;
      continue;
    }
    if (s.kind === gy.WILDCARD) {
      let m = c.slice(l);
      a && (m = vy(m)), d.push(m), l = g;
      continue;
    }
    let h = c.indexOf("/", l);
    h === -1 && (h = g);
    let b = c.slice(l, h);
    if (a && (b = vy(b)), s.isRegex) {
      const m = s.regex.exec(b);
      if (m === null) continue;
      for (let v = 1; v < m.length; v++) {
        const y = m[v];
        if (y.length > f)
          return null;
        d.push(y);
      }
    } else {
      if (b.length > f)
        return null;
      d.push(b);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    l = h;
  }
};
<<<<<<< HEAD
at.prototype._rebuild = function(e) {
  this.reset();
  for (const t of e) {
    const { method: r, path: n, opts: i, handler: s, store: o } = t;
    this._on(r, n, i, s, o);
  }
};
at.prototype._defaultRoute = function(e, t, r) {
=======
Be.prototype._rebuild = function(e) {
  this.reset();
  for (const t of e) {
    const { method: r, path: n, opts: s, handler: i, store: o } = t;
    this._on(r, n, s, i, o);
  }
};
Be.prototype._defaultRoute = function(e, t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (this.defaultRoute !== null)
    return r === void 0 ? this.defaultRoute(e, t) : this.defaultRoute.call(r, e, t);
  t.statusCode = 404, t.end();
};
<<<<<<< HEAD
at.prototype._onBadUrl = function(e) {
=======
Be.prototype._onBadUrl = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (this.onBadUrl === null)
    return null;
  const t = this.onBadUrl;
  return {
<<<<<<< HEAD
    handler: (r, n, i) => t(e, r, n),
=======
    handler: (r, n, s) => t(e, r, n),
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    params: {},
    store: null
  };
};
<<<<<<< HEAD
at.prototype.prettyPrint = function(e = {}) {
=======
Be.prototype.prettyPrint = function(e = {}) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = e.method;
  e.buildPrettyMeta = this.buildPrettyMeta.bind(this);
  let r = null;
  if (t === void 0) {
<<<<<<< HEAD
    const { version: n, host: i, ...s } = this.constrainer.strategies;
    s[Gd.name] = Gd;
    const o = new at({ ...this._opts, constraints: s }), a = this.routes.map((c) => {
      const u = {
        ...c.opts.constraints,
        [Gd.name]: c.method
      };
      return { ...c, method: "MERGED", opts: { constraints: u } };
=======
    const { version: n, host: s, ...i } = this.constrainer.strategies;
    i[cl.name] = cl;
    const o = new Be({ ...this._opts, constraints: i }), a = this.routes.map((c) => {
      const f = {
        ...c.opts.constraints,
        [cl.name]: c.method
      };
      return { ...c, method: "MERGED", opts: { constraints: f } };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    });
    o._rebuild(a), r = o.trees.MERGED;
  } else
    r = this.trees[t];
<<<<<<< HEAD
  return r == null ? "(empty tree)" : f4(r, e);
};
for (const e in ks) {
  if (!ks.hasOwnProperty(e)) continue;
  const t = ks[e], r = t.toLowerCase();
  at.prototype[r] = function(n, i, s) {
    return this.on(t, n, i, s);
  };
}
at.prototype.all = function(e, t, r) {
  this.on(ks, e, t, r);
};
var c1 = at;
function l1(e) {
  return e.replace(o1, "\\$&");
}
function fy(e) {
  return e.indexOf("//") !== -1 ? e.replace(a1, "/") : e;
}
function dy(e) {
  return e.length > 1 && e.charCodeAt(e.length - 1) === 47 ? e.slice(0, -1) : e;
}
function u1(e) {
  return e.charCodeAt(1) === 94 && (e = e.slice(0, 1) + e.slice(2)), e.charCodeAt(e.length - 2) === 36 && (e = e.slice(0, e.length - 2) + e.slice(e.length - 1)), e;
}
function f1(e, t) {
=======
  return r == null ? "(empty tree)" : pF(r, e);
};
for (const e in Bn) {
  if (!Bn.hasOwnProperty(e)) continue;
  const t = Bn[e], r = t.toLowerCase();
  Be.prototype[r] = function(n, s, i) {
    return this.on(t, n, s, i);
  };
}
Be.prototype.all = function(e, t, r) {
  this.on(Bn, e, t, r);
};
var K_ = Be;
function J_(e) {
  return e.replace(G_, "\\$&");
}
function Wd(e) {
  return e.indexOf("//") !== -1 ? e.replace(W_, "/") : e;
}
function Kd(e) {
  return e.length > 1 && e.charCodeAt(e.length - 1) === 47 ? e.slice(0, -1) : e;
}
function Y_(e) {
  return e.charCodeAt(1) === 94 && (e = e.slice(0, 1) + e.slice(2)), e.charCodeAt(e.length - 2) === 36 && (e = e.slice(0, e.length - 2) + e.slice(e.length - 1)), e;
}
function X_(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let r = 1;
  for (; t < e.length; ) {
    if (t++, e.charCodeAt(t) === 92) {
      t++;
      continue;
    }
    if (e.charCodeAt(t) === 41 ? r-- : e.charCodeAt(t) === 40 && r++, !r) return t;
  }
  throw new TypeError('Invalid regexp expression in "' + e + '"');
}
<<<<<<< HEAD
function h4(e) {
  return e ? e.store ? Object.assign({}, e.store) : {} : {};
}
function Wd(e, t, r, n) {
=======
function yF(e) {
  return e ? e.store ? Object.assign({}, e.store) : {} : {};
}
function ll(e, t, r, n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (r === void 0) {
    t.header("content-length", "0"), n(null, null);
    return;
  }
  if (typeof r.resume == "function") {
<<<<<<< HEAD
    r.on("error", (s) => {
      t.log.error({ err: s }, "Error on Stream found for HEAD route");
    }), r.resume(), n(null, null);
    return;
  }
  const i = "" + Buffer.byteLength(r);
  t.header("content-length", i), n(null, null);
}
function m4(e) {
  return e == null ? Wd : Array.isArray(e) ? [...e, Wd] : [e, Wd];
}
var g4 = {
  parseHeadOnSendHandlers: m4
};
const y4 = c1, v4 = Cm, fb = cx, { onRequestAbortHookRunner: _4, lifecycleHooks: db, preParsingHookRunner: b4, onTimeoutHookRunner: E4, onRequestHookRunner: w4 } = Wi, { normalizeSchema: S4 } = Pu, { parseHeadOnSendHandlers: x4 } = g4, {
  compileSchemasForValidation: R4,
  compileSchemasForSerialization: $4
} = ox, {
  FST_ERR_SCH_VALIDATION_BUILD: T4,
  FST_ERR_SCH_SERIALIZATION_BUILD: O4,
  FST_ERR_DUPLICATED_ROUTE: P4,
  FST_ERR_INVALID_URL: C4,
  FST_ERR_HOOK_INVALID_HANDLER: pb,
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: A4,
  FST_ERR_ROUTE_DUPLICATED_HANDLER: I4,
  FST_ERR_ROUTE_HANDLER_NOT_FN: hb,
  FST_ERR_ROUTE_MISSING_HANDLER: N4,
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: k4,
  FST_ERR_ROUTE_METHOD_INVALID: D4,
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: L4,
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: F4,
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: Kd
} = Wt, {
  kRoutePrefix: j4,
  kSupportedHTTPMethods: Ih,
  kLogLevel: U4,
  kLogSerializers: mb,
  kHooks: gb,
  kSchemaController: M4,
  kOptions: yb,
  kReplySerializerDefault: Yd,
  kReplyIsError: H4,
  kRequestPayloadStream: q4,
  kDisableRequestLogging: B4,
  kSchemaErrorFormatter: z4,
  kErrorHandler: vb,
  kHasBeenDecorated: _b,
  kRequestAcceptVersion: Jd,
  kRouteByFastify: V4,
  kRouteContext: bb
} = Ft, { buildErrorHandler: G4 } = Cu, { createChildLogger: W4 } = Tu, { getGenReqId: K4 } = ay;
function Y4(e) {
  const t = y4(e.config);
  let r, n, i, s, o, a, c, u, l, f, m, p, d = !1;
=======
    r.on("error", (i) => {
      t.log.error({ err: i }, "Error on Stream found for HEAD route");
    }), r.resume(), n(null, null);
    return;
  }
  const s = "" + Buffer.byteLength(r);
  t.header("content-length", s), n(null, null);
}
function gF(e) {
  return e == null ? ll : Array.isArray(e) ? [...e, ll] : [e, ll];
}
var vF = {
  parseHeadOnSendHandlers: gF
};
const bF = K_, _F = pf, by = Kv, { onRequestAbortHookRunner: EF, lifecycleHooks: _y, preParsingHookRunner: SF, onTimeoutHookRunner: xF, onRequestHookRunner: wF } = bn, { normalizeSchema: RF } = ua, { parseHeadOnSendHandlers: $F } = vF, {
  compileSchemasForValidation: TF,
  compileSchemasForSerialization: OF
} = Gv, {
  FST_ERR_SCH_VALIDATION_BUILD: CF,
  FST_ERR_SCH_SERIALIZATION_BUILD: PF,
  FST_ERR_DUPLICATED_ROUTE: IF,
  FST_ERR_INVALID_URL: NF,
  FST_ERR_HOOK_INVALID_HANDLER: Ey,
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: AF,
  FST_ERR_ROUTE_DUPLICATED_HANDLER: kF,
  FST_ERR_ROUTE_HANDLER_NOT_FN: Sy,
  FST_ERR_ROUTE_MISSING_HANDLER: LF,
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: jF,
  FST_ERR_ROUTE_METHOD_INVALID: DF,
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: FF,
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: MF,
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: ul
} = _t, {
  kRoutePrefix: zF,
  kSupportedHTTPMethods: Tu,
  kLogLevel: UF,
  kLogSerializers: xy,
  kHooks: wy,
  kSchemaController: qF,
  kOptions: Ry,
  kReplySerializerDefault: fl,
  kReplyIsError: HF,
  kRequestPayloadStream: BF,
  kDisableRequestLogging: VF,
  kSchemaErrorFormatter: GF,
  kErrorHandler: $y,
  kHasBeenDecorated: Ty,
  kRequestAcceptVersion: dl,
  kRouteByFastify: WF,
  kRouteContext: Oy
} = ht, { buildErrorHandler: KF } = fa, { createChildLogger: JF } = ca, { getGenReqId: YF } = Hd;
function XF(e) {
  const t = bF(e.config);
  let r, n, s, i, o, a, c, f, l, d, g, p, u = !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    /**
     * @param {import('../fastify').FastifyServerOptions} options
     * @param {*} fastifyArgs
     */
<<<<<<< HEAD
    setup(C, V) {
      r = V.avvio, n = V.fourOhFour, i = V.logger, s = V.hasLogger, o = V.setupResponseListeners, a = V.throwIfAlreadyStarted, m = C.exposeHeadRoutes, c = C.disableRequestLogging, u = C.ignoreTrailingSlash, l = C.ignoreDuplicateSlashes, f = Object.hasOwn(C, "return503OnClosing") ? C.return503OnClosing : !0, p = V.keepAliveConnections;
=======
    setup(O, z) {
      r = z.avvio, n = z.fourOhFour, s = z.logger, i = z.hasLogger, o = z.setupResponseListeners, a = z.throwIfAlreadyStarted, g = O.exposeHeadRoutes, c = O.disableRequestLogging, f = O.ignoreTrailingSlash, l = O.ignoreDuplicateSlashes, d = Object.hasOwn(O, "return503OnClosing") ? O.return503OnClosing : !0, p = z.keepAliveConnections;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    routing: t.lookup.bind(t),
    // router func to find the right handler to call
    route: R,
    // configure a route in the fastify instance
    hasRoute: y,
    prepareRoute: v,
<<<<<<< HEAD
    routeHandler: w,
    closeRoutes: () => {
      d = !0;
    },
    printRoutes: t.prettyPrint.bind(t),
    addConstraintStrategy: h,
    hasConstraintStrategy: _,
    isAsyncConstraint: g,
    findRoute: E
  };
  function h(C) {
    return a("Cannot add constraint strategy!"), t.addConstraintStrategy(C);
  }
  function _(C) {
    return t.hasConstraintStrategy(C);
  }
  function g() {
    return t.constrainer.asyncStrategiesInUse.size > 0;
  }
  function v({ method: C, url: V, options: b, handler: F, isFastify: H }) {
    if (typeof V != "string")
      throw new C4(typeof V);
    if (!F && typeof b == "function")
      F = b, b = {};
    else if (F && typeof F == "function") {
      if (Object.prototype.toString.call(b) !== "[object Object]")
        throw new A4(C, V);
      if (b.handler)
        throw typeof b.handler == "function" ? new I4(C, V) : new hb(C, V);
    }
    return b = Object.assign({}, b, {
      method: C,
      url: V,
      path: V,
      handler: F || b && b.handler
    }), R.call(this, { options: b, isFastify: H });
  }
  function y({ options: C }) {
    var b;
    const V = ((b = C.method) == null ? void 0 : b.toUpperCase()) ?? "";
    return t.hasRoute(
      V,
      C.url || "",
      C.constraints
    );
  }
  function E(C) {
    const V = t.find(
      C.method,
      C.url || "",
      C.constraints
    );
    return V ? {
      handler: V.handler,
      params: V.params,
      searchParams: V.searchParams
    } : null;
  }
  function R({ options: C, isFastify: V }) {
    a("Cannot add route!");
    const b = { ...C }, F = b.url || b.path || "";
    if (!b.handler)
      throw new N4(b.method, F);
    if (b.errorHandler !== void 0 && typeof b.errorHandler != "function")
      throw new hb(b.method, F);
    d1(b.bodyLimit);
    const H = b.exposeHeadRoute ?? m;
    let q = !1, $ = !1;
    if (Array.isArray(b.method))
      for (let D = 0; D < b.method.length; ++D)
        b.method[D] = Eb.call(this, b.method[D]), wb.call(this, b.method[D], F, b.schema), q = b.method.includes("GET"), $ = b.method.includes("HEAD");
    else
      b.method = Eb.call(this, b.method), wb.call(this, b.method, F, b.schema), q = b.method === "GET", $ = b.method === "HEAD";
    const x = H && q ? { ...C } : null, A = this[j4];
    if (F === "/" && A.length > 0 && b.method !== "HEAD")
      switch (b.prefixTrailingSlash) {
        case "slash":
          P.call(this, { path: F, isFastify: V });
          break;
        case "no-slash":
          P.call(this, { path: "", isFastify: V });
          break;
        case "both":
        default:
          P.call(this, { path: "", isFastify: V }), u !== !0 && (l !== !0 || !A.endsWith("/")) && P.call(this, { path: F, prefixing: !0, isFastify: V });
      }
    else F[0] === "/" && A.endsWith("/") ? P.call(this, { path: F.slice(1), isFastify: V }) : P.call(this, { path: F, isFastify: V });
    return this;
    function P({ path: D, prefixing: I = !1, isFastify: L = !1 }) {
      const j = A + D;
      if (b.url = j, b.path = j, b.routePath = D, b.prefix = A, b.logLevel = b.logLevel || this[U4], (this[mb] || b.logSerializers) && (b.logSerializers = Object.assign(Object.create(this[mb]), b.logSerializers)), b.attachValidation == null && (b.attachValidation = !1), I === !1)
        for (const G of this[gb].onRoute)
          G.call(this, b);
      for (const G of db)
        if (b && G in b) {
          if (Array.isArray(b[G]))
            for (const O of b[G]) {
              if (typeof O != "function")
                throw new pb(G, Object.prototype.toString.call(O));
              if (G === "onSend" || G === "preSerialization" || G === "onError" || G === "preParsing") {
                if (O.constructor.name === "AsyncFunction" && O.length === 4)
                  throw new Kd();
              } else if (G === "onRequestAbort") {
                if (O.constructor.name === "AsyncFunction" && O.length !== 1)
                  throw new Kd();
              } else if (O.constructor.name === "AsyncFunction" && O.length === 3)
                throw new Kd();
            }
          else if (b[G] !== void 0 && typeof b[G] != "function")
            throw new pb(G, Object.prototype.toString.call(b[G]));
        }
      const k = b.constraints || {}, U = {
        ...b.config,
        url: j,
        method: b.method
      }, M = new v4({
        schema: b.schema,
        handler: b.handler.bind(this),
        config: U,
        errorHandler: b.errorHandler,
        childLoggerFactory: b.childLoggerFactory,
        bodyLimit: b.bodyLimit,
        logLevel: b.logLevel,
        logSerializers: b.logSerializers,
        attachValidation: b.attachValidation,
        schemaErrorFormatter: b.schemaErrorFormatter,
        replySerializer: this[Yd],
        validatorCompiler: b.validatorCompiler,
        serializerCompiler: b.serializerCompiler,
        exposeHeadRoute: H,
        prefixTrailingSlash: b.prefixTrailingSlash || "both",
        server: this,
        isFastify: L
      }), N = t.findRoute("HEAD", b.url, k) !== null;
      try {
        t.on(b.method, b.url, { constraints: k }, w, M);
      } catch (G) {
        if (!M[V4])
          throw G.message.includes(`Method '${b.method}' already declared for route`) ? new P4(b.method, b.url) : G;
      }
      if (this.after((G, O) => {
        M.errorHandler = b.errorHandler ? G4(this[vb], b.errorHandler) : this[vb], M._parserOptions.limit = b.bodyLimit || null, M.logLevel = b.logLevel, M.logSerializers = b.logSerializers, M.attachValidation = b.attachValidation, M[Yd] = this[Yd], M.schemaErrorFormatter = b.schemaErrorFormatter || this[z4] || M.schemaErrorFormatter, r.once("preReady", () => {
          for (const S of db) {
            const W = this[gb][S].concat(b[S] || []).map((z) => z.bind(this));
            M[S] = W.length ? W : null;
          }
          for (; !M.Request[_b] && M.Request.parent; )
            M.Request = M.Request.parent;
          for (; !M.Reply[_b] && M.Reply.parent; )
            M.Reply = M.Reply.parent;
          if (n.setContext(this, M), b.schema) {
            M.schema = S4(M.schema, this.initialConfig);
            const S = this[M4];
            !b.validatorCompiler && (b.schema.body || b.schema.headers || b.schema.querystring || b.schema.params) && S.setupValidator(this[yb]);
            try {
              const W = typeof (b == null ? void 0 : b.validatorCompiler) == "function" || S.isCustomValidatorCompiler;
              R4(M, b.validatorCompiler || S.validatorCompiler, W);
            } catch (W) {
              throw new T4(b.method, j, W.message);
            }
            b.schema.response && !b.serializerCompiler && S.setupSerializer(this[yb]);
            try {
              $4(M, b.serializerCompiler || S.serializerCompiler);
            } catch (W) {
              throw new O4(b.method, j, W.message);
            }
          }
        }), O(G);
      }), H && q && !$ && !N) {
        const G = x4(x.onSend);
        v.call(this, { method: "HEAD", url: D, options: { ...x, onSend: G }, isFastify: !0 });
      }
    }
  }
  function w(C, V, b, F, H) {
    const q = K4(F.server, C), $ = {
      level: F.logLevel
    };
    F.logSerializers && ($.serializers = F.logSerializers);
    const x = W4(F, i, C, q, $);
    if (x[B4] = c, d === !0 && (C.httpVersionMajor !== 2 && V.setHeader("Connection", "close"), f)) {
      const I = {
        "Content-Type": "application/json",
        "Content-Length": "80"
      };
      V.writeHead(503, I), V.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}'), x.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
      return;
    }
    String.prototype.toLowerCase.call(C.headers.connection || "") === "keep-alive" && p.has(C.socket) === !1 && (p.add(C.socket), C.socket.on("close", Z4.bind({ keepAliveConnections: p, socket: C.socket }))), C.headers[Jd] !== void 0 && (C.headers["accept-version"] = C.headers[Jd], C.headers[Jd] = void 0);
    const P = new F.Request(q, b, C, H, x, F), D = new F.Reply(V, P, x);
    c === !1 && x.info({ req: P }, "incoming request"), (s === !0 || F.onResponse !== null) && o(D), F.onRequest !== null ? w4(
      F.onRequest,
      P,
      D,
      Sb
    ) : Sb(null, P, D), F.onRequestAbort !== null && C.on("close", () => {
      C.aborted && _4(
        F.onRequestAbort,
        P,
        J4.bind(null, D)
      );
    }), F.onTimeout !== null && (P.raw.socket._meta || P.raw.socket.on("timeout", X4), P.raw.socket._meta = { context: F, request: P, reply: D });
  }
}
function J4(e, t) {
  t && e.log.error({ err: t }, "onRequestAborted hook failed");
}
function X4() {
  const { context: e, request: t, reply: r } = this._meta;
  E4(
    e.onTimeout,
    t,
    r,
    Q4
  );
}
function Eb(e) {
  if (typeof e != "string")
    throw new D4();
  if (e = e.toUpperCase(), !this[Ih].bodyless.has(e) && !this[Ih].bodywith.has(e))
    throw new k4(e);
  return e;
}
function wb(e, t, r) {
  if (this[Ih].bodyless.has(e) && (r != null && r.body))
    throw new L4(e, t);
}
function d1(e) {
  if (e !== void 0 && (!Number.isInteger(e) || e <= 0))
    throw new F4(e);
}
function Sb(e, t, r) {
  if (r.sent !== !0) {
    if (e != null) {
      r[H4] = !0, r.send(e);
      return;
    }
    t[q4] = t.raw, t[bb].preParsing !== null ? b4(t[bb].preParsing, t, r, fb.bind(t.server)) : fb.call(t.server, null, t, r);
  }
}
function Z4() {
  this.keepAliveConnections.delete(this.socket);
}
function Q4() {
}
var eV = { buildRouting: Y4, validateBodyLimitOption: d1 };
const tV = c1, xb = xm, Rb = Pm, rV = Cm, {
  kRoutePrefix: nV,
  kCanSetNotFoundHandler: To,
  kFourOhFourLevelInstance: Oo,
  kFourOhFourContext: Kr,
  kHooks: iV,
  kErrorHandler: $b
} = Ft, { lifecycleHooks: sV } = Wi, { buildErrorHandler: oV } = Cu, {
  FST_ERR_NOT_FOUND: aV
} = Wt, { createChildLogger: Tb } = Tu, { getGenReqId: Ob } = ay;
function cV(e) {
  const { logger: t, disableRequestLogging: r } = e, n = tV({ onBadUrl: a(), defaultRoute: f });
  let i = null;
  return { router: n, setNotFoundHandler: u, setContext: c, arrange404: s };
  function s(m) {
    m[Oo] = m, m[To] = !0, n.onBadUrl = n.onBadUrl.bind(m), n.defaultRoute = n.defaultRoute.bind(m);
  }
  function o(m, p) {
    const { url: d, method: h } = m.raw, _ = `Route ${h}:${d} not found`;
    r || m.log.info(_), p.code(404).send({
      message: _,
=======
    routeHandler: E,
    closeRoutes: () => {
      u = !0;
    },
    printRoutes: t.prettyPrint.bind(t),
    addConstraintStrategy: h,
    hasConstraintStrategy: b,
    isAsyncConstraint: m,
    findRoute: _
  };
  function h(O) {
    return a("Cannot add constraint strategy!"), t.addConstraintStrategy(O);
  }
  function b(O) {
    return t.hasConstraintStrategy(O);
  }
  function m() {
    return t.constrainer.asyncStrategiesInUse.size > 0;
  }
  function v({ method: O, url: z, options: S, handler: L, isFastify: M }) {
    if (typeof z != "string")
      throw new NF(typeof z);
    if (!L && typeof S == "function")
      L = S, S = {};
    else if (L && typeof L == "function") {
      if (Object.prototype.toString.call(S) !== "[object Object]")
        throw new AF(O, z);
      if (S.handler)
        throw typeof S.handler == "function" ? new kF(O, z) : new Sy(O, z);
    }
    return S = Object.assign({}, S, {
      method: O,
      url: z,
      path: z,
      handler: L || S && S.handler
    }), R.call(this, { options: S, isFastify: M });
  }
  function y({ options: O }) {
    var S;
    const z = ((S = O.method) == null ? void 0 : S.toUpperCase()) ?? "";
    return t.hasRoute(
      z,
      O.url || "",
      O.constraints
    );
  }
  function _(O) {
    const z = t.find(
      O.method,
      O.url || "",
      O.constraints
    );
    return z ? {
      handler: z.handler,
      params: z.params,
      searchParams: z.searchParams
    } : null;
  }
  function R({ options: O, isFastify: z }) {
    a("Cannot add route!");
    const S = { ...O }, L = S.url || S.path || "";
    if (!S.handler)
      throw new LF(S.method, L);
    if (S.errorHandler !== void 0 && typeof S.errorHandler != "function")
      throw new Sy(S.method, L);
    Z_(S.bodyLimit);
    const M = S.exposeHeadRoute ?? g;
    let U = !1, $ = !1;
    if (Array.isArray(S.method))
      for (let j = 0; j < S.method.length; ++j)
        S.method[j] = Cy.call(this, S.method[j]), Py.call(this, S.method[j], L, S.schema), U = S.method.includes("GET"), $ = S.method.includes("HEAD");
    else
      S.method = Cy.call(this, S.method), Py.call(this, S.method, L, S.schema), U = S.method === "GET", $ = S.method === "HEAD";
    const x = M && U ? { ...O } : null, I = this[zF];
    if (L === "/" && I.length > 0 && S.method !== "HEAD")
      switch (S.prefixTrailingSlash) {
        case "slash":
          T.call(this, { path: L, isFastify: z });
          break;
        case "no-slash":
          T.call(this, { path: "", isFastify: z });
          break;
        case "both":
        default:
          T.call(this, { path: "", isFastify: z }), f !== !0 && (l !== !0 || !I.endsWith("/")) && T.call(this, { path: L, prefixing: !0, isFastify: z });
      }
    else L[0] === "/" && I.endsWith("/") ? T.call(this, { path: L.slice(1), isFastify: z }) : T.call(this, { path: L, isFastify: z });
    return this;
    function T({ path: j, prefixing: C = !1, isFastify: A = !1 }) {
      const k = I + j;
      if (S.url = k, S.path = k, S.routePath = j, S.prefix = I, S.logLevel = S.logLevel || this[UF], (this[xy] || S.logSerializers) && (S.logSerializers = Object.assign(Object.create(this[xy]), S.logSerializers)), S.attachValidation == null && (S.attachValidation = !1), C === !1)
        for (const q of this[wy].onRoute)
          q.call(this, S);
      for (const q of _y)
        if (S && q in S) {
          if (Array.isArray(S[q]))
            for (const K of S[q]) {
              if (typeof K != "function")
                throw new Ey(q, Object.prototype.toString.call(K));
              if (q === "onSend" || q === "preSerialization" || q === "onError" || q === "preParsing") {
                if (K.constructor.name === "AsyncFunction" && K.length === 4)
                  throw new ul();
              } else if (q === "onRequestAbort") {
                if (K.constructor.name === "AsyncFunction" && K.length !== 1)
                  throw new ul();
              } else if (K.constructor.name === "AsyncFunction" && K.length === 3)
                throw new ul();
            }
          else if (S[q] !== void 0 && typeof S[q] != "function")
            throw new Ey(q, Object.prototype.toString.call(S[q]));
        }
      const P = S.constraints || {}, D = {
        ...S.config,
        url: k,
        method: S.method
      }, F = new _F({
        schema: S.schema,
        handler: S.handler.bind(this),
        config: D,
        errorHandler: S.errorHandler,
        childLoggerFactory: S.childLoggerFactory,
        bodyLimit: S.bodyLimit,
        logLevel: S.logLevel,
        logSerializers: S.logSerializers,
        attachValidation: S.attachValidation,
        schemaErrorFormatter: S.schemaErrorFormatter,
        replySerializer: this[fl],
        validatorCompiler: S.validatorCompiler,
        serializerCompiler: S.serializerCompiler,
        exposeHeadRoute: M,
        prefixTrailingSlash: S.prefixTrailingSlash || "both",
        server: this,
        isFastify: A
      }), N = t.findRoute("HEAD", S.url, P) !== null;
      try {
        t.on(S.method, S.url, { constraints: P }, E, F);
      } catch (q) {
        if (!F[WF])
          throw q.message.includes(`Method '${S.method}' already declared for route`) ? new IF(S.method, S.url) : q;
      }
      if (this.after((q, K) => {
        F.errorHandler = S.errorHandler ? KF(this[$y], S.errorHandler) : this[$y], F._parserOptions.limit = S.bodyLimit || null, F.logLevel = S.logLevel, F.logSerializers = S.logSerializers, F.attachValidation = S.attachValidation, F[fl] = this[fl], F.schemaErrorFormatter = S.schemaErrorFormatter || this[GF] || F.schemaErrorFormatter, r.once("preReady", () => {
          for (const V of _y) {
            const Z = this[wy][V].concat(S[V] || []).map((Y) => Y.bind(this));
            F[V] = Z.length ? Z : null;
          }
          for (; !F.Request[Ty] && F.Request.parent; )
            F.Request = F.Request.parent;
          for (; !F.Reply[Ty] && F.Reply.parent; )
            F.Reply = F.Reply.parent;
          if (n.setContext(this, F), S.schema) {
            F.schema = RF(F.schema, this.initialConfig);
            const V = this[qF];
            !S.validatorCompiler && (S.schema.body || S.schema.headers || S.schema.querystring || S.schema.params) && V.setupValidator(this[Ry]);
            try {
              const Z = typeof (S == null ? void 0 : S.validatorCompiler) == "function" || V.isCustomValidatorCompiler;
              TF(F, S.validatorCompiler || V.validatorCompiler, Z);
            } catch (Z) {
              throw new CF(S.method, k, Z.message);
            }
            S.schema.response && !S.serializerCompiler && V.setupSerializer(this[Ry]);
            try {
              OF(F, S.serializerCompiler || V.serializerCompiler);
            } catch (Z) {
              throw new PF(S.method, k, Z.message);
            }
          }
        }), K(q);
      }), M && U && !$ && !N) {
        const q = $F(x.onSend);
        v.call(this, { method: "HEAD", url: j, options: { ...x, onSend: q }, isFastify: !0 });
      }
    }
  }
  function E(O, z, S, L, M) {
    const U = YF(L.server, O), $ = {
      level: L.logLevel
    };
    L.logSerializers && ($.serializers = L.logSerializers);
    const x = JF(L, s, O, U, $);
    if (x[VF] = c, u === !0 && (O.httpVersionMajor !== 2 && z.setHeader("Connection", "close"), d)) {
      const C = {
        "Content-Type": "application/json",
        "Content-Length": "80"
      };
      z.writeHead(503, C), z.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}'), x.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
      return;
    }
    String.prototype.toLowerCase.call(O.headers.connection || "") === "keep-alive" && p.has(O.socket) === !1 && (p.add(O.socket), O.socket.on("close", e2.bind({ keepAliveConnections: p, socket: O.socket }))), O.headers[dl] !== void 0 && (O.headers["accept-version"] = O.headers[dl], O.headers[dl] = void 0);
    const T = new L.Request(U, S, O, M, x, L), j = new L.Reply(z, T, x);
    c === !1 && x.info({ req: T }, "incoming request"), (i === !0 || L.onResponse !== null) && o(j), L.onRequest !== null ? wF(
      L.onRequest,
      T,
      j,
      Iy
    ) : Iy(null, T, j), L.onRequestAbort !== null && O.on("close", () => {
      O.aborted && EF(
        L.onRequestAbort,
        T,
        ZF.bind(null, j)
      );
    }), L.onTimeout !== null && (T.raw.socket._meta || T.raw.socket.on("timeout", QF), T.raw.socket._meta = { context: L, request: T, reply: j });
  }
}
function ZF(e, t) {
  t && e.log.error({ err: t }, "onRequestAborted hook failed");
}
function QF() {
  const { context: e, request: t, reply: r } = this._meta;
  xF(
    e.onTimeout,
    t,
    r,
    t2
  );
}
function Cy(e) {
  if (typeof e != "string")
    throw new DF();
  if (e = e.toUpperCase(), !this[Tu].bodyless.has(e) && !this[Tu].bodywith.has(e))
    throw new jF(e);
  return e;
}
function Py(e, t, r) {
  if (this[Tu].bodyless.has(e) && (r != null && r.body))
    throw new FF(e, t);
}
function Z_(e) {
  if (e !== void 0 && (!Number.isInteger(e) || e <= 0))
    throw new MF(e);
}
function Iy(e, t, r) {
  if (r.sent !== !0) {
    if (e != null) {
      r[HF] = !0, r.send(e);
      return;
    }
    t[BF] = t.raw, t[Oy].preParsing !== null ? SF(t[Oy].preParsing, t, r, by.bind(t.server)) : by.call(t.server, null, t, r);
  }
}
function e2() {
  this.keepAliveConnections.delete(this.socket);
}
function t2() {
}
var r2 = { buildRouting: XF, validateBodyLimitOption: Z_ };
const n2 = K_, Ny = af, Ay = df, s2 = pf, {
  kRoutePrefix: i2,
  kCanSetNotFoundHandler: Es,
  kFourOhFourLevelInstance: Ss,
  kFourOhFourContext: sr,
  kHooks: o2,
  kErrorHandler: ky
} = ht, { lifecycleHooks: a2 } = bn, { buildErrorHandler: c2 } = fa, {
  FST_ERR_NOT_FOUND: l2
} = _t, { createChildLogger: Ly } = ca, { getGenReqId: jy } = Hd;
function u2(e) {
  const { logger: t, disableRequestLogging: r } = e, n = n2({ onBadUrl: a(), defaultRoute: d });
  let s = null;
  return { router: n, setNotFoundHandler: f, setContext: c, arrange404: i };
  function i(g) {
    g[Ss] = g, g[Es] = !0, n.onBadUrl = n.onBadUrl.bind(g), n.defaultRoute = n.defaultRoute.bind(g);
  }
  function o(g, p) {
    const { url: u, method: h } = g.raw, b = `Route ${h}:${u} not found`;
    r || g.log.info(b), p.code(404).send({
      message: b,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      error: "Not Found",
      statusCode: 404
    });
  }
  function a() {
<<<<<<< HEAD
    return function(p, d, h) {
      const _ = this[Oo][Kr], g = Ob(_.server, d), v = Tb(_, t, d, g), y = new Rb(g, null, d, null, v, _), E = new xb(h, y, v);
      i(y, E);
    };
  }
  function c(m, p) {
    const d = Object.assign({}, m[Kr]);
    d.onSend = p.onSend, p[Kr] = d;
  }
  function u(m, p, d, h) {
    this[To] === void 0 && (this[To] = !0), this[Kr] === void 0 && (this[Kr] = null);
    const _ = this, g = this[nV] || "/";
    if (this[To] === !1)
      throw new Error(`Not found handler already set for Fastify instance with prefix: '${g}'`);
    typeof m == "object" && (m.preHandler && (Array.isArray(m.preHandler) ? m.preHandler = m.preHandler.map((v) => v.bind(_)) : m.preHandler = m.preHandler.bind(_)), m.preValidation && (Array.isArray(m.preValidation) ? m.preValidation = m.preValidation.map((v) => v.bind(_)) : m.preValidation = m.preValidation.bind(_))), typeof m == "function" && (p = m, m = void 0), m = m || {}, p ? (this[Oo][To] = !1, p = p.bind(this), i = p) : (p = o, i = o), this.after((v, y) => {
      l.call(this, g, m, p, d, h), y(v);
    });
  }
  function l(m, p, d, h, _) {
    const g = new rV({
      schema: p.schema,
      handler: d,
=======
    return function(p, u, h) {
      const b = this[Ss][sr], m = jy(b.server, u), v = Ly(b, t, u, m), y = new Ay(m, null, u, null, v, b), _ = new Ny(h, y, v);
      s(y, _);
    };
  }
  function c(g, p) {
    const u = Object.assign({}, g[sr]);
    u.onSend = p.onSend, p[sr] = u;
  }
  function f(g, p, u, h) {
    this[Es] === void 0 && (this[Es] = !0), this[sr] === void 0 && (this[sr] = null);
    const b = this, m = this[i2] || "/";
    if (this[Es] === !1)
      throw new Error(`Not found handler already set for Fastify instance with prefix: '${m}'`);
    typeof g == "object" && (g.preHandler && (Array.isArray(g.preHandler) ? g.preHandler = g.preHandler.map((v) => v.bind(b)) : g.preHandler = g.preHandler.bind(b)), g.preValidation && (Array.isArray(g.preValidation) ? g.preValidation = g.preValidation.map((v) => v.bind(b)) : g.preValidation = g.preValidation.bind(b))), typeof g == "function" && (p = g, g = void 0), g = g || {}, p ? (this[Ss][Es] = !1, p = p.bind(this), s = p) : (p = o, s = o), this.after((v, y) => {
      l.call(this, m, g, p, u, h), y(v);
    });
  }
  function l(g, p, u, h, b) {
    const m = new s2({
      schema: p.schema,
      handler: u,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      config: p.config || {},
      server: this
    });
    if (h.once("preReady", () => {
<<<<<<< HEAD
      const v = this[Kr];
      for (const y of sV) {
        const E = this[iV][y].concat(p[y] || []).map((R) => R.bind(this));
        v[y] = E.length ? E : null;
      }
      v.errorHandler = p.errorHandler ? oV(this[$b], p.errorHandler) : this[$b];
    }), this[Kr] !== null && m === "/") {
      Object.assign(this[Kr], g);
      return;
    }
    this[Oo][Kr] = g, n.all(m + (m.endsWith("/") ? "*" : "/*"), _, g), n.all(m, _, g);
  }
  function f(m, p) {
    const d = this[Oo][Kr], h = Ob(d.server, m), _ = Tb(d, t, m, h);
    _.info({ req: m }, "incoming request");
    const g = new Rb(h, null, m, null, _, d), v = new xb(p, g, _);
    g.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it"), g.log.warn(n.prettyPrint()), v.code(404).send(new aV());
  }
}
var lV = cV, rf = { exports: {} }, nf = { exports: {} };
nf.exports = De;
nf.exports.default = De;
const uV = { properties: { connectionTimeout: { type: "integer", default: 0 }, keepAliveTimeout: { type: "integer", default: 72e3 }, forceCloseConnections: { oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }] }, maxRequestsPerSocket: { type: "integer", default: 0, nullable: !0 }, requestTimeout: { type: "integer", default: 0 }, bodyLimit: { type: "integer", default: 1048576 }, caseSensitive: { type: "boolean", default: !0 }, allowUnsafeRegex: { type: "boolean", default: !1 }, http2: { type: "boolean" }, https: { if: { not: { oneOf: [{ type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: !1, required: ["allowHTTP1"], properties: { allowHTTP1: { type: "boolean" } } }] } }, then: { setDefaultValue: !0 } }, ignoreTrailingSlash: { type: "boolean", default: !1 }, ignoreDuplicateSlashes: { type: "boolean", default: !1 }, disableRequestLogging: { type: "boolean", default: !1 }, maxParamLength: { type: "integer", default: 100 }, onProtoPoisoning: { type: "string", default: "error" }, onConstructorPoisoning: { type: "string", default: "error" }, pluginTimeout: { type: "integer", default: 1e4 }, requestIdHeader: { anyOf: [{ type: "boolean" }, { type: "string" }], default: !1 }, requestIdLogLabel: { type: "string", default: "reqId" }, http2SessionTimeout: { type: "integer", default: 72e3 }, exposeHeadRoutes: { type: "boolean", default: !0 }, useSemicolonDelimiter: { type: "boolean", default: !1 }, constraints: { type: "object", additionalProperties: { type: "object", required: ["name", "storage", "validate", "deriveConstraint"], additionalProperties: !0, properties: { name: { type: "string" }, storage: {}, validate: {}, deriveConstraint: {} } } } } }, fV = Object.prototype.hasOwnProperty, dV = new RegExp("idle", "u");
function De(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (o === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      e.connectionTimeout === void 0 && (e.connectionTimeout = 0), e.keepAliveTimeout === void 0 && (e.keepAliveTimeout = 72e3), e.maxRequestsPerSocket === void 0 && (e.maxRequestsPerSocket = 0), e.requestTimeout === void 0 && (e.requestTimeout = 0), e.bodyLimit === void 0 && (e.bodyLimit = 1048576), e.caseSensitive === void 0 && (e.caseSensitive = !0), e.allowUnsafeRegex === void 0 && (e.allowUnsafeRegex = !1), e.ignoreTrailingSlash === void 0 && (e.ignoreTrailingSlash = !1), e.ignoreDuplicateSlashes === void 0 && (e.ignoreDuplicateSlashes = !1), e.disableRequestLogging === void 0 && (e.disableRequestLogging = !1), e.maxParamLength === void 0 && (e.maxParamLength = 100), e.onProtoPoisoning === void 0 && (e.onProtoPoisoning = "error"), e.onConstructorPoisoning === void 0 && (e.onConstructorPoisoning = "error"), e.pluginTimeout === void 0 && (e.pluginTimeout = 1e4), e.requestIdHeader === void 0 && (e.requestIdHeader = !1), e.requestIdLogLabel === void 0 && (e.requestIdLogLabel = "reqId"), e.http2SessionTimeout === void 0 && (e.http2SessionTimeout = 72e3), e.exposeHeadRoutes === void 0 && (e.exposeHeadRoutes = !0), e.useSemicolonDelimiter === void 0 && (e.useSemicolonDelimiter = !1);
      const d = o;
      for (const h in e)
        fV.call(uV.properties, h) || delete e[h];
      if (d === o) {
        let h = e.connectionTimeout;
        const _ = o;
        if (!(typeof h == "number" && !(h % 1) && !isNaN(h) && isFinite(h))) {
          let g = typeof h, v;
          if (v === void 0)
            if (g === "boolean" || h === null || g === "string" && h && h == +h && !(h % 1))
              v = +h;
            else
              return De.errors = [{ instancePath: t + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
          v !== void 0 && (h = v, e !== void 0 && (e.connectionTimeout = v));
        }
        var a = _ === o;
        if (a) {
          let g = e.keepAliveTimeout;
          const v = o;
          if (!(typeof g == "number" && !(g % 1) && !isNaN(g) && isFinite(g))) {
            let E = typeof g, R;
            if (R === void 0)
              if (E === "boolean" || g === null || E === "string" && g && g == +g && !(g % 1))
                R = +g;
              else
                return De.errors = [{ instancePath: t + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
            R !== void 0 && (g = R, e !== void 0 && (e.keepAliveTimeout = R));
=======
      const v = this[sr];
      for (const y of a2) {
        const _ = this[o2][y].concat(p[y] || []).map((R) => R.bind(this));
        v[y] = _.length ? _ : null;
      }
      v.errorHandler = p.errorHandler ? c2(this[ky], p.errorHandler) : this[ky];
    }), this[sr] !== null && g === "/") {
      Object.assign(this[sr], m);
      return;
    }
    this[Ss][sr] = m, n.all(g + (g.endsWith("/") ? "*" : "/*"), b, m), n.all(g, b, m);
  }
  function d(g, p) {
    const u = this[Ss][sr], h = jy(u.server, g), b = Ly(u, t, g, h);
    b.info({ req: g }, "incoming request");
    const m = new Ay(h, null, g, null, b, u), v = new Ny(p, m, b);
    m.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it"), m.log.warn(n.prettyPrint()), v.code(404).send(new l2());
  }
}
var f2 = u2, Da = { exports: {} }, Fa = { exports: {} };
Fa.exports = $e;
Fa.exports.default = $e;
const d2 = { properties: { connectionTimeout: { type: "integer", default: 0 }, keepAliveTimeout: { type: "integer", default: 72e3 }, forceCloseConnections: { oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }] }, maxRequestsPerSocket: { type: "integer", default: 0, nullable: !0 }, requestTimeout: { type: "integer", default: 0 }, bodyLimit: { type: "integer", default: 1048576 }, caseSensitive: { type: "boolean", default: !0 }, allowUnsafeRegex: { type: "boolean", default: !1 }, http2: { type: "boolean" }, https: { if: { not: { oneOf: [{ type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: !1, required: ["allowHTTP1"], properties: { allowHTTP1: { type: "boolean" } } }] } }, then: { setDefaultValue: !0 } }, ignoreTrailingSlash: { type: "boolean", default: !1 }, ignoreDuplicateSlashes: { type: "boolean", default: !1 }, disableRequestLogging: { type: "boolean", default: !1 }, maxParamLength: { type: "integer", default: 100 }, onProtoPoisoning: { type: "string", default: "error" }, onConstructorPoisoning: { type: "string", default: "error" }, pluginTimeout: { type: "integer", default: 1e4 }, requestIdHeader: { anyOf: [{ type: "boolean" }, { type: "string" }], default: !1 }, requestIdLogLabel: { type: "string", default: "reqId" }, http2SessionTimeout: { type: "integer", default: 72e3 }, exposeHeadRoutes: { type: "boolean", default: !0 }, useSemicolonDelimiter: { type: "boolean", default: !1 }, constraints: { type: "object", additionalProperties: { type: "object", required: ["name", "storage", "validate", "deriveConstraint"], additionalProperties: !0, properties: { name: { type: "string" }, storage: {}, validate: {}, deriveConstraint: {} } } } } }, p2 = Object.prototype.hasOwnProperty, h2 = new RegExp("idle", "u");
function $e(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: s = e } = {}) {
  let i = null, o = 0;
  if (o === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      e.connectionTimeout === void 0 && (e.connectionTimeout = 0), e.keepAliveTimeout === void 0 && (e.keepAliveTimeout = 72e3), e.maxRequestsPerSocket === void 0 && (e.maxRequestsPerSocket = 0), e.requestTimeout === void 0 && (e.requestTimeout = 0), e.bodyLimit === void 0 && (e.bodyLimit = 1048576), e.caseSensitive === void 0 && (e.caseSensitive = !0), e.allowUnsafeRegex === void 0 && (e.allowUnsafeRegex = !1), e.ignoreTrailingSlash === void 0 && (e.ignoreTrailingSlash = !1), e.ignoreDuplicateSlashes === void 0 && (e.ignoreDuplicateSlashes = !1), e.disableRequestLogging === void 0 && (e.disableRequestLogging = !1), e.maxParamLength === void 0 && (e.maxParamLength = 100), e.onProtoPoisoning === void 0 && (e.onProtoPoisoning = "error"), e.onConstructorPoisoning === void 0 && (e.onConstructorPoisoning = "error"), e.pluginTimeout === void 0 && (e.pluginTimeout = 1e4), e.requestIdHeader === void 0 && (e.requestIdHeader = !1), e.requestIdLogLabel === void 0 && (e.requestIdLogLabel = "reqId"), e.http2SessionTimeout === void 0 && (e.http2SessionTimeout = 72e3), e.exposeHeadRoutes === void 0 && (e.exposeHeadRoutes = !0), e.useSemicolonDelimiter === void 0 && (e.useSemicolonDelimiter = !1);
      const u = o;
      for (const h in e)
        p2.call(d2.properties, h) || delete e[h];
      if (u === o) {
        let h = e.connectionTimeout;
        const b = o;
        if (!(typeof h == "number" && !(h % 1) && !isNaN(h) && isFinite(h))) {
          let m = typeof h, v;
          if (v === void 0)
            if (m === "boolean" || h === null || m === "string" && h && h == +h && !(h % 1))
              v = +h;
            else
              return $e.errors = [{ instancePath: t + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
          v !== void 0 && (h = v, e !== void 0 && (e.connectionTimeout = v));
        }
        var a = b === o;
        if (a) {
          let m = e.keepAliveTimeout;
          const v = o;
          if (!(typeof m == "number" && !(m % 1) && !isNaN(m) && isFinite(m))) {
            let _ = typeof m, R;
            if (R === void 0)
              if (_ === "boolean" || m === null || _ === "string" && m && m == +m && !(m % 1))
                R = +m;
              else
                return $e.errors = [{ instancePath: t + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
            R !== void 0 && (m = R, e !== void 0 && (e.keepAliveTimeout = R));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          }
          var a = v === o;
          if (a) {
            if (e.forceCloseConnections !== void 0) {
<<<<<<< HEAD
              let E = e.forceCloseConnections;
              const R = o, w = o;
              let C = !1, V = null;
              const b = o;
              if (typeof E != "string") {
                let q = typeof E, $;
                if ($ === void 0)
                  if (q == "number" || q == "boolean")
                    $ = "" + E;
                  else if (E === null)
                    $ = "";
                  else {
                    const x = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    s === null ? s = [x] : s.push(x), o++;
                  }
                $ !== void 0 && (E = $, e !== void 0 && (e.forceCloseConnections = $));
              }
              if (o === b && typeof E == "string" && !dV.test(E)) {
                const q = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                s === null ? s = [q] : s.push(q), o++;
              }
              var c = b === o;
              c && (C = !0, V = 0);
              const F = o;
              if (typeof E != "boolean") {
                let q;
                if (q === void 0)
                  if (E === "false" || E === 0 || E === null)
                    q = !1;
                  else if (E === "true" || E === 1)
                    q = !0;
                  else {
                    const $ = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    s === null ? s = [$] : s.push($), o++;
                  }
                q !== void 0 && (E = q, e !== void 0 && (e.forceCloseConnections = q));
              }
              var c = F === o;
              if (c && C ? (C = !1, V = [V, 1]) : c && (C = !0, V = 1), C)
                o = w, s !== null && (w ? s.length = w : s = null);
              else {
                const q = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: V }, message: "must match exactly one schema in oneOf" };
                return s === null ? s = [q] : s.push(q), o++, De.errors = s, !1;
=======
              let _ = e.forceCloseConnections;
              const R = o, E = o;
              let O = !1, z = null;
              const S = o;
              if (typeof _ != "string") {
                let U = typeof _, $;
                if ($ === void 0)
                  if (U == "number" || U == "boolean")
                    $ = "" + _;
                  else if (_ === null)
                    $ = "";
                  else {
                    const x = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    i === null ? i = [x] : i.push(x), o++;
                  }
                $ !== void 0 && (_ = $, e !== void 0 && (e.forceCloseConnections = $));
              }
              if (o === S && typeof _ == "string" && !h2.test(_)) {
                const U = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                i === null ? i = [U] : i.push(U), o++;
              }
              var c = S === o;
              c && (O = !0, z = 0);
              const L = o;
              if (typeof _ != "boolean") {
                let U;
                if (U === void 0)
                  if (_ === "false" || _ === 0 || _ === null)
                    U = !1;
                  else if (_ === "true" || _ === 1)
                    U = !0;
                  else {
                    const $ = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    i === null ? i = [$] : i.push($), o++;
                  }
                U !== void 0 && (_ = U, e !== void 0 && (e.forceCloseConnections = U));
              }
              var c = L === o;
              if (c && O ? (O = !1, z = [z, 1]) : c && (O = !0, z = 1), O)
                o = E, i !== null && (E ? i.length = E : i = null);
              else {
                const U = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: z }, message: "must match exactly one schema in oneOf" };
                return i === null ? i = [U] : i.push(U), o++, $e.errors = i, !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
              }
              var a = R === o;
            } else
              var a = !0;
            if (a) {
<<<<<<< HEAD
              let E = e.maxRequestsPerSocket;
              const R = o;
              if (!(typeof E == "number" && !(E % 1) && !isNaN(E) && isFinite(E)) && E !== null) {
                let C = typeof E, V;
                if (V === void 0)
                  if (C === "boolean" || E === null || C === "string" && E && E == +E && !(E % 1))
                    V = +E;
                  else if (E === "" || E === 0 || E === !1)
                    V = null;
                  else
                    return De.errors = [{ instancePath: t + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                V !== void 0 && (E = V, e !== void 0 && (e.maxRequestsPerSocket = V));
              }
              var a = R === o;
              if (a) {
                let C = e.requestTimeout;
                const V = o;
                if (!(typeof C == "number" && !(C % 1) && !isNaN(C) && isFinite(C))) {
                  let F = typeof C, H;
                  if (H === void 0)
                    if (F === "boolean" || C === null || F === "string" && C && C == +C && !(C % 1))
                      H = +C;
                    else
                      return De.errors = [{ instancePath: t + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                  H !== void 0 && (C = H, e !== void 0 && (e.requestTimeout = H));
                }
                var a = V === o;
                if (a) {
                  let F = e.bodyLimit;
                  const H = o;
                  if (!(typeof F == "number" && !(F % 1) && !isNaN(F) && isFinite(F))) {
                    let $ = typeof F, x;
                    if (x === void 0)
                      if ($ === "boolean" || F === null || $ === "string" && F && F == +F && !(F % 1))
                        x = +F;
                      else
                        return De.errors = [{ instancePath: t + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                    x !== void 0 && (F = x, e !== void 0 && (e.bodyLimit = x));
                  }
                  var a = H === o;
=======
              let _ = e.maxRequestsPerSocket;
              const R = o;
              if (!(typeof _ == "number" && !(_ % 1) && !isNaN(_) && isFinite(_)) && _ !== null) {
                let O = typeof _, z;
                if (z === void 0)
                  if (O === "boolean" || _ === null || O === "string" && _ && _ == +_ && !(_ % 1))
                    z = +_;
                  else if (_ === "" || _ === 0 || _ === !1)
                    z = null;
                  else
                    return $e.errors = [{ instancePath: t + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                z !== void 0 && (_ = z, e !== void 0 && (e.maxRequestsPerSocket = z));
              }
              var a = R === o;
              if (a) {
                let O = e.requestTimeout;
                const z = o;
                if (!(typeof O == "number" && !(O % 1) && !isNaN(O) && isFinite(O))) {
                  let L = typeof O, M;
                  if (M === void 0)
                    if (L === "boolean" || O === null || L === "string" && O && O == +O && !(O % 1))
                      M = +O;
                    else
                      return $e.errors = [{ instancePath: t + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                  M !== void 0 && (O = M, e !== void 0 && (e.requestTimeout = M));
                }
                var a = z === o;
                if (a) {
                  let L = e.bodyLimit;
                  const M = o;
                  if (!(typeof L == "number" && !(L % 1) && !isNaN(L) && isFinite(L))) {
                    let $ = typeof L, x;
                    if (x === void 0)
                      if ($ === "boolean" || L === null || $ === "string" && L && L == +L && !(L % 1))
                        x = +L;
                      else
                        return $e.errors = [{ instancePath: t + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                    x !== void 0 && (L = x, e !== void 0 && (e.bodyLimit = x));
                  }
                  var a = M === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                  if (a) {
                    let $ = e.caseSensitive;
                    const x = o;
                    if (typeof $ != "boolean") {
<<<<<<< HEAD
                      let P;
                      if (P === void 0)
                        if ($ === "false" || $ === 0 || $ === null)
                          P = !1;
                        else if ($ === "true" || $ === 1)
                          P = !0;
                        else
                          return De.errors = [{ instancePath: t + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                      P !== void 0 && ($ = P, e !== void 0 && (e.caseSensitive = P));
                    }
                    var a = x === o;
                    if (a) {
                      let P = e.allowUnsafeRegex;
                      const D = o;
                      if (typeof P != "boolean") {
                        let L;
                        if (L === void 0)
                          if (P === "false" || P === 0 || P === null)
                            L = !1;
                          else if (P === "true" || P === 1)
                            L = !0;
                          else
                            return De.errors = [{ instancePath: t + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                        L !== void 0 && (P = L, e !== void 0 && (e.allowUnsafeRegex = L));
                      }
                      var a = D === o;
                      if (a) {
                        if (e.http2 !== void 0) {
                          let L = e.http2;
                          const j = o;
                          if (typeof L != "boolean") {
                            let U;
                            if (U === void 0)
                              if (L === "false" || L === 0 || L === null)
                                U = !1;
                              else if (L === "true" || L === 1)
                                U = !0;
                              else
                                return De.errors = [{ instancePath: t + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            U !== void 0 && (L = U, e !== void 0 && (e.http2 = U));
                          }
                          var a = j === o;
=======
                      let T;
                      if (T === void 0)
                        if ($ === "false" || $ === 0 || $ === null)
                          T = !1;
                        else if ($ === "true" || $ === 1)
                          T = !0;
                        else
                          return $e.errors = [{ instancePath: t + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                      T !== void 0 && ($ = T, e !== void 0 && (e.caseSensitive = T));
                    }
                    var a = x === o;
                    if (a) {
                      let T = e.allowUnsafeRegex;
                      const j = o;
                      if (typeof T != "boolean") {
                        let A;
                        if (A === void 0)
                          if (T === "false" || T === 0 || T === null)
                            A = !1;
                          else if (T === "true" || T === 1)
                            A = !0;
                          else
                            return $e.errors = [{ instancePath: t + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                        A !== void 0 && (T = A, e !== void 0 && (e.allowUnsafeRegex = A));
                      }
                      var a = j === o;
                      if (a) {
                        if (e.http2 !== void 0) {
                          let A = e.http2;
                          const k = o;
                          if (typeof A != "boolean") {
                            let D;
                            if (D === void 0)
                              if (A === "false" || A === 0 || A === null)
                                D = !1;
                              else if (A === "true" || A === 1)
                                D = !0;
                              else
                                return $e.errors = [{ instancePath: t + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            D !== void 0 && (A = D, e !== void 0 && (e.http2 = D));
                          }
                          var a = k === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                        } else
                          var a = !0;
                        if (a) {
                          if (e.https !== void 0) {
<<<<<<< HEAD
                            let L = e.https;
                            const j = o, k = o;
                            let U = !0;
                            const M = o, T = o, N = o, G = o;
                            let O = !1;
                            const S = o;
                            if (typeof L != "boolean") {
                              let Q;
                              if (Q === void 0)
                                if (L === "false" || L === 0 || L === null)
                                  Q = !1;
                                else if (L === "true" || L === 1)
                                  Q = !0;
                                else {
                                  const K = {};
                                  s === null ? s = [K] : s.push(K), o++;
                                }
                              Q !== void 0 && (L = Q, e !== void 0 && (e.https = Q));
                            }
                            var u = S === o;
                            u && (O = !0);
                            const W = o;
                            if (L !== null) {
                              let Q;
                              if (Q === void 0)
                                if (L === "" || L === 0 || L === !1)
                                  Q = null;
                                else {
                                  const K = {};
                                  s === null ? s = [K] : s.push(K), o++;
                                }
                              Q !== void 0 && (L = Q, e !== void 0 && (e.https = Q));
                            }
                            var u = W === o;
                            if (u && O)
                              O = !1;
                            else {
                              u && (O = !0);
                              const Q = o;
                              if (o === Q)
                                if (L && typeof L == "object" && !Array.isArray(L))
                                  if (L.allowHTTP1 === void 0) {
                                    const X = {};
                                    s === null ? s = [X] : s.push(X), o++;
                                  } else {
                                    const X = o;
                                    for (const J in L)
                                      J !== "allowHTTP1" && delete L[J];
                                    if (X === o && L.allowHTTP1 !== void 0) {
                                      let J = L.allowHTTP1;
                                      if (typeof J != "boolean") {
                                        let re;
                                        if (re === void 0)
                                          if (J === "false" || J === 0 || J === null)
                                            re = !1;
                                          else if (J === "true" || J === 1)
                                            re = !0;
                                          else {
                                            const fe = {};
                                            s === null ? s = [fe] : s.push(fe), o++;
                                          }
                                        re !== void 0 && (J = re, L !== void 0 && (L.allowHTTP1 = re));
=======
                            let A = e.https;
                            const k = o, P = o;
                            let D = !0;
                            const F = o, w = o, N = o, q = o;
                            let K = !1;
                            const V = o;
                            if (typeof A != "boolean") {
                              let J;
                              if (J === void 0)
                                if (A === "false" || A === 0 || A === null)
                                  J = !1;
                                else if (A === "true" || A === 1)
                                  J = !0;
                                else {
                                  const H = {};
                                  i === null ? i = [H] : i.push(H), o++;
                                }
                              J !== void 0 && (A = J, e !== void 0 && (e.https = J));
                            }
                            var f = V === o;
                            f && (K = !0);
                            const Z = o;
                            if (A !== null) {
                              let J;
                              if (J === void 0)
                                if (A === "" || A === 0 || A === !1)
                                  J = null;
                                else {
                                  const H = {};
                                  i === null ? i = [H] : i.push(H), o++;
                                }
                              J !== void 0 && (A = J, e !== void 0 && (e.https = J));
                            }
                            var f = Z === o;
                            if (f && K)
                              K = !1;
                            else {
                              f && (K = !0);
                              const J = o;
                              if (o === J)
                                if (A && typeof A == "object" && !Array.isArray(A))
                                  if (A.allowHTTP1 === void 0) {
                                    const W = {};
                                    i === null ? i = [W] : i.push(W), o++;
                                  } else {
                                    const W = o;
                                    for (const G in A)
                                      G !== "allowHTTP1" && delete A[G];
                                    if (W === o && A.allowHTTP1 !== void 0) {
                                      let G = A.allowHTTP1;
                                      if (typeof G != "boolean") {
                                        let ee;
                                        if (ee === void 0)
                                          if (G === "false" || G === 0 || G === null)
                                            ee = !1;
                                          else if (G === "true" || G === 1)
                                            ee = !0;
                                          else {
                                            const le = {};
                                            i === null ? i = [le] : i.push(le), o++;
                                          }
                                        ee !== void 0 && (G = ee, A !== void 0 && (A.allowHTTP1 = ee));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                      }
                                    }
                                  }
                                else {
<<<<<<< HEAD
                                  const X = {};
                                  s === null ? s = [X] : s.push(X), o++;
                                }
                              var u = Q === o;
                              u && O ? O = !1 : u && (O = !0);
                            }
                            if (O)
                              o = G, s !== null && (G ? s.length = G : s = null);
                            else {
                              const Q = {};
                              s === null ? s = [Q] : s.push(Q), o++;
                            }
                            var l = N === o;
                            if (l) {
                              const Q = {};
                              s === null ? s = [Q] : s.push(Q), o++;
                            } else
                              o = T, s !== null && (T ? s.length = T : s = null);
                            var f = M === o;
                            if (o = k, s !== null && (k ? s.length = k : s = null), f) {
                              const Q = o;
                              e.https = !0;
                              var f = Q === o;
                              U = f;
                            }
                            if (!U) {
                              const Q = { instancePath: t + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                              return s === null ? s = [Q] : s.push(Q), o++, De.errors = s, !1;
                            }
                            var a = j === o;
                          } else
                            var a = !0;
                          if (a) {
                            let L = e.ignoreTrailingSlash;
                            const j = o;
                            if (typeof L != "boolean") {
                              let U;
                              if (U === void 0)
                                if (L === "false" || L === 0 || L === null)
                                  U = !1;
                                else if (L === "true" || L === 1)
                                  U = !0;
                                else
                                  return De.errors = [{ instancePath: t + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              U !== void 0 && (L = U, e !== void 0 && (e.ignoreTrailingSlash = U));
                            }
                            var a = j === o;
                            if (a) {
                              let U = e.ignoreDuplicateSlashes;
                              const M = o;
                              if (typeof U != "boolean") {
                                let N;
                                if (N === void 0)
                                  if (U === "false" || U === 0 || U === null)
                                    N = !1;
                                  else if (U === "true" || U === 1)
                                    N = !0;
                                  else
                                    return De.errors = [{ instancePath: t + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                N !== void 0 && (U = N, e !== void 0 && (e.ignoreDuplicateSlashes = N));
                              }
                              var a = M === o;
                              if (a) {
                                let N = e.disableRequestLogging;
                                const G = o;
                                if (typeof N != "boolean") {
                                  let S;
                                  if (S === void 0)
                                    if (N === "false" || N === 0 || N === null)
                                      S = !1;
                                    else if (N === "true" || N === 1)
                                      S = !0;
                                    else
                                      return De.errors = [{ instancePath: t + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  S !== void 0 && (N = S, e !== void 0 && (e.disableRequestLogging = S));
                                }
                                var a = G === o;
                                if (a) {
                                  let S = e.maxParamLength;
                                  const W = o;
                                  if (!(typeof S == "number" && !(S % 1) && !isNaN(S) && isFinite(S))) {
                                    let Q = typeof S, K;
                                    if (K === void 0)
                                      if (Q === "boolean" || S === null || Q === "string" && S && S == +S && !(S % 1))
                                        K = +S;
                                      else
                                        return De.errors = [{ instancePath: t + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                    K !== void 0 && (S = K, e !== void 0 && (e.maxParamLength = K));
                                  }
                                  var a = W === o;
                                  if (a) {
                                    let Q = e.onProtoPoisoning;
                                    const K = o;
                                    if (typeof Q != "string") {
                                      let J = typeof Q, re;
                                      if (re === void 0)
                                        if (J == "number" || J == "boolean")
                                          re = "" + Q;
                                        else if (Q === null)
                                          re = "";
                                        else
                                          return De.errors = [{ instancePath: t + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                      re !== void 0 && (Q = re, e !== void 0 && (e.onProtoPoisoning = re));
                                    }
                                    var a = K === o;
                                    if (a) {
                                      let J = e.onConstructorPoisoning;
                                      const re = o;
                                      if (typeof J != "string") {
                                        let ee = typeof J, le;
                                        if (le === void 0)
                                          if (ee == "number" || ee == "boolean")
                                            le = "" + J;
                                          else if (J === null)
                                            le = "";
                                          else
                                            return De.errors = [{ instancePath: t + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                        le !== void 0 && (J = le, e !== void 0 && (e.onConstructorPoisoning = le));
                                      }
                                      var a = re === o;
                                      if (a) {
                                        let ee = e.pluginTimeout;
                                        const le = o;
                                        if (!(typeof ee == "number" && !(ee % 1) && !isNaN(ee) && isFinite(ee))) {
                                          let ye = typeof ee, ve;
                                          if (ve === void 0)
                                            if (ye === "boolean" || ee === null || ye === "string" && ee && ee == +ee && !(ee % 1))
                                              ve = +ee;
                                            else
                                              return De.errors = [{ instancePath: t + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          ve !== void 0 && (ee = ve, e !== void 0 && (e.pluginTimeout = ve));
                                        }
                                        var a = le === o;
                                        if (a) {
                                          let ye = e.requestIdHeader;
                                          const ve = o, qe = o;
                                          let Ae = !1;
                                          const $t = o;
                                          if (typeof ye != "boolean") {
                                            let Le;
                                            if (Le === void 0)
                                              if (ye === "false" || ye === 0 || ye === null)
                                                Le = !1;
                                              else if (ye === "true" || ye === 1)
                                                Le = !0;
                                              else {
                                                const Ut = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                s === null ? s = [Ut] : s.push(Ut), o++;
                                              }
                                            Le !== void 0 && (ye = Le, e !== void 0 && (e.requestIdHeader = Le));
                                          }
                                          var m = $t === o;
                                          if (Ae = Ae || m, !Ae) {
                                            const Le = o;
                                            if (typeof ye != "string") {
                                              let br = typeof ye, Ne;
                                              if (Ne === void 0)
                                                if (br == "number" || br == "boolean")
                                                  Ne = "" + ye;
                                                else if (ye === null)
                                                  Ne = "";
                                                else {
                                                  const je = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                  s === null ? s = [je] : s.push(je), o++;
                                                }
                                              Ne !== void 0 && (ye = Ne, e !== void 0 && (e.requestIdHeader = Ne));
                                            }
                                            var m = Le === o;
                                            Ae = Ae || m;
                                          }
                                          if (Ae)
                                            o = qe, s !== null && (qe ? s.length = qe : s = null);
                                          else {
                                            const Le = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            return s === null ? s = [Le] : s.push(Le), o++, De.errors = s, !1;
                                          }
                                          var a = ve === o;
                                          if (a) {
                                            let Le = e.requestIdLogLabel;
                                            const Ut = o;
                                            if (typeof Le != "string") {
                                              let Ne = typeof Le, je;
                                              if (je === void 0)
                                                if (Ne == "number" || Ne == "boolean")
                                                  je = "" + Le;
                                                else if (Le === null)
                                                  je = "";
                                                else
                                                  return De.errors = [{ instancePath: t + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                              je !== void 0 && (Le = je, e !== void 0 && (e.requestIdLogLabel = je));
                                            }
                                            var a = Ut === o;
                                            if (a) {
                                              let Ne = e.http2SessionTimeout;
                                              const je = o;
                                              if (!(typeof Ne == "number" && !(Ne % 1) && !isNaN(Ne) && isFinite(Ne))) {
                                                let Mt = typeof Ne, dr;
                                                if (dr === void 0)
                                                  if (Mt === "boolean" || Ne === null || Mt === "string" && Ne && Ne == +Ne && !(Ne % 1))
                                                    dr = +Ne;
                                                  else
                                                    return De.errors = [{ instancePath: t + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                dr !== void 0 && (Ne = dr, e !== void 0 && (e.http2SessionTimeout = dr));
                                              }
                                              var a = je === o;
                                              if (a) {
                                                let Mt = e.exposeHeadRoutes;
                                                const dr = o;
                                                if (typeof Mt != "boolean") {
                                                  let We;
                                                  if (We === void 0)
                                                    if (Mt === "false" || Mt === 0 || Mt === null)
                                                      We = !1;
                                                    else if (Mt === "true" || Mt === 1)
                                                      We = !0;
                                                    else
                                                      return De.errors = [{ instancePath: t + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                  We !== void 0 && (Mt = We, e !== void 0 && (e.exposeHeadRoutes = We));
                                                }
                                                var a = dr === o;
                                                if (a) {
                                                  let We = e.useSemicolonDelimiter;
                                                  const Qi = o;
                                                  if (typeof We != "boolean") {
                                                    let _t;
                                                    if (_t === void 0)
                                                      if (We === "false" || We === 0 || We === null)
                                                        _t = !1;
                                                      else if (We === "true" || We === 1)
                                                        _t = !0;
                                                      else
                                                        return De.errors = [{ instancePath: t + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                    _t !== void 0 && (We = _t, e !== void 0 && (e.useSemicolonDelimiter = _t));
                                                  }
                                                  var a = Qi === o;
                                                  if (a)
                                                    if (e.constraints !== void 0) {
                                                      let _t = e.constraints;
                                                      const Er = o;
                                                      if (o === Er)
                                                        if (_t && typeof _t == "object" && !Array.isArray(_t))
                                                          for (const $n in _t) {
                                                            let Yt = _t[$n];
                                                            const Nr = o;
                                                            if (o === Nr)
                                                              if (Yt && typeof Yt == "object" && !Array.isArray(Yt)) {
                                                                let Ht;
                                                                if (Yt.name === void 0 && (Ht = "name") || Yt.storage === void 0 && (Ht = "storage") || Yt.validate === void 0 && (Ht = "validate") || Yt.deriveConstraint === void 0 && (Ht = "deriveConstraint"))
                                                                  return De.errors = [{ instancePath: t + "/constraints/" + $n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: Ht }, message: "must have required property '" + Ht + "'" }], !1;
                                                                if (Yt.name !== void 0) {
                                                                  let wr = Yt.name;
                                                                  if (typeof wr != "string") {
                                                                    let cn = typeof wr, sr;
                                                                    if (sr === void 0)
                                                                      if (cn == "number" || cn == "boolean")
                                                                        sr = "" + wr;
                                                                      else if (wr === null)
                                                                        sr = "";
                                                                      else
                                                                        return De.errors = [{ instancePath: t + "/constraints/" + $n.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                    sr !== void 0 && (wr = sr, Yt !== void 0 && (Yt.name = sr));
                                                                  }
                                                                }
                                                              } else
                                                                return De.errors = [{ instancePath: t + "/constraints/" + $n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var p = Nr === o;
=======
                                  const W = {};
                                  i === null ? i = [W] : i.push(W), o++;
                                }
                              var f = J === o;
                              f && K ? K = !1 : f && (K = !0);
                            }
                            if (K)
                              o = q, i !== null && (q ? i.length = q : i = null);
                            else {
                              const J = {};
                              i === null ? i = [J] : i.push(J), o++;
                            }
                            var l = N === o;
                            if (l) {
                              const J = {};
                              i === null ? i = [J] : i.push(J), o++;
                            } else
                              o = w, i !== null && (w ? i.length = w : i = null);
                            var d = F === o;
                            if (o = P, i !== null && (P ? i.length = P : i = null), d) {
                              const J = o;
                              e.https = !0;
                              var d = J === o;
                              D = d;
                            }
                            if (!D) {
                              const J = { instancePath: t + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                              return i === null ? i = [J] : i.push(J), o++, $e.errors = i, !1;
                            }
                            var a = k === o;
                          } else
                            var a = !0;
                          if (a) {
                            let A = e.ignoreTrailingSlash;
                            const k = o;
                            if (typeof A != "boolean") {
                              let D;
                              if (D === void 0)
                                if (A === "false" || A === 0 || A === null)
                                  D = !1;
                                else if (A === "true" || A === 1)
                                  D = !0;
                                else
                                  return $e.errors = [{ instancePath: t + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              D !== void 0 && (A = D, e !== void 0 && (e.ignoreTrailingSlash = D));
                            }
                            var a = k === o;
                            if (a) {
                              let D = e.ignoreDuplicateSlashes;
                              const F = o;
                              if (typeof D != "boolean") {
                                let N;
                                if (N === void 0)
                                  if (D === "false" || D === 0 || D === null)
                                    N = !1;
                                  else if (D === "true" || D === 1)
                                    N = !0;
                                  else
                                    return $e.errors = [{ instancePath: t + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                N !== void 0 && (D = N, e !== void 0 && (e.ignoreDuplicateSlashes = N));
                              }
                              var a = F === o;
                              if (a) {
                                let N = e.disableRequestLogging;
                                const q = o;
                                if (typeof N != "boolean") {
                                  let V;
                                  if (V === void 0)
                                    if (N === "false" || N === 0 || N === null)
                                      V = !1;
                                    else if (N === "true" || N === 1)
                                      V = !0;
                                    else
                                      return $e.errors = [{ instancePath: t + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  V !== void 0 && (N = V, e !== void 0 && (e.disableRequestLogging = V));
                                }
                                var a = q === o;
                                if (a) {
                                  let V = e.maxParamLength;
                                  const Z = o;
                                  if (!(typeof V == "number" && !(V % 1) && !isNaN(V) && isFinite(V))) {
                                    let J = typeof V, H;
                                    if (H === void 0)
                                      if (J === "boolean" || V === null || J === "string" && V && V == +V && !(V % 1))
                                        H = +V;
                                      else
                                        return $e.errors = [{ instancePath: t + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                    H !== void 0 && (V = H, e !== void 0 && (e.maxParamLength = H));
                                  }
                                  var a = Z === o;
                                  if (a) {
                                    let J = e.onProtoPoisoning;
                                    const H = o;
                                    if (typeof J != "string") {
                                      let G = typeof J, ee;
                                      if (ee === void 0)
                                        if (G == "number" || G == "boolean")
                                          ee = "" + J;
                                        else if (J === null)
                                          ee = "";
                                        else
                                          return $e.errors = [{ instancePath: t + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                      ee !== void 0 && (J = ee, e !== void 0 && (e.onProtoPoisoning = ee));
                                    }
                                    var a = H === o;
                                    if (a) {
                                      let G = e.onConstructorPoisoning;
                                      const ee = o;
                                      if (typeof G != "string") {
                                        let X = typeof G, ce;
                                        if (ce === void 0)
                                          if (X == "number" || X == "boolean")
                                            ce = "" + G;
                                          else if (G === null)
                                            ce = "";
                                          else
                                            return $e.errors = [{ instancePath: t + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                        ce !== void 0 && (G = ce, e !== void 0 && (e.onConstructorPoisoning = ce));
                                      }
                                      var a = ee === o;
                                      if (a) {
                                        let X = e.pluginTimeout;
                                        const ce = o;
                                        if (!(typeof X == "number" && !(X % 1) && !isNaN(X) && isFinite(X))) {
                                          let pe = typeof X, me;
                                          if (me === void 0)
                                            if (pe === "boolean" || X === null || pe === "string" && X && X == +X && !(X % 1))
                                              me = +X;
                                            else
                                              return $e.errors = [{ instancePath: t + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          me !== void 0 && (X = me, e !== void 0 && (e.pluginTimeout = me));
                                        }
                                        var a = ce === o;
                                        if (a) {
                                          let pe = e.requestIdHeader;
                                          const me = o, We = o;
                                          let we = !1;
                                          const Et = o;
                                          if (typeof pe != "boolean") {
                                            let Ce;
                                            if (Ce === void 0)
                                              if (pe === "false" || pe === 0 || pe === null)
                                                Ce = !1;
                                              else if (pe === "true" || pe === 1)
                                                Ce = !0;
                                              else {
                                                const Bt = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                i === null ? i = [Bt] : i.push(Bt), o++;
                                              }
                                            Ce !== void 0 && (pe = Ce, e !== void 0 && (e.requestIdHeader = Ce));
                                          }
                                          var g = Et === o;
                                          if (we = we || g, !we) {
                                            const Ce = o;
                                            if (typeof pe != "string") {
                                              let $r = typeof pe, Te;
                                              if (Te === void 0)
                                                if ($r == "number" || $r == "boolean")
                                                  Te = "" + pe;
                                                else if (pe === null)
                                                  Te = "";
                                                else {
                                                  const ot = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                  i === null ? i = [ot] : i.push(ot), o++;
                                                }
                                              Te !== void 0 && (pe = Te, e !== void 0 && (e.requestIdHeader = Te));
                                            }
                                            var g = Ce === o;
                                            we = we || g;
                                          }
                                          if (we)
                                            o = We, i !== null && (We ? i.length = We : i = null);
                                          else {
                                            const Ce = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            return i === null ? i = [Ce] : i.push(Ce), o++, $e.errors = i, !1;
                                          }
                                          var a = me === o;
                                          if (a) {
                                            let Ce = e.requestIdLogLabel;
                                            const Bt = o;
                                            if (typeof Ce != "string") {
                                              let Te = typeof Ce, ot;
                                              if (ot === void 0)
                                                if (Te == "number" || Te == "boolean")
                                                  ot = "" + Ce;
                                                else if (Ce === null)
                                                  ot = "";
                                                else
                                                  return $e.errors = [{ instancePath: t + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                              ot !== void 0 && (Ce = ot, e !== void 0 && (e.requestIdLogLabel = ot));
                                            }
                                            var a = Bt === o;
                                            if (a) {
                                              let Te = e.http2SessionTimeout;
                                              const ot = o;
                                              if (!(typeof Te == "number" && !(Te % 1) && !isNaN(Te) && isFinite(Te))) {
                                                let Ct = typeof Te, Vt;
                                                if (Vt === void 0)
                                                  if (Ct === "boolean" || Te === null || Ct === "string" && Te && Te == +Te && !(Te % 1))
                                                    Vt = +Te;
                                                  else
                                                    return $e.errors = [{ instancePath: t + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                Vt !== void 0 && (Te = Vt, e !== void 0 && (e.http2SessionTimeout = Vt));
                                              }
                                              var a = ot === o;
                                              if (a) {
                                                let Ct = e.exposeHeadRoutes;
                                                const Vt = o;
                                                if (typeof Ct != "boolean") {
                                                  let Qe;
                                                  if (Qe === void 0)
                                                    if (Ct === "false" || Ct === 0 || Ct === null)
                                                      Qe = !1;
                                                    else if (Ct === "true" || Ct === 1)
                                                      Qe = !0;
                                                    else
                                                      return $e.errors = [{ instancePath: t + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                  Qe !== void 0 && (Ct = Qe, e !== void 0 && (e.exposeHeadRoutes = Qe));
                                                }
                                                var a = Vt === o;
                                                if (a) {
                                                  let Qe = e.useSemicolonDelimiter;
                                                  const Xa = o;
                                                  if (typeof Qe != "boolean") {
                                                    let mt;
                                                    if (mt === void 0)
                                                      if (Qe === "false" || Qe === 0 || Qe === null)
                                                        mt = !1;
                                                      else if (Qe === "true" || Qe === 1)
                                                        mt = !0;
                                                      else
                                                        return $e.errors = [{ instancePath: t + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                    mt !== void 0 && (Qe = mt, e !== void 0 && (e.useSemicolonDelimiter = mt));
                                                  }
                                                  var a = Xa === o;
                                                  if (a)
                                                    if (e.constraints !== void 0) {
                                                      let mt = e.constraints;
                                                      const Ti = o;
                                                      if (o === Ti)
                                                        if (mt && typeof mt == "object" && !Array.isArray(mt))
                                                          for (const xn in mt) {
                                                            let Pt = mt[xn];
                                                            const Br = o;
                                                            if (o === Br)
                                                              if (Pt && typeof Pt == "object" && !Array.isArray(Pt)) {
                                                                let tr;
                                                                if (Pt.name === void 0 && (tr = "name") || Pt.storage === void 0 && (tr = "storage") || Pt.validate === void 0 && (tr = "validate") || Pt.deriveConstraint === void 0 && (tr = "deriveConstraint"))
                                                                  return $e.errors = [{ instancePath: t + "/constraints/" + xn.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: tr }, message: "must have required property '" + tr + "'" }], !1;
                                                                if (Pt.name !== void 0) {
                                                                  let Tr = Pt.name;
                                                                  if (typeof Tr != "string") {
                                                                    let hs = typeof Tr, rr;
                                                                    if (rr === void 0)
                                                                      if (hs == "number" || hs == "boolean")
                                                                        rr = "" + Tr;
                                                                      else if (Tr === null)
                                                                        rr = "";
                                                                      else
                                                                        return $e.errors = [{ instancePath: t + "/constraints/" + xn.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                    rr !== void 0 && (Tr = rr, Pt !== void 0 && (Pt.name = rr));
                                                                  }
                                                                }
                                                              } else
                                                                return $e.errors = [{ instancePath: t + "/constraints/" + xn.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var p = Br === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                            if (!p)
                                                              break;
                                                          }
                                                        else
<<<<<<< HEAD
                                                          return De.errors = [{ instancePath: t + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                      var a = Er === o;
=======
                                                          return $e.errors = [{ instancePath: t + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                      var a = Ti === o;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                                                    } else
                                                      var a = !0;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
<<<<<<< HEAD
      return De.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
  return De.errors = s, o === 0;
}
nf.exports.defaultInitOptions = { connectionTimeout: 0, keepAliveTimeout: 72e3, maxRequestsPerSocket: 0, requestTimeout: 0, bodyLimit: 1048576, caseSensitive: !0, allowUnsafeRegex: !1, disableRequestLogging: !1, ignoreTrailingSlash: !1, ignoreDuplicateSlashes: !1, maxParamLength: 100, onProtoPoisoning: "error", onConstructorPoisoning: "error", pluginTimeout: 1e4, requestIdHeader: !1, requestIdLogLabel: "reqId", http2SessionTimeout: 72e3, exposeHeadRoutes: !0, useSemicolonDelimiter: !1 };
var pV = nf.exports;
const wl = pV, hV = vm({ circles: !0, proto: !1 }), { FST_ERR_INIT_OPTS_INVALID: mV } = Wt;
function gV(e) {
  const t = hV(e);
  if (!wl(t)) {
    const r = new mV(JSON.stringify(wl.errors.map((n) => n.message)));
    throw r.errors = wl.errors, r;
  }
  return py(t);
}
function py(e) {
  const t = Object.getOwnPropertyNames(e);
  for (const r of t) {
    const n = e[r];
    ArrayBuffer.isView(n) && !(n instanceof DataView) || (e[r] = n && typeof n == "object" ? py(n) : n);
  }
  return Object.freeze(e);
}
rf.exports = gV;
rf.exports.defaultInitOptions = wl.defaultInitOptions;
rf.exports.utils = { deepFreezeObject: py };
var yV = rf.exports;
const {
  kAvvioBoot: vV,
  kChildren: Pb,
  kRoutePrefix: Cb,
  kLogLevel: Ab,
  kLogSerializers: Xd,
  kHooks: Zd,
  kSchemaController: os,
  kContentTypeParser: Ib,
  kReply: Nb,
  kRequest: kb,
  kFourOhFour: _V,
  kPluginNameChain: Db
} = Ft, bV = xm, EV = Pm, wV = T$, SV = Kx, { buildHooks: xV } = Wi, Po = L$;
var RV = function(t, r, n) {
  const i = Po.registerPlugin.call(t, r), s = Po.getPluginName(r) || Po.getFuncPreview(r);
  if (i)
    return t[Db].push(s), t;
  const o = Object.create(t);
  t[Pb].push(o), o.ready = t[vV].bind(o), o[Pb] = [], o[Nb] = bV.buildReply(o[Nb]), o[kb] = EV.buildRequest(o[kb]), o[Ib] = SV.helpers.buildContentTypeParser(o[Ib]), o[Zd] = xV(o[Zd]), o[Cb] = $V(o[Cb], n.prefix), o[Ab] = n.logLevel || o[Ab], o[os] = wV.buildSchemaController(t[os]), o.getSchema = o[os].getSchema.bind(o[os]), o.getSchemas = o[os].getSchemas.bind(o[os]), o[Po.kRegisteredPlugins] = Object.create(o[Po.kRegisteredPlugins]), o[Db] = [s], (o[Xd] || n.logSerializers) && (o[Xd] = Object.assign(Object.create(o[Xd]), n.logSerializers)), n.prefix && o[_V].arrange404(o);
  for (const a of o[Zd].onRegister) a.call(t, o, n);
  return o;
};
function $V(e, t) {
  return t ? (e.endsWith("/") && t[0] === "/" ? t = t.slice(1) : t[0] !== "/" && (t = "/" + t), e + t) : e;
}
var TV = function() {
=======
      return $e.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
  return $e.errors = i, o === 0;
}
Fa.exports.defaultInitOptions = { connectionTimeout: 0, keepAliveTimeout: 72e3, maxRequestsPerSocket: 0, requestTimeout: 0, bodyLimit: 1048576, caseSensitive: !0, allowUnsafeRegex: !1, disableRequestLogging: !1, ignoreTrailingSlash: !1, ignoreDuplicateSlashes: !1, maxParamLength: 100, onProtoPoisoning: "error", onConstructorPoisoning: "error", pluginTimeout: 1e4, requestIdHeader: !1, requestIdLogLabel: "reqId", http2SessionTimeout: 72e3, exposeHeadRoutes: !0, useSemicolonDelimiter: !1 };
var m2 = Fa.exports;
const xo = m2, y2 = ef({ circles: !0, proto: !1 }), { FST_ERR_INIT_OPTS_INVALID: g2 } = _t;
function v2(e) {
  const t = y2(e);
  if (!xo(t)) {
    const r = new g2(JSON.stringify(xo.errors.map((n) => n.message)));
    throw r.errors = xo.errors, r;
  }
  return Jd(t);
}
function Jd(e) {
  const t = Object.getOwnPropertyNames(e);
  for (const r of t) {
    const n = e[r];
    ArrayBuffer.isView(n) && !(n instanceof DataView) || (e[r] = n && typeof n == "object" ? Jd(n) : n);
  }
  return Object.freeze(e);
}
Da.exports = v2;
Da.exports.defaultInitOptions = xo.defaultInitOptions;
Da.exports.utils = { deepFreezeObject: Jd };
var b2 = Da.exports;
const {
  kAvvioBoot: _2,
  kChildren: Dy,
  kRoutePrefix: Fy,
  kLogLevel: My,
  kLogSerializers: pl,
  kHooks: hl,
  kSchemaController: Cn,
  kContentTypeParser: zy,
  kReply: Uy,
  kRequest: qy,
  kFourOhFour: E2,
  kPluginNameChain: Hy
} = ht, S2 = af, x2 = df, w2 = p_, R2 = kb, { buildHooks: $2 } = bn, xs = S_;
var T2 = function(t, r, n) {
  const s = xs.registerPlugin.call(t, r), i = xs.getPluginName(r) || xs.getFuncPreview(r);
  if (s)
    return t[Hy].push(i), t;
  const o = Object.create(t);
  t[Dy].push(o), o.ready = t[_2].bind(o), o[Dy] = [], o[Uy] = S2.buildReply(o[Uy]), o[qy] = x2.buildRequest(o[qy]), o[zy] = R2.helpers.buildContentTypeParser(o[zy]), o[hl] = $2(o[hl]), o[Fy] = O2(o[Fy], n.prefix), o[My] = n.logLevel || o[My], o[Cn] = w2.buildSchemaController(t[Cn]), o.getSchema = o[Cn].getSchema.bind(o[Cn]), o.getSchemas = o[Cn].getSchemas.bind(o[Cn]), o[xs.kRegisteredPlugins] = Object.create(o[xs.kRegisteredPlugins]), o[Hy] = [i], (o[pl] || n.logSerializers) && (o[pl] = Object.assign(Object.create(o[pl]), n.logSerializers)), n.prefix && o[E2].arrange404(o);
  for (const a of o[hl].onRegister) a.call(t, o, n);
  return o;
};
function O2(e, t) {
  return t ? (e.endsWith("/") && t[0] === "/" ? t = t.slice(1) : t[0] !== "/" && (t = "/" + t), e + t) : e;
}
var C2 = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    [Symbol.iterator]: function* () {
    },
    add() {
    },
    delete() {
    },
    has() {
      return !0;
    }
  };
<<<<<<< HEAD
}, as = { exports: {} }, Co = { exports: {} }, Ao = {}, Lb;
function OV() {
  if (Lb) return Ao;
  Lb = 1, Object.defineProperty(Ao, "__esModule", { value: !0 }), Ao.parse = o, Ao.serialize = u;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, n = /^[\u0020-\u003A\u003D-\u007E]*$/, i = Object.prototype.toString, s = /* @__PURE__ */ (() => {
    const m = function() {
    };
    return m.prototype = /* @__PURE__ */ Object.create(null), m;
  })();
  function o(m, p) {
    const d = new s(), h = m.length;
    if (h < 2)
      return d;
    const _ = (p == null ? void 0 : p.decode) || l;
    let g = 0;
    do {
      const v = m.indexOf("=", g);
      if (v === -1)
        break;
      const y = m.indexOf(";", g), E = y === -1 ? h : y;
      if (v > E) {
        g = m.lastIndexOf(";", v - 1) + 1;
        continue;
      }
      const R = a(m, g, v), w = c(m, v, R), C = m.slice(R, w);
      if (d[C] === void 0) {
        let V = a(m, v + 1, E), b = c(m, E, V);
        const F = _(m.slice(V, b));
        d[C] = F;
      }
      g = E + 1;
    } while (g < h);
    return d;
  }
  function a(m, p, d) {
    do {
      const h = m.charCodeAt(p);
      if (h !== 32 && h !== 9)
        return p;
    } while (++p < d);
    return d;
  }
  function c(m, p, d) {
    for (; p > d; ) {
      const h = m.charCodeAt(--p);
      if (h !== 32 && h !== 9)
        return p + 1;
    }
    return d;
  }
  function u(m, p, d) {
    const h = (d == null ? void 0 : d.encode) || encodeURIComponent;
    if (!e.test(m))
      throw new TypeError(`argument name is invalid: ${m}`);
    const _ = h(p);
    if (!t.test(_))
      throw new TypeError(`argument val is invalid: ${p}`);
    let g = m + "=" + _;
    if (!d)
      return g;
    if (d.maxAge !== void 0) {
      if (!Number.isInteger(d.maxAge))
        throw new TypeError(`option maxAge is invalid: ${d.maxAge}`);
      g += "; Max-Age=" + d.maxAge;
    }
    if (d.domain) {
      if (!r.test(d.domain))
        throw new TypeError(`option domain is invalid: ${d.domain}`);
      g += "; Domain=" + d.domain;
    }
    if (d.path) {
      if (!n.test(d.path))
        throw new TypeError(`option path is invalid: ${d.path}`);
      g += "; Path=" + d.path;
    }
    if (d.expires) {
      if (!f(d.expires) || !Number.isFinite(d.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${d.expires}`);
      g += "; Expires=" + d.expires.toUTCString();
    }
    if (d.httpOnly && (g += "; HttpOnly"), d.secure && (g += "; Secure"), d.partitioned && (g += "; Partitioned"), d.priority)
      switch (typeof d.priority == "string" ? d.priority.toLowerCase() : void 0) {
        case "low":
          g += "; Priority=Low";
          break;
        case "medium":
          g += "; Priority=Medium";
          break;
        case "high":
          g += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${d.priority}`);
      }
    if (d.sameSite)
      switch (typeof d.sameSite == "string" ? d.sameSite.toLowerCase() : d.sameSite) {
        case !0:
        case "strict":
          g += "; SameSite=Strict";
          break;
        case "lax":
          g += "; SameSite=Lax";
          break;
        case "none":
          g += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${d.sameSite}`);
      }
    return g;
  }
  function l(m) {
    if (m.indexOf("%") === -1)
      return m;
    try {
      return decodeURIComponent(m);
    } catch {
      return m;
    }
  }
  function f(m) {
    return i.call(m) === "[object Date]";
  }
  return Ao;
}
var Qd, Fb;
function PV() {
  if (Fb) return Qd;
  Fb = 1;
  const { URL: e } = dC, t = "http://localhost";
  return Qd = function(n, i) {
    (typeof n == "string" || Object.prototype.toString.call(n) === "[object String]") && n.startsWith("//") && (n = t + n);
    const s = typeof n == "object" ? Object.assign(new e(t), n) : new e(n, t);
    if (typeof i == "string") {
      i = new URLSearchParams(i);
      for (const o of i.keys()) {
        s.searchParams.delete(o);
        for (const a of i.getAll(o))
          s.searchParams.append(o, a);
      }
    } else {
      const o = Object.assign({}, n.query, i);
      for (const a in o) {
        const c = o[a];
        if (Array.isArray(c)) {
          s.searchParams.delete(a);
          for (const u of c)
            s.searchParams.append(a, u);
        } else
          s.searchParams.set(a, c);
      }
    }
    return s;
  }, Qd;
}
var Vc = {}, jb;
function CV() {
  if (jb) return Vc;
  jb = 1;
  const { randomUUID: e } = EC, { Readable: t } = Na;
  let r;
  function n(s) {
    return s && typeof s == "object" && typeof s.append == "function" && typeof s.delete == "function" && typeof s.get == "function" && typeof s.getAll == "function" && typeof s.has == "function" && typeof s.set == "function" && s[Symbol.toStringTag] === "FormData";
  }
  function i(s) {
=======
}, Pn = { exports: {} }, ws = { exports: {} }, Rs = {}, By;
function P2() {
  if (By) return Rs;
  By = 1, Object.defineProperty(Rs, "__esModule", { value: !0 }), Rs.parse = o, Rs.serialize = f;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, n = /^[\u0020-\u003A\u003D-\u007E]*$/, s = Object.prototype.toString, i = /* @__PURE__ */ (() => {
    const g = function() {
    };
    return g.prototype = /* @__PURE__ */ Object.create(null), g;
  })();
  function o(g, p) {
    const u = new i(), h = g.length;
    if (h < 2)
      return u;
    const b = (p == null ? void 0 : p.decode) || l;
    let m = 0;
    do {
      const v = g.indexOf("=", m);
      if (v === -1)
        break;
      const y = g.indexOf(";", m), _ = y === -1 ? h : y;
      if (v > _) {
        m = g.lastIndexOf(";", v - 1) + 1;
        continue;
      }
      const R = a(g, m, v), E = c(g, v, R), O = g.slice(R, E);
      if (u[O] === void 0) {
        let z = a(g, v + 1, _), S = c(g, _, z);
        const L = b(g.slice(z, S));
        u[O] = L;
      }
      m = _ + 1;
    } while (m < h);
    return u;
  }
  function a(g, p, u) {
    do {
      const h = g.charCodeAt(p);
      if (h !== 32 && h !== 9)
        return p;
    } while (++p < u);
    return u;
  }
  function c(g, p, u) {
    for (; p > u; ) {
      const h = g.charCodeAt(--p);
      if (h !== 32 && h !== 9)
        return p + 1;
    }
    return u;
  }
  function f(g, p, u) {
    const h = (u == null ? void 0 : u.encode) || encodeURIComponent;
    if (!e.test(g))
      throw new TypeError(`argument name is invalid: ${g}`);
    const b = h(p);
    if (!t.test(b))
      throw new TypeError(`argument val is invalid: ${p}`);
    let m = g + "=" + b;
    if (!u)
      return m;
    if (u.maxAge !== void 0) {
      if (!Number.isInteger(u.maxAge))
        throw new TypeError(`option maxAge is invalid: ${u.maxAge}`);
      m += "; Max-Age=" + u.maxAge;
    }
    if (u.domain) {
      if (!r.test(u.domain))
        throw new TypeError(`option domain is invalid: ${u.domain}`);
      m += "; Domain=" + u.domain;
    }
    if (u.path) {
      if (!n.test(u.path))
        throw new TypeError(`option path is invalid: ${u.path}`);
      m += "; Path=" + u.path;
    }
    if (u.expires) {
      if (!d(u.expires) || !Number.isFinite(u.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${u.expires}`);
      m += "; Expires=" + u.expires.toUTCString();
    }
    if (u.httpOnly && (m += "; HttpOnly"), u.secure && (m += "; Secure"), u.partitioned && (m += "; Partitioned"), u.priority)
      switch (typeof u.priority == "string" ? u.priority.toLowerCase() : void 0) {
        case "low":
          m += "; Priority=Low";
          break;
        case "medium":
          m += "; Priority=Medium";
          break;
        case "high":
          m += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${u.priority}`);
      }
    if (u.sameSite)
      switch (typeof u.sameSite == "string" ? u.sameSite.toLowerCase() : u.sameSite) {
        case !0:
        case "strict":
          m += "; SameSite=Strict";
          break;
        case "lax":
          m += "; SameSite=Lax";
          break;
        case "none":
          m += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${u.sameSite}`);
      }
    return m;
  }
  function l(g) {
    if (g.indexOf("%") === -1)
      return g;
    try {
      return decodeURIComponent(g);
    } catch {
      return g;
    }
  }
  function d(g) {
    return s.call(g) === "[object Date]";
  }
  return Rs;
}
var ml, Vy;
function I2() {
  if (Vy) return ml;
  Vy = 1;
  const { URL: e } = hS, t = "http://localhost";
  return ml = function(n, s) {
    (typeof n == "string" || Object.prototype.toString.call(n) === "[object String]") && n.startsWith("//") && (n = t + n);
    const i = typeof n == "object" ? Object.assign(new e(t), n) : new e(n, t);
    if (typeof s == "string") {
      s = new URLSearchParams(s);
      for (const o of s.keys()) {
        i.searchParams.delete(o);
        for (const a of s.getAll(o))
          i.searchParams.append(o, a);
      }
    } else {
      const o = Object.assign({}, n.query, s);
      for (const a in o) {
        const c = o[a];
        if (Array.isArray(c)) {
          i.searchParams.delete(a);
          for (const f of c)
            i.searchParams.append(a, f);
        } else
          i.searchParams.set(a, c);
      }
    }
    return i;
  }, ml;
}
var Zi = {}, Gy;
function N2() {
  if (Gy) return Zi;
  Gy = 1;
  const { randomUUID: e } = xS, { Readable: t } = ri;
  let r;
  function n(i) {
    return i && typeof i == "object" && typeof i.append == "function" && typeof i.delete == "function" && typeof i.get == "function" && typeof i.getAll == "function" && typeof i.has == "function" && typeof i.set == "function" && i[Symbol.toStringTag] === "FormData";
  }
  function s(i) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    r = r ?? new TextEncoder();
    const o = `----formdata-${e()}`, a = `--${o}\r
Content-Disposition: form-data`;
    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
<<<<<<< HEAD
    const c = (p) => p.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), u = (p) => p.replace(/\r?\n|\r/g, `\r
`), l = new Uint8Array([13, 10]);
    async function* f() {
      for (const [p, d] of s)
        if (typeof d == "string")
          yield r.encode(`${a}; name="${c(u(p))}"\r
\r
`), yield r.encode(`${u(d)}\r
`);
        else {
          let h = `${a}; name="${c(u(p))}"`;
          d.name && (h += `; filename="${c(d.name)}"`), h += `\r
Content-Type: ${d.type || "application/octet-stream"}\r
\r
`, yield r.encode(h), d.stream ? yield* d.stream() : yield d, yield l;
=======
    const c = (p) => p.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), f = (p) => p.replace(/\r?\n|\r/g, `\r
`), l = new Uint8Array([13, 10]);
    async function* d() {
      for (const [p, u] of i)
        if (typeof u == "string")
          yield r.encode(`${a}; name="${c(f(p))}"\r
\r
`), yield r.encode(`${f(u)}\r
`);
        else {
          let h = `${a}; name="${c(f(p))}"`;
          u.name && (h += `; filename="${c(u.name)}"`), h += `\r
Content-Type: ${u.type || "application/octet-stream"}\r
\r
`, yield r.encode(h), u.stream ? yield* u.stream() : yield u, yield l;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      yield r.encode(`--${o}--`);
    }
    return {
<<<<<<< HEAD
      stream: t.from(f()),
      contentType: `multipart/form-data; boundary=${o}`
    };
  }
  return Vc.isFormDataLike = n, Vc.formDataToStream = i, Vc;
}
var Ub;
function AV() {
  if (Ub) return Co.exports;
  Ub = 1;
  const { Readable: e, addAbortSignal: t } = Na, r = zi, n = OV(), i = Vi, { createDeprecation: s } = VS, o = PV(), { isFormDataLike: a, formDataToStream: c } = CV(), { EventEmitter: u } = hu, l = s({
=======
      stream: t.from(d()),
      contentType: `multipart/form-data; boundary=${o}`
    };
  }
  return Zi.isFormDataLike = n, Zi.formDataToStream = s, Zi;
}
var Wy;
function A2() {
  if (Wy) return ws.exports;
  Wy = 1;
  const { Readable: e, addAbortSignal: t } = ri, r = yn, n = P2(), s = vn, { createDeprecation: i } = Iv, o = I2(), { isFormDataLike: a, formDataToStream: c } = N2(), { EventEmitter: f } = Qo, l = i({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    name: "FastifyDeprecationLightMyRequest",
    code: "FST_LIGHTMYREQUEST_DEP01",
    message: 'You are accessing "request.connection", use "request.socket" instead.'
  });
<<<<<<< HEAD
  function f(g) {
    return g.port ? g.host : g.hostname + (g.protocol === "https:" ? ":443" : ":80");
  }
  class m extends u {
=======
  function d(m) {
    return m.port ? m.host : m.hostname + (m.protocol === "https:" ? ":443" : ":80");
  }
  class g extends f {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    constructor(v) {
      super(), this.remoteAddress = v;
    }
  }
<<<<<<< HEAD
  function p(g) {
    return new v(this);
    function v(y) {
      d.call(y, {
        ...g,
        Request: void 0
      }), Object.assign(this, y);
      for (const E of Object.keys(d.prototype))
        this.constructor.prototype[E] = d.prototype[E];
      return r.inherits(this.constructor, g.Request), this;
    }
  }
  function d(g) {
    e.call(this, {
      autoDestroy: !1
    });
    const v = o(g.url || g.path, g.query);
    this.url = v.pathname + v.search, this.aborted = !1, this.httpVersionMajor = 1, this.httpVersionMinor = 1, this.httpVersion = "1.1", this.method = g.method ? g.method.toUpperCase() : "GET", this.headers = {}, this.rawHeaders = [];
    const y = g.headers || {};
    for (const C in y) {
      const V = C.toLowerCase();
      if ((V === "user-agent" || V === "content-type") && y[C] === void 0) {
        this.headers[V] = void 0;
        continue;
      }
      const b = y[C];
      i(b !== void 0, 'invalid value "undefined" for header ' + C), this.headers[V] = "" + b;
    }
    if ("user-agent" in this.headers || (this.headers["user-agent"] = "lightMyRequest"), this.headers.host = this.headers.host || g.authority || f(v), g.cookies) {
      const { cookies: C } = g, V = Object.keys(C).map((b) => n.serialize(b, C[b]));
      this.headers.cookie && V.unshift(this.headers.cookie), this.headers.cookie = V.join("; ");
    }
    this.socket = new m(g.remoteAddress || "127.0.0.1"), Object.defineProperty(this, "connection", {
=======
  function p(m) {
    return new v(this);
    function v(y) {
      u.call(y, {
        ...m,
        Request: void 0
      }), Object.assign(this, y);
      for (const _ of Object.keys(u.prototype))
        this.constructor.prototype[_] = u.prototype[_];
      return r.inherits(this.constructor, m.Request), this;
    }
  }
  function u(m) {
    e.call(this, {
      autoDestroy: !1
    });
    const v = o(m.url || m.path, m.query);
    this.url = v.pathname + v.search, this.aborted = !1, this.httpVersionMajor = 1, this.httpVersionMinor = 1, this.httpVersion = "1.1", this.method = m.method ? m.method.toUpperCase() : "GET", this.headers = {}, this.rawHeaders = [];
    const y = m.headers || {};
    for (const O in y) {
      const z = O.toLowerCase();
      if ((z === "user-agent" || z === "content-type") && y[O] === void 0) {
        this.headers[z] = void 0;
        continue;
      }
      const S = y[O];
      s(S !== void 0, 'invalid value "undefined" for header ' + O), this.headers[z] = "" + S;
    }
    if ("user-agent" in this.headers || (this.headers["user-agent"] = "lightMyRequest"), this.headers.host = this.headers.host || m.authority || d(v), m.cookies) {
      const { cookies: O } = m, z = Object.keys(O).map((S) => n.serialize(S, O[S]));
      this.headers.cookie && z.unshift(this.headers.cookie), this.headers.cookie = z.join("; ");
    }
    this.socket = new g(m.remoteAddress || "127.0.0.1"), Object.defineProperty(this, "connection", {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      get() {
        return l(), this.socket;
      },
      configurable: !0
    });
<<<<<<< HEAD
    let E = g.payload || g.body || null, R = E && typeof E.resume == "function";
    if (a(E)) {
      const C = c(E);
      E = C.stream, R = !0, this.headers["content-type"] = C.contentType, this.headers["transfer-encoding"] = "chunked";
    }
    E && typeof E != "string" && !R && !Buffer.isBuffer(E) && (E = JSON.stringify(E), "content-type" in this.headers || (this.headers["content-type"] = "application/json")), E && !R && !Object.hasOwn(this.headers, "content-length") && (this.headers["content-length"] = (Buffer.isBuffer(E) ? E.length : Buffer.byteLength(E)).toString());
    for (const C of Object.keys(this.headers))
      this.rawHeaders.push(C, this.headers[C]);
    this._lightMyRequest = {
      payload: E,
      isDone: !1,
      simulate: g.simulate || {},
      payloadAsStream: g.payloadAsStream,
      signal: g.signal
    };
    const w = g.signal;
    w && t(w, this);
    {
      const C = this._lightMyRequest.payload;
      C != null && C._readableState ? (this._read = h, C.on("error", (V) => {
        this.destroy(V);
      }), C.on("end", () => {
        this.push(null);
      })) : this._read = _;
=======
    let _ = m.payload || m.body || null, R = _ && typeof _.resume == "function";
    if (a(_)) {
      const O = c(_);
      _ = O.stream, R = !0, this.headers["content-type"] = O.contentType, this.headers["transfer-encoding"] = "chunked";
    }
    _ && typeof _ != "string" && !R && !Buffer.isBuffer(_) && (_ = JSON.stringify(_), "content-type" in this.headers || (this.headers["content-type"] = "application/json")), _ && !R && !Object.hasOwn(this.headers, "content-length") && (this.headers["content-length"] = (Buffer.isBuffer(_) ? _.length : Buffer.byteLength(_)).toString());
    for (const O of Object.keys(this.headers))
      this.rawHeaders.push(O, this.headers[O]);
    this._lightMyRequest = {
      payload: _,
      isDone: !1,
      simulate: m.simulate || {},
      payloadAsStream: m.payloadAsStream,
      signal: m.signal
    };
    const E = m.signal;
    E && t(E, this);
    {
      const O = this._lightMyRequest.payload;
      O != null && O._readableState ? (this._read = h, O.on("error", (z) => {
        this.destroy(z);
      }), O.on("end", () => {
        this.push(null);
      })) : this._read = b;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return this;
  }
  function h() {
<<<<<<< HEAD
    const g = this._lightMyRequest.payload;
    let v = !0, y = !1, E;
    for (; v && (E = g.read()); )
      y = !0, v = this.push(E);
    v && !y && this._lightMyRequest.payload.once("readable", this._read.bind(this));
  }
  function _() {
=======
    const m = this._lightMyRequest.payload;
    let v = !0, y = !1, _;
    for (; v && (_ = m.read()); )
      y = !0, v = this.push(_);
    v && !y && this._lightMyRequest.payload.once("readable", this._read.bind(this));
  }
  function b() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        this._lightMyRequest.simulate.end !== !1 && this.push(null);
        return;
      }
      this._lightMyRequest.isDone = !0, this._lightMyRequest.payload && (this._lightMyRequest.simulate.split ? (this.push(this._lightMyRequest.payload.slice(0, 1)), this.push(this._lightMyRequest.payload.slice(1))) : this.push(this._lightMyRequest.payload)), this._lightMyRequest.simulate.error && this.emit("error", new Error("Simulated")), this._lightMyRequest.simulate.close && this.emit("close"), this._lightMyRequest.simulate.end !== !1 && this.push(null);
    });
  }
<<<<<<< HEAD
  return r.inherits(d, e), r.inherits(p, d), d.prototype.destroy = function(g) {
    this.destroyed || this._lightMyRequest.isDone || (this.destroyed = !0, g && (this._error = !0, process.nextTick(() => this.emit("error", g))), process.nextTick(() => this.emit("close")));
  }, Co.exports = d, Co.exports.Request = d, Co.exports.CustomRequest = p, Co.exports;
}
var cs = { exports: {} }, Mb;
function IV() {
  if (Mb) return cs.exports;
  Mb = 1;
=======
  return r.inherits(u, e), r.inherits(p, u), u.prototype.destroy = function(m) {
    this.destroyed || this._lightMyRequest.isDone || (this.destroyed = !0, m && (this._error = !0, process.nextTick(() => this.emit("error", m))), process.nextTick(() => this.emit("close")));
  }, ws.exports = u, ws.exports.Request = u, ws.exports.CustomRequest = p, ws.exports;
}
var In = { exports: {} }, Ky;
function k2() {
  if (Ky) return In.exports;
  Ky = 1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var e = {
    decodeValues: !0,
    map: !1,
    silent: !1
  };
  function t(o) {
    return typeof o == "string" && !!o.trim();
  }
  function r(o, a) {
<<<<<<< HEAD
    var c = o.split(";").filter(t), u = c.shift(), l = n(u), f = l.name, m = l.value;
    a = a ? Object.assign({}, e, a) : e;
    try {
      m = a.decodeValues ? decodeURIComponent(m) : m;
    } catch (d) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + m + "'. Set options.decodeValues to false to disable this feature.",
        d
      );
    }
    var p = {
      name: f,
      value: m
    };
    return c.forEach(function(d) {
      var h = d.split("="), _ = h.shift().trimLeft().toLowerCase(), g = h.join("=");
      _ === "expires" ? p.expires = new Date(g) : _ === "max-age" ? p.maxAge = parseInt(g, 10) : _ === "secure" ? p.secure = !0 : _ === "httponly" ? p.httpOnly = !0 : _ === "samesite" ? p.sameSite = g : _ === "partitioned" ? p.partitioned = !0 : p[_] = g;
    }), p;
  }
  function n(o) {
    var a = "", c = "", u = o.split("=");
    return u.length > 1 ? (a = u.shift(), c = u.join("=")) : c = o, { name: a, value: c };
  }
  function i(o, a) {
=======
    var c = o.split(";").filter(t), f = c.shift(), l = n(f), d = l.name, g = l.value;
    a = a ? Object.assign({}, e, a) : e;
    try {
      g = a.decodeValues ? decodeURIComponent(g) : g;
    } catch (u) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + g + "'. Set options.decodeValues to false to disable this feature.",
        u
      );
    }
    var p = {
      name: d,
      value: g
    };
    return c.forEach(function(u) {
      var h = u.split("="), b = h.shift().trimLeft().toLowerCase(), m = h.join("=");
      b === "expires" ? p.expires = new Date(m) : b === "max-age" ? p.maxAge = parseInt(m, 10) : b === "secure" ? p.secure = !0 : b === "httponly" ? p.httpOnly = !0 : b === "samesite" ? p.sameSite = m : b === "partitioned" ? p.partitioned = !0 : p[b] = m;
    }), p;
  }
  function n(o) {
    var a = "", c = "", f = o.split("=");
    return f.length > 1 ? (a = f.shift(), c = f.join("=")) : c = o, { name: a, value: c };
  }
  function s(o, a) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (a = a ? Object.assign({}, e, a) : e, !o)
      return a.map ? {} : [];
    if (o.headers)
      if (typeof o.headers.getSetCookie == "function")
        o = o.headers.getSetCookie();
      else if (o.headers["set-cookie"])
        o = o.headers["set-cookie"];
      else {
        var c = o.headers[Object.keys(o.headers).find(function(l) {
          return l.toLowerCase() === "set-cookie";
        })];
        !c && o.headers.cookie && !a.silent && console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        ), o = c;
      }
    if (Array.isArray(o) || (o = [o]), a.map) {
<<<<<<< HEAD
      var u = {};
      return o.filter(t).reduce(function(l, f) {
        var m = r(f, a);
        return l[m.name] = m, l;
      }, u);
=======
      var f = {};
      return o.filter(t).reduce(function(l, d) {
        var g = r(d, a);
        return l[g.name] = g, l;
      }, f);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    } else
      return o.filter(t).map(function(l) {
        return r(l, a);
      });
  }
<<<<<<< HEAD
  function s(o) {
=======
  function i(o) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (Array.isArray(o))
      return o;
    if (typeof o != "string")
      return [];
<<<<<<< HEAD
    var a = [], c = 0, u, l, f, m, p;
    function d() {
=======
    var a = [], c = 0, f, l, d, g, p;
    function u() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      for (; c < o.length && /\s/.test(o.charAt(c)); )
        c += 1;
      return c < o.length;
    }
    function h() {
      return l = o.charAt(c), l !== "=" && l !== ";" && l !== ",";
    }
    for (; c < o.length; ) {
<<<<<<< HEAD
      for (u = c, p = !1; d(); )
        if (l = o.charAt(c), l === ",") {
          for (f = c, c += 1, d(), m = c; c < o.length && h(); )
            c += 1;
          c < o.length && o.charAt(c) === "=" ? (p = !0, c = m, a.push(o.substring(u, f)), u = c) : c = f + 1;
        } else
          c += 1;
      (!p || c >= o.length) && a.push(o.substring(u, o.length));
    }
    return a;
  }
  return cs.exports = i, cs.exports.parse = i, cs.exports.parseString = r, cs.exports.splitCookiesString = s, cs.exports;
}
var ep, Hb;
function NV() {
  if (Hb) return ep;
  Hb = 1;
  const e = mu, { Writable: t, Readable: r, addAbortSignal: n } = Na, i = zi, s = IV();
  function o(f, m, p) {
    var v;
    if (e.ServerResponse.call(this, f), (v = f._lightMyRequest) != null && v.payloadAsStream) {
      const y = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new r({ read: y }) };
      const E = f._lightMyRequest.signal;
      E && n(E, this._lightMyRequest.stream);
    } else
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    this.setHeader("foo", "bar"), this.removeHeader("foo"), this.assignSocket(c()), this._promiseCallback = typeof p == "function";
    let d = !1;
    const h = (y) => {
      if (!d) {
        if (d = !0, this._promiseCallback)
          return process.nextTick(() => m(y));
        process.nextTick(() => m(null, y));
      }
    };
    this._lightMyRequest.onEndSuccess = h;
    let _ = !1;
    const g = (y) => {
      if (d) {
        this._lightMyRequest.stream && !_ && (y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._lightMyRequest.stream.destroy(y), this._lightMyRequest.stream.on("error", () => {
        }));
        return;
      }
      if (d = !0, y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._promiseCallback)
        return process.nextTick(() => p(y));
      process.nextTick(() => m(y, null));
    };
    this._lightMyRequest.stream ? this.once("finish", () => {
      _ = !0, this._lightMyRequest.stream.push(null);
    }) : this.once("finish", () => {
      const y = a(this);
      y.raw.req = f, h(y);
    }), this.connection.once("error", g), this.once("error", g), this.once("close", g);
  }
  i.inherits(o, e.ServerResponse), o.prototype.setTimeout = function(f, m) {
    return this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, f), this.on("timeout", m), this;
  }, o.prototype.writeHead = function() {
    const f = e.ServerResponse.prototype.writeHead.apply(this, arguments);
    return l(this), this._lightMyRequest.stream && this._lightMyRequest.onEndSuccess(a(this)), f;
  }, o.prototype.write = function(f, m, p) {
    return this.timeoutHandle && clearTimeout(this.timeoutHandle), e.ServerResponse.prototype.write.call(this, f, m, p), this._lightMyRequest.stream ? this._lightMyRequest.stream.push(Buffer.from(f, m)) : (this._lightMyRequest.payloadChunks.push(Buffer.from(f, m)), !0);
  }, o.prototype.end = function(f, m, p) {
    f && this.write(f, m), e.ServerResponse.prototype.end.call(this, p), this.emit("finish"), this.destroy();
  }, o.prototype.destroy = function(f) {
    this.destroyed || (this.destroyed = !0, f && process.nextTick(() => this.emit("error", f)), process.nextTick(() => this.emit("close")));
  }, o.prototype.addTrailers = function(f) {
    for (const m in f)
      this._lightMyRequest.trailers[m.toLowerCase().trim()] = f[m].toString().trim();
  };
  function a(f) {
    f._lightMyRequest.headers === null && l(f), u(f);
    const m = {
      raw: {
        res: f
      },
      headers: f._lightMyRequest.headers,
      statusCode: f.statusCode,
      statusMessage: f.statusMessage,
      trailers: {},
      get cookies() {
        return s.parse(this);
      }
    };
    if (m.trailers = f._lightMyRequest.trailers, f._lightMyRequest.payloadChunks) {
      const p = Buffer.concat(f._lightMyRequest.payloadChunks);
      m.rawPayload = p, m.payload = p.toString(), m.body = m.payload, m.json = function() {
        return JSON.parse(m.payload);
      };
    } else
      m.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    return m.stream = function() {
      return f._lightMyRequest.stream ? f._lightMyRequest.stream : r.from(f._lightMyRequest.payloadChunks);
    }, m;
  }
  function c() {
    return new t({
      write(f, m, p) {
=======
      for (f = c, p = !1; u(); )
        if (l = o.charAt(c), l === ",") {
          for (d = c, c += 1, u(), g = c; c < o.length && h(); )
            c += 1;
          c < o.length && o.charAt(c) === "=" ? (p = !0, c = g, a.push(o.substring(f, d)), f = c) : c = d + 1;
        } else
          c += 1;
      (!p || c >= o.length) && a.push(o.substring(f, o.length));
    }
    return a;
  }
  return In.exports = s, In.exports.parse = s, In.exports.parseString = r, In.exports.splitCookiesString = i, In.exports;
}
var yl, Jy;
function L2() {
  if (Jy) return yl;
  Jy = 1;
  const e = ea, { Writable: t, Readable: r, addAbortSignal: n } = ri, s = yn, i = k2();
  function o(d, g, p) {
    var v;
    if (e.ServerResponse.call(this, d), (v = d._lightMyRequest) != null && v.payloadAsStream) {
      const y = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new r({ read: y }) };
      const _ = d._lightMyRequest.signal;
      _ && n(_, this._lightMyRequest.stream);
    } else
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    this.setHeader("foo", "bar"), this.removeHeader("foo"), this.assignSocket(c()), this._promiseCallback = typeof p == "function";
    let u = !1;
    const h = (y) => {
      if (!u) {
        if (u = !0, this._promiseCallback)
          return process.nextTick(() => g(y));
        process.nextTick(() => g(null, y));
      }
    };
    this._lightMyRequest.onEndSuccess = h;
    let b = !1;
    const m = (y) => {
      if (u) {
        this._lightMyRequest.stream && !b && (y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._lightMyRequest.stream.destroy(y), this._lightMyRequest.stream.on("error", () => {
        }));
        return;
      }
      if (u = !0, y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._promiseCallback)
        return process.nextTick(() => p(y));
      process.nextTick(() => g(y, null));
    };
    this._lightMyRequest.stream ? this.once("finish", () => {
      b = !0, this._lightMyRequest.stream.push(null);
    }) : this.once("finish", () => {
      const y = a(this);
      y.raw.req = d, h(y);
    }), this.connection.once("error", m), this.once("error", m), this.once("close", m);
  }
  s.inherits(o, e.ServerResponse), o.prototype.setTimeout = function(d, g) {
    return this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, d), this.on("timeout", g), this;
  }, o.prototype.writeHead = function() {
    const d = e.ServerResponse.prototype.writeHead.apply(this, arguments);
    return l(this), this._lightMyRequest.stream && this._lightMyRequest.onEndSuccess(a(this)), d;
  }, o.prototype.write = function(d, g, p) {
    return this.timeoutHandle && clearTimeout(this.timeoutHandle), e.ServerResponse.prototype.write.call(this, d, g, p), this._lightMyRequest.stream ? this._lightMyRequest.stream.push(Buffer.from(d, g)) : (this._lightMyRequest.payloadChunks.push(Buffer.from(d, g)), !0);
  }, o.prototype.end = function(d, g, p) {
    d && this.write(d, g), e.ServerResponse.prototype.end.call(this, p), this.emit("finish"), this.destroy();
  }, o.prototype.destroy = function(d) {
    this.destroyed || (this.destroyed = !0, d && process.nextTick(() => this.emit("error", d)), process.nextTick(() => this.emit("close")));
  }, o.prototype.addTrailers = function(d) {
    for (const g in d)
      this._lightMyRequest.trailers[g.toLowerCase().trim()] = d[g].toString().trim();
  };
  function a(d) {
    d._lightMyRequest.headers === null && l(d), f(d);
    const g = {
      raw: {
        res: d
      },
      headers: d._lightMyRequest.headers,
      statusCode: d.statusCode,
      statusMessage: d.statusMessage,
      trailers: {},
      get cookies() {
        return i.parse(this);
      }
    };
    if (g.trailers = d._lightMyRequest.trailers, d._lightMyRequest.payloadChunks) {
      const p = Buffer.concat(d._lightMyRequest.payloadChunks);
      g.rawPayload = p, g.payload = p.toString(), g.body = g.payload, g.json = function() {
        return JSON.parse(g.payload);
      };
    } else
      g.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    return g.stream = function() {
      return d._lightMyRequest.stream ? d._lightMyRequest.stream : r.from(d._lightMyRequest.payloadChunks);
    }, g;
  }
  function c() {
    return new t({
      write(d, g, p) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        setImmediate(p);
      }
    });
  }
<<<<<<< HEAD
  function u(f) {
    const m = f._lightMyRequest.headers;
    for (const p of Object.keys(m)) {
      const d = m[p];
      Array.isArray(d) ? m[p] = d.map((h) => "" + h) : m[p] = "" + d;
    }
  }
  function l(f) {
    f._lightMyRequest.headers = Object.assign({}, f.getHeaders()), ["Date", "Connection", "Transfer-Encoding"].forEach((m) => {
      var h;
      const p = new RegExp("\\r\\n" + m + ": ([^\\r]*)\\r\\n"), d = (h = f._header) == null ? void 0 : h.match(p);
      d && (f._lightMyRequest.headers[m.toLowerCase()] = d[1]);
    });
  }
  return ep = o, ep;
}
var Gc = { exports: {} }, qb;
function kV() {
  if (qb) return Gc.exports;
  qb = 1, Gc.exports = t, Gc.exports.default = t;
  const e = { properties: { method: { enum: ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] } } };
  function t(r, { instancePath: n = "", parentData: i, parentDataProperty: s, rootData: o = r } = {}) {
    let a = null, c = 0;
    const u = c;
    let l = !1, f = null;
    const m = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let w;
      if (r.url === void 0 && (w = "url")) {
        const C = { instancePath: n, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: w }, message: "must have required property '" + w + "'" };
        a === null ? a = [C] : a.push(C), c++;
      }
    }
    var d = m === c;
    d && (l = !0, f = 0);
    const p = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let w;
      if (r.path === void 0 && (w = "path")) {
        const C = { instancePath: n, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: w }, message: "must have required property '" + w + "'" };
        a === null ? a = [C] : a.push(C), c++;
      }
    }
    var d = p === c;
    if (d && l ? (l = !1, f = [f, 1]) : d && (l = !0, f = 1), l)
      c = u, a !== null && (u ? a.length = u : a = null);
    else {
      const w = { instancePath: n, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: f }, message: "must match exactly one schema in oneOf" };
      return a === null ? a = [w] : a.push(w), c++, t.errors = a, !1;
=======
  function f(d) {
    const g = d._lightMyRequest.headers;
    for (const p of Object.keys(g)) {
      const u = g[p];
      Array.isArray(u) ? g[p] = u.map((h) => "" + h) : g[p] = "" + u;
    }
  }
  function l(d) {
    d._lightMyRequest.headers = Object.assign({}, d.getHeaders()), ["Date", "Connection", "Transfer-Encoding"].forEach((g) => {
      var h;
      const p = new RegExp("\\r\\n" + g + ": ([^\\r]*)\\r\\n"), u = (h = d._header) == null ? void 0 : h.match(p);
      u && (d._lightMyRequest.headers[g.toLowerCase()] = u[1]);
    });
  }
  return yl = o, yl;
}
var Qi = { exports: {} }, Yy;
function j2() {
  if (Yy) return Qi.exports;
  Yy = 1, Qi.exports = t, Qi.exports.default = t;
  const e = { properties: { method: { enum: ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] } } };
  function t(r, { instancePath: n = "", parentData: s, parentDataProperty: i, rootData: o = r } = {}) {
    let a = null, c = 0;
    const f = c;
    let l = !1, d = null;
    const g = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let E;
      if (r.url === void 0 && (E = "url")) {
        const O = { instancePath: n, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: E }, message: "must have required property '" + E + "'" };
        a === null ? a = [O] : a.push(O), c++;
      }
    }
    var u = g === c;
    u && (l = !0, d = 0);
    const p = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let E;
      if (r.path === void 0 && (E = "path")) {
        const O = { instancePath: n, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: E }, message: "must have required property '" + E + "'" };
        a === null ? a = [O] : a.push(O), c++;
      }
    }
    var u = p === c;
    if (u && l ? (l = !1, d = [d, 1]) : u && (l = !0, d = 1), l)
      c = f, a !== null && (f ? a.length = f : a = null);
    else {
      const E = { instancePath: n, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: d }, message: "must match exactly one schema in oneOf" };
      return a === null ? a = [E] : a.push(E), c++, t.errors = a, !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    if (c === 0)
      if (r && typeof r == "object" && !Array.isArray(r)) {
        if (r.url !== void 0) {
<<<<<<< HEAD
          let w = r.url;
          const C = c, V = c;
          let b = !1, F = null;
          const H = c;
          if (typeof w != "string") {
            let $ = typeof w, x;
            if (x === void 0)
              if ($ == "number" || $ == "boolean")
                x = "" + w;
              else if (w === null)
                x = "";
              else {
                const A = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                a === null ? a = [A] : a.push(A), c++;
              }
            x !== void 0 && (w = x, r !== void 0 && (r.url = x));
          }
          var _ = H === c;
          _ && (b = !0, F = 0);
          const q = c;
          if (c === q)
            if (w && typeof w == "object" && !Array.isArray(w)) {
              let $;
              if (w.pathname === void 0 && ($ = "pathname")) {
                const x = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: $ }, message: "must have required property '" + $ + "'" };
                a === null ? a = [x] : a.push(x), c++;
              } else {
                if (w.protocol !== void 0) {
                  let x = w.protocol;
                  const A = c;
                  if (typeof x != "string") {
                    let P = typeof x, D;
                    if (D === void 0)
                      if (P == "number" || P == "boolean")
                        D = "" + x;
                      else if (x === null)
                        D = "";
                      else {
                        const I = { instancePath: n + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        a === null ? a = [I] : a.push(I), c++;
                      }
                    D !== void 0 && (x = D, w !== void 0 && (w.protocol = D));
                  }
                  var h = A === c;
                } else
                  var h = !0;
                if (h) {
                  if (w.hostname !== void 0) {
                    let x = w.hostname;
                    const A = c;
                    if (typeof x != "string") {
                      let D = typeof x, I;
                      if (I === void 0)
                        if (D == "number" || D == "boolean")
                          I = "" + x;
                        else if (x === null)
                          I = "";
                        else {
                          const L = { instancePath: n + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [L] : a.push(L), c++;
                        }
                      I !== void 0 && (x = I, w !== void 0 && (w.hostname = I));
                    }
                    var h = A === c;
                  } else
                    var h = !0;
                  if (h)
                    if (w.pathname !== void 0) {
                      let x = w.pathname;
                      const A = c;
                      if (typeof x != "string") {
                        let D = typeof x, I;
                        if (I === void 0)
                          if (D == "number" || D == "boolean")
                            I = "" + x;
                          else if (x === null)
                            I = "";
                          else {
                            const L = { instancePath: n + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [L] : a.push(L), c++;
                          }
                        I !== void 0 && (x = I, w !== void 0 && (w.pathname = I));
                      }
                      var h = A === c;
=======
          let E = r.url;
          const O = c, z = c;
          let S = !1, L = null;
          const M = c;
          if (typeof E != "string") {
            let $ = typeof E, x;
            if (x === void 0)
              if ($ == "number" || $ == "boolean")
                x = "" + E;
              else if (E === null)
                x = "";
              else {
                const I = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                a === null ? a = [I] : a.push(I), c++;
              }
            x !== void 0 && (E = x, r !== void 0 && (r.url = x));
          }
          var b = M === c;
          b && (S = !0, L = 0);
          const U = c;
          if (c === U)
            if (E && typeof E == "object" && !Array.isArray(E)) {
              let $;
              if (E.pathname === void 0 && ($ = "pathname")) {
                const x = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: $ }, message: "must have required property '" + $ + "'" };
                a === null ? a = [x] : a.push(x), c++;
              } else {
                if (E.protocol !== void 0) {
                  let x = E.protocol;
                  const I = c;
                  if (typeof x != "string") {
                    let T = typeof x, j;
                    if (j === void 0)
                      if (T == "number" || T == "boolean")
                        j = "" + x;
                      else if (x === null)
                        j = "";
                      else {
                        const C = { instancePath: n + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        a === null ? a = [C] : a.push(C), c++;
                      }
                    j !== void 0 && (x = j, E !== void 0 && (E.protocol = j));
                  }
                  var h = I === c;
                } else
                  var h = !0;
                if (h) {
                  if (E.hostname !== void 0) {
                    let x = E.hostname;
                    const I = c;
                    if (typeof x != "string") {
                      let j = typeof x, C;
                      if (C === void 0)
                        if (j == "number" || j == "boolean")
                          C = "" + x;
                        else if (x === null)
                          C = "";
                        else {
                          const A = { instancePath: n + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [A] : a.push(A), c++;
                        }
                      C !== void 0 && (x = C, E !== void 0 && (E.hostname = C));
                    }
                    var h = I === c;
                  } else
                    var h = !0;
                  if (h)
                    if (E.pathname !== void 0) {
                      let x = E.pathname;
                      const I = c;
                      if (typeof x != "string") {
                        let j = typeof x, C;
                        if (C === void 0)
                          if (j == "number" || j == "boolean")
                            C = "" + x;
                          else if (x === null)
                            C = "";
                          else {
                            const A = { instancePath: n + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [A] : a.push(A), c++;
                          }
                        C !== void 0 && (x = C, E !== void 0 && (E.pathname = C));
                      }
                      var h = I === c;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                    } else
                      var h = !0;
                }
              }
            } else {
              const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              a === null ? a = [$] : a.push($), c++;
            }
<<<<<<< HEAD
          var _ = q === c;
          if (_ && b ? (b = !1, F = [F, 1]) : _ && (b = !0, F = 1), b)
            c = V, a !== null && (V ? a.length = V : a = null);
          else {
            const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: F }, message: "must match exactly one schema in oneOf" };
            return a === null ? a = [$] : a.push($), c++, t.errors = a, !1;
          }
          var g = C === c;
        } else
          var g = !0;
        if (g) {
          if (r.path !== void 0) {
            let w = r.path;
            const C = c, V = c;
            let b = !1, F = null;
            const H = c;
            if (typeof w != "string") {
              let x = typeof w, A;
              if (A === void 0)
                if (x == "number" || x == "boolean")
                  A = "" + w;
                else if (w === null)
                  A = "";
                else {
                  const P = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  a === null ? a = [P] : a.push(P), c++;
                }
              A !== void 0 && (w = A, r !== void 0 && (r.path = A));
            }
            var y = H === c;
            y && (b = !0, F = 0);
            const q = c;
            if (c === q)
              if (w && typeof w == "object" && !Array.isArray(w)) {
                let x;
                if (w.pathname === void 0 && (x = "pathname")) {
                  const A = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: x }, message: "must have required property '" + x + "'" };
                  a === null ? a = [A] : a.push(A), c++;
                } else {
                  if (w.protocol !== void 0) {
                    let A = w.protocol;
                    const P = c;
                    if (typeof A != "string") {
                      let D = typeof A, I;
                      if (I === void 0)
                        if (D == "number" || D == "boolean")
                          I = "" + A;
                        else if (A === null)
                          I = "";
                        else {
                          const L = { instancePath: n + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [L] : a.push(L), c++;
                        }
                      I !== void 0 && (A = I, w !== void 0 && (w.protocol = I));
                    }
                    var v = P === c;
                  } else
                    var v = !0;
                  if (v) {
                    if (w.hostname !== void 0) {
                      let A = w.hostname;
                      const P = c;
                      if (typeof A != "string") {
                        let I = typeof A, L;
                        if (L === void 0)
                          if (I == "number" || I == "boolean")
                            L = "" + A;
                          else if (A === null)
                            L = "";
                          else {
                            const j = { instancePath: n + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [j] : a.push(j), c++;
                          }
                        L !== void 0 && (A = L, w !== void 0 && (w.hostname = L));
                      }
                      var v = P === c;
                    } else
                      var v = !0;
                    if (v)
                      if (w.pathname !== void 0) {
                        let A = w.pathname;
                        const P = c;
                        if (typeof A != "string") {
                          let I = typeof A, L;
                          if (L === void 0)
                            if (I == "number" || I == "boolean")
                              L = "" + A;
                            else if (A === null)
                              L = "";
                            else {
                              const j = { instancePath: n + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              a === null ? a = [j] : a.push(j), c++;
                            }
                          L !== void 0 && (A = L, w !== void 0 && (w.pathname = L));
                        }
                        var v = P === c;
=======
          var b = U === c;
          if (b && S ? (S = !1, L = [L, 1]) : b && (S = !0, L = 1), S)
            c = z, a !== null && (z ? a.length = z : a = null);
          else {
            const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: L }, message: "must match exactly one schema in oneOf" };
            return a === null ? a = [$] : a.push($), c++, t.errors = a, !1;
          }
          var m = O === c;
        } else
          var m = !0;
        if (m) {
          if (r.path !== void 0) {
            let E = r.path;
            const O = c, z = c;
            let S = !1, L = null;
            const M = c;
            if (typeof E != "string") {
              let x = typeof E, I;
              if (I === void 0)
                if (x == "number" || x == "boolean")
                  I = "" + E;
                else if (E === null)
                  I = "";
                else {
                  const T = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  a === null ? a = [T] : a.push(T), c++;
                }
              I !== void 0 && (E = I, r !== void 0 && (r.path = I));
            }
            var y = M === c;
            y && (S = !0, L = 0);
            const U = c;
            if (c === U)
              if (E && typeof E == "object" && !Array.isArray(E)) {
                let x;
                if (E.pathname === void 0 && (x = "pathname")) {
                  const I = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: x }, message: "must have required property '" + x + "'" };
                  a === null ? a = [I] : a.push(I), c++;
                } else {
                  if (E.protocol !== void 0) {
                    let I = E.protocol;
                    const T = c;
                    if (typeof I != "string") {
                      let j = typeof I, C;
                      if (C === void 0)
                        if (j == "number" || j == "boolean")
                          C = "" + I;
                        else if (I === null)
                          C = "";
                        else {
                          const A = { instancePath: n + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [A] : a.push(A), c++;
                        }
                      C !== void 0 && (I = C, E !== void 0 && (E.protocol = C));
                    }
                    var v = T === c;
                  } else
                    var v = !0;
                  if (v) {
                    if (E.hostname !== void 0) {
                      let I = E.hostname;
                      const T = c;
                      if (typeof I != "string") {
                        let C = typeof I, A;
                        if (A === void 0)
                          if (C == "number" || C == "boolean")
                            A = "" + I;
                          else if (I === null)
                            A = "";
                          else {
                            const k = { instancePath: n + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [k] : a.push(k), c++;
                          }
                        A !== void 0 && (I = A, E !== void 0 && (E.hostname = A));
                      }
                      var v = T === c;
                    } else
                      var v = !0;
                    if (v)
                      if (E.pathname !== void 0) {
                        let I = E.pathname;
                        const T = c;
                        if (typeof I != "string") {
                          let C = typeof I, A;
                          if (A === void 0)
                            if (C == "number" || C == "boolean")
                              A = "" + I;
                            else if (I === null)
                              A = "";
                            else {
                              const k = { instancePath: n + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              a === null ? a = [k] : a.push(k), c++;
                            }
                          A !== void 0 && (I = A, E !== void 0 && (E.pathname = A));
                        }
                        var v = T === c;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                      } else
                        var v = !0;
                  }
                }
              } else {
                const x = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                a === null ? a = [x] : a.push(x), c++;
              }
<<<<<<< HEAD
            var y = q === c;
            if (y && b ? (b = !1, F = [F, 1]) : y && (b = !0, F = 1), b)
              c = V, a !== null && (V ? a.length = V : a = null);
            else {
              const x = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: F }, message: "must match exactly one schema in oneOf" };
              return a === null ? a = [x] : a.push(x), c++, t.errors = a, !1;
            }
            var g = C === c;
          } else
            var g = !0;
          if (g) {
            if (r.cookies !== void 0) {
              let w = r.cookies;
              const C = c;
              if (c === C && !(w && typeof w == "object" && !Array.isArray(w)))
                return t.errors = [{ instancePath: n + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
              var g = C === c;
            } else
              var g = !0;
            if (g) {
              if (r.headers !== void 0) {
                let w = r.headers;
                const C = c;
                if (c === C && !(w && typeof w == "object" && !Array.isArray(w)))
                  return t.errors = [{ instancePath: n + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                var g = C === c;
              } else
                var g = !0;
              if (g) {
                if (r.query !== void 0) {
                  let w = r.query;
                  const C = c, V = c;
                  let b = !1;
                  const F = c;
                  if (c === F && !(w && typeof w == "object" && !Array.isArray(w))) {
                    const q = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    a === null ? a = [q] : a.push(q), c++;
                  }
                  var E = F === c;
                  if (b = b || E, !b) {
                    const q = c;
                    if (typeof w != "string") {
                      let x = typeof w, A;
                      if (A === void 0)
                        if (x == "number" || x == "boolean")
                          A = "" + w;
                        else if (w === null)
                          A = "";
                        else {
                          const P = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [P] : a.push(P), c++;
                        }
                      A !== void 0 && (w = A, r !== void 0 && (r.query = A));
                    }
                    var E = q === c;
                    b = b || E;
                  }
                  if (b)
                    c = V, a !== null && (V ? a.length = V : a = null);
                  else {
                    const q = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    return a === null ? a = [q] : a.push(q), c++, t.errors = a, !1;
                  }
                  var g = C === c;
                } else
                  var g = !0;
                if (g) {
                  if (r.simulate !== void 0) {
                    let w = r.simulate;
                    const C = c;
                    if (c === C)
                      if (w && typeof w == "object" && !Array.isArray(w)) {
                        if (w.end !== void 0) {
                          let b = w.end;
                          const F = c;
                          if (typeof b != "boolean") {
                            let H;
                            if (H === void 0)
                              if (b === "false" || b === 0 || b === null)
                                H = !1;
                              else if (b === "true" || b === 1)
                                H = !0;
                              else
                                return t.errors = [{ instancePath: n + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            H !== void 0 && (b = H, w !== void 0 && (w.end = H));
                          }
                          var R = F === c;
                        } else
                          var R = !0;
                        if (R) {
                          if (w.split !== void 0) {
                            let b = w.split;
                            const F = c;
                            if (typeof b != "boolean") {
                              let q;
                              if (q === void 0)
                                if (b === "false" || b === 0 || b === null)
                                  q = !1;
                                else if (b === "true" || b === 1)
                                  q = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              q !== void 0 && (b = q, w !== void 0 && (w.split = q));
                            }
                            var R = F === c;
                          } else
                            var R = !0;
                          if (R) {
                            if (w.error !== void 0) {
                              let b = w.error;
                              const F = c;
                              if (typeof b != "boolean") {
                                let q;
                                if (q === void 0)
                                  if (b === "false" || b === 0 || b === null)
                                    q = !1;
                                  else if (b === "true" || b === 1)
                                    q = !0;
                                  else
                                    return t.errors = [{ instancePath: n + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                q !== void 0 && (b = q, w !== void 0 && (w.error = q));
                              }
                              var R = F === c;
                            } else
                              var R = !0;
                            if (R)
                              if (w.close !== void 0) {
                                let b = w.close;
                                const F = c;
                                if (typeof b != "boolean") {
                                  let q;
                                  if (q === void 0)
                                    if (b === "false" || b === 0 || b === null)
                                      q = !1;
                                    else if (b === "true" || b === 1)
                                      q = !0;
                                    else
                                      return t.errors = [{ instancePath: n + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  q !== void 0 && (b = q, w !== void 0 && (w.close = q));
                                }
                                var R = F === c;
=======
            var y = U === c;
            if (y && S ? (S = !1, L = [L, 1]) : y && (S = !0, L = 1), S)
              c = z, a !== null && (z ? a.length = z : a = null);
            else {
              const x = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: L }, message: "must match exactly one schema in oneOf" };
              return a === null ? a = [x] : a.push(x), c++, t.errors = a, !1;
            }
            var m = O === c;
          } else
            var m = !0;
          if (m) {
            if (r.cookies !== void 0) {
              let E = r.cookies;
              const O = c;
              if (c === O && !(E && typeof E == "object" && !Array.isArray(E)))
                return t.errors = [{ instancePath: n + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
              var m = O === c;
            } else
              var m = !0;
            if (m) {
              if (r.headers !== void 0) {
                let E = r.headers;
                const O = c;
                if (c === O && !(E && typeof E == "object" && !Array.isArray(E)))
                  return t.errors = [{ instancePath: n + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                var m = O === c;
              } else
                var m = !0;
              if (m) {
                if (r.query !== void 0) {
                  let E = r.query;
                  const O = c, z = c;
                  let S = !1;
                  const L = c;
                  if (c === L && !(E && typeof E == "object" && !Array.isArray(E))) {
                    const U = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    a === null ? a = [U] : a.push(U), c++;
                  }
                  var _ = L === c;
                  if (S = S || _, !S) {
                    const U = c;
                    if (typeof E != "string") {
                      let x = typeof E, I;
                      if (I === void 0)
                        if (x == "number" || x == "boolean")
                          I = "" + E;
                        else if (E === null)
                          I = "";
                        else {
                          const T = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [T] : a.push(T), c++;
                        }
                      I !== void 0 && (E = I, r !== void 0 && (r.query = I));
                    }
                    var _ = U === c;
                    S = S || _;
                  }
                  if (S)
                    c = z, a !== null && (z ? a.length = z : a = null);
                  else {
                    const U = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    return a === null ? a = [U] : a.push(U), c++, t.errors = a, !1;
                  }
                  var m = O === c;
                } else
                  var m = !0;
                if (m) {
                  if (r.simulate !== void 0) {
                    let E = r.simulate;
                    const O = c;
                    if (c === O)
                      if (E && typeof E == "object" && !Array.isArray(E)) {
                        if (E.end !== void 0) {
                          let S = E.end;
                          const L = c;
                          if (typeof S != "boolean") {
                            let M;
                            if (M === void 0)
                              if (S === "false" || S === 0 || S === null)
                                M = !1;
                              else if (S === "true" || S === 1)
                                M = !0;
                              else
                                return t.errors = [{ instancePath: n + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            M !== void 0 && (S = M, E !== void 0 && (E.end = M));
                          }
                          var R = L === c;
                        } else
                          var R = !0;
                        if (R) {
                          if (E.split !== void 0) {
                            let S = E.split;
                            const L = c;
                            if (typeof S != "boolean") {
                              let U;
                              if (U === void 0)
                                if (S === "false" || S === 0 || S === null)
                                  U = !1;
                                else if (S === "true" || S === 1)
                                  U = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              U !== void 0 && (S = U, E !== void 0 && (E.split = U));
                            }
                            var R = L === c;
                          } else
                            var R = !0;
                          if (R) {
                            if (E.error !== void 0) {
                              let S = E.error;
                              const L = c;
                              if (typeof S != "boolean") {
                                let U;
                                if (U === void 0)
                                  if (S === "false" || S === 0 || S === null)
                                    U = !1;
                                  else if (S === "true" || S === 1)
                                    U = !0;
                                  else
                                    return t.errors = [{ instancePath: n + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                U !== void 0 && (S = U, E !== void 0 && (E.error = U));
                              }
                              var R = L === c;
                            } else
                              var R = !0;
                            if (R)
                              if (E.close !== void 0) {
                                let S = E.close;
                                const L = c;
                                if (typeof S != "boolean") {
                                  let U;
                                  if (U === void 0)
                                    if (S === "false" || S === 0 || S === null)
                                      U = !1;
                                    else if (S === "true" || S === 1)
                                      U = !0;
                                    else
                                      return t.errors = [{ instancePath: n + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  U !== void 0 && (S = U, E !== void 0 && (E.close = U));
                                }
                                var R = L === c;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                              } else
                                var R = !0;
                          }
                        }
                      } else
                        return t.errors = [{ instancePath: n + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
<<<<<<< HEAD
                    var g = C === c;
                  } else
                    var g = !0;
                  if (g) {
                    if (r.authority !== void 0) {
                      let w = r.authority;
                      const C = c;
                      if (typeof w != "string") {
                        let b = typeof w, F;
                        if (F === void 0)
                          if (b == "number" || b == "boolean")
                            F = "" + w;
                          else if (w === null)
                            F = "";
                          else
                            return t.errors = [{ instancePath: n + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                        F !== void 0 && (w = F, r !== void 0 && (r.authority = F));
                      }
                      var g = C === c;
                    } else
                      var g = !0;
                    if (g) {
                      if (r.remoteAddress !== void 0) {
                        let w = r.remoteAddress;
                        const C = c;
                        if (typeof w != "string") {
                          let b = typeof w, F;
                          if (F === void 0)
                            if (b == "number" || b == "boolean")
                              F = "" + w;
                            else if (w === null)
                              F = "";
                            else
                              return t.errors = [{ instancePath: n + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                          F !== void 0 && (w = F, r !== void 0 && (r.remoteAddress = F));
                        }
                        var g = C === c;
                      } else
                        var g = !0;
                      if (g) {
                        if (r.method !== void 0) {
                          let w = r.method;
                          const C = c;
                          if (typeof w != "string") {
                            let b = typeof w, F;
                            if (F === void 0)
                              if (b == "number" || b == "boolean")
                                F = "" + w;
                              else if (w === null)
                                F = "";
                              else
                                return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                            F !== void 0 && (w = F, r !== void 0 && (r.method = F));
                          }
                          if (!(w === "ACL" || w === "BIND" || w === "CHECKOUT" || w === "CONNECT" || w === "COPY" || w === "DELETE" || w === "GET" || w === "HEAD" || w === "LINK" || w === "LOCK" || w === "M-SEARCH" || w === "MERGE" || w === "MKACTIVITY" || w === "MKCALENDAR" || w === "MKCOL" || w === "MOVE" || w === "NOTIFY" || w === "OPTIONS" || w === "PATCH" || w === "POST" || w === "PROPFIND" || w === "PROPPATCH" || w === "PURGE" || w === "PUT" || w === "QUERY" || w === "REBIND" || w === "REPORT" || w === "SEARCH" || w === "SOURCE" || w === "SUBSCRIBE" || w === "TRACE" || w === "UNBIND" || w === "UNLINK" || w === "UNLOCK" || w === "UNSUBSCRIBE" || w === "acl" || w === "bind" || w === "checkout" || w === "connect" || w === "copy" || w === "delete" || w === "get" || w === "head" || w === "link" || w === "lock" || w === "m-search" || w === "merge" || w === "mkactivity" || w === "mkcalendar" || w === "mkcol" || w === "move" || w === "notify" || w === "options" || w === "patch" || w === "post" || w === "propfind" || w === "proppatch" || w === "purge" || w === "put" || w === "query" || w === "rebind" || w === "report" || w === "search" || w === "source" || w === "subscribe" || w === "trace" || w === "unbind" || w === "unlink" || w === "unlock" || w === "unsubscribe"))
                            return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: e.properties.method.enum }, message: "must be equal to one of the allowed values" }], !1;
                          var g = C === c;
                        } else
                          var g = !0;
                        if (g)
                          if (r.validate !== void 0) {
                            let w = r.validate;
                            const C = c;
                            if (typeof w != "boolean") {
                              let b;
                              if (b === void 0)
                                if (w === "false" || w === 0 || w === null)
                                  b = !1;
                                else if (w === "true" || w === 1)
                                  b = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              b !== void 0 && (w = b, r !== void 0 && (r.validate = b));
                            }
                            var g = C === c;
                          } else
                            var g = !0;
=======
                    var m = O === c;
                  } else
                    var m = !0;
                  if (m) {
                    if (r.authority !== void 0) {
                      let E = r.authority;
                      const O = c;
                      if (typeof E != "string") {
                        let S = typeof E, L;
                        if (L === void 0)
                          if (S == "number" || S == "boolean")
                            L = "" + E;
                          else if (E === null)
                            L = "";
                          else
                            return t.errors = [{ instancePath: n + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                        L !== void 0 && (E = L, r !== void 0 && (r.authority = L));
                      }
                      var m = O === c;
                    } else
                      var m = !0;
                    if (m) {
                      if (r.remoteAddress !== void 0) {
                        let E = r.remoteAddress;
                        const O = c;
                        if (typeof E != "string") {
                          let S = typeof E, L;
                          if (L === void 0)
                            if (S == "number" || S == "boolean")
                              L = "" + E;
                            else if (E === null)
                              L = "";
                            else
                              return t.errors = [{ instancePath: n + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                          L !== void 0 && (E = L, r !== void 0 && (r.remoteAddress = L));
                        }
                        var m = O === c;
                      } else
                        var m = !0;
                      if (m) {
                        if (r.method !== void 0) {
                          let E = r.method;
                          const O = c;
                          if (typeof E != "string") {
                            let S = typeof E, L;
                            if (L === void 0)
                              if (S == "number" || S == "boolean")
                                L = "" + E;
                              else if (E === null)
                                L = "";
                              else
                                return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                            L !== void 0 && (E = L, r !== void 0 && (r.method = L));
                          }
                          if (!(E === "ACL" || E === "BIND" || E === "CHECKOUT" || E === "CONNECT" || E === "COPY" || E === "DELETE" || E === "GET" || E === "HEAD" || E === "LINK" || E === "LOCK" || E === "M-SEARCH" || E === "MERGE" || E === "MKACTIVITY" || E === "MKCALENDAR" || E === "MKCOL" || E === "MOVE" || E === "NOTIFY" || E === "OPTIONS" || E === "PATCH" || E === "POST" || E === "PROPFIND" || E === "PROPPATCH" || E === "PURGE" || E === "PUT" || E === "QUERY" || E === "REBIND" || E === "REPORT" || E === "SEARCH" || E === "SOURCE" || E === "SUBSCRIBE" || E === "TRACE" || E === "UNBIND" || E === "UNLINK" || E === "UNLOCK" || E === "UNSUBSCRIBE" || E === "acl" || E === "bind" || E === "checkout" || E === "connect" || E === "copy" || E === "delete" || E === "get" || E === "head" || E === "link" || E === "lock" || E === "m-search" || E === "merge" || E === "mkactivity" || E === "mkcalendar" || E === "mkcol" || E === "move" || E === "notify" || E === "options" || E === "patch" || E === "post" || E === "propfind" || E === "proppatch" || E === "purge" || E === "put" || E === "query" || E === "rebind" || E === "report" || E === "search" || E === "source" || E === "subscribe" || E === "trace" || E === "unbind" || E === "unlink" || E === "unlock" || E === "unsubscribe"))
                            return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: e.properties.method.enum }, message: "must be equal to one of the allowed values" }], !1;
                          var m = O === c;
                        } else
                          var m = !0;
                        if (m)
                          if (r.validate !== void 0) {
                            let E = r.validate;
                            const O = c;
                            if (typeof E != "boolean") {
                              let S;
                              if (S === void 0)
                                if (E === "false" || E === 0 || E === null)
                                  S = !1;
                                else if (E === "true" || E === 1)
                                  S = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              S !== void 0 && (E = S, r !== void 0 && (r.validate = S));
                            }
                            var m = O === c;
                          } else
                            var m = !0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else
        return t.errors = [{ instancePath: n, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    return t.errors = a, c === 0;
  }
<<<<<<< HEAD
  return Gc.exports;
}
var Bb;
function DV() {
  if (Bb) return as.exports;
  Bb = 1;
  const e = Vi, t = AV(), r = NV(), n = "The dispatch function has already been invoked", i = kV();
  function s(p, d, h) {
    return h === void 0 ? new u(p, d) : c(p, d, h);
  }
  function o(p, d) {
    const h = p._lightMyRequest.payload;
    if (!h || h._readableState || typeof h.resume != "function")
      return d();
    const _ = [];
    h.on("data", (g) => _.push(Buffer.from(g))), h.on("end", () => {
      const g = Buffer.concat(_);
      return p.headers["content-length"] = p.headers["content-length"] || "" + g.length, delete p.headers["transfer-encoding"], p._lightMyRequest.payload = g, d();
    }), h.resume();
  }
  function a(p, d, h, _) {
    return h.once("error", function(g) {
      this.destroyed && _.destroy(g);
    }), h.once("close", function() {
      this.destroyed && !this._error && _.destroy();
    }), o(h, () => p.call(d, h, _));
  }
  function c(p, d, h) {
    if (d = typeof d == "string" ? { url: d } : d, d.validate !== !1 && (e(typeof p == "function", "dispatchFunc should be a function"), !i(d)))
      throw new Error(i.errors.map((y) => y.message));
    const _ = d.server || {}, g = d.Request ? t.CustomRequest : t;
    if (p.request && p.request.app === p && (Object.setPrototypeOf(Object.getPrototypeOf(p.request), g.prototype), Object.setPrototypeOf(Object.getPrototypeOf(p.response), r.prototype)), typeof h == "function") {
      const v = new g(d), y = new r(v, h);
      return a(p, _, v, y);
    } else
      return new Promise((v, y) => {
        const E = new g(d), R = new r(E, v, y);
        a(p, _, E, R);
      });
  }
  function u(p, d) {
    typeof d == "string" ? this.option = { url: d } : this.option = Object.assign({}, d), this.dispatch = p, this._hasInvoked = !1, this._promise = null, this.option.autoStart !== !1 && process.nextTick(() => {
=======
  return Qi.exports;
}
var Xy;
function D2() {
  if (Xy) return Pn.exports;
  Xy = 1;
  const e = vn, t = A2(), r = L2(), n = "The dispatch function has already been invoked", s = j2();
  function i(p, u, h) {
    return h === void 0 ? new f(p, u) : c(p, u, h);
  }
  function o(p, u) {
    const h = p._lightMyRequest.payload;
    if (!h || h._readableState || typeof h.resume != "function")
      return u();
    const b = [];
    h.on("data", (m) => b.push(Buffer.from(m))), h.on("end", () => {
      const m = Buffer.concat(b);
      return p.headers["content-length"] = p.headers["content-length"] || "" + m.length, delete p.headers["transfer-encoding"], p._lightMyRequest.payload = m, u();
    }), h.resume();
  }
  function a(p, u, h, b) {
    return h.once("error", function(m) {
      this.destroyed && b.destroy(m);
    }), h.once("close", function() {
      this.destroyed && !this._error && b.destroy();
    }), o(h, () => p.call(u, h, b));
  }
  function c(p, u, h) {
    if (u = typeof u == "string" ? { url: u } : u, u.validate !== !1 && (e(typeof p == "function", "dispatchFunc should be a function"), !s(u)))
      throw new Error(s.errors.map((y) => y.message));
    const b = u.server || {}, m = u.Request ? t.CustomRequest : t;
    if (p.request && p.request.app === p && (Object.setPrototypeOf(Object.getPrototypeOf(p.request), m.prototype), Object.setPrototypeOf(Object.getPrototypeOf(p.response), r.prototype)), typeof h == "function") {
      const v = new m(u), y = new r(v, h);
      return a(p, b, v, y);
    } else
      return new Promise((v, y) => {
        const _ = new m(u), R = new r(_, v, y);
        a(p, b, _, R);
      });
  }
  function f(p, u) {
    typeof u == "string" ? this.option = { url: u } : this.option = Object.assign({}, u), this.dispatch = p, this._hasInvoked = !1, this._promise = null, this.option.autoStart !== !1 && process.nextTick(() => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      this._hasInvoked || this.end();
    });
  }
  [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ].forEach((p) => {
<<<<<<< HEAD
    u.prototype[p] = function(d) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option.url = d, this.option.method = p.toUpperCase(), this;
=======
    f.prototype[p] = function(u) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option.url = u, this.option.method = p.toUpperCase(), this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    };
  }), [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ].forEach((p) => {
<<<<<<< HEAD
    u.prototype[p] = function(d) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option[p] = d, this;
    };
  }), u.prototype.end = function(p) {
=======
    f.prototype[p] = function(u) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option[p] = u, this;
    };
  }), f.prototype.end = function(p) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (this._hasInvoked === !0 || this._promise)
      throw new Error(n);
    if (this._hasInvoked = !0, typeof p == "function")
      c(this.dispatch, this.option, p);
    else
      return this._promise = c(this.dispatch, this.option), this._promise;
  }, Object.getOwnPropertyNames(Promise.prototype).forEach((p) => {
<<<<<<< HEAD
    p !== "constructor" && (u.prototype[p] = function(...d) {
=======
    p !== "constructor" && (f.prototype[p] = function(...u) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (!this._promise) {
        if (this._hasInvoked === !0)
          throw new Error(n);
        this._hasInvoked = !0, this._promise = c(this.dispatch, this.option);
      }
<<<<<<< HEAD
      return this._promise[p](...d);
    });
  });
  function m(p) {
    var d;
    return p instanceof t || p instanceof r || ((d = p == null ? void 0 : p.constructor) == null ? void 0 : d.name) === "_CustomLMRRequest";
  }
  return as.exports = s, as.exports.default = s, as.exports.inject = s, as.exports.isInjection = m, as.exports;
}
const LV = "5.2.2", FV = TA, Wc = mu, jV = om;
let Io;
const {
  kAvvioBoot: No,
  kChildren: tp,
  kServerBindings: zb,
  kBodyLimit: UV,
  kSupportedHTTPMethods: mi,
  kRoutePrefix: Vb,
  kLogLevel: MV,
  kLogSerializers: HV,
  kHooks: rp,
  kSchemaController: kn,
  kRequestAcceptVersion: qV,
  kReplySerializerDefault: Gb,
  kContentTypeParser: BV,
  kReply: zV,
  kRequest: VV,
  kFourOhFour: GV,
  kState: ut,
  kOptions: np,
  kPluginNameChain: ko,
  kSchemaErrorFormatter: ip,
  kErrorHandler: Kc,
  kKeepAliveConnections: sp,
  kChildLoggerFactory: op,
  kGenReqId: ap
} = Ft, { createServer: WV } = BS, Do = xm, Yc = Pm, KV = Cm, ls = Hx, gi = Kx, Wb = T$, { Hooks: YV, hookRunnerApplication: Kb, supportedHooks: Nh } = Wi, { createChildLogger: Yb, defaultChildLoggerFactory: JV, createLogger: XV } = Tu, Jb = L$, { getGenReqId: Xb, reqIdGenFactory: Zb } = ay, { buildRouting: ZV, validateBodyLimitOption: QV } = eV, e6 = lV, p1 = yV, t6 = RV, r6 = TV, {
  appendStackTrace: n6,
  AVVIO_ERRORS_MAP: Qb,
  ...Ti
} = Wt, { defaultInitOptions: mr } = p1, {
  FST_ERR_ASYNC_CONSTRAINT: i6,
  FST_ERR_BAD_URL: s6,
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: o6,
  FST_ERR_OPTIONS_NOT_OBJ: a6,
  FST_ERR_QSP_NOT_FN: c6,
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: l6,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: u6,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: f6,
  FST_ERR_INSTANCE_ALREADY_LISTENING: d6,
  FST_ERR_REOPENED_CLOSE_SERVER: p6,
  FST_ERR_ROUTE_REWRITE_NOT_STR: h6,
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: eE,
  FST_ERR_ERROR_HANDLER_NOT_FN: m6,
  FST_ERR_ROUTE_METHOD_INVALID: g6
} = Ti, { buildErrorHandler: tE } = Cu, rE = jV.channel("fastify.initialization");
function y6(e) {
  const t = {};
  return ["errorHandler", "logLevel", "logSerializers"].concat(Nh).forEach((n) => {
    t[n] = e.store[n];
  }), Object.assign({}, t);
}
function hy(e) {
  if (e && typeof e != "object")
    throw new a6();
  if (e = Object.assign({}, e), e.querystringParser && typeof e.querystringParser != "function")
    throw new c6(typeof e.querystringParser);
  if (e.schemaController && e.schemaController.bucket && typeof e.schemaController.bucket != "function")
    throw new l6(typeof e.schemaController.bucket);
  QV(e.bodyLimit);
  const t = typeof e.requestIdHeader == "string" && e.requestIdHeader.length !== 0 ? e.requestIdHeader.toLowerCase() : e.requestIdHeader === !0 && "request-id", r = Zb(t, e.genReqId), n = e.requestIdLogLabel || "reqId", i = e.bodyLimit || mr.bodyLimit, s = e.disableRequestLogging || !1, o = Object.assign({
=======
      return this._promise[p](...u);
    });
  });
  function g(p) {
    var u;
    return p instanceof t || p instanceof r || ((u = p == null ? void 0 : p.constructor) == null ? void 0 : u.name) === "_CustomLMRRequest";
  }
  return Pn.exports = i, Pn.exports.default = i, Pn.exports.inject = i, Pn.exports.isInjection = g, Pn.exports;
}
const F2 = "5.2.2", M2 = Ox, eo = ea, z2 = zu;
let $s;
const {
  kAvvioBoot: Ts,
  kChildren: gl,
  kServerBindings: Zy,
  kBodyLimit: U2,
  kSupportedHTTPMethods: Jr,
  kRoutePrefix: Qy,
  kLogLevel: q2,
  kLogSerializers: H2,
  kHooks: vl,
  kSchemaController: Nr,
  kRequestAcceptVersion: B2,
  kReplySerializerDefault: eg,
  kContentTypeParser: V2,
  kReply: G2,
  kRequest: W2,
  kFourOhFour: K2,
  kState: Ke,
  kOptions: bl,
  kPluginNameChain: Os,
  kSchemaErrorFormatter: _l,
  kErrorHandler: to,
  kKeepAliveConnections: El,
  kChildLoggerFactory: Sl,
  kGenReqId: xl
} = ht, { createServer: J2 } = Cv, Cs = af, ro = df, Y2 = pf, Nn = Tb, Yr = kb, tg = p_, { Hooks: X2, hookRunnerApplication: rg, supportedHooks: Ou } = bn, { createChildLogger: ng, defaultChildLoggerFactory: Z2, createLogger: Q2 } = ca, sg = S_, { getGenReqId: ig, reqIdGenFactory: og } = Hd, { buildRouting: eM, validateBodyLimitOption: tM } = r2, rM = f2, Q_ = b2, nM = T2, sM = C2, {
  appendStackTrace: iM,
  AVVIO_ERRORS_MAP: ag,
  ...sn
} = _t, { defaultInitOptions: Nt } = Q_, {
  FST_ERR_ASYNC_CONSTRAINT: oM,
  FST_ERR_BAD_URL: aM,
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: cM,
  FST_ERR_OPTIONS_NOT_OBJ: lM,
  FST_ERR_QSP_NOT_FN: uM,
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: fM,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: dM,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: pM,
  FST_ERR_INSTANCE_ALREADY_LISTENING: hM,
  FST_ERR_REOPENED_CLOSE_SERVER: mM,
  FST_ERR_ROUTE_REWRITE_NOT_STR: yM,
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: cg,
  FST_ERR_ERROR_HANDLER_NOT_FN: gM,
  FST_ERR_ROUTE_METHOD_INVALID: vM
} = sn, { buildErrorHandler: lg } = fa, ug = z2.channel("fastify.initialization");
function bM(e) {
  const t = {};
  return ["errorHandler", "logLevel", "logSerializers"].concat(Ou).forEach((n) => {
    t[n] = e.store[n];
  }), Object.assign({}, t);
}
function Yd(e) {
  if (e && typeof e != "object")
    throw new lM();
  if (e = Object.assign({}, e), e.querystringParser && typeof e.querystringParser != "function")
    throw new uM(typeof e.querystringParser);
  if (e.schemaController && e.schemaController.bucket && typeof e.schemaController.bucket != "function")
    throw new fM(typeof e.schemaController.bucket);
  tM(e.bodyLimit);
  const t = typeof e.requestIdHeader == "string" && e.requestIdHeader.length !== 0 ? e.requestIdHeader.toLowerCase() : e.requestIdHeader === !0 && "request-id", r = og(t, e.genReqId), n = e.requestIdLogLabel || "reqId", s = e.bodyLimit || Nt.bodyLimit, i = e.disableRequestLogging || !1, o = Object.assign({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    customOptions: {},
    plugins: []
  }, e.ajv), a = e.frameworkErrors;
  if (!o.customOptions || Object.prototype.toString.call(o.customOptions) !== "[object Object]")
<<<<<<< HEAD
    throw new u6(typeof o.customOptions);
  if (!o.plugins || !Array.isArray(o.plugins))
    throw new f6(typeof o.plugins);
  const { logger: c, hasLogger: u } = XV(e);
  e.connectionTimeout = e.connectionTimeout || mr.connectionTimeout, e.keepAliveTimeout = e.keepAliveTimeout || mr.keepAliveTimeout, e.maxRequestsPerSocket = e.maxRequestsPerSocket || mr.maxRequestsPerSocket, e.requestTimeout = e.requestTimeout || mr.requestTimeout, e.logger = c, e.requestIdHeader = t, e.requestIdLogLabel = n, e.disableRequestLogging = s, e.ajv = o, e.clientErrorHandler = e.clientErrorHandler || P;
  const l = p1(e);
  e.exposeHeadRoutes = l.exposeHeadRoutes;
  const f = ZV({
    config: {
      defaultRoute: D,
      onBadUrl: I,
      constraints: e.constraints,
      ignoreTrailingSlash: e.ignoreTrailingSlash || mr.ignoreTrailingSlash,
      ignoreDuplicateSlashes: e.ignoreDuplicateSlashes || mr.ignoreDuplicateSlashes,
      maxParamLength: e.maxParamLength || mr.maxParamLength,
      caseSensitive: e.caseSensitive,
      allowUnsafeRegex: e.allowUnsafeRegex || mr.allowUnsafeRegex,
      buildPrettyMeta: y6,
      querystringParser: e.querystringParser,
      useSemicolonDelimiter: e.useSemicolonDelimiter ?? mr.useSemicolonDelimiter
    }
  }), m = e6(e), p = W(f, e);
  e.http2SessionTimeout = l.http2SessionTimeout;
  const { server: d, listen: h } = WV(e, p), _ = typeof d.closeAllConnections == "function", g = typeof d.closeIdleConnections == "function";
  let v = e.forceCloseConnections;
  if (v === "idle" && !g)
    throw new o6();
  typeof v != "boolean" && (v = g ? "idle" : !1);
  const y = !_ && v === !0 ? /* @__PURE__ */ new Set() : r6(), E = Do.setupResponseListeners, R = Wb.buildSchemaController(null, e.schemaController), w = {
    // Fastify internals
    [ut]: {
=======
    throw new dM(typeof o.customOptions);
  if (!o.plugins || !Array.isArray(o.plugins))
    throw new pM(typeof o.plugins);
  const { logger: c, hasLogger: f } = Q2(e);
  e.connectionTimeout = e.connectionTimeout || Nt.connectionTimeout, e.keepAliveTimeout = e.keepAliveTimeout || Nt.keepAliveTimeout, e.maxRequestsPerSocket = e.maxRequestsPerSocket || Nt.maxRequestsPerSocket, e.requestTimeout = e.requestTimeout || Nt.requestTimeout, e.logger = c, e.requestIdHeader = t, e.requestIdLogLabel = n, e.disableRequestLogging = i, e.ajv = o, e.clientErrorHandler = e.clientErrorHandler || T;
  const l = Q_(e);
  e.exposeHeadRoutes = l.exposeHeadRoutes;
  const d = eM({
    config: {
      defaultRoute: j,
      onBadUrl: C,
      constraints: e.constraints,
      ignoreTrailingSlash: e.ignoreTrailingSlash || Nt.ignoreTrailingSlash,
      ignoreDuplicateSlashes: e.ignoreDuplicateSlashes || Nt.ignoreDuplicateSlashes,
      maxParamLength: e.maxParamLength || Nt.maxParamLength,
      caseSensitive: e.caseSensitive,
      allowUnsafeRegex: e.allowUnsafeRegex || Nt.allowUnsafeRegex,
      buildPrettyMeta: bM,
      querystringParser: e.querystringParser,
      useSemicolonDelimiter: e.useSemicolonDelimiter ?? Nt.useSemicolonDelimiter
    }
  }), g = rM(e), p = Z(d, e);
  e.http2SessionTimeout = l.http2SessionTimeout;
  const { server: u, listen: h } = J2(e, p), b = typeof u.closeAllConnections == "function", m = typeof u.closeIdleConnections == "function";
  let v = e.forceCloseConnections;
  if (v === "idle" && !m)
    throw new cM();
  typeof v != "boolean" && (v = m ? "idle" : !1);
  const y = !b && v === !0 ? /* @__PURE__ */ new Set() : sM(), _ = Cs.setupResponseListeners, R = tg.buildSchemaController(null, e.schemaController), E = {
    // Fastify internals
    [Ke]: {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      listening: !1,
      closing: !1,
      started: !1,
      ready: !1,
      booting: !1,
      readyPromise: null
    },
<<<<<<< HEAD
    [sp]: y,
    [mi]: {
=======
    [El]: y,
    [Jr]: {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      bodyless: /* @__PURE__ */ new Set([
        // Standard
        "GET",
        "HEAD",
        "TRACE"
      ]),
      bodywith: /* @__PURE__ */ new Set([
        // Standard
        "DELETE",
        "OPTIONS",
        "PATCH",
        "PUT",
        "POST"
      ])
    },
<<<<<<< HEAD
    [np]: e,
    [tp]: [],
    [zb]: [],
    [UV]: i,
    [Vb]: "",
    [MV]: "",
    [HV]: null,
    [rp]: new YV(),
    [kn]: R,
    [ip]: null,
    [Kc]: tE(),
    [op]: JV,
    [Gb]: null,
    [BV]: new gi(
      i,
      e.onProtoPoisoning || mr.onProtoPoisoning,
      e.onConstructorPoisoning || mr.onConstructorPoisoning
    ),
    [zV]: Do.buildReply(Do),
    [VV]: Yc.buildRequest(Yc, e.trustProxy),
    [GV]: m,
    [Jb.kRegisteredPlugins]: [],
    [ko]: ["fastify"],
    [No]: null,
    [ap]: r,
    // routing method
    routing: p,
    // routes shorthand methods
    delete: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "DELETE", url: X, options: J, handler: re });
    },
    get: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "GET", url: X, options: J, handler: re });
    },
    head: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "HEAD", url: X, options: J, handler: re });
    },
    trace: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "TRACE", url: X, options: J, handler: re });
    },
    patch: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "PATCH", url: X, options: J, handler: re });
    },
    post: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "POST", url: X, options: J, handler: re });
    },
    put: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "PUT", url: X, options: J, handler: re });
    },
    options: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "OPTIONS", url: X, options: J, handler: re });
    },
    all: function(X, J, re) {
      return f.prepareRoute.call(this, { method: this.supportedMethods, url: X, options: J, handler: re });
    },
    // extended route
    route: function(X) {
      return f.route.call(this, { options: X });
    },
    hasRoute: function(X) {
      return f.hasRoute.call(this, { options: X });
    },
    findRoute: function(X) {
      return f.findRoute(X);
=======
    [bl]: e,
    [gl]: [],
    [Zy]: [],
    [U2]: s,
    [Qy]: "",
    [q2]: "",
    [H2]: null,
    [vl]: new X2(),
    [Nr]: R,
    [_l]: null,
    [to]: lg(),
    [Sl]: Z2,
    [eg]: null,
    [V2]: new Yr(
      s,
      e.onProtoPoisoning || Nt.onProtoPoisoning,
      e.onConstructorPoisoning || Nt.onConstructorPoisoning
    ),
    [G2]: Cs.buildReply(Cs),
    [W2]: ro.buildRequest(ro, e.trustProxy),
    [K2]: g,
    [sg.kRegisteredPlugins]: [],
    [Os]: ["fastify"],
    [Ts]: null,
    [xl]: r,
    // routing method
    routing: p,
    // routes shorthand methods
    delete: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "DELETE", url: W, options: G, handler: ee });
    },
    get: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "GET", url: W, options: G, handler: ee });
    },
    head: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "HEAD", url: W, options: G, handler: ee });
    },
    trace: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "TRACE", url: W, options: G, handler: ee });
    },
    patch: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "PATCH", url: W, options: G, handler: ee });
    },
    post: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "POST", url: W, options: G, handler: ee });
    },
    put: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "PUT", url: W, options: G, handler: ee });
    },
    options: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: "OPTIONS", url: W, options: G, handler: ee });
    },
    all: function(W, G, ee) {
      return d.prepareRoute.call(this, { method: this.supportedMethods, url: W, options: G, handler: ee });
    },
    // extended route
    route: function(W) {
      return d.route.call(this, { options: W });
    },
    hasRoute: function(W) {
      return d.hasRoute.call(this, { options: W });
    },
    findRoute: function(W) {
      return d.findRoute(W);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    // expose logger instance
    log: c,
    // type provider
    withTypeProvider: $,
    // hooks
    addHook: x,
    // schemas
<<<<<<< HEAD
    addSchema: A,
    getSchema: R.getSchema.bind(R),
    getSchemas: R.getSchemas.bind(R),
    setValidatorCompiler: k,
    setSerializerCompiler: M,
    setSchemaController: T,
    setReplySerializer: N,
    setSchemaErrorFormatter: U,
    // set generated request id
    setGenReqId: z,
    // custom parsers
    addContentTypeParser: gi.helpers.addContentTypeParser,
    hasContentTypeParser: gi.helpers.hasContentTypeParser,
    getDefaultJsonParser: gi.defaultParsers.getDefaultJsonParser,
    defaultTextParser: gi.defaultParsers.defaultTextParser,
    removeContentTypeParser: gi.helpers.removeContentTypeParser,
    removeAllContentTypeParsers: gi.helpers.removeAllContentTypeParsers,
=======
    addSchema: I,
    getSchema: R.getSchema.bind(R),
    getSchemas: R.getSchemas.bind(R),
    setValidatorCompiler: P,
    setSerializerCompiler: F,
    setSchemaController: w,
    setReplySerializer: N,
    setSchemaErrorFormatter: D,
    // set generated request id
    setGenReqId: Y,
    // custom parsers
    addContentTypeParser: Yr.helpers.addContentTypeParser,
    hasContentTypeParser: Yr.helpers.hasContentTypeParser,
    getDefaultJsonParser: Yr.defaultParsers.getDefaultJsonParser,
    defaultTextParser: Yr.defaultParsers.defaultTextParser,
    removeContentTypeParser: Yr.helpers.removeContentTypeParser,
    removeAllContentTypeParsers: Yr.helpers.removeAllContentTypeParsers,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    // Fastify architecture methods (initialized by Avvio)
    register: null,
    after: null,
    ready: null,
    onClose: null,
    close: null,
    printPlugins: null,
<<<<<<< HEAD
    hasPlugin: function(K) {
      return this[Jb.kRegisteredPlugins].includes(K) || this[ko].includes(K);
    },
    // http server
    listen: h,
    server: d,
    addresses: function() {
      const K = this[zb].map((X) => X.address());
      return K.push(this.server.address()), K.filter((X) => X);
    },
    // extend fastify objects
    decorate: ls.add,
    hasDecorator: ls.exist,
    decorateReply: ls.decorateReply,
    decorateRequest: ls.decorateRequest,
    hasRequestDecorator: ls.existRequest,
    hasReplyDecorator: ls.existReply,
    addHttpMethod: Q,
    // fake http injection
    inject: H,
    // pretty print of the registered routes
    printRoutes: S,
    // custom error handling
    setNotFoundHandler: j,
    setErrorHandler: G,
    // child logger
    setChildLoggerFactory: O,
    // Set fastify initial configuration options read-only object
    initialConfig: l,
    // constraint strategies
    addConstraintStrategy: f.addConstraintStrategy.bind(f),
    hasConstraintStrategy: f.hasConstraintStrategy.bind(f)
  };
  Object.defineProperties(w, {
    listeningOrigin: {
      get() {
        const K = this.addresses().slice(-1).pop();
        if (typeof K == "string")
          return K;
        const X = K.family === "IPv6" ? `[${K.address}]` : K.address;
        return `${this[np].https ? "https" : "http"}://${X}:${K.port}`;
=======
    hasPlugin: function(H) {
      return this[sg.kRegisteredPlugins].includes(H) || this[Os].includes(H);
    },
    // http server
    listen: h,
    server: u,
    addresses: function() {
      const H = this[Zy].map((W) => W.address());
      return H.push(this.server.address()), H.filter((W) => W);
    },
    // extend fastify objects
    decorate: Nn.add,
    hasDecorator: Nn.exist,
    decorateReply: Nn.decorateReply,
    decorateRequest: Nn.decorateRequest,
    hasRequestDecorator: Nn.existRequest,
    hasReplyDecorator: Nn.existReply,
    addHttpMethod: J,
    // fake http injection
    inject: M,
    // pretty print of the registered routes
    printRoutes: V,
    // custom error handling
    setNotFoundHandler: k,
    setErrorHandler: q,
    // child logger
    setChildLoggerFactory: K,
    // Set fastify initial configuration options read-only object
    initialConfig: l,
    // constraint strategies
    addConstraintStrategy: d.addConstraintStrategy.bind(d),
    hasConstraintStrategy: d.hasConstraintStrategy.bind(d)
  };
  Object.defineProperties(E, {
    listeningOrigin: {
      get() {
        const H = this.addresses().slice(-1).pop();
        if (typeof H == "string")
          return H;
        const W = H.family === "IPv6" ? `[${H.address}]` : H.address;
        return `${this[bl].https ? "https" : "http"}://${W}:${H.port}`;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    pluginName: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[ko].length > 1 ? this[ko].join(" -> ") : this[ko][0];
=======
        return this[Os].length > 1 ? this[Os].join(" -> ") : this[Os][0];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    prefix: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[Vb];
=======
        return this[Qy];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    validatorCompiler: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[kn].getValidatorCompiler();
=======
        return this[Nr].getValidatorCompiler();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    serializerCompiler: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[kn].getSerializerCompiler();
=======
        return this[Nr].getSerializerCompiler();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    childLoggerFactory: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[op];
=======
        return this[Sl];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    version: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return LV;
=======
        return F2;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    errorHandler: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[Kc].func;
=======
        return this[to].func;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    genReqId: {
      configurable: !0,
      get() {
<<<<<<< HEAD
        return this[ap];
=======
        return this[xl];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    },
    supportedMethods: {
      configurable: !1,
      get() {
        return [
<<<<<<< HEAD
          ...this[mi].bodyless,
          ...this[mi].bodywith
        ];
      }
    }
  }), e.schemaErrorFormatter && (nE(e.schemaErrorFormatter), w[ip] = e.schemaErrorFormatter.bind(w));
  const C = Number(e.pluginTimeout), V = FV(w, {
    autostart: !1,
    timeout: isNaN(C) === !1 ? C : mr.pluginTimeout,
=======
          ...this[Jr].bodyless,
          ...this[Jr].bodywith
        ];
      }
    }
  }), e.schemaErrorFormatter && (fg(e.schemaErrorFormatter), E[_l] = e.schemaErrorFormatter.bind(E));
  const O = Number(e.pluginTimeout), z = M2(E, {
    autostart: !1,
    timeout: isNaN(O) === !1 ? O : Nt.pluginTimeout,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    expose: {
      use: "register"
    }
  });
<<<<<<< HEAD
  V.override = t6, V.on("start", () => w[ut].started = !0), w[No] = w.ready, w.ready = q, w.printPlugins = V.prettyPrint.bind(V), V.once("preReady", () => {
    w.onClose((K, X) => {
      w[ut].closing = !0, f.closeRoutes(), Kb("preClose", w[No], w, function() {
        if (w[ut].listening) {
          if (v === "idle")
            K.server.closeIdleConnections();
          else if (_ && v)
            K.server.closeAllConnections();
          else if (v === !0)
            for (const J of w[sp])
              J.destroy(), w[sp].delete(J);
        }
        !e.serverFactory || w[ut].listening ? K.server.close(function(J) {
          J && J.code !== "ERR_SERVER_NOT_RUNNING" ? X(null) : X();
        }) : process.nextTick(X, null);
      });
    });
  });
  const b = new KV({
    server: w,
    config: {}
  });
  return w.setNotFoundHandler(), m.arrange404(w), f.setup(e, {
    avvio: V,
    fourOhFour: m,
    logger: c,
    hasLogger: u,
    setupResponseListeners: E,
    throwIfAlreadyStarted: F,
    keepAliveConnections: y
  }), d.on("clientError", e.clientErrorHandler.bind(w)), rE.hasSubscribers && rE.publish({ fastify: w }), "asyncDispose" in Symbol && (w[Symbol.asyncDispose] = function() {
    return w.close();
  }), w;
  function F(K) {
    if (w[ut].started) throw new d6(K);
  }
  function H(K, X) {
    if (Io === void 0 && (Io = DV()), w[ut].started) {
      if (w[ut].closing) {
        const J = new p6();
        if (X) {
          X(J);
          return;
        } else
          return Promise.reject(J);
      }
      return Io(p, K, X);
    }
    if (X)
      this.ready((J) => {
        J ? X(J, null) : Io(p, K, X);
      });
    else
      return Io((J, re) => {
        this.ready(function(fe) {
          if (fe) {
            re.emit("error", fe);
            return;
          }
          p(J, re);
        });
      }, K);
  }
  function q(K) {
    if (this[ut].readyPromise !== null) {
      if (K != null) {
        this[ut].readyPromise.then(() => K(null, w), K);
        return;
      }
      return this[ut].readyPromise;
    }
    let X, J;
    if (process.nextTick(re), this[ut].readyPromise = new Promise(function(ee, le) {
      X = ee, J = le;
    }), K)
      this[ut].readyPromise.then(() => K(null, w), K);
    else
      return this[ut].readyPromise;
    function re() {
      w[No]((ee, le) => {
        ee || w[ut].started || w[ut].ready || w[ut].booting ? fe(ee) : (w[ut].booting = !0, Kb("onReady", w[No], w, fe)), le();
      });
    }
    function fe(ee) {
      if (ee = ee != null && Qb[ee.code] != null ? n6(ee, new Qb[ee.code](ee.message)) : ee, ee)
        return J(ee);
      X(w), w[ut].booting = !1, w[ut].ready = !0, w[ut].promise = null;
=======
  z.override = nM, z.on("start", () => E[Ke].started = !0), E[Ts] = E.ready, E.ready = U, E.printPlugins = z.prettyPrint.bind(z), z.once("preReady", () => {
    E.onClose((H, W) => {
      E[Ke].closing = !0, d.closeRoutes(), rg("preClose", E[Ts], E, function() {
        if (E[Ke].listening) {
          if (v === "idle")
            H.server.closeIdleConnections();
          else if (b && v)
            H.server.closeAllConnections();
          else if (v === !0)
            for (const G of E[El])
              G.destroy(), E[El].delete(G);
        }
        !e.serverFactory || E[Ke].listening ? H.server.close(function(G) {
          G && G.code !== "ERR_SERVER_NOT_RUNNING" ? W(null) : W();
        }) : process.nextTick(W, null);
      });
    });
  });
  const S = new Y2({
    server: E,
    config: {}
  });
  return E.setNotFoundHandler(), g.arrange404(E), d.setup(e, {
    avvio: z,
    fourOhFour: g,
    logger: c,
    hasLogger: f,
    setupResponseListeners: _,
    throwIfAlreadyStarted: L,
    keepAliveConnections: y
  }), u.on("clientError", e.clientErrorHandler.bind(E)), ug.hasSubscribers && ug.publish({ fastify: E }), "asyncDispose" in Symbol && (E[Symbol.asyncDispose] = function() {
    return E.close();
  }), E;
  function L(H) {
    if (E[Ke].started) throw new hM(H);
  }
  function M(H, W) {
    if ($s === void 0 && ($s = D2()), E[Ke].started) {
      if (E[Ke].closing) {
        const G = new mM();
        if (W) {
          W(G);
          return;
        } else
          return Promise.reject(G);
      }
      return $s(p, H, W);
    }
    if (W)
      this.ready((G) => {
        G ? W(G, null) : $s(p, H, W);
      });
    else
      return $s((G, ee) => {
        this.ready(function(le) {
          if (le) {
            ee.emit("error", le);
            return;
          }
          p(G, ee);
        });
      }, H);
  }
  function U(H) {
    if (this[Ke].readyPromise !== null) {
      if (H != null) {
        this[Ke].readyPromise.then(() => H(null, E), H);
        return;
      }
      return this[Ke].readyPromise;
    }
    let W, G;
    if (process.nextTick(ee), this[Ke].readyPromise = new Promise(function(X, ce) {
      W = X, G = ce;
    }), H)
      this[Ke].readyPromise.then(() => H(null, E), H);
    else
      return this[Ke].readyPromise;
    function ee() {
      E[Ts]((X, ce) => {
        X || E[Ke].started || E[Ke].ready || E[Ke].booting ? le(X) : (E[Ke].booting = !0, rg("onReady", E[Ts], E, le)), ce();
      });
    }
    function le(X) {
      if (X = X != null && ag[X.code] != null ? iM(X, new ag[X.code](X.message)) : X, X)
        return G(X);
      W(E), E[Ke].booting = !1, E[Ke].ready = !0, E[Ke].promise = null;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  }
  function $() {
    return this;
  }
<<<<<<< HEAD
  function x(K, X) {
    if (F('Cannot call "addHook"!'), X == null)
      throw new Ti.FST_ERR_HOOK_INVALID_HANDLER(K, X);
    if (K === "onSend" || K === "preSerialization" || K === "onError" || K === "preParsing") {
      if (X.constructor.name === "AsyncFunction" && X.length === 4)
        throw new Ti.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (K === "onReady" || K === "onListen") {
      if (X.constructor.name === "AsyncFunction" && X.length !== 0)
        throw new Ti.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (K === "onRequestAbort") {
      if (X.constructor.name === "AsyncFunction" && X.length !== 1)
        throw new Ti.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (X.constructor.name === "AsyncFunction" && X.length === 3)
      throw new Ti.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    return K === "onClose" ? this.onClose(X.bind(this)) : K === "onReady" || K === "onListen" || K === "onRoute" ? this[rp].add(K, X) : this.after((re, fe) => {
      J.call(this, K, X), fe(re);
    }), this;
    function J(re, fe) {
      this[rp].add(re, fe), this[tp].forEach((ee) => J.call(ee, re, fe));
    }
  }
  function A(K) {
    return F('Cannot call "addSchema"!'), this[kn].add(K), this[tp].forEach((X) => X.addSchema(K)), this;
  }
  function P(K, X) {
    if (K.code === "ECONNRESET" || X.destroyed)
      return;
    let J, re, fe, ee;
    K.code === "ERR_HTTP_REQUEST_TIMEOUT" ? (re = "408", fe = Wc.STATUS_CODES[re], J = `{"error":"${fe}","message":"Client Timeout","statusCode":408}`, ee = "timeout") : K.code === "HPE_HEADER_OVERFLOW" ? (re = "431", fe = Wc.STATUS_CODES[re], J = `{"error":"${fe}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`, ee = "header_overflow") : (re = "400", fe = Wc.STATUS_CODES[re], J = `{"error":"${fe}","message":"Client Error","statusCode":400}`, ee = "error"), this.log.trace({ err: K }, `client ${ee}`), X.writable && X.write(`HTTP/1.1 ${re} ${fe}\r
Content-Length: ${J.length}\r
Content-Type: application/json\r
\r
${J}`), X.destroy(K);
  }
  function D(K, X) {
    K.headers["accept-version"] !== void 0 && (K.headers[qV] = K.headers["accept-version"], K.headers["accept-version"] = void 0), m.router.lookup(K, X);
  }
  function I(K, X, J) {
    if (a) {
      const fe = Xb(b.server, X), ee = Yb(b, c, X, fe), le = new Yc(fe, null, X, null, ee, b), Se = new Do(J, le, ee);
      return s === !1 && ee.info({ req: le }, "incoming request"), a(new s6(K), le, Se);
    }
    const re = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${K}' is not a valid url component","statusCode":400}`;
    J.writeHead(400, {
      "Content-Type": "application/json",
      "Content-Length": re.length
    }), J.end(re);
  }
  function L(K, X, J) {
    if (K !== !1)
      return function(fe) {
        if (fe) {
          if (a) {
            const le = Xb(b.server, X), Se = Yb(b, c, X, le), ye = new Yc(le, null, X, null, Se, b), ve = new Do(J, ye, Se);
            return s === !1 && Se.info({ req: ye }, "incoming request"), a(new i6(), ye, ve);
          }
          const ee = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          J.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": ee.length
          }), J.end(ee);
        }
      };
  }
  function j(K, X) {
    return F('Cannot call "setNotFoundHandler"!'), m.setNotFoundHandler.call(this, K, X, V, f.routeHandler), this;
  }
  function k(K) {
    return F('Cannot call "setValidatorCompiler"!'), this[kn].setValidatorCompiler(K), this;
  }
  function U(K) {
    return F('Cannot call "setSchemaErrorFormatter"!'), nE(K), this[ip] = K.bind(this), this;
  }
  function M(K) {
    return F('Cannot call "setSerializerCompiler"!'), this[kn].setSerializerCompiler(K), this;
  }
  function T(K) {
    F('Cannot call "setSchemaController"!');
    const X = this[kn], J = Wb.buildSchemaController(X, Object.assign({}, X.opts, K));
    return this[kn] = J, this.getSchema = J.getSchema.bind(J), this.getSchemas = J.getSchemas.bind(J), this;
  }
  function N(K) {
    return F('Cannot call "setReplySerializer"!'), this[Gb] = K, this;
  }
  function G(K) {
    if (F('Cannot call "setErrorHandler"!'), typeof K != "function")
      throw new m6();
    return this[Kc] = tE(this[Kc], K.bind(this)), this;
  }
  function O(K) {
    return F('Cannot call "setChildLoggerFactory"!'), this[op] = K, this;
  }
  function S(K = {}) {
    return K.includeMeta = K.includeHooks ? K.includeMeta ? Nh.concat(K.includeMeta) : Nh : K.includeMeta, f.printRoutes(K);
  }
  function W(K, { rewriteUrl: X, logger: J }) {
    let re;
    return function(ee, le) {
      if (re === void 0 && (re = K.isAsyncConstraint()), X) {
        ee.originalUrl = ee.url;
        const Se = X.call(w, ee);
        if (typeof Se == "string")
          ee.url = Se;
        else {
          const ye = new h6(ee.url, typeof Se);
          ee.destroy(ye);
        }
      }
      K.routing(ee, le, L(re, ee, le));
    };
  }
  function z(K) {
    return F('Cannot call "setGenReqId"!'), this[ap] = Zb(this[np].requestIdHeader, K), this;
  }
  function Q(K, { hasBody: X = !1 } = {}) {
    if (typeof K != "string" || Wc.METHODS.indexOf(K) === -1)
      throw new g6();
    X === !0 ? (this[mi].bodywith.add(K), this[mi].bodyless.delete(K)) : (this[mi].bodywith.delete(K), this[mi].bodyless.add(K));
    const J = K.toLowerCase();
    return this.hasDecorator(J) || this.decorate(J, function(re, fe, ee) {
      return f.prepareRoute.call(this, { method: K, url: re, options: fe, handler: ee });
    }), this;
  }
}
function nE(e) {
  if (typeof e != "function")
    throw new eE(typeof e);
  if (e.constructor.name === "AsyncFunction")
    throw new eE("AsyncFunction");
}
La.exports = hy;
La.exports.errorCodes = Ti;
La.exports.fastify = hy;
La.exports.default = hy;
var v6 = La.exports;
const _6 = /* @__PURE__ */ Da(v6);
function h1(e, t) {
=======
  function x(H, W) {
    if (L('Cannot call "addHook"!'), W == null)
      throw new sn.FST_ERR_HOOK_INVALID_HANDLER(H, W);
    if (H === "onSend" || H === "preSerialization" || H === "onError" || H === "preParsing") {
      if (W.constructor.name === "AsyncFunction" && W.length === 4)
        throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (H === "onReady" || H === "onListen") {
      if (W.constructor.name === "AsyncFunction" && W.length !== 0)
        throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (H === "onRequestAbort") {
      if (W.constructor.name === "AsyncFunction" && W.length !== 1)
        throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (W.constructor.name === "AsyncFunction" && W.length === 3)
      throw new sn.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    return H === "onClose" ? this.onClose(W.bind(this)) : H === "onReady" || H === "onListen" || H === "onRoute" ? this[vl].add(H, W) : this.after((ee, le) => {
      G.call(this, H, W), le(ee);
    }), this;
    function G(ee, le) {
      this[vl].add(ee, le), this[gl].forEach((X) => G.call(X, ee, le));
    }
  }
  function I(H) {
    return L('Cannot call "addSchema"!'), this[Nr].add(H), this[gl].forEach((W) => W.addSchema(H)), this;
  }
  function T(H, W) {
    if (H.code === "ECONNRESET" || W.destroyed)
      return;
    let G, ee, le, X;
    H.code === "ERR_HTTP_REQUEST_TIMEOUT" ? (ee = "408", le = eo.STATUS_CODES[ee], G = `{"error":"${le}","message":"Client Timeout","statusCode":408}`, X = "timeout") : H.code === "HPE_HEADER_OVERFLOW" ? (ee = "431", le = eo.STATUS_CODES[ee], G = `{"error":"${le}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`, X = "header_overflow") : (ee = "400", le = eo.STATUS_CODES[ee], G = `{"error":"${le}","message":"Client Error","statusCode":400}`, X = "error"), this.log.trace({ err: H }, `client ${X}`), W.writable && W.write(`HTTP/1.1 ${ee} ${le}\r
Content-Length: ${G.length}\r
Content-Type: application/json\r
\r
${G}`), W.destroy(H);
  }
  function j(H, W) {
    H.headers["accept-version"] !== void 0 && (H.headers[B2] = H.headers["accept-version"], H.headers["accept-version"] = void 0), g.router.lookup(H, W);
  }
  function C(H, W, G) {
    if (a) {
      const le = ig(S.server, W), X = ng(S, c, W, le), ce = new ro(le, null, W, null, X, S), Ee = new Cs(G, ce, X);
      return i === !1 && X.info({ req: ce }, "incoming request"), a(new aM(H), ce, Ee);
    }
    const ee = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${H}' is not a valid url component","statusCode":400}`;
    G.writeHead(400, {
      "Content-Type": "application/json",
      "Content-Length": ee.length
    }), G.end(ee);
  }
  function A(H, W, G) {
    if (H !== !1)
      return function(le) {
        if (le) {
          if (a) {
            const ce = ig(S.server, W), Ee = ng(S, c, W, ce), pe = new ro(ce, null, W, null, Ee, S), me = new Cs(G, pe, Ee);
            return i === !1 && Ee.info({ req: pe }, "incoming request"), a(new oM(), pe, me);
          }
          const X = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          G.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": X.length
          }), G.end(X);
        }
      };
  }
  function k(H, W) {
    return L('Cannot call "setNotFoundHandler"!'), g.setNotFoundHandler.call(this, H, W, z, d.routeHandler), this;
  }
  function P(H) {
    return L('Cannot call "setValidatorCompiler"!'), this[Nr].setValidatorCompiler(H), this;
  }
  function D(H) {
    return L('Cannot call "setSchemaErrorFormatter"!'), fg(H), this[_l] = H.bind(this), this;
  }
  function F(H) {
    return L('Cannot call "setSerializerCompiler"!'), this[Nr].setSerializerCompiler(H), this;
  }
  function w(H) {
    L('Cannot call "setSchemaController"!');
    const W = this[Nr], G = tg.buildSchemaController(W, Object.assign({}, W.opts, H));
    return this[Nr] = G, this.getSchema = G.getSchema.bind(G), this.getSchemas = G.getSchemas.bind(G), this;
  }
  function N(H) {
    return L('Cannot call "setReplySerializer"!'), this[eg] = H, this;
  }
  function q(H) {
    if (L('Cannot call "setErrorHandler"!'), typeof H != "function")
      throw new gM();
    return this[to] = lg(this[to], H.bind(this)), this;
  }
  function K(H) {
    return L('Cannot call "setChildLoggerFactory"!'), this[Sl] = H, this;
  }
  function V(H = {}) {
    return H.includeMeta = H.includeHooks ? H.includeMeta ? Ou.concat(H.includeMeta) : Ou : H.includeMeta, d.printRoutes(H);
  }
  function Z(H, { rewriteUrl: W, logger: G }) {
    let ee;
    return function(X, ce) {
      if (ee === void 0 && (ee = H.isAsyncConstraint()), W) {
        X.originalUrl = X.url;
        const Ee = W.call(E, X);
        if (typeof Ee == "string")
          X.url = Ee;
        else {
          const pe = new yM(X.url, typeof Ee);
          X.destroy(pe);
        }
      }
      H.routing(X, ce, A(ee, X, ce));
    };
  }
  function Y(H) {
    return L('Cannot call "setGenReqId"!'), this[xl] = og(this[bl].requestIdHeader, H), this;
  }
  function J(H, { hasBody: W = !1 } = {}) {
    if (typeof H != "string" || eo.METHODS.indexOf(H) === -1)
      throw new vM();
    W === !0 ? (this[Jr].bodywith.add(H), this[Jr].bodyless.delete(H)) : (this[Jr].bodywith.delete(H), this[Jr].bodyless.add(H));
    const G = H.toLowerCase();
    return this.hasDecorator(G) || this.decorate(G, function(ee, le, X) {
      return d.prepareRoute.call(this, { method: H, url: ee, options: le, handler: X });
    }), this;
  }
}
function fg(e) {
  if (typeof e != "function")
    throw new cg(typeof e);
  if (e.constructor.name === "AsyncFunction")
    throw new cg("AsyncFunction");
}
ii.exports = Yd;
ii.exports.errorCodes = sn;
ii.exports.fastify = Yd;
ii.exports.default = Yd;
var _M = ii.exports;
const EM = /* @__PURE__ */ si(_M);
function eE(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return function() {
    return e.apply(t, arguments);
  };
}
<<<<<<< HEAD
const { toString: b6 } = Object.prototype, { getPrototypeOf: my } = Object, sf = /* @__PURE__ */ ((e) => (t) => {
  const r = b6.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), zr = (e) => (e = e.toLowerCase(), (t) => sf(t) === e), of = (e) => (t) => typeof t === e, { isArray: co } = Array, ua = of("undefined");
function E6(e) {
  return e !== null && !ua(e) && e.constructor !== null && !ua(e.constructor) && vr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const m1 = zr("ArrayBuffer");
function w6(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && m1(e.buffer), t;
}
const S6 = of("string"), vr = of("function"), g1 = of("number"), af = (e) => e !== null && typeof e == "object", x6 = (e) => e === !0 || e === !1, Sl = (e) => {
  if (sf(e) !== "object")
    return !1;
  const t = my(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, R6 = zr("Date"), $6 = zr("File"), T6 = zr("Blob"), O6 = zr("FileList"), P6 = (e) => af(e) && vr(e.pipe), C6 = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || vr(e.append) && ((t = sf(e)) === "formdata" || // detect form-data instance
  t === "object" && vr(e.toString) && e.toString() === "[object FormData]"));
}, A6 = zr("URLSearchParams"), [I6, N6, k6, D6] = ["ReadableStream", "Request", "Response", "Headers"].map(zr), L6 = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ja(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, i;
  if (typeof e != "object" && (e = [e]), co(e))
    for (n = 0, i = e.length; n < i; n++)
      t.call(null, e[n], n, e);
  else {
    const s = r ? Object.getOwnPropertyNames(e) : Object.keys(e), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], t.call(null, e[a], a, e);
  }
}
function y1(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], t === i.toLowerCase())
      return i;
  return null;
}
const Ci = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, v1 = (e) => !ua(e) && e !== Ci;
function kh() {
  const { caseless: e } = v1(this) && this || {}, t = {}, r = (n, i) => {
    const s = e && y1(t, i) || i;
    Sl(t[s]) && Sl(n) ? t[s] = kh(t[s], n) : Sl(n) ? t[s] = kh({}, n) : co(n) ? t[s] = n.slice() : t[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && Ja(arguments[n], r);
  return t;
}
const F6 = (e, t, r, { allOwnKeys: n } = {}) => (Ja(t, (i, s) => {
  r && vr(i) ? e[s] = h1(i, r) : e[s] = i;
}, { allOwnKeys: n }), e), j6 = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), U6 = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, M6 = (e, t, r, n) => {
  let i, s, o;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = r !== !1 && my(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, H6 = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, q6 = (e) => {
  if (!e) return null;
  if (co(e)) return e;
  let t = e.length;
  if (!g1(t)) return null;
=======
const { toString: SM } = Object.prototype, { getPrototypeOf: Xd } = Object, Ma = /* @__PURE__ */ ((e) => (t) => {
  const r = SM.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Qt = (e) => (e = e.toLowerCase(), (t) => Ma(t) === e), za = (e) => (t) => typeof t === e, { isArray: ds } = Array, Ks = za("undefined");
function xM(e) {
  return e !== null && !Ks(e) && e.constructor !== null && !Ks(e.constructor) && Lt(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const tE = Qt("ArrayBuffer");
function wM(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && tE(e.buffer), t;
}
const RM = za("string"), Lt = za("function"), rE = za("number"), Ua = (e) => e !== null && typeof e == "object", $M = (e) => e === !0 || e === !1, wo = (e) => {
  if (Ma(e) !== "object")
    return !1;
  const t = Xd(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, TM = Qt("Date"), OM = Qt("File"), CM = Qt("Blob"), PM = Qt("FileList"), IM = (e) => Ua(e) && Lt(e.pipe), NM = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Lt(e.append) && ((t = Ma(e)) === "formdata" || // detect form-data instance
  t === "object" && Lt(e.toString) && e.toString() === "[object FormData]"));
}, AM = Qt("URLSearchParams"), [kM, LM, jM, DM] = ["ReadableStream", "Request", "Response", "Headers"].map(Qt), FM = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function bi(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, s;
  if (typeof e != "object" && (e = [e]), ds(e))
    for (n = 0, s = e.length; n < s; n++)
      t.call(null, e[n], n, e);
  else {
    const i = r ? Object.getOwnPropertyNames(e) : Object.keys(e), o = i.length;
    let a;
    for (n = 0; n < o; n++)
      a = i[n], t.call(null, e[a], a, e);
  }
}
function nE(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, s;
  for (; n-- > 0; )
    if (s = r[n], t === s.toLowerCase())
      return s;
  return null;
}
const an = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, sE = (e) => !Ks(e) && e !== an;
function Cu() {
  const { caseless: e } = sE(this) && this || {}, t = {}, r = (n, s) => {
    const i = e && nE(t, s) || s;
    wo(t[i]) && wo(n) ? t[i] = Cu(t[i], n) : wo(n) ? t[i] = Cu({}, n) : ds(n) ? t[i] = n.slice() : t[i] = n;
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && bi(arguments[n], r);
  return t;
}
const MM = (e, t, r, { allOwnKeys: n } = {}) => (bi(t, (s, i) => {
  r && Lt(s) ? e[i] = eE(s, r) : e[i] = s;
}, { allOwnKeys: n }), e), zM = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), UM = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, qM = (e, t, r, n) => {
  let s, i, o;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (s = Object.getOwnPropertyNames(e), i = s.length; i-- > 0; )
      o = s[i], (!n || n(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = r !== !1 && Xd(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, HM = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, BM = (e) => {
  if (!e) return null;
  if (ds(e)) return e;
  let t = e.length;
  if (!rE(t)) return null;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
<<<<<<< HEAD
}, B6 = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && my(Uint8Array)), z6 = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, V6 = (e, t) => {
=======
}, VM = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Xd(Uint8Array)), GM = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const i = s.value;
    t.call(e, i[0], i[1]);
  }
}, WM = (e, t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
<<<<<<< HEAD
}, G6 = zr("HTMLFormElement"), W6 = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), iE = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), K6 = zr("RegExp"), _1 = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  Ja(r, (i, s) => {
    let o;
    (o = t(i, s, e)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(e, n);
}, Y6 = (e) => {
  _1(e, (t, r) => {
    if (vr(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (vr(n)) {
=======
}, KM = Qt("HTMLFormElement"), JM = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, s) {
    return n.toUpperCase() + s;
  }
), dg = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), YM = Qt("RegExp"), iE = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  bi(r, (s, i) => {
    let o;
    (o = t(s, i, e)) !== !1 && (n[i] = o || s);
  }), Object.defineProperties(e, n);
}, XM = (e) => {
  iE(e, (t, r) => {
    if (Lt(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (Lt(n)) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
<<<<<<< HEAD
}, J6 = (e, t) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return co(e) ? n(e) : n(String(e).split(t)), r;
}, X6 = () => {
}, Z6 = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function Q6(e) {
  return !!(e && vr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const e9 = (e) => {
  const t = new Array(10), r = (n, i) => {
    if (af(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[i] = n;
        const s = co(n) ? [] : {};
        return Ja(n, (o, a) => {
          const c = r(o, i + 1);
          !ua(c) && (s[a] = c);
        }), t[i] = void 0, s;
=======
}, ZM = (e, t) => {
  const r = {}, n = (s) => {
    s.forEach((i) => {
      r[i] = !0;
    });
  };
  return ds(e) ? n(e) : n(String(e).split(t)), r;
}, QM = () => {
}, ez = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function tz(e) {
  return !!(e && Lt(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const rz = (e) => {
  const t = new Array(10), r = (n, s) => {
    if (Ua(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[s] = n;
        const i = ds(n) ? [] : {};
        return bi(n, (o, a) => {
          const c = r(o, s + 1);
          !Ks(c) && (i[a] = c);
        }), t[s] = void 0, i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
    return n;
  };
  return r(e, 0);
<<<<<<< HEAD
}, t9 = zr("AsyncFunction"), r9 = (e) => e && (af(e) || vr(e)) && vr(e.then) && vr(e.catch), b1 = ((e, t) => e ? setImmediate : t ? ((r, n) => (Ci.addEventListener("message", ({ source: i, data: s }) => {
  i === Ci && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), Ci.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  vr(Ci.postMessage)
), n9 = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ci) : typeof process < "u" && process.nextTick || b1, Z = {
  isArray: co,
  isArrayBuffer: m1,
  isBuffer: E6,
  isFormData: C6,
  isArrayBufferView: w6,
  isString: S6,
  isNumber: g1,
  isBoolean: x6,
  isObject: af,
  isPlainObject: Sl,
  isReadableStream: I6,
  isRequest: N6,
  isResponse: k6,
  isHeaders: D6,
  isUndefined: ua,
  isDate: R6,
  isFile: $6,
  isBlob: T6,
  isRegExp: K6,
  isFunction: vr,
  isStream: P6,
  isURLSearchParams: A6,
  isTypedArray: B6,
  isFileList: O6,
  forEach: Ja,
  merge: kh,
  extend: F6,
  trim: L6,
  stripBOM: j6,
  inherits: U6,
  toFlatObject: M6,
  kindOf: sf,
  kindOfTest: zr,
  endsWith: H6,
  toArray: q6,
  forEachEntry: z6,
  matchAll: V6,
  isHTMLForm: G6,
  hasOwnProperty: iE,
  hasOwnProp: iE,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: _1,
  freezeMethods: Y6,
  toObjectSet: J6,
  toCamelCase: W6,
  noop: X6,
  toFiniteNumber: Z6,
  findKey: y1,
  global: Ci,
  isContextDefined: v1,
  isSpecCompliantForm: Q6,
  toJSONObject: e9,
  isAsyncFn: t9,
  isThenable: r9,
  setImmediate: b1,
  asap: n9
};
function ae(e, t, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Z.inherits(ae, Error, {
=======
}, nz = Qt("AsyncFunction"), sz = (e) => e && (Ua(e) || Lt(e)) && Lt(e.then) && Lt(e.catch), oE = ((e, t) => e ? setImmediate : t ? ((r, n) => (an.addEventListener("message", ({ source: s, data: i }) => {
  s === an && i === r && n.length && n.shift()();
}, !1), (s) => {
  n.push(s), an.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Lt(an.postMessage)
), iz = typeof queueMicrotask < "u" ? queueMicrotask.bind(an) : typeof process < "u" && process.nextTick || oE, B = {
  isArray: ds,
  isArrayBuffer: tE,
  isBuffer: xM,
  isFormData: NM,
  isArrayBufferView: wM,
  isString: RM,
  isNumber: rE,
  isBoolean: $M,
  isObject: Ua,
  isPlainObject: wo,
  isReadableStream: kM,
  isRequest: LM,
  isResponse: jM,
  isHeaders: DM,
  isUndefined: Ks,
  isDate: TM,
  isFile: OM,
  isBlob: CM,
  isRegExp: YM,
  isFunction: Lt,
  isStream: IM,
  isURLSearchParams: AM,
  isTypedArray: VM,
  isFileList: PM,
  forEach: bi,
  merge: Cu,
  extend: MM,
  trim: FM,
  stripBOM: zM,
  inherits: UM,
  toFlatObject: qM,
  kindOf: Ma,
  kindOfTest: Qt,
  endsWith: HM,
  toArray: BM,
  forEachEntry: GM,
  matchAll: WM,
  isHTMLForm: KM,
  hasOwnProperty: dg,
  hasOwnProp: dg,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: iE,
  freezeMethods: XM,
  toObjectSet: ZM,
  toCamelCase: JM,
  noop: QM,
  toFiniteNumber: ez,
  findKey: nE,
  global: an,
  isContextDefined: sE,
  isSpecCompliantForm: tz,
  toJSONObject: rz,
  isAsyncFn: nz,
  isThenable: sz,
  setImmediate: oE,
  asap: iz
};
function se(e, t, r, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), s && (this.response = s, this.status = s.status ? s.status : null);
}
B.inherits(se, Error, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
<<<<<<< HEAD
      config: Z.toJSONObject(this.config),
=======
      config: B.toJSONObject(this.config),
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      code: this.code,
      status: this.status
    };
  }
});
<<<<<<< HEAD
const E1 = ae.prototype, w1 = {};
=======
const aE = se.prototype, cE = {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
<<<<<<< HEAD
  w1[e] = { value: e };
});
Object.defineProperties(ae, w1);
Object.defineProperty(E1, "isAxiosError", { value: !0 });
ae.from = (e, t, r, n, i, s) => {
  const o = Object.create(E1);
  return Z.toFlatObject(e, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), ae.call(o, e.message, t, r, n, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o;
};
var S1 = It.Stream, i9 = wn, s9 = Vr;
function Vr() {
  this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
}
i9.inherits(Vr, S1);
Vr.create = function(e, t) {
=======
  cE[e] = { value: e };
});
Object.defineProperties(se, cE);
Object.defineProperty(aE, "isAxiosError", { value: !0 });
se.from = (e, t, r, n, s, i) => {
  const o = Object.create(aE);
  return B.toFlatObject(e, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), se.call(o, e.message, t, r, n, s), o.cause = e, o.name = e.name, i && Object.assign(o, i), o;
};
var lE = zt.Stream, oz = gn, az = er;
function er() {
  this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
}
oz.inherits(er, lE);
er.create = function(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var r = new this();
  t = t || {};
  for (var n in t)
    r[n] = t[n];
  r.source = e;
<<<<<<< HEAD
  var i = e.emit;
  return e.emit = function() {
    return r._handleEmit(arguments), i.apply(e, arguments);
  }, e.on("error", function() {
  }), r.pauseStream && e.pause(), r;
};
Object.defineProperty(Vr.prototype, "readable", {
=======
  var s = e.emit;
  return e.emit = function() {
    return r._handleEmit(arguments), s.apply(e, arguments);
  }, e.on("error", function() {
  }), r.pauseStream && e.pause(), r;
};
Object.defineProperty(er.prototype, "readable", {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.source.readable;
  }
});
<<<<<<< HEAD
Vr.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
Vr.prototype.resume = function() {
  this._released || this.release(), this.source.resume();
};
Vr.prototype.pause = function() {
  this.source.pause();
};
Vr.prototype.release = function() {
=======
er.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
er.prototype.resume = function() {
  this._released || this.release(), this.source.resume();
};
er.prototype.pause = function() {
  this.source.pause();
};
er.prototype.release = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  this._released = !0, this._bufferedEvents.forEach((function(e) {
    this.emit.apply(this, e);
  }).bind(this)), this._bufferedEvents = [];
};
<<<<<<< HEAD
Vr.prototype.pipe = function() {
  var e = S1.prototype.pipe.apply(this, arguments);
  return this.resume(), e;
};
Vr.prototype._handleEmit = function(e) {
=======
er.prototype.pipe = function() {
  var e = lE.prototype.pipe.apply(this, arguments);
  return this.resume(), e;
};
er.prototype._handleEmit = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (this._released) {
    this.emit.apply(this, e);
    return;
  }
  e[0] === "data" && (this.dataSize += e[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(e);
};
<<<<<<< HEAD
Vr.prototype._checkIfMaxDataSizeExceeded = function() {
=======
er.prototype._checkIfMaxDataSizeExceeded = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
    this._maxDataSizeExceeded = !0;
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(e));
  }
};
<<<<<<< HEAD
var o9 = wn, x1 = It.Stream, sE = s9, a9 = ct;
function ct() {
  this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
}
o9.inherits(ct, x1);
ct.create = function(e) {
=======
var cz = gn, uE = zt.Stream, pg = az, lz = Ve;
function Ve() {
  this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
}
cz.inherits(Ve, uE);
Ve.create = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var t = new this();
  e = e || {};
  for (var r in e)
    t[r] = e[r];
  return t;
};
<<<<<<< HEAD
ct.isStreamLike = function(e) {
  return typeof e != "function" && typeof e != "string" && typeof e != "boolean" && typeof e != "number" && !Buffer.isBuffer(e);
};
ct.prototype.append = function(e) {
  var t = ct.isStreamLike(e);
  if (t) {
    if (!(e instanceof sE)) {
      var r = sE.create(e, {
=======
Ve.isStreamLike = function(e) {
  return typeof e != "function" && typeof e != "string" && typeof e != "boolean" && typeof e != "number" && !Buffer.isBuffer(e);
};
Ve.prototype.append = function(e) {
  var t = Ve.isStreamLike(e);
  if (t) {
    if (!(e instanceof pg)) {
      var r = pg.create(e, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        maxDataSize: 1 / 0,
        pauseStream: this.pauseStreams
      });
      e.on("data", this._checkDataSize.bind(this)), e = r;
    }
    this._handleErrors(e), this.pauseStreams && e.pause();
  }
  return this._streams.push(e), this;
};
<<<<<<< HEAD
ct.prototype.pipe = function(e, t) {
  return x1.prototype.pipe.call(this, e, t), this.resume(), e;
};
ct.prototype._getNext = function() {
=======
Ve.prototype.pipe = function(e, t) {
  return uE.prototype.pipe.call(this, e, t), this.resume(), e;
};
Ve.prototype._getNext = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (this._currentStream = null, this._insideLoop) {
    this._pendingNext = !0;
    return;
  }
  this._insideLoop = !0;
  try {
    do
      this._pendingNext = !1, this._realGetNext();
    while (this._pendingNext);
  } finally {
    this._insideLoop = !1;
  }
};
<<<<<<< HEAD
ct.prototype._realGetNext = function() {
=======
Ve.prototype._realGetNext = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var e = this._streams.shift();
  if (typeof e > "u") {
    this.end();
    return;
  }
  if (typeof e != "function") {
    this._pipeNext(e);
    return;
  }
  var t = e;
  t((function(r) {
<<<<<<< HEAD
    var n = ct.isStreamLike(r);
    n && (r.on("data", this._checkDataSize.bind(this)), this._handleErrors(r)), this._pipeNext(r);
  }).bind(this));
};
ct.prototype._pipeNext = function(e) {
  this._currentStream = e;
  var t = ct.isStreamLike(e);
=======
    var n = Ve.isStreamLike(r);
    n && (r.on("data", this._checkDataSize.bind(this)), this._handleErrors(r)), this._pipeNext(r);
  }).bind(this));
};
Ve.prototype._pipeNext = function(e) {
  this._currentStream = e;
  var t = Ve.isStreamLike(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (t) {
    e.on("end", this._getNext.bind(this)), e.pipe(this, { end: !1 });
    return;
  }
  var r = e;
  this.write(r), this._getNext();
};
<<<<<<< HEAD
ct.prototype._handleErrors = function(e) {
=======
Ve.prototype._handleErrors = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var t = this;
  e.on("error", function(r) {
    t._emitError(r);
  });
};
<<<<<<< HEAD
ct.prototype.write = function(e) {
  this.emit("data", e);
};
ct.prototype.pause = function() {
  this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
};
ct.prototype.resume = function() {
  this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
};
ct.prototype.end = function() {
  this._reset(), this.emit("end");
};
ct.prototype.destroy = function() {
  this._reset(), this.emit("close");
};
ct.prototype._reset = function() {
  this.writable = !1, this._streams = [], this._currentStream = null;
};
ct.prototype._checkDataSize = function() {
=======
Ve.prototype.write = function(e) {
  this.emit("data", e);
};
Ve.prototype.pause = function() {
  this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
};
Ve.prototype.resume = function() {
  this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
};
Ve.prototype.end = function() {
  this._reset(), this.emit("end");
};
Ve.prototype.destroy = function() {
  this._reset(), this.emit("close");
};
Ve.prototype._reset = function() {
  this.writable = !1, this._streams = [], this._currentStream = null;
};
Ve.prototype._checkDataSize = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(e));
  }
};
<<<<<<< HEAD
ct.prototype._updateDataSize = function() {
=======
Ve.prototype._updateDataSize = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  this.dataSize = 0;
  var e = this;
  this._streams.forEach(function(t) {
    t.dataSize && (e.dataSize += t.dataSize);
  }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
};
<<<<<<< HEAD
ct.prototype._emitError = function(e) {
  this._reset(), this.emit("error", e);
};
var R1 = {};
const c9 = {
=======
Ve.prototype._emitError = function(e) {
  this._reset(), this.emit("error", e);
};
var fE = {};
const uz = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: !0
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: !0
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: !0
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: !1
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/calendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: !0
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: !0
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: !0
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: !0
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/csvm+json": {
    source: "iana",
    compressible: !0
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: !0
  },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: !0
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: !0
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: !1
  },
  "application/edifact": {
    source: "iana",
    compressible: !1
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/elm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: !0
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fido.trusted-apps+json": {
    compressible: !0
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: !1
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: !0
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: !0
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: !0
  },
  "application/jrd+json": {
    source: "iana",
    compressible: !0
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: !1
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: !0
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: !0
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: !1
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: !1
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: !0
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: !0,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: !0
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: !0
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: !0
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sarif+json": {
    source: "iana",
    compressible: !0
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/scim+json": {
    source: "iana",
    compressible: !0
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: !0
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: !0
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: !0
  },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: !0
  },
  "application/taxii+json": {
    source: "iana",
    compressible: !0
  },
  "application/td+json": {
    source: "iana",
    compressible: !0
  },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: !0
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: !0,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: !1,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+json": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: !1,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-outlook": {
    compressible: !1,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: !0
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: !0
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: !1,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: !1
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: !0,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: !0
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: !1
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: !0,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: !0,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: !0,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: !0,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: !0,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: !0,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: !0,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: !0
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: !0
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: !1,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: !1
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: !1,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: !1
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: !1
  },
  "audio/vorbis": {
    source: "iana",
    compressible: !1
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: !1,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: !1,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: !1,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: !1
  },
  "image/png": {
    source: "iana",
    compressible: !1,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: !0,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: !1
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: !1
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: !0
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: !1
  },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: !1
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: !1
  },
  "multipart/form-data": {
    source: "iana",
    compressible: !1
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: !1
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: !1
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: !0
  },
  "text/cmd": {
    compressible: !0
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: !0
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: !0,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: !0,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: !0,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: !0
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: !0
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: !0,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: !0,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: !0,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: !0,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: !0,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: !0
  },
  "x-shader/x-vertex": {
    compressible: !0
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
var l9 = c9;
=======
var fz = uz;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(e) {
<<<<<<< HEAD
  var t = l9, r = we.extname, n = /^\s*([^;\s]*)(?:;|\s|$)/, i = /^text\//i;
  e.charset = s, e.charsets = { lookup: s }, e.contentType = o, e.extension = a, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = c, e.types = /* @__PURE__ */ Object.create(null), u(e.extensions, e.types);
  function s(l) {
    if (!l || typeof l != "string")
      return !1;
    var f = n.exec(l), m = f && t[f[1].toLowerCase()];
    return m && m.charset ? m.charset : f && i.test(f[1]) ? "UTF-8" : !1;
=======
  var t = fz, r = rt.extname, n = /^\s*([^;\s]*)(?:;|\s|$)/, s = /^text\//i;
  e.charset = i, e.charsets = { lookup: i }, e.contentType = o, e.extension = a, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = c, e.types = /* @__PURE__ */ Object.create(null), f(e.extensions, e.types);
  function i(l) {
    if (!l || typeof l != "string")
      return !1;
    var d = n.exec(l), g = d && t[d[1].toLowerCase()];
    return g && g.charset ? g.charset : d && s.test(d[1]) ? "UTF-8" : !1;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function o(l) {
    if (!l || typeof l != "string")
      return !1;
<<<<<<< HEAD
    var f = l.indexOf("/") === -1 ? e.lookup(l) : l;
    if (!f)
      return !1;
    if (f.indexOf("charset") === -1) {
      var m = e.charset(f);
      m && (f += "; charset=" + m.toLowerCase());
    }
    return f;
=======
    var d = l.indexOf("/") === -1 ? e.lookup(l) : l;
    if (!d)
      return !1;
    if (d.indexOf("charset") === -1) {
      var g = e.charset(d);
      g && (d += "; charset=" + g.toLowerCase());
    }
    return d;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function a(l) {
    if (!l || typeof l != "string")
      return !1;
<<<<<<< HEAD
    var f = n.exec(l), m = f && e.extensions[f[1].toLowerCase()];
    return !m || !m.length ? !1 : m[0];
=======
    var d = n.exec(l), g = d && e.extensions[d[1].toLowerCase()];
    return !g || !g.length ? !1 : g[0];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  function c(l) {
    if (!l || typeof l != "string")
      return !1;
<<<<<<< HEAD
    var f = r("x." + l).toLowerCase().substr(1);
    return f && e.types[f] || !1;
  }
  function u(l, f) {
    var m = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function(d) {
      var h = t[d], _ = h.extensions;
      if (!(!_ || !_.length)) {
        l[d] = _;
        for (var g = 0; g < _.length; g++) {
          var v = _[g];
          if (f[v]) {
            var y = m.indexOf(t[f[v]].source), E = m.indexOf(h.source);
            if (f[v] !== "application/octet-stream" && (y > E || y === E && f[v].substr(0, 12) === "application/"))
              continue;
          }
          f[v] = d;
=======
    var d = r("x." + l).toLowerCase().substr(1);
    return d && e.types[d] || !1;
  }
  function f(l, d) {
    var g = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function(u) {
      var h = t[u], b = h.extensions;
      if (!(!b || !b.length)) {
        l[u] = b;
        for (var m = 0; m < b.length; m++) {
          var v = b[m];
          if (d[v]) {
            var y = g.indexOf(t[d[v]].source), _ = g.indexOf(h.source);
            if (d[v] !== "application/octet-stream" && (y > _ || y === _ && d[v].substr(0, 12) === "application/"))
              continue;
          }
          d[v] = u;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
    });
  }
<<<<<<< HEAD
})(R1);
var u9 = f9;
function f9(e) {
  var t = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  t ? t(e) : setTimeout(e, 0);
}
var oE = u9, $1 = d9;
function d9(e) {
  var t = !1;
  return oE(function() {
    t = !0;
  }), function(n, i) {
    t ? e(n, i) : oE(function() {
      e(n, i);
    });
  };
}
var T1 = p9;
function p9(e) {
  Object.keys(e.jobs).forEach(h9.bind(e)), e.jobs = {};
}
function h9(e) {
  typeof this.jobs[e] == "function" && this.jobs[e]();
}
var aE = $1, m9 = T1, O1 = g9;
function g9(e, t, r, n) {
  var i = r.keyedList ? r.keyedList[r.index] : r.index;
  r.jobs[i] = y9(t, i, e[i], function(s, o) {
    i in r.jobs && (delete r.jobs[i], s ? m9(r) : r.results[i] = o, n(s, r.results));
  });
}
function y9(e, t, r, n) {
  var i;
  return e.length == 2 ? i = e(r, aE(n)) : i = e(r, t, aE(n)), i;
}
var P1 = v9;
function v9(e, t) {
=======
})(fE);
var dz = pz;
function pz(e) {
  var t = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  t ? t(e) : setTimeout(e, 0);
}
var hg = dz, dE = hz;
function hz(e) {
  var t = !1;
  return hg(function() {
    t = !0;
  }), function(n, s) {
    t ? e(n, s) : hg(function() {
      e(n, s);
    });
  };
}
var pE = mz;
function mz(e) {
  Object.keys(e.jobs).forEach(yz.bind(e)), e.jobs = {};
}
function yz(e) {
  typeof this.jobs[e] == "function" && this.jobs[e]();
}
var mg = dE, gz = pE, hE = vz;
function vz(e, t, r, n) {
  var s = r.keyedList ? r.keyedList[r.index] : r.index;
  r.jobs[s] = bz(t, s, e[s], function(i, o) {
    s in r.jobs && (delete r.jobs[s], i ? gz(r) : r.results[s] = o, n(i, r.results));
  });
}
function bz(e, t, r, n) {
  var s;
  return e.length == 2 ? s = e(r, mg(n)) : s = e(r, t, mg(n)), s;
}
var mE = _z;
function _z(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var r = !Array.isArray(e), n = {
    index: 0,
    keyedList: r || t ? Object.keys(e) : null,
    jobs: {},
    results: r ? {} : [],
    size: r ? Object.keys(e).length : e.length
  };
<<<<<<< HEAD
  return t && n.keyedList.sort(r ? t : function(i, s) {
    return t(e[i], e[s]);
  }), n;
}
var _9 = T1, b9 = $1, C1 = E9;
function E9(e) {
  Object.keys(this.jobs).length && (this.index = this.size, _9(this), b9(e)(null, this.results));
}
var w9 = O1, S9 = P1, x9 = C1, R9 = $9;
function $9(e, t, r) {
  for (var n = S9(e); n.index < (n.keyedList || e).length; )
    w9(e, t, n, function(i, s) {
      if (i) {
        r(i, s);
=======
  return t && n.keyedList.sort(r ? t : function(s, i) {
    return t(e[s], e[i]);
  }), n;
}
var Ez = pE, Sz = dE, yE = xz;
function xz(e) {
  Object.keys(this.jobs).length && (this.index = this.size, Ez(this), Sz(e)(null, this.results));
}
var wz = hE, Rz = mE, $z = yE, Tz = Oz;
function Oz(e, t, r) {
  for (var n = Rz(e); n.index < (n.keyedList || e).length; )
    wz(e, t, n, function(s, i) {
      if (s) {
        r(s, i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        return;
      }
      if (Object.keys(n.jobs).length === 0) {
        r(null, n.results);
        return;
      }
    }), n.index++;
<<<<<<< HEAD
  return x9.bind(n, r);
}
var cf = { exports: {} }, cE = O1, T9 = P1, O9 = C1;
cf.exports = P9;
cf.exports.ascending = A1;
cf.exports.descending = C9;
function P9(e, t, r, n) {
  var i = T9(e, r);
  return cE(e, t, i, function s(o, a) {
=======
  return $z.bind(n, r);
}
var qa = { exports: {} }, yg = hE, Cz = mE, Pz = yE;
qa.exports = Iz;
qa.exports.ascending = gE;
qa.exports.descending = Nz;
function Iz(e, t, r, n) {
  var s = Cz(e, r);
  return yg(e, t, s, function i(o, a) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (o) {
      n(o, a);
      return;
    }
<<<<<<< HEAD
    if (i.index++, i.index < (i.keyedList || e).length) {
      cE(e, t, i, s);
      return;
    }
    n(null, i.results);
  }), O9.bind(i, n);
}
function A1(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function C9(e, t) {
  return -1 * A1(e, t);
}
var I1 = cf.exports, A9 = I1, I9 = N9;
function N9(e, t, r) {
  return A9(e, t, null, r);
}
var k9 = {
  parallel: R9,
  serial: I9,
  serialOrdered: I1
}, N1 = Object, D9 = Error, L9 = EvalError, F9 = RangeError, j9 = ReferenceError, U9 = SyntaxError, gy = TypeError, M9 = URIError, H9 = Math.abs, q9 = Math.floor, B9 = Math.max, z9 = Math.min, V9 = Math.pow, G9 = Math.round, W9 = Number.isNaN || function(t) {
  return t !== t;
}, K9 = W9, Y9 = function(t) {
  return K9(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, J9 = Object.getOwnPropertyDescriptor, xl = J9;
if (xl)
  try {
    xl([], "length");
  } catch {
    xl = null;
  }
var k1 = xl, Rl = Object.defineProperty || !1;
if (Rl)
  try {
    Rl({}, "a", { value: 1 });
  } catch {
    Rl = !1;
  }
var X9 = Rl, cp, lE;
function D1() {
  return lE || (lE = 1, cp = function() {
=======
    if (s.index++, s.index < (s.keyedList || e).length) {
      yg(e, t, s, i);
      return;
    }
    n(null, s.results);
  }), Pz.bind(s, n);
}
function gE(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function Nz(e, t) {
  return -1 * gE(e, t);
}
var vE = qa.exports, Az = vE, kz = Lz;
function Lz(e, t, r) {
  return Az(e, t, null, r);
}
var jz = {
  parallel: Tz,
  serial: kz,
  serialOrdered: vE
}, bE = Object, Dz = Error, Fz = EvalError, Mz = RangeError, zz = ReferenceError, Uz = SyntaxError, Zd = TypeError, qz = URIError, Hz = Math.abs, Bz = Math.floor, Vz = Math.max, Gz = Math.min, Wz = Math.pow, Kz = Math.round, Jz = Number.isNaN || function(t) {
  return t !== t;
}, Yz = Jz, Xz = function(t) {
  return Yz(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, Zz = Object.getOwnPropertyDescriptor, Ro = Zz;
if (Ro)
  try {
    Ro([], "length");
  } catch {
    Ro = null;
  }
var _E = Ro, $o = Object.defineProperty || !1;
if ($o)
  try {
    $o({}, "a", { value: 1 });
  } catch {
    $o = !1;
  }
var Qz = $o, wl, gg;
function EE() {
  return gg || (gg = 1, wl = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = Symbol("test"), n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
<<<<<<< HEAD
    var i = 42;
    t[r] = i;
    for (var s in t)
=======
    var s = 42;
    t[r] = s;
    for (var i in t)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(t);
    if (o.length !== 1 || o[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
<<<<<<< HEAD
      if (a.value !== i || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), cp;
}
var lp, uE;
function Z9() {
  if (uE) return lp;
  uE = 1;
  var e = typeof Symbol < "u" && Symbol, t = D1();
  return lp = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, lp;
}
var up, fE;
function L1() {
  return fE || (fE = 1, up = typeof Reflect < "u" && Reflect.getPrototypeOf || null), up;
}
var fp, dE;
function F1() {
  if (dE) return fp;
  dE = 1;
  var e = N1;
  return fp = e.getPrototypeOf || null, fp;
}
var dp, pE;
function Q9() {
  if (pE) return dp;
  pE = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", i = function(c, u) {
    for (var l = [], f = 0; f < c.length; f += 1)
      l[f] = c[f];
    for (var m = 0; m < u.length; m += 1)
      l[m + c.length] = u[m];
    return l;
  }, s = function(c, u) {
    for (var l = [], f = u, m = 0; f < c.length; f += 1, m += 1)
      l[m] = c[f];
    return l;
  }, o = function(a, c) {
    for (var u = "", l = 0; l < a.length; l += 1)
      u += a[l], l + 1 < a.length && (u += c);
    return u;
  };
  return dp = function(c) {
    var u = this;
    if (typeof u != "function" || t.apply(u) !== n)
      throw new TypeError(e + u);
    for (var l = s(arguments, 1), f, m = function() {
      if (this instanceof f) {
        var g = u.apply(
          this,
          i(l, arguments)
        );
        return Object(g) === g ? g : this;
      }
      return u.apply(
        c,
        i(l, arguments)
      );
    }, p = r(0, u.length - l.length), d = [], h = 0; h < p; h++)
      d[h] = "$" + h;
    if (f = Function("binder", "return function (" + o(d, ",") + "){ return binder.apply(this,arguments); }")(m), u.prototype) {
      var _ = function() {
      };
      _.prototype = u.prototype, f.prototype = new _(), _.prototype = null;
    }
    return f;
  }, dp;
}
var pp, hE;
function lf() {
  if (hE) return pp;
  hE = 1;
  var e = Q9();
  return pp = Function.prototype.bind || e, pp;
}
var hp, mE;
function yy() {
  return mE || (mE = 1, hp = Function.prototype.call), hp;
}
var mp, gE;
function j1() {
  return gE || (gE = 1, mp = Function.prototype.apply), mp;
}
var gp, yE;
function e5() {
  return yE || (yE = 1, gp = typeof Reflect < "u" && Reflect && Reflect.apply), gp;
}
var yp, vE;
function t5() {
  if (vE) return yp;
  vE = 1;
  var e = lf(), t = j1(), r = yy(), n = e5();
  return yp = n || e.call(r, t), yp;
}
var vp, _E;
function r5() {
  if (_E) return vp;
  _E = 1;
  var e = lf(), t = gy, r = yy(), n = t5();
  return vp = function(s) {
    if (s.length < 1 || typeof s[0] != "function")
      throw new t("a function is required");
    return n(e, r, s);
  }, vp;
}
var _p, bE;
function n5() {
  if (bE) return _p;
  bE = 1;
  var e = r5(), t = k1, r;
=======
      if (a.value !== s || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), wl;
}
var Rl, vg;
function eU() {
  if (vg) return Rl;
  vg = 1;
  var e = typeof Symbol < "u" && Symbol, t = EE();
  return Rl = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Rl;
}
var $l, bg;
function SE() {
  return bg || (bg = 1, $l = typeof Reflect < "u" && Reflect.getPrototypeOf || null), $l;
}
var Tl, _g;
function xE() {
  if (_g) return Tl;
  _g = 1;
  var e = bE;
  return Tl = e.getPrototypeOf || null, Tl;
}
var Ol, Eg;
function tU() {
  if (Eg) return Ol;
  Eg = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", s = function(c, f) {
    for (var l = [], d = 0; d < c.length; d += 1)
      l[d] = c[d];
    for (var g = 0; g < f.length; g += 1)
      l[g + c.length] = f[g];
    return l;
  }, i = function(c, f) {
    for (var l = [], d = f, g = 0; d < c.length; d += 1, g += 1)
      l[g] = c[d];
    return l;
  }, o = function(a, c) {
    for (var f = "", l = 0; l < a.length; l += 1)
      f += a[l], l + 1 < a.length && (f += c);
    return f;
  };
  return Ol = function(c) {
    var f = this;
    if (typeof f != "function" || t.apply(f) !== n)
      throw new TypeError(e + f);
    for (var l = i(arguments, 1), d, g = function() {
      if (this instanceof d) {
        var m = f.apply(
          this,
          s(l, arguments)
        );
        return Object(m) === m ? m : this;
      }
      return f.apply(
        c,
        s(l, arguments)
      );
    }, p = r(0, f.length - l.length), u = [], h = 0; h < p; h++)
      u[h] = "$" + h;
    if (d = Function("binder", "return function (" + o(u, ",") + "){ return binder.apply(this,arguments); }")(g), f.prototype) {
      var b = function() {
      };
      b.prototype = f.prototype, d.prototype = new b(), b.prototype = null;
    }
    return d;
  }, Ol;
}
var Cl, Sg;
function Ha() {
  if (Sg) return Cl;
  Sg = 1;
  var e = tU();
  return Cl = Function.prototype.bind || e, Cl;
}
var Pl, xg;
function Qd() {
  return xg || (xg = 1, Pl = Function.prototype.call), Pl;
}
var Il, wg;
function wE() {
  return wg || (wg = 1, Il = Function.prototype.apply), Il;
}
var Nl, Rg;
function rU() {
  return Rg || (Rg = 1, Nl = typeof Reflect < "u" && Reflect && Reflect.apply), Nl;
}
var Al, $g;
function nU() {
  if ($g) return Al;
  $g = 1;
  var e = Ha(), t = wE(), r = Qd(), n = rU();
  return Al = n || e.call(r, t), Al;
}
var kl, Tg;
function sU() {
  if (Tg) return kl;
  Tg = 1;
  var e = Ha(), t = Zd, r = Qd(), n = nU();
  return kl = function(i) {
    if (i.length < 1 || typeof i[0] != "function")
      throw new t("a function is required");
    return n(e, r, i);
  }, kl;
}
var Ll, Og;
function iU() {
  if (Og) return Ll;
  Og = 1;
  var e = sU(), t = _E, r;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
<<<<<<< HEAD
  ), i = Object, s = i.getPrototypeOf;
  return _p = n && typeof n.get == "function" ? e([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(a) {
      return s(a == null ? a : i(a));
    }
  ) : !1, _p;
}
var bp, EE;
function i5() {
  if (EE) return bp;
  EE = 1;
  var e = L1(), t = F1(), r = n5();
  return bp = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return t(i);
  } : r ? function(i) {
    return r(i);
  } : null, bp;
}
var Ep, wE;
function U1() {
  if (wE) return Ep;
  wE = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = lf();
  return Ep = r.call(e, t), Ep;
}
var Oe, s5 = N1, o5 = D9, a5 = L9, c5 = F9, l5 = j9, Vs = U9, Ds = gy, u5 = M9, f5 = H9, d5 = q9, p5 = B9, h5 = z9, m5 = V9, g5 = G9, y5 = Y9, M1 = Function, wp = function(e) {
  try {
    return M1('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, fa = k1, v5 = X9, Sp = function() {
  throw new Ds();
}, _5 = fa ? function() {
  try {
    return arguments.callee, Sp;
  } catch {
    try {
      return fa(arguments, "callee").get;
    } catch {
      return Sp;
    }
  }
}() : Sp, us = Z9()(), Et = i5(), b5 = F1(), E5 = L1(), H1 = j1(), Xa = yy(), vs = {}, w5 = typeof Uint8Array > "u" || !Et ? Oe : Et(Uint8Array), Ni = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Oe : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Oe : ArrayBuffer,
  "%ArrayIteratorPrototype%": us && Et ? Et([][Symbol.iterator]()) : Oe,
  "%AsyncFromSyncIteratorPrototype%": Oe,
  "%AsyncFunction%": vs,
  "%AsyncGenerator%": vs,
  "%AsyncGeneratorFunction%": vs,
  "%AsyncIteratorPrototype%": vs,
  "%Atomics%": typeof Atomics > "u" ? Oe : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Oe : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Oe : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Oe : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Oe : DataView,
=======
  ), s = Object, i = s.getPrototypeOf;
  return Ll = n && typeof n.get == "function" ? e([n.get]) : typeof i == "function" ? (
    /** @type {import('./get')} */
    function(a) {
      return i(a == null ? a : s(a));
    }
  ) : !1, Ll;
}
var jl, Cg;
function oU() {
  if (Cg) return jl;
  Cg = 1;
  var e = SE(), t = xE(), r = iU();
  return jl = e ? function(s) {
    return e(s);
  } : t ? function(s) {
    if (!s || typeof s != "object" && typeof s != "function")
      throw new TypeError("getProto: not an object");
    return t(s);
  } : r ? function(s) {
    return r(s);
  } : null, jl;
}
var Dl, Pg;
function RE() {
  if (Pg) return Dl;
  Pg = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = Ha();
  return Dl = r.call(e, t), Dl;
}
var ve, aU = bE, cU = Dz, lU = Fz, uU = Mz, fU = zz, Qn = Uz, Vn = Zd, dU = qz, pU = Hz, hU = Bz, mU = Vz, yU = Gz, gU = Wz, vU = Kz, bU = Xz, $E = Function, Fl = function(e) {
  try {
    return $E('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Js = _E, _U = Qz, Ml = function() {
  throw new Vn();
}, EU = Js ? function() {
  try {
    return arguments.callee, Ml;
  } catch {
    try {
      return Js(arguments, "callee").get;
    } catch {
      return Ml;
    }
  }
}() : Ml, An = eU()(), nt = oU(), SU = xE(), xU = SE(), TE = wE(), _i = Qd(), Ln = {}, wU = typeof Uint8Array > "u" || !nt ? ve : nt(Uint8Array), ln = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? ve : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ve : ArrayBuffer,
  "%ArrayIteratorPrototype%": An && nt ? nt([][Symbol.iterator]()) : ve,
  "%AsyncFromSyncIteratorPrototype%": ve,
  "%AsyncFunction%": Ln,
  "%AsyncGenerator%": Ln,
  "%AsyncGeneratorFunction%": Ln,
  "%AsyncIteratorPrototype%": Ln,
  "%Atomics%": typeof Atomics > "u" ? ve : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ve : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ve : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ve : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ve : DataView,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
<<<<<<< HEAD
  "%Error%": o5,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": a5,
  "%Float16Array%": typeof Float16Array > "u" ? Oe : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? Oe : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Oe : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Oe : FinalizationRegistry,
  "%Function%": M1,
  "%GeneratorFunction%": vs,
  "%Int8Array%": typeof Int8Array > "u" ? Oe : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Oe : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Oe : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": us && Et ? Et(Et([][Symbol.iterator]())) : Oe,
  "%JSON%": typeof JSON == "object" ? JSON : Oe,
  "%Map%": typeof Map > "u" ? Oe : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !us || !Et ? Oe : Et((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": s5,
  "%Object.getOwnPropertyDescriptor%": fa,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Oe : Promise,
  "%Proxy%": typeof Proxy > "u" ? Oe : Proxy,
  "%RangeError%": c5,
  "%ReferenceError%": l5,
  "%Reflect%": typeof Reflect > "u" ? Oe : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Oe : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !us || !Et ? Oe : Et((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Oe : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": us && Et ? Et(""[Symbol.iterator]()) : Oe,
  "%Symbol%": us ? Symbol : Oe,
  "%SyntaxError%": Vs,
  "%ThrowTypeError%": _5,
  "%TypedArray%": w5,
  "%TypeError%": Ds,
  "%Uint8Array%": typeof Uint8Array > "u" ? Oe : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Oe : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Oe : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Oe : Uint32Array,
  "%URIError%": u5,
  "%WeakMap%": typeof WeakMap > "u" ? Oe : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Oe : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Oe : WeakSet,
  "%Function.prototype.call%": Xa,
  "%Function.prototype.apply%": H1,
  "%Object.defineProperty%": v5,
  "%Object.getPrototypeOf%": b5,
  "%Math.abs%": f5,
  "%Math.floor%": d5,
  "%Math.max%": p5,
  "%Math.min%": h5,
  "%Math.pow%": m5,
  "%Math.round%": g5,
  "%Math.sign%": y5,
  "%Reflect.getPrototypeOf%": E5
};
if (Et)
  try {
    null.error;
  } catch (e) {
    var S5 = Et(Et(e));
    Ni["%Error.prototype%"] = S5;
  }
var x5 = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = wp("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = wp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = wp("async function* () {}");
=======
  "%Error%": cU,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": lU,
  "%Float16Array%": typeof Float16Array > "u" ? ve : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? ve : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ve : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ve : FinalizationRegistry,
  "%Function%": $E,
  "%GeneratorFunction%": Ln,
  "%Int8Array%": typeof Int8Array > "u" ? ve : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ve : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ve : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": An && nt ? nt(nt([][Symbol.iterator]())) : ve,
  "%JSON%": typeof JSON == "object" ? JSON : ve,
  "%Map%": typeof Map > "u" ? ve : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !An || !nt ? ve : nt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": aU,
  "%Object.getOwnPropertyDescriptor%": Js,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ve : Promise,
  "%Proxy%": typeof Proxy > "u" ? ve : Proxy,
  "%RangeError%": uU,
  "%ReferenceError%": fU,
  "%Reflect%": typeof Reflect > "u" ? ve : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ve : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !An || !nt ? ve : nt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ve : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": An && nt ? nt(""[Symbol.iterator]()) : ve,
  "%Symbol%": An ? Symbol : ve,
  "%SyntaxError%": Qn,
  "%ThrowTypeError%": EU,
  "%TypedArray%": wU,
  "%TypeError%": Vn,
  "%Uint8Array%": typeof Uint8Array > "u" ? ve : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ve : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ve : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ve : Uint32Array,
  "%URIError%": dU,
  "%WeakMap%": typeof WeakMap > "u" ? ve : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ve : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ve : WeakSet,
  "%Function.prototype.call%": _i,
  "%Function.prototype.apply%": TE,
  "%Object.defineProperty%": _U,
  "%Object.getPrototypeOf%": SU,
  "%Math.abs%": pU,
  "%Math.floor%": hU,
  "%Math.max%": mU,
  "%Math.min%": yU,
  "%Math.pow%": gU,
  "%Math.round%": vU,
  "%Math.sign%": bU,
  "%Reflect.getPrototypeOf%": xU
};
if (nt)
  try {
    null.error;
  } catch (e) {
    var RU = nt(nt(e));
    ln["%Error.prototype%"] = RU;
  }
var $U = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Fl("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Fl("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Fl("async function* () {}");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  else if (t === "%AsyncGenerator%") {
    var n = e("%AsyncGeneratorFunction%");
    n && (r = n.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
<<<<<<< HEAD
    var i = e("%AsyncGenerator%");
    i && Et && (r = Et(i.prototype));
  }
  return Ni[t] = r, r;
}, SE = {
=======
    var s = e("%AsyncGenerator%");
    s && nt && (r = nt(s.prototype));
  }
  return ln[t] = r, r;
}, Ig = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
<<<<<<< HEAD
}, Za = lf(), Jl = U1(), R5 = Za.call(Xa, Array.prototype.concat), $5 = Za.call(H1, Array.prototype.splice), xE = Za.call(Xa, String.prototype.replace), Xl = Za.call(Xa, String.prototype.slice), T5 = Za.call(Xa, RegExp.prototype.exec), O5 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, P5 = /\\(\\)?/g, C5 = function(t) {
  var r = Xl(t, 0, 1), n = Xl(t, -1);
  if (r === "%" && n !== "%")
    throw new Vs("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && r !== "%")
    throw new Vs("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return xE(t, O5, function(s, o, a, c) {
    i[i.length] = a ? xE(c, P5, "$1") : o || s;
  }), i;
}, A5 = function(t, r) {
  var n = t, i;
  if (Jl(SE, n) && (i = SE[n], n = "%" + i[0] + "%"), Jl(Ni, n)) {
    var s = Ni[n];
    if (s === vs && (s = x5(n)), typeof s > "u" && !r)
      throw new Ds("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: n,
      value: s
    };
  }
  throw new Vs("intrinsic " + t + " does not exist!");
}, I5 = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Ds("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Ds('"allowMissing" argument must be a boolean');
  if (T5(/^%?[^%]*%?$/, t) === null)
    throw new Vs("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = C5(t), i = n.length > 0 ? n[0] : "", s = A5("%" + i + "%", r), o = s.name, a = s.value, c = !1, u = s.alias;
  u && (i = u[0], $5(n, R5([0, 1], u)));
  for (var l = 1, f = !0; l < n.length; l += 1) {
    var m = n[l], p = Xl(m, 0, 1), d = Xl(m, -1);
    if ((p === '"' || p === "'" || p === "`" || d === '"' || d === "'" || d === "`") && p !== d)
      throw new Vs("property names with quotes must have matching quotes");
    if ((m === "constructor" || !f) && (c = !0), i += "." + m, o = "%" + i + "%", Jl(Ni, o))
      a = Ni[o];
    else if (a != null) {
      if (!(m in a)) {
        if (!r)
          throw new Ds("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (fa && l + 1 >= n.length) {
        var h = fa(a, m);
        f = !!h, f && "get" in h && !("originalValue" in h.get) ? a = h.get : a = a[m];
      } else
        f = Jl(a, m), a = a[m];
      f && !c && (Ni[o] = a);
    }
  }
  return a;
}, xp, RE;
function N5() {
  if (RE) return xp;
  RE = 1;
  var e = D1();
  return xp = function() {
    return e() && !!Symbol.toStringTag;
  }, xp;
}
var k5 = I5, $E = k5("%Object.defineProperty%", !0), D5 = N5()(), L5 = U1(), F5 = gy, Jc = D5 ? Symbol.toStringTag : null, j5 = function(t, r) {
  var n = arguments.length > 2 && !!arguments[2] && arguments[2].force, i = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof n < "u" && typeof n != "boolean" || typeof i < "u" && typeof i != "boolean")
    throw new F5("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  Jc && (n || !L5(t, Jc)) && ($E ? $E(t, Jc, {
    configurable: !i,
    enumerable: !1,
    value: r,
    writable: !1
  }) : t[Jc] = r);
}, U5 = function(e, t) {
  return Object.keys(t).forEach(function(r) {
    e[r] = e[r] || t[r];
  }), e;
}, vy = a9, M5 = wn, Rp = we, H5 = yu, q5 = am, B5 = Hr.parse, z5 = Ye, V5 = It.Stream, $p = R1, G5 = k9, W5 = j5, Dh = U5, K5 = Ce;
M5.inherits(Ce, vy);
function Ce(e) {
  if (!(this instanceof Ce))
    return new Ce(e);
  this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], vy.call(this), e = e || {};
  for (var t in e)
    this[t] = e[t];
}
Ce.LINE_BREAK = `\r
`;
Ce.DEFAULT_CONTENT_TYPE = "application/octet-stream";
Ce.prototype.append = function(e, t, r) {
  r = r || {}, typeof r == "string" && (r = { filename: r });
  var n = vy.prototype.append.bind(this);
=======
}, Ei = Ha(), Wo = RE(), TU = Ei.call(_i, Array.prototype.concat), OU = Ei.call(TE, Array.prototype.splice), Ng = Ei.call(_i, String.prototype.replace), Ko = Ei.call(_i, String.prototype.slice), CU = Ei.call(_i, RegExp.prototype.exec), PU = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, IU = /\\(\\)?/g, NU = function(t) {
  var r = Ko(t, 0, 1), n = Ko(t, -1);
  if (r === "%" && n !== "%")
    throw new Qn("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && r !== "%")
    throw new Qn("invalid intrinsic syntax, expected opening `%`");
  var s = [];
  return Ng(t, PU, function(i, o, a, c) {
    s[s.length] = a ? Ng(c, IU, "$1") : o || i;
  }), s;
}, AU = function(t, r) {
  var n = t, s;
  if (Wo(Ig, n) && (s = Ig[n], n = "%" + s[0] + "%"), Wo(ln, n)) {
    var i = ln[n];
    if (i === Ln && (i = $U(n)), typeof i > "u" && !r)
      throw new Vn("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: s,
      name: n,
      value: i
    };
  }
  throw new Qn("intrinsic " + t + " does not exist!");
}, kU = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Vn("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Vn('"allowMissing" argument must be a boolean');
  if (CU(/^%?[^%]*%?$/, t) === null)
    throw new Qn("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = NU(t), s = n.length > 0 ? n[0] : "", i = AU("%" + s + "%", r), o = i.name, a = i.value, c = !1, f = i.alias;
  f && (s = f[0], OU(n, TU([0, 1], f)));
  for (var l = 1, d = !0; l < n.length; l += 1) {
    var g = n[l], p = Ko(g, 0, 1), u = Ko(g, -1);
    if ((p === '"' || p === "'" || p === "`" || u === '"' || u === "'" || u === "`") && p !== u)
      throw new Qn("property names with quotes must have matching quotes");
    if ((g === "constructor" || !d) && (c = !0), s += "." + g, o = "%" + s + "%", Wo(ln, o))
      a = ln[o];
    else if (a != null) {
      if (!(g in a)) {
        if (!r)
          throw new Vn("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Js && l + 1 >= n.length) {
        var h = Js(a, g);
        d = !!h, d && "get" in h && !("originalValue" in h.get) ? a = h.get : a = a[g];
      } else
        d = Wo(a, g), a = a[g];
      d && !c && (ln[o] = a);
    }
  }
  return a;
}, zl, Ag;
function LU() {
  if (Ag) return zl;
  Ag = 1;
  var e = EE();
  return zl = function() {
    return e() && !!Symbol.toStringTag;
  }, zl;
}
var jU = kU, kg = jU("%Object.defineProperty%", !0), DU = LU()(), FU = RE(), MU = Zd, no = DU ? Symbol.toStringTag : null, zU = function(t, r) {
  var n = arguments.length > 2 && !!arguments[2] && arguments[2].force, s = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof n < "u" && typeof n != "boolean" || typeof s < "u" && typeof s != "boolean")
    throw new MU("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  no && (n || !FU(t, no)) && (kg ? kg(t, no, {
    configurable: !s,
    enumerable: !1,
    value: r,
    writable: !1
  }) : t[no] = r);
}, UU = function(e, t) {
  return Object.keys(t).forEach(function(r) {
    e[r] = e[r] || t[r];
  }), e;
}, ep = lz, qU = gn, Ul = rt, HU = qu, BU = Hu, VU = ni.parse, GU = vt, WU = zt.Stream, ql = fE, KU = jz, JU = zU, Pu = UU, YU = xe;
qU.inherits(xe, ep);
function xe(e) {
  if (!(this instanceof xe))
    return new xe(e);
  this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], ep.call(this), e = e || {};
  for (var t in e)
    this[t] = e[t];
}
xe.LINE_BREAK = `\r
`;
xe.DEFAULT_CONTENT_TYPE = "application/octet-stream";
xe.prototype.append = function(e, t, r) {
  r = r || {}, typeof r == "string" && (r = { filename: r });
  var n = ep.prototype.append.bind(this);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (typeof t == "number" && (t = "" + t), Array.isArray(t)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
<<<<<<< HEAD
  var i = this._multiPartHeader(e, t, r), s = this._multiPartFooter();
  n(i), n(t), n(s), this._trackLength(i, t, r);
};
Ce.prototype._trackLength = function(e, t, r) {
  var n = 0;
  r.knownLength != null ? n += +r.knownLength : Buffer.isBuffer(t) ? n = t.length : typeof t == "string" && (n = Buffer.byteLength(t)), this._valueLength += n, this._overheadLength += Buffer.byteLength(e) + Ce.LINE_BREAK.length, !(!t || !t.path && !(t.readable && Object.prototype.hasOwnProperty.call(t, "httpVersion")) && !(t instanceof V5)) && (r.knownLength || this._valuesToMeasure.push(t));
};
Ce.prototype._lengthRetriever = function(e, t) {
  Object.prototype.hasOwnProperty.call(e, "fd") ? e.end != null && e.end != 1 / 0 && e.start != null ? t(null, e.end + 1 - (e.start ? e.start : 0)) : z5.stat(e.path, function(r, n) {
    var i;
=======
  var s = this._multiPartHeader(e, t, r), i = this._multiPartFooter();
  n(s), n(t), n(i), this._trackLength(s, t, r);
};
xe.prototype._trackLength = function(e, t, r) {
  var n = 0;
  r.knownLength != null ? n += +r.knownLength : Buffer.isBuffer(t) ? n = t.length : typeof t == "string" && (n = Buffer.byteLength(t)), this._valueLength += n, this._overheadLength += Buffer.byteLength(e) + xe.LINE_BREAK.length, !(!t || !t.path && !(t.readable && Object.prototype.hasOwnProperty.call(t, "httpVersion")) && !(t instanceof WU)) && (r.knownLength || this._valuesToMeasure.push(t));
};
xe.prototype._lengthRetriever = function(e, t) {
  Object.prototype.hasOwnProperty.call(e, "fd") ? e.end != null && e.end != 1 / 0 && e.start != null ? t(null, e.end + 1 - (e.start ? e.start : 0)) : GU.stat(e.path, function(r, n) {
    var s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (r) {
      t(r);
      return;
    }
<<<<<<< HEAD
    i = n.size - (e.start ? e.start : 0), t(null, i);
=======
    s = n.size - (e.start ? e.start : 0), t(null, s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }) : Object.prototype.hasOwnProperty.call(e, "httpVersion") ? t(null, +e.headers["content-length"]) : Object.prototype.hasOwnProperty.call(e, "httpModule") ? (e.on("response", function(r) {
    e.pause(), t(null, +r.headers["content-length"]);
  }), e.resume()) : t("Unknown stream");
};
<<<<<<< HEAD
Ce.prototype._multiPartHeader = function(e, t, r) {
  if (typeof r.header == "string")
    return r.header;
  var n = this._getContentDisposition(t, r), i = this._getContentType(t, r), s = "", o = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + e + '"'].concat(n || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(i || [])
  };
  typeof r.header == "object" && Dh(o, r.header);
=======
xe.prototype._multiPartHeader = function(e, t, r) {
  if (typeof r.header == "string")
    return r.header;
  var n = this._getContentDisposition(t, r), s = this._getContentType(t, r), i = "", o = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + e + '"'].concat(n || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(s || [])
  };
  typeof r.header == "object" && Pu(o, r.header);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var a;
  for (var c in o)
    if (Object.prototype.hasOwnProperty.call(o, c)) {
      if (a = o[c], a == null)
        continue;
<<<<<<< HEAD
      Array.isArray(a) || (a = [a]), a.length && (s += c + ": " + a.join("; ") + Ce.LINE_BREAK);
    }
  return "--" + this.getBoundary() + Ce.LINE_BREAK + s + Ce.LINE_BREAK;
};
Ce.prototype._getContentDisposition = function(e, t) {
  var r, n;
  return typeof t.filepath == "string" ? r = Rp.normalize(t.filepath).replace(/\\/g, "/") : t.filename || e.name || e.path ? r = Rp.basename(t.filename || e.name || e.path) : e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = Rp.basename(e.client._httpMessage.path || "")), r && (n = 'filename="' + r + '"'), n;
};
Ce.prototype._getContentType = function(e, t) {
  var r = t.contentType;
  return !r && e.name && (r = $p.lookup(e.name)), !r && e.path && (r = $p.lookup(e.path)), !r && e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = e.headers["content-type"]), !r && (t.filepath || t.filename) && (r = $p.lookup(t.filepath || t.filename)), !r && typeof e == "object" && (r = Ce.DEFAULT_CONTENT_TYPE), r;
};
Ce.prototype._multiPartFooter = function() {
  return (function(e) {
    var t = Ce.LINE_BREAK, r = this._streams.length === 0;
    r && (t += this._lastBoundary()), e(t);
  }).bind(this);
};
Ce.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + Ce.LINE_BREAK;
};
Ce.prototype.getHeaders = function(e) {
=======
      Array.isArray(a) || (a = [a]), a.length && (i += c + ": " + a.join("; ") + xe.LINE_BREAK);
    }
  return "--" + this.getBoundary() + xe.LINE_BREAK + i + xe.LINE_BREAK;
};
xe.prototype._getContentDisposition = function(e, t) {
  var r, n;
  return typeof t.filepath == "string" ? r = Ul.normalize(t.filepath).replace(/\\/g, "/") : t.filename || e.name || e.path ? r = Ul.basename(t.filename || e.name || e.path) : e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = Ul.basename(e.client._httpMessage.path || "")), r && (n = 'filename="' + r + '"'), n;
};
xe.prototype._getContentType = function(e, t) {
  var r = t.contentType;
  return !r && e.name && (r = ql.lookup(e.name)), !r && e.path && (r = ql.lookup(e.path)), !r && e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = e.headers["content-type"]), !r && (t.filepath || t.filename) && (r = ql.lookup(t.filepath || t.filename)), !r && typeof e == "object" && (r = xe.DEFAULT_CONTENT_TYPE), r;
};
xe.prototype._multiPartFooter = function() {
  return (function(e) {
    var t = xe.LINE_BREAK, r = this._streams.length === 0;
    r && (t += this._lastBoundary()), e(t);
  }).bind(this);
};
xe.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + xe.LINE_BREAK;
};
xe.prototype.getHeaders = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var t, r = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (r[t.toLowerCase()] = e[t]);
  return r;
};
<<<<<<< HEAD
Ce.prototype.setBoundary = function(e) {
  this._boundary = e;
};
Ce.prototype.getBoundary = function() {
  return this._boundary || this._generateBoundary(), this._boundary;
};
Ce.prototype.getBuffer = function() {
  for (var e = new Buffer.alloc(0), t = this.getBoundary(), r = 0, n = this._streams.length; r < n; r++)
    typeof this._streams[r] != "function" && (Buffer.isBuffer(this._streams[r]) ? e = Buffer.concat([e, this._streams[r]]) : e = Buffer.concat([e, Buffer.from(this._streams[r])]), (typeof this._streams[r] != "string" || this._streams[r].substring(2, t.length + 2) !== t) && (e = Buffer.concat([e, Buffer.from(Ce.LINE_BREAK)])));
  return Buffer.concat([e, Buffer.from(this._lastBoundary())]);
};
Ce.prototype._generateBoundary = function() {
=======
xe.prototype.setBoundary = function(e) {
  this._boundary = e;
};
xe.prototype.getBoundary = function() {
  return this._boundary || this._generateBoundary(), this._boundary;
};
xe.prototype.getBuffer = function() {
  for (var e = new Buffer.alloc(0), t = this.getBoundary(), r = 0, n = this._streams.length; r < n; r++)
    typeof this._streams[r] != "function" && (Buffer.isBuffer(this._streams[r]) ? e = Buffer.concat([e, this._streams[r]]) : e = Buffer.concat([e, Buffer.from(this._streams[r])]), (typeof this._streams[r] != "string" || this._streams[r].substring(2, t.length + 2) !== t) && (e = Buffer.concat([e, Buffer.from(xe.LINE_BREAK)])));
  return Buffer.concat([e, Buffer.from(this._lastBoundary())]);
};
xe.prototype._generateBoundary = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  for (var e = "--------------------------", t = 0; t < 24; t++)
    e += Math.floor(Math.random() * 10).toString(16);
  this._boundary = e;
};
<<<<<<< HEAD
Ce.prototype.getLengthSync = function() {
  var e = this._overheadLength + this._valueLength;
  return this._streams.length && (e += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), e;
};
Ce.prototype.hasKnownLength = function() {
  var e = !0;
  return this._valuesToMeasure.length && (e = !1), e;
};
Ce.prototype.getLength = function(e) {
=======
xe.prototype.getLengthSync = function() {
  var e = this._overheadLength + this._valueLength;
  return this._streams.length && (e += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), e;
};
xe.prototype.hasKnownLength = function() {
  var e = !0;
  return this._valuesToMeasure.length && (e = !1), e;
};
xe.prototype.getLength = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var t = this._overheadLength + this._valueLength;
  if (this._streams.length && (t += this._lastBoundary().length), !this._valuesToMeasure.length) {
    process.nextTick(e.bind(this, null, t));
    return;
  }
<<<<<<< HEAD
  G5.parallel(this._valuesToMeasure, this._lengthRetriever, function(r, n) {
=======
  KU.parallel(this._valuesToMeasure, this._lengthRetriever, function(r, n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if (r) {
      e(r);
      return;
    }
<<<<<<< HEAD
    n.forEach(function(i) {
      t += i;
    }), e(null, t);
  });
};
Ce.prototype.submit = function(e, t) {
  var r, n, i = { method: "post" };
  return typeof e == "string" ? (e = B5(e), n = Dh({
=======
    n.forEach(function(s) {
      t += s;
    }), e(null, t);
  });
};
xe.prototype.submit = function(e, t) {
  var r, n, s = { method: "post" };
  return typeof e == "string" ? (e = VU(e), n = Pu({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    port: e.port,
    path: e.pathname,
    host: e.hostname,
    protocol: e.protocol
<<<<<<< HEAD
  }, i)) : (n = Dh(e, i), n.port || (n.port = n.protocol == "https:" ? 443 : 80)), n.headers = this.getHeaders(e.headers), n.protocol == "https:" ? r = q5.request(n) : r = H5.request(n), this.getLength((function(s, o) {
    if (s && s !== "Unknown stream") {
      this._error(s);
      return;
    }
    if (o && r.setHeader("Content-Length", o), this.pipe(r), t) {
      var a, c = function(u, l) {
        return r.removeListener("error", c), r.removeListener("response", a), t.call(this, u, l);
=======
  }, s)) : (n = Pu(e, s), n.port || (n.port = n.protocol == "https:" ? 443 : 80)), n.headers = this.getHeaders(e.headers), n.protocol == "https:" ? r = BU.request(n) : r = HU.request(n), this.getLength((function(i, o) {
    if (i && i !== "Unknown stream") {
      this._error(i);
      return;
    }
    if (o && r.setHeader("Content-Length", o), this.pipe(r), t) {
      var a, c = function(f, l) {
        return r.removeListener("error", c), r.removeListener("response", a), t.call(this, f, l);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
      a = c.bind(this, null), r.on("error", c), r.on("response", a);
    }
  }).bind(this)), r;
};
<<<<<<< HEAD
Ce.prototype._error = function(e) {
  this.error || (this.error = e, this.pause(), this.emit("error", e));
};
Ce.prototype.toString = function() {
  return "[object FormData]";
};
W5(Ce, "FormData");
const q1 = /* @__PURE__ */ Da(K5);
function Lh(e) {
  return Z.isPlainObject(e) || Z.isArray(e);
}
function B1(e) {
  return Z.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function TE(e, t, r) {
  return e ? e.concat(t).map(function(i, s) {
    return i = B1(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : t;
}
function Y5(e) {
  return Z.isArray(e) && !e.some(Lh);
}
const J5 = Z.toFlatObject(Z, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function uf(e, t, r) {
  if (!Z.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (q1 || FormData)(), r = Z.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, _) {
    return !Z.isUndefined(_[h]);
  });
  const n = r.metaTokens, i = r.visitor || l, s = r.dots, o = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && Z.isSpecCompliantForm(t);
  if (!Z.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(d) {
    if (d === null) return "";
    if (Z.isDate(d))
      return d.toISOString();
    if (!c && Z.isBlob(d))
      throw new ae("Blob is not supported. Use a Buffer instead.");
    return Z.isArrayBuffer(d) || Z.isTypedArray(d) ? c && typeof Blob == "function" ? new Blob([d]) : Buffer.from(d) : d;
  }
  function l(d, h, _) {
    let g = d;
    if (d && !_ && typeof d == "object") {
      if (Z.endsWith(h, "{}"))
        h = n ? h : h.slice(0, -2), d = JSON.stringify(d);
      else if (Z.isArray(d) && Y5(d) || (Z.isFileList(d) || Z.endsWith(h, "[]")) && (g = Z.toArray(d)))
        return h = B1(h), g.forEach(function(y, E) {
          !(Z.isUndefined(y) || y === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? TE([h], E, s) : o === null ? h : h + "[]",
            u(y)
          );
        }), !1;
    }
    return Lh(d) ? !0 : (t.append(TE(_, h, s), u(d)), !1);
  }
  const f = [], m = Object.assign(J5, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: Lh
  });
  function p(d, h) {
    if (!Z.isUndefined(d)) {
      if (f.indexOf(d) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      f.push(d), Z.forEach(d, function(g, v) {
        (!(Z.isUndefined(g) || g === null) && i.call(
          t,
          g,
          Z.isString(v) ? v.trim() : v,
          h,
          m
        )) === !0 && p(g, h ? h.concat(v) : [v]);
      }), f.pop();
    }
  }
  if (!Z.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function OE(e) {
=======
xe.prototype._error = function(e) {
  this.error || (this.error = e, this.pause(), this.emit("error", e));
};
xe.prototype.toString = function() {
  return "[object FormData]";
};
JU(xe, "FormData");
const OE = /* @__PURE__ */ si(YU);
function Iu(e) {
  return B.isPlainObject(e) || B.isArray(e);
}
function CE(e) {
  return B.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Lg(e, t, r) {
  return e ? e.concat(t).map(function(s, i) {
    return s = CE(s), !r && i ? "[" + s + "]" : s;
  }).join(r ? "." : "") : t;
}
function XU(e) {
  return B.isArray(e) && !e.some(Iu);
}
const ZU = B.toFlatObject(B, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Ba(e, t, r) {
  if (!B.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (OE || FormData)(), r = B.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, b) {
    return !B.isUndefined(b[h]);
  });
  const n = r.metaTokens, s = r.visitor || l, i = r.dots, o = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && B.isSpecCompliantForm(t);
  if (!B.isFunction(s))
    throw new TypeError("visitor must be a function");
  function f(u) {
    if (u === null) return "";
    if (B.isDate(u))
      return u.toISOString();
    if (!c && B.isBlob(u))
      throw new se("Blob is not supported. Use a Buffer instead.");
    return B.isArrayBuffer(u) || B.isTypedArray(u) ? c && typeof Blob == "function" ? new Blob([u]) : Buffer.from(u) : u;
  }
  function l(u, h, b) {
    let m = u;
    if (u && !b && typeof u == "object") {
      if (B.endsWith(h, "{}"))
        h = n ? h : h.slice(0, -2), u = JSON.stringify(u);
      else if (B.isArray(u) && XU(u) || (B.isFileList(u) || B.endsWith(h, "[]")) && (m = B.toArray(u)))
        return h = CE(h), m.forEach(function(y, _) {
          !(B.isUndefined(y) || y === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Lg([h], _, i) : o === null ? h : h + "[]",
            f(y)
          );
        }), !1;
    }
    return Iu(u) ? !0 : (t.append(Lg(b, h, i), f(u)), !1);
  }
  const d = [], g = Object.assign(ZU, {
    defaultVisitor: l,
    convertValue: f,
    isVisitable: Iu
  });
  function p(u, h) {
    if (!B.isUndefined(u)) {
      if (d.indexOf(u) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      d.push(u), B.forEach(u, function(m, v) {
        (!(B.isUndefined(m) || m === null) && s.call(
          t,
          m,
          B.isString(v) ? v.trim() : v,
          h,
          g
        )) === !0 && p(m, h ? h.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!B.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function jg(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
<<<<<<< HEAD
function z1(e, t) {
  this._pairs = [], e && uf(e, this, t);
}
const V1 = z1.prototype;
V1.append = function(t, r) {
  this._pairs.push([t, r]);
};
V1.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, OE);
  } : OE;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function X5(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function _y(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || X5;
  Z.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(t, r) : s = Z.isURLSearchParams(t) ? t.toString() : new z1(t, r).toString(n), s) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class PE {
=======
function PE(e, t) {
  this._pairs = [], e && Ba(e, this, t);
}
const IE = PE.prototype;
IE.append = function(t, r) {
  this._pairs.push([t, r]);
};
IE.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, jg);
  } : jg;
  return this._pairs.map(function(s) {
    return r(s[0]) + "=" + r(s[1]);
  }, "").join("&");
};
function QU(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function tp(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || QU;
  B.isFunction(r) && (r = {
    serialize: r
  });
  const s = r && r.serialize;
  let i;
  if (s ? i = s(t, r) : i = B.isURLSearchParams(t) ? t.toString() : new PE(t, r).toString(n), i) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
class Dg {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
<<<<<<< HEAD
    Z.forEach(this.handlers, function(n) {
=======
    B.forEach(this.handlers, function(n) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      n !== null && t(n);
    });
  }
}
<<<<<<< HEAD
const by = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Z5 = Hr.URLSearchParams, Tp = "abcdefghijklmnopqrstuvwxyz", CE = "0123456789", G1 = {
  DIGIT: CE,
  ALPHA: Tp,
  ALPHA_DIGIT: Tp + Tp.toUpperCase() + CE
}, Q5 = (e = 16, t = G1.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t, i = new Uint32Array(e);
  Gi.randomFillSync(i);
  for (let s = 0; s < e; s++)
    r += t[i[s] % n];
  return r;
}, e8 = {
  isNode: !0,
  classes: {
    URLSearchParams: Z5,
    FormData: q1,
    Blob: typeof Blob < "u" && Blob || null
  },
  ALPHABET: G1,
  generateString: Q5,
  protocols: ["http", "https", "file", "data"]
}, Ey = typeof window < "u" && typeof document < "u", Fh = typeof navigator == "object" && navigator || void 0, t8 = Ey && (!Fh || ["ReactNative", "NativeScript", "NS"].indexOf(Fh.product) < 0), r8 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", n8 = Ey && window.location.href || "http://localhost", i8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Ey,
  hasStandardBrowserEnv: t8,
  hasStandardBrowserWebWorkerEnv: r8,
  navigator: Fh,
  origin: n8
}, Symbol.toStringTag, { value: "Module" })), st = {
  ...i8,
  ...e8
};
function s8(e, t) {
  return uf(e, new st.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return st.isNode && Z.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function o8(e) {
  return Z.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function a8(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], t[s] = e[s];
  return t;
}
function W1(e) {
  function t(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), c = s >= r.length;
    return o = !o && Z.isArray(i) ? i.length : o, c ? (Z.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Z.isObject(i[o])) && (i[o] = []), t(r, n, i[o], s) && Z.isArray(i[o]) && (i[o] = a8(i[o])), !a);
  }
  if (Z.isFormData(e) && Z.isFunction(e.entries)) {
    const r = {};
    return Z.forEachEntry(e, (n, i) => {
      t(o8(n), i, r, 0);
=======
const rp = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, eq = ni.URLSearchParams, Hl = "abcdefghijklmnopqrstuvwxyz", Fg = "0123456789", NE = {
  DIGIT: Fg,
  ALPHA: Hl,
  ALPHA_DIGIT: Hl + Hl.toUpperCase() + Fg
}, tq = (e = 16, t = NE.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t, s = new Uint32Array(e);
  bv.randomFillSync(s);
  for (let i = 0; i < e; i++)
    r += t[s[i] % n];
  return r;
}, rq = {
  isNode: !0,
  classes: {
    URLSearchParams: eq,
    FormData: OE,
    Blob: typeof Blob < "u" && Blob || null
  },
  ALPHABET: NE,
  generateString: tq,
  protocols: ["http", "https", "file", "data"]
}, np = typeof window < "u" && typeof document < "u", Nu = typeof navigator == "object" && navigator || void 0, nq = np && (!Nu || ["ReactNative", "NativeScript", "NS"].indexOf(Nu.product) < 0), sq = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", iq = np && window.location.href || "http://localhost", oq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: np,
  hasStandardBrowserEnv: nq,
  hasStandardBrowserWebWorkerEnv: sq,
  navigator: Nu,
  origin: iq
}, Symbol.toStringTag, { value: "Module" })), qe = {
  ...oq,
  ...rq
};
function aq(e, t) {
  return Ba(e, new qe.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, s, i) {
      return qe.isNode && B.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function cq(e) {
  return B.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function lq(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const s = r.length;
  let i;
  for (n = 0; n < s; n++)
    i = r[n], t[i] = e[i];
  return t;
}
function AE(e) {
  function t(r, n, s, i) {
    let o = r[i++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), c = i >= r.length;
    return o = !o && B.isArray(s) ? s.length : o, c ? (B.hasOwnProp(s, o) ? s[o] = [s[o], n] : s[o] = n, !a) : ((!s[o] || !B.isObject(s[o])) && (s[o] = []), t(r, n, s[o], i) && B.isArray(s[o]) && (s[o] = lq(s[o])), !a);
  }
  if (B.isFormData(e) && B.isFunction(e.entries)) {
    const r = {};
    return B.forEachEntry(e, (n, s) => {
      t(cq(n), s, r, 0);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }), r;
  }
  return null;
}
<<<<<<< HEAD
function c8(e, t, r) {
  if (Z.isString(e))
    try {
      return (t || JSON.parse)(e), Z.trim(e);
=======
function uq(e, t, r) {
  if (B.isString(e))
    try {
      return (t || JSON.parse)(e), B.trim(e);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
<<<<<<< HEAD
const Qa = {
  transitional: by,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Z.isObject(t);
    if (s && Z.isHTMLForm(t) && (t = new FormData(t)), Z.isFormData(t))
      return i ? JSON.stringify(W1(t)) : t;
    if (Z.isArrayBuffer(t) || Z.isBuffer(t) || Z.isStream(t) || Z.isFile(t) || Z.isBlob(t) || Z.isReadableStream(t))
      return t;
    if (Z.isArrayBufferView(t))
      return t.buffer;
    if (Z.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return s8(t, this.formSerializer).toString();
      if ((a = Z.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return uf(
=======
const Si = {
  transitional: rp,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", s = n.indexOf("application/json") > -1, i = B.isObject(t);
    if (i && B.isHTMLForm(t) && (t = new FormData(t)), B.isFormData(t))
      return s ? JSON.stringify(AE(t)) : t;
    if (B.isArrayBuffer(t) || B.isBuffer(t) || B.isStream(t) || B.isFile(t) || B.isBlob(t) || B.isReadableStream(t))
      return t;
    if (B.isArrayBufferView(t))
      return t.buffer;
    if (B.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (i) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return aq(t, this.formSerializer).toString();
      if ((a = B.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Ba(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          a ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
<<<<<<< HEAD
    return s || i ? (r.setContentType("application/json", !1), c8(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || Qa.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Z.isResponse(t) || Z.isReadableStream(t))
      return t;
    if (t && Z.isString(t) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
=======
    return i || s ? (r.setContentType("application/json", !1), uq(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || Si.transitional, n = r && r.forcedJSONParsing, s = this.responseType === "json";
    if (B.isResponse(t) || B.isReadableStream(t))
      return t;
    if (t && B.isString(t) && (n && !this.responseType || s)) {
      const o = !(r && r.silentJSONParsing) && s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
<<<<<<< HEAD
          throw a.name === "SyntaxError" ? ae.from(a, ae.ERR_BAD_RESPONSE, this, null, this.response) : a;
=======
          throw a.name === "SyntaxError" ? se.from(a, se.ERR_BAD_RESPONSE, this, null, this.response) : a;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
<<<<<<< HEAD
    FormData: st.classes.FormData,
    Blob: st.classes.Blob
=======
    FormData: qe.classes.FormData,
    Blob: qe.classes.Blob
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
<<<<<<< HEAD
Z.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Qa.headers[e] = {};
});
const l8 = Z.toObjectSet([
=======
B.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Si.headers[e] = {};
});
const fq = B.toObjectSet([
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
<<<<<<< HEAD
]), u8 = (e) => {
  const t = {};
  let r, n, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || t[r] && l8[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, AE = Symbol("internals");
function Lo(e) {
  return e && String(e).trim().toLowerCase();
}
function $l(e) {
  return e === !1 || e == null ? e : Z.isArray(e) ? e.map($l) : String(e);
}
function f8(e) {
=======
]), dq = (e) => {
  const t = {};
  let r, n, s;
  return e && e.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), r = o.substring(0, s).trim().toLowerCase(), n = o.substring(s + 1).trim(), !(!r || t[r] && fq[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, Mg = Symbol("internals");
function Ps(e) {
  return e && String(e).trim().toLowerCase();
}
function To(e) {
  return e === !1 || e == null ? e : B.isArray(e) ? e.map(To) : String(e);
}
function pq(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
<<<<<<< HEAD
const d8 = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Op(e, t, r, n, i) {
  if (Z.isFunction(n))
    return n.call(this, t, r);
  if (i && (t = r), !!Z.isString(t)) {
    if (Z.isString(n))
      return t.indexOf(n) !== -1;
    if (Z.isRegExp(n))
      return n.test(t);
  }
}
function p8(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function h8(e, t) {
  const r = Z.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, t, i, s, o);
=======
const hq = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Bl(e, t, r, n, s) {
  if (B.isFunction(n))
    return n.call(this, t, r);
  if (s && (t = r), !!B.isString(t)) {
    if (B.isString(n))
      return t.indexOf(n) !== -1;
    if (B.isRegExp(n))
      return n.test(t);
  }
}
function mq(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function yq(e, t) {
  const r = B.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(s, i, o) {
        return this[n].call(this, t, s, i, o);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      },
      configurable: !0
    });
  });
}
<<<<<<< HEAD
let Lt = class {
=======
let pt = class {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
<<<<<<< HEAD
    const i = this;
    function s(a, c, u) {
      const l = Lo(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const f = Z.findKey(i, l);
      (!f || i[f] === void 0 || u === !0 || u === void 0 && i[f] !== !1) && (i[f || c] = $l(a));
    }
    const o = (a, c) => Z.forEach(a, (u, l) => s(u, l, c));
    if (Z.isPlainObject(t) || t instanceof this.constructor)
      o(t, r);
    else if (Z.isString(t) && (t = t.trim()) && !d8(t))
      o(u8(t), r);
    else if (Z.isHeaders(t))
      for (const [a, c] of t.entries())
        s(c, a, n);
    else
      t != null && s(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = Lo(t), t) {
      const n = Z.findKey(this, t);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return f8(i);
        if (Z.isFunction(r))
          return r.call(this, i, n);
        if (Z.isRegExp(r))
          return r.exec(i);
=======
    const s = this;
    function i(a, c, f) {
      const l = Ps(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = B.findKey(s, l);
      (!d || s[d] === void 0 || f === !0 || f === void 0 && s[d] !== !1) && (s[d || c] = To(a));
    }
    const o = (a, c) => B.forEach(a, (f, l) => i(f, l, c));
    if (B.isPlainObject(t) || t instanceof this.constructor)
      o(t, r);
    else if (B.isString(t) && (t = t.trim()) && !hq(t))
      o(dq(t), r);
    else if (B.isHeaders(t))
      for (const [a, c] of t.entries())
        i(c, a, n);
    else
      t != null && i(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = Ps(t), t) {
      const n = B.findKey(this, t);
      if (n) {
        const s = this[n];
        if (!r)
          return s;
        if (r === !0)
          return pq(s);
        if (B.isFunction(r))
          return r.call(this, s, n);
        if (B.isRegExp(r))
          return r.exec(s);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
<<<<<<< HEAD
    if (t = Lo(t), t) {
      const n = Z.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || Op(this, this[n], n, r)));
=======
    if (t = Ps(t), t) {
      const n = B.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || Bl(this, this[n], n, r)));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
<<<<<<< HEAD
    let i = !1;
    function s(o) {
      if (o = Lo(o), o) {
        const a = Z.findKey(n, o);
        a && (!r || Op(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Z.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!t || Op(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const r = this, n = {};
    return Z.forEach(this, (i, s) => {
      const o = Z.findKey(n, s);
      if (o) {
        r[o] = $l(i), delete r[s];
        return;
      }
      const a = t ? p8(s) : String(s).trim();
      a !== s && delete r[s], r[a] = $l(i), n[a] = !0;
=======
    let s = !1;
    function i(o) {
      if (o = Ps(o), o) {
        const a = B.findKey(n, o);
        a && (!r || Bl(n, n[a], a, r)) && (delete n[a], s = !0);
      }
    }
    return B.isArray(t) ? t.forEach(i) : i(t), s;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, s = !1;
    for (; n--; ) {
      const i = r[n];
      (!t || Bl(this, this[i], i, t, !0)) && (delete this[i], s = !0);
    }
    return s;
  }
  normalize(t) {
    const r = this, n = {};
    return B.forEach(this, (s, i) => {
      const o = B.findKey(n, i);
      if (o) {
        r[o] = To(s), delete r[i];
        return;
      }
      const a = t ? mq(i) : String(i).trim();
      a !== i && delete r[i], r[a] = To(s), n[a] = !0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
<<<<<<< HEAD
    return Z.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = t && Z.isArray(n) ? n.join(", ") : n);
=======
    return B.forEach(this, (n, s) => {
      n != null && n !== !1 && (r[s] = t && B.isArray(n) ? n.join(", ") : n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
<<<<<<< HEAD
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(t) {
    const n = (this[AE] = this[AE] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Lo(o);
      n[a] || (h8(i, o), n[a] = !0);
    }
    return Z.isArray(t) ? t.forEach(s) : s(t), this;
  }
};
Lt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Z.reduceDescriptors(Lt.prototype, ({ value: e }, t) => {
=======
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(t) {
    const n = (this[Mg] = this[Mg] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function i(o) {
      const a = Ps(o);
      n[a] || (yq(s, o), n[a] = !0);
    }
    return B.isArray(t) ? t.forEach(i) : i(t), this;
  }
};
pt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
B.reduceDescriptors(pt.prototype, ({ value: e }, t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
<<<<<<< HEAD
Z.freezeMethods(Lt);
function Pp(e, t) {
  const r = this || Qa, n = t || r, i = Lt.from(n.headers);
  let s = n.data;
  return Z.forEach(e, function(a) {
    s = a.call(r, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function K1(e) {
  return !!(e && e.__CANCEL__);
}
function Xn(e, t, r) {
  ae.call(this, e ?? "canceled", ae.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Z.inherits(Xn, ae, {
  __CANCEL__: !0
});
function Ss(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new ae(
    "Request failed with status code " + r.status,
    [ae.ERR_BAD_REQUEST, ae.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
=======
B.freezeMethods(pt);
function Vl(e, t) {
  const r = this || Si, n = t || r, s = pt.from(n.headers);
  let i = n.data;
  return B.forEach(e, function(a) {
    i = a.call(r, i, s.normalize(), t ? t.status : void 0);
  }), s.normalize(), i;
}
function kE(e) {
  return !!(e && e.__CANCEL__);
}
function Hr(e, t, r) {
  se.call(this, e ?? "canceled", se.ERR_CANCELED, t, r), this.name = "CanceledError";
}
B.inherits(Hr, se, {
  __CANCEL__: !0
});
function Fn(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new se(
    "Request failed with status code " + r.status,
    [se.ERR_BAD_REQUEST, se.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    r.config,
    r.request,
    r
  ));
}
<<<<<<< HEAD
function m8(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function g8(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function wy(e, t, r) {
  let n = !m8(t);
  return e && (n || r == !1) ? g8(e, t) : t;
}
var Y1 = {}, y8 = Hr.parse, v8 = {
=======
function gq(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function vq(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function sp(e, t, r) {
  let n = !gq(t);
  return e && (n || r == !1) ? vq(e, t) : t;
}
var LE = {}, bq = ni.parse, _q = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
<<<<<<< HEAD
}, _8 = String.prototype.endsWith || function(e) {
  return e.length <= this.length && this.indexOf(e, this.length - e.length) !== -1;
};
function b8(e) {
  var t = typeof e == "string" ? y8(e) : e || {}, r = t.protocol, n = t.host, i = t.port;
  if (typeof n != "string" || !n || typeof r != "string" || (r = r.split(":", 1)[0], n = n.replace(/:\d*$/, ""), i = parseInt(i) || v8[r] || 0, !E8(n, i)))
    return "";
  var s = xs("npm_config_" + r + "_proxy") || xs(r + "_proxy") || xs("npm_config_proxy") || xs("all_proxy");
  return s && s.indexOf("://") === -1 && (s = r + "://" + s), s;
}
function E8(e, t) {
  var r = (xs("npm_config_no_proxy") || xs("no_proxy")).toLowerCase();
  return r ? r === "*" ? !1 : r.split(/[,\s]/).every(function(n) {
    if (!n)
      return !0;
    var i = n.match(/^(.+):(\d+)$/), s = i ? i[1] : n, o = i ? parseInt(i[2]) : 0;
    return o && o !== t ? !0 : /^[.*]/.test(s) ? (s.charAt(0) === "*" && (s = s.slice(1)), !_8.call(e, s)) : e !== s;
  }) : !0;
}
function xs(e) {
  return process.env[e.toLowerCase()] || process.env[e.toUpperCase()] || "";
}
Y1.getProxyForUrl = b8;
var Sy = { exports: {} }, jh = { exports: {} }, Xc = { exports: {} }, Cp, IE;
function w8() {
  if (IE) return Cp;
  IE = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, i = n * 7, s = n * 365.25;
  Cp = function(l, f) {
    f = f || {};
    var m = typeof l;
    if (m === "string" && l.length > 0)
      return o(l);
    if (m === "number" && isFinite(l))
      return f.long ? c(l) : a(l);
=======
}, Eq = String.prototype.endsWith || function(e) {
  return e.length <= this.length && this.indexOf(e, this.length - e.length) !== -1;
};
function Sq(e) {
  var t = typeof e == "string" ? bq(e) : e || {}, r = t.protocol, n = t.host, s = t.port;
  if (typeof n != "string" || !n || typeof r != "string" || (r = r.split(":", 1)[0], n = n.replace(/:\d*$/, ""), s = parseInt(s) || _q[r] || 0, !xq(n, s)))
    return "";
  var i = Mn("npm_config_" + r + "_proxy") || Mn(r + "_proxy") || Mn("npm_config_proxy") || Mn("all_proxy");
  return i && i.indexOf("://") === -1 && (i = r + "://" + i), i;
}
function xq(e, t) {
  var r = (Mn("npm_config_no_proxy") || Mn("no_proxy")).toLowerCase();
  return r ? r === "*" ? !1 : r.split(/[,\s]/).every(function(n) {
    if (!n)
      return !0;
    var s = n.match(/^(.+):(\d+)$/), i = s ? s[1] : n, o = s ? parseInt(s[2]) : 0;
    return o && o !== t ? !0 : /^[.*]/.test(i) ? (i.charAt(0) === "*" && (i = i.slice(1)), !Eq.call(e, i)) : e !== i;
  }) : !0;
}
function Mn(e) {
  return process.env[e.toLowerCase()] || process.env[e.toUpperCase()] || "";
}
LE.getProxyForUrl = Sq;
var ip = { exports: {} }, so = { exports: {} }, io = { exports: {} }, Gl, zg;
function wq() {
  if (zg) return Gl;
  zg = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, s = n * 7, i = n * 365.25;
  Gl = function(l, d) {
    d = d || {};
    var g = typeof l;
    if (g === "string" && l.length > 0)
      return o(l);
    if (g === "number" && isFinite(l))
      return d.long ? c(l) : a(l);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function o(l) {
    if (l = String(l), !(l.length > 100)) {
<<<<<<< HEAD
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (f) {
        var m = parseFloat(f[1]), p = (f[2] || "ms").toLowerCase();
=======
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (d) {
        var g = parseFloat(d[1]), p = (d[2] || "ms").toLowerCase();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
<<<<<<< HEAD
            return m * s;
          case "weeks":
          case "week":
          case "w":
            return m * i;
          case "days":
          case "day":
          case "d":
            return m * n;
=======
            return g * i;
          case "weeks":
          case "week":
          case "w":
            return g * s;
          case "days":
          case "day":
          case "d":
            return g * n;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
<<<<<<< HEAD
            return m * r;
=======
            return g * r;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
<<<<<<< HEAD
            return m * t;
=======
            return g * t;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
<<<<<<< HEAD
            return m * e;
=======
            return g * e;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
<<<<<<< HEAD
            return m;
=======
            return g;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          default:
            return;
        }
      }
    }
  }
  function a(l) {
<<<<<<< HEAD
    var f = Math.abs(l);
    return f >= n ? Math.round(l / n) + "d" : f >= r ? Math.round(l / r) + "h" : f >= t ? Math.round(l / t) + "m" : f >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function c(l) {
    var f = Math.abs(l);
    return f >= n ? u(l, f, n, "day") : f >= r ? u(l, f, r, "hour") : f >= t ? u(l, f, t, "minute") : f >= e ? u(l, f, e, "second") : l + " ms";
  }
  function u(l, f, m, p) {
    var d = f >= m * 1.5;
    return Math.round(l / m) + " " + p + (d ? "s" : "");
  }
  return Cp;
}
var Ap, NE;
function J1() {
  if (NE) return Ap;
  NE = 1;
  function e(t) {
    n.debug = n, n.default = n, n.coerce = u, n.disable = a, n.enable = s, n.enabled = c, n.humanize = w8(), n.destroy = l, Object.keys(t).forEach((f) => {
      n[f] = t[f];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(f) {
      let m = 0;
      for (let p = 0; p < f.length; p++)
        m = (m << 5) - m + f.charCodeAt(p), m |= 0;
      return n.colors[Math.abs(m) % n.colors.length];
    }
    n.selectColor = r;
    function n(f) {
      let m, p = null, d, h;
      function _(...g) {
        if (!_.enabled)
          return;
        const v = _, y = Number(/* @__PURE__ */ new Date()), E = y - (m || y);
        v.diff = E, v.prev = m, v.curr = y, m = y, g[0] = n.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let R = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (C, V) => {
          if (C === "%%")
            return "%";
          R++;
          const b = n.formatters[V];
          if (typeof b == "function") {
            const F = g[R];
            C = b.call(v, F), g.splice(R, 1), R--;
          }
          return C;
        }), n.formatArgs.call(v, g), (v.log || n.log).apply(v, g);
      }
      return _.namespace = f, _.useColors = n.useColors(), _.color = n.selectColor(f), _.extend = i, _.destroy = n.destroy, Object.defineProperty(_, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (d !== n.namespaces && (d = n.namespaces, h = n.enabled(f)), h),
        set: (g) => {
          p = g;
        }
      }), typeof n.init == "function" && n.init(_), _;
    }
    function i(f, m) {
      const p = n(this.namespace + (typeof m > "u" ? ":" : m) + f);
      return p.log = this.log, p;
    }
    function s(f) {
      n.save(f), n.namespaces = f, n.names = [], n.skips = [];
      const m = (typeof f == "string" ? f : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const p of m)
        p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
    }
    function o(f, m) {
      let p = 0, d = 0, h = -1, _ = 0;
      for (; p < f.length; )
        if (d < m.length && (m[d] === f[p] || m[d] === "*"))
          m[d] === "*" ? (h = d, _ = p, d++) : (p++, d++);
        else if (h !== -1)
          d = h + 1, _++, p = _;
        else
          return !1;
      for (; d < m.length && m[d] === "*"; )
        d++;
      return d === m.length;
    }
    function a() {
      const f = [
        ...n.names,
        ...n.skips.map((m) => "-" + m)
      ].join(",");
      return n.enable(""), f;
    }
    function c(f) {
      for (const m of n.skips)
        if (o(f, m))
          return !1;
      for (const m of n.names)
        if (o(f, m))
          return !0;
      return !1;
    }
    function u(f) {
      return f instanceof Error ? f.stack || f.message : f;
=======
    var d = Math.abs(l);
    return d >= n ? Math.round(l / n) + "d" : d >= r ? Math.round(l / r) + "h" : d >= t ? Math.round(l / t) + "m" : d >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function c(l) {
    var d = Math.abs(l);
    return d >= n ? f(l, d, n, "day") : d >= r ? f(l, d, r, "hour") : d >= t ? f(l, d, t, "minute") : d >= e ? f(l, d, e, "second") : l + " ms";
  }
  function f(l, d, g, p) {
    var u = d >= g * 1.5;
    return Math.round(l / g) + " " + p + (u ? "s" : "");
  }
  return Gl;
}
var Wl, Ug;
function jE() {
  if (Ug) return Wl;
  Ug = 1;
  function e(t) {
    n.debug = n, n.default = n, n.coerce = f, n.disable = a, n.enable = i, n.enabled = c, n.humanize = wq(), n.destroy = l, Object.keys(t).forEach((d) => {
      n[d] = t[d];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(d) {
      let g = 0;
      for (let p = 0; p < d.length; p++)
        g = (g << 5) - g + d.charCodeAt(p), g |= 0;
      return n.colors[Math.abs(g) % n.colors.length];
    }
    n.selectColor = r;
    function n(d) {
      let g, p = null, u, h;
      function b(...m) {
        if (!b.enabled)
          return;
        const v = b, y = Number(/* @__PURE__ */ new Date()), _ = y - (g || y);
        v.diff = _, v.prev = g, v.curr = y, g = y, m[0] = n.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
        let R = 0;
        m[0] = m[0].replace(/%([a-zA-Z%])/g, (O, z) => {
          if (O === "%%")
            return "%";
          R++;
          const S = n.formatters[z];
          if (typeof S == "function") {
            const L = m[R];
            O = S.call(v, L), m.splice(R, 1), R--;
          }
          return O;
        }), n.formatArgs.call(v, m), (v.log || n.log).apply(v, m);
      }
      return b.namespace = d, b.useColors = n.useColors(), b.color = n.selectColor(d), b.extend = s, b.destroy = n.destroy, Object.defineProperty(b, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (u !== n.namespaces && (u = n.namespaces, h = n.enabled(d)), h),
        set: (m) => {
          p = m;
        }
      }), typeof n.init == "function" && n.init(b), b;
    }
    function s(d, g) {
      const p = n(this.namespace + (typeof g > "u" ? ":" : g) + d);
      return p.log = this.log, p;
    }
    function i(d) {
      n.save(d), n.namespaces = d, n.names = [], n.skips = [];
      const g = (typeof d == "string" ? d : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const p of g)
        p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
    }
    function o(d, g) {
      let p = 0, u = 0, h = -1, b = 0;
      for (; p < d.length; )
        if (u < g.length && (g[u] === d[p] || g[u] === "*"))
          g[u] === "*" ? (h = u, b = p, u++) : (p++, u++);
        else if (h !== -1)
          u = h + 1, b++, p = b;
        else
          return !1;
      for (; u < g.length && g[u] === "*"; )
        u++;
      return u === g.length;
    }
    function a() {
      const d = [
        ...n.names,
        ...n.skips.map((g) => "-" + g)
      ].join(",");
      return n.enable(""), d;
    }
    function c(d) {
      for (const g of n.skips)
        if (o(d, g))
          return !1;
      for (const g of n.names)
        if (o(d, g))
          return !0;
      return !1;
    }
    function f(d) {
      return d instanceof Error ? d.stack || d.message : d;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    function l() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
<<<<<<< HEAD
  return Ap = e, Ap;
}
var kE;
function S8() {
  return kE || (kE = 1, function(e, t) {
    t.formatArgs = n, t.save = i, t.load = s, t.useColors = r, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
=======
  return Wl = e, Wl;
}
var qg;
function Rq() {
  return qg || (qg = 1, function(e, t) {
    t.formatArgs = n, t.save = s, t.load = i, t.useColors = r, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      let c = !1;
      return () => {
        c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let c;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (c = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(c[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(c) {
      if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
<<<<<<< HEAD
      const u = "color: " + this.color;
      c.splice(1, 0, u, "color: inherit");
      let l = 0, f = 0;
      c[0].replace(/%[a-zA-Z%]/g, (m) => {
        m !== "%%" && (l++, m === "%c" && (f = l));
      }), c.splice(f, 0, u);
    }
    t.log = console.debug || console.log || (() => {
    });
    function i(c) {
=======
      const f = "color: " + this.color;
      c.splice(1, 0, f, "color: inherit");
      let l = 0, d = 0;
      c[0].replace(/%[a-zA-Z%]/g, (g) => {
        g !== "%%" && (l++, g === "%c" && (d = l));
      }), c.splice(d, 0, f);
    }
    t.log = console.debug || console.log || (() => {
    });
    function s(c) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      try {
        c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
      } catch {
      }
    }
<<<<<<< HEAD
    function s() {
=======
    function i() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      let c;
      try {
        c = t.storage.getItem("debug");
      } catch {
      }
      return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
<<<<<<< HEAD
    e.exports = J1()(t);
=======
    e.exports = jE()(t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const { formatters: a } = e.exports;
    a.j = function(c) {
      try {
        return JSON.stringify(c);
<<<<<<< HEAD
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(Xc, Xc.exports)), Xc.exports;
}
var Zc = { exports: {} }, Ip, DE;
function x8() {
  return DE || (DE = 1, Ip = (e, t = process.argv) => {
    const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
    return n !== -1 && (i === -1 || n < i);
  }), Ip;
}
var Np, LE;
function R8() {
  if (LE) return Np;
  LE = 1;
  const e = vu, t = kS, r = x8(), { env: n } = process;
  let i;
  r("no-color") || r("no-colors") || r("color=false") || r("color=never") ? i = 0 : (r("color") || r("colors") || r("color=true") || r("color=always")) && (i = 1), "FORCE_COLOR" in n && (n.FORCE_COLOR === "true" ? i = 1 : n.FORCE_COLOR === "false" ? i = 0 : i = n.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(n.FORCE_COLOR, 10), 3));
  function s(c) {
=======
      } catch (f) {
        return "[UnexpectedJSONParseError]: " + f.message;
      }
    };
  }(io, io.exports)), io.exports;
}
var oo = { exports: {} }, Kl, Hg;
function $q() {
  return Hg || (Hg = 1, Kl = (e, t = process.argv) => {
    const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), s = t.indexOf("--");
    return n !== -1 && (s === -1 || n < s);
  }), Kl;
}
var Jl, Bg;
function Tq() {
  if (Bg) return Jl;
  Bg = 1;
  const e = RS, t = _v, r = $q(), { env: n } = process;
  let s;
  r("no-color") || r("no-colors") || r("color=false") || r("color=never") ? s = 0 : (r("color") || r("colors") || r("color=true") || r("color=always")) && (s = 1), "FORCE_COLOR" in n && (n.FORCE_COLOR === "true" ? s = 1 : n.FORCE_COLOR === "false" ? s = 0 : s = n.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(n.FORCE_COLOR, 10), 3));
  function i(c) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return c === 0 ? !1 : {
      level: c,
      hasBasic: !0,
      has256: c >= 2,
      has16m: c >= 3
    };
  }
<<<<<<< HEAD
  function o(c, u) {
    if (i === 0)
=======
  function o(c, f) {
    if (s === 0)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return 0;
    if (r("color=16m") || r("color=full") || r("color=truecolor"))
      return 3;
    if (r("color=256"))
      return 2;
<<<<<<< HEAD
    if (c && !u && i === void 0)
      return 0;
    const l = i || 0;
    if (n.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const f = e.release().split(".");
      return Number(f[0]) >= 10 && Number(f[2]) >= 10586 ? Number(f[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in n)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((f) => f in n) || n.CI_NAME === "codeship" ? 1 : l;
=======
    if (c && !f && s === void 0)
      return 0;
    const l = s || 0;
    if (n.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const d = e.release().split(".");
      return Number(d[0]) >= 10 && Number(d[2]) >= 10586 ? Number(d[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in n)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((d) => d in n) || n.CI_NAME === "codeship" ? 1 : l;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    if ("TEAMCITY_VERSION" in n)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0;
    if (n.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in n) {
<<<<<<< HEAD
      const f = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (n.TERM_PROGRAM) {
        case "iTerm.app":
          return f >= 3 ? 3 : 2;
=======
      const d = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (n.TERM_PROGRAM) {
        case "iTerm.app":
          return d >= 3 ? 3 : 2;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(n.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(n.TERM) || "COLORTERM" in n ? 1 : l;
  }
  function a(c) {
<<<<<<< HEAD
    const u = o(c, c && c.isTTY);
    return s(u);
  }
  return Np = {
    supportsColor: a,
    stdout: s(o(!0, t.isatty(1))),
    stderr: s(o(!0, t.isatty(2)))
  }, Np;
}
var FE;
function $8() {
  return FE || (FE = 1, function(e, t) {
    const r = kS, n = wn;
    t.init = l, t.log = a, t.formatArgs = s, t.save = c, t.load = u, t.useColors = i, t.destroy = n.deprecate(
=======
    const f = o(c, c && c.isTTY);
    return i(f);
  }
  return Jl = {
    supportsColor: a,
    stdout: i(o(!0, t.isatty(1))),
    stderr: i(o(!0, t.isatty(2)))
  }, Jl;
}
var Vg;
function Oq() {
  return Vg || (Vg = 1, function(e, t) {
    const r = _v, n = gn;
    t.init = l, t.log = a, t.formatArgs = i, t.save = c, t.load = f, t.useColors = s, t.destroy = n.deprecate(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), t.colors = [6, 2, 3, 4, 5, 1];
    try {
<<<<<<< HEAD
      const m = R8();
      m && (m.stderr || m).level >= 2 && (t.colors = [
=======
      const g = Tq();
      g && (g.stderr || g).level >= 2 && (t.colors = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
<<<<<<< HEAD
    t.inspectOpts = Object.keys(process.env).filter((m) => /^debug_/i.test(m)).reduce((m, p) => {
      const d = p.substring(6).toLowerCase().replace(/_([a-z])/g, (_, g) => g.toUpperCase());
      let h = process.env[p];
      return /^(yes|on|true|enabled)$/i.test(h) ? h = !0 : /^(no|off|false|disabled)$/i.test(h) ? h = !1 : h === "null" ? h = null : h = Number(h), m[d] = h, m;
    }, {});
    function i() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : r.isatty(process.stderr.fd);
    }
    function s(m) {
      const { namespace: p, useColors: d } = this;
      if (d) {
        const h = this.color, _ = "\x1B[3" + (h < 8 ? h : "8;5;" + h), g = `  ${_};1m${p} \x1B[0m`;
        m[0] = g + m[0].split(`
`).join(`
` + g), m.push(_ + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        m[0] = o() + p + " " + m[0];
=======
    t.inspectOpts = Object.keys(process.env).filter((g) => /^debug_/i.test(g)).reduce((g, p) => {
      const u = p.substring(6).toLowerCase().replace(/_([a-z])/g, (b, m) => m.toUpperCase());
      let h = process.env[p];
      return /^(yes|on|true|enabled)$/i.test(h) ? h = !0 : /^(no|off|false|disabled)$/i.test(h) ? h = !1 : h === "null" ? h = null : h = Number(h), g[u] = h, g;
    }, {});
    function s() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : r.isatty(process.stderr.fd);
    }
    function i(g) {
      const { namespace: p, useColors: u } = this;
      if (u) {
        const h = this.color, b = "\x1B[3" + (h < 8 ? h : "8;5;" + h), m = `  ${b};1m${p} \x1B[0m`;
        g[0] = m + g[0].split(`
`).join(`
` + m), g.push(b + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        g[0] = o() + p + " " + g[0];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    function o() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
<<<<<<< HEAD
    function a(...m) {
      return process.stderr.write(n.formatWithOptions(t.inspectOpts, ...m) + `
`);
    }
    function c(m) {
      m ? process.env.DEBUG = m : delete process.env.DEBUG;
    }
    function u() {
      return process.env.DEBUG;
    }
    function l(m) {
      m.inspectOpts = {};
      const p = Object.keys(t.inspectOpts);
      for (let d = 0; d < p.length; d++)
        m.inspectOpts[p[d]] = t.inspectOpts[p[d]];
    }
    e.exports = J1()(t);
    const { formatters: f } = e.exports;
    f.o = function(m) {
      return this.inspectOpts.colors = this.useColors, n.inspect(m, this.inspectOpts).split(`
`).map((p) => p.trim()).join(" ");
    }, f.O = function(m) {
      return this.inspectOpts.colors = this.useColors, n.inspect(m, this.inspectOpts);
    };
  }(Zc, Zc.exports)), Zc.exports;
}
typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? jh.exports = S8() : jh.exports = $8();
var X1 = jh.exports, Fo, T8 = function() {
  if (!Fo) {
    try {
      Fo = X1("follow-redirects");
    } catch {
    }
    typeof Fo != "function" && (Fo = function() {
    });
  }
  Fo.apply(null, arguments);
}, ec = Hr, da = ec.URL, O8 = yu, P8 = am, xy = It.Writable, Ry = ka, Z1 = T8;
(function() {
  var t = typeof process < "u", r = typeof window < "u" && typeof document < "u", n = Hi(Error.captureStackTrace);
  !t && (r || !n) && console.warn("The follow-redirects package should be excluded from browser builds.");
})();
var $y = !1;
try {
  Ry(new da(""));
} catch (e) {
  $y = e.code === "ERR_INVALID_URL";
}
var C8 = [
=======
    function a(...g) {
      return process.stderr.write(n.formatWithOptions(t.inspectOpts, ...g) + `
`);
    }
    function c(g) {
      g ? process.env.DEBUG = g : delete process.env.DEBUG;
    }
    function f() {
      return process.env.DEBUG;
    }
    function l(g) {
      g.inspectOpts = {};
      const p = Object.keys(t.inspectOpts);
      for (let u = 0; u < p.length; u++)
        g.inspectOpts[p[u]] = t.inspectOpts[p[u]];
    }
    e.exports = jE()(t);
    const { formatters: d } = e.exports;
    d.o = function(g) {
      return this.inspectOpts.colors = this.useColors, n.inspect(g, this.inspectOpts).split(`
`).map((p) => p.trim()).join(" ");
    }, d.O = function(g) {
      return this.inspectOpts.colors = this.useColors, n.inspect(g, this.inspectOpts);
    };
  }(oo, oo.exports)), oo.exports;
}
var Gg;
function Cq() {
  return Gg || (Gg = 1, typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? so.exports = Rq() : so.exports = Oq()), so.exports;
}
var Is, Pq = function() {
  if (!Is) {
    try {
      Is = Cq()("follow-redirects");
    } catch {
    }
    typeof Is != "function" && (Is = function() {
    });
  }
  Is.apply(null, arguments);
}, xi = ni, Ys = xi.URL, Iq = qu, Nq = Hu, op = zt.Writable, ap = Uu, DE = Pq;
(function() {
  var t = typeof process < "u", r = typeof window < "u" && typeof document < "u", n = hn(Error.captureStackTrace);
  !t && (r || !n) && console.warn("The follow-redirects package should be excluded from browser builds.");
})();
var cp = !1;
try {
  ap(new Ys(""));
} catch (e) {
  cp = e.code === "ERR_INVALID_URL";
}
var Aq = [
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
<<<<<<< HEAD
], Ty = ["abort", "aborted", "connect", "error", "socket", "timeout"], Oy = /* @__PURE__ */ Object.create(null);
Ty.forEach(function(e) {
  Oy[e] = function(t, r, n) {
    this._redirectable.emit(e, t, r, n);
  };
});
var Uh = tc(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
), Mh = tc(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
), A8 = tc(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  Mh
), I8 = tc(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
), N8 = tc(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
), k8 = xy.prototype.destroy || eT;
function fr(e, t) {
  xy.call(this), this._sanitizeOptions(e), this._options = e, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], t && this.on("response", t);
=======
], lp = ["abort", "aborted", "connect", "error", "socket", "timeout"], up = /* @__PURE__ */ Object.create(null);
lp.forEach(function(e) {
  up[e] = function(t, r, n) {
    this._redirectable.emit(e, t, r, n);
  };
});
var Au = wi(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
), ku = wi(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
), kq = wi(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  ku
), Lq = wi(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
), jq = wi(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
), Dq = op.prototype.destroy || ME;
function Ot(e, t) {
  op.call(this), this._sanitizeOptions(e), this._options = e, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], t && this.on("response", t);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var r = this;
  this._onNativeResponse = function(n) {
    try {
      r._processResponse(n);
<<<<<<< HEAD
    } catch (i) {
      r.emit("error", i instanceof Mh ? i : new Mh({ cause: i }));
    }
  }, this._performRequest();
}
fr.prototype = Object.create(xy.prototype);
fr.prototype.abort = function() {
  Cy(this._currentRequest), this._currentRequest.abort(), this.emit("abort");
};
fr.prototype.destroy = function(e) {
  return Cy(this._currentRequest, e), k8.call(this, e), this;
};
fr.prototype.write = function(e, t, r) {
  if (this._ending)
    throw new N8();
  if (!ki(e) && !F8(e))
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  if (Hi(t) && (r = t, t = null), e.length === 0) {
    r && r();
    return;
  }
  this._requestBodyLength + e.length <= this._options.maxBodyLength ? (this._requestBodyLength += e.length, this._requestBodyBuffers.push({ data: e, encoding: t }), this._currentRequest.write(e, t, r)) : (this.emit("error", new I8()), this.abort());
};
fr.prototype.end = function(e, t, r) {
  if (Hi(e) ? (r = e, e = t = null) : Hi(t) && (r = t, t = null), !e)
    this._ended = this._ending = !0, this._currentRequest.end(null, null, r);
  else {
    var n = this, i = this._currentRequest;
    this.write(e, t, function() {
      n._ended = !0, i.end(null, null, r);
    }), this._ending = !0;
  }
};
fr.prototype.setHeader = function(e, t) {
  this._options.headers[e] = t, this._currentRequest.setHeader(e, t);
};
fr.prototype.removeHeader = function(e) {
  delete this._options.headers[e], this._currentRequest.removeHeader(e);
};
fr.prototype.setTimeout = function(e, t) {
=======
    } catch (s) {
      r.emit("error", s instanceof ku ? s : new ku({ cause: s }));
    }
  }, this._performRequest();
}
Ot.prototype = Object.create(op.prototype);
Ot.prototype.abort = function() {
  dp(this._currentRequest), this._currentRequest.abort(), this.emit("abort");
};
Ot.prototype.destroy = function(e) {
  return dp(this._currentRequest, e), Dq.call(this, e), this;
};
Ot.prototype.write = function(e, t, r) {
  if (this._ending)
    throw new jq();
  if (!un(e) && !zq(e))
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  if (hn(t) && (r = t, t = null), e.length === 0) {
    r && r();
    return;
  }
  this._requestBodyLength + e.length <= this._options.maxBodyLength ? (this._requestBodyLength += e.length, this._requestBodyBuffers.push({ data: e, encoding: t }), this._currentRequest.write(e, t, r)) : (this.emit("error", new Lq()), this.abort());
};
Ot.prototype.end = function(e, t, r) {
  if (hn(e) ? (r = e, e = t = null) : hn(t) && (r = t, t = null), !e)
    this._ended = this._ending = !0, this._currentRequest.end(null, null, r);
  else {
    var n = this, s = this._currentRequest;
    this.write(e, t, function() {
      n._ended = !0, s.end(null, null, r);
    }), this._ending = !0;
  }
};
Ot.prototype.setHeader = function(e, t) {
  this._options.headers[e] = t, this._currentRequest.setHeader(e, t);
};
Ot.prototype.removeHeader = function(e) {
  delete this._options.headers[e], this._currentRequest.removeHeader(e);
};
Ot.prototype.setTimeout = function(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var r = this;
  function n(o) {
    o.setTimeout(e), o.removeListener("timeout", o.destroy), o.addListener("timeout", o.destroy);
  }
<<<<<<< HEAD
  function i(o) {
    r._timeout && clearTimeout(r._timeout), r._timeout = setTimeout(function() {
      r.emit("timeout"), s();
    }, e), n(o);
  }
  function s() {
    r._timeout && (clearTimeout(r._timeout), r._timeout = null), r.removeListener("abort", s), r.removeListener("error", s), r.removeListener("response", s), r.removeListener("close", s), t && r.removeListener("timeout", t), r.socket || r._currentRequest.removeListener("socket", i);
  }
  return t && this.on("timeout", t), this.socket ? i(this.socket) : this._currentRequest.once("socket", i), this.on("socket", n), this.on("abort", s), this.on("error", s), this.on("response", s), this.on("close", s), this;
=======
  function s(o) {
    r._timeout && clearTimeout(r._timeout), r._timeout = setTimeout(function() {
      r.emit("timeout"), i();
    }, e), n(o);
  }
  function i() {
    r._timeout && (clearTimeout(r._timeout), r._timeout = null), r.removeListener("abort", i), r.removeListener("error", i), r.removeListener("response", i), r.removeListener("close", i), t && r.removeListener("timeout", t), r.socket || r._currentRequest.removeListener("socket", s);
  }
  return t && this.on("timeout", t), this.socket ? s(this.socket) : this._currentRequest.once("socket", s), this.on("socket", n), this.on("abort", i), this.on("error", i), this.on("response", i), this.on("close", i), this;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(e) {
<<<<<<< HEAD
  fr.prototype[e] = function(t, r) {
=======
  Ot.prototype[e] = function(t, r) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return this._currentRequest[e](t, r);
  };
});
["aborted", "connection", "socket"].forEach(function(e) {
<<<<<<< HEAD
  Object.defineProperty(fr.prototype, e, {
=======
  Object.defineProperty(Ot.prototype, e, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    get: function() {
      return this._currentRequest[e];
    }
  });
});
<<<<<<< HEAD
fr.prototype._sanitizeOptions = function(e) {
=======
Ot.prototype._sanitizeOptions = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (e.headers || (e.headers = {}), e.host && (e.hostname || (e.hostname = e.host), delete e.host), !e.pathname && e.path) {
    var t = e.path.indexOf("?");
    t < 0 ? e.pathname = e.path : (e.pathname = e.path.substring(0, t), e.search = e.path.substring(t));
  }
};
<<<<<<< HEAD
fr.prototype._performRequest = function() {
=======
Ot.prototype._performRequest = function() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var e = this._options.protocol, t = this._options.nativeProtocols[e];
  if (!t)
    throw new TypeError("Unsupported protocol " + e);
  if (this._options.agents) {
    var r = e.slice(0, -1);
    this._options.agent = this._options.agents[r];
  }
  var n = this._currentRequest = t.request(this._options, this._onNativeResponse);
  n._redirectable = this;
<<<<<<< HEAD
  for (var i of Ty)
    n.on(i, Oy[i]);
  if (this._currentUrl = /^\//.test(this._options.path) ? ec.format(this._options) : (
=======
  for (var s of lp)
    n.on(s, up[s]);
  if (this._currentUrl = /^\//.test(this._options.path) ? xi.format(this._options) : (
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path
  ), this._isRedirect) {
<<<<<<< HEAD
    var s = 0, o = this, a = this._requestBodyBuffers;
    (function c(u) {
      if (n === o._currentRequest)
        if (u)
          o.emit("error", u);
        else if (s < a.length) {
          var l = a[s++];
=======
    var i = 0, o = this, a = this._requestBodyBuffers;
    (function c(f) {
      if (n === o._currentRequest)
        if (f)
          o.emit("error", f);
        else if (i < a.length) {
          var l = a[i++];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          n.finished || n.write(l.data, l.encoding, c);
        } else o._ended && n.end();
    })();
  }
};
<<<<<<< HEAD
fr.prototype._processResponse = function(e) {
=======
Ot.prototype._processResponse = function(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var t = e.statusCode;
  this._options.trackRedirects && this._redirects.push({
    url: this._currentUrl,
    headers: e.headers,
    statusCode: t
  });
  var r = e.headers.location;
  if (!r || this._options.followRedirects === !1 || t < 300 || t >= 400) {
    e.responseUrl = this._currentUrl, e.redirects = this._redirects, this.emit("response", e), this._requestBodyBuffers = [];
    return;
  }
<<<<<<< HEAD
  if (Cy(this._currentRequest), e.destroy(), ++this._redirectCount > this._options.maxRedirects)
    throw new A8();
  var n, i = this._options.beforeRedirect;
  i && (n = Object.assign({
    // The Host header was set by nativeProtocol.request
    Host: e.req.getHeader("host")
  }, this._options.headers));
  var s = this._options.method;
=======
  if (dp(this._currentRequest), e.destroy(), ++this._redirectCount > this._options.maxRedirects)
    throw new kq();
  var n, s = this._options.beforeRedirect;
  s && (n = Object.assign({
    // The Host header was set by nativeProtocol.request
    Host: e.req.getHeader("host")
  }, this._options.headers));
  var i = this._options.method;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  ((t === 301 || t === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource […]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) […]
<<<<<<< HEAD
  t === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], kp(/^content-/i, this._options.headers));
  var o = kp(/^host$/i, this._options.headers), a = Py(this._currentUrl), c = o || a.host, u = /^\w+:/.test(r) ? this._currentUrl : ec.format(Object.assign(a, { host: c })), l = D8(r, u);
  if (Z1("redirecting to", l.href), this._isRedirect = !0, Hh(l, this._options), (l.protocol !== a.protocol && l.protocol !== "https:" || l.host !== c && !L8(l.host, c)) && kp(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers), Hi(i)) {
    var f = {
      headers: e.headers,
      statusCode: t
    }, m = {
      url: u,
      method: s,
      headers: n
    };
    i(this._options, f, m), this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function Q1(e) {
=======
  t === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], Yl(/^content-/i, this._options.headers));
  var o = Yl(/^host$/i, this._options.headers), a = fp(this._currentUrl), c = o || a.host, f = /^\w+:/.test(r) ? this._currentUrl : xi.format(Object.assign(a, { host: c })), l = Fq(r, f);
  if (DE("redirecting to", l.href), this._isRedirect = !0, Lu(l, this._options), (l.protocol !== a.protocol && l.protocol !== "https:" || l.host !== c && !Mq(l.host, c)) && Yl(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers), hn(s)) {
    var d = {
      headers: e.headers,
      statusCode: t
    }, g = {
      url: f,
      method: i,
      headers: n
    };
    s(this._options, d, g), this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function FE(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var t = {
    maxRedirects: 21,
    maxBodyLength: 10485760
  }, r = {};
  return Object.keys(e).forEach(function(n) {
<<<<<<< HEAD
    var i = n + ":", s = r[i] = e[n], o = t[n] = Object.create(s);
    function a(u, l, f) {
      return j8(u) ? u = Hh(u) : ki(u) ? u = Hh(Py(u)) : (f = l, l = tT(u), u = { protocol: i }), Hi(l) && (f = l, l = null), l = Object.assign({
        maxRedirects: t.maxRedirects,
        maxBodyLength: t.maxBodyLength
      }, u, l), l.nativeProtocols = r, !ki(l.host) && !ki(l.hostname) && (l.hostname = "::1"), Ry.equal(l.protocol, i, "protocol mismatch"), Z1("options", l), new fr(l, f);
    }
    function c(u, l, f) {
      var m = o.request(u, l, f);
      return m.end(), m;
=======
    var s = n + ":", i = r[s] = e[n], o = t[n] = Object.create(i);
    function a(f, l, d) {
      return Uq(f) ? f = Lu(f) : un(f) ? f = Lu(fp(f)) : (d = l, l = zE(f), f = { protocol: s }), hn(l) && (d = l, l = null), l = Object.assign({
        maxRedirects: t.maxRedirects,
        maxBodyLength: t.maxBodyLength
      }, f, l), l.nativeProtocols = r, !un(l.host) && !un(l.hostname) && (l.hostname = "::1"), ap.equal(l.protocol, s, "protocol mismatch"), DE("options", l), new Ot(l, d);
    }
    function c(f, l, d) {
      var g = o.request(f, l, d);
      return g.end(), g;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    Object.defineProperties(o, {
      request: { value: a, configurable: !0, enumerable: !0, writable: !0 },
      get: { value: c, configurable: !0, enumerable: !0, writable: !0 }
    });
  }), t;
}
<<<<<<< HEAD
function eT() {
}
function Py(e) {
  var t;
  if ($y)
    t = new da(e);
  else if (t = tT(ec.parse(e)), !ki(t.protocol))
    throw new Uh({ input: e });
  return t;
}
function D8(e, t) {
  return $y ? new da(e, t) : Py(ec.resolve(t, e));
}
function tT(e) {
  if (/^\[/.test(e.hostname) && !/^\[[:0-9a-f]+\]$/i.test(e.hostname))
    throw new Uh({ input: e.href || e });
  if (/^\[/.test(e.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(e.host))
    throw new Uh({ input: e.href || e });
  return e;
}
function Hh(e, t) {
  var r = t || {};
  for (var n of C8)
    r[n] = e[n];
  return r.hostname.startsWith("[") && (r.hostname = r.hostname.slice(1, -1)), r.port !== "" && (r.port = Number(r.port)), r.path = r.search ? r.pathname + r.search : r.pathname, r;
}
function kp(e, t) {
=======
function ME() {
}
function fp(e) {
  var t;
  if (cp)
    t = new Ys(e);
  else if (t = zE(xi.parse(e)), !un(t.protocol))
    throw new Au({ input: e });
  return t;
}
function Fq(e, t) {
  return cp ? new Ys(e, t) : fp(xi.resolve(t, e));
}
function zE(e) {
  if (/^\[/.test(e.hostname) && !/^\[[:0-9a-f]+\]$/i.test(e.hostname))
    throw new Au({ input: e.href || e });
  if (/^\[/.test(e.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(e.host))
    throw new Au({ input: e.href || e });
  return e;
}
function Lu(e, t) {
  var r = t || {};
  for (var n of Aq)
    r[n] = e[n];
  return r.hostname.startsWith("[") && (r.hostname = r.hostname.slice(1, -1)), r.port !== "" && (r.port = Number(r.port)), r.path = r.search ? r.pathname + r.search : r.pathname, r;
}
function Yl(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  var r;
  for (var n in t)
    e.test(n) && (r = t[n], delete t[n]);
  return r === null || typeof r > "u" ? void 0 : String(r).trim();
}
<<<<<<< HEAD
function tc(e, t, r) {
  function n(i) {
    Hi(Error.captureStackTrace) && Error.captureStackTrace(this, this.constructor), Object.assign(this, i || {}), this.code = e, this.message = this.cause ? t + ": " + this.cause.message : t;
=======
function wi(e, t, r) {
  function n(s) {
    hn(Error.captureStackTrace) && Error.captureStackTrace(this, this.constructor), Object.assign(this, s || {}), this.code = e, this.message = this.cause ? t + ": " + this.cause.message : t;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  return n.prototype = new (r || Error)(), Object.defineProperties(n.prototype, {
    constructor: {
      value: n,
      enumerable: !1
    },
    name: {
      value: "Error [" + e + "]",
      enumerable: !1
    }
  }), n;
}
<<<<<<< HEAD
function Cy(e, t) {
  for (var r of Ty)
    e.removeListener(r, Oy[r]);
  e.on("error", eT), e.destroy(t);
}
function L8(e, t) {
  Ry(ki(e) && ki(t));
  var r = e.length - t.length - 1;
  return r > 0 && e[r] === "." && e.endsWith(t);
}
function ki(e) {
  return typeof e == "string" || e instanceof String;
}
function Hi(e) {
  return typeof e == "function";
}
function F8(e) {
  return typeof e == "object" && "length" in e;
}
function j8(e) {
  return da && e instanceof da;
}
Sy.exports = Q1({ http: O8, https: P8 });
Sy.exports.wrap = Q1;
var U8 = Sy.exports;
const M8 = /* @__PURE__ */ Da(U8), Zl = "1.8.4";
function rT(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
const H8 = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function q8(e, t, r) {
  const n = r && r.Blob || st.classes.Blob, i = rT(e);
  if (t === void 0 && n && (t = !0), i === "data") {
    e = i.length ? e.slice(i.length + 1) : e;
    const s = H8.exec(e);
    if (!s)
      throw new ae("Invalid URL", ae.ERR_INVALID_URL);
    const o = s[1], a = s[2], c = s[3], u = Buffer.from(decodeURIComponent(c), a ? "base64" : "utf8");
    if (t) {
      if (!n)
        throw new ae("Blob is not supported", ae.ERR_NOT_SUPPORT);
      return new n([u], { type: o });
    }
    return u;
  }
  throw new ae("Unsupported protocol " + i, ae.ERR_NOT_SUPPORT);
}
const Dp = Symbol("internals");
class jE extends It.Transform {
  constructor(t) {
    t = Z.toFlatObject(t, {
=======
function dp(e, t) {
  for (var r of lp)
    e.removeListener(r, up[r]);
  e.on("error", ME), e.destroy(t);
}
function Mq(e, t) {
  ap(un(e) && un(t));
  var r = e.length - t.length - 1;
  return r > 0 && e[r] === "." && e.endsWith(t);
}
function un(e) {
  return typeof e == "string" || e instanceof String;
}
function hn(e) {
  return typeof e == "function";
}
function zq(e) {
  return typeof e == "object" && "length" in e;
}
function Uq(e) {
  return Ys && e instanceof Ys;
}
ip.exports = FE({ http: Iq, https: Nq });
ip.exports.wrap = FE;
var qq = ip.exports;
const Hq = /* @__PURE__ */ si(qq), Jo = "1.8.4";
function UE(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
const Bq = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function Vq(e, t, r) {
  const n = r && r.Blob || qe.classes.Blob, s = UE(e);
  if (t === void 0 && n && (t = !0), s === "data") {
    e = s.length ? e.slice(s.length + 1) : e;
    const i = Bq.exec(e);
    if (!i)
      throw new se("Invalid URL", se.ERR_INVALID_URL);
    const o = i[1], a = i[2], c = i[3], f = Buffer.from(decodeURIComponent(c), a ? "base64" : "utf8");
    if (t) {
      if (!n)
        throw new se("Blob is not supported", se.ERR_NOT_SUPPORT);
      return new n([f], { type: o });
    }
    return f;
  }
  throw new se("Unsupported protocol " + s, se.ERR_NOT_SUPPORT);
}
const Xl = Symbol("internals");
class Wg extends zt.Transform {
  constructor(t) {
    t = B.toFlatObject(t, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
<<<<<<< HEAD
    }, null, (n, i) => !Z.isUndefined(i[n])), super({
      readableHighWaterMark: t.chunkSize
    });
    const r = this[Dp] = {
=======
    }, null, (n, s) => !B.isUndefined(s[n])), super({
      readableHighWaterMark: t.chunkSize
    });
    const r = this[Xl] = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      timeWindow: t.timeWindow,
      chunkSize: t.chunkSize,
      maxRate: t.maxRate,
      minChunkSize: t.minChunkSize,
      bytesSeen: 0,
      isCaptured: !1,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (n) => {
      n === "progress" && (r.isCaptured || (r.isCaptured = !0));
    });
  }
  _read(t) {
<<<<<<< HEAD
    const r = this[Dp];
    return r.onReadCallback && r.onReadCallback(), super._read(t);
  }
  _transform(t, r, n) {
    const i = this[Dp], s = i.maxRate, o = this.readableHighWaterMark, a = i.timeWindow, c = 1e3 / a, u = s / c, l = i.minChunkSize !== !1 ? Math.max(i.minChunkSize, u * 0.01) : 0, f = (p, d) => {
      const h = Buffer.byteLength(p);
      i.bytesSeen += h, i.bytes += h, i.isCaptured && this.emit("progress", i.bytesSeen), this.push(p) ? process.nextTick(d) : i.onReadCallback = () => {
        i.onReadCallback = null, process.nextTick(d);
      };
    }, m = (p, d) => {
      const h = Buffer.byteLength(p);
      let _ = null, g = o, v, y = 0;
      if (s) {
        const E = Date.now();
        (!i.ts || (y = E - i.ts) >= a) && (i.ts = E, v = u - i.bytes, i.bytes = v < 0 ? -v : 0, y = 0), v = u - i.bytes;
      }
      if (s) {
        if (v <= 0)
          return setTimeout(() => {
            d(null, p);
          }, a - y);
        v < g && (g = v);
      }
      g && h > g && h - g > l && (_ = p.subarray(g), p = p.subarray(0, g)), f(p, _ ? () => {
        process.nextTick(d, null, _);
      } : d);
    };
    m(t, function p(d, h) {
      if (d)
        return n(d);
      h ? m(h, p) : n(null);
    });
  }
}
const { asyncIterator: UE } = Symbol, nT = async function* (e) {
  e.stream ? yield* e.stream() : e.arrayBuffer ? yield await e.arrayBuffer() : e[UE] ? yield* e[UE]() : yield e;
}, B8 = st.ALPHABET.ALPHA_DIGIT + "-_", pa = typeof TextEncoder == "function" ? new TextEncoder() : new wn.TextEncoder(), zn = `\r
`, z8 = pa.encode(zn), V8 = 2;
class G8 {
  constructor(t, r) {
    const { escapeName: n } = this.constructor, i = Z.isString(r);
    let s = `Content-Disposition: form-data; name="${n(t)}"${!i && r.name ? `; filename="${n(r.name)}"` : ""}${zn}`;
    i ? r = pa.encode(String(r).replace(/\r?\n|\r\n?/g, zn)) : s += `Content-Type: ${r.type || "application/octet-stream"}${zn}`, this.headers = pa.encode(s + zn), this.contentLength = i ? r.byteLength : r.size, this.size = this.headers.byteLength + this.contentLength + V8, this.name = t, this.value = r;
=======
    const r = this[Xl];
    return r.onReadCallback && r.onReadCallback(), super._read(t);
  }
  _transform(t, r, n) {
    const s = this[Xl], i = s.maxRate, o = this.readableHighWaterMark, a = s.timeWindow, c = 1e3 / a, f = i / c, l = s.minChunkSize !== !1 ? Math.max(s.minChunkSize, f * 0.01) : 0, d = (p, u) => {
      const h = Buffer.byteLength(p);
      s.bytesSeen += h, s.bytes += h, s.isCaptured && this.emit("progress", s.bytesSeen), this.push(p) ? process.nextTick(u) : s.onReadCallback = () => {
        s.onReadCallback = null, process.nextTick(u);
      };
    }, g = (p, u) => {
      const h = Buffer.byteLength(p);
      let b = null, m = o, v, y = 0;
      if (i) {
        const _ = Date.now();
        (!s.ts || (y = _ - s.ts) >= a) && (s.ts = _, v = f - s.bytes, s.bytes = v < 0 ? -v : 0, y = 0), v = f - s.bytes;
      }
      if (i) {
        if (v <= 0)
          return setTimeout(() => {
            u(null, p);
          }, a - y);
        v < m && (m = v);
      }
      m && h > m && h - m > l && (b = p.subarray(m), p = p.subarray(0, m)), d(p, b ? () => {
        process.nextTick(u, null, b);
      } : u);
    };
    g(t, function p(u, h) {
      if (u)
        return n(u);
      h ? g(h, p) : n(null);
    });
  }
}
const { asyncIterator: Kg } = Symbol, qE = async function* (e) {
  e.stream ? yield* e.stream() : e.arrayBuffer ? yield await e.arrayBuffer() : e[Kg] ? yield* e[Kg]() : yield e;
}, Gq = qe.ALPHABET.ALPHA_DIGIT + "-_", Xs = typeof TextEncoder == "function" ? new TextEncoder() : new gn.TextEncoder(), Mr = `\r
`, Wq = Xs.encode(Mr), Kq = 2;
class Jq {
  constructor(t, r) {
    const { escapeName: n } = this.constructor, s = B.isString(r);
    let i = `Content-Disposition: form-data; name="${n(t)}"${!s && r.name ? `; filename="${n(r.name)}"` : ""}${Mr}`;
    s ? r = Xs.encode(String(r).replace(/\r?\n|\r\n?/g, Mr)) : i += `Content-Type: ${r.type || "application/octet-stream"}${Mr}`, this.headers = Xs.encode(i + Mr), this.contentLength = s ? r.byteLength : r.size, this.size = this.headers.byteLength + this.contentLength + Kq, this.name = t, this.value = r;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  async *encode() {
    yield this.headers;
    const { value: t } = this;
<<<<<<< HEAD
    Z.isTypedArray(t) ? yield t : yield* nT(t), yield z8;
=======
    B.isTypedArray(t) ? yield t : yield* qE(t), yield Wq;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  static escapeName(t) {
    return String(t).replace(/[\r\n"]/g, (r) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[r]);
  }
}
<<<<<<< HEAD
const W8 = (e, t, r) => {
  const {
    tag: n = "form-data-boundary",
    size: i = 25,
    boundary: s = n + "-" + st.generateString(i, B8)
  } = r || {};
  if (!Z.isFormData(e))
    throw TypeError("FormData instance required");
  if (s.length < 1 || s.length > 70)
    throw Error("boundary must be 10-70 characters long");
  const o = pa.encode("--" + s + zn), a = pa.encode("--" + s + "--" + zn + zn);
  let c = a.byteLength;
  const u = Array.from(e.entries()).map(([f, m]) => {
    const p = new G8(f, m);
    return c += p.size, p;
  });
  c += o.byteLength * u.length, c = Z.toFiniteNumber(c);
  const l = {
    "Content-Type": `multipart/form-data; boundary=${s}`
  };
  return Number.isFinite(c) && (l["Content-Length"] = c), t && t(l), wC.from(async function* () {
    for (const f of u)
      yield o, yield* f.encode();
    yield a;
  }());
};
class K8 extends It.Transform {
=======
const Yq = (e, t, r) => {
  const {
    tag: n = "form-data-boundary",
    size: s = 25,
    boundary: i = n + "-" + qe.generateString(s, Gq)
  } = r || {};
  if (!B.isFormData(e))
    throw TypeError("FormData instance required");
  if (i.length < 1 || i.length > 70)
    throw Error("boundary must be 10-70 characters long");
  const o = Xs.encode("--" + i + Mr), a = Xs.encode("--" + i + "--" + Mr + Mr);
  let c = a.byteLength;
  const f = Array.from(e.entries()).map(([d, g]) => {
    const p = new Jq(d, g);
    return c += p.size, p;
  });
  c += o.byteLength * f.length, c = B.toFiniteNumber(c);
  const l = {
    "Content-Type": `multipart/form-data; boundary=${i}`
  };
  return Number.isFinite(c) && (l["Content-Length"] = c), t && t(l), wS.from(async function* () {
    for (const d of f)
      yield o, yield* d.encode();
    yield a;
  }());
};
class Xq extends zt.Transform {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  __transform(t, r, n) {
    this.push(t), n();
  }
  _transform(t, r, n) {
    if (t.length !== 0 && (this._transform = this.__transform, t[0] !== 120)) {
<<<<<<< HEAD
      const i = Buffer.alloc(2);
      i[0] = 120, i[1] = 156, this.push(i, r);
=======
      const s = Buffer.alloc(2);
      s[0] = 120, s[1] = 156, this.push(s, r);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    this.__transform(t, r, n);
  }
}
<<<<<<< HEAD
const Y8 = (e, t) => Z.isAsyncFn(e) ? function(...r) {
  const n = r.pop();
  e.apply(this, r).then((i) => {
    try {
      t ? n(null, ...t(i)) : n(null, i);
    } catch (s) {
      n(s);
    }
  }, n);
} : e;
function J8(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let i = 0, s = 0, o;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const u = Date.now(), l = n[s];
    o || (o = u), r[i] = c, n[i] = u;
    let f = s, m = 0;
    for (; f !== i; )
      m += r[f++], f = f % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), u - o < t)
      return;
    const p = l && u - l;
    return p ? Math.round(m * 1e3 / p) : void 0;
  };
}
function X8(e, t) {
  let r = 0, n = 1e3 / t, i, s;
  const o = (u, l = Date.now()) => {
    r = l, i = null, s && (clearTimeout(s), s = null), e.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), f = l - r;
    f >= n ? o(u, l) : (i = u, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - f)));
  }, () => i && o(i)];
}
const Gs = (e, t, r = 3) => {
  let n = 0;
  const i = J8(50, 250);
  return X8((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, c = o - n, u = i(c), l = o <= a;
    n = o;
    const f = {
=======
const Zq = (e, t) => B.isAsyncFn(e) ? function(...r) {
  const n = r.pop();
  e.apply(this, r).then((s) => {
    try {
      t ? n(null, ...t(s)) : n(null, s);
    } catch (i) {
      n(i);
    }
  }, n);
} : e;
function Qq(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let s = 0, i = 0, o;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const f = Date.now(), l = n[i];
    o || (o = f), r[s] = c, n[s] = f;
    let d = i, g = 0;
    for (; d !== s; )
      g += r[d++], d = d % e;
    if (s = (s + 1) % e, s === i && (i = (i + 1) % e), f - o < t)
      return;
    const p = l && f - l;
    return p ? Math.round(g * 1e3 / p) : void 0;
  };
}
function eH(e, t) {
  let r = 0, n = 1e3 / t, s, i;
  const o = (f, l = Date.now()) => {
    r = l, s = null, i && (clearTimeout(i), i = null), e.apply(null, f);
  };
  return [(...f) => {
    const l = Date.now(), d = l - r;
    d >= n ? o(f, l) : (s = f, i || (i = setTimeout(() => {
      i = null, o(s);
    }, n - d)));
  }, () => s && o(s)];
}
const es = (e, t, r = 3) => {
  let n = 0;
  const s = Qq(50, 250);
  return eH((i) => {
    const o = i.loaded, a = i.lengthComputable ? i.total : void 0, c = o - n, f = s(c), l = o <= a;
    n = o;
    const d = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
<<<<<<< HEAD
      rate: u || void 0,
      estimated: u && a && l ? (a - o) / u : void 0,
      event: s,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, r);
}, Ql = (e, t) => {
=======
      rate: f || void 0,
      estimated: f && a && l ? (a - o) / f : void 0,
      event: i,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(d);
  }, r);
}, Yo = (e, t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
<<<<<<< HEAD
}, eu = (e) => (...t) => Z.asap(() => e(...t)), ME = {
  flush: Or.constants.Z_SYNC_FLUSH,
  finishFlush: Or.constants.Z_SYNC_FLUSH
}, Z8 = {
  flush: Or.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: Or.constants.BROTLI_OPERATION_FLUSH
}, HE = Z.isFunction(Or.createBrotliDecompress), { http: Q8, https: eG } = M8, tG = /https:?/, qE = st.protocols.map((e) => e + ":"), BE = (e, [t, r]) => (e.on("end", r).on("error", r), t);
function rG(e, t) {
  e.beforeRedirects.proxy && e.beforeRedirects.proxy(e), e.beforeRedirects.config && e.beforeRedirects.config(e, t);
}
function iT(e, t, r) {
  let n = t;
  if (!n && n !== !1) {
    const i = Y1.getProxyForUrl(r);
    i && (n = new URL(i));
=======
}, Xo = (e) => (...t) => B.asap(() => e(...t)), Jg = {
  flush: fr.constants.Z_SYNC_FLUSH,
  finishFlush: fr.constants.Z_SYNC_FLUSH
}, tH = {
  flush: fr.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: fr.constants.BROTLI_OPERATION_FLUSH
}, Yg = B.isFunction(fr.createBrotliDecompress), { http: rH, https: nH } = Hq, sH = /https:?/, Xg = qe.protocols.map((e) => e + ":"), Zg = (e, [t, r]) => (e.on("end", r).on("error", r), t);
function iH(e, t) {
  e.beforeRedirects.proxy && e.beforeRedirects.proxy(e), e.beforeRedirects.config && e.beforeRedirects.config(e, t);
}
function HE(e, t, r) {
  let n = t;
  if (!n && n !== !1) {
    const s = LE.getProxyForUrl(r);
    s && (n = new URL(s));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  if (n) {
    if (n.username && (n.auth = (n.username || "") + ":" + (n.password || "")), n.auth) {
      (n.auth.username || n.auth.password) && (n.auth = (n.auth.username || "") + ":" + (n.auth.password || ""));
<<<<<<< HEAD
      const s = Buffer.from(n.auth, "utf8").toString("base64");
      e.headers["Proxy-Authorization"] = "Basic " + s;
    }
    e.headers.host = e.hostname + (e.port ? ":" + e.port : "");
    const i = n.hostname || n.host;
    e.hostname = i, e.host = i, e.port = n.port, e.path = r, n.protocol && (e.protocol = n.protocol.includes(":") ? n.protocol : `${n.protocol}:`);
  }
  e.beforeRedirects.proxy = function(s) {
    iT(s, t, s.href);
  };
}
const nG = typeof process < "u" && Z.kindOf(process) === "process", iG = (e) => new Promise((t, r) => {
  let n, i;
  const s = (c, u) => {
    i || (i = !0, n && n(c, u));
  }, o = (c) => {
    s(c), t(c);
  }, a = (c) => {
    s(c, !0), r(c);
  };
  e(o, a, (c) => n = c).catch(a);
}), sG = ({ address: e, family: t }) => {
  if (!Z.isString(e))
=======
      const i = Buffer.from(n.auth, "utf8").toString("base64");
      e.headers["Proxy-Authorization"] = "Basic " + i;
    }
    e.headers.host = e.hostname + (e.port ? ":" + e.port : "");
    const s = n.hostname || n.host;
    e.hostname = s, e.host = s, e.port = n.port, e.path = r, n.protocol && (e.protocol = n.protocol.includes(":") ? n.protocol : `${n.protocol}:`);
  }
  e.beforeRedirects.proxy = function(i) {
    HE(i, t, i.href);
  };
}
const oH = typeof process < "u" && B.kindOf(process) === "process", aH = (e) => new Promise((t, r) => {
  let n, s;
  const i = (c, f) => {
    s || (s = !0, n && n(c, f));
  }, o = (c) => {
    i(c), t(c);
  }, a = (c) => {
    i(c, !0), r(c);
  };
  e(o, a, (c) => n = c).catch(a);
}), cH = ({ address: e, family: t }) => {
  if (!B.isString(e))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    throw TypeError("address must be a string");
  return {
    address: e,
    family: t || (e.indexOf(".") < 0 ? 6 : 4)
  };
<<<<<<< HEAD
}, zE = (e, t) => sG(Z.isObject(e) ? e : { address: e, family: t }), oG = nG && function(t) {
  return iG(async function(n, i, s) {
    let { data: o, lookup: a, family: c } = t;
    const { responseType: u, responseEncoding: l } = t, f = t.method.toUpperCase();
    let m, p = !1, d;
    if (a) {
      const D = Y8(a, (I) => Z.isArray(I) ? I : [I]);
      a = (I, L, j) => {
        D(I, L, (k, U, M) => {
          if (k)
            return j(k);
          const T = Z.isArray(U) ? U.map((N) => zE(N)) : [zE(U, M)];
          L.all ? j(k, T) : j(k, T[0].address, T[0].family);
        });
      };
    }
    const h = new yC(), _ = () => {
      t.cancelToken && t.cancelToken.unsubscribe(g), t.signal && t.signal.removeEventListener("abort", g), h.removeAllListeners();
    };
    s((D, I) => {
      m = !0, I && (p = !0, _());
    });
    function g(D) {
      h.emit("abort", !D || D.type ? new Xn(null, t, d) : D);
    }
    h.once("abort", i), (t.cancelToken || t.signal) && (t.cancelToken && t.cancelToken.subscribe(g), t.signal && (t.signal.aborted ? g() : t.signal.addEventListener("abort", g)));
    const v = wy(t.baseURL, t.url, t.allowAbsoluteUrls), y = new URL(v, st.hasBrowserEnv ? st.origin : void 0), E = y.protocol || qE[0];
    if (E === "data:") {
      let D;
      if (f !== "GET")
        return Ss(n, i, {
=======
}, Qg = (e, t) => cH(B.isObject(e) ? e : { address: e, family: t }), lH = oH && function(t) {
  return aH(async function(n, s, i) {
    let { data: o, lookup: a, family: c } = t;
    const { responseType: f, responseEncoding: l } = t, d = t.method.toUpperCase();
    let g, p = !1, u;
    if (a) {
      const j = Zq(a, (C) => B.isArray(C) ? C : [C]);
      a = (C, A, k) => {
        j(C, A, (P, D, F) => {
          if (P)
            return k(P);
          const w = B.isArray(D) ? D.map((N) => Qg(N)) : [Qg(D, F)];
          A.all ? k(P, w) : k(P, w[0].address, w[0].family);
        });
      };
    }
    const h = new bS(), b = () => {
      t.cancelToken && t.cancelToken.unsubscribe(m), t.signal && t.signal.removeEventListener("abort", m), h.removeAllListeners();
    };
    i((j, C) => {
      g = !0, C && (p = !0, b());
    });
    function m(j) {
      h.emit("abort", !j || j.type ? new Hr(null, t, u) : j);
    }
    h.once("abort", s), (t.cancelToken || t.signal) && (t.cancelToken && t.cancelToken.subscribe(m), t.signal && (t.signal.aborted ? m() : t.signal.addEventListener("abort", m)));
    const v = sp(t.baseURL, t.url, t.allowAbsoluteUrls), y = new URL(v, qe.hasBrowserEnv ? qe.origin : void 0), _ = y.protocol || Xg[0];
    if (_ === "data:") {
      let j;
      if (d !== "GET")
        return Fn(n, s, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: t
        });
      try {
<<<<<<< HEAD
        D = q8(t.url, u === "blob", {
          Blob: t.env && t.env.Blob
        });
      } catch (I) {
        throw ae.from(I, ae.ERR_BAD_REQUEST, t);
      }
      return u === "text" ? (D = D.toString(l), (!l || l === "utf8") && (D = Z.stripBOM(D))) : u === "stream" && (D = It.Readable.from(D)), Ss(n, i, {
        data: D,
        status: 200,
        statusText: "OK",
        headers: new Lt(),
        config: t
      });
    }
    if (qE.indexOf(E) === -1)
      return i(new ae(
        "Unsupported protocol " + E,
        ae.ERR_BAD_REQUEST,
        t
      ));
    const R = Lt.from(t.headers).normalize();
    R.set("User-Agent", "axios/" + Zl, !1);
    const { onUploadProgress: w, onDownloadProgress: C } = t, V = t.maxRate;
    let b, F;
    if (Z.isSpecCompliantForm(o)) {
      const D = R.getContentType(/boundary=([-_\w\d]{10,70})/i);
      o = W8(o, (I) => {
        R.set(I);
      }, {
        tag: `axios-${Zl}-boundary`,
        boundary: D && D[1] || void 0
      });
    } else if (Z.isFormData(o) && Z.isFunction(o.getHeaders)) {
      if (R.set(o.getHeaders()), !R.hasContentLength())
        try {
          const D = await wn.promisify(o.getLength).call(o);
          Number.isFinite(D) && D >= 0 && R.setContentLength(D);
        } catch {
        }
    } else if (Z.isBlob(o) || Z.isFile(o))
      o.size && R.setContentType(o.type || "application/octet-stream"), R.setContentLength(o.size || 0), o = It.Readable.from(nT(o));
    else if (o && !Z.isStream(o)) {
      if (!Buffer.isBuffer(o)) if (Z.isArrayBuffer(o))
        o = Buffer.from(new Uint8Array(o));
      else if (Z.isString(o))
        o = Buffer.from(o, "utf-8");
      else
        return i(new ae(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          ae.ERR_BAD_REQUEST,
          t
        ));
      if (R.setContentLength(o.length, !1), t.maxBodyLength > -1 && o.length > t.maxBodyLength)
        return i(new ae(
          "Request body larger than maxBodyLength limit",
          ae.ERR_BAD_REQUEST,
          t
        ));
    }
    const H = Z.toFiniteNumber(R.getContentLength());
    Z.isArray(V) ? (b = V[0], F = V[1]) : b = F = V, o && (w || b) && (Z.isStream(o) || (o = It.Readable.from(o, { objectMode: !1 })), o = It.pipeline([o, new jE({
      maxRate: Z.toFiniteNumber(b)
    })], Z.noop), w && o.on("progress", BE(
      o,
      Ql(
        H,
        Gs(eu(w), !1, 3)
      )
    )));
    let q;
    if (t.auth) {
      const D = t.auth.username || "", I = t.auth.password || "";
      q = D + ":" + I;
    }
    if (!q && y.username) {
      const D = y.username, I = y.password;
      q = D + ":" + I;
    }
    q && R.delete("authorization");
    let $;
    try {
      $ = _y(
=======
        j = Vq(t.url, f === "blob", {
          Blob: t.env && t.env.Blob
        });
      } catch (C) {
        throw se.from(C, se.ERR_BAD_REQUEST, t);
      }
      return f === "text" ? (j = j.toString(l), (!l || l === "utf8") && (j = B.stripBOM(j))) : f === "stream" && (j = zt.Readable.from(j)), Fn(n, s, {
        data: j,
        status: 200,
        statusText: "OK",
        headers: new pt(),
        config: t
      });
    }
    if (Xg.indexOf(_) === -1)
      return s(new se(
        "Unsupported protocol " + _,
        se.ERR_BAD_REQUEST,
        t
      ));
    const R = pt.from(t.headers).normalize();
    R.set("User-Agent", "axios/" + Jo, !1);
    const { onUploadProgress: E, onDownloadProgress: O } = t, z = t.maxRate;
    let S, L;
    if (B.isSpecCompliantForm(o)) {
      const j = R.getContentType(/boundary=([-_\w\d]{10,70})/i);
      o = Yq(o, (C) => {
        R.set(C);
      }, {
        tag: `axios-${Jo}-boundary`,
        boundary: j && j[1] || void 0
      });
    } else if (B.isFormData(o) && B.isFunction(o.getHeaders)) {
      if (R.set(o.getHeaders()), !R.hasContentLength())
        try {
          const j = await gn.promisify(o.getLength).call(o);
          Number.isFinite(j) && j >= 0 && R.setContentLength(j);
        } catch {
        }
    } else if (B.isBlob(o) || B.isFile(o))
      o.size && R.setContentType(o.type || "application/octet-stream"), R.setContentLength(o.size || 0), o = zt.Readable.from(qE(o));
    else if (o && !B.isStream(o)) {
      if (!Buffer.isBuffer(o)) if (B.isArrayBuffer(o))
        o = Buffer.from(new Uint8Array(o));
      else if (B.isString(o))
        o = Buffer.from(o, "utf-8");
      else
        return s(new se(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          se.ERR_BAD_REQUEST,
          t
        ));
      if (R.setContentLength(o.length, !1), t.maxBodyLength > -1 && o.length > t.maxBodyLength)
        return s(new se(
          "Request body larger than maxBodyLength limit",
          se.ERR_BAD_REQUEST,
          t
        ));
    }
    const M = B.toFiniteNumber(R.getContentLength());
    B.isArray(z) ? (S = z[0], L = z[1]) : S = L = z, o && (E || S) && (B.isStream(o) || (o = zt.Readable.from(o, { objectMode: !1 })), o = zt.pipeline([o, new Wg({
      maxRate: B.toFiniteNumber(S)
    })], B.noop), E && o.on("progress", Zg(
      o,
      Yo(
        M,
        es(Xo(E), !1, 3)
      )
    )));
    let U;
    if (t.auth) {
      const j = t.auth.username || "", C = t.auth.password || "";
      U = j + ":" + C;
    }
    if (!U && y.username) {
      const j = y.username, C = y.password;
      U = j + ":" + C;
    }
    U && R.delete("authorization");
    let $;
    try {
      $ = tp(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        y.pathname + y.search,
        t.params,
        t.paramsSerializer
      ).replace(/^\?/, "");
<<<<<<< HEAD
    } catch (D) {
      const I = new Error(D.message);
      return I.config = t, I.url = t.url, I.exists = !0, i(I);
    }
    R.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (HE ? ", br" : ""),
=======
    } catch (j) {
      const C = new Error(j.message);
      return C.config = t, C.url = t.url, C.exists = !0, s(C);
    }
    R.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (Yg ? ", br" : ""),
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      !1
    );
    const x = {
      path: $,
<<<<<<< HEAD
      method: f,
      headers: R.toJSON(),
      agents: { http: t.httpAgent, https: t.httpsAgent },
      auth: q,
      protocol: E,
      family: c,
      beforeRedirect: rG,
      beforeRedirects: {}
    };
    !Z.isUndefined(a) && (x.lookup = a), t.socketPath ? x.socketPath = t.socketPath : (x.hostname = y.hostname.startsWith("[") ? y.hostname.slice(1, -1) : y.hostname, x.port = y.port, iT(x, t.proxy, E + "//" + y.hostname + (y.port ? ":" + y.port : "") + x.path));
    let A;
    const P = tG.test(x.protocol);
    if (x.agent = P ? t.httpsAgent : t.httpAgent, t.transport ? A = t.transport : t.maxRedirects === 0 ? A = P ? am : yu : (t.maxRedirects && (x.maxRedirects = t.maxRedirects), t.beforeRedirect && (x.beforeRedirects.config = t.beforeRedirect), A = P ? eG : Q8), t.maxBodyLength > -1 ? x.maxBodyLength = t.maxBodyLength : x.maxBodyLength = 1 / 0, t.insecureHTTPParser && (x.insecureHTTPParser = t.insecureHTTPParser), d = A.request(x, function(I) {
      if (d.destroyed) return;
      const L = [I], j = +I.headers["content-length"];
      if (C || F) {
        const N = new jE({
          maxRate: Z.toFiniteNumber(F)
        });
        C && N.on("progress", BE(
          N,
          Ql(
            j,
            Gs(eu(C), !0, 3)
          )
        )), L.push(N);
      }
      let k = I;
      const U = I.req || d;
      if (t.decompress !== !1 && I.headers["content-encoding"])
        switch ((f === "HEAD" || I.statusCode === 204) && delete I.headers["content-encoding"], (I.headers["content-encoding"] || "").toLowerCase()) {
=======
      method: d,
      headers: R.toJSON(),
      agents: { http: t.httpAgent, https: t.httpsAgent },
      auth: U,
      protocol: _,
      family: c,
      beforeRedirect: iH,
      beforeRedirects: {}
    };
    !B.isUndefined(a) && (x.lookup = a), t.socketPath ? x.socketPath = t.socketPath : (x.hostname = y.hostname.startsWith("[") ? y.hostname.slice(1, -1) : y.hostname, x.port = y.port, HE(x, t.proxy, _ + "//" + y.hostname + (y.port ? ":" + y.port : "") + x.path));
    let I;
    const T = sH.test(x.protocol);
    if (x.agent = T ? t.httpsAgent : t.httpAgent, t.transport ? I = t.transport : t.maxRedirects === 0 ? I = T ? Hu : qu : (t.maxRedirects && (x.maxRedirects = t.maxRedirects), t.beforeRedirect && (x.beforeRedirects.config = t.beforeRedirect), I = T ? nH : rH), t.maxBodyLength > -1 ? x.maxBodyLength = t.maxBodyLength : x.maxBodyLength = 1 / 0, t.insecureHTTPParser && (x.insecureHTTPParser = t.insecureHTTPParser), u = I.request(x, function(C) {
      if (u.destroyed) return;
      const A = [C], k = +C.headers["content-length"];
      if (O || L) {
        const N = new Wg({
          maxRate: B.toFiniteNumber(L)
        });
        O && N.on("progress", Zg(
          N,
          Yo(
            k,
            es(Xo(O), !0, 3)
          )
        )), A.push(N);
      }
      let P = C;
      const D = C.req || u;
      if (t.decompress !== !1 && C.headers["content-encoding"])
        switch ((d === "HEAD" || C.statusCode === 204) && delete C.headers["content-encoding"], (C.headers["content-encoding"] || "").toLowerCase()) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
<<<<<<< HEAD
            L.push(Or.createUnzip(ME)), delete I.headers["content-encoding"];
            break;
          case "deflate":
            L.push(new K8()), L.push(Or.createUnzip(ME)), delete I.headers["content-encoding"];
            break;
          case "br":
            HE && (L.push(Or.createBrotliDecompress(Z8)), delete I.headers["content-encoding"]);
        }
      k = L.length > 1 ? It.pipeline(L, Z.noop) : L[0];
      const M = It.finished(k, () => {
        M(), _();
      }), T = {
        status: I.statusCode,
        statusText: I.statusMessage,
        headers: new Lt(I.headers),
        config: t,
        request: U
      };
      if (u === "stream")
        T.data = k, Ss(n, i, T);
      else {
        const N = [];
        let G = 0;
        k.on("data", function(S) {
          N.push(S), G += S.length, t.maxContentLength > -1 && G > t.maxContentLength && (p = !0, k.destroy(), i(new ae(
            "maxContentLength size of " + t.maxContentLength + " exceeded",
            ae.ERR_BAD_RESPONSE,
            t,
            U
          )));
        }), k.on("aborted", function() {
          if (p)
            return;
          const S = new ae(
            "stream has been aborted",
            ae.ERR_BAD_RESPONSE,
            t,
            U
          );
          k.destroy(S), i(S);
        }), k.on("error", function(S) {
          d.destroyed || i(ae.from(S, null, t, U));
        }), k.on("end", function() {
          try {
            let S = N.length === 1 ? N[0] : Buffer.concat(N);
            u !== "arraybuffer" && (S = S.toString(l), (!l || l === "utf8") && (S = Z.stripBOM(S))), T.data = S;
          } catch (S) {
            return i(ae.from(S, null, t, T.request, T));
          }
          Ss(n, i, T);
        });
      }
      h.once("abort", (N) => {
        k.destroyed || (k.emit("error", N), k.destroy());
      });
    }), h.once("abort", (D) => {
      i(D), d.destroy(D);
    }), d.on("error", function(I) {
      i(ae.from(I, null, t, d));
    }), d.on("socket", function(I) {
      I.setKeepAlive(!0, 1e3 * 60);
    }), t.timeout) {
      const D = parseInt(t.timeout, 10);
      if (Number.isNaN(D)) {
        i(new ae(
          "error trying to parse `config.timeout` to int",
          ae.ERR_BAD_OPTION_VALUE,
          t,
          d
        ));
        return;
      }
      d.setTimeout(D, function() {
        if (m) return;
        let L = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
        const j = t.transitional || by;
        t.timeoutErrorMessage && (L = t.timeoutErrorMessage), i(new ae(
          L,
          j.clarifyTimeoutError ? ae.ETIMEDOUT : ae.ECONNABORTED,
          t,
          d
        )), g();
      });
    }
    if (Z.isStream(o)) {
      let D = !1, I = !1;
      o.on("end", () => {
        D = !0;
      }), o.once("error", (L) => {
        I = !0, d.destroy(L);
      }), o.on("close", () => {
        !D && !I && g(new Xn("Request stream has been aborted", t, d));
      }), o.pipe(d);
    } else
      d.end(o);
  });
}, aG = st.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (r) => (r = new URL(r, st.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(
  new URL(st.origin),
  st.navigator && /(msie|trident)/i.test(st.navigator.userAgent)
) : () => !0, cG = st.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, i, s) {
      const o = [e + "=" + encodeURIComponent(t)];
      Z.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Z.isString(n) && o.push("path=" + n), Z.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
=======
            A.push(fr.createUnzip(Jg)), delete C.headers["content-encoding"];
            break;
          case "deflate":
            A.push(new Xq()), A.push(fr.createUnzip(Jg)), delete C.headers["content-encoding"];
            break;
          case "br":
            Yg && (A.push(fr.createBrotliDecompress(tH)), delete C.headers["content-encoding"]);
        }
      P = A.length > 1 ? zt.pipeline(A, B.noop) : A[0];
      const F = zt.finished(P, () => {
        F(), b();
      }), w = {
        status: C.statusCode,
        statusText: C.statusMessage,
        headers: new pt(C.headers),
        config: t,
        request: D
      };
      if (f === "stream")
        w.data = P, Fn(n, s, w);
      else {
        const N = [];
        let q = 0;
        P.on("data", function(V) {
          N.push(V), q += V.length, t.maxContentLength > -1 && q > t.maxContentLength && (p = !0, P.destroy(), s(new se(
            "maxContentLength size of " + t.maxContentLength + " exceeded",
            se.ERR_BAD_RESPONSE,
            t,
            D
          )));
        }), P.on("aborted", function() {
          if (p)
            return;
          const V = new se(
            "stream has been aborted",
            se.ERR_BAD_RESPONSE,
            t,
            D
          );
          P.destroy(V), s(V);
        }), P.on("error", function(V) {
          u.destroyed || s(se.from(V, null, t, D));
        }), P.on("end", function() {
          try {
            let V = N.length === 1 ? N[0] : Buffer.concat(N);
            f !== "arraybuffer" && (V = V.toString(l), (!l || l === "utf8") && (V = B.stripBOM(V))), w.data = V;
          } catch (V) {
            return s(se.from(V, null, t, w.request, w));
          }
          Fn(n, s, w);
        });
      }
      h.once("abort", (N) => {
        P.destroyed || (P.emit("error", N), P.destroy());
      });
    }), h.once("abort", (j) => {
      s(j), u.destroy(j);
    }), u.on("error", function(C) {
      s(se.from(C, null, t, u));
    }), u.on("socket", function(C) {
      C.setKeepAlive(!0, 1e3 * 60);
    }), t.timeout) {
      const j = parseInt(t.timeout, 10);
      if (Number.isNaN(j)) {
        s(new se(
          "error trying to parse `config.timeout` to int",
          se.ERR_BAD_OPTION_VALUE,
          t,
          u
        ));
        return;
      }
      u.setTimeout(j, function() {
        if (g) return;
        let A = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
        const k = t.transitional || rp;
        t.timeoutErrorMessage && (A = t.timeoutErrorMessage), s(new se(
          A,
          k.clarifyTimeoutError ? se.ETIMEDOUT : se.ECONNABORTED,
          t,
          u
        )), m();
      });
    }
    if (B.isStream(o)) {
      let j = !1, C = !1;
      o.on("end", () => {
        j = !0;
      }), o.once("error", (A) => {
        C = !0, u.destroy(A);
      }), o.on("close", () => {
        !j && !C && m(new Hr("Request stream has been aborted", t, u));
      }), o.pipe(u);
    } else
      u.end(o);
  });
}, uH = qe.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (r) => (r = new URL(r, qe.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(
  new URL(qe.origin),
  qe.navigator && /(msie|trident)/i.test(qe.navigator.userAgent)
) : () => !0, fH = qe.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, s, i) {
      const o = [e + "=" + encodeURIComponent(t)];
      B.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), B.isString(n) && o.push("path=" + n), B.isString(s) && o.push("domain=" + s), i === !0 && o.push("secure"), document.cookie = o.join("; ");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
<<<<<<< HEAD
), VE = (e) => e instanceof Lt ? { ...e } : e;
function qi(e, t) {
  t = t || {};
  const r = {};
  function n(u, l, f, m) {
    return Z.isPlainObject(u) && Z.isPlainObject(l) ? Z.merge.call({ caseless: m }, u, l) : Z.isPlainObject(l) ? Z.merge({}, l) : Z.isArray(l) ? l.slice() : l;
  }
  function i(u, l, f, m) {
    if (Z.isUndefined(l)) {
      if (!Z.isUndefined(u))
        return n(void 0, u, f, m);
    } else return n(u, l, f, m);
  }
  function s(u, l) {
    if (!Z.isUndefined(l))
      return n(void 0, l);
  }
  function o(u, l) {
    if (Z.isUndefined(l)) {
      if (!Z.isUndefined(u))
        return n(void 0, u);
    } else return n(void 0, l);
  }
  function a(u, l, f) {
    if (f in t)
      return n(u, l);
    if (f in e)
      return n(void 0, u);
  }
  const c = {
    url: s,
    method: s,
    data: s,
=======
), ev = (e) => e instanceof pt ? { ...e } : e;
function mn(e, t) {
  t = t || {};
  const r = {};
  function n(f, l, d, g) {
    return B.isPlainObject(f) && B.isPlainObject(l) ? B.merge.call({ caseless: g }, f, l) : B.isPlainObject(l) ? B.merge({}, l) : B.isArray(l) ? l.slice() : l;
  }
  function s(f, l, d, g) {
    if (B.isUndefined(l)) {
      if (!B.isUndefined(f))
        return n(void 0, f, d, g);
    } else return n(f, l, d, g);
  }
  function i(f, l) {
    if (!B.isUndefined(l))
      return n(void 0, l);
  }
  function o(f, l) {
    if (B.isUndefined(l)) {
      if (!B.isUndefined(f))
        return n(void 0, f);
    } else return n(void 0, l);
  }
  function a(f, l, d) {
    if (d in t)
      return n(f, l);
    if (d in e)
      return n(void 0, f);
  }
  const c = {
    url: i,
    method: i,
    data: i,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
<<<<<<< HEAD
    headers: (u, l, f) => i(VE(u), VE(l), f, !0)
  };
  return Z.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const f = c[l] || i, m = f(e[l], t[l], l);
    Z.isUndefined(m) && f !== a || (r[l] = m);
  }), r;
}
const sT = (e) => {
  const t = qi({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = t;
  t.headers = o = Lt.from(o), t.url = _y(wy(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set(
=======
    headers: (f, l, d) => s(ev(f), ev(l), d, !0)
  };
  return B.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const d = c[l] || s, g = d(e[l], t[l], l);
    B.isUndefined(g) && d !== a || (r[l] = g);
  }), r;
}
const BE = (e) => {
  const t = mn({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: a } = t;
  t.headers = o = pt.from(o), t.url = tp(sp(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
<<<<<<< HEAD
  if (Z.isFormData(r)) {
    if (st.hasStandardBrowserEnv || st.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
      o.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (st.hasStandardBrowserEnv && (n && Z.isFunction(n) && (n = n(t)), n || n !== !1 && aG(t.url))) {
    const u = i && s && cG.read(s);
    u && o.set(i, u);
  }
  return t;
}, lG = typeof XMLHttpRequest < "u", uG = lG && function(e) {
  return new Promise(function(r, n) {
    const i = sT(e);
    let s = i.data;
    const o = Lt.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: u } = i, l, f, m, p, d;
    function h() {
      p && p(), d && d(), i.cancelToken && i.cancelToken.unsubscribe(l), i.signal && i.signal.removeEventListener("abort", l);
    }
    let _ = new XMLHttpRequest();
    _.open(i.method.toUpperCase(), i.url, !0), _.timeout = i.timeout;
    function g() {
      if (!_)
        return;
      const y = Lt.from(
        "getAllResponseHeaders" in _ && _.getAllResponseHeaders()
      ), R = {
        data: !a || a === "text" || a === "json" ? _.responseText : _.response,
        status: _.status,
        statusText: _.statusText,
        headers: y,
        config: e,
        request: _
      };
      Ss(function(C) {
        r(C), h();
      }, function(C) {
        n(C), h();
      }, R), _ = null;
    }
    "onloadend" in _ ? _.onloadend = g : _.onreadystatechange = function() {
      !_ || _.readyState !== 4 || _.status === 0 && !(_.responseURL && _.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, _.onabort = function() {
      _ && (n(new ae("Request aborted", ae.ECONNABORTED, e, _)), _ = null);
    }, _.onerror = function() {
      n(new ae("Network Error", ae.ERR_NETWORK, e, _)), _ = null;
    }, _.ontimeout = function() {
      let E = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const R = i.transitional || by;
      i.timeoutErrorMessage && (E = i.timeoutErrorMessage), n(new ae(
        E,
        R.clarifyTimeoutError ? ae.ETIMEDOUT : ae.ECONNABORTED,
        e,
        _
      )), _ = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in _ && Z.forEach(o.toJSON(), function(E, R) {
      _.setRequestHeader(R, E);
    }), Z.isUndefined(i.withCredentials) || (_.withCredentials = !!i.withCredentials), a && a !== "json" && (_.responseType = i.responseType), u && ([m, d] = Gs(u, !0), _.addEventListener("progress", m)), c && _.upload && ([f, p] = Gs(c), _.upload.addEventListener("progress", f), _.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (l = (y) => {
      _ && (n(!y || y.type ? new Xn(null, e, _) : y), _.abort(), _ = null);
    }, i.cancelToken && i.cancelToken.subscribe(l), i.signal && (i.signal.aborted ? l() : i.signal.addEventListener("abort", l)));
    const v = rT(i.url);
    if (v && st.protocols.indexOf(v) === -1) {
      n(new ae("Unsupported protocol " + v + ":", ae.ERR_BAD_REQUEST, e));
      return;
    }
    _.send(s || null);
  });
}, fG = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), i;
    const s = function(u) {
      if (!i) {
        i = !0, a();
        const l = u instanceof Error ? u : this.reason;
        n.abort(l instanceof ae ? l : new Xn(l instanceof Error ? l.message : l));
      }
    };
    let o = t && setTimeout(() => {
      o = null, s(new ae(`timeout ${t} of ms exceeded`, ae.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(s) : u.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", s));
    const { signal: c } = n;
    return c.unsubscribe = () => Z.asap(a), c;
  }
}, dG = function* (e, t) {
=======
  if (B.isFormData(r)) {
    if (qe.hasStandardBrowserEnv || qe.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [f, ...l] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      o.setContentType([f || "multipart/form-data", ...l].join("; "));
    }
  }
  if (qe.hasStandardBrowserEnv && (n && B.isFunction(n) && (n = n(t)), n || n !== !1 && uH(t.url))) {
    const f = s && i && fH.read(i);
    f && o.set(s, f);
  }
  return t;
}, dH = typeof XMLHttpRequest < "u", pH = dH && function(e) {
  return new Promise(function(r, n) {
    const s = BE(e);
    let i = s.data;
    const o = pt.from(s.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: f } = s, l, d, g, p, u;
    function h() {
      p && p(), u && u(), s.cancelToken && s.cancelToken.unsubscribe(l), s.signal && s.signal.removeEventListener("abort", l);
    }
    let b = new XMLHttpRequest();
    b.open(s.method.toUpperCase(), s.url, !0), b.timeout = s.timeout;
    function m() {
      if (!b)
        return;
      const y = pt.from(
        "getAllResponseHeaders" in b && b.getAllResponseHeaders()
      ), R = {
        data: !a || a === "text" || a === "json" ? b.responseText : b.response,
        status: b.status,
        statusText: b.statusText,
        headers: y,
        config: e,
        request: b
      };
      Fn(function(O) {
        r(O), h();
      }, function(O) {
        n(O), h();
      }, R), b = null;
    }
    "onloadend" in b ? b.onloadend = m : b.onreadystatechange = function() {
      !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(m);
    }, b.onabort = function() {
      b && (n(new se("Request aborted", se.ECONNABORTED, e, b)), b = null);
    }, b.onerror = function() {
      n(new se("Network Error", se.ERR_NETWORK, e, b)), b = null;
    }, b.ontimeout = function() {
      let _ = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const R = s.transitional || rp;
      s.timeoutErrorMessage && (_ = s.timeoutErrorMessage), n(new se(
        _,
        R.clarifyTimeoutError ? se.ETIMEDOUT : se.ECONNABORTED,
        e,
        b
      )), b = null;
    }, i === void 0 && o.setContentType(null), "setRequestHeader" in b && B.forEach(o.toJSON(), function(_, R) {
      b.setRequestHeader(R, _);
    }), B.isUndefined(s.withCredentials) || (b.withCredentials = !!s.withCredentials), a && a !== "json" && (b.responseType = s.responseType), f && ([g, u] = es(f, !0), b.addEventListener("progress", g)), c && b.upload && ([d, p] = es(c), b.upload.addEventListener("progress", d), b.upload.addEventListener("loadend", p)), (s.cancelToken || s.signal) && (l = (y) => {
      b && (n(!y || y.type ? new Hr(null, e, b) : y), b.abort(), b = null);
    }, s.cancelToken && s.cancelToken.subscribe(l), s.signal && (s.signal.aborted ? l() : s.signal.addEventListener("abort", l)));
    const v = UE(s.url);
    if (v && qe.protocols.indexOf(v) === -1) {
      n(new se("Unsupported protocol " + v + ":", se.ERR_BAD_REQUEST, e));
      return;
    }
    b.send(i || null);
  });
}, hH = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), s;
    const i = function(f) {
      if (!s) {
        s = !0, a();
        const l = f instanceof Error ? f : this.reason;
        n.abort(l instanceof se ? l : new Hr(l instanceof Error ? l.message : l));
      }
    };
    let o = t && setTimeout(() => {
      o = null, i(new se(`timeout ${t} of ms exceeded`, se.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(i) : f.removeEventListener("abort", i);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", i));
    const { signal: c } = n;
    return c.unsubscribe = () => B.asap(a), c;
  }
}, mH = function* (e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
<<<<<<< HEAD
  let n = 0, i;
  for (; n < r; )
    i = n + t, yield e.slice(n, i), n = i;
}, pG = async function* (e, t) {
  for await (const r of hG(e))
    yield* dG(r, t);
}, hG = async function* (e) {
=======
  let n = 0, s;
  for (; n < r; )
    s = n + t, yield e.slice(n, s), n = s;
}, yH = async function* (e, t) {
  for await (const r of gH(e))
    yield* mH(r, t);
}, gH = async function* (e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
<<<<<<< HEAD
}, GE = (e, t, r, n) => {
  const i = pG(e, t);
  let s = 0, o, a = (c) => {
=======
}, tv = (e, t, r, n) => {
  const s = yH(e, t);
  let i = 0, o, a = (c) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    o || (o = !0, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
<<<<<<< HEAD
        const { done: u, value: l } = await i.next();
        if (u) {
          a(), c.close();
          return;
        }
        let f = l.byteLength;
        if (r) {
          let m = s += f;
          r(m);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), i.return();
=======
        const { done: f, value: l } = await s.next();
        if (f) {
          a(), c.close();
          return;
        }
        let d = l.byteLength;
        if (r) {
          let g = i += d;
          r(g);
        }
        c.enqueue(new Uint8Array(l));
      } catch (f) {
        throw a(f), f;
      }
    },
    cancel(c) {
      return a(c), s.return();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
  }, {
    highWaterMark: 2
  });
<<<<<<< HEAD
}, ff = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", oT = ff && typeof ReadableStream == "function", mG = ff && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), aT = (e, ...t) => {
=======
}, Va = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", VE = Va && typeof ReadableStream == "function", vH = Va && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), GE = (e, ...t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
<<<<<<< HEAD
}, gG = oT && aT(() => {
  let e = !1;
  const t = new Request(st.origin, {
=======
}, bH = VE && GE(() => {
  let e = !1;
  const t = new Request(qe.origin, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
<<<<<<< HEAD
}), WE = 64 * 1024, qh = oT && aT(() => Z.isReadableStream(new Response("").body)), tu = {
  stream: qh && ((e) => e.body)
};
ff && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !tu[t] && (tu[t] = Z.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new ae(`Response type '${t}' is not supported`, ae.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const yG = async (e) => {
  if (e == null)
    return 0;
  if (Z.isBlob(e))
    return e.size;
  if (Z.isSpecCompliantForm(e))
    return (await new Request(st.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (Z.isArrayBufferView(e) || Z.isArrayBuffer(e))
    return e.byteLength;
  if (Z.isURLSearchParams(e) && (e = e + ""), Z.isString(e))
    return (await mG(e)).byteLength;
}, vG = async (e, t) => {
  const r = Z.toFiniteNumber(e.getContentLength());
  return r ?? yG(t);
}, _G = ff && (async (e) => {
=======
}), rv = 64 * 1024, ju = VE && GE(() => B.isReadableStream(new Response("").body)), Zo = {
  stream: ju && ((e) => e.body)
};
Va && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Zo[t] && (Zo[t] = B.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new se(`Response type '${t}' is not supported`, se.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const _H = async (e) => {
  if (e == null)
    return 0;
  if (B.isBlob(e))
    return e.size;
  if (B.isSpecCompliantForm(e))
    return (await new Request(qe.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (B.isArrayBufferView(e) || B.isArrayBuffer(e))
    return e.byteLength;
  if (B.isURLSearchParams(e) && (e = e + ""), B.isString(e))
    return (await vH(e)).byteLength;
}, EH = async (e, t) => {
  const r = B.toFiniteNumber(e.getContentLength());
  return r ?? _H(t);
}, SH = Va && (async (e) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  let {
    url: t,
    method: r,
    data: n,
<<<<<<< HEAD
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: f = "same-origin",
    fetchOptions: m
  } = sT(e);
  u = u ? (u + "").toLowerCase() : "text";
  let p = fG([i, s && s.toAbortSignal()], o), d;
  const h = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let _;
  try {
    if (c && gG && r !== "get" && r !== "head" && (_ = await vG(l, n)) !== 0) {
=======
    signal: s,
    cancelToken: i,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: f,
    headers: l,
    withCredentials: d = "same-origin",
    fetchOptions: g
  } = BE(e);
  f = f ? (f + "").toLowerCase() : "text";
  let p = hH([s, i && i.toAbortSignal()], o), u;
  const h = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let b;
  try {
    if (c && bH && r !== "get" && r !== "head" && (b = await EH(l, n)) !== 0) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      let R = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
<<<<<<< HEAD
      }), w;
      if (Z.isFormData(n) && (w = R.headers.get("content-type")) && l.setContentType(w), R.body) {
        const [C, V] = Ql(
          _,
          Gs(eu(c))
        );
        n = GE(R.body, WE, C, V);
      }
    }
    Z.isString(f) || (f = f ? "include" : "omit");
    const g = "credentials" in Request.prototype;
    d = new Request(t, {
      ...m,
=======
      }), E;
      if (B.isFormData(n) && (E = R.headers.get("content-type")) && l.setContentType(E), R.body) {
        const [O, z] = Yo(
          b,
          es(Xo(c))
        );
        n = tv(R.body, rv, O, z);
      }
    }
    B.isString(d) || (d = d ? "include" : "omit");
    const m = "credentials" in Request.prototype;
    u = new Request(t, {
      ...g,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      signal: p,
      method: r.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
<<<<<<< HEAD
      credentials: g ? f : void 0
    });
    let v = await fetch(d);
    const y = qh && (u === "stream" || u === "response");
    if (qh && (a || y && h)) {
      const R = {};
      ["status", "statusText", "headers"].forEach((b) => {
        R[b] = v[b];
      });
      const w = Z.toFiniteNumber(v.headers.get("content-length")), [C, V] = a && Ql(
        w,
        Gs(eu(a), !0)
      ) || [];
      v = new Response(
        GE(v.body, WE, C, () => {
          V && V(), h && h();
=======
      credentials: m ? d : void 0
    });
    let v = await fetch(u);
    const y = ju && (f === "stream" || f === "response");
    if (ju && (a || y && h)) {
      const R = {};
      ["status", "statusText", "headers"].forEach((S) => {
        R[S] = v[S];
      });
      const E = B.toFiniteNumber(v.headers.get("content-length")), [O, z] = a && Yo(
        E,
        es(Xo(a), !0)
      ) || [];
      v = new Response(
        tv(v.body, rv, O, () => {
          z && z(), h && h();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }),
        R
      );
    }
<<<<<<< HEAD
    u = u || "text";
    let E = await tu[Z.findKey(tu, u) || "text"](v, e);
    return !y && h && h(), await new Promise((R, w) => {
      Ss(R, w, {
        data: E,
        headers: Lt.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: e,
        request: d
      });
    });
  } catch (g) {
    throw h && h(), g && g.name === "TypeError" && /fetch/i.test(g.message) ? Object.assign(
      new ae("Network Error", ae.ERR_NETWORK, e, d),
      {
        cause: g.cause || g
      }
    ) : ae.from(g, g && g.code, e, d);
  }
}), Bh = {
  http: oG,
  xhr: uG,
  fetch: _G
};
Z.forEach(Bh, (e, t) => {
=======
    f = f || "text";
    let _ = await Zo[B.findKey(Zo, f) || "text"](v, e);
    return !y && h && h(), await new Promise((R, E) => {
      Fn(R, E, {
        data: _,
        headers: pt.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: e,
        request: u
      });
    });
  } catch (m) {
    throw h && h(), m && m.name === "TypeError" && /fetch/i.test(m.message) ? Object.assign(
      new se("Network Error", se.ERR_NETWORK, e, u),
      {
        cause: m.cause || m
      }
    ) : se.from(m, m && m.code, e, u);
  }
}), Du = {
  http: lH,
  xhr: pH,
  fetch: SH
};
B.forEach(Du, (e, t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
<<<<<<< HEAD
const KE = (e) => `- ${e}`, bG = (e) => Z.isFunction(e) || e === null || e === !1, cT = {
  getAdapter: (e) => {
    e = Z.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const i = {};
    for (let s = 0; s < t; s++) {
      r = e[s];
      let o;
      if (n = r, !bG(r) && (n = Bh[(o = String(r)).toLowerCase()], n === void 0))
        throw new ae(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? s.length > 1 ? `since :
` + s.map(KE).join(`
`) : " " + KE(s[0]) : "as no adapter specified";
      throw new ae(
=======
const nv = (e) => `- ${e}`, xH = (e) => B.isFunction(e) || e === null || e === !1, WE = {
  getAdapter: (e) => {
    e = B.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const s = {};
    for (let i = 0; i < t; i++) {
      r = e[i];
      let o;
      if (n = r, !xH(r) && (n = Du[(o = String(r)).toLowerCase()], n === void 0))
        throw new se(`Unknown adapter '${o}'`);
      if (n)
        break;
      s[o || "#" + i] = n;
    }
    if (!n) {
      const i = Object.entries(s).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? i.length > 1 ? `since :
` + i.map(nv).join(`
`) : " " + nv(i[0]) : "as no adapter specified";
      throw new se(
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
<<<<<<< HEAD
  adapters: Bh
};
function Lp(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Xn(null, e);
}
function YE(e) {
  return Lp(e), e.headers = Lt.from(e.headers), e.data = Pp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), cT.getAdapter(e.adapter || Qa.adapter)(e).then(function(n) {
    return Lp(e), n.data = Pp.call(
      e,
      e.transformResponse,
      n
    ), n.headers = Lt.from(n.headers), n;
  }, function(n) {
    return K1(n) || (Lp(e), n && n.response && (n.response.data = Pp.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = Lt.from(n.response.headers))), Promise.reject(n);
  });
}
const df = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  df[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const JE = {};
df.transitional = function(t, r, n) {
  function i(s, o) {
    return "[Axios v" + Zl + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (t === !1)
      throw new ae(
        i(o, " has been removed" + (r ? " in " + r : "")),
        ae.ERR_DEPRECATED
      );
    return r && !JE[o] && (JE[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(s, o, a) : !0;
  };
};
df.spelling = function(t) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function EG(e, t, r) {
  if (typeof e != "object")
    throw new ae("options must be an object", ae.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = t[s];
    if (o) {
      const a = e[s], c = a === void 0 || o(a, s, e);
      if (c !== !0)
        throw new ae("option " + s + " must be " + c, ae.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new ae("Unknown option " + s, ae.ERR_BAD_OPTION);
  }
}
const Tl = {
  assertOptions: EG,
  validators: df
}, Yr = Tl.validators;
let Di = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new PE(),
      response: new PE()
=======
  adapters: Du
};
function Zl(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Hr(null, e);
}
function sv(e) {
  return Zl(e), e.headers = pt.from(e.headers), e.data = Vl.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), WE.getAdapter(e.adapter || Si.adapter)(e).then(function(n) {
    return Zl(e), n.data = Vl.call(
      e,
      e.transformResponse,
      n
    ), n.headers = pt.from(n.headers), n;
  }, function(n) {
    return kE(n) || (Zl(e), n && n.response && (n.response.data = Vl.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = pt.from(n.response.headers))), Promise.reject(n);
  });
}
const Ga = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Ga[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const iv = {};
Ga.transitional = function(t, r, n) {
  function s(i, o) {
    return "[Axios v" + Jo + "] Transitional option '" + i + "'" + o + (n ? ". " + n : "");
  }
  return (i, o, a) => {
    if (t === !1)
      throw new se(
        s(o, " has been removed" + (r ? " in " + r : "")),
        se.ERR_DEPRECATED
      );
    return r && !iv[o] && (iv[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(i, o, a) : !0;
  };
};
Ga.spelling = function(t) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function wH(e, t, r) {
  if (typeof e != "object")
    throw new se("options must be an object", se.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let s = n.length;
  for (; s-- > 0; ) {
    const i = n[s], o = t[i];
    if (o) {
      const a = e[i], c = a === void 0 || o(a, i, e);
      if (c !== !0)
        throw new se("option " + i + " must be " + c, se.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new se("Unknown option " + i, se.ERR_BAD_OPTION);
  }
}
const Oo = {
  assertOptions: wH,
  validators: Ga
}, ir = Oo.validators;
let fn = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Dg(),
      response: new Dg()
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
<<<<<<< HEAD
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
=======
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const i = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? i && !String(n.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + i) : n.stack = i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
<<<<<<< HEAD
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = qi(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && Tl.assertOptions(n, {
      silentJSONParsing: Yr.transitional(Yr.boolean),
      forcedJSONParsing: Yr.transitional(Yr.boolean),
      clarifyTimeoutError: Yr.transitional(Yr.boolean)
    }, !1), i != null && (Z.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : Tl.assertOptions(i, {
      encode: Yr.function,
      serialize: Yr.function
    }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Tl.assertOptions(r, {
      baseUrl: Yr.spelling("baseURL"),
      withXsrfToken: Yr.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Z.merge(
      s.common,
      s[r.method]
    );
    s && Z.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (d) => {
        delete s[d];
      }
    ), r.headers = Lt.concat(o, s);
=======
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = mn(this.defaults, r);
    const { transitional: n, paramsSerializer: s, headers: i } = r;
    n !== void 0 && Oo.assertOptions(n, {
      silentJSONParsing: ir.transitional(ir.boolean),
      forcedJSONParsing: ir.transitional(ir.boolean),
      clarifyTimeoutError: ir.transitional(ir.boolean)
    }, !1), s != null && (B.isFunction(s) ? r.paramsSerializer = {
      serialize: s
    } : Oo.assertOptions(s, {
      encode: ir.function,
      serialize: ir.function
    }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Oo.assertOptions(r, {
      baseUrl: ir.spelling("baseURL"),
      withXsrfToken: ir.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = i && B.merge(
      i.common,
      i[r.method]
    );
    i && B.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (u) => {
        delete i[u];
      }
    ), r.headers = pt.concat(o, i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(h) {
      typeof h.runWhen == "function" && h.runWhen(r) === !1 || (c = c && h.synchronous, a.unshift(h.fulfilled, h.rejected));
    });
<<<<<<< HEAD
    const u = [];
    this.interceptors.response.forEach(function(h) {
      u.push(h.fulfilled, h.rejected);
    });
    let l, f = 0, m;
    if (!c) {
      const d = [YE.bind(this), void 0];
      for (d.unshift.apply(d, a), d.push.apply(d, u), m = d.length, l = Promise.resolve(r); f < m; )
        l = l.then(d[f++], d[f++]);
      return l;
    }
    m = a.length;
    let p = r;
    for (f = 0; f < m; ) {
      const d = a[f++], h = a[f++];
      try {
        p = d(p);
      } catch (_) {
        h.call(this, _);
=======
    const f = [];
    this.interceptors.response.forEach(function(h) {
      f.push(h.fulfilled, h.rejected);
    });
    let l, d = 0, g;
    if (!c) {
      const u = [sv.bind(this), void 0];
      for (u.unshift.apply(u, a), u.push.apply(u, f), g = u.length, l = Promise.resolve(r); d < g; )
        l = l.then(u[d++], u[d++]);
      return l;
    }
    g = a.length;
    let p = r;
    for (d = 0; d < g; ) {
      const u = a[d++], h = a[d++];
      try {
        p = u(p);
      } catch (b) {
        h.call(this, b);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        break;
      }
    }
    try {
<<<<<<< HEAD
      l = YE.call(this, p);
    } catch (d) {
      return Promise.reject(d);
    }
    for (f = 0, m = u.length; f < m; )
      l = l.then(u[f++], u[f++]);
    return l;
  }
  getUri(t) {
    t = qi(this.defaults, t);
    const r = wy(t.baseURL, t.url, t.allowAbsoluteUrls);
    return _y(r, t.params, t.paramsSerializer);
  }
};
Z.forEach(["delete", "get", "head", "options"], function(t) {
  Di.prototype[t] = function(r, n) {
    return this.request(qi(n || {}, {
=======
      l = sv.call(this, p);
    } catch (u) {
      return Promise.reject(u);
    }
    for (d = 0, g = f.length; d < g; )
      l = l.then(f[d++], f[d++]);
    return l;
  }
  getUri(t) {
    t = mn(this.defaults, t);
    const r = sp(t.baseURL, t.url, t.allowAbsoluteUrls);
    return tp(r, t.params, t.paramsSerializer);
  }
};
B.forEach(["delete", "get", "head", "options"], function(t) {
  fn.prototype[t] = function(r, n) {
    return this.request(mn(n || {}, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
<<<<<<< HEAD
Z.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(s, o, a) {
      return this.request(qi(a || {}, {
=======
B.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(i, o, a) {
      return this.request(mn(a || {}, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
<<<<<<< HEAD
        url: s,
=======
        url: i,
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        data: o
      }));
    };
  }
<<<<<<< HEAD
  Di.prototype[t] = r(), Di.prototype[t + "Form"] = r(!0);
});
let wG = class lT {
=======
  fn.prototype[t] = r(), fn.prototype[t + "Form"] = r(!0);
});
let RH = class KE {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
<<<<<<< HEAD
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, t(function(s, o, a) {
      n.reason || (n.reason = new Xn(s, o, a), r(n.reason));
=======
    this.promise = new Promise(function(i) {
      r = i;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners) return;
      let i = n._listeners.length;
      for (; i-- > 0; )
        n._listeners[i](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let i;
      const o = new Promise((a) => {
        n.subscribe(a), i = a;
      }).then(s);
      return o.cancel = function() {
        n.unsubscribe(i);
      }, o;
    }, t(function(i, o, a) {
      n.reason || (n.reason = new Hr(i, o, a), r(n.reason));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
<<<<<<< HEAD
      token: new lT(function(i) {
        t = i;
=======
      token: new KE(function(s) {
        t = s;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }),
      cancel: t
    };
  }
};
<<<<<<< HEAD
function SG(e) {
=======
function $H(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return function(r) {
    return e.apply(null, r);
  };
}
<<<<<<< HEAD
function xG(e) {
  return Z.isObject(e) && e.isAxiosError === !0;
}
const zh = {
=======
function TH(e) {
  return B.isObject(e) && e.isAxiosError === !0;
}
const Fu = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
<<<<<<< HEAD
Object.entries(zh).forEach(([e, t]) => {
  zh[t] = e;
});
function uT(e) {
  const t = new Di(e), r = h1(Di.prototype.request, t);
  return Z.extend(r, Di.prototype, t, { allOwnKeys: !0 }), Z.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(i) {
    return uT(qi(e, i));
  }, r;
}
const tt = uT(Qa);
tt.Axios = Di;
tt.CanceledError = Xn;
tt.CancelToken = wG;
tt.isCancel = K1;
tt.VERSION = Zl;
tt.toFormData = uf;
tt.AxiosError = ae;
tt.Cancel = tt.CanceledError;
tt.all = function(t) {
  return Promise.all(t);
};
tt.spread = SG;
tt.isAxiosError = xG;
tt.mergeConfig = qi;
tt.AxiosHeaders = Lt;
tt.formToJSON = (e) => W1(Z.isHTMLForm(e) ? new FormData(e) : e);
tt.getAdapter = cT.getAdapter;
tt.HttpStatusCode = zh;
tt.default = tt;
const {
  Axios: xee,
  AxiosError: Ree,
  CanceledError: $ee,
  isCancel: Tee,
  CancelToken: Oee,
  VERSION: Pee,
  all: Cee,
  Cancel: Aee,
  isAxiosError: Iee,
  spread: Nee,
  toFormData: kee,
  AxiosHeaders: Dee,
  HttpStatusCode: Lee,
  formToJSON: Fee,
  getAdapter: jee,
  mergeConfig: Uee
} = tt;
var fT = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(me, function() {
    var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", o = "second", a = "minute", c = "hour", u = "day", l = "week", f = "month", m = "quarter", p = "year", d = "date", h = "Invalid Date", _ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(x) {
      var A = ["th", "st", "nd", "rd"], P = x % 100;
      return "[" + x + (A[(P - 20) % 10] || A[P] || A[0]) + "]";
    } }, y = function(x, A, P) {
      var D = String(x);
      return !D || D.length >= A ? x : "" + Array(A + 1 - D.length).join(P) + x;
    }, E = { s: y, z: function(x) {
      var A = -x.utcOffset(), P = Math.abs(A), D = Math.floor(P / 60), I = P % 60;
      return (A <= 0 ? "+" : "-") + y(D, 2, "0") + ":" + y(I, 2, "0");
    }, m: function x(A, P) {
      if (A.date() < P.date()) return -x(P, A);
      var D = 12 * (P.year() - A.year()) + (P.month() - A.month()), I = A.clone().add(D, f), L = P - I < 0, j = A.clone().add(D + (L ? -1 : 1), f);
      return +(-(D + (P - I) / (L ? I - j : j - I)) || 0);
    }, a: function(x) {
      return x < 0 ? Math.ceil(x) || 0 : Math.floor(x);
    }, p: function(x) {
      return { M: f, y: p, w: l, d: u, D: d, h: c, m: a, s: o, ms: s, Q: m }[x] || String(x || "").toLowerCase().replace(/s$/, "");
    }, u: function(x) {
      return x === void 0;
    } }, R = "en", w = {};
    w[R] = v;
    var C = "$isDayjsObject", V = function(x) {
      return x instanceof q || !(!x || !x[C]);
    }, b = function x(A, P, D) {
      var I;
      if (!A) return R;
      if (typeof A == "string") {
        var L = A.toLowerCase();
        w[L] && (I = L), P && (w[L] = P, I = L);
        var j = A.split("-");
        if (!I && j.length > 1) return x(j[0]);
      } else {
        var k = A.name;
        w[k] = A, I = k;
      }
      return !D && I && (R = I), I || !D && R;
    }, F = function(x, A) {
      if (V(x)) return x.clone();
      var P = typeof A == "object" ? A : {};
      return P.date = x, P.args = arguments, new q(P);
    }, H = E;
    H.l = b, H.i = V, H.w = function(x, A) {
      return F(x, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
    };
    var q = function() {
      function x(P) {
        this.$L = b(P.locale, null, !0), this.parse(P), this.$x = this.$x || P.x || {}, this[C] = !0;
      }
      var A = x.prototype;
      return A.parse = function(P) {
        this.$d = function(D) {
          var I = D.date, L = D.utc;
          if (I === null) return /* @__PURE__ */ new Date(NaN);
          if (H.u(I)) return /* @__PURE__ */ new Date();
          if (I instanceof Date) return new Date(I);
          if (typeof I == "string" && !/Z$/i.test(I)) {
            var j = I.match(_);
            if (j) {
              var k = j[2] - 1 || 0, U = (j[7] || "0").substring(0, 3);
              return L ? new Date(Date.UTC(j[1], k, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, U)) : new Date(j[1], k, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, U);
            }
          }
          return new Date(I);
        }(P), this.init();
      }, A.init = function() {
        var P = this.$d;
        this.$y = P.getFullYear(), this.$M = P.getMonth(), this.$D = P.getDate(), this.$W = P.getDay(), this.$H = P.getHours(), this.$m = P.getMinutes(), this.$s = P.getSeconds(), this.$ms = P.getMilliseconds();
      }, A.$utils = function() {
        return H;
      }, A.isValid = function() {
        return this.$d.toString() !== h;
      }, A.isSame = function(P, D) {
        var I = F(P);
        return this.startOf(D) <= I && I <= this.endOf(D);
      }, A.isAfter = function(P, D) {
        return F(P) < this.startOf(D);
      }, A.isBefore = function(P, D) {
        return this.endOf(D) < F(P);
      }, A.$g = function(P, D, I) {
        return H.u(P) ? this[D] : this.set(I, P);
      }, A.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, A.valueOf = function() {
        return this.$d.getTime();
      }, A.startOf = function(P, D) {
        var I = this, L = !!H.u(D) || D, j = H.p(P), k = function(W, z) {
          var Q = H.w(I.$u ? Date.UTC(I.$y, z, W) : new Date(I.$y, z, W), I);
          return L ? Q : Q.endOf(u);
        }, U = function(W, z) {
          return H.w(I.toDate()[W].apply(I.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(z)), I);
        }, M = this.$W, T = this.$M, N = this.$D, G = "set" + (this.$u ? "UTC" : "");
        switch (j) {
          case p:
            return L ? k(1, 0) : k(31, 11);
          case f:
            return L ? k(1, T) : k(0, T + 1);
          case l:
            var O = this.$locale().weekStart || 0, S = (M < O ? M + 7 : M) - O;
            return k(L ? N - S : N + (6 - S), T);
          case u:
          case d:
            return U(G + "Hours", 0);
          case c:
            return U(G + "Minutes", 1);
          case a:
            return U(G + "Seconds", 2);
          case o:
            return U(G + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, A.endOf = function(P) {
        return this.startOf(P, !1);
      }, A.$set = function(P, D) {
        var I, L = H.p(P), j = "set" + (this.$u ? "UTC" : ""), k = (I = {}, I[u] = j + "Date", I[d] = j + "Date", I[f] = j + "Month", I[p] = j + "FullYear", I[c] = j + "Hours", I[a] = j + "Minutes", I[o] = j + "Seconds", I[s] = j + "Milliseconds", I)[L], U = L === u ? this.$D + (D - this.$W) : D;
        if (L === f || L === p) {
          var M = this.clone().set(d, 1);
          M.$d[k](U), M.init(), this.$d = M.set(d, Math.min(this.$D, M.daysInMonth())).$d;
        } else k && this.$d[k](U);
        return this.init(), this;
      }, A.set = function(P, D) {
        return this.clone().$set(P, D);
      }, A.get = function(P) {
        return this[H.p(P)]();
      }, A.add = function(P, D) {
        var I, L = this;
        P = Number(P);
        var j = H.p(D), k = function(T) {
          var N = F(L);
          return H.w(N.date(N.date() + Math.round(T * P)), L);
        };
        if (j === f) return this.set(f, this.$M + P);
        if (j === p) return this.set(p, this.$y + P);
        if (j === u) return k(1);
        if (j === l) return k(7);
        var U = (I = {}, I[a] = n, I[c] = i, I[o] = r, I)[j] || 1, M = this.$d.getTime() + P * U;
        return H.w(M, this);
      }, A.subtract = function(P, D) {
        return this.add(-1 * P, D);
      }, A.format = function(P) {
        var D = this, I = this.$locale();
        if (!this.isValid()) return I.invalidDate || h;
        var L = P || "YYYY-MM-DDTHH:mm:ssZ", j = H.z(this), k = this.$H, U = this.$m, M = this.$M, T = I.weekdays, N = I.months, G = I.meridiem, O = function(z, Q, K, X) {
          return z && (z[Q] || z(D, L)) || K[Q].slice(0, X);
        }, S = function(z) {
          return H.s(k % 12 || 12, z, "0");
        }, W = G || function(z, Q, K) {
          var X = z < 12 ? "AM" : "PM";
          return K ? X.toLowerCase() : X;
        };
        return L.replace(g, function(z, Q) {
          return Q || function(K) {
            switch (K) {
              case "YY":
                return String(D.$y).slice(-2);
              case "YYYY":
                return H.s(D.$y, 4, "0");
              case "M":
                return M + 1;
              case "MM":
                return H.s(M + 1, 2, "0");
              case "MMM":
                return O(I.monthsShort, M, N, 3);
              case "MMMM":
                return O(N, M);
              case "D":
                return D.$D;
              case "DD":
                return H.s(D.$D, 2, "0");
              case "d":
                return String(D.$W);
              case "dd":
                return O(I.weekdaysMin, D.$W, T, 2);
              case "ddd":
                return O(I.weekdaysShort, D.$W, T, 3);
              case "dddd":
                return T[D.$W];
              case "H":
                return String(k);
              case "HH":
                return H.s(k, 2, "0");
              case "h":
                return S(1);
              case "hh":
                return S(2);
              case "a":
                return W(k, U, !0);
              case "A":
                return W(k, U, !1);
              case "m":
                return String(U);
              case "mm":
                return H.s(U, 2, "0");
              case "s":
                return String(D.$s);
              case "ss":
                return H.s(D.$s, 2, "0");
              case "SSS":
                return H.s(D.$ms, 3, "0");
              case "Z":
                return j;
            }
            return null;
          }(z) || j.replace(":", "");
        });
      }, A.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, A.diff = function(P, D, I) {
        var L, j = this, k = H.p(D), U = F(P), M = (U.utcOffset() - this.utcOffset()) * n, T = this - U, N = function() {
          return H.m(j, U);
        };
        switch (k) {
          case p:
            L = N() / 12;
            break;
          case f:
            L = N();
            break;
          case m:
            L = N() / 3;
            break;
          case l:
            L = (T - M) / 6048e5;
            break;
          case u:
            L = (T - M) / 864e5;
            break;
          case c:
            L = T / i;
            break;
          case a:
            L = T / n;
            break;
          case o:
            L = T / r;
            break;
          default:
            L = T;
        }
        return I ? L : H.a(L);
      }, A.daysInMonth = function() {
        return this.endOf(f).$D;
      }, A.$locale = function() {
        return w[this.$L];
      }, A.locale = function(P, D) {
        if (!P) return this.$L;
        var I = this.clone(), L = b(P, D, !0);
        return L && (I.$L = L), I;
      }, A.clone = function() {
        return H.w(this.$d, this);
      }, A.toDate = function() {
        return new Date(this.valueOf());
      }, A.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, A.toISOString = function() {
        return this.$d.toISOString();
      }, A.toString = function() {
        return this.$d.toUTCString();
      }, x;
    }(), $ = q.prototype;
    return F.prototype = $, [["$ms", s], ["$s", o], ["$m", a], ["$H", c], ["$W", u], ["$M", f], ["$y", p], ["$D", d]].forEach(function(x) {
      $[x[1]] = function(A) {
        return this.$g(A, x[0], x[1]);
      };
    }), F.extend = function(x, A) {
      return x.$i || (x(A, q, F), x.$i = !0), F;
    }, F.locale = b, F.isDayjs = V, F.unix = function(x) {
      return F(1e3 * x);
    }, F.en = w[R], F.Ls = w, F.p = {}, F;
  });
})(fT);
var RG = fT.exports;
const $G = /* @__PURE__ */ Da(RG);
var lo = { exports: {} }, dT = {
=======
Object.entries(Fu).forEach(([e, t]) => {
  Fu[t] = e;
});
function JE(e) {
  const t = new fn(e), r = eE(fn.prototype.request, t);
  return B.extend(r, fn.prototype, t, { allOwnKeys: !0 }), B.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(s) {
    return JE(mn(e, s));
  }, r;
}
const Me = JE(Si);
Me.Axios = fn;
Me.CanceledError = Hr;
Me.CancelToken = RH;
Me.isCancel = kE;
Me.VERSION = Jo;
Me.toFormData = Ba;
Me.AxiosError = se;
Me.Cancel = Me.CanceledError;
Me.all = function(t) {
  return Promise.all(t);
};
Me.spread = $H;
Me.isAxiosError = TH;
Me.mergeConfig = mn;
Me.AxiosHeaders = pt;
Me.formToJSON = (e) => AE(B.isHTMLForm(e) ? new FormData(e) : e);
Me.getAdapter = WE.getAdapter;
Me.HttpStatusCode = Fu;
Me.default = Me;
const {
  Axios: Z3,
  AxiosError: Q3,
  CanceledError: e4,
  isCancel: t4,
  CancelToken: r4,
  VERSION: n4,
  all: s4,
  Cancel: i4,
  isAxiosError: o4,
  spread: a4,
  toFormData: c4,
  AxiosHeaders: l4,
  HttpStatusCode: u4,
  formToJSON: f4,
  getAdapter: d4,
  mergeConfig: p4
} = Me;
var YE = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(_e, function() {
    var r = 1e3, n = 6e4, s = 36e5, i = "millisecond", o = "second", a = "minute", c = "hour", f = "day", l = "week", d = "month", g = "quarter", p = "year", u = "date", h = "Invalid Date", b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(x) {
      var I = ["th", "st", "nd", "rd"], T = x % 100;
      return "[" + x + (I[(T - 20) % 10] || I[T] || I[0]) + "]";
    } }, y = function(x, I, T) {
      var j = String(x);
      return !j || j.length >= I ? x : "" + Array(I + 1 - j.length).join(T) + x;
    }, _ = { s: y, z: function(x) {
      var I = -x.utcOffset(), T = Math.abs(I), j = Math.floor(T / 60), C = T % 60;
      return (I <= 0 ? "+" : "-") + y(j, 2, "0") + ":" + y(C, 2, "0");
    }, m: function x(I, T) {
      if (I.date() < T.date()) return -x(T, I);
      var j = 12 * (T.year() - I.year()) + (T.month() - I.month()), C = I.clone().add(j, d), A = T - C < 0, k = I.clone().add(j + (A ? -1 : 1), d);
      return +(-(j + (T - C) / (A ? C - k : k - C)) || 0);
    }, a: function(x) {
      return x < 0 ? Math.ceil(x) || 0 : Math.floor(x);
    }, p: function(x) {
      return { M: d, y: p, w: l, d: f, D: u, h: c, m: a, s: o, ms: i, Q: g }[x] || String(x || "").toLowerCase().replace(/s$/, "");
    }, u: function(x) {
      return x === void 0;
    } }, R = "en", E = {};
    E[R] = v;
    var O = "$isDayjsObject", z = function(x) {
      return x instanceof U || !(!x || !x[O]);
    }, S = function x(I, T, j) {
      var C;
      if (!I) return R;
      if (typeof I == "string") {
        var A = I.toLowerCase();
        E[A] && (C = A), T && (E[A] = T, C = A);
        var k = I.split("-");
        if (!C && k.length > 1) return x(k[0]);
      } else {
        var P = I.name;
        E[P] = I, C = P;
      }
      return !j && C && (R = C), C || !j && R;
    }, L = function(x, I) {
      if (z(x)) return x.clone();
      var T = typeof I == "object" ? I : {};
      return T.date = x, T.args = arguments, new U(T);
    }, M = _;
    M.l = S, M.i = z, M.w = function(x, I) {
      return L(x, { locale: I.$L, utc: I.$u, x: I.$x, $offset: I.$offset });
    };
    var U = function() {
      function x(T) {
        this.$L = S(T.locale, null, !0), this.parse(T), this.$x = this.$x || T.x || {}, this[O] = !0;
      }
      var I = x.prototype;
      return I.parse = function(T) {
        this.$d = function(j) {
          var C = j.date, A = j.utc;
          if (C === null) return /* @__PURE__ */ new Date(NaN);
          if (M.u(C)) return /* @__PURE__ */ new Date();
          if (C instanceof Date) return new Date(C);
          if (typeof C == "string" && !/Z$/i.test(C)) {
            var k = C.match(b);
            if (k) {
              var P = k[2] - 1 || 0, D = (k[7] || "0").substring(0, 3);
              return A ? new Date(Date.UTC(k[1], P, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, D)) : new Date(k[1], P, k[3] || 1, k[4] || 0, k[5] || 0, k[6] || 0, D);
            }
          }
          return new Date(C);
        }(T), this.init();
      }, I.init = function() {
        var T = this.$d;
        this.$y = T.getFullYear(), this.$M = T.getMonth(), this.$D = T.getDate(), this.$W = T.getDay(), this.$H = T.getHours(), this.$m = T.getMinutes(), this.$s = T.getSeconds(), this.$ms = T.getMilliseconds();
      }, I.$utils = function() {
        return M;
      }, I.isValid = function() {
        return this.$d.toString() !== h;
      }, I.isSame = function(T, j) {
        var C = L(T);
        return this.startOf(j) <= C && C <= this.endOf(j);
      }, I.isAfter = function(T, j) {
        return L(T) < this.startOf(j);
      }, I.isBefore = function(T, j) {
        return this.endOf(j) < L(T);
      }, I.$g = function(T, j, C) {
        return M.u(T) ? this[j] : this.set(C, T);
      }, I.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, I.valueOf = function() {
        return this.$d.getTime();
      }, I.startOf = function(T, j) {
        var C = this, A = !!M.u(j) || j, k = M.p(T), P = function(Z, Y) {
          var J = M.w(C.$u ? Date.UTC(C.$y, Y, Z) : new Date(C.$y, Y, Z), C);
          return A ? J : J.endOf(f);
        }, D = function(Z, Y) {
          return M.w(C.toDate()[Z].apply(C.toDate("s"), (A ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Y)), C);
        }, F = this.$W, w = this.$M, N = this.$D, q = "set" + (this.$u ? "UTC" : "");
        switch (k) {
          case p:
            return A ? P(1, 0) : P(31, 11);
          case d:
            return A ? P(1, w) : P(0, w + 1);
          case l:
            var K = this.$locale().weekStart || 0, V = (F < K ? F + 7 : F) - K;
            return P(A ? N - V : N + (6 - V), w);
          case f:
          case u:
            return D(q + "Hours", 0);
          case c:
            return D(q + "Minutes", 1);
          case a:
            return D(q + "Seconds", 2);
          case o:
            return D(q + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, I.endOf = function(T) {
        return this.startOf(T, !1);
      }, I.$set = function(T, j) {
        var C, A = M.p(T), k = "set" + (this.$u ? "UTC" : ""), P = (C = {}, C[f] = k + "Date", C[u] = k + "Date", C[d] = k + "Month", C[p] = k + "FullYear", C[c] = k + "Hours", C[a] = k + "Minutes", C[o] = k + "Seconds", C[i] = k + "Milliseconds", C)[A], D = A === f ? this.$D + (j - this.$W) : j;
        if (A === d || A === p) {
          var F = this.clone().set(u, 1);
          F.$d[P](D), F.init(), this.$d = F.set(u, Math.min(this.$D, F.daysInMonth())).$d;
        } else P && this.$d[P](D);
        return this.init(), this;
      }, I.set = function(T, j) {
        return this.clone().$set(T, j);
      }, I.get = function(T) {
        return this[M.p(T)]();
      }, I.add = function(T, j) {
        var C, A = this;
        T = Number(T);
        var k = M.p(j), P = function(w) {
          var N = L(A);
          return M.w(N.date(N.date() + Math.round(w * T)), A);
        };
        if (k === d) return this.set(d, this.$M + T);
        if (k === p) return this.set(p, this.$y + T);
        if (k === f) return P(1);
        if (k === l) return P(7);
        var D = (C = {}, C[a] = n, C[c] = s, C[o] = r, C)[k] || 1, F = this.$d.getTime() + T * D;
        return M.w(F, this);
      }, I.subtract = function(T, j) {
        return this.add(-1 * T, j);
      }, I.format = function(T) {
        var j = this, C = this.$locale();
        if (!this.isValid()) return C.invalidDate || h;
        var A = T || "YYYY-MM-DDTHH:mm:ssZ", k = M.z(this), P = this.$H, D = this.$m, F = this.$M, w = C.weekdays, N = C.months, q = C.meridiem, K = function(Y, J, H, W) {
          return Y && (Y[J] || Y(j, A)) || H[J].slice(0, W);
        }, V = function(Y) {
          return M.s(P % 12 || 12, Y, "0");
        }, Z = q || function(Y, J, H) {
          var W = Y < 12 ? "AM" : "PM";
          return H ? W.toLowerCase() : W;
        };
        return A.replace(m, function(Y, J) {
          return J || function(H) {
            switch (H) {
              case "YY":
                return String(j.$y).slice(-2);
              case "YYYY":
                return M.s(j.$y, 4, "0");
              case "M":
                return F + 1;
              case "MM":
                return M.s(F + 1, 2, "0");
              case "MMM":
                return K(C.monthsShort, F, N, 3);
              case "MMMM":
                return K(N, F);
              case "D":
                return j.$D;
              case "DD":
                return M.s(j.$D, 2, "0");
              case "d":
                return String(j.$W);
              case "dd":
                return K(C.weekdaysMin, j.$W, w, 2);
              case "ddd":
                return K(C.weekdaysShort, j.$W, w, 3);
              case "dddd":
                return w[j.$W];
              case "H":
                return String(P);
              case "HH":
                return M.s(P, 2, "0");
              case "h":
                return V(1);
              case "hh":
                return V(2);
              case "a":
                return Z(P, D, !0);
              case "A":
                return Z(P, D, !1);
              case "m":
                return String(D);
              case "mm":
                return M.s(D, 2, "0");
              case "s":
                return String(j.$s);
              case "ss":
                return M.s(j.$s, 2, "0");
              case "SSS":
                return M.s(j.$ms, 3, "0");
              case "Z":
                return k;
            }
            return null;
          }(Y) || k.replace(":", "");
        });
      }, I.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, I.diff = function(T, j, C) {
        var A, k = this, P = M.p(j), D = L(T), F = (D.utcOffset() - this.utcOffset()) * n, w = this - D, N = function() {
          return M.m(k, D);
        };
        switch (P) {
          case p:
            A = N() / 12;
            break;
          case d:
            A = N();
            break;
          case g:
            A = N() / 3;
            break;
          case l:
            A = (w - F) / 6048e5;
            break;
          case f:
            A = (w - F) / 864e5;
            break;
          case c:
            A = w / s;
            break;
          case a:
            A = w / n;
            break;
          case o:
            A = w / r;
            break;
          default:
            A = w;
        }
        return C ? A : M.a(A);
      }, I.daysInMonth = function() {
        return this.endOf(d).$D;
      }, I.$locale = function() {
        return E[this.$L];
      }, I.locale = function(T, j) {
        if (!T) return this.$L;
        var C = this.clone(), A = S(T, j, !0);
        return A && (C.$L = A), C;
      }, I.clone = function() {
        return M.w(this.$d, this);
      }, I.toDate = function() {
        return new Date(this.valueOf());
      }, I.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, I.toISOString = function() {
        return this.$d.toISOString();
      }, I.toString = function() {
        return this.$d.toUTCString();
      }, x;
    }(), $ = U.prototype;
    return L.prototype = $, [["$ms", i], ["$s", o], ["$m", a], ["$H", c], ["$W", f], ["$M", d], ["$y", p], ["$D", u]].forEach(function(x) {
      $[x[1]] = function(I) {
        return this.$g(I, x[0], x[1]);
      };
    }), L.extend = function(x, I) {
      return x.$i || (x(I, U, L), x.$i = !0), L;
    }, L.locale = S, L.isDayjs = z, L.unix = function(x) {
      return L(1e3 * x);
    }, L.en = E[R], L.Ls = E, L.p = {}, L;
  });
})(YE);
var OH = YE.exports;
const CH = /* @__PURE__ */ si(OH);
var ps = { exports: {} }, XE = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  /* The local file header */
  LOCHDR: 30,
  // LOC header size
  LOCSIG: 67324752,
  // "PK\003\004"
  LOCVER: 4,
  // version needed to extract
  LOCFLG: 6,
  // general purpose bit flag
  LOCHOW: 8,
  // compression method
  LOCTIM: 10,
  // modification time (2 bytes time, 2 bytes date)
  LOCCRC: 14,
  // uncompressed file crc-32 value
  LOCSIZ: 18,
  // compressed size
  LOCLEN: 22,
  // uncompressed size
  LOCNAM: 26,
  // filename length
  LOCEXT: 28,
  // extra field length
  /* The Data descriptor */
  EXTSIG: 134695760,
  // "PK\007\008"
  EXTHDR: 16,
  // EXT header size
  EXTCRC: 4,
  // uncompressed file crc-32 value
  EXTSIZ: 8,
  // compressed size
  EXTLEN: 12,
  // uncompressed size
  /* The central directory file header */
  CENHDR: 46,
  // CEN header size
  CENSIG: 33639248,
  // "PK\001\002"
  CENVEM: 4,
  // version made by
  CENVER: 6,
  // version needed to extract
  CENFLG: 8,
  // encrypt, decrypt flags
  CENHOW: 10,
  // compression method
  CENTIM: 12,
  // modification time (2 bytes time, 2 bytes date)
  CENCRC: 16,
  // uncompressed file crc-32 value
  CENSIZ: 20,
  // compressed size
  CENLEN: 24,
  // uncompressed size
  CENNAM: 28,
  // filename length
  CENEXT: 30,
  // extra field length
  CENCOM: 32,
  // file comment length
  CENDSK: 34,
  // volume number start
  CENATT: 36,
  // internal file attributes
  CENATX: 38,
  // external file attributes (host system dependent)
  CENOFF: 42,
  // LOC header offset
  /* The entries in the end of central directory */
  ENDHDR: 22,
  // END header size
  ENDSIG: 101010256,
  // "PK\005\006"
  ENDSUB: 8,
  // number of entries on this disk
  ENDTOT: 10,
  // total number of entries
  ENDSIZ: 12,
  // central directory size in bytes
  ENDOFF: 16,
  // offset of first CEN header
  ENDCOM: 20,
  // zip file comment length
  END64HDR: 20,
  // zip64 END header size
  END64SIG: 117853008,
  // zip64 Locator signature, "PK\006\007"
  END64START: 4,
  // number of the disk with the start of the zip64
  END64OFF: 8,
  // relative offset of the zip64 end of central directory
  END64NUMDISKS: 16,
  // total number of disks
  ZIP64SIG: 101075792,
  // zip64 signature, "PK\006\006"
  ZIP64HDR: 56,
  // zip64 record minimum size
  ZIP64LEAD: 12,
  // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
  ZIP64SIZE: 4,
  // zip64 size of the central directory record
  ZIP64VEM: 12,
  // zip64 version made by
  ZIP64VER: 14,
  // zip64 version needed to extract
  ZIP64DSK: 16,
  // zip64 number of this disk
  ZIP64DSKDIR: 20,
  // number of the disk with the start of the record directory
  ZIP64SUB: 24,
  // number of entries on this disk
  ZIP64TOT: 32,
  // total number of entries
  ZIP64SIZB: 40,
  // zip64 central directory size in bytes
  ZIP64OFF: 48,
  // offset of start of central directory with respect to the starting disk number
  ZIP64EXTRA: 56,
  // extensible data sector
  /* Compression methods */
  STORED: 0,
  // no compression
  SHRUNK: 1,
  // shrunk
  REDUCED1: 2,
  // reduced with compression factor 1
  REDUCED2: 3,
  // reduced with compression factor 2
  REDUCED3: 4,
  // reduced with compression factor 3
  REDUCED4: 5,
  // reduced with compression factor 4
  IMPLODED: 6,
  // imploded
  // 7 reserved for Tokenizing compression algorithm
  DEFLATED: 8,
  // deflated
  ENHANCED_DEFLATED: 9,
  // enhanced deflated
  PKWARE: 10,
  // PKWare DCL imploded
  // 11 reserved by PKWARE
  BZIP2: 12,
  //  compressed using BZIP2
  // 13 reserved by PKWARE
  LZMA: 14,
  // LZMA
  // 15-17 reserved by PKWARE
  IBM_TERSE: 18,
  // compressed using IBM TERSE
  IBM_LZ77: 19,
  // IBM LZ77 z
  AES_ENCRYPT: 99,
  // WinZIP AES encryption method
  /* General purpose bit flag */
  // values can obtained with expression 2**bitnr
  FLG_ENC: 1,
  // Bit 0: encrypted file
  FLG_COMP1: 2,
  // Bit 1, compression option
  FLG_COMP2: 4,
  // Bit 2, compression option
  FLG_DESC: 8,
  // Bit 3, data descriptor
  FLG_ENH: 16,
  // Bit 4, enhanced deflating
  FLG_PATCH: 32,
  // Bit 5, indicates that the file is compressed patched data.
  FLG_STR: 64,
  // Bit 6, strong encryption (patented)
  // Bits 7-10: Currently unused.
  FLG_EFS: 2048,
  // Bit 11: Language encoding flag (EFS)
  // Bit 12: Reserved by PKWARE for enhanced compression.
  // Bit 13: encrypted the Central Directory (patented).
  // Bits 14-15: Reserved by PKWARE.
  FLG_MSK: 4096,
  // mask header values
  /* Load type */
  FILE: 2,
  BUFFER: 1,
  NONE: 0,
  /* 4.5 Extensible data fields */
  EF_ID: 0,
  EF_SIZE: 2,
  /* Header IDs */
  ID_ZIP64: 1,
  ID_AVINFO: 7,
  ID_PFS: 8,
  ID_OS2: 9,
  ID_NTFS: 10,
  ID_OPENVMS: 12,
  ID_UNIX: 13,
  ID_FORK: 14,
  ID_PATCH: 15,
  ID_X509_PKCS7: 20,
  ID_X509_CERTID_F: 21,
  ID_X509_CERTID_C: 22,
  ID_STRONGENC: 23,
  ID_RECORD_MGT: 24,
  ID_X509_PKCS7_RL: 25,
  ID_IBM1: 101,
  ID_IBM2: 102,
  ID_POSZIP: 18064,
  EF_ZIP64_OR_32: 4294967295,
  EF_ZIP64_OR_16: 65535,
  EF_ZIP64_SUNCOMP: 0,
  EF_ZIP64_SCOMP: 8,
  EF_ZIP64_RHO: 16,
  EF_ZIP64_DSN: 24
<<<<<<< HEAD
}, pf = {};
=======
}, Wa = {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
(function(e) {
  const t = {
    /* Header error messages */
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",
    /* Descriptor */
    DESCRIPTOR_NOT_EXIST: "No descriptor present",
    DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
    DESCRIPTOR_FAULTY: "Descriptor data is malformed",
    /* ZipEntry error messages*/
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed {0}",
    FILE_IN_THE_WAY: "There is a file in the way: {0}",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",
    /* Inflater error messages */
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
    /* ADM-ZIP error messages */
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: 'File not found: "{0}"',
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
    INVALID_PASS_PARAM: "Incompatible password parameter",
    WRONG_PASSWORD: "Wrong Password",
    /* ADM-ZIP */
    COMMENT_TOO_LONG: "Comment is too long",
    // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)
    EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
  };
  function r(n) {
<<<<<<< HEAD
    return function(...i) {
      return i.length && (n = n.replace(/\{(\d)\}/g, (s, o) => i[o] || "")), new Error("ADM-ZIP: " + n);
=======
    return function(...s) {
      return s.length && (n = n.replace(/\{(\d)\}/g, (i, o) => s[o] || "")), new Error("ADM-ZIP: " + n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    };
  }
  for (const n of Object.keys(t))
    e[n] = r(t[n]);
<<<<<<< HEAD
})(pf);
const TG = Ye, gt = we, XE = dT, OG = pf, PG = typeof process == "object" && process.platform === "win32", ZE = (e) => typeof e == "object" && e !== null, pT = new Uint32Array(256).map((e, t) => {
=======
})(Wa);
const PH = vt, et = rt, ov = XE, IH = Wa, NH = typeof process == "object" && process.platform === "win32", av = (e) => typeof e == "object" && e !== null, ZE = new Uint32Array(256).map((e, t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  for (let r = 0; r < 8; r++)
    t & 1 ? t = 3988292384 ^ t >>> 1 : t >>>= 1;
  return t >>> 0;
});
<<<<<<< HEAD
function lt(e) {
  this.sep = gt.sep, this.fs = TG, ZE(e) && ZE(e.fs) && typeof e.fs.statSync == "function" && (this.fs = e.fs);
}
var CG = lt;
lt.prototype.makeDir = function(e) {
  const t = this;
  function r(n) {
    let i = n.split(t.sep)[0];
    n.split(t.sep).forEach(function(s) {
      if (!(!s || s.substr(-1, 1) === ":")) {
        i += t.sep + s;
        var o;
        try {
          o = t.fs.statSync(i);
        } catch {
          t.fs.mkdirSync(i);
        }
        if (o && o.isFile()) throw OG.FILE_IN_THE_WAY(`"${i}"`);
=======
function Ge(e) {
  this.sep = et.sep, this.fs = PH, av(e) && av(e.fs) && typeof e.fs.statSync == "function" && (this.fs = e.fs);
}
var AH = Ge;
Ge.prototype.makeDir = function(e) {
  const t = this;
  function r(n) {
    let s = n.split(t.sep)[0];
    n.split(t.sep).forEach(function(i) {
      if (!(!i || i.substr(-1, 1) === ":")) {
        s += t.sep + i;
        var o;
        try {
          o = t.fs.statSync(s);
        } catch {
          t.fs.mkdirSync(s);
        }
        if (o && o.isFile()) throw IH.FILE_IN_THE_WAY(`"${s}"`);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    });
  }
  r(e);
};
<<<<<<< HEAD
lt.prototype.writeFileTo = function(e, t, r, n) {
  const i = this;
  if (i.fs.existsSync(e)) {
    if (!r) return !1;
    var s = i.fs.statSync(e);
    if (s.isDirectory())
      return !1;
  }
  var o = gt.dirname(e);
  i.fs.existsSync(o) || i.makeDir(o);
  var a;
  try {
    a = i.fs.openSync(e, "w", 438);
  } catch {
    i.fs.chmodSync(e, 438), a = i.fs.openSync(e, "w", 438);
  }
  if (a)
    try {
      i.fs.writeSync(a, t, 0, t.length, 0);
    } finally {
      i.fs.closeSync(a);
    }
  return i.fs.chmodSync(e, n || 438), !0;
};
lt.prototype.writeFileToAsync = function(e, t, r, n, i) {
  typeof n == "function" && (i = n, n = void 0);
  const s = this;
  s.fs.exists(e, function(o) {
    if (o && !r) return i(!1);
    s.fs.stat(e, function(a, c) {
      if (o && c.isDirectory())
        return i(!1);
      var u = gt.dirname(e);
      s.fs.exists(u, function(l) {
        l || s.makeDir(u), s.fs.open(e, "w", 438, function(f, m) {
          f ? s.fs.chmod(e, 438, function() {
            s.fs.open(e, "w", 438, function(p, d) {
              s.fs.write(d, t, 0, t.length, 0, function() {
                s.fs.close(d, function() {
                  s.fs.chmod(e, n || 438, function() {
                    i(!0);
=======
Ge.prototype.writeFileTo = function(e, t, r, n) {
  const s = this;
  if (s.fs.existsSync(e)) {
    if (!r) return !1;
    var i = s.fs.statSync(e);
    if (i.isDirectory())
      return !1;
  }
  var o = et.dirname(e);
  s.fs.existsSync(o) || s.makeDir(o);
  var a;
  try {
    a = s.fs.openSync(e, "w", 438);
  } catch {
    s.fs.chmodSync(e, 438), a = s.fs.openSync(e, "w", 438);
  }
  if (a)
    try {
      s.fs.writeSync(a, t, 0, t.length, 0);
    } finally {
      s.fs.closeSync(a);
    }
  return s.fs.chmodSync(e, n || 438), !0;
};
Ge.prototype.writeFileToAsync = function(e, t, r, n, s) {
  typeof n == "function" && (s = n, n = void 0);
  const i = this;
  i.fs.exists(e, function(o) {
    if (o && !r) return s(!1);
    i.fs.stat(e, function(a, c) {
      if (o && c.isDirectory())
        return s(!1);
      var f = et.dirname(e);
      i.fs.exists(f, function(l) {
        l || i.makeDir(f), i.fs.open(e, "w", 438, function(d, g) {
          d ? i.fs.chmod(e, 438, function() {
            i.fs.open(e, "w", 438, function(p, u) {
              i.fs.write(u, t, 0, t.length, 0, function() {
                i.fs.close(u, function() {
                  i.fs.chmod(e, n || 438, function() {
                    s(!0);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                  });
                });
              });
            });
<<<<<<< HEAD
          }) : m ? s.fs.write(m, t, 0, t.length, 0, function() {
            s.fs.close(m, function() {
              s.fs.chmod(e, n || 438, function() {
                i(!0);
              });
            });
          }) : s.fs.chmod(e, n || 438, function() {
            i(!0);
=======
          }) : g ? i.fs.write(g, t, 0, t.length, 0, function() {
            i.fs.close(g, function() {
              i.fs.chmod(e, n || 438, function() {
                s(!0);
              });
            });
          }) : i.fs.chmod(e, n || 438, function() {
            s(!0);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          });
        });
      });
    });
  });
};
<<<<<<< HEAD
lt.prototype.findFiles = function(e) {
  const t = this;
  function r(n, i, s) {
    let o = [];
    return t.fs.readdirSync(n).forEach(function(a) {
      const c = gt.join(n, a), u = t.fs.statSync(c);
      o.push(gt.normalize(c) + (u.isDirectory() ? t.sep : "")), u.isDirectory() && s && (o = o.concat(r(c, i, s)));
=======
Ge.prototype.findFiles = function(e) {
  const t = this;
  function r(n, s, i) {
    let o = [];
    return t.fs.readdirSync(n).forEach(function(a) {
      const c = et.join(n, a), f = t.fs.statSync(c);
      o.push(et.normalize(c) + (f.isDirectory() ? t.sep : "")), f.isDirectory() && i && (o = o.concat(r(c, s, i)));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }), o;
  }
  return r(e, void 0, !0);
};
<<<<<<< HEAD
lt.prototype.findFilesAsync = function(e, t) {
  const r = this;
  let n = [];
  r.fs.readdir(e, function(i, s) {
    if (i) return t(i);
    let o = s.length;
    if (!o) return t(null, n);
    s.forEach(function(a) {
      a = gt.join(e, a), r.fs.stat(a, function(c, u) {
        if (c) return t(c);
        u && (n.push(gt.normalize(a) + (u.isDirectory() ? r.sep : "")), u.isDirectory() ? r.findFilesAsync(a, function(l, f) {
          if (l) return t(l);
          n = n.concat(f), --o || t(null, n);
=======
Ge.prototype.findFilesAsync = function(e, t) {
  const r = this;
  let n = [];
  r.fs.readdir(e, function(s, i) {
    if (s) return t(s);
    let o = i.length;
    if (!o) return t(null, n);
    i.forEach(function(a) {
      a = et.join(e, a), r.fs.stat(a, function(c, f) {
        if (c) return t(c);
        f && (n.push(et.normalize(a) + (f.isDirectory() ? r.sep : "")), f.isDirectory() ? r.findFilesAsync(a, function(l, d) {
          if (l) return t(l);
          n = n.concat(d), --o || t(null, n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }) : --o || t(null, n));
      });
    });
  });
};
<<<<<<< HEAD
lt.prototype.getAttributes = function() {
};
lt.prototype.setAttributes = function() {
};
lt.crc32update = function(e, t) {
  return pT[(e ^ t) & 255] ^ e >>> 8;
};
lt.crc32 = function(e) {
  typeof e == "string" && (e = Buffer.from(e, "utf8"));
  let t = e.length, r = -1;
  for (let n = 0; n < t; ) r = lt.crc32update(r, e[n++]);
  return ~r >>> 0;
};
lt.methodToString = function(e) {
  switch (e) {
    case XE.STORED:
      return "STORED (" + e + ")";
    case XE.DEFLATED:
=======
Ge.prototype.getAttributes = function() {
};
Ge.prototype.setAttributes = function() {
};
Ge.crc32update = function(e, t) {
  return ZE[(e ^ t) & 255] ^ e >>> 8;
};
Ge.crc32 = function(e) {
  typeof e == "string" && (e = Buffer.from(e, "utf8"));
  let t = e.length, r = -1;
  for (let n = 0; n < t; ) r = Ge.crc32update(r, e[n++]);
  return ~r >>> 0;
};
Ge.methodToString = function(e) {
  switch (e) {
    case ov.STORED:
      return "STORED (" + e + ")";
    case ov.DEFLATED:
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      return "DEFLATED (" + e + ")";
    default:
      return "UNSUPPORTED (" + e + ")";
  }
};
<<<<<<< HEAD
lt.canonical = function(e) {
  if (!e) return "";
  const t = gt.posix.normalize("/" + e.split("\\").join("/"));
  return gt.join(".", t);
};
lt.zipnamefix = function(e) {
  if (!e) return "";
  const t = gt.posix.normalize("/" + e.split("\\").join("/"));
  return gt.posix.join(".", t);
};
lt.findLast = function(e, t) {
=======
Ge.canonical = function(e) {
  if (!e) return "";
  const t = et.posix.normalize("/" + e.split("\\").join("/"));
  return et.join(".", t);
};
Ge.zipnamefix = function(e) {
  if (!e) return "";
  const t = et.posix.normalize("/" + e.split("\\").join("/"));
  return et.posix.join(".", t);
};
Ge.findLast = function(e, t) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  if (!Array.isArray(e)) throw new TypeError("arr is not array");
  const r = e.length >>> 0;
  for (let n = r - 1; n >= 0; n--)
    if (t(e[n], n, e))
      return e[n];
};
<<<<<<< HEAD
lt.sanitize = function(e, t) {
  e = gt.resolve(gt.normalize(e));
  for (var r = t.split("/"), n = 0, i = r.length; n < i; n++) {
    var s = gt.normalize(gt.join(e, r.slice(n, i).join(gt.sep)));
    if (s.indexOf(e) === 0)
      return s;
  }
  return gt.normalize(gt.join(e, gt.basename(t)));
};
lt.toBuffer = function(t, r) {
  return Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? Buffer.from(t) : typeof t == "string" ? r(t) : Buffer.alloc(0);
};
lt.readBigUInt64LE = function(e, t) {
  var r = Buffer.from(e.slice(t, t + 8));
  return r.swap64(), parseInt(`0x${r.toString("hex")}`);
};
lt.fromDOS2Date = function(e) {
  return new Date((e >> 25 & 127) + 1980, Math.max((e >> 21 & 15) - 1, 0), Math.max(e >> 16 & 31, 1), e >> 11 & 31, e >> 5 & 63, (e & 31) << 1);
};
lt.fromDate2DOS = function(e) {
  let t = 0, r = 0;
  return e.getFullYear() > 1979 && (t = (e.getFullYear() - 1980 & 127) << 9 | e.getMonth() + 1 << 5 | e.getDate(), r = e.getHours() << 11 | e.getMinutes() << 5 | e.getSeconds() >> 1), t << 16 | r;
};
lt.isWin = PG;
lt.crcTable = pT;
const AG = we;
var IG = function(e, { fs: t }) {
  var r = e || "", n = s(), i = null;
  function s() {
=======
Ge.sanitize = function(e, t) {
  e = et.resolve(et.normalize(e));
  for (var r = t.split("/"), n = 0, s = r.length; n < s; n++) {
    var i = et.normalize(et.join(e, r.slice(n, s).join(et.sep)));
    if (i.indexOf(e) === 0)
      return i;
  }
  return et.normalize(et.join(e, et.basename(t)));
};
Ge.toBuffer = function(t, r) {
  return Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? Buffer.from(t) : typeof t == "string" ? r(t) : Buffer.alloc(0);
};
Ge.readBigUInt64LE = function(e, t) {
  var r = Buffer.from(e.slice(t, t + 8));
  return r.swap64(), parseInt(`0x${r.toString("hex")}`);
};
Ge.fromDOS2Date = function(e) {
  return new Date((e >> 25 & 127) + 1980, Math.max((e >> 21 & 15) - 1, 0), Math.max(e >> 16 & 31, 1), e >> 11 & 31, e >> 5 & 63, (e & 31) << 1);
};
Ge.fromDate2DOS = function(e) {
  let t = 0, r = 0;
  return e.getFullYear() > 1979 && (t = (e.getFullYear() - 1980 & 127) << 9 | e.getMonth() + 1 << 5 | e.getDate(), r = e.getHours() << 11 | e.getMinutes() << 5 | e.getSeconds() >> 1), t << 16 | r;
};
Ge.isWin = NH;
Ge.crcTable = ZE;
const kH = rt;
var LH = function(e, { fs: t }) {
  var r = e || "", n = i(), s = null;
  function i() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return {
      directory: !1,
      readonly: !1,
      hidden: !1,
      executable: !1,
      mtime: 0,
      atime: 0
    };
  }
<<<<<<< HEAD
  return r && t.existsSync(r) ? (i = t.statSync(r), n.directory = i.isDirectory(), n.mtime = i.mtime, n.atime = i.atime, n.executable = (73 & i.mode) !== 0, n.readonly = (128 & i.mode) === 0, n.hidden = AG.basename(r)[0] === ".") : console.warn("Invalid path: " + r), {
=======
  return r && t.existsSync(r) ? (s = t.statSync(r), n.directory = s.isDirectory(), n.mtime = s.mtime, n.atime = s.atime, n.executable = (73 & s.mode) !== 0, n.readonly = (128 & s.mode) === 0, n.hidden = kH.basename(r)[0] === ".") : console.warn("Invalid path: " + r), {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    get directory() {
      return n.directory;
    },
    get readOnly() {
      return n.readonly;
    },
    get hidden() {
      return n.hidden;
    },
    get mtime() {
      return n.mtime;
    },
    get atime() {
      return n.atime;
    },
    get executable() {
      return n.executable;
    },
    decodeAttributes: function() {
    },
    encodeAttributes: function() {
    },
    toJSON: function() {
      return {
        path: r,
        isDirectory: n.directory,
        isReadOnly: n.readonly,
        isHidden: n.hidden,
        isExecutable: n.executable,
        mTime: n.mtime,
        aTime: n.atime
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
<<<<<<< HEAD
}, NG = {
=======
}, jH = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  efs: !0,
  encode: (e) => Buffer.from(e, "utf8"),
  decode: (e) => e.toString("utf8")
};
<<<<<<< HEAD
lo.exports = CG;
lo.exports.Constants = dT;
lo.exports.Errors = pf;
lo.exports.FileAttr = IG;
lo.exports.decoder = NG;
var rc = lo.exports, hf = {}, Fn = rc, oe = Fn.Constants, kG = function() {
  var e = 20, t = 10, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, c = 0, u = 0, l = 0, f = 0, m = 0, p = 0, d = 0;
  e |= Fn.isWin ? 2560 : 768, r |= oe.FLG_EFS;
  const h = {
    extraLen: 0
  }, _ = (v) => Math.max(0, v) >>> 0, g = (v) => Math.max(0, v) & 255;
  return i = Fn.fromDate2DOS(/* @__PURE__ */ new Date()), {
=======
ps.exports = AH;
ps.exports.Constants = XE;
ps.exports.Errors = Wa;
ps.exports.FileAttr = LH;
ps.exports.decoder = jH;
var Ri = ps.exports, Ka = {}, kr = Ri, ne = kr.Constants, DH = function() {
  var e = 20, t = 10, r = 0, n = 0, s = 0, i = 0, o = 0, a = 0, c = 0, f = 0, l = 0, d = 0, g = 0, p = 0, u = 0;
  e |= kr.isWin ? 2560 : 768, r |= ne.FLG_EFS;
  const h = {
    extraLen: 0
  }, b = (v) => Math.max(0, v) >>> 0, m = (v) => Math.max(0, v) & 255;
  return s = kr.fromDate2DOS(/* @__PURE__ */ new Date()), {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    get made() {
      return e;
    },
    set made(v) {
      e = v;
    },
    get version() {
      return t;
    },
    set version(v) {
      t = v;
    },
    get flags() {
      return r;
    },
    set flags(v) {
      r = v;
    },
    get flags_efs() {
<<<<<<< HEAD
      return (r & oe.FLG_EFS) > 0;
    },
    set flags_efs(v) {
      v ? r |= oe.FLG_EFS : r &= ~oe.FLG_EFS;
    },
    get flags_desc() {
      return (r & oe.FLG_DESC) > 0;
    },
    set flags_desc(v) {
      v ? r |= oe.FLG_DESC : r &= ~oe.FLG_DESC;
=======
      return (r & ne.FLG_EFS) > 0;
    },
    set flags_efs(v) {
      v ? r |= ne.FLG_EFS : r &= ~ne.FLG_EFS;
    },
    get flags_desc() {
      return (r & ne.FLG_DESC) > 0;
    },
    set flags_desc(v) {
      v ? r |= ne.FLG_DESC : r &= ~ne.FLG_DESC;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get method() {
      return n;
    },
    set method(v) {
      switch (v) {
<<<<<<< HEAD
        case oe.STORED:
          this.version = 10;
        case oe.DEFLATED:
=======
        case ne.STORED:
          this.version = 10;
        case ne.DEFLATED:
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        default:
          this.version = 20;
      }
      n = v;
    },
    get time() {
<<<<<<< HEAD
      return Fn.fromDOS2Date(this.timeval);
    },
    set time(v) {
      this.timeval = Fn.fromDate2DOS(v);
    },
    get timeval() {
      return i;
    },
    set timeval(v) {
      i = _(v);
    },
    get timeHighByte() {
      return g(i >>> 8);
    },
    get crc() {
      return s;
    },
    set crc(v) {
      s = _(v);
=======
      return kr.fromDOS2Date(this.timeval);
    },
    set time(v) {
      this.timeval = kr.fromDate2DOS(v);
    },
    get timeval() {
      return s;
    },
    set timeval(v) {
      s = b(v);
    },
    get timeHighByte() {
      return m(s >>> 8);
    },
    get crc() {
      return i;
    },
    set crc(v) {
      i = b(v);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get compressedSize() {
      return o;
    },
    set compressedSize(v) {
<<<<<<< HEAD
      o = _(v);
=======
      o = b(v);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get size() {
      return a;
    },
    set size(v) {
<<<<<<< HEAD
      a = _(v);
=======
      a = b(v);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get fileNameLength() {
      return c;
    },
    set fileNameLength(v) {
      c = v;
    },
    get extraLength() {
<<<<<<< HEAD
      return u;
    },
    set extraLength(v) {
      u = v;
=======
      return f;
    },
    set extraLength(v) {
      f = v;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get extraLocalLength() {
      return h.extraLen;
    },
    set extraLocalLength(v) {
      h.extraLen = v;
    },
    get commentLength() {
      return l;
    },
    set commentLength(v) {
      l = v;
    },
    get diskNumStart() {
<<<<<<< HEAD
      return f;
    },
    set diskNumStart(v) {
      f = _(v);
    },
    get inAttr() {
      return m;
    },
    set inAttr(v) {
      m = _(v);
=======
      return d;
    },
    set diskNumStart(v) {
      d = b(v);
    },
    get inAttr() {
      return g;
    },
    set inAttr(v) {
      g = b(v);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get attr() {
      return p;
    },
    set attr(v) {
<<<<<<< HEAD
      p = _(v);
=======
      p = b(v);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    // get Unix file permissions
    get fileAttr() {
      return (p || 0) >> 16 & 4095;
    },
    get offset() {
<<<<<<< HEAD
      return d;
    },
    set offset(v) {
      d = _(v);
    },
    get encrypted() {
      return (r & oe.FLG_ENC) === oe.FLG_ENC;
    },
    get centralHeaderSize() {
      return oe.CENHDR + c + u + l;
    },
    get realDataOffset() {
      return d + oe.LOCHDR + h.fnameLen + h.extraLen;
=======
      return u;
    },
    set offset(v) {
      u = b(v);
    },
    get encrypted() {
      return (r & ne.FLG_ENC) === ne.FLG_ENC;
    },
    get centralHeaderSize() {
      return ne.CENHDR + c + f + l;
    },
    get realDataOffset() {
      return u + ne.LOCHDR + h.fnameLen + h.extraLen;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get localHeader() {
      return h;
    },
    loadLocalHeaderFromBinary: function(v) {
<<<<<<< HEAD
      var y = v.slice(d, d + oe.LOCHDR);
      if (y.readUInt32LE(0) !== oe.LOCSIG)
        throw Fn.Errors.INVALID_LOC();
      h.version = y.readUInt16LE(oe.LOCVER), h.flags = y.readUInt16LE(oe.LOCFLG), h.method = y.readUInt16LE(oe.LOCHOW), h.time = y.readUInt32LE(oe.LOCTIM), h.crc = y.readUInt32LE(oe.LOCCRC), h.compressedSize = y.readUInt32LE(oe.LOCSIZ), h.size = y.readUInt32LE(oe.LOCLEN), h.fnameLen = y.readUInt16LE(oe.LOCNAM), h.extraLen = y.readUInt16LE(oe.LOCEXT);
      const E = d + oe.LOCHDR + h.fnameLen, R = E + h.extraLen;
      return v.slice(E, R);
    },
    loadFromBinary: function(v) {
      if (v.length !== oe.CENHDR || v.readUInt32LE(0) !== oe.CENSIG)
        throw Fn.Errors.INVALID_CEN();
      e = v.readUInt16LE(oe.CENVEM), t = v.readUInt16LE(oe.CENVER), r = v.readUInt16LE(oe.CENFLG), n = v.readUInt16LE(oe.CENHOW), i = v.readUInt32LE(oe.CENTIM), s = v.readUInt32LE(oe.CENCRC), o = v.readUInt32LE(oe.CENSIZ), a = v.readUInt32LE(oe.CENLEN), c = v.readUInt16LE(oe.CENNAM), u = v.readUInt16LE(oe.CENEXT), l = v.readUInt16LE(oe.CENCOM), f = v.readUInt16LE(oe.CENDSK), m = v.readUInt16LE(oe.CENATT), p = v.readUInt32LE(oe.CENATX), d = v.readUInt32LE(oe.CENOFF);
    },
    localHeaderToBinary: function() {
      var v = Buffer.alloc(oe.LOCHDR);
      return v.writeUInt32LE(oe.LOCSIG, 0), v.writeUInt16LE(t, oe.LOCVER), v.writeUInt16LE(r, oe.LOCFLG), v.writeUInt16LE(n, oe.LOCHOW), v.writeUInt32LE(i, oe.LOCTIM), v.writeUInt32LE(s, oe.LOCCRC), v.writeUInt32LE(o, oe.LOCSIZ), v.writeUInt32LE(a, oe.LOCLEN), v.writeUInt16LE(c, oe.LOCNAM), v.writeUInt16LE(h.extraLen, oe.LOCEXT), v;
    },
    centralHeaderToBinary: function() {
      var v = Buffer.alloc(oe.CENHDR + c + u + l);
      return v.writeUInt32LE(oe.CENSIG, 0), v.writeUInt16LE(e, oe.CENVEM), v.writeUInt16LE(t, oe.CENVER), v.writeUInt16LE(r, oe.CENFLG), v.writeUInt16LE(n, oe.CENHOW), v.writeUInt32LE(i, oe.CENTIM), v.writeUInt32LE(s, oe.CENCRC), v.writeUInt32LE(o, oe.CENSIZ), v.writeUInt32LE(a, oe.CENLEN), v.writeUInt16LE(c, oe.CENNAM), v.writeUInt16LE(u, oe.CENEXT), v.writeUInt16LE(l, oe.CENCOM), v.writeUInt16LE(f, oe.CENDSK), v.writeUInt16LE(m, oe.CENATT), v.writeUInt32LE(p, oe.CENATX), v.writeUInt32LE(d, oe.CENOFF), v;
=======
      var y = v.slice(u, u + ne.LOCHDR);
      if (y.readUInt32LE(0) !== ne.LOCSIG)
        throw kr.Errors.INVALID_LOC();
      h.version = y.readUInt16LE(ne.LOCVER), h.flags = y.readUInt16LE(ne.LOCFLG), h.method = y.readUInt16LE(ne.LOCHOW), h.time = y.readUInt32LE(ne.LOCTIM), h.crc = y.readUInt32LE(ne.LOCCRC), h.compressedSize = y.readUInt32LE(ne.LOCSIZ), h.size = y.readUInt32LE(ne.LOCLEN), h.fnameLen = y.readUInt16LE(ne.LOCNAM), h.extraLen = y.readUInt16LE(ne.LOCEXT);
      const _ = u + ne.LOCHDR + h.fnameLen, R = _ + h.extraLen;
      return v.slice(_, R);
    },
    loadFromBinary: function(v) {
      if (v.length !== ne.CENHDR || v.readUInt32LE(0) !== ne.CENSIG)
        throw kr.Errors.INVALID_CEN();
      e = v.readUInt16LE(ne.CENVEM), t = v.readUInt16LE(ne.CENVER), r = v.readUInt16LE(ne.CENFLG), n = v.readUInt16LE(ne.CENHOW), s = v.readUInt32LE(ne.CENTIM), i = v.readUInt32LE(ne.CENCRC), o = v.readUInt32LE(ne.CENSIZ), a = v.readUInt32LE(ne.CENLEN), c = v.readUInt16LE(ne.CENNAM), f = v.readUInt16LE(ne.CENEXT), l = v.readUInt16LE(ne.CENCOM), d = v.readUInt16LE(ne.CENDSK), g = v.readUInt16LE(ne.CENATT), p = v.readUInt32LE(ne.CENATX), u = v.readUInt32LE(ne.CENOFF);
    },
    localHeaderToBinary: function() {
      var v = Buffer.alloc(ne.LOCHDR);
      return v.writeUInt32LE(ne.LOCSIG, 0), v.writeUInt16LE(t, ne.LOCVER), v.writeUInt16LE(r, ne.LOCFLG), v.writeUInt16LE(n, ne.LOCHOW), v.writeUInt32LE(s, ne.LOCTIM), v.writeUInt32LE(i, ne.LOCCRC), v.writeUInt32LE(o, ne.LOCSIZ), v.writeUInt32LE(a, ne.LOCLEN), v.writeUInt16LE(c, ne.LOCNAM), v.writeUInt16LE(h.extraLen, ne.LOCEXT), v;
    },
    centralHeaderToBinary: function() {
      var v = Buffer.alloc(ne.CENHDR + c + f + l);
      return v.writeUInt32LE(ne.CENSIG, 0), v.writeUInt16LE(e, ne.CENVEM), v.writeUInt16LE(t, ne.CENVER), v.writeUInt16LE(r, ne.CENFLG), v.writeUInt16LE(n, ne.CENHOW), v.writeUInt32LE(s, ne.CENTIM), v.writeUInt32LE(i, ne.CENCRC), v.writeUInt32LE(o, ne.CENSIZ), v.writeUInt32LE(a, ne.CENLEN), v.writeUInt16LE(c, ne.CENNAM), v.writeUInt16LE(f, ne.CENEXT), v.writeUInt16LE(l, ne.CENCOM), v.writeUInt16LE(d, ne.CENDSK), v.writeUInt16LE(g, ne.CENATT), v.writeUInt32LE(p, ne.CENATX), v.writeUInt32LE(u, ne.CENOFF), v;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    toJSON: function() {
      const v = function(y) {
        return y + " bytes";
      };
      return {
        made: e,
        version: t,
        flags: r,
<<<<<<< HEAD
        method: Fn.methodToString(n),
        time: this.time,
        crc: "0x" + s.toString(16).toUpperCase(),
        compressedSize: v(o),
        size: v(a),
        fileNameLength: v(c),
        extraLength: v(u),
        commentLength: v(l),
        diskNumStart: f,
        inAttr: m,
        attr: p,
        offset: d,
        centralHeaderSize: v(oe.CENHDR + c + u + l)
=======
        method: kr.methodToString(n),
        time: this.time,
        crc: "0x" + i.toString(16).toUpperCase(),
        compressedSize: v(o),
        size: v(a),
        fileNameLength: v(c),
        extraLength: v(f),
        commentLength: v(l),
        diskNumStart: d,
        inAttr: g,
        attr: p,
        offset: u,
        centralHeaderSize: v(ne.CENHDR + c + f + l)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
<<<<<<< HEAD
}, _s = rc, Ze = _s.Constants, DG = function() {
  var e = 0, t = 0, r = 0, n = 0, i = 0;
=======
}, jn = Ri, De = jn.Constants, FH = function() {
  var e = 0, t = 0, r = 0, n = 0, s = 0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    get diskEntries() {
      return e;
    },
<<<<<<< HEAD
    set diskEntries(s) {
      e = t = s;
=======
    set diskEntries(i) {
      e = t = i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get totalEntries() {
      return t;
    },
<<<<<<< HEAD
    set totalEntries(s) {
      t = e = s;
=======
    set totalEntries(i) {
      t = e = i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get size() {
      return r;
    },
<<<<<<< HEAD
    set size(s) {
      r = s;
=======
    set size(i) {
      r = i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get offset() {
      return n;
    },
<<<<<<< HEAD
    set offset(s) {
      n = s;
    },
    get commentLength() {
      return i;
    },
    set commentLength(s) {
      i = s;
    },
    get mainHeaderSize() {
      return Ze.ENDHDR + i;
    },
    loadFromBinary: function(s) {
      if ((s.length !== Ze.ENDHDR || s.readUInt32LE(0) !== Ze.ENDSIG) && (s.length < Ze.ZIP64HDR || s.readUInt32LE(0) !== Ze.ZIP64SIG))
        throw _s.Errors.INVALID_END();
      s.readUInt32LE(0) === Ze.ENDSIG ? (e = s.readUInt16LE(Ze.ENDSUB), t = s.readUInt16LE(Ze.ENDTOT), r = s.readUInt32LE(Ze.ENDSIZ), n = s.readUInt32LE(Ze.ENDOFF), i = s.readUInt16LE(Ze.ENDCOM)) : (e = _s.readBigUInt64LE(s, Ze.ZIP64SUB), t = _s.readBigUInt64LE(s, Ze.ZIP64TOT), r = _s.readBigUInt64LE(s, Ze.ZIP64SIZE), n = _s.readBigUInt64LE(s, Ze.ZIP64OFF), i = 0);
    },
    toBinary: function() {
      var s = Buffer.alloc(Ze.ENDHDR + i);
      return s.writeUInt32LE(Ze.ENDSIG, 0), s.writeUInt32LE(0, 4), s.writeUInt16LE(e, Ze.ENDSUB), s.writeUInt16LE(t, Ze.ENDTOT), s.writeUInt32LE(r, Ze.ENDSIZ), s.writeUInt32LE(n, Ze.ENDOFF), s.writeUInt16LE(i, Ze.ENDCOM), s.fill(" ", Ze.ENDHDR), s;
    },
    toJSON: function() {
      const s = function(o, a) {
=======
    set offset(i) {
      n = i;
    },
    get commentLength() {
      return s;
    },
    set commentLength(i) {
      s = i;
    },
    get mainHeaderSize() {
      return De.ENDHDR + s;
    },
    loadFromBinary: function(i) {
      if ((i.length !== De.ENDHDR || i.readUInt32LE(0) !== De.ENDSIG) && (i.length < De.ZIP64HDR || i.readUInt32LE(0) !== De.ZIP64SIG))
        throw jn.Errors.INVALID_END();
      i.readUInt32LE(0) === De.ENDSIG ? (e = i.readUInt16LE(De.ENDSUB), t = i.readUInt16LE(De.ENDTOT), r = i.readUInt32LE(De.ENDSIZ), n = i.readUInt32LE(De.ENDOFF), s = i.readUInt16LE(De.ENDCOM)) : (e = jn.readBigUInt64LE(i, De.ZIP64SUB), t = jn.readBigUInt64LE(i, De.ZIP64TOT), r = jn.readBigUInt64LE(i, De.ZIP64SIZE), n = jn.readBigUInt64LE(i, De.ZIP64OFF), s = 0);
    },
    toBinary: function() {
      var i = Buffer.alloc(De.ENDHDR + s);
      return i.writeUInt32LE(De.ENDSIG, 0), i.writeUInt32LE(0, 4), i.writeUInt16LE(e, De.ENDSUB), i.writeUInt16LE(t, De.ENDTOT), i.writeUInt32LE(r, De.ENDSIZ), i.writeUInt32LE(n, De.ENDOFF), i.writeUInt16LE(s, De.ENDCOM), i.fill(" ", De.ENDHDR), i;
    },
    toJSON: function() {
      const i = function(o, a) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        let c = o.toString(16).toUpperCase();
        for (; c.length < a; ) c = "0" + c;
        return "0x" + c;
      };
      return {
        diskEntries: e,
        totalEntries: t,
        size: r + " bytes",
<<<<<<< HEAD
        offset: s(n, 4),
        commentLength: i
=======
        offset: i(n, 4),
        commentLength: s
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
<<<<<<< HEAD
hf.EntryHeader = kG;
hf.MainHeader = DG;
var mf = {}, LG = function(e) {
  var t = Or, r = { chunkSize: (parseInt(e.length / 1024) + 1) * 1024 };
=======
Ka.EntryHeader = DH;
Ka.MainHeader = FH;
var Ja = {}, MH = function(e) {
  var t = fr, r = { chunkSize: (parseInt(e.length / 1024) + 1) * 1024 };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    deflate: function() {
      return t.deflateRawSync(e, r);
    },
    deflateAsync: function(n) {
<<<<<<< HEAD
      var i = t.createDeflateRaw(r), s = [], o = 0;
      i.on("data", function(a) {
        s.push(a), o += a.length;
      }), i.on("end", function() {
        var a = Buffer.alloc(o), c = 0;
        a.fill(0);
        for (var u = 0; u < s.length; u++) {
          var l = s[u];
          l.copy(a, c), c += l.length;
        }
        n && n(a);
      }), i.end(e);
    }
  };
};
const FG = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
var jG = function(e, t) {
  var r = Or;
  const n = FG >= 15 && t > 0 ? { maxOutputLength: t } : {};
=======
      var s = t.createDeflateRaw(r), i = [], o = 0;
      s.on("data", function(a) {
        i.push(a), o += a.length;
      }), s.on("end", function() {
        var a = Buffer.alloc(o), c = 0;
        a.fill(0);
        for (var f = 0; f < i.length; f++) {
          var l = i[f];
          l.copy(a, c), c += l.length;
        }
        n && n(a);
      }), s.end(e);
    }
  };
};
const zH = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
var UH = function(e, t) {
  var r = fr;
  const n = zH >= 15 && t > 0 ? { maxOutputLength: t } : {};
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  return {
    inflate: function() {
      return r.inflateRawSync(e, n);
    },
<<<<<<< HEAD
    inflateAsync: function(i) {
      var s = r.createInflateRaw(n), o = [], a = 0;
      s.on("data", function(c) {
        o.push(c), a += c.length;
      }), s.on("end", function() {
        var c = Buffer.alloc(a), u = 0;
        c.fill(0);
        for (var l = 0; l < o.length; l++) {
          var f = o[l];
          f.copy(c, u), u += f.length;
        }
        i && i(c);
      }), s.end(e);
    }
  };
};
const { randomFillSync: QE } = Gi, UG = pf, MG = new Uint32Array(256).map((e, t) => {
  for (let r = 0; r < 8; r++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t >>>= 1;
  return t >>> 0;
}), hT = (e, t) => Math.imul(e, t) >>> 0, ew = (e, t) => MG[(e ^ t) & 255] ^ e >>> 8, ha = () => typeof QE == "function" ? QE(Buffer.alloc(12)) : ha.node();
ha.node = () => {
=======
    inflateAsync: function(s) {
      var i = r.createInflateRaw(n), o = [], a = 0;
      i.on("data", function(c) {
        o.push(c), a += c.length;
      }), i.on("end", function() {
        var c = Buffer.alloc(a), f = 0;
        c.fill(0);
        for (var l = 0; l < o.length; l++) {
          var d = o[l];
          d.copy(c, f), f += d.length;
        }
        s && s(c);
      }), i.end(e);
    }
  };
};
const { randomFillSync: cv } = bv, qH = Wa, HH = new Uint32Array(256).map((e, t) => {
  for (let r = 0; r < 8; r++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t >>>= 1;
  return t >>> 0;
}), QE = (e, t) => Math.imul(e, t) >>> 0, lv = (e, t) => HH[(e ^ t) & 255] ^ e >>> 8, Zs = () => typeof cv == "function" ? cv(Buffer.alloc(12)) : Zs.node();
Zs.node = () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const e = Buffer.alloc(12), t = e.length;
  for (let r = 0; r < t; r++) e[r] = Math.random() * 256 & 255;
  return e;
};
<<<<<<< HEAD
const Ol = {
  genSalt: ha
};
function gf(e) {
=======
const Co = {
  genSalt: Zs
};
function Ya(e) {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  const t = Buffer.isBuffer(e) ? e : Buffer.from(e);
  this.keys = new Uint32Array([305419896, 591751049, 878082192]);
  for (let r = 0; r < t.length; r++)
    this.updateKeys(t[r]);
}
<<<<<<< HEAD
gf.prototype.updateKeys = function(e) {
  const t = this.keys;
  return t[0] = ew(t[0], e), t[1] += t[0] & 255, t[1] = hT(t[1], 134775813) + 1, t[2] = ew(t[2], t[1] >>> 24), e;
};
gf.prototype.next = function() {
  const e = (this.keys[2] | 2) >>> 0;
  return hT(e, e ^ 1) >> 8 & 255;
};
function HG(e) {
  const t = new gf(e);
  return function(r) {
    const n = Buffer.alloc(r.length);
    let i = 0;
    for (let s of r)
      n[i++] = t.updateKeys(s ^ t.next());
    return n;
  };
}
function qG(e) {
  const t = new gf(e);
  return function(r, n, i = 0) {
    n || (n = Buffer.alloc(r.length));
    for (let s of r) {
      const o = t.next();
      n[i++] = s ^ o, t.updateKeys(s);
=======
Ya.prototype.updateKeys = function(e) {
  const t = this.keys;
  return t[0] = lv(t[0], e), t[1] += t[0] & 255, t[1] = QE(t[1], 134775813) + 1, t[2] = lv(t[2], t[1] >>> 24), e;
};
Ya.prototype.next = function() {
  const e = (this.keys[2] | 2) >>> 0;
  return QE(e, e ^ 1) >> 8 & 255;
};
function BH(e) {
  const t = new Ya(e);
  return function(r) {
    const n = Buffer.alloc(r.length);
    let s = 0;
    for (let i of r)
      n[s++] = t.updateKeys(i ^ t.next());
    return n;
  };
}
function VH(e) {
  const t = new Ya(e);
  return function(r, n, s = 0) {
    n || (n = Buffer.alloc(r.length));
    for (let i of r) {
      const o = t.next();
      n[s++] = i ^ o, t.updateKeys(i);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return n;
  };
}
<<<<<<< HEAD
function BG(e, t, r) {
  if (!e || !Buffer.isBuffer(e) || e.length < 12)
    return Buffer.alloc(0);
  const n = HG(r), i = n(e.slice(0, 12)), s = (t.flags & 8) === 8 ? t.timeHighByte : t.crc >>> 24;
  if (i[11] !== s)
    throw UG.WRONG_PASSWORD();
  return n(e.slice(12));
}
function zG(e) {
  Buffer.isBuffer(e) && e.length >= 12 ? Ol.genSalt = function() {
    return e.slice(0, 12);
  } : e === "node" ? Ol.genSalt = ha.node : Ol.genSalt = ha;
}
function VG(e, t, r, n = !1) {
  e == null && (e = Buffer.alloc(0)), Buffer.isBuffer(e) || (e = Buffer.from(e.toString()));
  const i = qG(r), s = Ol.genSalt();
  s[11] = t.crc >>> 24 & 255, n && (s[10] = t.crc >>> 16 & 255);
  const o = Buffer.alloc(e.length + 12);
  return i(s, o), i(e, o, 12);
}
var GG = { decrypt: BG, encrypt: VG, _salter: zG };
mf.Deflater = LG;
mf.Inflater = jG;
mf.ZipCrypto = GG;
var Fe = rc, WG = hf, nt = Fe.Constants, Fp = mf, mT = function(e, t) {
  var r = new WG.EntryHeader(), n = Buffer.alloc(0), i = Buffer.alloc(0), s = !1, o = null, a = Buffer.alloc(0), c = Buffer.alloc(0), u = !0;
  const l = e, f = typeof l.decoder == "object" ? l.decoder : Fe.decoder;
  u = f.hasOwnProperty("efs") ? f.efs : !1;
  function m() {
=======
function GH(e, t, r) {
  if (!e || !Buffer.isBuffer(e) || e.length < 12)
    return Buffer.alloc(0);
  const n = BH(r), s = n(e.slice(0, 12)), i = (t.flags & 8) === 8 ? t.timeHighByte : t.crc >>> 24;
  if (s[11] !== i)
    throw qH.WRONG_PASSWORD();
  return n(e.slice(12));
}
function WH(e) {
  Buffer.isBuffer(e) && e.length >= 12 ? Co.genSalt = function() {
    return e.slice(0, 12);
  } : e === "node" ? Co.genSalt = Zs.node : Co.genSalt = Zs;
}
function KH(e, t, r, n = !1) {
  e == null && (e = Buffer.alloc(0)), Buffer.isBuffer(e) || (e = Buffer.from(e.toString()));
  const s = VH(r), i = Co.genSalt();
  i[11] = t.crc >>> 24 & 255, n && (i[10] = t.crc >>> 16 & 255);
  const o = Buffer.alloc(e.length + 12);
  return s(i, o), s(e, o, 12);
}
var JH = { decrypt: GH, encrypt: KH, _salter: WH };
Ja.Deflater = MH;
Ja.Inflater = UH;
Ja.ZipCrypto = JH;
var Oe = Ri, YH = Ka, ze = Oe.Constants, Ql = Ja, eS = function(e, t) {
  var r = new YH.EntryHeader(), n = Buffer.alloc(0), s = Buffer.alloc(0), i = !1, o = null, a = Buffer.alloc(0), c = Buffer.alloc(0), f = !0;
  const l = e, d = typeof l.decoder == "object" ? l.decoder : Oe.decoder;
  f = d.hasOwnProperty("efs") ? d.efs : !1;
  function g() {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return !t || !(t instanceof Uint8Array) ? Buffer.alloc(0) : (c = r.loadLocalHeaderFromBinary(t), t.slice(r.realDataOffset, r.realDataOffset + r.compressedSize));
  }
  function p(y) {
    if (r.flags_desc) {
<<<<<<< HEAD
      const E = {}, R = r.realDataOffset + r.compressedSize;
      if (t.readUInt32LE(R) == nt.LOCSIG || t.readUInt32LE(R) == nt.CENSIG)
        throw Fe.Errors.DESCRIPTOR_NOT_EXIST();
      if (t.readUInt32LE(R) == nt.EXTSIG)
        E.crc = t.readUInt32LE(R + nt.EXTCRC), E.compressedSize = t.readUInt32LE(R + nt.EXTSIZ), E.size = t.readUInt32LE(R + nt.EXTLEN);
      else if (t.readUInt16LE(R + 12) === 19280)
        E.crc = t.readUInt32LE(R + nt.EXTCRC - 4), E.compressedSize = t.readUInt32LE(R + nt.EXTSIZ - 4), E.size = t.readUInt32LE(R + nt.EXTLEN - 4);
      else
        throw Fe.Errors.DESCRIPTOR_UNKNOWN();
      if (E.compressedSize !== r.compressedSize || E.size !== r.size || E.crc !== r.crc)
        throw Fe.Errors.DESCRIPTOR_FAULTY();
      if (Fe.crc32(y) !== E.crc)
        return !1;
    } else if (Fe.crc32(y) !== r.localHeader.crc)
      return !1;
    return !0;
  }
  function d(y, E, R) {
    if (typeof E > "u" && typeof y == "string" && (R = y, y = void 0), s)
      return y && E && E(Buffer.alloc(0), Fe.Errors.DIRECTORY_CONTENT_ERROR()), Buffer.alloc(0);
    var w = m();
    if (w.length === 0)
      return y && E && E(w), w;
    if (r.encrypted) {
      if (typeof R != "string" && !Buffer.isBuffer(R))
        throw Fe.Errors.INVALID_PASS_PARAM();
      w = Fp.ZipCrypto.decrypt(w, r, R);
    }
    var C = Buffer.alloc(r.size);
    switch (r.method) {
      case Fe.Constants.STORED:
        if (w.copy(C), p(C))
          return y && E && E(C), C;
        throw y && E && E(C, Fe.Errors.BAD_CRC()), Fe.Errors.BAD_CRC();
      case Fe.Constants.DEFLATED:
        var V = new Fp.Inflater(w, r.size);
        if (y)
          V.inflateAsync(function(b) {
            b.copy(b, 0), E && (p(b) ? E(b) : E(b, Fe.Errors.BAD_CRC()));
          });
        else {
          if (V.inflate(C).copy(C, 0), !p(C))
            throw Fe.Errors.BAD_CRC(`"${f.decode(n)}"`);
          return C;
        }
        break;
      default:
        throw y && E && E(Buffer.alloc(0), Fe.Errors.UNKNOWN_METHOD()), Fe.Errors.UNKNOWN_METHOD();
    }
  }
  function h(y, E) {
    if ((!o || !o.length) && Buffer.isBuffer(t))
      return y && E && E(m()), m();
    if (o.length && !s) {
      var R;
      switch (r.method) {
        case Fe.Constants.STORED:
          return r.compressedSize = r.size, R = Buffer.alloc(o.length), o.copy(R), y && E && E(R), R;
        default:
        case Fe.Constants.DEFLATED:
          var w = new Fp.Deflater(o);
          if (y)
            w.deflateAsync(function(V) {
              R = Buffer.alloc(V.length), r.compressedSize = V.length, V.copy(R), E && E(R);
            });
          else {
            var C = w.deflate();
            return r.compressedSize = C.length, C;
          }
          w = null;
          break;
      }
    } else if (y && E)
      E(Buffer.alloc(0));
    else
      return Buffer.alloc(0);
  }
  function _(y, E) {
    return (y.readUInt32LE(E + 4) << 4) + y.readUInt32LE(E);
  }
  function g(y) {
    try {
      for (var E = 0, R, w, C; E + 4 < y.length; )
        R = y.readUInt16LE(E), E += 2, w = y.readUInt16LE(E), E += 2, C = y.slice(E, E + w), E += w, nt.ID_ZIP64 === R && v(C);
    } catch {
      throw Fe.Errors.EXTRA_FIELD_PARSE_ERROR();
    }
  }
  function v(y) {
    var E, R, w, C;
    y.length >= nt.EF_ZIP64_SCOMP && (E = _(y, nt.EF_ZIP64_SUNCOMP), r.size === nt.EF_ZIP64_OR_32 && (r.size = E)), y.length >= nt.EF_ZIP64_RHO && (R = _(y, nt.EF_ZIP64_SCOMP), r.compressedSize === nt.EF_ZIP64_OR_32 && (r.compressedSize = R)), y.length >= nt.EF_ZIP64_DSN && (w = _(y, nt.EF_ZIP64_RHO), r.offset === nt.EF_ZIP64_OR_32 && (r.offset = w)), y.length >= nt.EF_ZIP64_DSN + 4 && (C = y.readUInt32LE(nt.EF_ZIP64_DSN), r.diskNumStart === nt.EF_ZIP64_OR_16 && (r.diskNumStart = C));
  }
  return {
    get entryName() {
      return f.decode(n);
=======
      const _ = {}, R = r.realDataOffset + r.compressedSize;
      if (t.readUInt32LE(R) == ze.LOCSIG || t.readUInt32LE(R) == ze.CENSIG)
        throw Oe.Errors.DESCRIPTOR_NOT_EXIST();
      if (t.readUInt32LE(R) == ze.EXTSIG)
        _.crc = t.readUInt32LE(R + ze.EXTCRC), _.compressedSize = t.readUInt32LE(R + ze.EXTSIZ), _.size = t.readUInt32LE(R + ze.EXTLEN);
      else if (t.readUInt16LE(R + 12) === 19280)
        _.crc = t.readUInt32LE(R + ze.EXTCRC - 4), _.compressedSize = t.readUInt32LE(R + ze.EXTSIZ - 4), _.size = t.readUInt32LE(R + ze.EXTLEN - 4);
      else
        throw Oe.Errors.DESCRIPTOR_UNKNOWN();
      if (_.compressedSize !== r.compressedSize || _.size !== r.size || _.crc !== r.crc)
        throw Oe.Errors.DESCRIPTOR_FAULTY();
      if (Oe.crc32(y) !== _.crc)
        return !1;
    } else if (Oe.crc32(y) !== r.localHeader.crc)
      return !1;
    return !0;
  }
  function u(y, _, R) {
    if (typeof _ > "u" && typeof y == "string" && (R = y, y = void 0), i)
      return y && _ && _(Buffer.alloc(0), Oe.Errors.DIRECTORY_CONTENT_ERROR()), Buffer.alloc(0);
    var E = g();
    if (E.length === 0)
      return y && _ && _(E), E;
    if (r.encrypted) {
      if (typeof R != "string" && !Buffer.isBuffer(R))
        throw Oe.Errors.INVALID_PASS_PARAM();
      E = Ql.ZipCrypto.decrypt(E, r, R);
    }
    var O = Buffer.alloc(r.size);
    switch (r.method) {
      case Oe.Constants.STORED:
        if (E.copy(O), p(O))
          return y && _ && _(O), O;
        throw y && _ && _(O, Oe.Errors.BAD_CRC()), Oe.Errors.BAD_CRC();
      case Oe.Constants.DEFLATED:
        var z = new Ql.Inflater(E, r.size);
        if (y)
          z.inflateAsync(function(S) {
            S.copy(S, 0), _ && (p(S) ? _(S) : _(S, Oe.Errors.BAD_CRC()));
          });
        else {
          if (z.inflate(O).copy(O, 0), !p(O))
            throw Oe.Errors.BAD_CRC(`"${d.decode(n)}"`);
          return O;
        }
        break;
      default:
        throw y && _ && _(Buffer.alloc(0), Oe.Errors.UNKNOWN_METHOD()), Oe.Errors.UNKNOWN_METHOD();
    }
  }
  function h(y, _) {
    if ((!o || !o.length) && Buffer.isBuffer(t))
      return y && _ && _(g()), g();
    if (o.length && !i) {
      var R;
      switch (r.method) {
        case Oe.Constants.STORED:
          return r.compressedSize = r.size, R = Buffer.alloc(o.length), o.copy(R), y && _ && _(R), R;
        default:
        case Oe.Constants.DEFLATED:
          var E = new Ql.Deflater(o);
          if (y)
            E.deflateAsync(function(z) {
              R = Buffer.alloc(z.length), r.compressedSize = z.length, z.copy(R), _ && _(R);
            });
          else {
            var O = E.deflate();
            return r.compressedSize = O.length, O;
          }
          E = null;
          break;
      }
    } else if (y && _)
      _(Buffer.alloc(0));
    else
      return Buffer.alloc(0);
  }
  function b(y, _) {
    return (y.readUInt32LE(_ + 4) << 4) + y.readUInt32LE(_);
  }
  function m(y) {
    try {
      for (var _ = 0, R, E, O; _ + 4 < y.length; )
        R = y.readUInt16LE(_), _ += 2, E = y.readUInt16LE(_), _ += 2, O = y.slice(_, _ + E), _ += E, ze.ID_ZIP64 === R && v(O);
    } catch {
      throw Oe.Errors.EXTRA_FIELD_PARSE_ERROR();
    }
  }
  function v(y) {
    var _, R, E, O;
    y.length >= ze.EF_ZIP64_SCOMP && (_ = b(y, ze.EF_ZIP64_SUNCOMP), r.size === ze.EF_ZIP64_OR_32 && (r.size = _)), y.length >= ze.EF_ZIP64_RHO && (R = b(y, ze.EF_ZIP64_SCOMP), r.compressedSize === ze.EF_ZIP64_OR_32 && (r.compressedSize = R)), y.length >= ze.EF_ZIP64_DSN && (E = b(y, ze.EF_ZIP64_RHO), r.offset === ze.EF_ZIP64_OR_32 && (r.offset = E)), y.length >= ze.EF_ZIP64_DSN + 4 && (O = y.readUInt32LE(ze.EF_ZIP64_DSN), r.diskNumStart === ze.EF_ZIP64_OR_16 && (r.diskNumStart = O));
  }
  return {
    get entryName() {
      return d.decode(n);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get rawEntryName() {
      return n;
    },
    set entryName(y) {
<<<<<<< HEAD
      n = Fe.toBuffer(y, f.encode);
      var E = n[n.length - 1];
      s = E === 47 || E === 92, r.fileNameLength = n.length;
    },
    get efs() {
      return typeof u == "function" ? u(this.entryName) : u;
=======
      n = Oe.toBuffer(y, d.encode);
      var _ = n[n.length - 1];
      i = _ === 47 || _ === 92, r.fileNameLength = n.length;
    },
    get efs() {
      return typeof f == "function" ? f(this.entryName) : f;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    get extra() {
      return a;
    },
    set extra(y) {
<<<<<<< HEAD
      a = y, r.extraLength = y.length, g(y);
    },
    get comment() {
      return f.decode(i);
    },
    set comment(y) {
      if (i = Fe.toBuffer(y, f.encode), r.commentLength = i.length, i.length > 65535) throw Fe.Errors.COMMENT_TOO_LONG();
    },
    get name() {
      var y = f.decode(n);
      return s ? y.substr(y.length - 1).split("/").pop() : y.split("/").pop();
    },
    get isDirectory() {
      return s;
=======
      a = y, r.extraLength = y.length, m(y);
    },
    get comment() {
      return d.decode(s);
    },
    set comment(y) {
      if (s = Oe.toBuffer(y, d.encode), r.commentLength = s.length, s.length > 65535) throw Oe.Errors.COMMENT_TOO_LONG();
    },
    get name() {
      var y = d.decode(n);
      return i ? y.substr(y.length - 1).split("/").pop() : y.split("/").pop();
    },
    get isDirectory() {
      return i;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    getCompressedData: function() {
      return h(!1, null);
    },
    getCompressedDataAsync: function(y) {
      h(!0, y);
    },
    setData: function(y) {
<<<<<<< HEAD
      o = Fe.toBuffer(y, Fe.decoder.encode), !s && o.length ? (r.size = o.length, r.method = Fe.Constants.DEFLATED, r.crc = Fe.crc32(y), r.changed = !0) : r.method = Fe.Constants.STORED;
    },
    getData: function(y) {
      return r.changed ? o : d(!1, null, y);
    },
    getDataAsync: function(y, E) {
      r.changed ? y(o) : d(!0, y, E);
=======
      o = Oe.toBuffer(y, Oe.decoder.encode), !i && o.length ? (r.size = o.length, r.method = Oe.Constants.DEFLATED, r.crc = Oe.crc32(y), r.changed = !0) : r.method = Oe.Constants.STORED;
    },
    getData: function(y) {
      return r.changed ? o : u(!1, null, y);
    },
    getDataAsync: function(y, _) {
      r.changed ? y(o) : u(!0, y, _);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    set attr(y) {
      r.attr = y;
    },
    get attr() {
      return r.attr;
    },
    set header(y) {
      r.loadFromBinary(y);
    },
    get header() {
      return r;
    },
    packCentralHeader: function() {
      r.flags_efs = this.efs, r.extraLength = a.length;
<<<<<<< HEAD
      var y = r.centralHeaderToBinary(), E = Fe.Constants.CENHDR;
      return n.copy(y, E), E += n.length, a.copy(y, E), E += r.extraLength, i.copy(y, E), y;
=======
      var y = r.centralHeaderToBinary(), _ = Oe.Constants.CENHDR;
      return n.copy(y, _), _ += n.length, a.copy(y, _), _ += r.extraLength, s.copy(y, _), y;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    packLocalHeader: function() {
      let y = 0;
      r.flags_efs = this.efs, r.extraLocalLength = c.length;
<<<<<<< HEAD
      const E = r.localHeaderToBinary(), R = Buffer.alloc(E.length + n.length + r.extraLocalLength);
      return E.copy(R, y), y += E.length, n.copy(R, y), y += n.length, c.copy(R, y), y += c.length, R;
    },
    toJSON: function() {
      const y = function(E) {
        return "<" + (E && E.length + " bytes buffer" || "null") + ">";
=======
      const _ = r.localHeaderToBinary(), R = Buffer.alloc(_.length + n.length + r.extraLocalLength);
      return _.copy(R, y), y += _.length, n.copy(R, y), y += n.length, c.copy(R, y), y += c.length, R;
    },
    toJSON: function() {
      const y = function(_) {
        return "<" + (_ && _.length + " bytes buffer" || "null") + ">";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
      return {
        entryName: this.entryName,
        name: this.name,
        comment: this.comment,
        isDirectory: this.isDirectory,
        header: r.toJSON(),
        compressedData: y(t),
        data: y(o)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
<<<<<<< HEAD
const tw = mT, KG = hf, Ot = rc;
var YG = function(e, t) {
  var r = [], n = {}, i = Buffer.alloc(0), s = new KG.MainHeader(), o = !1;
  const a = /* @__PURE__ */ new Set(), c = t, { noSort: u, decoder: l } = c;
  e ? p(c.readEntries) : o = !0;
  function f() {
    const h = /* @__PURE__ */ new Set();
    for (const _ of Object.keys(n)) {
      const g = _.split("/");
      if (g.pop(), !!g.length)
        for (let v = 0; v < g.length; v++) {
          const y = g.slice(0, v + 1).join("/") + "/";
          h.add(y);
        }
    }
    for (const _ of h)
      if (!(_ in n)) {
        const g = new tw(c);
        g.entryName = _, g.attr = 16, g.temporary = !0, r.push(g), n[g.entryName] = g, a.add(g);
      }
  }
  function m() {
    if (o = !0, n = {}, s.diskEntries > (e.length - s.offset) / Ot.Constants.CENHDR)
      throw Ot.Errors.DISK_ENTRY_TOO_LARGE();
    r = new Array(s.diskEntries);
    for (var h = s.offset, _ = 0; _ < r.length; _++) {
      var g = h, v = new tw(c, e);
      v.header = e.slice(g, g += Ot.Constants.CENHDR), v.entryName = e.slice(g, g += v.header.fileNameLength), v.header.extraLength && (v.extra = e.slice(g, g += v.header.extraLength)), v.header.commentLength && (v.comment = e.slice(g, g + v.header.commentLength)), h += v.header.centralHeaderSize, r[_] = v, n[v.entryName] = v;
    }
    a.clear(), f();
  }
  function p(h) {
    var _ = e.length - Ot.Constants.ENDHDR, g = Math.max(0, _ - 65535), v = g, y = e.length, E = -1, R = 0;
    for ((typeof c.trailingSpace == "boolean" ? c.trailingSpace : !1) && (g = 0), _; _ >= v; _--)
      if (e[_] === 80) {
        if (e.readUInt32LE(_) === Ot.Constants.ENDSIG) {
          E = _, R = _, y = _ + Ot.Constants.ENDHDR, v = _ - Ot.Constants.END64HDR;
          continue;
        }
        if (e.readUInt32LE(_) === Ot.Constants.END64SIG) {
          v = g;
          continue;
        }
        if (e.readUInt32LE(_) === Ot.Constants.ZIP64SIG) {
          E = _, y = _ + Ot.readBigUInt64LE(e, _ + Ot.Constants.ZIP64SIZE) + Ot.Constants.ZIP64LEAD;
          break;
        }
      }
    if (E == -1) throw Ot.Errors.INVALID_FORMAT();
    s.loadFromBinary(e.slice(E, y)), s.commentLength && (i = e.slice(R + Ot.Constants.ENDHDR)), h && m();
  }
  function d() {
    r.length > 1 && !u && r.sort((h, _) => h.entryName.toLowerCase().localeCompare(_.entryName.toLowerCase()));
=======
const uv = eS, XH = Ka, at = Ri;
var ZH = function(e, t) {
  var r = [], n = {}, s = Buffer.alloc(0), i = new XH.MainHeader(), o = !1;
  const a = /* @__PURE__ */ new Set(), c = t, { noSort: f, decoder: l } = c;
  e ? p(c.readEntries) : o = !0;
  function d() {
    const h = /* @__PURE__ */ new Set();
    for (const b of Object.keys(n)) {
      const m = b.split("/");
      if (m.pop(), !!m.length)
        for (let v = 0; v < m.length; v++) {
          const y = m.slice(0, v + 1).join("/") + "/";
          h.add(y);
        }
    }
    for (const b of h)
      if (!(b in n)) {
        const m = new uv(c);
        m.entryName = b, m.attr = 16, m.temporary = !0, r.push(m), n[m.entryName] = m, a.add(m);
      }
  }
  function g() {
    if (o = !0, n = {}, i.diskEntries > (e.length - i.offset) / at.Constants.CENHDR)
      throw at.Errors.DISK_ENTRY_TOO_LARGE();
    r = new Array(i.diskEntries);
    for (var h = i.offset, b = 0; b < r.length; b++) {
      var m = h, v = new uv(c, e);
      v.header = e.slice(m, m += at.Constants.CENHDR), v.entryName = e.slice(m, m += v.header.fileNameLength), v.header.extraLength && (v.extra = e.slice(m, m += v.header.extraLength)), v.header.commentLength && (v.comment = e.slice(m, m + v.header.commentLength)), h += v.header.centralHeaderSize, r[b] = v, n[v.entryName] = v;
    }
    a.clear(), d();
  }
  function p(h) {
    var b = e.length - at.Constants.ENDHDR, m = Math.max(0, b - 65535), v = m, y = e.length, _ = -1, R = 0;
    for ((typeof c.trailingSpace == "boolean" ? c.trailingSpace : !1) && (m = 0), b; b >= v; b--)
      if (e[b] === 80) {
        if (e.readUInt32LE(b) === at.Constants.ENDSIG) {
          _ = b, R = b, y = b + at.Constants.ENDHDR, v = b - at.Constants.END64HDR;
          continue;
        }
        if (e.readUInt32LE(b) === at.Constants.END64SIG) {
          v = m;
          continue;
        }
        if (e.readUInt32LE(b) === at.Constants.ZIP64SIG) {
          _ = b, y = b + at.readBigUInt64LE(e, b + at.Constants.ZIP64SIZE) + at.Constants.ZIP64LEAD;
          break;
        }
      }
    if (_ == -1) throw at.Errors.INVALID_FORMAT();
    i.loadFromBinary(e.slice(_, y)), i.commentLength && (s = e.slice(R + at.Constants.ENDHDR)), h && g();
  }
  function u() {
    r.length > 1 && !f && r.sort((h, b) => h.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  }
  return {
    /**
     * Returns an array of ZipEntry objects existent in the current opened archive
     * @return Array
     */
    get entries() {
<<<<<<< HEAD
      return o || m(), r.filter((h) => !a.has(h));
=======
      return o || g(), r.filter((h) => !a.has(h));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Archive comment
     * @return {String}
     */
    get comment() {
<<<<<<< HEAD
      return l.decode(i);
    },
    set comment(h) {
      i = Ot.toBuffer(h, l.encode), s.commentLength = i.length;
    },
    getEntryCount: function() {
      return o ? r.length : s.diskEntries;
=======
      return l.decode(s);
    },
    set comment(h) {
      s = at.toBuffer(h, l.encode), i.commentLength = s.length;
    },
    getEntryCount: function() {
      return o ? r.length : i.diskEntries;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    forEach: function(h) {
      this.entries.forEach(h);
    },
    /**
     * Returns a reference to the entry with the given name or null if entry is inexistent
     *
     * @param entryName
     * @return ZipEntry
     */
    getEntry: function(h) {
<<<<<<< HEAD
      return o || m(), n[h] || null;
=======
      return o || g(), n[h] || null;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Adds the given entry to the entry list
     *
     * @param entry
     */
    setEntry: function(h) {
<<<<<<< HEAD
      o || m(), r.push(h), n[h.entryName] = h, s.totalEntries = r.length;
=======
      o || g(), r.push(h), n[h.entryName] = h, i.totalEntries = r.length;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Removes the file with the given name from the entry list.
     *
     * If the entry is a directory, then all nested files and directories will be removed
     * @param entryName
     * @returns {void}
     */
<<<<<<< HEAD
    deleteFile: function(h, _ = !0) {
      o || m();
      const g = n[h];
      this.getEntryChildren(g, _).map((y) => y.entryName).forEach(this.deleteEntry);
=======
    deleteFile: function(h, b = !0) {
      o || g();
      const m = n[h];
      this.getEntryChildren(m, b).map((y) => y.entryName).forEach(this.deleteEntry);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Removes the entry with the given name from the entry list.
     *
     * @param {string} entryName
     * @returns {void}
     */
    deleteEntry: function(h) {
<<<<<<< HEAD
      o || m();
      const _ = n[h], g = r.indexOf(_);
      g >= 0 && (r.splice(g, 1), delete n[h], s.totalEntries = r.length);
=======
      o || g();
      const b = n[h], m = r.indexOf(b);
      m >= 0 && (r.splice(m, 1), delete n[h], i.totalEntries = r.length);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     *  Iterates and returns all nested files and directories of the given entry
     *
     * @param entry
     * @return Array
     */
<<<<<<< HEAD
    getEntryChildren: function(h, _ = !0) {
      if (o || m(), typeof h == "object")
        if (h.isDirectory && _) {
          const g = [], v = h.entryName;
          for (const y of r)
            y.entryName.startsWith(v) && g.push(y);
          return g;
=======
    getEntryChildren: function(h, b = !0) {
      if (o || g(), typeof h == "object")
        if (h.isDirectory && b) {
          const m = [], v = h.entryName;
          for (const y of r)
            y.entryName.startsWith(v) && m.push(y);
          return m;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        } else
          return [h];
      return [];
    },
    /**
     *  How many child elements entry has
     *
     * @param {ZipEntry} entry
     * @return {integer}
     */
    getChildCount: function(h) {
      if (h && h.isDirectory) {
<<<<<<< HEAD
        const _ = this.getEntryChildren(h);
        return _.includes(h) ? _.length - 1 : _.length;
=======
        const b = this.getEntryChildren(h);
        return b.includes(h) ? b.length - 1 : b.length;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      return 0;
    },
    /**
     * Returns the zip file
     *
     * @return Buffer
     */
    compressToBuffer: function() {
<<<<<<< HEAD
      o || m(), d();
      const h = [], _ = [];
      let g = 0, v = 0;
      s.size = 0, s.offset = 0;
      let y = 0;
      for (const w of this.entries) {
        const C = w.getCompressedData();
        w.header.offset = v;
        const V = w.packLocalHeader(), b = V.length + C.length;
        v += b, h.push(V), h.push(C);
        const F = w.packCentralHeader();
        _.push(F), s.size += F.length, g += b + F.length, y++;
      }
      g += s.mainHeaderSize, s.offset = v, s.totalEntries = y, v = 0;
      const E = Buffer.alloc(g);
      for (const w of h)
        w.copy(E, v), v += w.length;
      for (const w of _)
        w.copy(E, v), v += w.length;
      const R = s.toBinary();
      return i && i.copy(R, Ot.Constants.ENDHDR), R.copy(E, v), e = E, o = !1, E;
    },
    toAsyncBuffer: function(h, _, g, v) {
      try {
        o || m(), d();
        const y = [], E = [];
        let R = 0, w = 0, C = 0;
        s.size = 0, s.offset = 0;
        const V = function(b) {
          if (b.length > 0) {
            const F = b.shift(), H = F.entryName + F.extra.toString();
            g && g(H), F.getCompressedDataAsync(function(q) {
              v && v(H), F.header.offset = w;
              const $ = F.packLocalHeader(), x = $.length + q.length;
              w += x, y.push($), y.push(q);
              const A = F.packCentralHeader();
              E.push(A), s.size += A.length, R += x + A.length, C++, V(b);
            });
          } else {
            R += s.mainHeaderSize, s.offset = w, s.totalEntries = C, w = 0;
            const F = Buffer.alloc(R);
            y.forEach(function(q) {
              q.copy(F, w), w += q.length;
            }), E.forEach(function(q) {
              q.copy(F, w), w += q.length;
            });
            const H = s.toBinary();
            i && i.copy(H, Ot.Constants.ENDHDR), H.copy(F, w), e = F, o = !1, h(F);
          }
        };
        V(Array.from(this.entries));
      } catch (y) {
        _(y);
=======
      o || g(), u();
      const h = [], b = [];
      let m = 0, v = 0;
      i.size = 0, i.offset = 0;
      let y = 0;
      for (const E of this.entries) {
        const O = E.getCompressedData();
        E.header.offset = v;
        const z = E.packLocalHeader(), S = z.length + O.length;
        v += S, h.push(z), h.push(O);
        const L = E.packCentralHeader();
        b.push(L), i.size += L.length, m += S + L.length, y++;
      }
      m += i.mainHeaderSize, i.offset = v, i.totalEntries = y, v = 0;
      const _ = Buffer.alloc(m);
      for (const E of h)
        E.copy(_, v), v += E.length;
      for (const E of b)
        E.copy(_, v), v += E.length;
      const R = i.toBinary();
      return s && s.copy(R, at.Constants.ENDHDR), R.copy(_, v), e = _, o = !1, _;
    },
    toAsyncBuffer: function(h, b, m, v) {
      try {
        o || g(), u();
        const y = [], _ = [];
        let R = 0, E = 0, O = 0;
        i.size = 0, i.offset = 0;
        const z = function(S) {
          if (S.length > 0) {
            const L = S.shift(), M = L.entryName + L.extra.toString();
            m && m(M), L.getCompressedDataAsync(function(U) {
              v && v(M), L.header.offset = E;
              const $ = L.packLocalHeader(), x = $.length + U.length;
              E += x, y.push($), y.push(U);
              const I = L.packCentralHeader();
              _.push(I), i.size += I.length, R += x + I.length, O++, z(S);
            });
          } else {
            R += i.mainHeaderSize, i.offset = E, i.totalEntries = O, E = 0;
            const L = Buffer.alloc(R);
            y.forEach(function(U) {
              U.copy(L, E), E += U.length;
            }), _.forEach(function(U) {
              U.copy(L, E), E += U.length;
            });
            const M = i.toBinary();
            s && s.copy(M, at.Constants.ENDHDR), M.copy(L, E), e = L, o = !1, h(L);
          }
        };
        z(Array.from(this.entries));
      } catch (y) {
        b(y);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
    }
  };
};
<<<<<<< HEAD
const Qe = rc, it = we, JG = mT, XG = YG, yi = (...e) => Qe.findLast(e, (t) => typeof t == "boolean"), rw = (...e) => Qe.findLast(e, (t) => typeof t == "string"), ZG = (...e) => Qe.findLast(e, (t) => typeof t == "function"), QG = {
=======
const Fe = Ri, Ue = rt, QH = eS, e3 = ZH, Xr = (...e) => Fe.findLast(e, (t) => typeof t == "boolean"), fv = (...e) => Fe.findLast(e, (t) => typeof t == "string"), t3 = (...e) => Fe.findLast(e, (t) => typeof t == "function"), r3 = {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  // option "noSort" : if true it disables files sorting
  noSort: !1,
  // read entries during load (initial loading may be slower)
  readEntries: !1,
  // default method is none
<<<<<<< HEAD
  method: Qe.Constants.NONE,
  // file system
  fs: null
};
var eW = function(e, t) {
  let r = null;
  const n = Object.assign(/* @__PURE__ */ Object.create(null), QG);
  e && typeof e == "object" && (e instanceof Uint8Array || (Object.assign(n, e), e = n.input ? n.input : void 0, n.input && delete n.input), Buffer.isBuffer(e) && (r = e, n.method = Qe.Constants.BUFFER, e = void 0)), Object.assign(n, t);
  const i = new Qe(n);
  if ((typeof n.decoder != "object" || typeof n.decoder.encode != "function" || typeof n.decoder.decode != "function") && (n.decoder = Qe.decoder), e && typeof e == "string")
    if (i.fs.existsSync(e))
      n.method = Qe.Constants.FILE, n.filename = e, r = i.fs.readFileSync(e);
    else
      throw Qe.Errors.INVALID_FILENAME();
  const s = new XG(r, n), { canonical: o, sanitize: a, zipnamefix: c } = Qe;
  function u(p) {
    if (p && s) {
      var d;
      if (typeof p == "string" && (d = s.getEntry(it.posix.normalize(p))), typeof p == "object" && typeof p.entryName < "u" && typeof p.header < "u" && (d = s.getEntry(p.entryName)), d)
        return d;
=======
  method: Fe.Constants.NONE,
  // file system
  fs: null
};
var n3 = function(e, t) {
  let r = null;
  const n = Object.assign(/* @__PURE__ */ Object.create(null), r3);
  e && typeof e == "object" && (e instanceof Uint8Array || (Object.assign(n, e), e = n.input ? n.input : void 0, n.input && delete n.input), Buffer.isBuffer(e) && (r = e, n.method = Fe.Constants.BUFFER, e = void 0)), Object.assign(n, t);
  const s = new Fe(n);
  if ((typeof n.decoder != "object" || typeof n.decoder.encode != "function" || typeof n.decoder.decode != "function") && (n.decoder = Fe.decoder), e && typeof e == "string")
    if (s.fs.existsSync(e))
      n.method = Fe.Constants.FILE, n.filename = e, r = s.fs.readFileSync(e);
    else
      throw Fe.Errors.INVALID_FILENAME();
  const i = new e3(r, n), { canonical: o, sanitize: a, zipnamefix: c } = Fe;
  function f(p) {
    if (p && i) {
      var u;
      if (typeof p == "string" && (u = i.getEntry(Ue.posix.normalize(p))), typeof p == "object" && typeof p.entryName < "u" && typeof p.header < "u" && (u = i.getEntry(p.entryName)), u)
        return u;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    }
    return null;
  }
  function l(p) {
<<<<<<< HEAD
    const { join: d, normalize: h, sep: _ } = it.posix;
    return d(".", h(_ + p.split("\\").join(_) + _));
  }
  function f(p) {
    return p instanceof RegExp ? /* @__PURE__ */ function(d) {
      return function(h) {
        return d.test(h);
      };
    }(p) : typeof p != "function" ? () => !0 : p;
  }
  const m = (p, d) => {
    let h = d.slice(-1);
    return h = h === i.sep ? i.sep : "", it.relative(p, d) + h;
=======
    const { join: u, normalize: h, sep: b } = Ue.posix;
    return u(".", h(b + p.split("\\").join(b) + b));
  }
  function d(p) {
    return p instanceof RegExp ? /* @__PURE__ */ function(u) {
      return function(h) {
        return u.test(h);
      };
    }(p) : typeof p != "function" ? () => !0 : p;
  }
  const g = (p, u) => {
    let h = u.slice(-1);
    return h = h === s.sep ? s.sep : "", Ue.relative(p, u) + h;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
  };
  return {
    /**
     * Extracts the given entry from the archive and returns the content as a Buffer object
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {Buffer|string} [pass] - password
     * @return Buffer or Null in case of error
     */
<<<<<<< HEAD
    readFile: function(p, d) {
      var h = u(p);
      return h && h.getData(d) || null;
=======
    readFile: function(p, u) {
      var h = f(p);
      return h && h.getData(u) || null;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Returns how many child elements has on entry (directories) on files it is always 0
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @returns {integer}
     */
    childCount: function(p) {
<<<<<<< HEAD
      const d = u(p);
      if (d)
        return s.getChildCount(d);
=======
      const u = f(p);
      if (u)
        return i.getChildCount(u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Asynchronous readFile
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     *
     * @return Buffer or Null in case of error
     */
<<<<<<< HEAD
    readFileAsync: function(p, d) {
      var h = u(p);
      h ? h.getDataAsync(d) : d(null, "getEntry failed for:" + p);
=======
    readFileAsync: function(p, u) {
      var h = f(p);
      h ? h.getDataAsync(u) : u(null, "getEntry failed for:" + p);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
     * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry
     * @param {string} encoding - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
<<<<<<< HEAD
    readAsText: function(p, d) {
      var h = u(p);
      if (h) {
        var _ = h.getData();
        if (_ && _.length)
          return _.toString(d || "utf8");
=======
    readAsText: function(p, u) {
      var h = f(p);
      if (h) {
        var b = h.getData();
        if (b && b.length)
          return b.toString(u || "utf8");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      return "";
    },
    /**
     * Asynchronous readAsText
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
<<<<<<< HEAD
    readAsTextAsync: function(p, d, h) {
      var _ = u(p);
      _ ? _.getDataAsync(function(g, v) {
        if (v) {
          d(g, v);
          return;
        }
        g && g.length ? d(g.toString(h || "utf8")) : d("");
      }) : d("");
=======
    readAsTextAsync: function(p, u, h) {
      var b = f(p);
      b ? b.getDataAsync(function(m, v) {
        if (v) {
          u(m, v);
          return;
        }
        m && m.length ? u(m.toString(h || "utf8")) : u("");
      }) : u("");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
<<<<<<< HEAD
    deleteFile: function(p, d = !0) {
      var h = u(p);
      h && s.deleteFile(h.entryName, d);
=======
    deleteFile: function(p, u = !0) {
      var h = f(p);
      h && i.deleteFile(h.entryName, u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Remove the entry from the file or directory without affecting any nested entries
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteEntry: function(p) {
<<<<<<< HEAD
      var d = u(p);
      d && s.deleteEntry(d.entryName);
=======
      var u = f(p);
      u && i.deleteEntry(u.entryName);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
     *
     * @param {string} comment
     */
    addZipComment: function(p) {
<<<<<<< HEAD
      s.comment = p;
=======
      i.comment = p;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Returns the zip comment
     *
     * @return String
     */
    getZipComment: function() {
<<<<<<< HEAD
      return s.comment || "";
=======
      return i.comment || "";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
     * The comment cannot exceed 65535 characters in length
     *
     * @param {ZipEntry} entry
     * @param {string} comment
     */
<<<<<<< HEAD
    addZipEntryComment: function(p, d) {
      var h = u(p);
      h && (h.comment = d);
=======
    addZipEntryComment: function(p, u) {
      var h = f(p);
      h && (h.comment = u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Returns the comment of the specified entry
     *
     * @param {ZipEntry} entry
     * @return String
     */
    getZipEntryComment: function(p) {
<<<<<<< HEAD
      var d = u(p);
      return d && d.comment || "";
=======
      var u = f(p);
      return u && u.comment || "";
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
     *
     * @param {ZipEntry} entry
     * @param {Buffer} content
     */
<<<<<<< HEAD
    updateFile: function(p, d) {
      var h = u(p);
      h && h.setData(d);
=======
    updateFile: function(p, u) {
      var h = f(p);
      h && h.setData(u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Adds a file from the disk to the archive
     *
     * @param {string} localPath File to add to zip
     * @param {string} [zipPath] Optional path inside the zip
     * @param {string} [zipName] Optional name for the file
     * @param {string} [comment] Optional file comment
     */
<<<<<<< HEAD
    addLocalFile: function(p, d, h, _) {
      if (i.fs.existsSync(p)) {
        d = d ? l(d) : "";
        const g = it.win32.basename(it.win32.normalize(p));
        d += h || g;
        const v = i.fs.statSync(p), y = v.isFile() ? i.fs.readFileSync(p) : Buffer.alloc(0);
        v.isDirectory() && (d += i.sep), this.addFile(d, y, _, v);
      } else
        throw Qe.Errors.FILE_NOT_FOUND(p);
=======
    addLocalFile: function(p, u, h, b) {
      if (s.fs.existsSync(p)) {
        u = u ? l(u) : "";
        const m = Ue.win32.basename(Ue.win32.normalize(p));
        u += h || m;
        const v = s.fs.statSync(p), y = v.isFile() ? s.fs.readFileSync(p) : Buffer.alloc(0);
        v.isDirectory() && (u += s.sep), this.addFile(u, y, b, v);
      } else
        throw Fe.Errors.FILE_NOT_FOUND(p);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Callback for showing if everything was done.
     *
     * @callback doneCallback
     * @param {Error} err - Error object
     * @param {boolean} done - was request fully completed
     */
    /**
     * Adds a file from the disk to the archive
     *
     * @param {(object|string)} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the file.
     * @param {string} [options.comment] - Optional file comment.
     * @param {string} [options.zipPath] - Optional path inside the zip
     * @param {string} [options.zipName] - Optional name for the file
     * @param {doneCallback} callback - The callback that handles the response.
     */
<<<<<<< HEAD
    addLocalFileAsync: function(p, d) {
      p = typeof p == "object" ? p : { localPath: p };
      const h = it.resolve(p.localPath), { comment: _ } = p;
      let { zipPath: g, zipName: v } = p;
      const y = this;
      i.fs.stat(h, function(E, R) {
        if (E) return d(E, !1);
        g = g ? l(g) : "";
        const w = it.win32.basename(it.win32.normalize(h));
        if (g += v || w, R.isFile())
          i.fs.readFile(h, function(C, V) {
            return C ? d(C, !1) : (y.addFile(g, V, _, R), setImmediate(d, void 0, !0));
          });
        else if (R.isDirectory())
          return g += i.sep, y.addFile(g, Buffer.alloc(0), _, R), setImmediate(d, void 0, !0);
=======
    addLocalFileAsync: function(p, u) {
      p = typeof p == "object" ? p : { localPath: p };
      const h = Ue.resolve(p.localPath), { comment: b } = p;
      let { zipPath: m, zipName: v } = p;
      const y = this;
      s.fs.stat(h, function(_, R) {
        if (_) return u(_, !1);
        m = m ? l(m) : "";
        const E = Ue.win32.basename(Ue.win32.normalize(h));
        if (m += v || E, R.isFile())
          s.fs.readFile(h, function(O, z) {
            return O ? u(O, !1) : (y.addFile(m, z, b, R), setImmediate(u, void 0, !0));
          });
        else if (R.isDirectory())
          return m += s.sep, y.addFile(m, Buffer.alloc(0), b, R), setImmediate(u, void 0, !0);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - local path to the folder
     * @param {string} [zipPath] - optional path inside zip
     * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.
     */
<<<<<<< HEAD
    addLocalFolder: function(p, d, h) {
      if (h = f(h), d = d ? l(d) : "", p = it.normalize(p), i.fs.existsSync(p)) {
        const _ = i.findFiles(p), g = this;
        if (_.length)
          for (const v of _) {
            const y = it.join(d, m(p, v));
            h(y) && g.addLocalFile(v, it.dirname(y));
          }
      } else
        throw Qe.Errors.FILE_NOT_FOUND(p);
=======
    addLocalFolder: function(p, u, h) {
      if (h = d(h), u = u ? l(u) : "", p = Ue.normalize(p), s.fs.existsSync(p)) {
        const b = s.findFiles(p), m = this;
        if (b.length)
          for (const v of b) {
            const y = Ue.join(u, g(p, v));
            h(y) && m.addLocalFile(v, Ue.dirname(y));
          }
      } else
        throw Fe.Errors.FILE_NOT_FOUND(p);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Asynchronous addLocalFolder
     * @param {string} localPath
     * @param {callback} callback
     * @param {string} [zipPath] optional path inside zip
     * @param {RegExp|function} [filter] optional RegExp or Function if files match will
     *               be included.
     */
<<<<<<< HEAD
    addLocalFolderAsync: function(p, d, h, _) {
      _ = f(_), h = h ? l(h) : "", p = it.normalize(p);
      var g = this;
      i.fs.open(p, "r", function(v) {
        if (v && v.code === "ENOENT")
          d(void 0, Qe.Errors.FILE_NOT_FOUND(p));
        else if (v)
          d(void 0, v);
        else {
          var y = i.findFiles(p), E = -1, R = function() {
            if (E += 1, E < y.length) {
              var w = y[E], C = m(p, w).split("\\").join("/");
              C = C.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, ""), _(C) ? i.fs.stat(w, function(V, b) {
                V && d(void 0, V), b.isFile() ? i.fs.readFile(w, function(F, H) {
                  F ? d(void 0, F) : (g.addFile(h + C, H, "", b), R());
                }) : (g.addFile(h + C + "/", Buffer.alloc(0), "", b), R());
=======
    addLocalFolderAsync: function(p, u, h, b) {
      b = d(b), h = h ? l(h) : "", p = Ue.normalize(p);
      var m = this;
      s.fs.open(p, "r", function(v) {
        if (v && v.code === "ENOENT")
          u(void 0, Fe.Errors.FILE_NOT_FOUND(p));
        else if (v)
          u(void 0, v);
        else {
          var y = s.findFiles(p), _ = -1, R = function() {
            if (_ += 1, _ < y.length) {
              var E = y[_], O = g(p, E).split("\\").join("/");
              O = O.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, ""), b(O) ? s.fs.stat(E, function(z, S) {
                z && u(void 0, z), S.isFile() ? s.fs.readFile(E, function(L, M) {
                  L ? u(void 0, L) : (m.addFile(h + O, M, "", S), R());
                }) : (m.addFile(h + O + "/", Buffer.alloc(0), "", S), R());
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
              }) : process.nextTick(() => {
                R();
              });
            } else
<<<<<<< HEAD
              d(!0, void 0);
=======
              u(!0, void 0);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          };
          R();
        }
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {object | string} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the folder.
     * @param {string} [options.zipPath] - optional path inside zip.
     * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [options.namefix] - optional function to help fix filename
     * @param {doneCallback} callback - The callback that handles the response.
     *
     */
<<<<<<< HEAD
    addLocalFolderAsync2: function(p, d) {
      const h = this;
      p = typeof p == "object" ? p : { localPath: p }, localPath = it.resolve(l(p.localPath));
      let { zipPath: _, filter: g, namefix: v } = p;
      g instanceof RegExp ? g = /* @__PURE__ */ function(R) {
        return function(w) {
          return R.test(w);
        };
      }(g) : typeof g != "function" && (g = function() {
        return !0;
      }), _ = _ ? l(_) : "", v == "latin1" && (v = (R) => R.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "")), typeof v != "function" && (v = (R) => R);
      const y = (R) => it.join(_, v(m(localPath, R))), E = (R) => it.win32.basename(it.win32.normalize(v(R)));
      i.fs.open(localPath, "r", function(R) {
        R && R.code === "ENOENT" ? d(void 0, Qe.Errors.FILE_NOT_FOUND(localPath)) : R ? d(void 0, R) : i.findFilesAsync(localPath, function(w, C) {
          if (w) return d(w);
          C = C.filter((V) => g(y(V))), C.length || d(void 0, !1), setImmediate(
            C.reverse().reduce(function(V, b) {
              return function(F, H) {
                if (F || H === !1) return setImmediate(V, F, !1);
                h.addLocalFileAsync(
                  {
                    localPath: b,
                    zipPath: it.dirname(y(b)),
                    zipName: E(b)
                  },
                  V
                );
              };
            }, d)
=======
    addLocalFolderAsync2: function(p, u) {
      const h = this;
      p = typeof p == "object" ? p : { localPath: p }, localPath = Ue.resolve(l(p.localPath));
      let { zipPath: b, filter: m, namefix: v } = p;
      m instanceof RegExp ? m = /* @__PURE__ */ function(R) {
        return function(E) {
          return R.test(E);
        };
      }(m) : typeof m != "function" && (m = function() {
        return !0;
      }), b = b ? l(b) : "", v == "latin1" && (v = (R) => R.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "")), typeof v != "function" && (v = (R) => R);
      const y = (R) => Ue.join(b, v(g(localPath, R))), _ = (R) => Ue.win32.basename(Ue.win32.normalize(v(R)));
      s.fs.open(localPath, "r", function(R) {
        R && R.code === "ENOENT" ? u(void 0, Fe.Errors.FILE_NOT_FOUND(localPath)) : R ? u(void 0, R) : s.findFilesAsync(localPath, function(E, O) {
          if (E) return u(E);
          O = O.filter((z) => m(y(z))), O.length || u(void 0, !1), setImmediate(
            O.reverse().reduce(function(z, S) {
              return function(L, M) {
                if (L || M === !1) return setImmediate(z, L, !1);
                h.addLocalFileAsync(
                  {
                    localPath: S,
                    zipPath: Ue.dirname(y(S)),
                    zipName: _(S)
                  },
                  z
                );
              };
            }, u)
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          );
        });
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - path where files will be extracted
     * @param {object} props - optional properties
     * @param {string} [props.zipPath] - optional path inside zip
     * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [props.namefix] - optional function to help fix filename
     */
<<<<<<< HEAD
    addLocalFolderPromise: function(p, d) {
      return new Promise((h, _) => {
        this.addLocalFolderAsync2(Object.assign({ localPath: p }, d), (g, v) => {
          g && _(g), v && h(this);
=======
    addLocalFolderPromise: function(p, u) {
      return new Promise((h, b) => {
        this.addLocalFolderAsync2(Object.assign({ localPath: p }, u), (m, v) => {
          m && b(m), v && h(this);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      });
    },
    /**
     * Allows you to create a entry (file or directory) in the zip file.
     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
     * Comment and attributes are optional
     *
     * @param {string} entryName
     * @param {Buffer | string} content - file content as buffer or utf8 coded string
     * @param {string} [comment] - file comment
     * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object
     */
<<<<<<< HEAD
    addFile: function(p, d, h, _) {
      p = c(p);
      let g = u(p);
      const v = g != null;
      v || (g = new JG(n), g.entryName = p), g.comment = h || "";
      const y = typeof _ == "object" && _ instanceof i.fs.Stats;
      y && (g.header.time = _.mtime);
      var E = g.isDirectory ? 16 : 0;
      let R = g.isDirectory ? 16384 : 32768;
      return y ? R |= 4095 & _.mode : typeof _ == "number" ? R |= 4095 & _ : R |= g.isDirectory ? 493 : 420, E = (E | R << 16) >>> 0, g.attr = E, g.setData(d), v || s.setEntry(g), g;
=======
    addFile: function(p, u, h, b) {
      p = c(p);
      let m = f(p);
      const v = m != null;
      v || (m = new QH(n), m.entryName = p), m.comment = h || "";
      const y = typeof b == "object" && b instanceof s.fs.Stats;
      y && (m.header.time = b.mtime);
      var _ = m.isDirectory ? 16 : 0;
      let R = m.isDirectory ? 16384 : 32768;
      return y ? R |= 4095 & b.mode : typeof b == "number" ? R |= 4095 & b : R |= m.isDirectory ? 493 : 420, _ = (_ | R << 16) >>> 0, m.attr = _, m.setData(u), v || i.setEntry(m), m;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Returns an array of ZipEntry objects representing the files and folders inside the archive
     *
     * @param {string} [password]
     * @returns Array
     */
    getEntries: function(p) {
<<<<<<< HEAD
      return s.password = p, s ? s.entries : [];
=======
      return i.password = p, i ? i.entries : [];
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Returns a ZipEntry object representing the file or folder specified by ``name``.
     *
     * @param {string} name
     * @return ZipEntry
     */
    getEntry: function(p) {
<<<<<<< HEAD
      return u(p);
    },
    getEntryCount: function() {
      return s.getEntryCount();
    },
    forEach: function(p) {
      return s.forEach(p);
=======
      return f(p);
    },
    getEntryCount: function() {
      return i.getEntryCount();
    },
    forEach: function(p) {
      return i.forEach(p);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Extracts the given entry to the given targetPath
     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
     *
     * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry
     * @param {string} targetPath - Target folder where to write the file
     * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE
     * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.
     * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.
     * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)
     *
     * @return Boolean
     */
<<<<<<< HEAD
    extractEntryTo: function(p, d, h, _, g, v) {
      _ = yi(!1, _), g = yi(!1, g), h = yi(!0, h), v = rw(g, v);
      var y = u(p);
      if (!y)
        throw Qe.Errors.NO_ENTRY();
      var E = o(y.entryName), R = a(d, v && !y.isDirectory ? v : h ? E : it.basename(E));
      if (y.isDirectory) {
        var w = s.getEntryChildren(y);
        return w.forEach(function(b) {
          if (b.isDirectory) return;
          var F = b.getData();
          if (!F)
            throw Qe.Errors.CANT_EXTRACT_FILE();
          var H = o(b.entryName), q = a(d, h ? H : it.basename(H));
          const $ = g ? b.header.fileAttr : void 0;
          i.writeFileTo(q, F, _, $);
        }), !0;
      }
      var C = y.getData(s.password);
      if (!C) throw Qe.Errors.CANT_EXTRACT_FILE();
      if (i.fs.existsSync(R) && !_)
        throw Qe.Errors.CANT_OVERRIDE();
      const V = g ? p.header.fileAttr : void 0;
      return i.writeFileTo(R, C, _, V), !0;
=======
    extractEntryTo: function(p, u, h, b, m, v) {
      b = Xr(!1, b), m = Xr(!1, m), h = Xr(!0, h), v = fv(m, v);
      var y = f(p);
      if (!y)
        throw Fe.Errors.NO_ENTRY();
      var _ = o(y.entryName), R = a(u, v && !y.isDirectory ? v : h ? _ : Ue.basename(_));
      if (y.isDirectory) {
        var E = i.getEntryChildren(y);
        return E.forEach(function(S) {
          if (S.isDirectory) return;
          var L = S.getData();
          if (!L)
            throw Fe.Errors.CANT_EXTRACT_FILE();
          var M = o(S.entryName), U = a(u, h ? M : Ue.basename(M));
          const $ = m ? S.header.fileAttr : void 0;
          s.writeFileTo(U, L, b, $);
        }), !0;
      }
      var O = y.getData(i.password);
      if (!O) throw Fe.Errors.CANT_EXTRACT_FILE();
      if (s.fs.existsSync(R) && !b)
        throw Fe.Errors.CANT_OVERRIDE();
      const z = m ? p.header.fileAttr : void 0;
      return s.writeFileTo(R, O, b, z), !0;
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Test the archive
     * @param {string} [pass]
     */
    test: function(p) {
<<<<<<< HEAD
      if (!s)
        return !1;
      for (var d in s.entries)
        try {
          if (d.isDirectory)
            continue;
          var h = s.entries[d].getData(p);
=======
      if (!i)
        return !1;
      for (var u in i.entries)
        try {
          if (u.isDirectory)
            continue;
          var h = i.entries[u].getData(p);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          if (!h)
            return !1;
        } catch {
          return !1;
        }
      return !0;
    },
    /**
     * Extracts the entire archive to the given location
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {string|Buffer} [pass] password
     */
<<<<<<< HEAD
    extractAllTo: function(p, d, h, _) {
      if (h = yi(!1, h), _ = rw(h, _), d = yi(!1, d), !s) throw Qe.Errors.NO_ZIP();
      s.entries.forEach(function(g) {
        var v = a(p, o(g.entryName));
        if (g.isDirectory) {
          i.makeDir(v);
          return;
        }
        var y = g.getData(_);
        if (!y)
          throw Qe.Errors.CANT_EXTRACT_FILE();
        const E = h ? g.header.fileAttr : void 0;
        i.writeFileTo(v, y, d, E);
        try {
          i.fs.utimesSync(v, g.header.time, g.header.time);
        } catch {
          throw Qe.Errors.CANT_EXTRACT_FILE();
=======
    extractAllTo: function(p, u, h, b) {
      if (h = Xr(!1, h), b = fv(h, b), u = Xr(!1, u), !i) throw Fe.Errors.NO_ZIP();
      i.entries.forEach(function(m) {
        var v = a(p, o(m.entryName));
        if (m.isDirectory) {
          s.makeDir(v);
          return;
        }
        var y = m.getData(b);
        if (!y)
          throw Fe.Errors.CANT_EXTRACT_FILE();
        const _ = h ? m.header.fileAttr : void 0;
        s.writeFileTo(v, y, u, _);
        try {
          s.fs.utimesSync(v, m.header.time, m.header.time);
        } catch {
          throw Fe.Errors.CANT_EXTRACT_FILE();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      });
    },
    /**
     * Asynchronous extractAllTo
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.
     */
<<<<<<< HEAD
    extractAllToAsync: function(p, d, h, _) {
      if (_ = ZG(d, h, _), h = yi(!1, h), d = yi(!1, d), !_)
        return new Promise((R, w) => {
          this.extractAllToAsync(p, d, h, function(C) {
            C ? w(C) : R(this);
          });
        });
      if (!s) {
        _(Qe.Errors.NO_ZIP());
        return;
      }
      p = it.resolve(p);
      const g = (R) => a(p, it.normalize(o(R.entryName))), v = (R, w) => new Error(R + ': "' + w + '"'), y = [], E = [];
      s.entries.forEach((R) => {
        R.isDirectory ? y.push(R) : E.push(R);
      });
      for (const R of y) {
        const w = g(R), C = h ? R.header.fileAttr : void 0;
        try {
          i.makeDir(w), C && i.fs.chmodSync(w, C), i.fs.utimesSync(w, R.header.time, R.header.time);
        } catch {
          _(v("Unable to create folder", w));
        }
      }
      E.reverse().reduce(function(R, w) {
        return function(C) {
          if (C)
            R(C);
          else {
            const V = it.normalize(o(w.entryName)), b = a(p, V);
            w.getDataAsync(function(F, H) {
              if (H)
                R(H);
              else if (!F)
                R(Qe.Errors.CANT_EXTRACT_FILE());
              else {
                const q = h ? w.header.fileAttr : void 0;
                i.writeFileToAsync(b, F, d, q, function($) {
                  $ || R(v("Unable to write file", b)), i.fs.utimes(b, w.header.time, w.header.time, function(x) {
                    x ? R(v("Unable to set times", b)) : R();
=======
    extractAllToAsync: function(p, u, h, b) {
      if (b = t3(u, h, b), h = Xr(!1, h), u = Xr(!1, u), !b)
        return new Promise((R, E) => {
          this.extractAllToAsync(p, u, h, function(O) {
            O ? E(O) : R(this);
          });
        });
      if (!i) {
        b(Fe.Errors.NO_ZIP());
        return;
      }
      p = Ue.resolve(p);
      const m = (R) => a(p, Ue.normalize(o(R.entryName))), v = (R, E) => new Error(R + ': "' + E + '"'), y = [], _ = [];
      i.entries.forEach((R) => {
        R.isDirectory ? y.push(R) : _.push(R);
      });
      for (const R of y) {
        const E = m(R), O = h ? R.header.fileAttr : void 0;
        try {
          s.makeDir(E), O && s.fs.chmodSync(E, O), s.fs.utimesSync(E, R.header.time, R.header.time);
        } catch {
          b(v("Unable to create folder", E));
        }
      }
      _.reverse().reduce(function(R, E) {
        return function(O) {
          if (O)
            R(O);
          else {
            const z = Ue.normalize(o(E.entryName)), S = a(p, z);
            E.getDataAsync(function(L, M) {
              if (M)
                R(M);
              else if (!L)
                R(Fe.Errors.CANT_EXTRACT_FILE());
              else {
                const U = h ? E.header.fileAttr : void 0;
                s.writeFileToAsync(S, L, u, U, function($) {
                  $ || R(v("Unable to write file", S)), s.fs.utimes(S, E.header.time, E.header.time, function(x) {
                    x ? R(v("Unable to set times", S)) : R();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
                  });
                });
              }
            });
          }
        };
<<<<<<< HEAD
      }, _)();
=======
      }, b)();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    },
    /**
     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
     *
     * @param {string} targetFileName
     * @param {function} callback
     */
<<<<<<< HEAD
    writeZip: function(p, d) {
      if (arguments.length === 1 && typeof p == "function" && (d = p, p = ""), !p && n.filename && (p = n.filename), !!p) {
        var h = s.compressToBuffer();
        if (h) {
          var _ = i.writeFileTo(p, h, !0);
          typeof d == "function" && d(_ ? null : new Error("failed"), "");
=======
    writeZip: function(p, u) {
      if (arguments.length === 1 && typeof p == "function" && (u = p, p = ""), !p && n.filename && (p = n.filename), !!p) {
        var h = i.compressToBuffer();
        if (h) {
          var b = s.writeFileTo(p, h, !0);
          typeof u == "function" && u(b ? null : new Error("failed"), "");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }
      }
    },
    /**
             *
             * @param {string} targetFileName
             * @param {object} [props]
             * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.
             * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.
    
             * @returns {Promise<void>}
             */
<<<<<<< HEAD
    writeZipPromise: function(p, d) {
      const { overwrite: h, perm: _ } = Object.assign({ overwrite: !0 }, d);
      return new Promise((g, v) => {
        !p && n.filename && (p = n.filename), p || v("ADM-ZIP: ZIP File Name Missing"), this.toBufferPromise().then((y) => {
          const E = (R) => R ? g(R) : v("ADM-ZIP: Wasn't able to write zip file");
          i.writeFileToAsync(p, y, h, _, E);
=======
    writeZipPromise: function(p, u) {
      const { overwrite: h, perm: b } = Object.assign({ overwrite: !0 }, u);
      return new Promise((m, v) => {
        !p && n.filename && (p = n.filename), p || v("ADM-ZIP: ZIP File Name Missing"), this.toBufferPromise().then((y) => {
          const _ = (R) => R ? m(R) : v("ADM-ZIP: Wasn't able to write zip file");
          s.writeFileToAsync(p, y, h, b, _);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }, v);
      });
    },
    /**
     * @returns {Promise<Buffer>} A promise to the Buffer.
     */
    toBufferPromise: function() {
<<<<<<< HEAD
      return new Promise((p, d) => {
        s.toAsyncBuffer(p, d);
=======
      return new Promise((p, u) => {
        i.toAsyncBuffer(p, u);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      });
    },
    /**
     * Returns the content of the entire zip file as a Buffer object
     *
     * @prop {function} [onSuccess]
     * @prop {function} [onFail]
     * @prop {function} [onItemStart]
     * @prop {function} [onItemEnd]
     * @returns {Buffer}
     */
<<<<<<< HEAD
    toBuffer: function(p, d, h, _) {
      return typeof p == "function" ? (s.toAsyncBuffer(p, d, h, _), null) : s.compressToBuffer();
    }
  };
};
const tW = /* @__PURE__ */ Da(eW);
function rW(e) {
  try {
    let t;
    process.platform === "win32" ? t = `netstat -ano | findstr :${e}` : t = `lsof -i :${e} | awk 'NR>1 {print $2}'`;
    const r = al(t, { encoding: "utf8" }).trim();
    if (!r) return null;
    let n;
    if (process.platform === "win32") {
      const i = /\s+(\d+)\s*$/;
      n = r.split(`
`).map((s) => {
        const o = s.match(i);
        return o ? parseInt(o[1], 10) : NaN;
      }).filter((s) => !isNaN(s));
    } else
      n = r.split(`
`).map((i) => parseInt(i.trim(), 10)).filter((i) => !isNaN(i));
=======
    toBuffer: function(p, u, h, b) {
      return typeof p == "function" ? (i.toAsyncBuffer(p, u, h, b), null) : i.compressToBuffer();
    }
  };
};
const s3 = /* @__PURE__ */ si(n3);
function i3(e) {
  try {
    let t;
    process.platform === "win32" ? t = `netstat -ano | findstr :${e}` : t = `lsof -i :${e} | awk 'NR>1 {print $2}'`;
    const r = ao(t, { encoding: "utf8" }).trim();
    if (!r) return null;
    let n;
    if (process.platform === "win32") {
      const s = /\s+(\d+)\s*$/;
      n = r.split(`
`).map((i) => {
        const o = i.match(s);
        return o ? parseInt(o[1], 10) : NaN;
      }).filter((i) => !isNaN(i));
    } else
      n = r.split(`
`).map((s) => parseInt(s.trim(), 10)).filter((s) => !isNaN(s));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    return [...new Set(n)];
  } catch {
    return null;
  }
}
<<<<<<< HEAD
function jp(e) {
  const t = rW(e);
  return !!(t && t.length > 0);
}
const gT = hC(import.meta.url), nW = gT("koffi"), iW = gT("node-cron");
class sW {
  constructor(t) {
    Te(this, "Wcf_directory");
    Te(this, "wcfconfigPath");
    Te(this, "wcfConfig");
    Te(this, "windown");
    Te(this, "server");
    Te(this, "WxInitSDK");
    Te(this, "WxDestroySDK");
    Te(this, "scheduleJobs");
    //   上报配置文件
    Te(this, "reportConfig", () => {
      this.windown.webContents.send("wcf:config", this.wcfConfig);
    });
    //   写入配置文件
    Te(this, "writeConfig", (t) => {
      this.wcfConfig = t, Ye.writeFileSync(this.wcfconfigPath, JSON.stringify(t, null, 4));
    });
    //   发送日志
    Te(this, "sendLog", (t, r) => {
      this.windown.webContents.send("wcf:log", { message: t, level: r || "INFO", timestamp: $G().format("YYYY-MM-DD HH:mm:ss.SSS ") });
    });
    //   检测WCF是否有更新
    Te(this, "checkUpdate", async () => {
      const t = we.join(this.Wcf_directory, "config.json");
      if (Ye.existsSync(t)) {
        const n = JSON.parse(Ye.readFileSync(t, "utf-8")).version.replace("v", "").split(".").join("") || "0", i = await this.getWCFVersion(), s = (i == null ? void 0 : i.version.replace("v", "").split(".").join("")) || "0";
        if (Number(n) < Number(s))
          return { status: !0, version: (i == null ? void 0 : i.version) || "" };
=======
function eu(e) {
  const t = i3(e);
  return !!(t && t.length > 0);
}
const tS = yS(import.meta.url), o3 = tS("koffi"), a3 = tS("node-cron");
class c3 {
  constructor(t) {
    Se(this, "Wcf_directory");
    Se(this, "wcfconfigPath");
    Se(this, "wcfConfig");
    Se(this, "windown");
    Se(this, "server");
    Se(this, "WxInitSDK");
    Se(this, "WxDestroySDK");
    Se(this, "scheduleJobs");
    //   上报配置文件
    Se(this, "reportConfig", () => {
      this.windown.webContents.send("wcf:config", this.wcfConfig);
    });
    //   写入配置文件
    Se(this, "writeConfig", (t) => {
      this.wcfConfig = t, vt.writeFileSync(this.wcfconfigPath, JSON.stringify(t, null, 4));
    });
    //   发送日志
    Se(this, "sendLog", (t, r) => {
      this.windown.webContents.send("wcf:log", { message: t, level: r || "INFO", timestamp: CH().format("YYYY-MM-DD HH:mm:ss.SSS ") });
    });
    //   检测WCF是否有更新
    Se(this, "checkUpdate", async () => {
      const t = rt.join(this.Wcf_directory, "config.json");
      if (vt.existsSync(t)) {
        const n = JSON.parse(vt.readFileSync(t, "utf-8")).version.replace("v", "").split(".").join("") || "0", s = await this.getWCFVersion(), i = (s == null ? void 0 : s.version.replace("v", "").split(".").join("")) || "0";
        if (Number(n) < Number(i))
          return { status: !0, version: (s == null ? void 0 : s.version) || "" };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      }
      return { staus: !1, version: this.wcfConfig.version };
    });
    //   检测WCF是否存在
<<<<<<< HEAD
    Te(this, "checkWCF", () => {
      const t = we.join(this.Wcf_directory, "sdk.dll");
      return !!Ye.existsSync(t);
    });
    // 获取WCF版本信息
    Te(this, "getWCFVersion", async () => {
      const t = "https://api.github.com/repos/lich0821/WeChatFerry/releases/latest";
      try {
        const r = await tt.get(t, {
=======
    Se(this, "checkWCF", () => {
      const t = rt.join(this.Wcf_directory, "sdk.dll");
      return !!vt.existsSync(t);
    });
    // 获取WCF版本信息
    Se(this, "getWCFVersion", async () => {
      const t = "https://api.github.com/repos/lich0821/WeChatFerry/releases/latest";
      try {
        const r = await Me.get(t, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          responseType: "json",
          validateStatus: (n) => n < 500
        });
        return !r || !r.data || !r.data.assets || r.data.assets.length === 0 ? (this.sendLog("Failed to retrieve valid data from GitHub API.", "ERROR"), r.data.message && this.sendLog(r.data.message, "ERROR"), { version: "", download_url: "" }) : {
          version: r.data.tag_name,
          download_url: r.data.assets[0].browser_download_url
        };
      } catch (r) {
        return this.sendLog(`获取WCF版本信息失败:${r == null ? void 0 : r.message}`, "ERROR"), null;
      }
    });
<<<<<<< HEAD
    Te(this, "downloadFile", async (t, r) => {
      try {
        const i = (this.wcfConfig.proxy_url ? this.wcfConfig.proxy_url + "/" : "") + t;
        this.sendLog(`开始下载文件:${i}`, "INFO");
        const s = Ye.createWriteStream(r);
        return (await tt({
          method: "get",
          url: i,
          responseType: "stream"
        })).data.pipe(s), await new Promise((a, c) => {
          s.on("finish", async () => {
            this.sendLog("下载完成", "SUCCESS"), a(!0);
          }), s.on("error", c);
=======
    Se(this, "downloadFile", async (t, r) => {
      try {
        const s = (this.wcfConfig.proxy_url ? this.wcfConfig.proxy_url + "/" : "") + t;
        this.sendLog(`开始下载文件:${s}`, "INFO");
        const i = vt.createWriteStream(r);
        return (await Me({
          method: "get",
          url: s,
          responseType: "stream"
        })).data.pipe(i), await new Promise((a, c) => {
          i.on("finish", async () => {
            this.sendLog("下载完成", "SUCCESS"), a(!0);
          }), i.on("error", c);
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      } catch (n) {
        return this.sendLog(`下载失败:${n.message},url:${t}`, "ERROR"), !1;
      }
    });
    //   下载最新版的WCF
<<<<<<< HEAD
    Te(this, "downloadWCF", async () => {
=======
    Se(this, "downloadWCF", async () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      this.sendLog("开始下载最新版本的WCF", "INFO");
      let t = "";
      try {
        const r = await this.getWCFVersion();
        this.sendLog(`✅ 获取WCF最新版本信息成功:${r == null ? void 0 : r.version}`, "SUCCESS"), this.wcfConfig.version = (r == null ? void 0 : r.version) || "";
<<<<<<< HEAD
        const n = we.basename(r == null ? void 0 : r.download_url);
        if (t = we.join(this.Wcf_directory, n), Ye.existsSync(t))
          return await this.unzipFile(t);
        const i = await this.downloadFile(r == null ? void 0 : r.download_url, t);
        if (!i) return i;
        await this.unzipFile(t) && (this.wcfConfig.version = (r == null ? void 0 : r.version) || "", this.writeConfig(this.wcfConfig), this.reportConfig());
      } catch (r) {
        return this.sendLog(`下载WCF失败:${r.message}`, "ERROR"), Ye.unlinkSync(t), !1;
      }
    });
    // 注入Dll
    Te(this, "InjectWCF", async () => {
=======
        const n = rt.basename(r == null ? void 0 : r.download_url);
        if (t = rt.join(this.Wcf_directory, n), vt.existsSync(t))
          return await this.unzipFile(t);
        const s = await this.downloadFile(r == null ? void 0 : r.download_url, t);
        if (!s) return s;
        await this.unzipFile(t) && (this.wcfConfig.version = (r == null ? void 0 : r.version) || "", this.writeConfig(this.wcfConfig), this.reportConfig());
      } catch (r) {
        return this.sendLog(`下载WCF失败:${r.message}`, "ERROR"), vt.unlinkSync(t), !1;
      }
    });
    // 注入Dll
    Se(this, "InjectWCF", async () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      if (process.platform !== "win32") {
        this.sendLog("当前系统不支持WCF注入", "ERROR");
        return;
      }
      this.checkWCF() || (this.sendLog("WCF核心不存在，即将自动下载", "WARN"), await this.downloadWCF());
      const r = await this.checkWCFIsRun();
      if (!r.wcf_run && r.portOcc)
        return this.sendLog(`当前端口已被占用:${this.wcfConfig.port}请修改系统设置端口，避免启动失败！`, "WARN"), !1;
      this.sendLog("开始注入WCF", "INFO");
<<<<<<< HEAD
      const n = we.join(this.Wcf_directory, "sdk.dll"), i = nW.load(n);
      return this.WxInitSDK = i.func("int WxInitSDK(bool, int)", "stdcall"), this.WxDestroySDK = i.func("WxDestroySDK", "void", []), !0;
    });
    // 启动WCF
    Te(this, "startWCF", async () => {
=======
      const n = rt.join(this.Wcf_directory, "sdk.dll"), s = o3.load(n);
      return this.WxInitSDK = s.func("int WxInitSDK(bool, int)", "stdcall"), this.WxDestroySDK = s.func("WxDestroySDK", "void", []), !0;
    });
    // 启动WCF
    Se(this, "startWCF", async () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      var t;
      try {
        const r = await this.InjectWCF();
        if (!r) return r;
        const n = (t = this.WxInitSDK) == null ? void 0 : t.call(this, this.wcfConfig.debug, this.wcfConfig.port);
        if (n !== 0) {
          this.sendLog(`WCF启动失败：${n}`, "ERROR");
          return;
        }
        return this.sendLog(`✅WCF启动成功:tcp://0.0.0.0:${this.wcfConfig.port}发起连接`, "SUCCESS"), this.checkWCFIsRun(), !0;
      } catch (r) {
        this.sendLog(`启动WCF失败:${r.message}`, "ERROR");
      }
    });
    // 更新WCFdLL
<<<<<<< HEAD
    Te(this, "updateWCF", async () => {
=======
    Se(this, "updateWCF", async () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      var r;
      (await this.checkWCFIsRun()).wcf_run && ((r = this.WxDestroySDK) == null || r.call(this), this.sendLog("WCF已关闭", "INFO")), await this.downloadWCF(), await this.startWCF();
    });
    // 重启WCF
<<<<<<< HEAD
    Te(this, "restartWCF", async () => {
=======
    Se(this, "restartWCF", async () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      var r;
      (await this.checkWCFIsRun()).wcf_run && ((r = this.WxDestroySDK) == null || r.call(this), this.sendLog("WCF已关闭", "INFO")), await this.startWCF();
    });
    // 关闭WCF
<<<<<<< HEAD
    Te(this, "closeWCF", async () => {
      this.WxDestroySDK ? (this.WxDestroySDK(), this.sendLog("WCF已关闭", "INFO")) : this.sendLog("WCF未运行", "INFO"), this.checkWCFIsRun();
    });
    // 修改WCF配置文件
    Te(this, "modifyWCFConfig", async (t, r) => {
      this.wcfConfig = { ...this.wcfConfig, ...r }, this.writeConfig(this.wcfConfig), this.reportConfig();
    });
    // 获取配置文件
    Te(this, "getWCFConfig", async () => this.wcfConfig);
    //   检测WCF是否在运行
    Te(this, "checkWCFIsRun", async () => {
      const t = {
        portOcc: jp(this.wcfConfig.port),
        wcf_run: jp(this.wcfConfig.port) && !!this.WxInitSDK,
        http: !!(this.server && jp(this.wcfConfig.httpPort))
=======
    Se(this, "closeWCF", async () => {
      this.WxDestroySDK ? (this.WxDestroySDK(), this.sendLog("WCF已关闭", "INFO")) : this.sendLog("WCF未运行", "INFO"), this.checkWCFIsRun();
    });
    // 修改WCF配置文件
    Se(this, "modifyWCFConfig", async (t, r) => {
      this.wcfConfig = { ...this.wcfConfig, ...r }, this.writeConfig(this.wcfConfig), this.reportConfig();
    });
    // 获取配置文件
    Se(this, "getWCFConfig", async () => this.wcfConfig);
    //   检测WCF是否在运行
    Se(this, "checkWCFIsRun", async () => {
      const t = {
        portOcc: eu(this.wcfConfig.port),
        wcf_run: eu(this.wcfConfig.port) && !!this.WxInitSDK,
        http: !!(this.server && eu(this.wcfConfig.httpPort))
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      };
      return this.windown.webContents.send("wcf:startEvent", t), t;
    });
    // 重置WCF环境
<<<<<<< HEAD
    Te(this, "resetWCF", async () => {
      this.sendLog("开始重置WCF环境", "INFO"), await this.KillPort(this.wcfConfig.port), await this.KillPort(+this.wcfConfig.port + 1);
    });
    Te(this, "KillPort", async (t) => {
=======
    Se(this, "resetWCF", async () => {
      this.sendLog("开始重置WCF环境", "INFO"), await this.KillPort(this.wcfConfig.port), await this.KillPort(+this.wcfConfig.port + 1);
    });
    Se(this, "KillPort", async (t) => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      try {
        const r = await this.getPidsByPort(t);
        if (r.length == 0) {
          this.sendLog(`当前端口:${t}没有被占用`, "INFO");
          return;
        }
        this.sendLog(`成功检测${t}端口对应的PID:${r},即将终止相关PID进程`, "INFO"), r.forEach((n) => {
<<<<<<< HEAD
          const i = this.killProcessByPid(n);
          this.sendLog(`${i.success ? "✅" : ""}${i.message}`, i.success ? "SUCCESS" : "ERROR");
=======
          const s = this.killProcessByPid(n);
          this.sendLog(`${s.success ? "✅" : ""}${s.message}`, s.success ? "SUCCESS" : "ERROR");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        });
      } catch (r) {
        this.sendLog(`重置WCF环境失败:${r.message}`, "ERROR");
      }
    });
    // 开启http服务
<<<<<<< HEAD
    Te(this, "startWcfServer", async () => {
      try {
        const t = _6({ trustProxy: !0 });
        t.get("/", async () => ({ code: 0, ...this.wcfConfig })), t.get("/start-wcf", async () => await this.startWCF() ? { code: 0, message: "WCF启动成功" } : { code: 1, message: "WCF启动失败,详情请看软件日志区域" }), t.get("/close-wcf", async () => (await this.closeWCF(), { code: 0, message: "WCF关闭成功" })), t.addHook("onSend", async (r, n, i) => {
          this.sendLog(`HTTP LOG: Method: ${r.method}、Url: ${r.url}、ClientIp:${r.ip}、Response:${i}`, "INFO");
=======
    Se(this, "startWcfServer", async () => {
      try {
        const t = EM({ trustProxy: !0 });
        t.get("/", async () => ({ code: 0, ...this.wcfConfig })), t.get("/start-wcf", async () => await this.startWCF() ? { code: 0, message: "WCF启动成功" } : { code: 1, message: "WCF启动失败,详情请看软件日志区域" }), t.get("/close-wcf", async () => (await this.closeWCF(), { code: 0, message: "WCF关闭成功" })), t.addHook("onSend", async (r, n, s) => {
          this.sendLog(`HTTP LOG: Method: ${r.method}、Url: ${r.url}、ClientIp:${r.ip}、Response:${s}`, "INFO");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        }), await t.listen({ host: "0.0.0.0", port: this.wcfConfig.httpPort }), this.sendLog(`✅ HTTP SERVER IS START:0.0.0.0:${this.wcfConfig.httpPort}`, "SUCCESS"), this.server = t, this.checkWCFIsRun();
      } catch (t) {
        this.sendLog(t.message, "ERROR");
      }
    });
    // 关闭http服务
<<<<<<< HEAD
    Te(this, "closeWcfServer", async () => {
      this.server && (await this.server.close(), this.sendLog("Http Server Is Close", "INFO")), this.checkWCFIsRun();
    });
    // 注册定时任务
    Te(this, "registerSchedule", (t, r) => {
      const n = iW.schedule(t, r);
      this.scheduleJobs.push(n), n.start();
    });
    // 清空定时任务
    Te(this, "clearSchedule", () => {
=======
    Se(this, "closeWcfServer", async () => {
      this.server && (await this.server.close(), this.sendLog("Http Server Is Close", "INFO")), this.checkWCFIsRun();
    });
    // 注册定时任务
    Se(this, "registerSchedule", (t, r) => {
      const n = a3.schedule(t, r);
      this.scheduleJobs.push(n), n.start();
    });
    // 清空定时任务
    Se(this, "clearSchedule", () => {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      this.scheduleJobs.map((t) => {
        t.stop();
      }), this.scheduleJobs.length = 0;
    });
    // 检测端口对应的pid
<<<<<<< HEAD
    Te(this, "getPidsByPort", async (t) => {
      try {
        const n = al(`netstat -ano | findstr :${t}`, { encoding: "utf-8" }).split(`
`).filter((s) => s.includes(`:${t}`));
        return n.length === 0 ? [] : n.map((s) => {
          const o = s.trim().split(/\s+/).pop();
=======
    Se(this, "getPidsByPort", async (t) => {
      try {
        const n = ao(`netstat -ano | findstr :${t}`, { encoding: "utf-8" }).split(`
`).filter((i) => i.includes(`:${t}`));
        return n.length === 0 ? [] : n.map((i) => {
          const o = i.trim().split(/\s+/).pop();
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
          return Number(o);
        });
      } catch {
        return [];
      }
    });
<<<<<<< HEAD
    Te(this, "killProcessByPid", (t) => {
      try {
        return al(`taskkill /PID ${t} /F`, { stdio: "ignore" }), { success: !0, message: `✅ 成功终止 PID ${t} 的进程` };
=======
    Se(this, "killProcessByPid", (t) => {
      try {
        return ao(`taskkill /PID ${t} /F`, { stdio: "ignore" }), { success: !0, message: `✅ 成功终止 PID ${t} 的进程` };
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      } catch {
        return { success: !1, message: `❌ 无法终止 PID ${t}，可能不存在或已退出,请打开任务管理器核对` };
      }
    });
    // 唤醒微信
<<<<<<< HEAD
    Te(this, "wakeUpWeChat", () => {
      try {
        if (process.platform === "win32")
          al("start weixin://");
=======
    Se(this, "wakeUpWeChat", () => {
      try {
        if (process.platform === "win32")
          ao("start weixin://");
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        else if (process.platform === "darwin")
          open("open weixin://");
        else {
          this.sendLog("❌ 当前系统不支持微信协议唤醒", "ERROR");
          return;
        }
        console.log("✅ 微信客户端已唤醒");
      } catch (t) {
        this.sendLog(`❌ 无法唤醒微信:${t.message}`, "ERROR");
      }
    });
<<<<<<< HEAD
    Te(this, "injectVersionDll", async (t, r = !1) => {
      const n = js.getPath("downloads");
      this.closeWCF(), this.sendLog(`开始检测指定版本:${t}是否存在`, "INFO");
      const i = `https://api.github.com/repos/lich0821/WeChatFerry/releases/tags/${t}`, o = (await tt.get(i, {
=======
    Se(this, "injectVersionDll", async (t, r = !1) => {
      const n = Gn.getPath("downloads");
      this.closeWCF(), this.sendLog(`开始检测指定版本:${t}是否存在`, "INFO");
      const s = `https://api.github.com/repos/lich0821/WeChatFerry/releases/tags/${t}`, o = (await Me.get(s, {
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
        validateStatus: (h) => h < 500
      })).data;
      if (o.status == 404)
        return this.sendLog(`指定版本:${t}不存在`, "ERROR"), 404;
<<<<<<< HEAD
      const a = o.assets, [c, u] = a, l = c.browser_download_url;
      this.sendLog(`✅ 获取指定版本:${t}下载地址成功:${l}`, "SUCCESS");
      const f = we.basename(l), m = we.join(this.Wcf_directory, f), p = await this.downloadFile(l, m);
      if (!p) return p;
      const d = await this.unzipFile(m, this.Wcf_directory);
      if (d && (this.wcfConfig.version = t || "", this.writeConfig(this.wcfConfig), this.reportConfig()), !d) return d;
      if (this.sendLog(`✅ 指定版本:${t}下载完成`, "SUCCESS"), r) {
        const h = u.browser_download_url, _ = we.basename(h);
        this.sendLog(`开始下载指定版本:${t}对应的${u.name}`, "INFO");
        const g = we.join(n, _), v = await this.downloadFile(h, g);
        if (!v) return v;
        this.sendLog(`✅ 指定版本:${t}对应的${u.name}下载完成`, "SUCCESS"), this.sendLog(`文件已保存:${g}`, "INFO"), this.sendLog("安装指定版本微信登录成功后 重新启动WCF即可", "INFO");
      }
    });
    this.windown = t, this.server = null, this.Wcf_directory = we.join(js.getPath("documents"), "WCFApp"), this.wcfconfigPath = we.join(this.Wcf_directory, "config.json"), this.WxInitSDK = null, this.WxDestroySDK = null, Ye.existsSync(this.Wcf_directory) || Ye.mkdirSync(this.Wcf_directory, { recursive: !0 });
=======
      const a = o.assets, [c, f] = a, l = c.browser_download_url;
      this.sendLog(`✅ 获取指定版本:${t}下载地址成功:${l}`, "SUCCESS");
      const d = rt.basename(l), g = rt.join(this.Wcf_directory, d), p = await this.downloadFile(l, g);
      if (!p) return p;
      const u = await this.unzipFile(g, this.Wcf_directory);
      if (u && (this.wcfConfig.version = t || "", this.writeConfig(this.wcfConfig), this.reportConfig()), !u) return u;
      if (this.sendLog(`✅ 指定版本:${t}下载完成`, "SUCCESS"), r) {
        const h = f.browser_download_url, b = rt.basename(h);
        this.sendLog(`开始下载指定版本:${t}对应的${f.name}`, "INFO");
        const m = rt.join(n, b), v = await this.downloadFile(h, m);
        if (!v) return v;
        this.sendLog(`✅ 指定版本:${t}对应的${f.name}下载完成`, "SUCCESS"), this.sendLog(`文件已保存:${m}`, "INFO"), this.sendLog("安装指定版本微信登录成功后 重新启动WCF即可", "INFO");
      }
    });
    this.windown = t, this.server = null, this.Wcf_directory = rt.join(Gn.getPath("documents"), "WCFApp"), this.wcfconfigPath = rt.join(this.Wcf_directory, "config.json"), this.WxInitSDK = null, this.WxDestroySDK = null, vt.existsSync(this.Wcf_directory) || vt.mkdirSync(this.Wcf_directory, { recursive: !0 });
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    const r = {
      port: 10086,
      debug: !1,
      proxy_url: "",
      version: "",
      httpPort: 9200,
      cronCheck: 12
    };
<<<<<<< HEAD
    if (Ye.existsSync(this.wcfconfigPath)) {
      const n = JSON.parse(Ye.readFileSync(this.wcfconfigPath, "utf-8"));
=======
    if (vt.existsSync(this.wcfconfigPath)) {
      const n = JSON.parse(vt.readFileSync(this.wcfconfigPath, "utf-8"));
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
      this.wcfConfig = { ...r, ...n };
    } else
      this.wcfConfig = r;
    this.writeConfig(this.wcfConfig), this.scheduleJobs = [];
  }
  //   解压文件
  async unzipFile(t, r = this.Wcf_directory) {
    try {
      this.sendLog("开始解压文件", "INFO");
<<<<<<< HEAD
      const n = new tW(t);
      return await new Promise((i, s) => {
        n.extractAllToAsync(r, !0, (o) => {
          o ? s(o) : (this.sendLog("✅ 解压文件完成", "SUCCESS"), Ye.unlinkSync(t), i(!0));
        });
      });
    } catch (n) {
      return this.sendLog(`解压文件失败: ${n}`, "ERROR"), Ye.unlinkSync(t), !1;
    }
  }
}
var bs = {}, Ji = {}, rr = {};
rr.fromCallback = function(e) {
  return Object.defineProperty(function(...t) {
    if (typeof t[t.length - 1] == "function") e.apply(this, t);
    else
      return new Promise((r, n) => {
        t.push((i, s) => i != null ? n(i) : r(s)), e.apply(this, t);
      });
  }, "name", { value: e.name });
};
rr.fromPromise = function(e) {
  return Object.defineProperty(function(...t) {
    const r = t[t.length - 1];
    if (typeof r != "function") return e.apply(this, t);
    t.pop(), e.apply(this, t).then((n) => r(null, n), r);
  }, "name", { value: e.name });
};
var Dn = SC, oW = process.cwd, Pl = null, aW = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return Pl || (Pl = oW.call(process)), Pl;
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var nw = process.chdir;
  process.chdir = function(e) {
    Pl = null, nw.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, nw);
}
var cW = lW;
function lW(e) {
  Dn.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || r(e), e.chown = s(e.chown), e.fchown = s(e.fchown), e.lchown = s(e.lchown), e.chmod = n(e.chmod), e.fchmod = n(e.fchmod), e.lchmod = n(e.lchmod), e.chownSync = o(e.chownSync), e.fchownSync = o(e.fchownSync), e.lchownSync = o(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync = i(e.lchmodSync), e.stat = a(e.stat), e.fstat = a(e.fstat), e.lstat = a(e.lstat), e.statSync = c(e.statSync), e.fstatSync = c(e.fstatSync), e.lstatSync = c(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(l, f, m) {
    m && process.nextTick(m);
  }, e.lchmodSync = function() {
  }), e.chown && !e.lchown && (e.lchown = function(l, f, m, p) {
    p && process.nextTick(p);
  }, e.lchownSync = function() {
  }), aW === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(l) {
    function f(m, p, d) {
      var h = Date.now(), _ = 0;
      l(m, p, function g(v) {
        if (v && (v.code === "EACCES" || v.code === "EPERM" || v.code === "EBUSY") && Date.now() - h < 6e4) {
          setTimeout(function() {
            e.stat(p, function(y, E) {
              y && y.code === "ENOENT" ? l(m, p, g) : d(v);
            });
          }, _), _ < 100 && (_ += 10);
          return;
        }
        d && d(v);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(f, l), f;
  }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(l) {
    function f(m, p, d, h, _, g) {
      var v;
      if (g && typeof g == "function") {
        var y = 0;
        v = function(E, R, w) {
          if (E && E.code === "EAGAIN" && y < 10)
            return y++, l.call(e, m, p, d, h, _, v);
          g.apply(this, arguments);
        };
      }
      return l.call(e, m, p, d, h, _, v);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(f, l), f;
  }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(l) {
    return function(f, m, p, d, h) {
      for (var _ = 0; ; )
        try {
          return l.call(e, f, m, p, d, h);
        } catch (g) {
          if (g.code === "EAGAIN" && _ < 10) {
            _++;
            continue;
          }
          throw g;
        }
    };
  }(e.readSync);
  function t(l) {
    l.lchmod = function(f, m, p) {
      l.open(
        f,
        Dn.O_WRONLY | Dn.O_SYMLINK,
        m,
        function(d, h) {
          if (d) {
            p && p(d);
            return;
          }
          l.fchmod(h, m, function(_) {
            l.close(h, function(g) {
              p && p(_ || g);
            });
          });
        }
      );
    }, l.lchmodSync = function(f, m) {
      var p = l.openSync(f, Dn.O_WRONLY | Dn.O_SYMLINK, m), d = !0, h;
      try {
        h = l.fchmodSync(p, m), d = !1;
      } finally {
        if (d)
          try {
            l.closeSync(p);
          } catch {
          }
        else
          l.closeSync(p);
      }
      return h;
    };
  }
  function r(l) {
    Dn.hasOwnProperty("O_SYMLINK") && l.futimes ? (l.lutimes = function(f, m, p, d) {
      l.open(f, Dn.O_SYMLINK, function(h, _) {
        if (h) {
          d && d(h);
          return;
        }
        l.futimes(_, m, p, function(g) {
          l.close(_, function(v) {
            d && d(g || v);
          });
        });
      });
    }, l.lutimesSync = function(f, m, p) {
      var d = l.openSync(f, Dn.O_SYMLINK), h, _ = !0;
      try {
        h = l.futimesSync(d, m, p), _ = !1;
      } finally {
        if (_)
          try {
            l.closeSync(d);
          } catch {
          }
        else
          l.closeSync(d);
      }
      return h;
    }) : l.futimes && (l.lutimes = function(f, m, p, d) {
      d && process.nextTick(d);
    }, l.lutimesSync = function() {
    });
  }
  function n(l) {
    return l && function(f, m, p) {
      return l.call(e, f, m, function(d) {
        u(d) && (d = null), p && p.apply(this, arguments);
      });
    };
  }
  function i(l) {
    return l && function(f, m) {
      try {
        return l.call(e, f, m);
      } catch (p) {
        if (!u(p)) throw p;
      }
    };
  }
  function s(l) {
    return l && function(f, m, p, d) {
      return l.call(e, f, m, p, function(h) {
        u(h) && (h = null), d && d.apply(this, arguments);
      });
    };
  }
  function o(l) {
    return l && function(f, m, p) {
      try {
        return l.call(e, f, m, p);
      } catch (d) {
        if (!u(d)) throw d;
      }
    };
  }
  function a(l) {
    return l && function(f, m, p) {
      typeof m == "function" && (p = m, m = null);
      function d(h, _) {
        _ && (_.uid < 0 && (_.uid += 4294967296), _.gid < 0 && (_.gid += 4294967296)), p && p.apply(this, arguments);
      }
      return m ? l.call(e, f, m, d) : l.call(e, f, d);
    };
  }
  function c(l) {
    return l && function(f, m) {
      var p = m ? l.call(e, f, m) : l.call(e, f);
      return p && (p.uid < 0 && (p.uid += 4294967296), p.gid < 0 && (p.gid += 4294967296)), p;
    };
  }
  function u(l) {
    if (!l || l.code === "ENOSYS")
      return !0;
    var f = !process.getuid || process.getuid() !== 0;
    return !!(f && (l.code === "EINVAL" || l.code === "EPERM"));
  }
}
var iw = It.Stream, uW = fW;
function fW(e) {
  return {
    ReadStream: t,
    WriteStream: r
  };
  function t(n, i) {
    if (!(this instanceof t)) return new t(n, i);
    iw.call(this);
    var s = this;
    this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i = i || {};
    for (var o = Object.keys(i), a = 0, c = o.length; a < c; a++) {
      var u = o[a];
      this[u] = i[u];
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        s._read();
      });
      return;
    }
    e.open(this.path, this.flags, this.mode, function(l, f) {
      if (l) {
        s.emit("error", l), s.readable = !1;
        return;
      }
      s.fd = f, s.emit("open", f), s._read();
    });
  }
  function r(n, i) {
    if (!(this instanceof r)) return new r(n, i);
    iw.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
    for (var s = Object.keys(i), o = 0, a = s.length; o < a; o++) {
      var c = s[o];
      this[c] = i[c];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
var dW = hW, pW = Object.getPrototypeOf || function(e) {
  return e.__proto__;
};
function hW(e) {
  if (e === null || typeof e != "object")
    return e;
  if (e instanceof Object)
    var t = { __proto__: pW(e) };
  else
    var t = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(e).forEach(function(r) {
    Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
  }), t;
}
var et = Ye, mW = cW, gW = uW, yW = dW, Qc = wn, Dt, ru;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (Dt = Symbol.for("graceful-fs.queue"), ru = Symbol.for("graceful-fs.previous")) : (Dt = "___graceful-fs.queue", ru = "___graceful-fs.previous");
function vW() {
}
function yT(e, t) {
  Object.defineProperty(e, Dt, {
    get: function() {
      return t;
    }
  });
}
var Li = vW;
Qc.debuglog ? Li = Qc.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (Li = function() {
  var e = Qc.format.apply(Qc, arguments);
  e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
});
if (!et[Dt]) {
  var _W = me[Dt] || [];
  yT(et, _W), et.close = function(e) {
    function t(r, n) {
      return e.call(et, r, function(i) {
        i || sw(), typeof n == "function" && n.apply(this, arguments);
      });
    }
    return Object.defineProperty(t, ru, {
      value: e
    }), t;
  }(et.close), et.closeSync = function(e) {
    function t(r) {
      e.apply(et, arguments), sw();
    }
    return Object.defineProperty(t, ru, {
      value: e
    }), t;
  }(et.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    Li(et[Dt]), ka.equal(et[Dt].length, 0);
  });
}
me[Dt] || yT(me, et[Dt]);
var nr = Ay(yW(et));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !et.__patched && (nr = Ay(et), et.__patched = !0);
function Ay(e) {
  mW(e), e.gracefulify = Ay, e.createReadStream = R, e.createWriteStream = w;
  var t = e.readFile;
  e.readFile = r;
  function r(b, F, H) {
    return typeof F == "function" && (H = F, F = null), q(b, F, H);
    function q($, x, A, P) {
      return t($, x, function(D) {
        D && (D.code === "EMFILE" || D.code === "ENFILE") ? fs([q, [$, x, A], D, P || Date.now(), Date.now()]) : typeof A == "function" && A.apply(this, arguments);
      });
    }
  }
  var n = e.writeFile;
  e.writeFile = i;
  function i(b, F, H, q) {
    return typeof H == "function" && (q = H, H = null), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return n(x, A, P, function(L) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? fs([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  var s = e.appendFile;
  s && (e.appendFile = o);
  function o(b, F, H, q) {
    return typeof H == "function" && (q = H, H = null), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return s(x, A, P, function(L) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? fs([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  var a = e.copyFile;
  a && (e.copyFile = c);
  function c(b, F, H, q) {
    return typeof H == "function" && (q = H, H = 0), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return a(x, A, P, function(L) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? fs([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  var u = e.readdir;
  e.readdir = f;
  var l = /^v[0-5]\./;
  function f(b, F, H) {
    typeof F == "function" && (H = F, F = null);
    var q = l.test(process.version) ? function(A, P, D, I) {
      return u(A, $(
        A,
        P,
        D,
        I
      ));
    } : function(A, P, D, I) {
      return u(A, P, $(
        A,
        P,
        D,
        I
      ));
    };
    return q(b, F, H);
    function $(x, A, P, D) {
      return function(I, L) {
        I && (I.code === "EMFILE" || I.code === "ENFILE") ? fs([
          q,
          [x, A, P],
          I,
          D || Date.now(),
          Date.now()
        ]) : (L && L.sort && L.sort(), typeof P == "function" && P.call(this, I, L));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var m = gW(e);
    g = m.ReadStream, y = m.WriteStream;
  }
  var p = e.ReadStream;
  p && (g.prototype = Object.create(p.prototype), g.prototype.open = v);
  var d = e.WriteStream;
  d && (y.prototype = Object.create(d.prototype), y.prototype.open = E), Object.defineProperty(e, "ReadStream", {
    get: function() {
      return g;
    },
    set: function(b) {
      g = b;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e, "WriteStream", {
    get: function() {
      return y;
    },
    set: function(b) {
      y = b;
    },
    enumerable: !0,
    configurable: !0
  });
  var h = g;
  Object.defineProperty(e, "FileReadStream", {
    get: function() {
      return h;
    },
    set: function(b) {
      h = b;
    },
    enumerable: !0,
    configurable: !0
  });
  var _ = y;
  Object.defineProperty(e, "FileWriteStream", {
    get: function() {
      return _;
    },
    set: function(b) {
      _ = b;
    },
    enumerable: !0,
    configurable: !0
  });
  function g(b, F) {
    return this instanceof g ? (p.apply(this, arguments), this) : g.apply(Object.create(g.prototype), arguments);
  }
  function v() {
    var b = this;
    V(b.path, b.flags, b.mode, function(F, H) {
      F ? (b.autoClose && b.destroy(), b.emit("error", F)) : (b.fd = H, b.emit("open", H), b.read());
    });
  }
  function y(b, F) {
    return this instanceof y ? (d.apply(this, arguments), this) : y.apply(Object.create(y.prototype), arguments);
  }
  function E() {
    var b = this;
    V(b.path, b.flags, b.mode, function(F, H) {
      F ? (b.destroy(), b.emit("error", F)) : (b.fd = H, b.emit("open", H));
    });
  }
  function R(b, F) {
    return new e.ReadStream(b, F);
  }
  function w(b, F) {
    return new e.WriteStream(b, F);
  }
  var C = e.open;
  e.open = V;
  function V(b, F, H, q) {
    return typeof H == "function" && (q = H, H = null), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return C(x, A, P, function(L, j) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? fs([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  return e;
}
function fs(e) {
  Li("ENQUEUE", e[0].name, e[1]), et[Dt].push(e), Iy();
}
var el;
function sw() {
  for (var e = Date.now(), t = 0; t < et[Dt].length; ++t)
    et[Dt][t].length > 2 && (et[Dt][t][3] = e, et[Dt][t][4] = e);
  Iy();
}
function Iy() {
  if (clearTimeout(el), el = void 0, et[Dt].length !== 0) {
    var e = et[Dt].shift(), t = e[0], r = e[1], n = e[2], i = e[3], s = e[4];
    if (i === void 0)
      Li("RETRY", t.name, r), t.apply(null, r);
    else if (Date.now() - i >= 6e4) {
      Li("TIMEOUT", t.name, r);
      var o = r.pop();
      typeof o == "function" && o.call(null, n);
    } else {
      var a = Date.now() - s, c = Math.max(s - i, 1), u = Math.min(c * 1.2, 100);
      a >= u ? (Li("RETRY", t.name, r), t.apply(null, r.concat([i]))) : et[Dt].push(e);
    }
    el === void 0 && (el = setTimeout(Iy, 0));
  }
}
(function(e) {
  const t = rr.fromCallback, r = nr, n = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((i) => typeof r[i] == "function");
  Object.assign(e, r), n.forEach((i) => {
    e[i] = t(r[i]);
  }), e.exists = function(i, s) {
    return typeof s == "function" ? r.exists(i, s) : new Promise((o) => r.exists(i, o));
  }, e.read = function(i, s, o, a, c, u) {
    return typeof u == "function" ? r.read(i, s, o, a, c, u) : new Promise((l, f) => {
      r.read(i, s, o, a, c, (m, p, d) => {
        if (m) return f(m);
        l({ bytesRead: p, buffer: d });
      });
    });
  }, e.write = function(i, s, ...o) {
    return typeof o[o.length - 1] == "function" ? r.write(i, s, ...o) : new Promise((a, c) => {
      r.write(i, s, ...o, (u, l, f) => {
        if (u) return c(u);
        a({ bytesWritten: l, buffer: f });
      });
    });
  }, typeof r.writev == "function" && (e.writev = function(i, s, ...o) {
    return typeof o[o.length - 1] == "function" ? r.writev(i, s, ...o) : new Promise((a, c) => {
      r.writev(i, s, ...o, (u, l, f) => {
        if (u) return c(u);
        a({ bytesWritten: l, buffers: f });
      });
    });
  }), typeof r.realpath.native == "function" ? e.realpath.native = t(r.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(Ji);
var Ny = {}, vT = {};
const bW = we;
vT.checkPath = function(t) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(bW.parse(t).root, ""))) {
    const n = new Error(`Path contains invalid characters: ${t}`);
    throw n.code = "EINVAL", n;
  }
};
const _T = Ji, { checkPath: bT } = vT, ET = (e) => {
  const t = { mode: 511 };
  return typeof e == "number" ? e : { ...t, ...e }.mode;
};
Ny.makeDir = async (e, t) => (bT(e), _T.mkdir(e, {
  mode: ET(t),
  recursive: !0
}));
Ny.makeDirSync = (e, t) => (bT(e), _T.mkdirSync(e, {
  mode: ET(t),
  recursive: !0
}));
const EW = rr.fromPromise, { makeDir: wW, makeDirSync: Up } = Ny, Mp = EW(wW);
var an = {
  mkdirs: Mp,
  mkdirsSync: Up,
  // alias
  mkdirp: Mp,
  mkdirpSync: Up,
  ensureDir: Mp,
  ensureDirSync: Up
};
const SW = rr.fromPromise, wT = Ji;
function xW(e) {
  return wT.access(e).then(() => !0).catch(() => !1);
}
var Xi = {
  pathExists: SW(xW),
  pathExistsSync: wT.existsSync
};
const Ls = nr;
function RW(e, t, r, n) {
  Ls.open(e, "r+", (i, s) => {
    if (i) return n(i);
    Ls.futimes(s, t, r, (o) => {
      Ls.close(s, (a) => {
        n && n(o || a);
      });
    });
  });
}
function $W(e, t, r) {
  const n = Ls.openSync(e, "r+");
  return Ls.futimesSync(n, t, r), Ls.closeSync(n);
}
var ST = {
  utimesMillis: RW,
  utimesMillisSync: $W
};
const Ws = Ji, xt = we, TW = wn;
function OW(e, t, r) {
  const n = r.dereference ? (i) => Ws.stat(i, { bigint: !0 }) : (i) => Ws.lstat(i, { bigint: !0 });
  return Promise.all([
    n(e),
    n(t).catch((i) => {
      if (i.code === "ENOENT") return null;
      throw i;
    })
  ]).then(([i, s]) => ({ srcStat: i, destStat: s }));
}
function PW(e, t, r) {
  let n;
  const i = r.dereference ? (o) => Ws.statSync(o, { bigint: !0 }) : (o) => Ws.lstatSync(o, { bigint: !0 }), s = i(e);
  try {
    n = i(t);
  } catch (o) {
    if (o.code === "ENOENT") return { srcStat: s, destStat: null };
    throw o;
  }
  return { srcStat: s, destStat: n };
}
function CW(e, t, r, n, i) {
  TW.callbackify(OW)(e, t, n, (s, o) => {
    if (s) return i(s);
    const { srcStat: a, destStat: c } = o;
    if (c) {
      if (nc(a, c)) {
        const u = xt.basename(e), l = xt.basename(t);
        return r === "move" && u !== l && u.toLowerCase() === l.toLowerCase() ? i(null, { srcStat: a, destStat: c, isChangingCase: !0 }) : i(new Error("Source and destination must not be the same."));
      }
      if (a.isDirectory() && !c.isDirectory())
        return i(new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`));
      if (!a.isDirectory() && c.isDirectory())
        return i(new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`));
    }
    return a.isDirectory() && ky(e, t) ? i(new Error(yf(e, t, r))) : i(null, { srcStat: a, destStat: c });
  });
}
function AW(e, t, r, n) {
  const { srcStat: i, destStat: s } = PW(e, t, n);
  if (s) {
    if (nc(i, s)) {
      const o = xt.basename(e), a = xt.basename(t);
      if (r === "move" && o !== a && o.toLowerCase() === a.toLowerCase())
        return { srcStat: i, destStat: s, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !s.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
    if (!i.isDirectory() && s.isDirectory())
      throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
  }
  if (i.isDirectory() && ky(e, t))
    throw new Error(yf(e, t, r));
  return { srcStat: i, destStat: s };
}
function xT(e, t, r, n, i) {
  const s = xt.resolve(xt.dirname(e)), o = xt.resolve(xt.dirname(r));
  if (o === s || o === xt.parse(o).root) return i();
  Ws.stat(o, { bigint: !0 }, (a, c) => a ? a.code === "ENOENT" ? i() : i(a) : nc(t, c) ? i(new Error(yf(e, r, n))) : xT(e, t, o, n, i));
}
function RT(e, t, r, n) {
  const i = xt.resolve(xt.dirname(e)), s = xt.resolve(xt.dirname(r));
  if (s === i || s === xt.parse(s).root) return;
  let o;
  try {
    o = Ws.statSync(s, { bigint: !0 });
  } catch (a) {
    if (a.code === "ENOENT") return;
    throw a;
  }
  if (nc(t, o))
    throw new Error(yf(e, r, n));
  return RT(e, t, s, n);
}
function nc(e, t) {
  return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
}
function ky(e, t) {
  const r = xt.resolve(e).split(xt.sep).filter((i) => i), n = xt.resolve(t).split(xt.sep).filter((i) => i);
  return r.reduce((i, s, o) => i && n[o] === s, !0);
}
function yf(e, t, r) {
  return `Cannot ${r} '${e}' to a subdirectory of itself, '${t}'.`;
}
var uo = {
  checkPaths: CW,
  checkPathsSync: AW,
  checkParentPaths: xT,
  checkParentPathsSync: RT,
  isSrcSubdir: ky,
  areIdentical: nc
};
const lr = nr, ma = we, IW = an.mkdirs, NW = Xi.pathExists, kW = ST.utimesMillis, ga = uo;
function DW(e, t, r, n) {
  typeof r == "function" && !n ? (n = r, r = {}) : typeof r == "function" && (r = { filter: r }), n = n || function() {
  }, r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  ), ga.checkPaths(e, t, "copy", r, (i, s) => {
    if (i) return n(i);
    const { srcStat: o, destStat: a } = s;
    ga.checkParentPaths(e, o, t, "copy", (c) => c ? n(c) : r.filter ? $T(ow, a, e, t, r, n) : ow(a, e, t, r, n));
  });
}
function ow(e, t, r, n, i) {
  const s = ma.dirname(r);
  NW(s, (o, a) => {
    if (o) return i(o);
    if (a) return nu(e, t, r, n, i);
    IW(s, (c) => c ? i(c) : nu(e, t, r, n, i));
  });
}
function $T(e, t, r, n, i, s) {
  Promise.resolve(i.filter(r, n)).then((o) => o ? e(t, r, n, i, s) : s(), (o) => s(o));
}
function LW(e, t, r, n, i) {
  return n.filter ? $T(nu, e, t, r, n, i) : nu(e, t, r, n, i);
}
function nu(e, t, r, n, i) {
  (n.dereference ? lr.stat : lr.lstat)(t, (o, a) => o ? i(o) : a.isDirectory() ? BW(a, e, t, r, n, i) : a.isFile() || a.isCharacterDevice() || a.isBlockDevice() ? FW(a, e, t, r, n, i) : a.isSymbolicLink() ? GW(e, t, r, n, i) : a.isSocket() ? i(new Error(`Cannot copy a socket file: ${t}`)) : a.isFIFO() ? i(new Error(`Cannot copy a FIFO pipe: ${t}`)) : i(new Error(`Unknown file: ${t}`)));
}
function FW(e, t, r, n, i, s) {
  return t ? jW(e, r, n, i, s) : TT(e, r, n, i, s);
}
function jW(e, t, r, n, i) {
  if (n.overwrite)
    lr.unlink(r, (s) => s ? i(s) : TT(e, t, r, n, i));
  else return n.errorOnExist ? i(new Error(`'${r}' already exists`)) : i();
}
function TT(e, t, r, n, i) {
  lr.copyFile(t, r, (s) => s ? i(s) : n.preserveTimestamps ? UW(e.mode, t, r, i) : vf(r, e.mode, i));
}
function UW(e, t, r, n) {
  return MW(e) ? HW(r, e, (i) => i ? n(i) : aw(e, t, r, n)) : aw(e, t, r, n);
}
function MW(e) {
  return (e & 128) === 0;
}
function HW(e, t, r) {
  return vf(e, t | 128, r);
}
function aw(e, t, r, n) {
  qW(t, r, (i) => i ? n(i) : vf(r, e, n));
}
function vf(e, t, r) {
  return lr.chmod(e, t, r);
}
function qW(e, t, r) {
  lr.stat(e, (n, i) => n ? r(n) : kW(t, i.atime, i.mtime, r));
}
function BW(e, t, r, n, i, s) {
  return t ? OT(r, n, i, s) : zW(e.mode, r, n, i, s);
}
function zW(e, t, r, n, i) {
  lr.mkdir(r, (s) => {
    if (s) return i(s);
    OT(t, r, n, (o) => o ? i(o) : vf(r, e, i));
  });
}
function OT(e, t, r, n) {
  lr.readdir(e, (i, s) => i ? n(i) : PT(s, e, t, r, n));
}
function PT(e, t, r, n, i) {
  const s = e.pop();
  return s ? VW(e, s, t, r, n, i) : i();
}
function VW(e, t, r, n, i, s) {
  const o = ma.join(r, t), a = ma.join(n, t);
  ga.checkPaths(o, a, "copy", i, (c, u) => {
    if (c) return s(c);
    const { destStat: l } = u;
    LW(l, o, a, i, (f) => f ? s(f) : PT(e, r, n, i, s));
  });
}
function GW(e, t, r, n, i) {
  lr.readlink(t, (s, o) => {
    if (s) return i(s);
    if (n.dereference && (o = ma.resolve(process.cwd(), o)), e)
      lr.readlink(r, (a, c) => a ? a.code === "EINVAL" || a.code === "UNKNOWN" ? lr.symlink(o, r, i) : i(a) : (n.dereference && (c = ma.resolve(process.cwd(), c)), ga.isSrcSubdir(o, c) ? i(new Error(`Cannot copy '${o}' to a subdirectory of itself, '${c}'.`)) : e.isDirectory() && ga.isSrcSubdir(c, o) ? i(new Error(`Cannot overwrite '${c}' with '${o}'.`)) : WW(o, r, i)));
    else
      return lr.symlink(o, r, i);
  });
}
function WW(e, t, r) {
  lr.unlink(t, (n) => n ? r(n) : lr.symlink(e, t, r));
}
var KW = DW;
const Gt = nr, ya = we, YW = an.mkdirsSync, JW = ST.utimesMillisSync, va = uo;
function XW(e, t, r) {
  typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: n, destStat: i } = va.checkPathsSync(e, t, "copy", r);
  return va.checkParentPathsSync(e, n, t, "copy"), ZW(i, e, t, r);
}
function ZW(e, t, r, n) {
  if (n.filter && !n.filter(t, r)) return;
  const i = ya.dirname(r);
  return Gt.existsSync(i) || YW(i), CT(e, t, r, n);
}
function QW(e, t, r, n) {
  if (!(n.filter && !n.filter(t, r)))
    return CT(e, t, r, n);
}
function CT(e, t, r, n) {
  const s = (n.dereference ? Gt.statSync : Gt.lstatSync)(t);
  if (s.isDirectory()) return o7(s, e, t, r, n);
  if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice()) return e7(s, e, t, r, n);
  if (s.isSymbolicLink()) return l7(e, t, r, n);
  throw s.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : s.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(`Unknown file: ${t}`);
}
function e7(e, t, r, n, i) {
  return t ? t7(e, r, n, i) : AT(e, r, n, i);
}
function t7(e, t, r, n) {
  if (n.overwrite)
    return Gt.unlinkSync(r), AT(e, t, r, n);
  if (n.errorOnExist)
    throw new Error(`'${r}' already exists`);
}
function AT(e, t, r, n) {
  return Gt.copyFileSync(t, r), n.preserveTimestamps && r7(e.mode, t, r), Dy(r, e.mode);
}
function r7(e, t, r) {
  return n7(e) && i7(r, e), s7(t, r);
}
function n7(e) {
  return (e & 128) === 0;
}
function i7(e, t) {
  return Dy(e, t | 128);
}
function Dy(e, t) {
  return Gt.chmodSync(e, t);
}
function s7(e, t) {
  const r = Gt.statSync(e);
  return JW(t, r.atime, r.mtime);
}
function o7(e, t, r, n, i) {
  return t ? IT(r, n, i) : a7(e.mode, r, n, i);
}
function a7(e, t, r, n) {
  return Gt.mkdirSync(r), IT(t, r, n), Dy(r, e);
}
function IT(e, t, r) {
  Gt.readdirSync(e).forEach((n) => c7(n, e, t, r));
}
function c7(e, t, r, n) {
  const i = ya.join(t, e), s = ya.join(r, e), { destStat: o } = va.checkPathsSync(i, s, "copy", n);
  return QW(o, i, s, n);
}
function l7(e, t, r, n) {
  let i = Gt.readlinkSync(t);
  if (n.dereference && (i = ya.resolve(process.cwd(), i)), e) {
    let s;
    try {
      s = Gt.readlinkSync(r);
    } catch (o) {
      if (o.code === "EINVAL" || o.code === "UNKNOWN") return Gt.symlinkSync(i, r);
      throw o;
    }
    if (n.dereference && (s = ya.resolve(process.cwd(), s)), va.isSrcSubdir(i, s))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${s}'.`);
    if (Gt.statSync(r).isDirectory() && va.isSrcSubdir(s, i))
      throw new Error(`Cannot overwrite '${s}' with '${i}'.`);
    return u7(i, r);
  } else
    return Gt.symlinkSync(i, r);
}
function u7(e, t) {
  return Gt.unlinkSync(t), Gt.symlinkSync(e, t);
}
var f7 = XW;
const d7 = rr.fromCallback;
var Ly = {
  copy: d7(KW),
  copySync: f7
};
const cw = nr, NT = we, Me = ka, _a = process.platform === "win32";
function kT(e) {
  [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ].forEach((r) => {
    e[r] = e[r] || cw[r], r = r + "Sync", e[r] = e[r] || cw[r];
  }), e.maxBusyTries = e.maxBusyTries || 3;
}
function Fy(e, t, r) {
  let n = 0;
  typeof t == "function" && (r = t, t = {}), Me(e, "rimraf: missing path"), Me.strictEqual(typeof e, "string", "rimraf: path should be a string"), Me.strictEqual(typeof r, "function", "rimraf: callback function required"), Me(t, "rimraf: invalid options argument provided"), Me.strictEqual(typeof t, "object", "rimraf: options should be object"), kT(t), lw(e, t, function i(s) {
    if (s) {
      if ((s.code === "EBUSY" || s.code === "ENOTEMPTY" || s.code === "EPERM") && n < t.maxBusyTries) {
        n++;
        const o = n * 100;
        return setTimeout(() => lw(e, t, i), o);
      }
      s.code === "ENOENT" && (s = null);
    }
    r(s);
  });
}
function lw(e, t, r) {
  Me(e), Me(t), Me(typeof r == "function"), t.lstat(e, (n, i) => {
    if (n && n.code === "ENOENT")
      return r(null);
    if (n && n.code === "EPERM" && _a)
      return uw(e, t, n, r);
    if (i && i.isDirectory())
      return Cl(e, t, n, r);
    t.unlink(e, (s) => {
      if (s) {
        if (s.code === "ENOENT")
          return r(null);
        if (s.code === "EPERM")
          return _a ? uw(e, t, s, r) : Cl(e, t, s, r);
        if (s.code === "EISDIR")
          return Cl(e, t, s, r);
      }
      return r(s);
    });
  });
}
function uw(e, t, r, n) {
  Me(e), Me(t), Me(typeof n == "function"), t.chmod(e, 438, (i) => {
    i ? n(i.code === "ENOENT" ? null : r) : t.stat(e, (s, o) => {
      s ? n(s.code === "ENOENT" ? null : r) : o.isDirectory() ? Cl(e, t, r, n) : t.unlink(e, n);
    });
  });
}
function fw(e, t, r) {
  let n;
  Me(e), Me(t);
  try {
    t.chmodSync(e, 438);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  try {
    n = t.statSync(e);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  n.isDirectory() ? Al(e, t, r) : t.unlinkSync(e);
}
function Cl(e, t, r, n) {
  Me(e), Me(t), Me(typeof n == "function"), t.rmdir(e, (i) => {
    i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") ? p7(e, t, n) : i && i.code === "ENOTDIR" ? n(r) : n(i);
  });
}
function p7(e, t, r) {
  Me(e), Me(t), Me(typeof r == "function"), t.readdir(e, (n, i) => {
    if (n) return r(n);
    let s = i.length, o;
    if (s === 0) return t.rmdir(e, r);
    i.forEach((a) => {
      Fy(NT.join(e, a), t, (c) => {
        if (!o) {
          if (c) return r(o = c);
          --s === 0 && t.rmdir(e, r);
        }
      });
    });
  });
}
function DT(e, t) {
  let r;
  t = t || {}, kT(t), Me(e, "rimraf: missing path"), Me.strictEqual(typeof e, "string", "rimraf: path should be a string"), Me(t, "rimraf: missing options"), Me.strictEqual(typeof t, "object", "rimraf: options should be object");
  try {
    r = t.lstatSync(e);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    n.code === "EPERM" && _a && fw(e, t, n);
  }
  try {
    r && r.isDirectory() ? Al(e, t, null) : t.unlinkSync(e);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    if (n.code === "EPERM")
      return _a ? fw(e, t, n) : Al(e, t, n);
    if (n.code !== "EISDIR")
      throw n;
    Al(e, t, n);
  }
}
function Al(e, t, r) {
  Me(e), Me(t);
  try {
    t.rmdirSync(e);
  } catch (n) {
    if (n.code === "ENOTDIR")
      throw r;
    if (n.code === "ENOTEMPTY" || n.code === "EEXIST" || n.code === "EPERM")
      h7(e, t);
    else if (n.code !== "ENOENT")
      throw n;
  }
}
function h7(e, t) {
  if (Me(e), Me(t), t.readdirSync(e).forEach((r) => DT(NT.join(e, r), t)), _a) {
    const r = Date.now();
    do
      try {
        return t.rmdirSync(e, t);
      } catch {
      }
    while (Date.now() - r < 500);
  } else
    return t.rmdirSync(e, t);
}
var m7 = Fy;
Fy.sync = DT;
const iu = nr, g7 = rr.fromCallback, LT = m7;
function y7(e, t) {
  if (iu.rm) return iu.rm(e, { recursive: !0, force: !0 }, t);
  LT(e, t);
}
function v7(e) {
  if (iu.rmSync) return iu.rmSync(e, { recursive: !0, force: !0 });
  LT.sync(e);
}
var _f = {
  remove: g7(y7),
  removeSync: v7
};
const _7 = rr.fromPromise, FT = Ji, jT = we, UT = an, MT = _f, dw = _7(async function(t) {
  let r;
  try {
    r = await FT.readdir(t);
  } catch {
    return UT.mkdirs(t);
  }
  return Promise.all(r.map((n) => MT.remove(jT.join(t, n))));
});
function pw(e) {
  let t;
  try {
    t = FT.readdirSync(e);
  } catch {
    return UT.mkdirsSync(e);
  }
  t.forEach((r) => {
    r = jT.join(e, r), MT.removeSync(r);
  });
}
var b7 = {
  emptyDirSync: pw,
  emptydirSync: pw,
  emptyDir: dw,
  emptydir: dw
};
const E7 = rr.fromCallback, HT = we, Vn = nr, qT = an;
function w7(e, t) {
  function r() {
    Vn.writeFile(e, "", (n) => {
      if (n) return t(n);
      t();
    });
  }
  Vn.stat(e, (n, i) => {
    if (!n && i.isFile()) return t();
    const s = HT.dirname(e);
    Vn.stat(s, (o, a) => {
      if (o)
        return o.code === "ENOENT" ? qT.mkdirs(s, (c) => {
          if (c) return t(c);
          r();
        }) : t(o);
      a.isDirectory() ? r() : Vn.readdir(s, (c) => {
        if (c) return t(c);
      });
    });
  });
}
function S7(e) {
  let t;
  try {
    t = Vn.statSync(e);
  } catch {
  }
  if (t && t.isFile()) return;
  const r = HT.dirname(e);
  try {
    Vn.statSync(r).isDirectory() || Vn.readdirSync(r);
  } catch (n) {
    if (n && n.code === "ENOENT") qT.mkdirsSync(r);
    else throw n;
  }
  Vn.writeFileSync(e, "");
}
var x7 = {
  createFile: E7(w7),
  createFileSync: S7
};
const R7 = rr.fromCallback, BT = we, Mn = nr, zT = an, $7 = Xi.pathExists, { areIdentical: VT } = uo;
function T7(e, t, r) {
  function n(i, s) {
    Mn.link(i, s, (o) => {
      if (o) return r(o);
      r(null);
    });
  }
  Mn.lstat(t, (i, s) => {
    Mn.lstat(e, (o, a) => {
      if (o)
        return o.message = o.message.replace("lstat", "ensureLink"), r(o);
      if (s && VT(a, s)) return r(null);
      const c = BT.dirname(t);
      $7(c, (u, l) => {
        if (u) return r(u);
        if (l) return n(e, t);
        zT.mkdirs(c, (f) => {
          if (f) return r(f);
          n(e, t);
        });
      });
    });
  });
}
function O7(e, t) {
  let r;
  try {
    r = Mn.lstatSync(t);
  } catch {
  }
  try {
    const s = Mn.lstatSync(e);
    if (r && VT(s, r)) return;
  } catch (s) {
    throw s.message = s.message.replace("lstat", "ensureLink"), s;
  }
  const n = BT.dirname(t);
  return Mn.existsSync(n) || zT.mkdirsSync(n), Mn.linkSync(e, t);
}
var P7 = {
  createLink: R7(T7),
  createLinkSync: O7
};
const Gn = we, Qo = nr, C7 = Xi.pathExists;
function A7(e, t, r) {
  if (Gn.isAbsolute(e))
    return Qo.lstat(e, (n) => n ? (n.message = n.message.replace("lstat", "ensureSymlink"), r(n)) : r(null, {
      toCwd: e,
      toDst: e
    }));
  {
    const n = Gn.dirname(t), i = Gn.join(n, e);
    return C7(i, (s, o) => s ? r(s) : o ? r(null, {
      toCwd: i,
      toDst: e
    }) : Qo.lstat(e, (a) => a ? (a.message = a.message.replace("lstat", "ensureSymlink"), r(a)) : r(null, {
      toCwd: e,
      toDst: Gn.relative(n, e)
    })));
  }
}
function I7(e, t) {
  let r;
  if (Gn.isAbsolute(e)) {
    if (r = Qo.existsSync(e), !r) throw new Error("absolute srcpath does not exist");
    return {
      toCwd: e,
      toDst: e
    };
  } else {
    const n = Gn.dirname(t), i = Gn.join(n, e);
    if (r = Qo.existsSync(i), r)
      return {
        toCwd: i,
        toDst: e
      };
    if (r = Qo.existsSync(e), !r) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: Gn.relative(n, e)
    };
  }
}
var N7 = {
  symlinkPaths: A7,
  symlinkPathsSync: I7
};
const GT = nr;
function k7(e, t, r) {
  if (r = typeof t == "function" ? t : r, t = typeof t == "function" ? !1 : t, t) return r(null, t);
  GT.lstat(e, (n, i) => {
    if (n) return r(null, "file");
    t = i && i.isDirectory() ? "dir" : "file", r(null, t);
  });
}
function D7(e, t) {
  let r;
  if (t) return t;
  try {
    r = GT.lstatSync(e);
  } catch {
    return "file";
  }
  return r && r.isDirectory() ? "dir" : "file";
}
var L7 = {
  symlinkType: k7,
  symlinkTypeSync: D7
};
const F7 = rr.fromCallback, WT = we, jr = Ji, KT = an, j7 = KT.mkdirs, U7 = KT.mkdirsSync, YT = N7, M7 = YT.symlinkPaths, H7 = YT.symlinkPathsSync, JT = L7, q7 = JT.symlinkType, B7 = JT.symlinkTypeSync, z7 = Xi.pathExists, { areIdentical: XT } = uo;
function V7(e, t, r, n) {
  n = typeof r == "function" ? r : n, r = typeof r == "function" ? !1 : r, jr.lstat(t, (i, s) => {
    !i && s.isSymbolicLink() ? Promise.all([
      jr.stat(e),
      jr.stat(t)
    ]).then(([o, a]) => {
      if (XT(o, a)) return n(null);
      hw(e, t, r, n);
    }) : hw(e, t, r, n);
  });
}
function hw(e, t, r, n) {
  M7(e, t, (i, s) => {
    if (i) return n(i);
    e = s.toDst, q7(s.toCwd, r, (o, a) => {
      if (o) return n(o);
      const c = WT.dirname(t);
      z7(c, (u, l) => {
        if (u) return n(u);
        if (l) return jr.symlink(e, t, a, n);
        j7(c, (f) => {
          if (f) return n(f);
          jr.symlink(e, t, a, n);
        });
      });
    });
  });
}
function G7(e, t, r) {
  let n;
  try {
    n = jr.lstatSync(t);
  } catch {
  }
  if (n && n.isSymbolicLink()) {
    const a = jr.statSync(e), c = jr.statSync(t);
    if (XT(a, c)) return;
  }
  const i = H7(e, t);
  e = i.toDst, r = B7(i.toCwd, r);
  const s = WT.dirname(t);
  return jr.existsSync(s) || U7(s), jr.symlinkSync(e, t, r);
}
var W7 = {
  createSymlink: F7(V7),
  createSymlinkSync: G7
};
const { createFile: mw, createFileSync: gw } = x7, { createLink: yw, createLinkSync: vw } = P7, { createSymlink: _w, createSymlinkSync: bw } = W7;
var K7 = {
  // file
  createFile: mw,
  createFileSync: gw,
  ensureFile: mw,
  ensureFileSync: gw,
  // link
  createLink: yw,
  createLinkSync: vw,
  ensureLink: yw,
  ensureLinkSync: vw,
  // symlink
  createSymlink: _w,
  createSymlinkSync: bw,
  ensureSymlink: _w,
  ensureSymlinkSync: bw
};
function Y7(e, { EOL: t = `
`, finalEOL: r = !0, replacer: n = null, spaces: i } = {}) {
  const s = r ? t : "";
  return JSON.stringify(e, n, i).replace(/\n/g, t) + s;
}
function J7(e) {
  return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
}
var jy = { stringify: Y7, stripBom: J7 };
let Ks;
try {
  Ks = nr;
} catch {
  Ks = Ye;
}
const bf = rr, { stringify: ZT, stripBom: QT } = jy;
async function X7(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const r = t.fs || Ks, n = "throws" in t ? t.throws : !0;
  let i = await bf.fromCallback(r.readFile)(e, t);
  i = QT(i);
  let s;
  try {
    s = JSON.parse(i, t ? t.reviver : null);
  } catch (o) {
    if (n)
      throw o.message = `${e}: ${o.message}`, o;
    return null;
  }
  return s;
}
const Z7 = bf.fromPromise(X7);
function Q7(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const r = t.fs || Ks, n = "throws" in t ? t.throws : !0;
  try {
    let i = r.readFileSync(e, t);
    return i = QT(i), JSON.parse(i, t.reviver);
  } catch (i) {
    if (n)
      throw i.message = `${e}: ${i.message}`, i;
    return null;
  }
}
async function eK(e, t, r = {}) {
  const n = r.fs || Ks, i = ZT(t, r);
  await bf.fromCallback(n.writeFile)(e, i, r);
}
const tK = bf.fromPromise(eK);
function rK(e, t, r = {}) {
  const n = r.fs || Ks, i = ZT(t, r);
  return n.writeFileSync(e, i, r);
}
const nK = {
  readFile: Z7,
  readFileSync: Q7,
  writeFile: tK,
  writeFileSync: rK
};
var iK = nK;
const tl = iK;
var sK = {
  // jsonfile exports
  readJson: tl.readFile,
  readJsonSync: tl.readFileSync,
  writeJson: tl.writeFile,
  writeJsonSync: tl.writeFileSync
};
const oK = rr.fromCallback, ea = nr, eO = we, tO = an, aK = Xi.pathExists;
function cK(e, t, r, n) {
  typeof r == "function" && (n = r, r = "utf8");
  const i = eO.dirname(e);
  aK(i, (s, o) => {
    if (s) return n(s);
    if (o) return ea.writeFile(e, t, r, n);
    tO.mkdirs(i, (a) => {
      if (a) return n(a);
      ea.writeFile(e, t, r, n);
    });
  });
}
function lK(e, ...t) {
  const r = eO.dirname(e);
  if (ea.existsSync(r))
    return ea.writeFileSync(e, ...t);
  tO.mkdirsSync(r), ea.writeFileSync(e, ...t);
}
var Uy = {
  outputFile: oK(cK),
  outputFileSync: lK
};
const { stringify: uK } = jy, { outputFile: fK } = Uy;
async function dK(e, t, r = {}) {
  const n = uK(t, r);
  await fK(e, n, r);
}
var pK = dK;
const { stringify: hK } = jy, { outputFileSync: mK } = Uy;
function gK(e, t, r) {
  const n = hK(t, r);
  mK(e, n, r);
}
var yK = gK;
const vK = rr.fromPromise, er = sK;
er.outputJson = vK(pK);
er.outputJsonSync = yK;
er.outputJSON = er.outputJson;
er.outputJSONSync = er.outputJsonSync;
er.writeJSON = er.writeJson;
er.writeJSONSync = er.writeJsonSync;
er.readJSON = er.readJson;
er.readJSONSync = er.readJsonSync;
var _K = er;
const bK = nr, Vh = we, EK = Ly.copy, rO = _f.remove, wK = an.mkdirp, SK = Xi.pathExists, Ew = uo;
function xK(e, t, r, n) {
  typeof r == "function" && (n = r, r = {}), r = r || {};
  const i = r.overwrite || r.clobber || !1;
  Ew.checkPaths(e, t, "move", r, (s, o) => {
    if (s) return n(s);
    const { srcStat: a, isChangingCase: c = !1 } = o;
    Ew.checkParentPaths(e, a, t, "move", (u) => {
      if (u) return n(u);
      if (RK(t)) return ww(e, t, i, c, n);
      wK(Vh.dirname(t), (l) => l ? n(l) : ww(e, t, i, c, n));
    });
  });
}
function RK(e) {
  const t = Vh.dirname(e);
  return Vh.parse(t).root === t;
}
function ww(e, t, r, n, i) {
  if (n) return Hp(e, t, r, i);
  if (r)
    return rO(t, (s) => s ? i(s) : Hp(e, t, r, i));
  SK(t, (s, o) => s ? i(s) : o ? i(new Error("dest already exists.")) : Hp(e, t, r, i));
}
function Hp(e, t, r, n) {
  bK.rename(e, t, (i) => i ? i.code !== "EXDEV" ? n(i) : $K(e, t, r, n) : n());
}
function $K(e, t, r, n) {
  EK(e, t, {
    overwrite: r,
    errorOnExist: !0
  }, (s) => s ? n(s) : rO(e, n));
}
var TK = xK;
const nO = nr, Gh = we, OK = Ly.copySync, iO = _f.removeSync, PK = an.mkdirpSync, Sw = uo;
function CK(e, t, r) {
  r = r || {};
  const n = r.overwrite || r.clobber || !1, { srcStat: i, isChangingCase: s = !1 } = Sw.checkPathsSync(e, t, "move", r);
  return Sw.checkParentPathsSync(e, i, t, "move"), AK(t) || PK(Gh.dirname(t)), IK(e, t, n, s);
}
function AK(e) {
  const t = Gh.dirname(e);
  return Gh.parse(t).root === t;
}
function IK(e, t, r, n) {
  if (n) return qp(e, t, r);
  if (r)
    return iO(t), qp(e, t, r);
  if (nO.existsSync(t)) throw new Error("dest already exists.");
  return qp(e, t, r);
}
function qp(e, t, r) {
  try {
    nO.renameSync(e, t);
  } catch (n) {
    if (n.code !== "EXDEV") throw n;
    return NK(e, t, r);
  }
}
function NK(e, t, r) {
  return OK(e, t, {
    overwrite: r,
    errorOnExist: !0
  }), iO(e);
}
var kK = CK;
const DK = rr.fromCallback;
var LK = {
  move: DK(TK),
  moveSync: kK
}, ni = {
  // Export promiseified graceful-fs:
  ...Ji,
  // Export extra methods:
  ...Ly,
  ...b7,
  ...K7,
  ..._K,
  ...an,
  ...LK,
  ...Uy,
  ...Xi,
  ..._f
}, xn = {}, Zn = {}, Rt = {}, Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.CancellationError = Qn.CancellationToken = void 0;
const FK = gu;
class jK extends FK.EventEmitter {
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(t) {
    this.removeParentCancelHandler(), this._parent = t, this.parentCancelHandler = () => this.cancel(), this._parent.onCancel(this.parentCancelHandler);
  }
  // babel cannot compile ... correctly for super calls
  constructor(t) {
    super(), this.parentCancelHandler = null, this._parent = null, this._cancelled = !1, t != null && (this.parent = t);
  }
  cancel() {
    this._cancelled = !0, this.emit("cancel");
  }
  onCancel(t) {
    this.cancelled ? t() : this.once("cancel", t);
  }
  createPromise(t) {
    if (this.cancelled)
      return Promise.reject(new Wh());
    const r = () => {
      if (n != null)
        try {
          this.removeListener("cancel", n), n = null;
        } catch {
        }
    };
    let n = null;
    return new Promise((i, s) => {
      let o = null;
      if (n = () => {
        try {
          o != null && (o(), o = null);
        } finally {
          s(new Wh());
        }
      }, this.cancelled) {
        n();
        return;
      }
      this.onCancel(n), t(i, s, (a) => {
        o = a;
      });
    }).then((i) => (r(), i)).catch((i) => {
      throw r(), i;
    });
  }
  removeParentCancelHandler() {
    const t = this._parent;
    t != null && this.parentCancelHandler != null && (t.removeListener("cancel", this.parentCancelHandler), this.parentCancelHandler = null);
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners(), this._parent = null;
    }
  }
}
Qn.CancellationToken = jK;
class Wh extends Error {
  constructor() {
    super("cancelled");
  }
}
Qn.CancellationError = Wh;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.newError = UK;
function UK(e, t) {
  const r = new Error(e);
  return r.code = t, r;
}
var Qt = {}, ic = {};
Object.defineProperty(ic, "__esModule", { value: !0 });
ic.ProgressCallbackTransform = void 0;
const MK = It;
class HK extends MK.Transform {
  constructor(t, r, n) {
    super(), this.total = t, this.cancellationToken = r, this.onProgress = n, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.nextUpdate = this.start + 1e3;
  }
  _transform(t, r, n) {
    if (this.cancellationToken.cancelled) {
      n(new Error("cancelled"), null);
      return;
    }
    this.transferred += t.length, this.delta += t.length;
    const i = Date.now();
    i >= this.nextUpdate && this.transferred !== this.total && (this.nextUpdate = i + 1e3, this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.total * 100,
      bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3))
    }), this.delta = 0), n(null, t);
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    }), this.delta = 0, t(null);
  }
}
ic.ProgressCallbackTransform = HK;
Object.defineProperty(Qt, "__esModule", { value: !0 });
Qt.DigestTransform = Qt.HttpExecutor = Qt.HttpError = void 0;
Qt.createHttpError = Kh;
Qt.parseJson = YK;
Qt.configureRequestOptionsFromUrl = oO;
Qt.configureRequestUrl = Hy;
Qt.safeGetHeader = Fs;
Qt.configureRequestOptions = ou;
Qt.safeStringifyJson = au;
const qK = Gi, BK = X1, zK = Ye, VK = It, sO = Hr, GK = Qn, xw = fo, WK = ic, jo = (0, BK.default)("electron-builder");
function Kh(e, t = null) {
  return new My(e.statusCode || -1, `${e.statusCode} ${e.statusMessage}` + (t == null ? "" : `
` + JSON.stringify(t, null, "  ")) + `
Headers: ` + au(e.headers), t);
}
const KK = /* @__PURE__ */ new Map([
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
class My extends Error {
  constructor(t, r = `HTTP error: ${KK.get(t) || t}`, n = null) {
    super(r), this.statusCode = t, this.description = n, this.name = "HttpError", this.code = `HTTP_ERROR_${t}`;
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
Qt.HttpError = My;
function YK(e) {
  return e.then((t) => t == null || t.length === 0 ? null : JSON.parse(t));
}
class su {
  constructor() {
    this.maxRedirects = 10;
  }
  request(t, r = new GK.CancellationToken(), n) {
    ou(t);
    const i = n == null ? void 0 : JSON.stringify(n), s = i ? Buffer.from(i) : void 0;
    if (s != null) {
      jo(i);
      const { headers: o, ...a } = t;
      t = {
        method: "post",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": s.length,
          ...o
        },
        ...a
      };
    }
    return this.doApiRequest(t, r, (o) => o.end(s));
  }
  doApiRequest(t, r, n, i = 0) {
    return jo.enabled && jo(`Request: ${au(t)}`), r.createPromise((s, o, a) => {
      const c = this.createRequest(t, (u) => {
        try {
          this.handleResponse(u, t, r, s, o, i, n);
        } catch (l) {
          o(l);
        }
      });
      this.addErrorAndTimeoutHandlers(c, o, t.timeout), this.addRedirectHandlers(c, t, o, i, (u) => {
        this.doApiRequest(u, r, n, i).then(s).catch(o);
      }), n(c, o), a(() => c.abort());
    });
  }
  // noinspection JSUnusedLocalSymbols
  // eslint-disable-next-line
  addRedirectHandlers(t, r, n, i, s) {
  }
  addErrorAndTimeoutHandlers(t, r, n = 60 * 1e3) {
    this.addTimeOutHandler(t, r, n), t.on("error", r), t.on("aborted", () => {
      r(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(t, r, n, i, s, o, a) {
    var c;
    if (jo.enabled && jo(`Response: ${t.statusCode} ${t.statusMessage}, request options: ${au(r)}`), t.statusCode === 404) {
      s(Kh(t, `method: ${r.method || "GET"} url: ${r.protocol || "https:"}//${r.hostname}${r.port ? `:${r.port}` : ""}${r.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (t.statusCode === 204) {
      i();
      return;
    }
    const u = (c = t.statusCode) !== null && c !== void 0 ? c : 0, l = u >= 300 && u < 400, f = Fs(t, "location");
    if (l && f != null) {
      if (o > this.maxRedirects) {
        s(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(su.prepareRedirectUrlOptions(f, r), n, a, o).then(i).catch(s);
      return;
    }
    t.setEncoding("utf8");
    let m = "";
    t.on("error", s), t.on("data", (p) => m += p), t.on("end", () => {
      try {
        if (t.statusCode != null && t.statusCode >= 400) {
          const p = Fs(t, "content-type"), d = p != null && (Array.isArray(p) ? p.find((h) => h.includes("json")) != null : p.includes("json"));
          s(Kh(t, `method: ${r.method || "GET"} url: ${r.protocol || "https:"}//${r.hostname}${r.port ? `:${r.port}` : ""}${r.path}

          Data:
          ${d ? JSON.stringify(JSON.parse(m)) : m}
          `));
        } else
          i(m.length === 0 ? null : m);
      } catch (p) {
        s(p);
      }
    });
  }
  async downloadToBuffer(t, r) {
    return await r.cancellationToken.createPromise((n, i, s) => {
      const o = [], a = {
        headers: r.headers || void 0,
        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
        redirect: "manual"
      };
      Hy(t, a), ou(a), this.doDownload(a, {
        destination: null,
        options: r,
        onCancel: s,
        callback: (c) => {
          c == null ? n(Buffer.concat(o)) : i(c);
        },
        responseHandler: (c, u) => {
          let l = 0;
          c.on("data", (f) => {
            if (l += f.length, l > 524288e3) {
              u(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            o.push(f);
          }), c.on("end", () => {
            u(null);
          });
        }
      }, 0);
    });
  }
  doDownload(t, r, n) {
    const i = this.createRequest(t, (s) => {
      if (s.statusCode >= 400) {
        r.callback(new Error(`Cannot download "${t.protocol || "https:"}//${t.hostname}${t.path}", status ${s.statusCode}: ${s.statusMessage}`));
        return;
      }
      s.on("error", r.callback);
      const o = Fs(s, "location");
      if (o != null) {
        n < this.maxRedirects ? this.doDownload(su.prepareRedirectUrlOptions(o, t), r, n++) : r.callback(this.createMaxRedirectError());
        return;
      }
      r.responseHandler == null ? XK(r, s) : r.responseHandler(s, r.callback);
    });
    this.addErrorAndTimeoutHandlers(i, r.callback, t.timeout), this.addRedirectHandlers(i, t, r.callback, n, (s) => {
      this.doDownload(s, r, n++);
    }), i.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(t, r, n) {
    t.on("socket", (i) => {
      i.setTimeout(n, () => {
        t.abort(), r(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(t, r) {
    const n = oO(t, { ...r }), i = n.headers;
    if (i != null && i.authorization) {
      const s = new sO.URL(t);
      (s.hostname.endsWith(".amazonaws.com") || s.searchParams.has("X-Amz-Credential")) && delete i.authorization;
    }
    return n;
  }
  static retryOnServerError(t, r = 3) {
    for (let n = 0; ; n++)
      try {
        return t();
      } catch (i) {
        if (n < r && (i instanceof My && i.isServerError() || i.code === "EPIPE"))
          continue;
        throw i;
      }
  }
}
Qt.HttpExecutor = su;
function oO(e, t) {
  const r = ou(t);
  return Hy(new sO.URL(e), r), r;
}
function Hy(e, t) {
  t.protocol = e.protocol, t.hostname = e.hostname, e.port ? t.port = e.port : t.port && delete t.port, t.path = e.pathname + e.search;
}
class Yh extends VK.Transform {
  // noinspection JSUnusedGlobalSymbols
  get actual() {
    return this._actual;
  }
  constructor(t, r = "sha512", n = "base64") {
    super(), this.expected = t, this.algorithm = r, this.encoding = n, this._actual = null, this.isValidateOnEnd = !0, this.digester = (0, qK.createHash)(r);
  }
  // noinspection JSUnusedGlobalSymbols
  _transform(t, r, n) {
    this.digester.update(t), n(null, t);
  }
  // noinspection JSUnusedGlobalSymbols
  _flush(t) {
    if (this._actual = this.digester.digest(this.encoding), this.isValidateOnEnd)
      try {
        this.validate();
      } catch (r) {
        t(r);
        return;
      }
    t(null);
  }
  validate() {
    if (this._actual == null)
      throw (0, xw.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    if (this._actual !== this.expected)
      throw (0, xw.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    return null;
  }
}
Qt.DigestTransform = Yh;
function JK(e, t, r) {
  return e != null && t != null && e !== t ? (r(new Error(`checksum mismatch: expected ${t} but got ${e} (X-Checksum-Sha2 header)`)), !1) : !0;
}
function Fs(e, t) {
  const r = e.headers[t];
  return r == null ? null : Array.isArray(r) ? r.length === 0 ? null : r[r.length - 1] : r;
}
function XK(e, t) {
  if (!JK(Fs(t, "X-Checksum-Sha2"), e.options.sha2, e.callback))
    return;
  const r = [];
  if (e.options.onProgress != null) {
    const o = Fs(t, "content-length");
    o != null && r.push(new WK.ProgressCallbackTransform(parseInt(o, 10), e.options.cancellationToken, e.options.onProgress));
  }
  const n = e.options.sha512;
  n != null ? r.push(new Yh(n, "sha512", n.length === 128 && !n.includes("+") && !n.includes("Z") && !n.includes("=") ? "hex" : "base64")) : e.options.sha2 != null && r.push(new Yh(e.options.sha2, "sha256", "hex"));
  const i = (0, zK.createWriteStream)(e.destination);
  r.push(i);
  let s = t;
  for (const o of r)
    o.on("error", (a) => {
      i.close(), e.options.cancellationToken.cancelled || e.callback(a);
    }), s = s.pipe(o);
  i.on("finish", () => {
    i.close(e.callback);
  });
}
function ou(e, t, r) {
  r != null && (e.method = r), e.headers = { ...e.headers };
  const n = e.headers;
  return t != null && (n.authorization = t.startsWith("Basic") || t.startsWith("Bearer") ? t : `token ${t}`), n["User-Agent"] == null && (n["User-Agent"] = "electron-builder"), (r == null || r === "GET" || n["Cache-Control"] == null) && (n["Cache-Control"] = "no-cache"), e.protocol == null && process.versions.electron != null && (e.protocol = "https:"), e;
}
function au(e, t) {
  return JSON.stringify(e, (r, n) => r.endsWith("Authorization") || r.endsWith("authorization") || r.endsWith("Password") || r.endsWith("PASSWORD") || r.endsWith("Token") || r.includes("password") || r.includes("token") || t != null && t.has(r) ? "<stripped sensitive data>" : n, 2);
}
var Ef = {};
Object.defineProperty(Ef, "__esModule", { value: !0 });
Ef.MemoLazy = void 0;
class ZK {
  constructor(t, r) {
    this.selector = t, this.creator = r, this.selected = void 0, this._value = void 0;
  }
  get hasValue() {
    return this._value !== void 0;
  }
  get value() {
    const t = this.selector();
    if (this._value !== void 0 && aO(this.selected, t))
      return this._value;
    this.selected = t;
    const r = this.creator(t);
    return this.value = r, r;
  }
  set value(t) {
    this._value = t;
  }
}
Ef.MemoLazy = ZK;
function aO(e, t) {
  if (typeof e == "object" && e !== null && (typeof t == "object" && t !== null)) {
    const i = Object.keys(e), s = Object.keys(t);
    return i.length === s.length && i.every((o) => aO(e[o], t[o]));
  }
  return e === t;
}
var wf = {};
Object.defineProperty(wf, "__esModule", { value: !0 });
wf.githubUrl = QK;
wf.getS3LikeProviderBaseUrl = eY;
function QK(e, t = "github.com") {
  return `${e.protocol || "https"}://${e.host || t}`;
}
function eY(e) {
  const t = e.provider;
  if (t === "s3")
    return tY(e);
  if (t === "spaces")
    return rY(e);
  throw new Error(`Not supported provider: ${t}`);
}
function tY(e) {
  let t;
  if (e.accelerate == !0)
    t = `https://${e.bucket}.s3-accelerate.amazonaws.com`;
  else if (e.endpoint != null)
    t = `${e.endpoint}/${e.bucket}`;
  else if (e.bucket.includes(".")) {
    if (e.region == null)
      throw new Error(`Bucket name "${e.bucket}" includes a dot, but S3 region is missing`);
    e.region === "us-east-1" ? t = `https://s3.amazonaws.com/${e.bucket}` : t = `https://s3-${e.region}.amazonaws.com/${e.bucket}`;
  } else e.region === "cn-north-1" ? t = `https://${e.bucket}.s3.${e.region}.amazonaws.com.cn` : t = `https://${e.bucket}.s3.amazonaws.com`;
  return cO(t, e.path);
}
function cO(e, t) {
  return t != null && t.length > 0 && (t.startsWith("/") || (e += "/"), e += t), e;
}
function rY(e) {
  if (e.name == null)
    throw new Error("name is missing");
  if (e.region == null)
    throw new Error("region is missing");
  return cO(`https://${e.name}.${e.region}.digitaloceanspaces.com`, e.path);
}
var qy = {};
Object.defineProperty(qy, "__esModule", { value: !0 });
qy.retry = lO;
const nY = Qn;
async function lO(e, t, r, n = 0, i = 0, s) {
  var o;
  const a = new nY.CancellationToken();
  try {
    return await e();
  } catch (c) {
    if ((!((o = s == null ? void 0 : s(c)) !== null && o !== void 0) || o) && t > 0 && !a.cancelled)
      return await new Promise((u) => setTimeout(u, r + n * i)), await lO(e, t - 1, r, n, i + 1, s);
    throw c;
  }
}
var By = {};
Object.defineProperty(By, "__esModule", { value: !0 });
By.parseDn = iY;
function iY(e) {
  let t = !1, r = null, n = "", i = 0;
  e = e.trim();
  const s = /* @__PURE__ */ new Map();
  for (let o = 0; o <= e.length; o++) {
    if (o === e.length) {
      r !== null && s.set(r, n);
      break;
    }
    const a = e[o];
    if (t) {
      if (a === '"') {
        t = !1;
        continue;
      }
    } else {
      if (a === '"') {
        t = !0;
        continue;
      }
      if (a === "\\") {
        o++;
        const c = parseInt(e.slice(o, o + 2), 16);
        Number.isNaN(c) ? n += e[o] : (o++, n += String.fromCharCode(c));
        continue;
      }
      if (r === null && a === "=") {
        r = n, n = "";
        continue;
      }
      if (a === "," || a === ";" || a === "+") {
        r !== null && s.set(r, n), r = null, n = "";
        continue;
      }
    }
    if (a === " " && !t) {
      if (n.length === 0)
        continue;
      if (o > i) {
        let c = o;
        for (; e[c] === " "; )
          c++;
        i = c;
      }
      if (i >= e.length || e[i] === "," || e[i] === ";" || r === null && e[i] === "=" || r !== null && e[i] === "+") {
        o = i - 1;
        continue;
      }
    }
    n += a;
  }
  return s;
}
var Ys = {};
Object.defineProperty(Ys, "__esModule", { value: !0 });
Ys.nil = Ys.UUID = void 0;
const uO = Gi, fO = fo, sY = "options.name must be either a string or a Buffer", Rw = (0, uO.randomBytes)(16);
Rw[0] = Rw[0] | 1;
const Il = {}, Ie = [];
for (let e = 0; e < 256; e++) {
  const t = (e + 256).toString(16).substr(1);
  Il[t] = e, Ie[e] = t;
}
class Bi {
  constructor(t) {
    this.ascii = null, this.binary = null;
    const r = Bi.check(t);
    if (!r)
      throw new Error("not a UUID");
    this.version = r.version, r.format === "ascii" ? this.ascii = t : this.binary = t;
  }
  static v5(t, r) {
    return oY(t, "sha1", 80, r);
  }
  toString() {
    return this.ascii == null && (this.ascii = aY(this.binary)), this.ascii;
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(t, r = 0) {
    if (typeof t == "string")
      return t = t.toLowerCase(), /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(t) ? t === "00000000-0000-0000-0000-000000000000" ? { version: void 0, variant: "nil", format: "ascii" } : {
        version: (Il[t[14] + t[15]] & 240) >> 4,
        variant: $w((Il[t[19] + t[20]] & 224) >> 5),
        format: "ascii"
      } : !1;
    if (Buffer.isBuffer(t)) {
      if (t.length < r + 16)
        return !1;
      let n = 0;
      for (; n < 16 && t[r + n] === 0; n++)
        ;
      return n === 16 ? { version: void 0, variant: "nil", format: "binary" } : {
        version: (t[r + 6] & 240) >> 4,
        variant: $w((t[r + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, fO.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  // read stringified uuid into a Buffer
  static parse(t) {
    const r = Buffer.allocUnsafe(16);
    let n = 0;
    for (let i = 0; i < 16; i++)
      r[i] = Il[t[n++] + t[n++]], (i === 3 || i === 5 || i === 7 || i === 9) && (n += 1);
    return r;
  }
}
Ys.UUID = Bi;
Bi.OID = Bi.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function $w(e) {
  switch (e) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
var ta;
(function(e) {
  e[e.ASCII = 0] = "ASCII", e[e.BINARY = 1] = "BINARY", e[e.OBJECT = 2] = "OBJECT";
})(ta || (ta = {}));
function oY(e, t, r, n, i = ta.ASCII) {
  const s = (0, uO.createHash)(t);
  if (typeof e != "string" && !Buffer.isBuffer(e))
    throw (0, fO.newError)(sY, "ERR_INVALID_UUID_NAME");
  s.update(n), s.update(e);
  const a = s.digest();
  let c;
  switch (i) {
    case ta.BINARY:
      a[6] = a[6] & 15 | r, a[8] = a[8] & 63 | 128, c = a;
      break;
    case ta.OBJECT:
      a[6] = a[6] & 15 | r, a[8] = a[8] & 63 | 128, c = new Bi(a);
      break;
    default:
      c = Ie[a[0]] + Ie[a[1]] + Ie[a[2]] + Ie[a[3]] + "-" + Ie[a[4]] + Ie[a[5]] + "-" + Ie[a[6] & 15 | r] + Ie[a[7]] + "-" + Ie[a[8] & 63 | 128] + Ie[a[9]] + "-" + Ie[a[10]] + Ie[a[11]] + Ie[a[12]] + Ie[a[13]] + Ie[a[14]] + Ie[a[15]];
      break;
  }
  return c;
}
function aY(e) {
  return Ie[e[0]] + Ie[e[1]] + Ie[e[2]] + Ie[e[3]] + "-" + Ie[e[4]] + Ie[e[5]] + "-" + Ie[e[6]] + Ie[e[7]] + "-" + Ie[e[8]] + Ie[e[9]] + "-" + Ie[e[10]] + Ie[e[11]] + Ie[e[12]] + Ie[e[13]] + Ie[e[14]] + Ie[e[15]];
}
Ys.nil = new Bi("00000000-0000-0000-0000-000000000000");
var sc = {}, dO = {};
(function(e) {
  (function(t) {
    t.parser = function(O, S) {
      return new n(O, S);
    }, t.SAXParser = n, t.SAXStream = l, t.createStream = u, t.MAX_BUFFER_LENGTH = 64 * 1024;
    var r = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    t.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function n(O, S) {
      if (!(this instanceof n))
        return new n(O, S);
      var W = this;
      s(W), W.q = W.c = "", W.bufferCheckPosition = t.MAX_BUFFER_LENGTH, W.opt = S || {}, W.opt.lowercase = W.opt.lowercase || W.opt.lowercasetags, W.looseCase = W.opt.lowercase ? "toLowerCase" : "toUpperCase", W.tags = [], W.closed = W.closedRoot = W.sawRoot = !1, W.tag = W.error = null, W.strict = !!O, W.noscript = !!(O || W.opt.noscript), W.state = b.BEGIN, W.strictEntities = W.opt.strictEntities, W.ENTITIES = W.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), W.attribList = [], W.opt.xmlns && (W.ns = Object.create(h)), W.opt.unquotedAttributeValues === void 0 && (W.opt.unquotedAttributeValues = !O), W.trackPosition = W.opt.position !== !1, W.trackPosition && (W.position = W.line = W.column = 0), H(W, "onready");
    }
    Object.create || (Object.create = function(O) {
      function S() {
      }
      S.prototype = O;
      var W = new S();
      return W;
    }), Object.keys || (Object.keys = function(O) {
      var S = [];
      for (var W in O) O.hasOwnProperty(W) && S.push(W);
      return S;
    });
    function i(O) {
      for (var S = Math.max(t.MAX_BUFFER_LENGTH, 10), W = 0, z = 0, Q = r.length; z < Q; z++) {
        var K = O[r[z]].length;
        if (K > S)
          switch (r[z]) {
            case "textNode":
              $(O);
              break;
            case "cdata":
              q(O, "oncdata", O.cdata), O.cdata = "";
              break;
            case "script":
              q(O, "onscript", O.script), O.script = "";
              break;
            default:
              A(O, "Max buffer length exceeded: " + r[z]);
          }
        W = Math.max(W, K);
      }
      var X = t.MAX_BUFFER_LENGTH - W;
      O.bufferCheckPosition = X + O.position;
    }
    function s(O) {
      for (var S = 0, W = r.length; S < W; S++)
        O[r[S]] = "";
    }
    function o(O) {
      $(O), O.cdata !== "" && (q(O, "oncdata", O.cdata), O.cdata = ""), O.script !== "" && (q(O, "onscript", O.script), O.script = "");
    }
    n.prototype = {
      end: function() {
        P(this);
      },
      write: G,
      resume: function() {
        return this.error = null, this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        o(this);
      }
    };
    var a;
    try {
      a = require("stream").Stream;
    } catch {
      a = function() {
      };
    }
    a || (a = function() {
    });
    var c = t.EVENTS.filter(function(O) {
      return O !== "error" && O !== "end";
    });
    function u(O, S) {
      return new l(O, S);
    }
    function l(O, S) {
      if (!(this instanceof l))
        return new l(O, S);
      a.apply(this), this._parser = new n(O, S), this.writable = !0, this.readable = !0;
      var W = this;
      this._parser.onend = function() {
        W.emit("end");
      }, this._parser.onerror = function(z) {
        W.emit("error", z), W._parser.error = null;
      }, this._decoder = null, c.forEach(function(z) {
        Object.defineProperty(W, "on" + z, {
          get: function() {
            return W._parser["on" + z];
          },
          set: function(Q) {
            if (!Q)
              return W.removeAllListeners(z), W._parser["on" + z] = Q, Q;
            W.on(z, Q);
          },
          enumerable: !0,
          configurable: !1
        });
      });
    }
    l.prototype = Object.create(a.prototype, {
      constructor: {
        value: l
      }
    }), l.prototype.write = function(O) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(O)) {
        if (!this._decoder) {
          var S = xC.StringDecoder;
          this._decoder = new S("utf8");
        }
        O = this._decoder.write(O);
      }
      return this._parser.write(O.toString()), this.emit("data", O), !0;
    }, l.prototype.end = function(O) {
      return O && O.length && this.write(O), this._parser.end(), !0;
    }, l.prototype.on = function(O, S) {
      var W = this;
      return !W._parser["on" + O] && c.indexOf(O) !== -1 && (W._parser["on" + O] = function() {
        var z = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        z.splice(0, 0, O), W.emit.apply(W, z);
      }), a.prototype.on.call(W, O, S);
    };
    var f = "[CDATA[", m = "DOCTYPE", p = "http://www.w3.org/XML/1998/namespace", d = "http://www.w3.org/2000/xmlns/", h = { xml: p, xmlns: d }, _ = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, g = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, v = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function E(O) {
      return O === " " || O === `
` || O === "\r" || O === "	";
    }
    function R(O) {
      return O === '"' || O === "'";
    }
    function w(O) {
      return O === ">" || E(O);
    }
    function C(O, S) {
      return O.test(S);
    }
    function V(O, S) {
      return !C(O, S);
    }
    var b = 0;
    t.STATE = {
      BEGIN: b++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: b++,
      // leading whitespace
      TEXT: b++,
      // general stuff
      TEXT_ENTITY: b++,
      // &amp and such.
      OPEN_WAKA: b++,
      // <
      SGML_DECL: b++,
      // <!BLARG
      SGML_DECL_QUOTED: b++,
      // <!BLARG foo "bar
      DOCTYPE: b++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: b++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: b++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: b++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: b++,
      // <!-
      COMMENT: b++,
      // <!--
      COMMENT_ENDING: b++,
      // <!-- blah -
      COMMENT_ENDED: b++,
      // <!-- blah --
      CDATA: b++,
      // <![CDATA[ something
      CDATA_ENDING: b++,
      // ]
      CDATA_ENDING_2: b++,
      // ]]
      PROC_INST: b++,
      // <?hi
      PROC_INST_BODY: b++,
      // <?hi there
      PROC_INST_ENDING: b++,
      // <?hi "there" ?
      OPEN_TAG: b++,
      // <strong
      OPEN_TAG_SLASH: b++,
      // <strong /
      ATTRIB: b++,
      // <a
      ATTRIB_NAME: b++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: b++,
      // <a foo _
      ATTRIB_VALUE: b++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: b++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: b++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: b++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: b++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: b++,
      // <foo bar=&quot
      CLOSE_TAG: b++,
      // </a
      CLOSE_TAG_SAW_WHITE: b++,
      // </a   >
      SCRIPT: b++,
      // <script> ...
      SCRIPT_ENDING: b++
      // <script> ... <
    }, t.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, t.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(t.ENTITIES).forEach(function(O) {
      var S = t.ENTITIES[O], W = typeof S == "number" ? String.fromCharCode(S) : S;
      t.ENTITIES[O] = W;
    });
    for (var F in t.STATE)
      t.STATE[t.STATE[F]] = F;
    b = t.STATE;
    function H(O, S, W) {
      O[S] && O[S](W);
    }
    function q(O, S, W) {
      O.textNode && $(O), H(O, S, W);
    }
    function $(O) {
      O.textNode = x(O.opt, O.textNode), O.textNode && H(O, "ontext", O.textNode), O.textNode = "";
    }
    function x(O, S) {
      return O.trim && (S = S.trim()), O.normalize && (S = S.replace(/\s+/g, " ")), S;
    }
    function A(O, S) {
      return $(O), O.trackPosition && (S += `
Line: ` + O.line + `
Column: ` + O.column + `
Char: ` + O.c), S = new Error(S), O.error = S, H(O, "onerror", S), O;
    }
    function P(O) {
      return O.sawRoot && !O.closedRoot && D(O, "Unclosed root tag"), O.state !== b.BEGIN && O.state !== b.BEGIN_WHITESPACE && O.state !== b.TEXT && A(O, "Unexpected end"), $(O), O.c = "", O.closed = !0, H(O, "onend"), n.call(O, O.strict, O.opt), O;
    }
    function D(O, S) {
      if (typeof O != "object" || !(O instanceof n))
        throw new Error("bad call to strictFail");
      O.strict && A(O, S);
    }
    function I(O) {
      O.strict || (O.tagName = O.tagName[O.looseCase]());
      var S = O.tags[O.tags.length - 1] || O, W = O.tag = { name: O.tagName, attributes: {} };
      O.opt.xmlns && (W.ns = S.ns), O.attribList.length = 0, q(O, "onopentagstart", W);
    }
    function L(O, S) {
      var W = O.indexOf(":"), z = W < 0 ? ["", O] : O.split(":"), Q = z[0], K = z[1];
      return S && O === "xmlns" && (Q = "xmlns", K = ""), { prefix: Q, local: K };
    }
    function j(O) {
      if (O.strict || (O.attribName = O.attribName[O.looseCase]()), O.attribList.indexOf(O.attribName) !== -1 || O.tag.attributes.hasOwnProperty(O.attribName)) {
        O.attribName = O.attribValue = "";
        return;
      }
      if (O.opt.xmlns) {
        var S = L(O.attribName, !0), W = S.prefix, z = S.local;
        if (W === "xmlns")
          if (z === "xml" && O.attribValue !== p)
            D(
              O,
              "xml: prefix must be bound to " + p + `
Actual: ` + O.attribValue
            );
          else if (z === "xmlns" && O.attribValue !== d)
            D(
              O,
              "xmlns: prefix must be bound to " + d + `
Actual: ` + O.attribValue
            );
          else {
            var Q = O.tag, K = O.tags[O.tags.length - 1] || O;
            Q.ns === K.ns && (Q.ns = Object.create(K.ns)), Q.ns[z] = O.attribValue;
          }
        O.attribList.push([O.attribName, O.attribValue]);
      } else
        O.tag.attributes[O.attribName] = O.attribValue, q(O, "onattribute", {
          name: O.attribName,
          value: O.attribValue
        });
      O.attribName = O.attribValue = "";
    }
    function k(O, S) {
      if (O.opt.xmlns) {
        var W = O.tag, z = L(O.tagName);
        W.prefix = z.prefix, W.local = z.local, W.uri = W.ns[z.prefix] || "", W.prefix && !W.uri && (D(O, "Unbound namespace prefix: " + JSON.stringify(O.tagName)), W.uri = z.prefix);
        var Q = O.tags[O.tags.length - 1] || O;
        W.ns && Q.ns !== W.ns && Object.keys(W.ns).forEach(function(qe) {
          q(O, "onopennamespace", {
            prefix: qe,
            uri: W.ns[qe]
          });
        });
        for (var K = 0, X = O.attribList.length; K < X; K++) {
          var J = O.attribList[K], re = J[0], fe = J[1], ee = L(re, !0), le = ee.prefix, Se = ee.local, ye = le === "" ? "" : W.ns[le] || "", ve = {
            name: re,
            value: fe,
            prefix: le,
            local: Se,
            uri: ye
          };
          le && le !== "xmlns" && !ye && (D(O, "Unbound namespace prefix: " + JSON.stringify(le)), ve.uri = le), O.tag.attributes[re] = ve, q(O, "onattribute", ve);
        }
        O.attribList.length = 0;
      }
      O.tag.isSelfClosing = !!S, O.sawRoot = !0, O.tags.push(O.tag), q(O, "onopentag", O.tag), S || (!O.noscript && O.tagName.toLowerCase() === "script" ? O.state = b.SCRIPT : O.state = b.TEXT, O.tag = null, O.tagName = ""), O.attribName = O.attribValue = "", O.attribList.length = 0;
    }
    function U(O) {
      if (!O.tagName) {
        D(O, "Weird empty close tag."), O.textNode += "</>", O.state = b.TEXT;
        return;
      }
      if (O.script) {
        if (O.tagName !== "script") {
          O.script += "</" + O.tagName + ">", O.tagName = "", O.state = b.SCRIPT;
          return;
        }
        q(O, "onscript", O.script), O.script = "";
      }
      var S = O.tags.length, W = O.tagName;
      O.strict || (W = W[O.looseCase]());
      for (var z = W; S--; ) {
        var Q = O.tags[S];
        if (Q.name !== z)
          D(O, "Unexpected close tag");
        else
          break;
      }
      if (S < 0) {
        D(O, "Unmatched closing tag: " + O.tagName), O.textNode += "</" + O.tagName + ">", O.state = b.TEXT;
        return;
      }
      O.tagName = W;
      for (var K = O.tags.length; K-- > S; ) {
        var X = O.tag = O.tags.pop();
        O.tagName = O.tag.name, q(O, "onclosetag", O.tagName);
        var J = {};
        for (var re in X.ns)
          J[re] = X.ns[re];
        var fe = O.tags[O.tags.length - 1] || O;
        O.opt.xmlns && X.ns !== fe.ns && Object.keys(X.ns).forEach(function(ee) {
          var le = X.ns[ee];
          q(O, "onclosenamespace", { prefix: ee, uri: le });
        });
      }
      S === 0 && (O.closedRoot = !0), O.tagName = O.attribValue = O.attribName = "", O.attribList.length = 0, O.state = b.TEXT;
    }
    function M(O) {
      var S = O.entity, W = S.toLowerCase(), z, Q = "";
      return O.ENTITIES[S] ? O.ENTITIES[S] : O.ENTITIES[W] ? O.ENTITIES[W] : (S = W, S.charAt(0) === "#" && (S.charAt(1) === "x" ? (S = S.slice(2), z = parseInt(S, 16), Q = z.toString(16)) : (S = S.slice(1), z = parseInt(S, 10), Q = z.toString(10))), S = S.replace(/^0+/, ""), isNaN(z) || Q.toLowerCase() !== S ? (D(O, "Invalid character entity"), "&" + O.entity + ";") : String.fromCodePoint(z));
    }
    function T(O, S) {
      S === "<" ? (O.state = b.OPEN_WAKA, O.startTagPosition = O.position) : E(S) || (D(O, "Non-whitespace before first tag."), O.textNode = S, O.state = b.TEXT);
    }
    function N(O, S) {
      var W = "";
      return S < O.length && (W = O.charAt(S)), W;
    }
    function G(O) {
      var S = this;
      if (this.error)
        throw this.error;
      if (S.closed)
        return A(
          S,
          "Cannot write after close. Assign an onready handler."
        );
      if (O === null)
        return P(S);
      typeof O == "object" && (O = O.toString());
      for (var W = 0, z = ""; z = N(O, W++), S.c = z, !!z; )
        switch (S.trackPosition && (S.position++, z === `
` ? (S.line++, S.column = 0) : S.column++), S.state) {
          case b.BEGIN:
            if (S.state = b.BEGIN_WHITESPACE, z === "\uFEFF")
              continue;
            T(S, z);
            continue;
          case b.BEGIN_WHITESPACE:
            T(S, z);
            continue;
          case b.TEXT:
            if (S.sawRoot && !S.closedRoot) {
              for (var Q = W - 1; z && z !== "<" && z !== "&"; )
                z = N(O, W++), z && S.trackPosition && (S.position++, z === `
` ? (S.line++, S.column = 0) : S.column++);
              S.textNode += O.substring(Q, W - 1);
            }
            z === "<" && !(S.sawRoot && S.closedRoot && !S.strict) ? (S.state = b.OPEN_WAKA, S.startTagPosition = S.position) : (!E(z) && (!S.sawRoot || S.closedRoot) && D(S, "Text data outside of root node."), z === "&" ? S.state = b.TEXT_ENTITY : S.textNode += z);
            continue;
          case b.SCRIPT:
            z === "<" ? S.state = b.SCRIPT_ENDING : S.script += z;
            continue;
          case b.SCRIPT_ENDING:
            z === "/" ? S.state = b.CLOSE_TAG : (S.script += "<" + z, S.state = b.SCRIPT);
            continue;
          case b.OPEN_WAKA:
            if (z === "!")
              S.state = b.SGML_DECL, S.sgmlDecl = "";
            else if (!E(z)) if (C(_, z))
              S.state = b.OPEN_TAG, S.tagName = z;
            else if (z === "/")
              S.state = b.CLOSE_TAG, S.tagName = "";
            else if (z === "?")
              S.state = b.PROC_INST, S.procInstName = S.procInstBody = "";
            else {
              if (D(S, "Unencoded <"), S.startTagPosition + 1 < S.position) {
                var K = S.position - S.startTagPosition;
                z = new Array(K).join(" ") + z;
              }
              S.textNode += "<" + z, S.state = b.TEXT;
            }
            continue;
          case b.SGML_DECL:
            if (S.sgmlDecl + z === "--") {
              S.state = b.COMMENT, S.comment = "", S.sgmlDecl = "";
              continue;
            }
            S.doctype && S.doctype !== !0 && S.sgmlDecl ? (S.state = b.DOCTYPE_DTD, S.doctype += "<!" + S.sgmlDecl + z, S.sgmlDecl = "") : (S.sgmlDecl + z).toUpperCase() === f ? (q(S, "onopencdata"), S.state = b.CDATA, S.sgmlDecl = "", S.cdata = "") : (S.sgmlDecl + z).toUpperCase() === m ? (S.state = b.DOCTYPE, (S.doctype || S.sawRoot) && D(
              S,
              "Inappropriately located doctype declaration"
            ), S.doctype = "", S.sgmlDecl = "") : z === ">" ? (q(S, "onsgmldeclaration", S.sgmlDecl), S.sgmlDecl = "", S.state = b.TEXT) : (R(z) && (S.state = b.SGML_DECL_QUOTED), S.sgmlDecl += z);
            continue;
          case b.SGML_DECL_QUOTED:
            z === S.q && (S.state = b.SGML_DECL, S.q = ""), S.sgmlDecl += z;
            continue;
          case b.DOCTYPE:
            z === ">" ? (S.state = b.TEXT, q(S, "ondoctype", S.doctype), S.doctype = !0) : (S.doctype += z, z === "[" ? S.state = b.DOCTYPE_DTD : R(z) && (S.state = b.DOCTYPE_QUOTED, S.q = z));
            continue;
          case b.DOCTYPE_QUOTED:
            S.doctype += z, z === S.q && (S.q = "", S.state = b.DOCTYPE);
            continue;
          case b.DOCTYPE_DTD:
            z === "]" ? (S.doctype += z, S.state = b.DOCTYPE) : z === "<" ? (S.state = b.OPEN_WAKA, S.startTagPosition = S.position) : R(z) ? (S.doctype += z, S.state = b.DOCTYPE_DTD_QUOTED, S.q = z) : S.doctype += z;
            continue;
          case b.DOCTYPE_DTD_QUOTED:
            S.doctype += z, z === S.q && (S.state = b.DOCTYPE_DTD, S.q = "");
            continue;
          case b.COMMENT:
            z === "-" ? S.state = b.COMMENT_ENDING : S.comment += z;
            continue;
          case b.COMMENT_ENDING:
            z === "-" ? (S.state = b.COMMENT_ENDED, S.comment = x(S.opt, S.comment), S.comment && q(S, "oncomment", S.comment), S.comment = "") : (S.comment += "-" + z, S.state = b.COMMENT);
            continue;
          case b.COMMENT_ENDED:
            z !== ">" ? (D(S, "Malformed comment"), S.comment += "--" + z, S.state = b.COMMENT) : S.doctype && S.doctype !== !0 ? S.state = b.DOCTYPE_DTD : S.state = b.TEXT;
            continue;
          case b.CDATA:
            z === "]" ? S.state = b.CDATA_ENDING : S.cdata += z;
            continue;
          case b.CDATA_ENDING:
            z === "]" ? S.state = b.CDATA_ENDING_2 : (S.cdata += "]" + z, S.state = b.CDATA);
            continue;
          case b.CDATA_ENDING_2:
            z === ">" ? (S.cdata && q(S, "oncdata", S.cdata), q(S, "onclosecdata"), S.cdata = "", S.state = b.TEXT) : z === "]" ? S.cdata += "]" : (S.cdata += "]]" + z, S.state = b.CDATA);
            continue;
          case b.PROC_INST:
            z === "?" ? S.state = b.PROC_INST_ENDING : E(z) ? S.state = b.PROC_INST_BODY : S.procInstName += z;
            continue;
          case b.PROC_INST_BODY:
            if (!S.procInstBody && E(z))
              continue;
            z === "?" ? S.state = b.PROC_INST_ENDING : S.procInstBody += z;
            continue;
          case b.PROC_INST_ENDING:
            z === ">" ? (q(S, "onprocessinginstruction", {
              name: S.procInstName,
              body: S.procInstBody
            }), S.procInstName = S.procInstBody = "", S.state = b.TEXT) : (S.procInstBody += "?" + z, S.state = b.PROC_INST_BODY);
            continue;
          case b.OPEN_TAG:
            C(g, z) ? S.tagName += z : (I(S), z === ">" ? k(S) : z === "/" ? S.state = b.OPEN_TAG_SLASH : (E(z) || D(S, "Invalid character in tag name"), S.state = b.ATTRIB));
            continue;
          case b.OPEN_TAG_SLASH:
            z === ">" ? (k(S, !0), U(S)) : (D(S, "Forward-slash in opening tag not followed by >"), S.state = b.ATTRIB);
            continue;
          case b.ATTRIB:
            if (E(z))
              continue;
            z === ">" ? k(S) : z === "/" ? S.state = b.OPEN_TAG_SLASH : C(_, z) ? (S.attribName = z, S.attribValue = "", S.state = b.ATTRIB_NAME) : D(S, "Invalid attribute name");
            continue;
          case b.ATTRIB_NAME:
            z === "=" ? S.state = b.ATTRIB_VALUE : z === ">" ? (D(S, "Attribute without value"), S.attribValue = S.attribName, j(S), k(S)) : E(z) ? S.state = b.ATTRIB_NAME_SAW_WHITE : C(g, z) ? S.attribName += z : D(S, "Invalid attribute name");
            continue;
          case b.ATTRIB_NAME_SAW_WHITE:
            if (z === "=")
              S.state = b.ATTRIB_VALUE;
            else {
              if (E(z))
                continue;
              D(S, "Attribute without value"), S.tag.attributes[S.attribName] = "", S.attribValue = "", q(S, "onattribute", {
                name: S.attribName,
                value: ""
              }), S.attribName = "", z === ">" ? k(S) : C(_, z) ? (S.attribName = z, S.state = b.ATTRIB_NAME) : (D(S, "Invalid attribute name"), S.state = b.ATTRIB);
            }
            continue;
          case b.ATTRIB_VALUE:
            if (E(z))
              continue;
            R(z) ? (S.q = z, S.state = b.ATTRIB_VALUE_QUOTED) : (S.opt.unquotedAttributeValues || A(S, "Unquoted attribute value"), S.state = b.ATTRIB_VALUE_UNQUOTED, S.attribValue = z);
            continue;
          case b.ATTRIB_VALUE_QUOTED:
            if (z !== S.q) {
              z === "&" ? S.state = b.ATTRIB_VALUE_ENTITY_Q : S.attribValue += z;
              continue;
            }
            j(S), S.q = "", S.state = b.ATTRIB_VALUE_CLOSED;
            continue;
          case b.ATTRIB_VALUE_CLOSED:
            E(z) ? S.state = b.ATTRIB : z === ">" ? k(S) : z === "/" ? S.state = b.OPEN_TAG_SLASH : C(_, z) ? (D(S, "No whitespace between attributes"), S.attribName = z, S.attribValue = "", S.state = b.ATTRIB_NAME) : D(S, "Invalid attribute name");
            continue;
          case b.ATTRIB_VALUE_UNQUOTED:
            if (!w(z)) {
              z === "&" ? S.state = b.ATTRIB_VALUE_ENTITY_U : S.attribValue += z;
              continue;
            }
            j(S), z === ">" ? k(S) : S.state = b.ATTRIB;
            continue;
          case b.CLOSE_TAG:
            if (S.tagName)
              z === ">" ? U(S) : C(g, z) ? S.tagName += z : S.script ? (S.script += "</" + S.tagName, S.tagName = "", S.state = b.SCRIPT) : (E(z) || D(S, "Invalid tagname in closing tag"), S.state = b.CLOSE_TAG_SAW_WHITE);
            else {
              if (E(z))
                continue;
              V(_, z) ? S.script ? (S.script += "</" + z, S.state = b.SCRIPT) : D(S, "Invalid tagname in closing tag.") : S.tagName = z;
            }
            continue;
          case b.CLOSE_TAG_SAW_WHITE:
            if (E(z))
              continue;
            z === ">" ? U(S) : D(S, "Invalid characters in closing tag");
            continue;
          case b.TEXT_ENTITY:
          case b.ATTRIB_VALUE_ENTITY_Q:
          case b.ATTRIB_VALUE_ENTITY_U:
            var X, J;
            switch (S.state) {
              case b.TEXT_ENTITY:
                X = b.TEXT, J = "textNode";
                break;
              case b.ATTRIB_VALUE_ENTITY_Q:
                X = b.ATTRIB_VALUE_QUOTED, J = "attribValue";
                break;
              case b.ATTRIB_VALUE_ENTITY_U:
                X = b.ATTRIB_VALUE_UNQUOTED, J = "attribValue";
                break;
            }
            if (z === ";") {
              var re = M(S);
              S.opt.unparsedEntities && !Object.values(t.XML_ENTITIES).includes(re) ? (S.entity = "", S.state = X, S.write(re)) : (S[J] += re, S.entity = "", S.state = X);
            } else C(S.entity.length ? y : v, z) ? S.entity += z : (D(S, "Invalid character in entity name"), S[J] += "&" + S.entity + z, S.entity = "", S.state = X);
            continue;
          default:
            throw new Error(S, "Unknown state: " + S.state);
        }
      return S.position >= S.bufferCheckPosition && i(S), S;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    String.fromCodePoint || function() {
      var O = String.fromCharCode, S = Math.floor, W = function() {
        var z = 16384, Q = [], K, X, J = -1, re = arguments.length;
        if (!re)
          return "";
        for (var fe = ""; ++J < re; ) {
          var ee = Number(arguments[J]);
          if (!isFinite(ee) || // `NaN`, `+Infinity`, or `-Infinity`
          ee < 0 || // not a valid Unicode code point
          ee > 1114111 || // not a valid Unicode code point
          S(ee) !== ee)
            throw RangeError("Invalid code point: " + ee);
          ee <= 65535 ? Q.push(ee) : (ee -= 65536, K = (ee >> 10) + 55296, X = ee % 1024 + 56320, Q.push(K, X)), (J + 1 === re || Q.length > z) && (fe += O.apply(null, Q), Q.length = 0);
        }
        return fe;
      };
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: W,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = W;
    }();
  })(e);
})(dO);
Object.defineProperty(sc, "__esModule", { value: !0 });
sc.XElement = void 0;
sc.parseXml = fY;
const cY = dO, rl = fo;
class pO {
  constructor(t) {
    if (this.name = t, this.value = "", this.attributes = null, this.isCData = !1, this.elements = null, !t)
      throw (0, rl.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    if (!uY(t))
      throw (0, rl.newError)(`Invalid element name: ${t}`, "ERR_XML_ELEMENT_INVALID_NAME");
  }
  attribute(t) {
    const r = this.attributes === null ? null : this.attributes[t];
    if (r == null)
      throw (0, rl.newError)(`No attribute "${t}"`, "ERR_XML_MISSED_ATTRIBUTE");
    return r;
  }
  removeAttribute(t) {
    this.attributes !== null && delete this.attributes[t];
  }
  element(t, r = !1, n = null) {
    const i = this.elementOrNull(t, r);
    if (i === null)
      throw (0, rl.newError)(n || `No element "${t}"`, "ERR_XML_MISSED_ELEMENT");
    return i;
  }
  elementOrNull(t, r = !1) {
    if (this.elements === null)
      return null;
    for (const n of this.elements)
      if (Tw(n, t, r))
        return n;
    return null;
  }
  getElements(t, r = !1) {
    return this.elements === null ? [] : this.elements.filter((n) => Tw(n, t, r));
  }
  elementValueOrEmpty(t, r = !1) {
    const n = this.elementOrNull(t, r);
    return n === null ? "" : n.value;
  }
}
sc.XElement = pO;
const lY = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function uY(e) {
  return lY.test(e);
}
function Tw(e, t, r) {
  const n = e.name;
  return n === t || r === !0 && n.length === t.length && n.toLowerCase() === t.toLowerCase();
}
function fY(e) {
  let t = null;
  const r = cY.parser(!0, {}), n = [];
  return r.onopentag = (i) => {
    const s = new pO(i.name);
    if (s.attributes = i.attributes, t === null)
      t = s;
    else {
      const o = n[n.length - 1];
      o.elements == null && (o.elements = []), o.elements.push(s);
    }
    n.push(s);
  }, r.onclosetag = () => {
    n.pop();
  }, r.ontext = (i) => {
    n.length > 0 && (n[n.length - 1].value = i);
  }, r.oncdata = (i) => {
    const s = n[n.length - 1];
    s.value = i, s.isCData = !0;
  }, r.onerror = (i) => {
    throw i;
  }, r.write(e), t;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CURRENT_APP_PACKAGE_FILE_NAME = e.CURRENT_APP_INSTALLER_FILE_NAME = e.XElement = e.parseXml = e.UUID = e.parseDn = e.retry = e.githubUrl = e.getS3LikeProviderBaseUrl = e.ProgressCallbackTransform = e.MemoLazy = e.safeStringifyJson = e.safeGetHeader = e.parseJson = e.HttpExecutor = e.HttpError = e.DigestTransform = e.createHttpError = e.configureRequestUrl = e.configureRequestOptionsFromUrl = e.configureRequestOptions = e.newError = e.CancellationToken = e.CancellationError = void 0, e.asArray = f;
  var t = Qn;
  Object.defineProperty(e, "CancellationError", { enumerable: !0, get: function() {
    return t.CancellationError;
  } }), Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } });
  var r = fo;
  Object.defineProperty(e, "newError", { enumerable: !0, get: function() {
    return r.newError;
  } });
  var n = Qt;
  Object.defineProperty(e, "configureRequestOptions", { enumerable: !0, get: function() {
    return n.configureRequestOptions;
  } }), Object.defineProperty(e, "configureRequestOptionsFromUrl", { enumerable: !0, get: function() {
    return n.configureRequestOptionsFromUrl;
  } }), Object.defineProperty(e, "configureRequestUrl", { enumerable: !0, get: function() {
    return n.configureRequestUrl;
  } }), Object.defineProperty(e, "createHttpError", { enumerable: !0, get: function() {
    return n.createHttpError;
  } }), Object.defineProperty(e, "DigestTransform", { enumerable: !0, get: function() {
    return n.DigestTransform;
  } }), Object.defineProperty(e, "HttpError", { enumerable: !0, get: function() {
    return n.HttpError;
  } }), Object.defineProperty(e, "HttpExecutor", { enumerable: !0, get: function() {
    return n.HttpExecutor;
  } }), Object.defineProperty(e, "parseJson", { enumerable: !0, get: function() {
    return n.parseJson;
  } }), Object.defineProperty(e, "safeGetHeader", { enumerable: !0, get: function() {
    return n.safeGetHeader;
  } }), Object.defineProperty(e, "safeStringifyJson", { enumerable: !0, get: function() {
    return n.safeStringifyJson;
  } });
  var i = Ef;
  Object.defineProperty(e, "MemoLazy", { enumerable: !0, get: function() {
    return i.MemoLazy;
  } });
  var s = ic;
  Object.defineProperty(e, "ProgressCallbackTransform", { enumerable: !0, get: function() {
    return s.ProgressCallbackTransform;
  } });
  var o = wf;
  Object.defineProperty(e, "getS3LikeProviderBaseUrl", { enumerable: !0, get: function() {
    return o.getS3LikeProviderBaseUrl;
  } }), Object.defineProperty(e, "githubUrl", { enumerable: !0, get: function() {
    return o.githubUrl;
  } });
  var a = qy;
  Object.defineProperty(e, "retry", { enumerable: !0, get: function() {
    return a.retry;
  } });
  var c = By;
  Object.defineProperty(e, "parseDn", { enumerable: !0, get: function() {
    return c.parseDn;
  } });
  var u = Ys;
  Object.defineProperty(e, "UUID", { enumerable: !0, get: function() {
    return u.UUID;
  } });
  var l = sc;
  Object.defineProperty(e, "parseXml", { enumerable: !0, get: function() {
    return l.parseXml;
  } }), Object.defineProperty(e, "XElement", { enumerable: !0, get: function() {
    return l.XElement;
  } }), e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe", e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function f(m) {
    return m == null ? [] : Array.isArray(m) ? m : [m];
  }
})(Rt);
var jt = {}, zy = {}, Gr = {};
function hO(e) {
  return typeof e > "u" || e === null;
}
function dY(e) {
  return typeof e == "object" && e !== null;
}
function pY(e) {
  return Array.isArray(e) ? e : hO(e) ? [] : [e];
}
function hY(e, t) {
  var r, n, i, s;
  if (t)
    for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1)
      i = s[r], e[i] = t[i];
  return e;
}
function mY(e, t) {
  var r = "", n;
  for (n = 0; n < t; n += 1)
    r += e;
  return r;
}
function gY(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
Gr.isNothing = hO;
Gr.isObject = dY;
Gr.toArray = pY;
Gr.repeat = mY;
Gr.isNegativeZero = gY;
Gr.extend = hY;
function mO(e, t) {
  var r = "", n = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), n + " " + r) : n;
}
function ba(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = mO(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
ba.prototype = Object.create(Error.prototype);
ba.prototype.constructor = ba;
ba.prototype.toString = function(t) {
  return this.name + ": " + mO(this, t);
};
var oc = ba, zo = Gr;
function Bp(e, t, r, n, i) {
  var s = "", o = "", a = Math.floor(i / 2) - 1;
  return n - t > a && (s = " ... ", t = n - a + s.length), r - n > a && (o = " ...", r = n + a - o.length), {
    str: s + e.slice(t, r).replace(/\t/g, "→") + o,
    pos: n - t + s.length
    // relative position
  };
}
function zp(e, t) {
  return zo.repeat(" ", t - e.length) + e;
}
function yY(e, t) {
  if (t = Object.create(t || null), !e.buffer) return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1; s = r.exec(e.buffer); )
    i.push(s.index), n.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = n.length - 2);
  o < 0 && (o = n.length - 1);
  var a = "", c, u, l = Math.min(e.line + t.linesAfter, i.length).toString().length, f = t.maxLength - (t.indent + l + 3);
  for (c = 1; c <= t.linesBefore && !(o - c < 0); c++)
    u = Bp(
      e.buffer,
      n[o - c],
      i[o - c],
      e.position - (n[o] - n[o - c]),
      f
    ), a = zo.repeat(" ", t.indent) + zp((e.line - c + 1).toString(), l) + " | " + u.str + `
` + a;
  for (u = Bp(e.buffer, n[o], i[o], e.position, f), a += zo.repeat(" ", t.indent) + zp((e.line + 1).toString(), l) + " | " + u.str + `
`, a += zo.repeat("-", t.indent + l + 3 + u.pos) + `^
`, c = 1; c <= t.linesAfter && !(o + c >= i.length); c++)
    u = Bp(
      e.buffer,
      n[o + c],
      i[o + c],
      e.position - (n[o] - n[o + c]),
      f
    ), a += zo.repeat(" ", t.indent) + zp((e.line + c + 1).toString(), l) + " | " + u.str + `
`;
  return a.replace(/\n$/, "");
}
var vY = yY, Ow = oc, _Y = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], bY = [
  "scalar",
  "sequence",
  "mapping"
];
function EY(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(n) {
      t[String(n)] = r;
    });
  }), t;
}
function wY(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (_Y.indexOf(r) === -1)
      throw new Ow('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = EY(t.styleAliases || null), bY.indexOf(this.kind) === -1)
    throw new Ow('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var ir = wY, Uo = oc, Vp = ir;
function Pw(e, t) {
  var r = [];
  return e[t].forEach(function(n) {
    var i = r.length;
    r.forEach(function(s, o) {
      s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = o);
    }), r[i] = n;
  }), r;
}
function SY() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function n(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(n);
  return e;
}
function Jh(e) {
  return this.extend(e);
}
Jh.prototype.extend = function(t) {
  var r = [], n = [];
  if (t instanceof Vp)
    n.push(t);
  else if (Array.isArray(t))
    n = n.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (n = n.concat(t.explicit));
  else
    throw new Uo("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(s) {
    if (!(s instanceof Vp))
      throw new Uo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Uo("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Uo("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n.forEach(function(s) {
    if (!(s instanceof Vp))
      throw new Uo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(Jh.prototype);
  return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = Pw(i, "implicit"), i.compiledExplicit = Pw(i, "explicit"), i.compiledTypeMap = SY(i.compiledImplicit, i.compiledExplicit), i;
};
var gO = Jh, xY = ir, yO = new xY("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), RY = ir, vO = new RY("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), $Y = ir, _O = new $Y("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), TY = gO, bO = new TY({
  explicit: [
    yO,
    vO,
    _O
  ]
}), OY = ir;
function PY(e) {
  if (e === null) return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function CY() {
  return null;
}
function AY(e) {
  return e === null;
}
var EO = new OY("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: PY,
  construct: CY,
  predicate: AY,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), IY = ir;
function NY(e) {
  if (e === null) return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function kY(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function DY(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var wO = new IY("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: NY,
  construct: kY,
  predicate: DY,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), LY = Gr, FY = ir;
function jY(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function UY(e) {
  return 48 <= e && e <= 55;
}
function MY(e) {
  return 48 <= e && e <= 57;
}
function HY(e) {
  if (e === null) return !1;
  var t = e.length, r = 0, n = !1, i;
  if (!t) return !1;
  if (i = e[r], (i === "-" || i === "+") && (i = e[++r]), i === "0") {
    if (r + 1 === t) return !0;
    if (i = e[++r], i === "b") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (!jY(e.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (!UY(e.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; r < t; r++)
    if (i = e[r], i !== "_") {
      if (!MY(e.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !(!n || i === "_");
}
function qY(e) {
  var t = e, r = 1, n;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), n = t[0], (n === "-" || n === "+") && (n === "-" && (r = -1), t = t.slice(1), n = t[0]), t === "0") return 0;
  if (n === "0") {
    if (t[1] === "b") return r * parseInt(t.slice(2), 2);
    if (t[1] === "x") return r * parseInt(t.slice(2), 16);
    if (t[1] === "o") return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
function BY(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !LY.isNegativeZero(e);
}
var SO = new FY("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: HY,
  construct: qY,
  predicate: BY,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), xO = Gr, zY = ir, VY = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function GY(e) {
  return !(e === null || !VY.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function WY(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
var KY = /^[-+]?[0-9]+e/;
function YY(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (xO.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), KY.test(r) ? r.replace("e", ".e") : r;
}
function JY(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || xO.isNegativeZero(e));
}
var RO = new zY("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: GY,
  construct: WY,
  predicate: JY,
  represent: YY,
  defaultStyle: "lowercase"
}), $O = bO.extend({
  implicit: [
    EO,
    wO,
    SO,
    RO
  ]
}), TO = $O, XY = ir, OO = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), PO = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function ZY(e) {
  return e === null ? !1 : OO.exec(e) !== null || PO.exec(e) !== null;
}
function QY(e) {
  var t, r, n, i, s, o, a, c = 0, u = null, l, f, m;
  if (t = OO.exec(e), t === null && (t = PO.exec(e)), t === null) throw new Error("Date resolve error");
  if (r = +t[1], n = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +t[4], o = +t[5], a = +t[6], t[7]) {
    for (c = t[7].slice(0, 3); c.length < 3; )
      c += "0";
    c = +c;
  }
  return t[9] && (l = +t[10], f = +(t[11] || 0), u = (l * 60 + f) * 6e4, t[9] === "-" && (u = -u)), m = new Date(Date.UTC(r, n, i, s, o, a, c)), u && m.setTime(m.getTime() - u), m;
}
function eJ(e) {
  return e.toISOString();
}
var CO = new XY("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: ZY,
  construct: QY,
  instanceOf: Date,
  represent: eJ
}), tJ = ir;
function rJ(e) {
  return e === "<<" || e === null;
}
var AO = new tJ("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: rJ
}), nJ = ir, Vy = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function iJ(e) {
  if (e === null) return !1;
  var t, r, n = 0, i = e.length, s = Vy;
  for (r = 0; r < i; r++)
    if (t = s.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0) return !1;
      n += 6;
    }
  return n % 8 === 0;
}
function sJ(e) {
  var t, r, n = e.replace(/[\r\n=]/g, ""), i = n.length, s = Vy, o = 0, a = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(n.charAt(t));
  return r = i % 4 * 6, r === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : r === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : r === 12 && a.push(o >> 4 & 255), new Uint8Array(a);
}
function oJ(e) {
  var t = "", r = 0, n, i, s = e.length, o = Vy;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (t += o[r >> 18 & 63], t += o[r >> 12 & 63], t += o[r >> 6 & 63], t += o[r & 63]), r = (r << 8) + e[n];
  return i = s % 3, i === 0 ? (t += o[r >> 18 & 63], t += o[r >> 12 & 63], t += o[r >> 6 & 63], t += o[r & 63]) : i === 2 ? (t += o[r >> 10 & 63], t += o[r >> 4 & 63], t += o[r << 2 & 63], t += o[64]) : i === 1 && (t += o[r >> 2 & 63], t += o[r << 4 & 63], t += o[64], t += o[64]), t;
}
function aJ(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var IO = new nJ("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: iJ,
  construct: sJ,
  predicate: aJ,
  represent: oJ
}), cJ = ir, lJ = Object.prototype.hasOwnProperty, uJ = Object.prototype.toString;
function fJ(e) {
  if (e === null) return !0;
  var t = [], r, n, i, s, o, a = e;
  for (r = 0, n = a.length; r < n; r += 1) {
    if (i = a[r], o = !1, uJ.call(i) !== "[object Object]") return !1;
    for (s in i)
      if (lJ.call(i, s))
        if (!o) o = !0;
        else return !1;
    if (!o) return !1;
    if (t.indexOf(s) === -1) t.push(s);
    else return !1;
  }
  return !0;
}
function dJ(e) {
  return e !== null ? e : [];
}
var NO = new cJ("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: fJ,
  construct: dJ
}), pJ = ir, hJ = Object.prototype.toString;
function mJ(e) {
  if (e === null) return !0;
  var t, r, n, i, s, o = e;
  for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
    if (n = o[t], hJ.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return !1;
    s[t] = [i[0], n[i[0]]];
  }
  return !0;
}
function gJ(e) {
  if (e === null) return [];
  var t, r, n, i, s, o = e;
  for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
    n = o[t], i = Object.keys(n), s[t] = [i[0], n[i[0]]];
  return s;
}
var kO = new pJ("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: mJ,
  construct: gJ
}), yJ = ir, vJ = Object.prototype.hasOwnProperty;
function _J(e) {
  if (e === null) return !0;
  var t, r = e;
  for (t in r)
    if (vJ.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
function bJ(e) {
  return e !== null ? e : {};
}
var DO = new yJ("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: _J,
  construct: bJ
}), Gy = TO.extend({
  implicit: [
    CO,
    AO
  ],
  explicit: [
    IO,
    NO,
    kO,
    DO
  ]
}), Oi = Gr, LO = oc, EJ = vY, wJ = Gy, ei = Object.prototype.hasOwnProperty, cu = 1, FO = 2, jO = 3, lu = 4, Gp = 1, SJ = 2, Cw = 3, xJ = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, RJ = /[\x85\u2028\u2029]/, $J = /[,\[\]\{\}]/, UO = /^(?:!|!!|![a-z\-]+!)$/i, MO = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Aw(e) {
  return Object.prototype.toString.call(e);
}
function tn(e) {
  return e === 10 || e === 13;
}
function Fi(e) {
  return e === 9 || e === 32;
}
function ur(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Rs(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function TJ(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function OJ(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function PJ(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function Iw(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function CJ(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var HO = new Array(256), qO = new Array(256);
for (var ds = 0; ds < 256; ds++)
  HO[ds] = Iw(ds) ? 1 : 0, qO[ds] = Iw(ds);
function AJ(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || wJ, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function BO(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = EJ(r), new LO(t, r);
}
function pe(e, t) {
  throw BO(e, t);
}
function uu(e, t) {
  e.onWarning && e.onWarning.call(null, BO(e, t));
}
var Nw = {
  YAML: function(t, r, n) {
    var i, s, o;
    t.version !== null && pe(t, "duplication of %YAML directive"), n.length !== 1 && pe(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && pe(t, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && pe(t, "unacceptable YAML version of the document"), t.version = n[0], t.checkLineBreaks = o < 2, o !== 1 && o !== 2 && uu(t, "unsupported YAML version of the document");
  },
  TAG: function(t, r, n) {
    var i, s;
    n.length !== 2 && pe(t, "TAG directive accepts exactly two arguments"), i = n[0], s = n[1], UO.test(i) || pe(t, "ill-formed tag handle (first argument) of the TAG directive"), ei.call(t.tagMap, i) && pe(t, 'there is a previously declared suffix for "' + i + '" tag handle'), MO.test(s) || pe(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      pe(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[i] = s;
  }
};
function Yn(e, t, r, n) {
  var i, s, o, a;
  if (t < r) {
    if (a = e.input.slice(t, r), n)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || pe(e, "expected valid JSON character");
    else xJ.test(a) && pe(e, "the stream contains non-printable characters");
    e.result += a;
  }
}
function kw(e, t, r, n) {
  var i, s, o, a;
  for (Oi.isObject(r) || pe(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), o = 0, a = i.length; o < a; o += 1)
    s = i[o], ei.call(t, s) || (t[s] = r[s], n[s] = !0);
}
function $s(e, t, r, n, i, s, o, a, c) {
  var u, l;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, l = i.length; u < l; u += 1)
      Array.isArray(i[u]) && pe(e, "nested arrays are not supported inside keys"), typeof i == "object" && Aw(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && Aw(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (u = 0, l = s.length; u < l; u += 1)
        kw(e, t, s[u], r);
    else
      kw(e, t, s, r);
  else
    !e.json && !ei.call(r, i) && ei.call(t, i) && (e.line = o || e.line, e.lineStart = a || e.lineStart, e.position = c || e.position, pe(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[i] = s, delete r[i];
  return t;
}
function Wy(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : pe(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function ht(e, t, r) {
  for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Fi(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (tn(i))
      for (Wy(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && e.lineIndent < r && uu(e, "deficient indentation"), n;
}
function Sf(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || ur(r)));
}
function Ky(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Oi.repeat(`
`, t - 1));
}
function IJ(e, t, r) {
  var n, i, s, o, a, c, u, l, f = e.kind, m = e.result, p;
  if (p = e.input.charCodeAt(e.position), ur(p) || Rs(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = e.input.charCodeAt(e.position + 1), ur(i) || r && Rs(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = o = e.position, a = !1; p !== 0; ) {
    if (p === 58) {
      if (i = e.input.charCodeAt(e.position + 1), ur(i) || r && Rs(i))
        break;
    } else if (p === 35) {
      if (n = e.input.charCodeAt(e.position - 1), ur(n))
        break;
    } else {
      if (e.position === e.lineStart && Sf(e) || r && Rs(p))
        break;
      if (tn(p))
        if (c = e.line, u = e.lineStart, l = e.lineIndent, ht(e, !1, -1), e.lineIndent >= t) {
          a = !0, p = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = c, e.lineStart = u, e.lineIndent = l;
          break;
        }
    }
    a && (Yn(e, s, o, !1), Ky(e, e.line - c), s = o = e.position, a = !1), Fi(p) || (o = e.position + 1), p = e.input.charCodeAt(++e.position);
  }
  return Yn(e, s, o, !1), e.result ? !0 : (e.kind = f, e.result = m, !1);
}
function NJ(e, t) {
  var r, n, i;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = i = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (Yn(e, n, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        n = e.position, e.position++, i = e.position;
      else
        return !0;
    else tn(r) ? (Yn(e, n, i, !0), Ky(e, ht(e, !1, t)), n = i = e.position) : e.position === e.lineStart && Sf(e) ? pe(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  pe(e, "unexpected end of the stream within a single quoted scalar");
}
function kJ(e, t) {
  var r, n, i, s, o, a;
  if (a = e.input.charCodeAt(e.position), a !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = n = e.position; (a = e.input.charCodeAt(e.position)) !== 0; ) {
    if (a === 34)
      return Yn(e, r, e.position, !0), e.position++, !0;
    if (a === 92) {
      if (Yn(e, r, e.position, !0), a = e.input.charCodeAt(++e.position), tn(a))
        ht(e, !1, t);
      else if (a < 256 && HO[a])
        e.result += qO[a], e.position++;
      else if ((o = OJ(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = e.input.charCodeAt(++e.position), (o = TJ(a)) >= 0 ? s = (s << 4) + o : pe(e, "expected hexadecimal character");
        e.result += CJ(s), e.position++;
      } else
        pe(e, "unknown escape sequence");
      r = n = e.position;
    } else tn(a) ? (Yn(e, r, n, !0), Ky(e, ht(e, !1, t)), r = n = e.position) : e.position === e.lineStart && Sf(e) ? pe(e, "unexpected end of the document within a double quoted scalar") : (e.position++, n = e.position);
  }
  pe(e, "unexpected end of the stream within a double quoted scalar");
}
function DJ(e, t) {
  var r = !0, n, i, s, o = e.tag, a, c = e.anchor, u, l, f, m, p, d = /* @__PURE__ */ Object.create(null), h, _, g, v;
  if (v = e.input.charCodeAt(e.position), v === 91)
    l = 93, p = !1, a = [];
  else if (v === 123)
    l = 125, p = !0, a = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), v = e.input.charCodeAt(++e.position); v !== 0; ) {
    if (ht(e, !0, t), v = e.input.charCodeAt(e.position), v === l)
      return e.position++, e.tag = o, e.anchor = c, e.kind = p ? "mapping" : "sequence", e.result = a, !0;
    r ? v === 44 && pe(e, "expected the node content, but found ','") : pe(e, "missed comma between flow collection entries"), _ = h = g = null, f = m = !1, v === 63 && (u = e.input.charCodeAt(e.position + 1), ur(u) && (f = m = !0, e.position++, ht(e, !0, t))), n = e.line, i = e.lineStart, s = e.position, Js(e, t, cu, !1, !0), _ = e.tag, h = e.result, ht(e, !0, t), v = e.input.charCodeAt(e.position), (m || e.line === n) && v === 58 && (f = !0, v = e.input.charCodeAt(++e.position), ht(e, !0, t), Js(e, t, cu, !1, !0), g = e.result), p ? $s(e, a, d, _, h, g, n, i, s) : f ? a.push($s(e, null, d, _, h, g, n, i, s)) : a.push(h), ht(e, !0, t), v = e.input.charCodeAt(e.position), v === 44 ? (r = !0, v = e.input.charCodeAt(++e.position)) : r = !1;
  }
  pe(e, "unexpected end of the stream within a flow collection");
}
function LJ(e, t) {
  var r, n, i = Gp, s = !1, o = !1, a = t, c = 0, u = !1, l, f;
  if (f = e.input.charCodeAt(e.position), f === 124)
    n = !1;
  else if (f === 62)
    n = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (f = e.input.charCodeAt(++e.position), f === 43 || f === 45)
      Gp === i ? i = f === 43 ? Cw : SJ : pe(e, "repeat of a chomping mode identifier");
    else if ((l = PJ(f)) >= 0)
      l === 0 ? pe(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? pe(e, "repeat of an indentation width identifier") : (a = t + l - 1, o = !0);
    else
      break;
  if (Fi(f)) {
    do
      f = e.input.charCodeAt(++e.position);
    while (Fi(f));
    if (f === 35)
      do
        f = e.input.charCodeAt(++e.position);
      while (!tn(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (Wy(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position); (!o || e.lineIndent < a) && f === 32; )
      e.lineIndent++, f = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > a && (a = e.lineIndent), tn(f)) {
      c++;
      continue;
    }
    if (e.lineIndent < a) {
      i === Cw ? e.result += Oi.repeat(`
`, s ? 1 + c : c) : i === Gp && s && (e.result += `
`);
      break;
    }
    for (n ? Fi(f) ? (u = !0, e.result += Oi.repeat(`
`, s ? 1 + c : c)) : u ? (u = !1, e.result += Oi.repeat(`
`, c + 1)) : c === 0 ? s && (e.result += " ") : e.result += Oi.repeat(`
`, c) : e.result += Oi.repeat(`
`, s ? 1 + c : c), s = !0, o = !0, c = 0, r = e.position; !tn(f) && f !== 0; )
      f = e.input.charCodeAt(++e.position);
    Yn(e, r, e.position, !1);
  }
  return !0;
}
function Dw(e, t) {
  var r, n = e.tag, i = e.anchor, s = [], o, a = !1, c;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), c = e.input.charCodeAt(e.position); c !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, pe(e, "tab characters must not be used in indentation")), !(c !== 45 || (o = e.input.charCodeAt(e.position + 1), !ur(o)))); ) {
    if (a = !0, e.position++, ht(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), c = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, Js(e, t, jO, !1, !0), s.push(e.result), ht(e, !0, -1), c = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && c !== 0)
      pe(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return a ? (e.tag = n, e.anchor = i, e.kind = "sequence", e.result = s, !0) : !1;
}
function FJ(e, t, r) {
  var n, i, s, o, a, c, u = e.tag, l = e.anchor, f = {}, m = /* @__PURE__ */ Object.create(null), p = null, d = null, h = null, _ = !1, g = !1, v;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = f), v = e.input.charCodeAt(e.position); v !== 0; ) {
    if (!_ && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, pe(e, "tab characters must not be used in indentation")), n = e.input.charCodeAt(e.position + 1), s = e.line, (v === 63 || v === 58) && ur(n))
      v === 63 ? (_ && ($s(e, f, m, p, d, null, o, a, c), p = d = h = null), g = !0, _ = !0, i = !0) : _ ? (_ = !1, i = !0) : pe(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, v = n;
    else {
      if (o = e.line, a = e.lineStart, c = e.position, !Js(e, r, FO, !1, !0))
        break;
      if (e.line === s) {
        for (v = e.input.charCodeAt(e.position); Fi(v); )
          v = e.input.charCodeAt(++e.position);
        if (v === 58)
          v = e.input.charCodeAt(++e.position), ur(v) || pe(e, "a whitespace character is expected after the key-value separator within a block mapping"), _ && ($s(e, f, m, p, d, null, o, a, c), p = d = h = null), g = !0, _ = !1, i = !1, p = e.tag, d = e.result;
        else if (g)
          pe(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = u, e.anchor = l, !0;
      } else if (g)
        pe(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = u, e.anchor = l, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (_ && (o = e.line, a = e.lineStart, c = e.position), Js(e, t, lu, !0, i) && (_ ? d = e.result : h = e.result), _ || ($s(e, f, m, p, d, h, o, a, c), p = d = h = null), ht(e, !0, -1), v = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && v !== 0)
      pe(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return _ && $s(e, f, m, p, d, null, o, a, c), g && (e.tag = u, e.anchor = l, e.kind = "mapping", e.result = f), g;
}
function jJ(e) {
  var t, r = !1, n = !1, i, s, o;
  if (o = e.input.charCodeAt(e.position), o !== 33) return !1;
  if (e.tag !== null && pe(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (r = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (n = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, r) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), o = e.input.charCodeAt(++e.position)) : pe(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !ur(o); )
      o === 33 && (n ? pe(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), UO.test(i) || pe(e, "named tag handle cannot contain such characters"), n = !0, t = e.position + 1)), o = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), $J.test(s) && pe(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !MO.test(s) && pe(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    pe(e, "tag name is malformed: " + s);
  }
  return r ? e.tag = s : ei.call(e.tagMap, i) ? e.tag = e.tagMap[i] + s : i === "!" ? e.tag = "!" + s : i === "!!" ? e.tag = "tag:yaml.org,2002:" + s : pe(e, 'undeclared tag handle "' + i + '"'), !0;
}
function UJ(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38) return !1;
  for (e.anchor !== null && pe(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !ur(r) && !Rs(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && pe(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function MJ(e) {
  var t, r, n;
  if (n = e.input.charCodeAt(e.position), n !== 42) return !1;
  for (n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !ur(n) && !Rs(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && pe(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), ei.call(e.anchorMap, r) || pe(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], ht(e, !0, -1), !0;
}
function Js(e, t, r, n, i) {
  var s, o, a, c = 1, u = !1, l = !1, f, m, p, d, h, _;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = o = a = lu === r || jO === r, n && ht(e, !0, -1) && (u = !0, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)), c === 1)
    for (; jJ(e) || UJ(e); )
      ht(e, !0, -1) ? (u = !0, a = s, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)) : a = !1;
  if (a && (a = u || i), (c === 1 || lu === r) && (cu === r || FO === r ? h = t : h = t + 1, _ = e.position - e.lineStart, c === 1 ? a && (Dw(e, _) || FJ(e, _, h)) || DJ(e, h) ? l = !0 : (o && LJ(e, h) || NJ(e, h) || kJ(e, h) ? l = !0 : MJ(e) ? (l = !0, (e.tag !== null || e.anchor !== null) && pe(e, "alias node should not have any properties")) : IJ(e, h, cu === r) && (l = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : c === 0 && (l = a && Dw(e, _))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && pe(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), f = 0, m = e.implicitTypes.length; f < m; f += 1)
      if (d = e.implicitTypes[f], d.resolve(e.result)) {
        e.result = d.construct(e.result), e.tag = d.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (ei.call(e.typeMap[e.kind || "fallback"], e.tag))
      d = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (d = null, p = e.typeMap.multi[e.kind || "fallback"], f = 0, m = p.length; f < m; f += 1)
        if (e.tag.slice(0, p[f].tag.length) === p[f].tag) {
          d = p[f];
          break;
        }
    d || pe(e, "unknown tag !<" + e.tag + ">"), e.result !== null && d.kind !== e.kind && pe(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + d.kind + '", not "' + e.kind + '"'), d.resolve(e.result, e.tag) ? (e.result = d.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : pe(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || l;
}
function HJ(e) {
  var t = e.position, r, n, i, s = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (ht(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = e.input.charCodeAt(++e.position), r = e.position; o !== 0 && !ur(o); )
      o = e.input.charCodeAt(++e.position);
    for (n = e.input.slice(r, e.position), i = [], n.length < 1 && pe(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; Fi(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !tn(o));
        break;
      }
      if (tn(o)) break;
      for (r = e.position; o !== 0 && !ur(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(r, e.position));
    }
    o !== 0 && Wy(e), ei.call(Nw, n) ? Nw[n](e, n, i) : uu(e, 'unknown document directive "' + n + '"');
  }
  if (ht(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, ht(e, !0, -1)) : s && pe(e, "directives end mark is expected"), Js(e, e.lineIndent - 1, lu, !1, !0), ht(e, !0, -1), e.checkLineBreaks && RJ.test(e.input.slice(t, e.position)) && uu(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Sf(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, ht(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    pe(e, "end of the stream or a document separator is expected");
  else
    return;
}
function zO(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new AJ(e, t), n = e.indexOf("\0");
  for (n !== -1 && (r.position = n, pe(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    HJ(r);
  return r.documents;
}
function qJ(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var n = zO(e, r);
  if (typeof t != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    t(n[i]);
}
function BJ(e, t) {
  var r = zO(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new LO("expected a single document in the stream, but found more");
  }
}
zy.loadAll = qJ;
zy.load = BJ;
var VO = {}, xf = Gr, ac = oc, zJ = Gy, GO = Object.prototype.toString, WO = Object.prototype.hasOwnProperty, Yy = 65279, VJ = 9, Ea = 10, GJ = 13, WJ = 32, KJ = 33, YJ = 34, Xh = 35, JJ = 37, XJ = 38, ZJ = 39, QJ = 42, KO = 44, eX = 45, fu = 58, tX = 61, rX = 62, nX = 63, iX = 64, YO = 91, JO = 93, sX = 96, XO = 123, oX = 124, ZO = 125, Kt = {};
Kt[0] = "\\0";
Kt[7] = "\\a";
Kt[8] = "\\b";
Kt[9] = "\\t";
Kt[10] = "\\n";
Kt[11] = "\\v";
Kt[12] = "\\f";
Kt[13] = "\\r";
Kt[27] = "\\e";
Kt[34] = '\\"';
Kt[92] = "\\\\";
Kt[133] = "\\N";
Kt[160] = "\\_";
Kt[8232] = "\\L";
Kt[8233] = "\\P";
var aX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], cX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function lX(e, t) {
  var r, n, i, s, o, a, c;
  if (t === null) return {};
  for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
    o = n[i], a = String(t[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), c = e.compiledTypeMap.fallback[o], c && WO.call(c.styleAliases, a) && (a = c.styleAliases[a]), r[o] = a;
  return r;
}
function uX(e) {
  var t, r, n;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", n = 2;
  else if (e <= 65535)
    r = "u", n = 4;
  else if (e <= 4294967295)
    r = "U", n = 8;
  else
    throw new ac("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + xf.repeat("0", n - t.length) + t;
}
var fX = 1, wa = 2;
function dX(e) {
  this.schema = e.schema || zJ, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = xf.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = lX(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? wa : fX, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function Lw(e, t) {
  for (var r = xf.repeat(" ", t), n = 0, i = -1, s = "", o, a = e.length; n < a; )
    i = e.indexOf(`
`, n), i === -1 ? (o = e.slice(n), n = a) : (o = e.slice(n, i + 1), n = i + 1), o.length && o !== `
` && (s += r), s += o;
  return s;
}
function Zh(e, t) {
  return `
` + xf.repeat(" ", e.indent * t);
}
function pX(e, t) {
  var r, n, i;
  for (r = 0, n = e.implicitTypes.length; r < n; r += 1)
    if (i = e.implicitTypes[r], i.resolve(t))
      return !0;
  return !1;
}
function du(e) {
  return e === WJ || e === VJ;
}
function Sa(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== Yy || 65536 <= e && e <= 1114111;
}
function Fw(e) {
  return Sa(e) && e !== Yy && e !== GJ && e !== Ea;
}
function jw(e, t, r) {
  var n = Fw(e), i = n && !du(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && e !== KO && e !== YO && e !== JO && e !== XO && e !== ZO) && e !== Xh && !(t === fu && !i) || Fw(t) && !du(t) && e === Xh || t === fu && i
  );
}
function hX(e) {
  return Sa(e) && e !== Yy && !du(e) && e !== eX && e !== nX && e !== fu && e !== KO && e !== YO && e !== JO && e !== XO && e !== ZO && e !== Xh && e !== XJ && e !== QJ && e !== KJ && e !== oX && e !== tX && e !== rX && e !== ZJ && e !== YJ && e !== JJ && e !== iX && e !== sX;
}
function mX(e) {
  return !du(e) && e !== fu;
}
function Vo(e, t) {
  var r = e.charCodeAt(t), n;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (n = e.charCodeAt(t + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
function QO(e) {
  var t = /^\n* /;
  return t.test(e);
}
var eP = 1, Qh = 2, tP = 3, rP = 4, Es = 5;
function gX(e, t, r, n, i, s, o, a) {
  var c, u = 0, l = null, f = !1, m = !1, p = n !== -1, d = -1, h = hX(Vo(e, 0)) && mX(Vo(e, e.length - 1));
  if (t || o)
    for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) {
      if (u = Vo(e, c), !Sa(u))
        return Es;
      h = h && jw(u, l, a), l = u;
    }
  else {
    for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) {
      if (u = Vo(e, c), u === Ea)
        f = !0, p && (m = m || // Foldable line = too long, and not more-indented.
        c - d - 1 > n && e[d + 1] !== " ", d = c);
      else if (!Sa(u))
        return Es;
      h = h && jw(u, l, a), l = u;
    }
    m = m || p && c - d - 1 > n && e[d + 1] !== " ";
  }
  return !f && !m ? h && !o && !i(e) ? eP : s === wa ? Es : Qh : r > 9 && QO(e) ? Es : o ? s === wa ? Es : Qh : m ? rP : tP;
}
function yX(e, t, r, n, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === wa ? '""' : "''";
    if (!e.noCompatMode && (aX.indexOf(t) !== -1 || cX.test(t)))
      return e.quotingType === wa ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, r), o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), a = n || e.flowLevel > -1 && r >= e.flowLevel;
    function c(u) {
      return pX(e, u);
    }
    switch (gX(
      t,
      a,
      e.indent,
      o,
      c,
      e.quotingType,
      e.forceQuotes && !n,
      i
    )) {
      case eP:
        return t;
      case Qh:
        return "'" + t.replace(/'/g, "''") + "'";
      case tP:
        return "|" + Uw(t, e.indent) + Mw(Lw(t, s));
      case rP:
        return ">" + Uw(t, e.indent) + Mw(Lw(vX(t, o), s));
      case Es:
        return '"' + _X(t) + '"';
      default:
        throw new ac("impossible error: invalid scalar style");
    }
  }();
}
function Uw(e, t) {
  var r = QO(e) ? String(t) : "", n = e[e.length - 1] === `
`, i = n && (e[e.length - 2] === `
` || e === `
`), s = i ? "+" : n ? "" : "-";
  return r + s + `
`;
}
function Mw(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function vX(e, t) {
  for (var r = /(\n+)([^\n]*)/g, n = function() {
    var u = e.indexOf(`
`);
    return u = u !== -1 ? u : e.length, r.lastIndex = u, Hw(e.slice(0, u), t);
  }(), i = e[0] === `
` || e[0] === " ", s, o; o = r.exec(e); ) {
    var a = o[1], c = o[2];
    s = c[0] === " ", n += a + (!i && !s && c !== "" ? `
` : "") + Hw(c, t), i = s;
  }
  return n;
}
function Hw(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var r = / [^ ]/g, n, i = 0, s, o = 0, a = 0, c = ""; n = r.exec(e); )
    a = n.index, a - i > t && (s = o > i ? o : a, c += `
` + e.slice(i, s), i = s + 1), o = a;
  return c += `
`, e.length - i > t && o > i ? c += e.slice(i, o) + `
` + e.slice(o + 1) : c += e.slice(i), c.slice(1);
}
function _X(e) {
  for (var t = "", r = 0, n, i = 0; i < e.length; r >= 65536 ? i += 2 : i++)
    r = Vo(e, i), n = Kt[r], !n && Sa(r) ? (t += e[i], r >= 65536 && (t += e[i + 1])) : t += n || uX(r);
  return t;
}
function bX(e, t, r) {
  var n = "", i = e.tag, s, o, a;
  for (s = 0, o = r.length; s < o; s += 1)
    a = r[s], e.replacer && (a = e.replacer.call(r, String(s), a)), (En(e, t, a, !1, !1) || typeof a > "u" && En(e, t, null, !1, !1)) && (n !== "" && (n += "," + (e.condenseFlow ? "" : " ")), n += e.dump);
  e.tag = i, e.dump = "[" + n + "]";
}
function qw(e, t, r, n) {
  var i = "", s = e.tag, o, a, c;
  for (o = 0, a = r.length; o < a; o += 1)
    c = r[o], e.replacer && (c = e.replacer.call(r, String(o), c)), (En(e, t + 1, c, !0, !0, !1, !0) || typeof c > "u" && En(e, t + 1, null, !0, !0, !1, !0)) && ((!n || i !== "") && (i += Zh(e, t)), e.dump && Ea === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = s, e.dump = i || "[]";
}
function EX(e, t, r) {
  var n = "", i = e.tag, s = Object.keys(r), o, a, c, u, l;
  for (o = 0, a = s.length; o < a; o += 1)
    l = "", n !== "" && (l += ", "), e.condenseFlow && (l += '"'), c = s[o], u = r[c], e.replacer && (u = e.replacer.call(r, c, u)), En(e, t, c, !1, !1) && (e.dump.length > 1024 && (l += "? "), l += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), En(e, t, u, !1, !1) && (l += e.dump, n += l));
  e.tag = i, e.dump = "{" + n + "}";
}
function wX(e, t, r, n) {
  var i = "", s = e.tag, o = Object.keys(r), a, c, u, l, f, m;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new ac("sortKeys must be a boolean or a function");
  for (a = 0, c = o.length; a < c; a += 1)
    m = "", (!n || i !== "") && (m += Zh(e, t)), u = o[a], l = r[u], e.replacer && (l = e.replacer.call(r, u, l)), En(e, t + 1, u, !0, !0, !0) && (f = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, f && (e.dump && Ea === e.dump.charCodeAt(0) ? m += "?" : m += "? "), m += e.dump, f && (m += Zh(e, t)), En(e, t + 1, l, !0, f) && (e.dump && Ea === e.dump.charCodeAt(0) ? m += ":" : m += ": ", m += e.dump, i += m));
  e.tag = s, e.dump = i || "{}";
}
function Bw(e, t, r) {
  var n, i, s, o, a, c;
  for (i = r ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (a = i[s], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof t == "object" && t instanceof a.instanceOf) && (!a.predicate || a.predicate(t))) {
      if (r ? a.multi && a.representName ? e.tag = a.representName(t) : e.tag = a.tag : e.tag = "?", a.represent) {
        if (c = e.styleMap[a.tag] || a.defaultStyle, GO.call(a.represent) === "[object Function]")
          n = a.represent(t, c);
        else if (WO.call(a.represent, c))
          n = a.represent[c](t, c);
        else
          throw new ac("!<" + a.tag + '> tag resolver accepts not "' + c + '" style');
        e.dump = n;
      }
      return !0;
    }
  return !1;
}
function En(e, t, r, n, i, s, o) {
  e.tag = null, e.dump = r, Bw(e, r, !1) || Bw(e, r, !0);
  var a = GO.call(e.dump), c = n, u;
  n && (n = e.flowLevel < 0 || e.flowLevel > t);
  var l = a === "[object Object]" || a === "[object Array]", f, m;
  if (l && (f = e.duplicates.indexOf(r), m = f !== -1), (e.tag !== null && e.tag !== "?" || m || e.indent !== 2 && t > 0) && (i = !1), m && e.usedDuplicates[f])
    e.dump = "*ref_" + f;
  else {
    if (l && m && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0), a === "[object Object]")
      n && Object.keys(e.dump).length !== 0 ? (wX(e, t, e.dump, i), m && (e.dump = "&ref_" + f + e.dump)) : (EX(e, t, e.dump), m && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object Array]")
      n && e.dump.length !== 0 ? (e.noArrayIndent && !o && t > 0 ? qw(e, t - 1, e.dump, i) : qw(e, t, e.dump, i), m && (e.dump = "&ref_" + f + e.dump)) : (bX(e, t, e.dump), m && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object String]")
      e.tag !== "?" && yX(e, e.dump, t, s, c);
    else {
      if (a === "[object Undefined]")
        return !1;
      if (e.skipInvalid) return !1;
      throw new ac("unacceptable kind of an object to dump " + a);
    }
    e.tag !== null && e.tag !== "?" && (u = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", e.dump = u + " " + e.dump);
  }
  return !0;
}
function SX(e, t) {
  var r = [], n = [], i, s;
  for (em(e, r, n), i = 0, s = n.length; i < s; i += 1)
    t.duplicates.push(r[n[i]]);
  t.usedDuplicates = new Array(s);
}
function em(e, t, r) {
  var n, i, s;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, s = e.length; i < s; i += 1)
        em(e[i], t, r);
    else
      for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
        em(e[n[i]], t, r);
}
function xX(e, t) {
  t = t || {};
  var r = new dX(t);
  r.noRefs || SX(e, r);
  var n = e;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), En(r, 0, n, !0, !0) ? r.dump + `
` : "";
}
VO.dump = xX;
var nP = zy, RX = VO;
function Jy(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
jt.Type = ir;
jt.Schema = gO;
jt.FAILSAFE_SCHEMA = bO;
jt.JSON_SCHEMA = $O;
jt.CORE_SCHEMA = TO;
jt.DEFAULT_SCHEMA = Gy;
jt.load = nP.load;
jt.loadAll = nP.loadAll;
jt.dump = RX.dump;
jt.YAMLException = oc;
jt.types = {
  binary: IO,
  float: RO,
  map: _O,
  null: EO,
  pairs: kO,
  set: DO,
  timestamp: CO,
  bool: wO,
  int: SO,
  merge: AO,
  omap: NO,
  seq: vO,
  str: yO
};
jt.safeLoad = Jy("safeLoad", "load");
jt.safeLoadAll = Jy("safeLoadAll", "loadAll");
jt.safeDump = Jy("safeDump", "dump");
var Rf = {};
Object.defineProperty(Rf, "__esModule", { value: !0 });
Rf.Lazy = void 0;
class $X {
  constructor(t) {
    this._value = null, this.creator = t;
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null)
      return this._value;
    const t = this.creator();
    return this.value = t, t;
  }
  set value(t) {
    this._value = t, this.creator = null;
  }
}
Rf.Lazy = $X;
var cc = {}, pu = { exports: {} };
pu.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", c = "[object Array]", u = "[object AsyncFunction]", l = "[object Boolean]", f = "[object Date]", m = "[object Error]", p = "[object Function]", d = "[object GeneratorFunction]", h = "[object Map]", _ = "[object Number]", g = "[object Null]", v = "[object Object]", y = "[object Promise]", E = "[object Proxy]", R = "[object RegExp]", w = "[object Set]", C = "[object String]", V = "[object Symbol]", b = "[object Undefined]", F = "[object WeakMap]", H = "[object ArrayBuffer]", q = "[object DataView]", $ = "[object Float32Array]", x = "[object Float64Array]", A = "[object Int8Array]", P = "[object Int16Array]", D = "[object Int32Array]", I = "[object Uint8Array]", L = "[object Uint8ClampedArray]", j = "[object Uint16Array]", k = "[object Uint32Array]", U = /[\\^$.*+?()[\]{}|]/g, M = /^\[object .+?Constructor\]$/, T = /^(?:0|[1-9]\d*)$/, N = {};
  N[$] = N[x] = N[A] = N[P] = N[D] = N[I] = N[L] = N[j] = N[k] = !0, N[a] = N[c] = N[H] = N[l] = N[q] = N[f] = N[m] = N[p] = N[h] = N[_] = N[v] = N[R] = N[w] = N[C] = N[F] = !1;
  var G = typeof me == "object" && me && me.Object === Object && me, O = typeof self == "object" && self && self.Object === Object && self, S = G || O || Function("return this")(), W = t && !t.nodeType && t, z = W && !0 && e && !e.nodeType && e, Q = z && z.exports === W, K = Q && G.process, X = function() {
    try {
      return K && K.binding && K.binding("util");
    } catch {
    }
  }(), J = X && X.isTypedArray;
  function re(B, Y) {
    for (var te = -1, ce = B == null ? 0 : B.length, Ve = 0, be = []; ++te < ce; ) {
      var rt = B[te];
      Y(rt, te, B) && (be[Ve++] = rt);
    }
    return be;
  }
  function fe(B, Y) {
    for (var te = -1, ce = Y.length, Ve = B.length; ++te < ce; )
      B[Ve + te] = Y[te];
    return B;
  }
  function ee(B, Y) {
    for (var te = -1, ce = B == null ? 0 : B.length; ++te < ce; )
      if (Y(B[te], te, B))
        return !0;
    return !1;
  }
  function le(B, Y) {
    for (var te = -1, ce = Array(B); ++te < B; )
      ce[te] = Y(te);
    return ce;
  }
  function Se(B) {
    return function(Y) {
      return B(Y);
    };
  }
  function ye(B, Y) {
    return B.has(Y);
  }
  function ve(B, Y) {
    return B == null ? void 0 : B[Y];
  }
  function qe(B) {
    var Y = -1, te = Array(B.size);
    return B.forEach(function(ce, Ve) {
      te[++Y] = [Ve, ce];
    }), te;
  }
  function Ae(B, Y) {
    return function(te) {
      return B(Y(te));
    };
  }
  function $t(B) {
    var Y = -1, te = Array(B.size);
    return B.forEach(function(ce) {
      te[++Y] = ce;
    }), te;
  }
  var Rn = Array.prototype, Le = Function.prototype, Ut = Object.prototype, br = S["__core-js_shared__"], Ne = Le.toString, je = Ut.hasOwnProperty, ho = function() {
    var B = /[^.]+$/.exec(br && br.keys && br.keys.IE_PROTO || "");
    return B ? "Symbol(src)_1." + B : "";
  }(), Mt = Ut.toString, dr = RegExp(
    "^" + Ne.call(je).replace(U, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), mo = Q ? S.Buffer : void 0, We = S.Symbol, Qi = S.Uint8Array, si = Ut.propertyIsEnumerable, _t = Rn.splice, Er = We ? We.toStringTag : void 0, dc = Object.getOwnPropertySymbols, $n = mo ? mo.isBuffer : void 0, Yt = Ae(Object.keys, Object), Nr = es(S, "DataView"), Ht = es(S, "Map"), wr = es(S, "Promise"), cn = es(S, "Set"), sr = es(S, "WeakMap"), oi = es(Object, "create"), kf = li(Nr), pc = li(Ht), go = li(wr), hc = li(cn), Df = li(sr), yo = We ? We.prototype : void 0, vo = yo ? yo.valueOf : void 0;
  function ai(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.clear(); ++Y < te; ) {
      var ce = B[Y];
      this.set(ce[0], ce[1]);
    }
  }
  function vP() {
    this.__data__ = oi ? oi(null) : {}, this.size = 0;
  }
  function _P(B) {
    var Y = this.has(B) && delete this.__data__[B];
    return this.size -= Y ? 1 : 0, Y;
  }
  function bP(B) {
    var Y = this.__data__;
    if (oi) {
      var te = Y[B];
      return te === n ? void 0 : te;
    }
    return je.call(Y, B) ? Y[B] : void 0;
  }
  function EP(B) {
    var Y = this.__data__;
    return oi ? Y[B] !== void 0 : je.call(Y, B);
  }
  function wP(B, Y) {
    var te = this.__data__;
    return this.size += this.has(B) ? 0 : 1, te[B] = oi && Y === void 0 ? n : Y, this;
  }
  ai.prototype.clear = vP, ai.prototype.delete = _P, ai.prototype.get = bP, ai.prototype.has = EP, ai.prototype.set = wP;
  function ln(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.clear(); ++Y < te; ) {
      var ce = B[Y];
      this.set(ce[0], ce[1]);
    }
  }
  function SP() {
    this.__data__ = [], this.size = 0;
  }
  function xP(B) {
    var Y = this.__data__, te = gc(Y, B);
    if (te < 0)
      return !1;
    var ce = Y.length - 1;
    return te == ce ? Y.pop() : _t.call(Y, te, 1), --this.size, !0;
  }
  function RP(B) {
    var Y = this.__data__, te = gc(Y, B);
    return te < 0 ? void 0 : Y[te][1];
  }
  function $P(B) {
    return gc(this.__data__, B) > -1;
  }
  function TP(B, Y) {
    var te = this.__data__, ce = gc(te, B);
    return ce < 0 ? (++this.size, te.push([B, Y])) : te[ce][1] = Y, this;
  }
  ln.prototype.clear = SP, ln.prototype.delete = xP, ln.prototype.get = RP, ln.prototype.has = $P, ln.prototype.set = TP;
  function ci(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.clear(); ++Y < te; ) {
      var ce = B[Y];
      this.set(ce[0], ce[1]);
    }
  }
  function OP() {
    this.size = 0, this.__data__ = {
      hash: new ai(),
      map: new (Ht || ln)(),
      string: new ai()
    };
  }
  function PP(B) {
    var Y = yc(this, B).delete(B);
    return this.size -= Y ? 1 : 0, Y;
  }
  function CP(B) {
    return yc(this, B).get(B);
  }
  function AP(B) {
    return yc(this, B).has(B);
  }
  function IP(B, Y) {
    var te = yc(this, B), ce = te.size;
    return te.set(B, Y), this.size += te.size == ce ? 0 : 1, this;
  }
  ci.prototype.clear = OP, ci.prototype.delete = PP, ci.prototype.get = CP, ci.prototype.has = AP, ci.prototype.set = IP;
  function mc(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.__data__ = new ci(); ++Y < te; )
      this.add(B[Y]);
  }
  function NP(B) {
    return this.__data__.set(B, n), this;
  }
  function kP(B) {
    return this.__data__.has(B);
  }
  mc.prototype.add = mc.prototype.push = NP, mc.prototype.has = kP;
  function Tn(B) {
    var Y = this.__data__ = new ln(B);
    this.size = Y.size;
  }
  function DP() {
    this.__data__ = new ln(), this.size = 0;
  }
  function LP(B) {
    var Y = this.__data__, te = Y.delete(B);
    return this.size = Y.size, te;
  }
  function FP(B) {
    return this.__data__.get(B);
  }
  function jP(B) {
    return this.__data__.has(B);
  }
  function UP(B, Y) {
    var te = this.__data__;
    if (te instanceof ln) {
      var ce = te.__data__;
      if (!Ht || ce.length < r - 1)
        return ce.push([B, Y]), this.size = ++te.size, this;
      te = this.__data__ = new ci(ce);
    }
    return te.set(B, Y), this.size = te.size, this;
  }
  Tn.prototype.clear = DP, Tn.prototype.delete = LP, Tn.prototype.get = FP, Tn.prototype.has = jP, Tn.prototype.set = UP;
  function MP(B, Y) {
    var te = vc(B), ce = !te && tC(B), Ve = !te && !ce && Lf(B), be = !te && !ce && !Ve && cv(B), rt = te || ce || Ve || be, bt = rt ? le(B.length, String) : [], Tt = bt.length;
    for (var Je in B)
      je.call(B, Je) && !(rt && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Je == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ve && (Je == "offset" || Je == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      be && (Je == "buffer" || Je == "byteLength" || Je == "byteOffset") || // Skip index properties.
      JP(Je, Tt))) && bt.push(Je);
    return bt;
  }
  function gc(B, Y) {
    for (var te = B.length; te--; )
      if (iv(B[te][0], Y))
        return te;
    return -1;
  }
  function HP(B, Y, te) {
    var ce = Y(B);
    return vc(B) ? ce : fe(ce, te(B));
  }
  function _o(B) {
    return B == null ? B === void 0 ? b : g : Er && Er in Object(B) ? KP(B) : eC(B);
  }
  function ev(B) {
    return bo(B) && _o(B) == a;
  }
  function tv(B, Y, te, ce, Ve) {
    return B === Y ? !0 : B == null || Y == null || !bo(B) && !bo(Y) ? B !== B && Y !== Y : qP(B, Y, te, ce, tv, Ve);
  }
  function qP(B, Y, te, ce, Ve, be) {
    var rt = vc(B), bt = vc(Y), Tt = rt ? c : On(B), Je = bt ? c : On(Y);
    Tt = Tt == a ? v : Tt, Je = Je == a ? v : Je;
    var pr = Tt == v, kr = Je == v, qt = Tt == Je;
    if (qt && Lf(B)) {
      if (!Lf(Y))
        return !1;
      rt = !0, pr = !1;
    }
    if (qt && !pr)
      return be || (be = new Tn()), rt || cv(B) ? rv(B, Y, te, ce, Ve, be) : GP(B, Y, Tt, te, ce, Ve, be);
    if (!(te & i)) {
      var Sr = pr && je.call(B, "__wrapped__"), xr = kr && je.call(Y, "__wrapped__");
      if (Sr || xr) {
        var Pn = Sr ? B.value() : B, un = xr ? Y.value() : Y;
        return be || (be = new Tn()), Ve(Pn, un, te, ce, be);
      }
    }
    return qt ? (be || (be = new Tn()), WP(B, Y, te, ce, Ve, be)) : !1;
  }
  function BP(B) {
    if (!av(B) || ZP(B))
      return !1;
    var Y = sv(B) ? dr : M;
    return Y.test(li(B));
  }
  function zP(B) {
    return bo(B) && ov(B.length) && !!N[_o(B)];
  }
  function VP(B) {
    if (!QP(B))
      return Yt(B);
    var Y = [];
    for (var te in Object(B))
      je.call(B, te) && te != "constructor" && Y.push(te);
    return Y;
  }
  function rv(B, Y, te, ce, Ve, be) {
    var rt = te & i, bt = B.length, Tt = Y.length;
    if (bt != Tt && !(rt && Tt > bt))
      return !1;
    var Je = be.get(B);
    if (Je && be.get(Y))
      return Je == Y;
    var pr = -1, kr = !0, qt = te & s ? new mc() : void 0;
    for (be.set(B, Y), be.set(Y, B); ++pr < bt; ) {
      var Sr = B[pr], xr = Y[pr];
      if (ce)
        var Pn = rt ? ce(xr, Sr, pr, Y, B, be) : ce(Sr, xr, pr, B, Y, be);
      if (Pn !== void 0) {
        if (Pn)
          continue;
        kr = !1;
        break;
      }
      if (qt) {
        if (!ee(Y, function(un, ui) {
          if (!ye(qt, ui) && (Sr === un || Ve(Sr, un, te, ce, be)))
            return qt.push(ui);
        })) {
          kr = !1;
          break;
        }
      } else if (!(Sr === xr || Ve(Sr, xr, te, ce, be))) {
        kr = !1;
        break;
      }
    }
    return be.delete(B), be.delete(Y), kr;
  }
  function GP(B, Y, te, ce, Ve, be, rt) {
    switch (te) {
      case q:
        if (B.byteLength != Y.byteLength || B.byteOffset != Y.byteOffset)
          return !1;
        B = B.buffer, Y = Y.buffer;
      case H:
        return !(B.byteLength != Y.byteLength || !be(new Qi(B), new Qi(Y)));
      case l:
      case f:
      case _:
        return iv(+B, +Y);
      case m:
        return B.name == Y.name && B.message == Y.message;
      case R:
      case C:
        return B == Y + "";
      case h:
        var bt = qe;
      case w:
        var Tt = ce & i;
        if (bt || (bt = $t), B.size != Y.size && !Tt)
          return !1;
        var Je = rt.get(B);
        if (Je)
          return Je == Y;
        ce |= s, rt.set(B, Y);
        var pr = rv(bt(B), bt(Y), ce, Ve, be, rt);
        return rt.delete(B), pr;
      case V:
        if (vo)
          return vo.call(B) == vo.call(Y);
    }
    return !1;
  }
  function WP(B, Y, te, ce, Ve, be) {
    var rt = te & i, bt = nv(B), Tt = bt.length, Je = nv(Y), pr = Je.length;
    if (Tt != pr && !rt)
      return !1;
    for (var kr = Tt; kr--; ) {
      var qt = bt[kr];
      if (!(rt ? qt in Y : je.call(Y, qt)))
        return !1;
    }
    var Sr = be.get(B);
    if (Sr && be.get(Y))
      return Sr == Y;
    var xr = !0;
    be.set(B, Y), be.set(Y, B);
    for (var Pn = rt; ++kr < Tt; ) {
      qt = bt[kr];
      var un = B[qt], ui = Y[qt];
      if (ce)
        var lv = rt ? ce(ui, un, qt, Y, B, be) : ce(un, ui, qt, B, Y, be);
      if (!(lv === void 0 ? un === ui || Ve(un, ui, te, ce, be) : lv)) {
        xr = !1;
        break;
      }
      Pn || (Pn = qt == "constructor");
    }
    if (xr && !Pn) {
      var _c = B.constructor, bc = Y.constructor;
      _c != bc && "constructor" in B && "constructor" in Y && !(typeof _c == "function" && _c instanceof _c && typeof bc == "function" && bc instanceof bc) && (xr = !1);
    }
    return be.delete(B), be.delete(Y), xr;
  }
  function nv(B) {
    return HP(B, iC, YP);
  }
  function yc(B, Y) {
    var te = B.__data__;
    return XP(Y) ? te[typeof Y == "string" ? "string" : "hash"] : te.map;
  }
  function es(B, Y) {
    var te = ve(B, Y);
    return BP(te) ? te : void 0;
  }
  function KP(B) {
    var Y = je.call(B, Er), te = B[Er];
    try {
      B[Er] = void 0;
      var ce = !0;
    } catch {
    }
    var Ve = Mt.call(B);
    return ce && (Y ? B[Er] = te : delete B[Er]), Ve;
  }
  var YP = dc ? function(B) {
    return B == null ? [] : (B = Object(B), re(dc(B), function(Y) {
      return si.call(B, Y);
    }));
  } : sC, On = _o;
  (Nr && On(new Nr(new ArrayBuffer(1))) != q || Ht && On(new Ht()) != h || wr && On(wr.resolve()) != y || cn && On(new cn()) != w || sr && On(new sr()) != F) && (On = function(B) {
    var Y = _o(B), te = Y == v ? B.constructor : void 0, ce = te ? li(te) : "";
    if (ce)
      switch (ce) {
        case kf:
          return q;
        case pc:
          return h;
        case go:
          return y;
        case hc:
          return w;
        case Df:
          return F;
      }
    return Y;
  });
  function JP(B, Y) {
    return Y = Y ?? o, !!Y && (typeof B == "number" || T.test(B)) && B > -1 && B % 1 == 0 && B < Y;
  }
  function XP(B) {
    var Y = typeof B;
    return Y == "string" || Y == "number" || Y == "symbol" || Y == "boolean" ? B !== "__proto__" : B === null;
  }
  function ZP(B) {
    return !!ho && ho in B;
  }
  function QP(B) {
    var Y = B && B.constructor, te = typeof Y == "function" && Y.prototype || Ut;
    return B === te;
  }
  function eC(B) {
    return Mt.call(B);
  }
  function li(B) {
    if (B != null) {
      try {
        return Ne.call(B);
      } catch {
      }
      try {
        return B + "";
      } catch {
      }
    }
    return "";
  }
  function iv(B, Y) {
    return B === Y || B !== B && Y !== Y;
  }
  var tC = ev(/* @__PURE__ */ function() {
    return arguments;
  }()) ? ev : function(B) {
    return bo(B) && je.call(B, "callee") && !si.call(B, "callee");
  }, vc = Array.isArray;
  function rC(B) {
    return B != null && ov(B.length) && !sv(B);
  }
  var Lf = $n || oC;
  function nC(B, Y) {
    return tv(B, Y);
  }
  function sv(B) {
    if (!av(B))
      return !1;
    var Y = _o(B);
    return Y == p || Y == d || Y == u || Y == E;
  }
  function ov(B) {
    return typeof B == "number" && B > -1 && B % 1 == 0 && B <= o;
  }
  function av(B) {
    var Y = typeof B;
    return B != null && (Y == "object" || Y == "function");
  }
  function bo(B) {
    return B != null && typeof B == "object";
  }
  var cv = J ? Se(J) : zP;
  function iC(B) {
    return rC(B) ? MP(B) : VP(B);
  }
  function sC() {
    return [];
  }
  function oC() {
    return !1;
  }
  e.exports = nC;
})(pu, pu.exports);
var TX = pu.exports;
Object.defineProperty(cc, "__esModule", { value: !0 });
cc.DownloadedUpdateHelper = void 0;
cc.createTempUpdateFile = IX;
const OX = Gi, PX = Ye, zw = TX, wi = ni, ra = we;
class CX {
  constructor(t) {
    this.cacheDir = t, this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, this._downloadedFileInfo = null;
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return ra.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(t, r, n, i) {
    if (this.versionInfo != null && this.file === t && this.fileInfo != null)
      return zw(this.versionInfo, r) && zw(this.fileInfo.info, n.info) && await (0, wi.pathExists)(t) ? t : null;
    const s = await this.getValidCachedUpdateFile(n, i);
    return s === null ? null : (i.info(`Update has already been downloaded to ${t}).`), this._file = s, s);
  }
  async setDownloadedFile(t, r, n, i, s, o) {
    this._file = t, this._packageFile = r, this.versionInfo = n, this.fileInfo = i, this._downloadedFileInfo = {
      fileName: s,
      sha512: i.info.sha512,
      isAdminRightsRequired: i.info.isAdminRightsRequired === !0
    }, o && await (0, wi.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
  }
  async clear() {
    this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, wi.emptyDir)(this.cacheDirForPendingUpdate);
    } catch {
    }
  }
  /**
   * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
   * @param fileInfo
   * @param logger
   */
  async getValidCachedUpdateFile(t, r) {
    const n = this.getUpdateInfoFile();
    if (!await (0, wi.pathExists)(n))
      return null;
    let s;
    try {
      s = await (0, wi.readJson)(n);
    } catch (u) {
      let l = "No cached update info available";
      return u.code !== "ENOENT" && (await this.cleanCacheDirForPendingUpdate(), l += ` (error on read: ${u.message})`), r.info(l), null;
    }
    if (!((s == null ? void 0 : s.fileName) !== null))
      return r.warn("Cached update info is corrupted: no fileName, directory for cached update will be cleaned"), await this.cleanCacheDirForPendingUpdate(), null;
    if (t.info.sha512 !== s.sha512)
      return r.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${s.sha512}, expected: ${t.info.sha512}. Directory for cached update will be cleaned`), await this.cleanCacheDirForPendingUpdate(), null;
    const a = ra.join(this.cacheDirForPendingUpdate, s.fileName);
    if (!await (0, wi.pathExists)(a))
      return r.info("Cached update file doesn't exist"), null;
    const c = await AX(a);
    return t.info.sha512 !== c ? (r.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${c}, expected: ${t.info.sha512}`), await this.cleanCacheDirForPendingUpdate(), null) : (this._downloadedFileInfo = s, a);
  }
  getUpdateInfoFile() {
    return ra.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
cc.DownloadedUpdateHelper = CX;
function AX(e, t = "sha512", r = "base64", n) {
  return new Promise((i, s) => {
    const o = (0, OX.createHash)(t);
    o.on("error", s).setEncoding(r), (0, PX.createReadStream)(e, {
      ...n,
      highWaterMark: 1024 * 1024
      /* better to use more memory but hash faster */
    }).on("error", s).on("end", () => {
      o.end(), i(o.read());
    }).pipe(o, { end: !1 });
  });
}
async function IX(e, t, r) {
  let n = 0, i = ra.join(t, e);
  for (let s = 0; s < 3; s++)
    try {
      return await (0, wi.unlink)(i), i;
    } catch (o) {
      if (o.code === "ENOENT")
        return i;
      r.warn(`Error on remove temp update file: ${o}`), i = ra.join(t, `${n++}-${e}`);
    }
  return i;
}
var $f = {}, Xy = {};
Object.defineProperty(Xy, "__esModule", { value: !0 });
Xy.getAppCacheDir = kX;
const Wp = we, NX = vu;
function kX() {
  const e = (0, NX.homedir)();
  let t;
  return process.platform === "win32" ? t = process.env.LOCALAPPDATA || Wp.join(e, "AppData", "Local") : process.platform === "darwin" ? t = Wp.join(e, "Library", "Caches") : t = process.env.XDG_CACHE_HOME || Wp.join(e, ".cache"), t;
}
Object.defineProperty($f, "__esModule", { value: !0 });
$f.ElectronAppAdapter = void 0;
const Vw = we, DX = Xy;
class LX {
  constructor(t = ji.app) {
    this.app = t;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === !0;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? Vw.join(process.resourcesPath, "app-update.yml") : Vw.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return (0, DX.getAppCacheDir)();
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(t) {
    this.app.once("quit", (r, n) => t(n));
  }
}
$f.ElectronAppAdapter = LX;
var iP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ElectronHttpExecutor = e.NET_SESSION_NAME = void 0, e.getNetSession = r;
  const t = Rt;
  e.NET_SESSION_NAME = "electron-updater";
  function r() {
    return ji.session.fromPartition(e.NET_SESSION_NAME, {
      cache: !1
    });
  }
  class n extends t.HttpExecutor {
    constructor(s) {
      super(), this.proxyLoginCallback = s, this.cachedSession = null;
    }
    async download(s, o, a) {
      return await a.cancellationToken.createPromise((c, u, l) => {
        const f = {
          headers: a.headers || void 0,
          redirect: "manual"
        };
        (0, t.configureRequestUrl)(s, f), (0, t.configureRequestOptions)(f), this.doDownload(f, {
          destination: o,
          options: a,
          onCancel: l,
          callback: (m) => {
            m == null ? c(o) : u(m);
          },
          responseHandler: null
        }, 0);
      });
    }
    createRequest(s, o) {
      s.headers && s.headers.Host && (s.host = s.headers.Host, delete s.headers.Host), this.cachedSession == null && (this.cachedSession = r());
      const a = ji.net.request({
        ...s,
        session: this.cachedSession
      });
      return a.on("response", o), this.proxyLoginCallback != null && a.on("login", this.proxyLoginCallback), a;
    }
    addRedirectHandlers(s, o, a, c, u) {
      s.on("redirect", (l, f, m) => {
        s.abort(), c > this.maxRedirects ? a(this.createMaxRedirectError()) : u(t.HttpExecutor.prepareRedirectUrlOptions(m, o));
      });
    }
  }
  e.ElectronHttpExecutor = n;
})(iP);
var lc = {}, Ir = {}, FX = "[object Symbol]", sP = /[\\^$.*+?()[\]{}|]/g, jX = RegExp(sP.source), UX = typeof me == "object" && me && me.Object === Object && me, MX = typeof self == "object" && self && self.Object === Object && self, HX = UX || MX || Function("return this")(), qX = Object.prototype, BX = qX.toString, Gw = HX.Symbol, Ww = Gw ? Gw.prototype : void 0, Kw = Ww ? Ww.toString : void 0;
function zX(e) {
  if (typeof e == "string")
    return e;
  if (GX(e))
    return Kw ? Kw.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function VX(e) {
  return !!e && typeof e == "object";
}
function GX(e) {
  return typeof e == "symbol" || VX(e) && BX.call(e) == FX;
}
function WX(e) {
  return e == null ? "" : zX(e);
}
function KX(e) {
  return e = WX(e), e && jX.test(e) ? e.replace(sP, "\\$&") : e;
}
var YX = KX;
Object.defineProperty(Ir, "__esModule", { value: !0 });
Ir.newBaseUrl = XX;
Ir.newUrlFromBase = tm;
Ir.getChannelFilename = ZX;
Ir.blockmapFiles = QX;
const oP = Hr, JX = YX;
function XX(e) {
  const t = new oP.URL(e);
  return t.pathname.endsWith("/") || (t.pathname += "/"), t;
}
function tm(e, t, r = !1) {
  const n = new oP.URL(e, t), i = t.search;
  return i != null && i.length !== 0 ? n.search = i : r && (n.search = `noCache=${Date.now().toString(32)}`), n;
}
function ZX(e) {
  return `${e}.yml`;
}
function QX(e, t, r) {
  const n = tm(`${e.pathname}.blockmap`, e);
  return [tm(`${e.pathname.replace(new RegExp(JX(r), "g"), t)}.blockmap`, e), n];
}
var vt = {};
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.Provider = void 0;
vt.findFile = rZ;
vt.parseUpdateInfo = nZ;
vt.getFileList = aP;
vt.resolveFiles = iZ;
const ti = Rt, eZ = jt, Yw = Ir;
class tZ {
  constructor(t) {
    this.runtimeOptions = t, this.requestHeaders = null, this.executor = t.executor;
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== !1;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const t = process.env.TEST_UPDATER_ARCH || process.arch;
      return "-linux" + (t === "x64" ? "" : `-${t}`);
    } else
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
  }
  // due to historical reasons for windows we use channel name without platform specifier
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(t) {
    return `${t}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(t) {
    this.requestHeaders = t;
  }
  /**
   * Method to perform API request only to resolve update info, but not to download update.
   */
  httpRequest(t, r, n) {
    return this.executor.request(this.createRequestOptions(t, r), n);
  }
  createRequestOptions(t, r) {
    const n = {};
    return this.requestHeaders == null ? r != null && (n.headers = r) : n.headers = r == null ? this.requestHeaders : { ...this.requestHeaders, ...r }, (0, ti.configureRequestUrl)(t, n), n;
  }
}
vt.Provider = tZ;
function rZ(e, t, r) {
  if (e.length === 0)
    throw (0, ti.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  const n = e.find((i) => i.url.pathname.toLowerCase().endsWith(`.${t}`));
  return n ?? (r == null ? e[0] : e.find((i) => !r.some((s) => i.url.pathname.toLowerCase().endsWith(`.${s}`))));
}
function nZ(e, t, r) {
  if (e == null)
    throw (0, ti.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${r}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  let n;
  try {
    n = (0, eZ.load)(e);
  } catch (i) {
    throw (0, ti.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${r}): ${i.stack || i.message}, rawData: ${e}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  return n;
}
function aP(e) {
  const t = e.files;
  if (t != null && t.length > 0)
    return t;
  if (e.path != null)
    return [
      {
        url: e.path,
        sha2: e.sha2,
        sha512: e.sha512
      }
    ];
  throw (0, ti.newError)(`No files provided: ${(0, ti.safeStringifyJson)(e)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
}
function iZ(e, t, r = (n) => n) {
  const i = aP(e).map((a) => {
    if (a.sha2 == null && a.sha512 == null)
      throw (0, ti.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, ti.safeStringifyJson)(a)}`, "ERR_UPDATER_NO_CHECKSUM");
    return {
      url: (0, Yw.newUrlFromBase)(r(a.url), t),
      info: a
    };
  }), s = e.packages, o = s == null ? null : s[process.arch] || s.ia32;
  return o != null && (i[0].packageInfo = {
    ...o,
    path: (0, Yw.newUrlFromBase)(r(o.path), t).href
  }), i;
}
Object.defineProperty(lc, "__esModule", { value: !0 });
lc.GenericProvider = void 0;
const Jw = Rt, Kp = Ir, Yp = vt;
class sZ extends Yp.Provider {
  constructor(t, r, n) {
    super(n), this.configuration = t, this.updater = r, this.baseUrl = (0, Kp.newBaseUrl)(this.configuration.url);
  }
  get channel() {
    const t = this.updater.channel || this.configuration.channel;
    return t == null ? this.getDefaultChannelName() : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    const t = (0, Kp.getChannelFilename)(this.channel), r = (0, Kp.newUrlFromBase)(t, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let n = 0; ; n++)
      try {
        return (0, Yp.parseUpdateInfo)(await this.httpRequest(r), t, r);
      } catch (i) {
        if (i instanceof Jw.HttpError && i.statusCode === 404)
          throw (0, Jw.newError)(`Cannot find channel "${t}" update info: ${i.stack || i.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        if (i.code === "ECONNREFUSED" && n < 3) {
          await new Promise((s, o) => {
            try {
              setTimeout(s, 1e3 * n);
            } catch (a) {
              o(a);
            }
          });
          continue;
        }
        throw i;
      }
  }
  resolveFiles(t) {
    return (0, Yp.resolveFiles)(t, this.baseUrl);
  }
}
lc.GenericProvider = sZ;
var Tf = {}, Of = {};
Object.defineProperty(Of, "__esModule", { value: !0 });
Of.BitbucketProvider = void 0;
const Xw = Rt, Jp = Ir, Xp = vt;
class oZ extends Xp.Provider {
  constructor(t, r, n) {
    super({
      ...n,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = r;
    const { owner: i, slug: s } = t;
    this.baseUrl = (0, Jp.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${i}/${s}/downloads`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const t = new Xw.CancellationToken(), r = (0, Jp.getChannelFilename)(this.getCustomChannelName(this.channel)), n = (0, Jp.newUrlFromBase)(r, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(n, void 0, t);
      return (0, Xp.parseUpdateInfo)(i, r, n);
    } catch (i) {
      throw (0, Xw.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, Xp.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { owner: t, slug: r } = this.configuration;
    return `Bitbucket (owner: ${t}, slug: ${r}, channel: ${this.channel})`;
  }
}
Of.BitbucketProvider = oZ;
var ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.GitHubProvider = ri.BaseGitHubProvider = void 0;
ri.computeReleaseNotes = lP;
const fn = Rt, Ts = oy, aZ = Hr, Os = Ir, rm = vt, Zp = /\/tag\/([^/]+)$/;
class cP extends rm.Provider {
  constructor(t, r, n) {
    super({
      ...n,
      /* because GitHib uses S3 */
      isUseMultipleRangeRequest: !1
    }), this.options = t, this.baseUrl = (0, Os.newBaseUrl)((0, fn.githubUrl)(t, r));
    const i = r === "github.com" ? "api.github.com" : r;
    this.baseApiUrl = (0, Os.newBaseUrl)((0, fn.githubUrl)(t, i));
  }
  computeGithubBasePath(t) {
    const r = this.options.host;
    return r && !["github.com", "api.github.com"].includes(r) ? `/api/v3${t}` : t;
  }
}
ri.BaseGitHubProvider = cP;
class cZ extends cP {
  constructor(t, r, n) {
    super(t, "github.com", n), this.options = t, this.updater = r;
  }
  get channel() {
    const t = this.updater.channel || this.options.channel;
    return t == null ? this.getDefaultChannelName() : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    var t, r, n, i, s;
    const o = new fn.CancellationToken(), a = await this.httpRequest((0, Os.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, o), c = (0, fn.parseXml)(a);
    let u = c.element("entry", !1, "No published versions on GitHub"), l = null;
    try {
      if (this.updater.allowPrerelease) {
        const _ = ((t = this.updater) === null || t === void 0 ? void 0 : t.channel) || ((r = Ts.prerelease(this.updater.currentVersion)) === null || r === void 0 ? void 0 : r[0]) || null;
        if (_ === null)
          l = Zp.exec(u.element("link").attribute("href"))[1];
        else
          for (const g of c.getElements("entry")) {
            const v = Zp.exec(g.element("link").attribute("href"));
            if (v === null)
              continue;
            const y = v[1], E = ((n = Ts.prerelease(y)) === null || n === void 0 ? void 0 : n[0]) || null, R = !_ || ["alpha", "beta"].includes(_), w = E !== null && !["alpha", "beta"].includes(String(E));
            if (R && !w && !(_ === "beta" && E === "alpha")) {
              l = y;
              break;
            }
            if (E && E === _) {
              l = y;
              break;
            }
          }
      } else {
        l = await this.getLatestTagName(o);
        for (const _ of c.getElements("entry"))
          if (Zp.exec(_.element("link").attribute("href"))[1] === l) {
            u = _;
            break;
          }
      }
    } catch (_) {
      throw (0, fn.newError)(`Cannot parse releases feed: ${_.stack || _.message},
XML:
${a}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
    if (l == null)
      throw (0, fn.newError)("No published versions on GitHub", "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    let f, m = "", p = "";
    const d = async (_) => {
      m = (0, Os.getChannelFilename)(_), p = (0, Os.newUrlFromBase)(this.getBaseDownloadPath(String(l), m), this.baseUrl);
      const g = this.createRequestOptions(p);
      try {
        return await this.executor.request(g, o);
      } catch (v) {
        throw v instanceof fn.HttpError && v.statusCode === 404 ? (0, fn.newError)(`Cannot find ${m} in the latest release artifacts (${p}): ${v.stack || v.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : v;
      }
    };
    try {
      let _ = this.channel;
      this.updater.allowPrerelease && (!((i = Ts.prerelease(l)) === null || i === void 0) && i[0]) && (_ = this.getCustomChannelName(String((s = Ts.prerelease(l)) === null || s === void 0 ? void 0 : s[0]))), f = await d(_);
    } catch (_) {
      if (this.updater.allowPrerelease)
        f = await d(this.getDefaultChannelName());
      else
        throw _;
    }
    const h = (0, rm.parseUpdateInfo)(f, m, p);
    return h.releaseName == null && (h.releaseName = u.elementValueOrEmpty("title")), h.releaseNotes == null && (h.releaseNotes = lP(this.updater.currentVersion, this.updater.fullChangelog, c, u)), {
      tag: l,
      ...h
    };
  }
  async getLatestTagName(t) {
    const r = this.options, n = r.host == null || r.host === "github.com" ? (0, Os.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new aZ.URL(`${this.computeGithubBasePath(`/repos/${r.owner}/${r.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const i = await this.httpRequest(n, { Accept: "application/json" }, t);
      return i == null ? null : JSON.parse(i).tag_name;
    } catch (i) {
      throw (0, fn.newError)(`Unable to find latest version on GitHub (${n}), please ensure a production release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(t) {
    return (0, rm.resolveFiles)(t, this.baseUrl, (r) => this.getBaseDownloadPath(t.tag, r.replace(/ /g, "-")));
  }
  getBaseDownloadPath(t, r) {
    return `${this.basePath}/download/${t}/${r}`;
  }
}
ri.GitHubProvider = cZ;
function Zw(e) {
  const t = e.elementValueOrEmpty("content");
  return t === "No content." ? "" : t;
}
function lP(e, t, r, n) {
  if (!t)
    return Zw(n);
  const i = [];
  for (const s of r.getElements("entry")) {
    const o = /\/tag\/v?([^/]+)$/.exec(s.element("link").attribute("href"))[1];
    Ts.lt(e, o) && i.push({
      version: o,
      note: Zw(s)
    });
  }
  return i.sort((s, o) => Ts.rcompare(s.version, o.version));
}
var Pf = {};
Object.defineProperty(Pf, "__esModule", { value: !0 });
Pf.KeygenProvider = void 0;
const Qw = Rt, Qp = Ir, eh = vt;
class lZ extends eh.Provider {
  constructor(t, r, n) {
    super({
      ...n,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = r, this.defaultHostname = "api.keygen.sh";
    const i = this.configuration.host || this.defaultHostname;
    this.baseUrl = (0, Qp.newBaseUrl)(`https://${i}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const t = new Qw.CancellationToken(), r = (0, Qp.getChannelFilename)(this.getCustomChannelName(this.channel)), n = (0, Qp.newUrlFromBase)(r, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(n, {
        Accept: "application/vnd.api+json",
        "Keygen-Version": "1.1"
      }, t);
      return (0, eh.parseUpdateInfo)(i, r, n);
    } catch (i) {
      throw (0, Qw.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, eh.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { account: t, product: r, platform: n } = this.configuration;
    return `Keygen (account: ${t}, product: ${r}, platform: ${n}, channel: ${this.channel})`;
  }
}
Pf.KeygenProvider = lZ;
var Cf = {};
Object.defineProperty(Cf, "__esModule", { value: !0 });
Cf.PrivateGitHubProvider = void 0;
const ps = Rt, uZ = jt, fZ = we, eS = Hr, tS = Ir, dZ = ri, pZ = vt;
class hZ extends dZ.BaseGitHubProvider {
  constructor(t, r, n, i) {
    super(t, "api.github.com", i), this.updater = r, this.token = n;
  }
  createRequestOptions(t, r) {
    const n = super.createRequestOptions(t, r);
    return n.redirect = "manual", n;
  }
  async getLatestVersion() {
    const t = new ps.CancellationToken(), r = (0, tS.getChannelFilename)(this.getDefaultChannelName()), n = await this.getLatestVersionInfo(t), i = n.assets.find((a) => a.name === r);
    if (i == null)
      throw (0, ps.newError)(`Cannot find ${r} in the release ${n.html_url || n.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    const s = new eS.URL(i.url);
    let o;
    try {
      o = (0, uZ.load)(await this.httpRequest(s, this.configureHeaders("application/octet-stream"), t));
    } catch (a) {
      throw a instanceof ps.HttpError && a.statusCode === 404 ? (0, ps.newError)(`Cannot find ${r} in the latest release artifacts (${s}): ${a.stack || a.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : a;
    }
    return o.assets = n.assets, o;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(t) {
    return {
      accept: t,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(t) {
    const r = this.updater.allowPrerelease;
    let n = this.basePath;
    r || (n = `${n}/latest`);
    const i = (0, tS.newUrlFromBase)(n, this.baseUrl);
    try {
      const s = JSON.parse(await this.httpRequest(i, this.configureHeaders("application/vnd.github.v3+json"), t));
      return r ? s.find((o) => o.prerelease) || s[0] : s;
    } catch (s) {
      throw (0, ps.newError)(`Unable to find latest version on GitHub (${i}), please ensure a production release exists: ${s.stack || s.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
  resolveFiles(t) {
    return (0, pZ.getFileList)(t).map((r) => {
      const n = fZ.posix.basename(r.url).replace(/ /g, "-"), i = t.assets.find((s) => s != null && s.name === n);
      if (i == null)
        throw (0, ps.newError)(`Cannot find asset "${n}" in: ${JSON.stringify(t.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      return {
        url: new eS.URL(i.url),
        info: r
      };
    });
  }
}
Cf.PrivateGitHubProvider = hZ;
Object.defineProperty(Tf, "__esModule", { value: !0 });
Tf.isUrlProbablySupportMultiRangeRequests = uP;
Tf.createClient = _Z;
const nl = Rt, mZ = Of, rS = lc, gZ = ri, yZ = Pf, vZ = Cf;
function uP(e) {
  return !e.includes("s3.amazonaws.com");
}
function _Z(e, t, r) {
  if (typeof e == "string")
    throw (0, nl.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  const n = e.provider;
  switch (n) {
    case "github": {
      const i = e, s = (i.private ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN : null) || i.token;
      return s == null ? new gZ.GitHubProvider(i, t, r) : new vZ.PrivateGitHubProvider(i, t, s, r);
    }
    case "bitbucket":
      return new mZ.BitbucketProvider(e, t, r);
    case "keygen":
      return new yZ.KeygenProvider(e, t, r);
    case "s3":
    case "spaces":
      return new rS.GenericProvider({
        provider: "generic",
        url: (0, nl.getS3LikeProviderBaseUrl)(e),
        channel: e.channel || null
      }, t, {
        ...r,
        // https://github.com/minio/minio/issues/5285#issuecomment-350428955
        isUseMultipleRangeRequest: !1
      });
    case "generic": {
      const i = e;
      return new rS.GenericProvider(i, t, {
        ...r,
        isUseMultipleRangeRequest: i.useMultipleRangeRequest !== !1 && uP(i.url)
      });
    }
    case "custom": {
      const i = e, s = i.updateProvider;
      if (!s)
        throw (0, nl.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      return new s(i, t, r);
    }
    default:
      throw (0, nl.newError)(`Unsupported provider: ${n}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
var Af = {}, uc = {}, po = {}, Zi = {};
Object.defineProperty(Zi, "__esModule", { value: !0 });
Zi.OperationKind = void 0;
Zi.computeOperations = bZ;
var Ai;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(Ai || (Zi.OperationKind = Ai = {}));
function bZ(e, t, r) {
  const n = iS(e.files), i = iS(t.files);
  let s = null;
  const o = t.files[0], a = [], c = o.name, u = n.get(c);
  if (u == null)
    throw new Error(`no file ${c} in old blockmap`);
  const l = i.get(c);
  let f = 0;
  const { checksumToOffset: m, checksumToOldSize: p } = wZ(n.get(c), u.offset, r);
  let d = o.offset;
  for (let h = 0; h < l.checksums.length; d += l.sizes[h], h++) {
    const _ = l.sizes[h], g = l.checksums[h];
    let v = m.get(g);
    v != null && p.get(g) !== _ && (r.warn(`Checksum ("${g}") matches, but size differs (old: ${p.get(g)}, new: ${_})`), v = void 0), v === void 0 ? (f++, s != null && s.kind === Ai.DOWNLOAD && s.end === d ? s.end += _ : (s = {
      kind: Ai.DOWNLOAD,
      start: d,
      end: d + _
      // oldBlocks: null,
    }, nS(s, a, g, h))) : s != null && s.kind === Ai.COPY && s.end === v ? s.end += _ : (s = {
      kind: Ai.COPY,
      start: v,
      end: v + _
      // oldBlocks: [checksum]
    }, nS(s, a, g, h));
  }
  return f > 0 && r.info(`File${o.name === "file" ? "" : " " + o.name} has ${f} changed blocks`), a;
}
const EZ = process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
function nS(e, t, r, n) {
  if (EZ && t.length !== 0) {
    const i = t[t.length - 1];
    if (i.kind === e.kind && e.start < i.end && e.start > i.start) {
      const s = [i.start, i.end, e.start, e.end].reduce((o, a) => o < a ? o : a);
      throw new Error(`operation (block index: ${n}, checksum: ${r}, kind: ${Ai[e.kind]}) overlaps previous operation (checksum: ${r}):
abs: ${i.start} until ${i.end} and ${e.start} until ${e.end}
rel: ${i.start - s} until ${i.end - s} and ${e.start - s} until ${e.end - s}`);
    }
  }
  t.push(e);
}
function wZ(e, t, r) {
  const n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  let s = t;
  for (let o = 0; o < e.checksums.length; o++) {
    const a = e.checksums[o], c = e.sizes[o], u = i.get(a);
    if (u === void 0)
      n.set(a, s), i.set(a, c);
    else if (r.debug != null) {
      const l = u === c ? "(same size)" : `(size: ${u}, this size: ${c})`;
      r.debug(`${a} duplicated in blockmap ${l}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    s += c;
  }
  return { checksumToOffset: n, checksumToOldSize: i };
}
function iS(e) {
  const t = /* @__PURE__ */ new Map();
  for (const r of e)
    t.set(r.name, r);
  return t;
}
Object.defineProperty(po, "__esModule", { value: !0 });
po.DataSplitter = void 0;
po.copyData = fP;
const il = Rt, SZ = Ye, xZ = It, RZ = Zi, sS = Buffer.from(`\r
\r
`);
var jn;
(function(e) {
  e[e.INIT = 0] = "INIT", e[e.HEADER = 1] = "HEADER", e[e.BODY = 2] = "BODY";
})(jn || (jn = {}));
function fP(e, t, r, n, i) {
  const s = (0, SZ.createReadStream)("", {
    fd: r,
    autoClose: !1,
    start: e.start,
    // end is inclusive
    end: e.end - 1
  });
  s.on("error", n), s.once("end", i), s.pipe(t, {
    end: !1
  });
}
class $Z extends xZ.Writable {
  constructor(t, r, n, i, s, o) {
    super(), this.out = t, this.options = r, this.partIndexToTaskIndex = n, this.partIndexToLength = s, this.finishHandler = o, this.partIndex = -1, this.headerListBuffer = null, this.readState = jn.INIT, this.ignoreByteCount = 0, this.remainingPartDataCount = 0, this.actualPartLength = 0, this.boundaryLength = i.length + 4, this.ignoreByteCount = this.boundaryLength - 2;
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  // noinspection JSUnusedGlobalSymbols
  _write(t, r, n) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${t.length} bytes`);
      return;
    }
    this.handleData(t).then(n).catch(n);
  }
  async handleData(t) {
    let r = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
      throw (0, il.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    if (this.ignoreByteCount > 0) {
      const n = Math.min(this.ignoreByteCount, t.length);
      this.ignoreByteCount -= n, r = n;
    } else if (this.remainingPartDataCount > 0) {
      const n = Math.min(this.remainingPartDataCount, t.length);
      this.remainingPartDataCount -= n, await this.processPartData(t, 0, n), r = n;
    }
    if (r !== t.length) {
      if (this.readState === jn.HEADER) {
        const n = this.searchHeaderListEnd(t, r);
        if (n === -1)
          return;
        r = n, this.readState = jn.BODY, this.headerListBuffer = null;
      }
      for (; ; ) {
        if (this.readState === jn.BODY)
          this.readState = jn.INIT;
        else {
          this.partIndex++;
          let o = this.partIndexToTaskIndex.get(this.partIndex);
          if (o == null)
            if (this.isFinished)
              o = this.options.end;
            else
              throw (0, il.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          const a = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (a < o)
            await this.copyExistingData(a, o);
          else if (a > o)
            throw (0, il.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
          if (this.isFinished) {
            this.onPartEnd(), this.finishHandler();
            return;
          }
          if (r = this.searchHeaderListEnd(t, r), r === -1) {
            this.readState = jn.HEADER;
            return;
          }
        }
        const n = this.partIndexToLength[this.partIndex], i = r + n, s = Math.min(i, t.length);
        if (await this.processPartStarted(t, r, s), this.remainingPartDataCount = n - (s - r), this.remainingPartDataCount > 0)
          return;
        if (r = i + this.boundaryLength, r >= t.length) {
          this.ignoreByteCount = this.boundaryLength - (t.length - i);
          return;
        }
      }
    }
  }
  copyExistingData(t, r) {
    return new Promise((n, i) => {
      const s = () => {
        if (t === r) {
          n();
          return;
        }
        const o = this.options.tasks[t];
        if (o.kind !== RZ.OperationKind.COPY) {
          i(new Error("Task kind must be COPY"));
          return;
        }
        fP(o, this.out, this.options.oldFileFd, i, () => {
          t++, s();
        });
      };
      s();
    });
  }
  searchHeaderListEnd(t, r) {
    const n = t.indexOf(sS, r);
    if (n !== -1)
      return n + sS.length;
    const i = r === 0 ? t : t.slice(r);
    return this.headerListBuffer == null ? this.headerListBuffer = i : this.headerListBuffer = Buffer.concat([this.headerListBuffer, i]), -1;
  }
  onPartEnd() {
    const t = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== t)
      throw (0, il.newError)(`Expected length: ${t} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    this.actualPartLength = 0;
  }
  processPartStarted(t, r, n) {
    return this.partIndex !== 0 && this.onPartEnd(), this.processPartData(t, r, n);
  }
  processPartData(t, r, n) {
    this.actualPartLength += n - r;
    const i = this.out;
    return i.write(r === 0 && t.length === n ? t : t.slice(r, n)) ? Promise.resolve() : new Promise((s, o) => {
      i.on("error", o), i.once("drain", () => {
        i.removeListener("error", o), s();
      });
    });
  }
}
po.DataSplitter = $Z;
var If = {};
Object.defineProperty(If, "__esModule", { value: !0 });
If.executeTasksUsingMultipleRangeRequests = TZ;
If.checkIsRangesSupported = im;
const nm = Rt, oS = po, aS = Zi;
function TZ(e, t, r, n, i) {
  const s = (o) => {
    if (o >= t.length) {
      e.fileMetadataBuffer != null && r.write(e.fileMetadataBuffer), r.end();
      return;
    }
    const a = o + 1e3;
    OZ(e, {
      tasks: t,
      start: o,
      end: Math.min(t.length, a),
      oldFileFd: n
    }, r, () => s(a), i);
  };
  return s;
}
function OZ(e, t, r, n, i) {
  let s = "bytes=", o = 0;
  const a = /* @__PURE__ */ new Map(), c = [];
  for (let f = t.start; f < t.end; f++) {
    const m = t.tasks[f];
    m.kind === aS.OperationKind.DOWNLOAD && (s += `${m.start}-${m.end - 1}, `, a.set(o, f), o++, c.push(m.end - m.start));
  }
  if (o <= 1) {
    const f = (m) => {
      if (m >= t.end) {
        n();
        return;
      }
      const p = t.tasks[m++];
      if (p.kind === aS.OperationKind.COPY)
        (0, oS.copyData)(p, r, t.oldFileFd, i, () => f(m));
      else {
        const d = e.createRequestOptions();
        d.headers.Range = `bytes=${p.start}-${p.end - 1}`;
        const h = e.httpExecutor.createRequest(d, (_) => {
          im(_, i) && (_.pipe(r, {
            end: !1
          }), _.once("end", () => f(m)));
        });
        e.httpExecutor.addErrorAndTimeoutHandlers(h, i), h.end();
      }
    };
    f(t.start);
    return;
  }
  const u = e.createRequestOptions();
  u.headers.Range = s.substring(0, s.length - 2);
  const l = e.httpExecutor.createRequest(u, (f) => {
    if (!im(f, i))
      return;
    const m = (0, nm.safeGetHeader)(f, "content-type"), p = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(m);
    if (p == null) {
      i(new Error(`Content-Type "multipart/byteranges" is expected, but got "${m}"`));
      return;
    }
    const d = new oS.DataSplitter(r, t, a, p[1] || p[2], c, n);
    d.on("error", i), f.pipe(d), f.on("end", () => {
      setTimeout(() => {
        l.abort(), i(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  e.httpExecutor.addErrorAndTimeoutHandlers(l, i), l.end();
}
function im(e, t) {
  if (e.statusCode >= 400)
    return t((0, nm.createHttpError)(e)), !1;
  if (e.statusCode !== 206) {
    const r = (0, nm.safeGetHeader)(e, "accept-ranges");
    if (r == null || r === "none")
      return t(new Error(`Server doesn't support Accept-Ranges (response code ${e.statusCode})`)), !1;
  }
  return !0;
}
var Nf = {};
Object.defineProperty(Nf, "__esModule", { value: !0 });
Nf.ProgressDifferentialDownloadCallbackTransform = void 0;
const PZ = It;
var Ps;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(Ps || (Ps = {}));
class CZ extends PZ.Transform {
  constructor(t, r, n) {
    super(), this.progressDifferentialDownloadInfo = t, this.cancellationToken = r, this.onProgress = n, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.expectedBytes = 0, this.index = 0, this.operationType = Ps.COPY, this.nextUpdate = this.start + 1e3;
  }
  _transform(t, r, n) {
    if (this.cancellationToken.cancelled) {
      n(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == Ps.COPY) {
      n(null, t);
      return;
    }
    this.transferred += t.length, this.delta += t.length;
    const i = Date.now();
    i >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && (this.nextUpdate = i + 1e3, this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
      bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3))
    }), this.delta = 0), n(null, t);
  }
  beginFileCopy() {
    this.operationType = Ps.COPY;
  }
  beginRangeDownload() {
    this.operationType = Ps.DOWNLOAD, this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
  }
  // Called when we are 100% done with the connection/download
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    }), this.delta = 0, this.transferred = 0, t(null);
  }
}
Nf.ProgressDifferentialDownloadCallbackTransform = CZ;
Object.defineProperty(uc, "__esModule", { value: !0 });
uc.DifferentialDownloader = void 0;
const Mo = Rt, th = ni, AZ = Ye, IZ = po, NZ = Hr, sl = Zi, cS = If, kZ = Nf;
class DZ {
  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
  constructor(t, r, n) {
    this.blockAwareFileInfo = t, this.httpExecutor = r, this.options = n, this.fileMetadataBuffer = null, this.logger = n.logger;
  }
  createRequestOptions() {
    const t = {
      headers: {
        ...this.options.requestHeaders,
        accept: "*/*"
      }
    };
    return (0, Mo.configureRequestUrl)(this.options.newUrl, t), (0, Mo.configureRequestOptions)(t), t;
  }
  doDownload(t, r) {
    if (t.version !== r.version)
      throw new Error(`version is different (${t.version} - ${r.version}), full download is required`);
    const n = this.logger, i = (0, sl.computeOperations)(t, r, n);
    n.debug != null && n.debug(JSON.stringify(i, null, 2));
    let s = 0, o = 0;
    for (const c of i) {
      const u = c.end - c.start;
      c.kind === sl.OperationKind.DOWNLOAD ? s += u : o += u;
    }
    const a = this.blockAwareFileInfo.size;
    if (s + o + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== a)
      throw new Error(`Internal error, size mismatch: downloadSize: ${s}, copySize: ${o}, newSize: ${a}`);
    return n.info(`Full: ${lS(a)}, To download: ${lS(s)} (${Math.round(s / (a / 100))}%)`), this.downloadFile(i);
  }
  downloadFile(t) {
    const r = [], n = () => Promise.all(r.map((i) => (0, th.close)(i.descriptor).catch((s) => {
      this.logger.error(`cannot close file "${i.path}": ${s}`);
    })));
    return this.doDownloadFile(t, r).then(n).catch((i) => n().catch((s) => {
      try {
        this.logger.error(`cannot close files: ${s}`);
      } catch (o) {
        try {
          console.error(o);
        } catch {
        }
      }
      throw i;
    }).then(() => {
      throw i;
    }));
  }
  async doDownloadFile(t, r) {
    const n = await (0, th.open)(this.options.oldFile, "r");
    r.push({ descriptor: n, path: this.options.oldFile });
    const i = await (0, th.open)(this.options.newFile, "w");
    r.push({ descriptor: i, path: this.options.newFile });
    const s = (0, AZ.createWriteStream)(this.options.newFile, { fd: i });
    await new Promise((o, a) => {
      const c = [];
      let u;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const g = [];
        let v = 0;
        for (const E of t)
          E.kind === sl.OperationKind.DOWNLOAD && (g.push(E.end - E.start), v += E.end - E.start);
        const y = {
          expectedByteCounts: g,
          grandTotal: v
        };
        u = new kZ.ProgressDifferentialDownloadCallbackTransform(y, this.options.cancellationToken, this.options.onProgress), c.push(u);
      }
      const l = new Mo.DigestTransform(this.blockAwareFileInfo.sha512);
      l.isValidateOnEnd = !1, c.push(l), s.on("finish", () => {
        s.close(() => {
          r.splice(1, 1);
          try {
            l.validate();
          } catch (g) {
            a(g);
            return;
          }
          o(void 0);
        });
      }), c.push(s);
      let f = null;
      for (const g of c)
        g.on("error", a), f == null ? f = g : f = f.pipe(g);
      const m = c[0];
      let p;
      if (this.options.isUseMultipleRangeRequest) {
        p = (0, cS.executeTasksUsingMultipleRangeRequests)(this, t, m, n, a), p(0);
        return;
      }
      let d = 0, h = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const _ = this.createRequestOptions();
      _.redirect = "manual", p = (g) => {
        var v, y;
        if (g >= t.length) {
          this.fileMetadataBuffer != null && m.write(this.fileMetadataBuffer), m.end();
          return;
        }
        const E = t[g++];
        if (E.kind === sl.OperationKind.COPY) {
          u && u.beginFileCopy(), (0, IZ.copyData)(E, m, n, a, () => p(g));
          return;
        }
        const R = `bytes=${E.start}-${E.end - 1}`;
        _.headers.range = R, (y = (v = this.logger) === null || v === void 0 ? void 0 : v.debug) === null || y === void 0 || y.call(v, `download range: ${R}`), u && u.beginRangeDownload();
        const w = this.httpExecutor.createRequest(_, (C) => {
          C.on("error", a), C.on("aborted", () => {
            a(new Error("response has been aborted by the server"));
          }), C.statusCode >= 400 && a((0, Mo.createHttpError)(C)), C.pipe(m, {
            end: !1
          }), C.once("end", () => {
            u && u.endRangeDownload(), ++d === 100 ? (d = 0, setTimeout(() => p(g), 1e3)) : p(g);
          });
        });
        w.on("redirect", (C, V, b) => {
          this.logger.info(`Redirect to ${LZ(b)}`), h = b, (0, Mo.configureRequestUrl)(new NZ.URL(h), _), w.followRedirect();
        }), this.httpExecutor.addErrorAndTimeoutHandlers(w, a), w.end();
      }, p(0);
    });
  }
  async readRemoteBytes(t, r) {
    const n = Buffer.allocUnsafe(r + 1 - t), i = this.createRequestOptions();
    i.headers.range = `bytes=${t}-${r}`;
    let s = 0;
    if (await this.request(i, (o) => {
      o.copy(n, s), s += o.length;
    }), s !== n.length)
      throw new Error(`Received data length ${s} is not equal to expected ${n.length}`);
    return n;
  }
  request(t, r) {
    return new Promise((n, i) => {
      const s = this.httpExecutor.createRequest(t, (o) => {
        (0, cS.checkIsRangesSupported)(o, i) && (o.on("error", i), o.on("aborted", () => {
          i(new Error("response has been aborted by the server"));
        }), o.on("data", r), o.on("end", () => n()));
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(s, i), s.end();
    });
  }
}
uc.DifferentialDownloader = DZ;
function lS(e, t = " KB") {
  return new Intl.NumberFormat("en").format((e / 1024).toFixed(2)) + t;
}
function LZ(e) {
  const t = e.indexOf("?");
  return t < 0 ? e : e.substring(0, t);
}
Object.defineProperty(Af, "__esModule", { value: !0 });
Af.GenericDifferentialDownloader = void 0;
const FZ = uc;
class jZ extends FZ.DifferentialDownloader {
  download(t, r) {
    return this.doDownload(t, r);
  }
}
Af.GenericDifferentialDownloader = jZ;
var ii = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.UpdaterSignal = e.UPDATE_DOWNLOADED = e.DOWNLOAD_PROGRESS = e.CancellationToken = void 0, e.addHandler = n;
  const t = Rt;
  Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } }), e.DOWNLOAD_PROGRESS = "download-progress", e.UPDATE_DOWNLOADED = "update-downloaded";
  class r {
    constructor(s) {
      this.emitter = s;
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(s) {
      n(this.emitter, "login", s);
    }
    progress(s) {
      n(this.emitter, e.DOWNLOAD_PROGRESS, s);
    }
    updateDownloaded(s) {
      n(this.emitter, e.UPDATE_DOWNLOADED, s);
    }
    updateCancelled(s) {
      n(this.emitter, "update-cancelled", s);
    }
  }
  e.UpdaterSignal = r;
  function n(i, s, o) {
    i.on(s, o);
  }
})(ii);
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.NoOpLogger = Zn.AppUpdater = void 0;
const Jt = Rt, UZ = Gi, MZ = vu, HZ = gu, hs = ni, qZ = jt, rh = Rf, vi = we, Si = oy, uS = cc, BZ = $f, fS = iP, zZ = lc, nh = Tf, VZ = Or, GZ = Ir, WZ = Af, ms = ii;
class Zy extends HZ.EventEmitter {
  /**
   * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
   */
  get channel() {
    return this._channel;
  }
  /**
   * Set the update channel. Overrides `channel` in the update configuration.
   *
   * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
   */
  set channel(t) {
    if (this._channel != null) {
      if (typeof t != "string")
        throw (0, Jt.newError)(`Channel must be a string, but got: ${t}`, "ERR_UPDATER_INVALID_CHANNEL");
      if (t.length === 0)
        throw (0, Jt.newError)("Channel must be not an empty string", "ERR_UPDATER_INVALID_CHANNEL");
    }
    this._channel = t, this.allowDowngrade = !0;
  }
  /**
   *  Shortcut for explicitly adding auth tokens to request headers
   */
  addAuthHeader(t) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: t
    });
  }
  // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  get netSession() {
    return (0, fS.getNetSession)();
  }
  /**
   * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
   * Set it to `null` if you would like to disable a logging feature.
   */
  get logger() {
    return this._logger;
  }
  set logger(t) {
    this._logger = t ?? new dP();
  }
  // noinspection JSUnusedGlobalSymbols
  /**
   * test only
   * @private
   */
  set updateConfigPath(t) {
    this.clientPromise = null, this._appUpdateConfigPath = t, this.configOnDisk = new rh.Lazy(() => this.loadUpdateConfig());
  }
  /**
   * Allows developer to override default logic for determining if an update is supported.
   * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
   */
  get isUpdateSupported() {
    return this._isUpdateSupported;
  }
  set isUpdateSupported(t) {
    t && (this._isUpdateSupported = t);
  }
  constructor(t, r) {
    super(), this.autoDownload = !0, this.autoInstallOnAppQuit = !0, this.autoRunAppAfterInstall = !0, this.allowPrerelease = !1, this.fullChangelog = !1, this.allowDowngrade = !1, this.disableWebInstaller = !1, this.disableDifferentialDownload = !1, this.forceDevUpdateConfig = !1, this._channel = null, this.downloadedUpdateHelper = null, this.requestHeaders = null, this._logger = console, this.signals = new ms.UpdaterSignal(this), this._appUpdateConfigPath = null, this._isUpdateSupported = (s) => this.checkIfUpdateSupported(s), this.clientPromise = null, this.stagingUserIdPromise = new rh.Lazy(() => this.getOrCreateStagingUserId()), this.configOnDisk = new rh.Lazy(() => this.loadUpdateConfig()), this.checkForUpdatesPromise = null, this.downloadPromise = null, this.updateInfoAndProvider = null, this._testOnlyOptions = null, this.on("error", (s) => {
      this._logger.error(`Error: ${s.stack || s.message}`);
    }), r == null ? (this.app = new BZ.ElectronAppAdapter(), this.httpExecutor = new fS.ElectronHttpExecutor((s, o) => this.emit("login", s, o))) : (this.app = r, this.httpExecutor = null);
    const n = this.app.version, i = (0, Si.parse)(n);
    if (i == null)
      throw (0, Jt.newError)(`App version is not a valid semver version: "${n}"`, "ERR_UPDATER_INVALID_VERSION");
    this.currentVersion = i, this.allowPrerelease = KZ(i), t != null && (this.setFeedURL(t), typeof t != "string" && t.requestHeaders && (this.requestHeaders = t.requestHeaders));
  }
  //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  /**
   * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
   * @param options If you want to override configuration in the `app-update.yml`.
   */
  setFeedURL(t) {
    const r = this.createProviderRuntimeOptions();
    let n;
    typeof t == "string" ? n = new zZ.GenericProvider({ provider: "generic", url: t }, this, {
      ...r,
      isUseMultipleRangeRequest: (0, nh.isUrlProbablySupportMultiRangeRequests)(t)
    }) : n = (0, nh.createClient)(t, this, r), this.clientPromise = Promise.resolve(n);
  }
  /**
   * Asks the server whether there is an update.
   * @returns null if the updater is disabled, otherwise info about the latest version
   */
  checkForUpdates() {
    if (!this.isUpdaterActive())
      return Promise.resolve(null);
    let t = this.checkForUpdatesPromise;
    if (t != null)
      return this._logger.info("Checking for update (already in progress)"), t;
    const r = () => this.checkForUpdatesPromise = null;
    return this._logger.info("Checking for update"), t = this.doCheckForUpdates().then((n) => (r(), n)).catch((n) => {
      throw r(), this.emit("error", n, `Cannot check for updates: ${(n.stack || n).toString()}`), n;
    }), this.checkForUpdatesPromise = t, t;
  }
  isUpdaterActive() {
    return this.app.isPackaged || this.forceDevUpdateConfig ? !0 : (this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced"), !1);
  }
  // noinspection JSUnusedGlobalSymbols
  checkForUpdatesAndNotify(t) {
    return this.checkForUpdates().then((r) => r != null && r.downloadPromise ? (r.downloadPromise.then(() => {
      const n = Zy.formatDownloadNotification(r.updateInfo.version, this.app.name, t);
      new ji.Notification(n).show();
    }), r) : (this._logger.debug != null && this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null"), r));
  }
  static formatDownloadNotification(t, r, n) {
    return n == null && (n = {
      title: "A new update is ready to install",
      body: "{appName} version {version} has been downloaded and will be automatically installed on exit"
    }), n = {
      title: n.title.replace("{appName}", r).replace("{version}", t),
      body: n.body.replace("{appName}", r).replace("{version}", t)
    }, n;
  }
  async isStagingMatch(t) {
    const r = t.stagingPercentage;
    let n = r;
    if (n == null)
      return !0;
    if (n = parseInt(n, 10), isNaN(n))
      return this._logger.warn(`Staging percentage is NaN: ${r}`), !0;
    n = n / 100;
    const i = await this.stagingUserIdPromise.value, o = Jt.UUID.parse(i).readUInt32BE(12) / 4294967295;
    return this._logger.info(`Staging percentage: ${n}, percentage: ${o}, user id: ${i}`), o < n;
  }
  computeFinalHeaders(t) {
    return this.requestHeaders != null && Object.assign(t, this.requestHeaders), t;
  }
  async isUpdateAvailable(t) {
    const r = (0, Si.parse)(t.version);
    if (r == null)
      throw (0, Jt.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${t.version}"`, "ERR_UPDATER_INVALID_VERSION");
    const n = this.currentVersion;
    if ((0, Si.eq)(r, n) || !await Promise.resolve(this.isUpdateSupported(t)) || !await this.isStagingMatch(t))
      return !1;
    const s = (0, Si.gt)(r, n), o = (0, Si.lt)(r, n);
    return s ? !0 : this.allowDowngrade && o;
  }
  checkIfUpdateSupported(t) {
    const r = t == null ? void 0 : t.minimumSystemVersion, n = (0, MZ.release)();
    if (r)
      try {
        if ((0, Si.lt)(n, r))
          return this._logger.info(`Current OS version ${n} is less than the minimum OS version required ${r} for version ${n}`), !1;
      } catch (i) {
        this._logger.warn(`Failed to compare current OS version(${n}) with minimum OS version(${r}): ${(i.message || i).toString()}`);
      }
    return !0;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady(), this.clientPromise == null && (this.clientPromise = this.configOnDisk.value.then((n) => (0, nh.createClient)(n, this, this.createProviderRuntimeOptions())));
    const t = await this.clientPromise, r = await this.stagingUserIdPromise.value;
    return t.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": r })), {
      info: await t.getLatestVersion(),
      provider: t
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: !0,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const t = await this.getUpdateInfoAndProvider(), r = t.info;
    if (!await this.isUpdateAvailable(r))
      return this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${r.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`), this.emit("update-not-available", r), {
        isUpdateAvailable: !1,
        versionInfo: r,
        updateInfo: r
      };
    this.updateInfoAndProvider = t, this.onUpdateAvailable(r);
    const n = new Jt.CancellationToken();
    return {
      isUpdateAvailable: !0,
      versionInfo: r,
      updateInfo: r,
      cancellationToken: n,
      downloadPromise: this.autoDownload ? this.downloadUpdate(n) : null
    };
  }
  onUpdateAvailable(t) {
    this._logger.info(`Found version ${t.version} (url: ${(0, Jt.asArray)(t.files).map((r) => r.url).join(", ")})`), this.emit("update-available", t);
  }
  /**
   * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
   * @returns {Promise<Array<string>>} Paths to downloaded files.
   */
  downloadUpdate(t = new Jt.CancellationToken()) {
    const r = this.updateInfoAndProvider;
    if (r == null) {
      const i = new Error("Please check update first");
      return this.dispatchError(i), Promise.reject(i);
    }
    if (this.downloadPromise != null)
      return this._logger.info("Downloading update (already in progress)"), this.downloadPromise;
    this._logger.info(`Downloading update from ${(0, Jt.asArray)(r.info.files).map((i) => i.url).join(", ")}`);
    const n = (i) => {
      if (!(i instanceof Jt.CancellationError))
        try {
          this.dispatchError(i);
        } catch (s) {
          this._logger.warn(`Cannot dispatch error event: ${s.stack || s}`);
        }
      return i;
    };
    return this.downloadPromise = this.doDownloadUpdate({
      updateInfoAndProvider: r,
      requestHeaders: this.computeRequestHeaders(r.provider),
      cancellationToken: t,
      disableWebInstaller: this.disableWebInstaller,
      disableDifferentialDownload: this.disableDifferentialDownload
    }).catch((i) => {
      throw n(i);
    }).finally(() => {
      this.downloadPromise = null;
    }), this.downloadPromise;
  }
  dispatchError(t) {
    this.emit("error", t, (t.stack || t).toString());
  }
  dispatchUpdateDownloaded(t) {
    this.emit(ms.UPDATE_DOWNLOADED, t);
  }
  async loadUpdateConfig() {
    return this._appUpdateConfigPath == null && (this._appUpdateConfigPath = this.app.appUpdateConfigPath), (0, qZ.load)(await (0, hs.readFile)(this._appUpdateConfigPath, "utf-8"));
  }
  computeRequestHeaders(t) {
    const r = t.fileExtraDownloadHeaders;
    if (r != null) {
      const n = this.requestHeaders;
      return n == null ? r : {
        ...r,
        ...n
      };
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const t = vi.join(this.app.userDataPath, ".updaterId");
    try {
      const n = await (0, hs.readFile)(t, "utf-8");
      if (Jt.UUID.check(n))
        return n;
      this._logger.warn(`Staging user id file exists, but content was invalid: ${n}`);
    } catch (n) {
      n.code !== "ENOENT" && this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${n}`);
    }
    const r = Jt.UUID.v5((0, UZ.randomBytes)(4096), Jt.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${r}`);
    try {
      await (0, hs.outputFile)(t, r);
    } catch (n) {
      this._logger.warn(`Couldn't write out staging user ID: ${n}`);
    }
    return r;
  }
  /** @internal */
  get isAddNoCacheQuery() {
    const t = this.requestHeaders;
    if (t == null)
      return !0;
    for (const r of Object.keys(t)) {
      const n = r.toLowerCase();
      if (n === "authorization" || n === "private-token")
        return !1;
    }
    return !0;
  }
  async getOrCreateDownloadHelper() {
    let t = this.downloadedUpdateHelper;
    if (t == null) {
      const r = (await this.configOnDisk.value).updaterCacheDirName, n = this._logger;
      r == null && n.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      const i = vi.join(this.app.baseCachePath, r || this.app.name);
      n.debug != null && n.debug(`updater cache dir: ${i}`), t = new uS.DownloadedUpdateHelper(i), this.downloadedUpdateHelper = t;
    }
    return t;
  }
  async executeDownload(t) {
    const r = t.fileInfo, n = {
      headers: t.downloadUpdateOptions.requestHeaders,
      cancellationToken: t.downloadUpdateOptions.cancellationToken,
      sha2: r.info.sha2,
      sha512: r.info.sha512
    };
    this.listenerCount(ms.DOWNLOAD_PROGRESS) > 0 && (n.onProgress = (v) => this.emit(ms.DOWNLOAD_PROGRESS, v));
    const i = t.downloadUpdateOptions.updateInfoAndProvider.info, s = i.version, o = r.packageInfo;
    function a() {
      const v = decodeURIComponent(t.fileInfo.url.pathname);
      return v.endsWith(`.${t.fileExtension}`) ? vi.basename(v) : t.fileInfo.info.url;
    }
    const c = await this.getOrCreateDownloadHelper(), u = c.cacheDirForPendingUpdate;
    await (0, hs.mkdir)(u, { recursive: !0 });
    const l = a();
    let f = vi.join(u, l);
    const m = o == null ? null : vi.join(u, `package-${s}${vi.extname(o.path) || ".7z"}`), p = async (v) => (await c.setDownloadedFile(f, m, i, r, l, v), await t.done({
      ...i,
      downloadedFile: f
    }), m == null ? [f] : [f, m]), d = this._logger, h = await c.validateDownloadedPath(f, i, r, d);
    if (h != null)
      return f = h, await p(!1);
    const _ = async () => (await c.clear().catch(() => {
    }), await (0, hs.unlink)(f).catch(() => {
    })), g = await (0, uS.createTempUpdateFile)(`temp-${l}`, u, d);
    try {
      await t.task(g, n, m, _), await (0, Jt.retry)(() => (0, hs.rename)(g, f), 60, 500, 0, 0, (v) => v instanceof Error && /^EBUSY:/.test(v.message));
    } catch (v) {
      throw await _(), v instanceof Jt.CancellationError && (d.info("cancelled"), this.emit("update-cancelled", i)), v;
    }
    return d.info(`New version ${s} has been downloaded to ${f}`), await p(!0);
  }
  async differentialDownloadInstaller(t, r, n, i, s) {
    try {
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload)
        return !0;
      const o = (0, GZ.blockmapFiles)(t.url, this.app.version, r.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${o[0]}", new: ${o[1]})`);
      const a = async (l) => {
        const f = await this.httpExecutor.downloadToBuffer(l, {
          headers: r.requestHeaders,
          cancellationToken: r.cancellationToken
        });
        if (f == null || f.length === 0)
          throw new Error(`Blockmap "${l.href}" is empty`);
        try {
          return JSON.parse((0, VZ.gunzipSync)(f).toString());
        } catch (m) {
          throw new Error(`Cannot parse blockmap "${l.href}", error: ${m}`);
        }
      }, c = {
        newUrl: t.url,
        oldFile: vi.join(this.downloadedUpdateHelper.cacheDir, s),
        logger: this._logger,
        newFile: n,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        requestHeaders: r.requestHeaders,
        cancellationToken: r.cancellationToken
      };
      this.listenerCount(ms.DOWNLOAD_PROGRESS) > 0 && (c.onProgress = (l) => this.emit(ms.DOWNLOAD_PROGRESS, l));
      const u = await Promise.all(o.map((l) => a(l)));
      return await new WZ.GenericDifferentialDownloader(t.info, this.httpExecutor, c).download(u[0], u[1]), !1;
    } catch (o) {
      if (this._logger.error(`Cannot download differentially, fallback to full download: ${o.stack || o}`), this._testOnlyOptions != null)
        throw o;
      return !0;
    }
  }
}
Zn.AppUpdater = Zy;
function KZ(e) {
  const t = (0, Si.prerelease)(e);
  return t != null && t.length > 0;
}
class dP {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  info(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  warn(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  error(t) {
  }
}
Zn.NoOpLogger = dP;
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.BaseUpdater = void 0;
const dS = _u, YZ = Zn;
class JZ extends YZ.AppUpdater {
  constructor(t, r) {
    super(t, r), this.quitAndInstallCalled = !1, this.quitHandlerAdded = !1;
  }
  quitAndInstall(t = !1, r = !1) {
    this._logger.info("Install on explicit quitAndInstall"), this.install(t, t ? r : this.autoRunAppAfterInstall) ? setImmediate(() => {
      ji.autoUpdater.emit("before-quit-for-update"), this.app.quit();
    }) : this.quitAndInstallCalled = !1;
  }
  executeDownload(t) {
    return super.executeDownload({
      ...t,
      done: (r) => (this.dispatchUpdateDownloaded(r), this.addQuitHandler(), Promise.resolve())
    });
  }
  get installerPath() {
    return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
  }
  // must be sync (because quit even handler is not async)
  install(t = !1, r = !1) {
    if (this.quitAndInstallCalled)
      return this._logger.warn("install call ignored: quitAndInstallCalled is set to true"), !1;
    const n = this.downloadedUpdateHelper, i = this.installerPath, s = n == null ? null : n.downloadedFileInfo;
    if (i == null || s == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    this.quitAndInstallCalled = !0;
    try {
      return this._logger.info(`Install: isSilent: ${t}, isForceRunAfter: ${r}`), this.doInstall({
        isSilent: t,
        isForceRunAfter: r,
        isAdminRightsRequired: s.isAdminRightsRequired
      });
    } catch (o) {
      return this.dispatchError(o), !1;
    }
  }
  addQuitHandler() {
    this.quitHandlerAdded || !this.autoInstallOnAppQuit || (this.quitHandlerAdded = !0, this.app.onQuit((t) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (t !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${t}`);
        return;
      }
      this._logger.info("Auto install update on quit"), this.install(!0, !1);
    }));
  }
  wrapSudo() {
    const { name: t } = this.app, r = `"${t} would like to update"`, n = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu"), i = [n];
    return /kdesudo/i.test(n) ? (i.push("--comment", r), i.push("-c")) : /gksudo/i.test(n) ? i.push("--message", r) : /pkexec/i.test(n) && i.push("--disable-internal-agent"), i.join(" ");
  }
  spawnSyncLog(t, r = [], n = {}) {
    this._logger.info(`Executing: ${t} with args: ${r}`);
    const i = (0, dS.spawnSync)(t, r, {
      env: { ...process.env, ...n },
      encoding: "utf-8",
      shell: !0
    }), { error: s, status: o, stdout: a, stderr: c } = i;
    if (s != null)
      throw this._logger.error(c), s;
    if (o != null && o !== 0)
      throw this._logger.error(c), new Error(`Command ${t} exited with code ${o}`);
    return a.trim();
  }
  /**
   * This handles both node 8 and node 10 way of emitting error when spawning a process
   *   - node 8: Throws the error
   *   - node 10: Emit the error(Need to listen with on)
   */
  // https://github.com/electron-userland/electron-builder/issues/1129
  // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
  async spawnLog(t, r = [], n = void 0, i = "ignore") {
    return this._logger.info(`Executing: ${t} with args: ${r}`), new Promise((s, o) => {
      try {
        const a = { stdio: i, env: n, detached: !0 }, c = (0, dS.spawn)(t, r, a);
        c.on("error", (u) => {
          o(u);
        }), c.unref(), c.pid !== void 0 && s(!0);
      } catch (a) {
        o(a);
      }
    });
  }
}
xn.BaseUpdater = JZ;
var xa = {}, fc = {};
Object.defineProperty(fc, "__esModule", { value: !0 });
fc.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const gs = ni, XZ = uc, ZZ = Or;
class QZ extends XZ.DifferentialDownloader {
  async download() {
    const t = this.blockAwareFileInfo, r = t.size, n = r - (t.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(n, r - 1);
    const i = pP(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await eQ(this.options.oldFile), i);
  }
}
fc.FileWithEmbeddedBlockMapDifferentialDownloader = QZ;
function pP(e) {
  return JSON.parse((0, ZZ.inflateRawSync)(e).toString());
}
async function eQ(e) {
  const t = await (0, gs.open)(e, "r");
  try {
    const r = (await (0, gs.fstat)(t)).size, n = Buffer.allocUnsafe(4);
    await (0, gs.read)(t, n, 0, n.length, r - n.length);
    const i = Buffer.allocUnsafe(n.readUInt32BE(0));
    return await (0, gs.read)(t, i, 0, i.length, r - n.length - i.length), await (0, gs.close)(t), pP(i);
  } catch (r) {
    throw await (0, gs.close)(t), r;
  }
}
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.AppImageUpdater = void 0;
const pS = Rt, hS = _u, tQ = ni, rQ = Ye, Ho = we, nQ = xn, iQ = fc, sQ = vt, mS = ii;
class oQ extends nQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  isUpdaterActive() {
    return process.env.APPIMAGE == null ? (process.env.SNAP == null ? this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage") : this._logger.info("SNAP env is defined, updater is disabled"), !1) : super.isUpdaterActive();
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, sQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        const o = process.env.APPIMAGE;
        if (o == null)
          throw (0, pS.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        (t.disableDifferentialDownload || await this.downloadDifferential(n, o, i, r, t)) && await this.httpExecutor.download(n.url, i, s), await (0, tQ.chmod)(i, 493);
      }
    });
  }
  async downloadDifferential(t, r, n, i, s) {
    try {
      const o = {
        newUrl: t.url,
        oldFile: r,
        logger: this._logger,
        newFile: n,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        requestHeaders: s.requestHeaders,
        cancellationToken: s.cancellationToken
      };
      return this.listenerCount(mS.DOWNLOAD_PROGRESS) > 0 && (o.onProgress = (a) => this.emit(mS.DOWNLOAD_PROGRESS, a)), await new iQ.FileWithEmbeddedBlockMapDifferentialDownloader(t.info, this.httpExecutor, o).download(), !1;
    } catch (o) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${o.stack || o}`), process.platform === "linux";
    }
  }
  doInstall(t) {
    const r = process.env.APPIMAGE;
    if (r == null)
      throw (0, pS.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    (0, rQ.unlinkSync)(r);
    let n;
    const i = Ho.basename(r), s = this.installerPath;
    if (s == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    Ho.basename(s) === i || !/\d+\.\d+\.\d+/.test(i) ? n = r : n = Ho.join(Ho.dirname(r), Ho.basename(s)), (0, hS.execFileSync)("mv", ["-f", s, n]), n !== r && this.emit("appimage-filename-updated", n);
    const o = {
      ...process.env,
      APPIMAGE_SILENT_INSTALL: "true"
    };
    return t.isForceRunAfter ? this.spawnLog(n, [], o) : (o.APPIMAGE_EXIT_AFTER_INSTALL = "true", (0, hS.execFileSync)(n, [], { env: o })), !0;
  }
}
xa.AppImageUpdater = oQ;
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.DebUpdater = void 0;
const aQ = xn, cQ = vt, gS = ii;
class lQ extends aQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, cQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        this.listenerCount(gS.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(gS.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(n.url, i, s);
      }
    });
  }
  get installerPath() {
    var t, r;
    return (r = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && r !== void 0 ? r : null;
  }
  doInstall(t) {
    const r = this.wrapSudo(), n = /pkexec/i.test(r) ? "" : '"', i = this.installerPath;
    if (i == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const s = ["dpkg", "-i", i, "||", "apt-get", "install", "-f", "-y"];
    return this.spawnSyncLog(r, [`${n}/bin/bash`, "-c", `'${s.join(" ")}'${n}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
Ra.DebUpdater = lQ;
var $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.PacmanUpdater = void 0;
const uQ = xn, yS = ii, fQ = vt;
class dQ extends uQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, fQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
    return this.executeDownload({
      fileExtension: "pacman",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        this.listenerCount(yS.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(yS.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(n.url, i, s);
      }
    });
  }
  get installerPath() {
    var t, r;
    return (r = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && r !== void 0 ? r : null;
  }
  doInstall(t) {
    const r = this.wrapSudo(), n = /pkexec/i.test(r) ? "" : '"', i = this.installerPath;
    if (i == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const s = ["pacman", "-U", "--noconfirm", i];
    return this.spawnSyncLog(r, [`${n}/bin/bash`, "-c", `'${s.join(" ")}'${n}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
$a.PacmanUpdater = dQ;
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.RpmUpdater = void 0;
const pQ = xn, vS = ii, hQ = vt;
class mQ extends pQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, hQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        this.listenerCount(vS.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(vS.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(n.url, i, s);
      }
    });
  }
  get installerPath() {
    var t, r;
    return (r = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && r !== void 0 ? r : null;
  }
  doInstall(t) {
    const r = this.wrapSudo(), n = /pkexec/i.test(r) ? "" : '"', i = this.spawnSyncLog("which zypper"), s = this.installerPath;
    if (s == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    let o;
    return i ? o = [i, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", s] : o = [this.spawnSyncLog("which dnf || which yum"), "-y", "install", s], this.spawnSyncLog(r, [`${n}/bin/bash`, "-c", `'${o.join(" ")}'${n}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
Ta.RpmUpdater = mQ;
var Oa = {};
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.MacUpdater = void 0;
const _S = Rt, ih = ni, gQ = Ye, bS = we, yQ = yu, vQ = Zn, _Q = vt, ES = _u, wS = Gi;
class bQ extends vQ.AppUpdater {
  constructor(t, r) {
    super(t, r), this.nativeUpdater = ji.autoUpdater, this.squirrelDownloadedUpdate = !1, this.nativeUpdater.on("error", (n) => {
      this._logger.warn(n), this.emit("error", n);
    }), this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = !0, this.debug("nativeUpdater.update-downloaded");
    });
  }
  debug(t) {
    this._logger.debug != null && this._logger.debug(t);
  }
  closeServerIfExists() {
    this.server && (this.debug("Closing proxy server"), this.server.close((t) => {
      t && this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
    }));
  }
  async doDownloadUpdate(t) {
    let r = t.updateInfoAndProvider.provider.resolveFiles(t.updateInfoAndProvider.info);
    const n = this._logger, i = "sysctl.proc_translated";
    let s = !1;
    try {
      this.debug("Checking for macOS Rosetta environment"), s = (0, ES.execFileSync)("sysctl", [i], { encoding: "utf8" }).includes(`${i}: 1`), n.info(`Checked for macOS Rosetta environment (isRosetta=${s})`);
    } catch (f) {
      n.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${f}`);
    }
    let o = !1;
    try {
      this.debug("Checking for arm64 in uname");
      const m = (0, ES.execFileSync)("uname", ["-a"], { encoding: "utf8" }).includes("ARM");
      n.info(`Checked 'uname -a': arm64=${m}`), o = o || m;
    } catch (f) {
      n.warn(`uname shell command to check for arm64 failed: ${f}`);
    }
    o = o || process.arch === "arm64" || s;
    const a = (f) => {
      var m;
      return f.url.pathname.includes("arm64") || ((m = f.info.url) === null || m === void 0 ? void 0 : m.includes("arm64"));
    };
    o && r.some(a) ? r = r.filter((f) => o === a(f)) : r = r.filter((f) => !a(f));
    const c = (0, _Q.findFile)(r, "zip", ["pkg", "dmg"]);
    if (c == null)
      throw (0, _S.newError)(`ZIP file not provided: ${(0, _S.safeStringifyJson)(r)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    const u = t.updateInfoAndProvider.provider, l = "update.zip";
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: c,
      downloadUpdateOptions: t,
      task: async (f, m) => {
        const p = bS.join(this.downloadedUpdateHelper.cacheDir, l), d = () => (0, ih.pathExistsSync)(p) ? !t.disableDifferentialDownload : (n.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download"), !1);
        let h = !0;
        d() && (h = await this.differentialDownloadInstaller(c, t, f, u, l)), h && await this.httpExecutor.download(c.url, f, m);
      },
      done: async (f) => {
        if (!t.disableDifferentialDownload)
          try {
            const m = bS.join(this.downloadedUpdateHelper.cacheDir, l);
            await (0, ih.copyFile)(f.downloadedFile, m);
          } catch (m) {
            this._logger.warn(`Unable to copy file for caching for future differential downloads: ${m.message}`);
          }
        return this.updateDownloaded(c, f);
      }
    });
  }
  async updateDownloaded(t, r) {
    var n;
    const i = r.downloadedFile, s = (n = t.info.size) !== null && n !== void 0 ? n : (await (0, ih.stat)(i)).size, o = this._logger, a = `fileToProxy=${t.url.href}`;
    this.closeServerIfExists(), this.debug(`Creating proxy server for native Squirrel.Mac (${a})`), this.server = (0, yQ.createServer)(), this.debug(`Proxy server for native Squirrel.Mac is created (${a})`), this.server.on("close", () => {
      o.info(`Proxy server for native Squirrel.Mac is closed (${a})`);
    });
    const c = (u) => {
      const l = u.address();
      return typeof l == "string" ? l : `http://127.0.0.1:${l == null ? void 0 : l.port}`;
    };
    return await new Promise((u, l) => {
      const f = (0, wS.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-"), m = Buffer.from(`autoupdater:${f}`, "ascii"), p = `/${(0, wS.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (d, h) => {
        const _ = d.url;
        if (o.info(`${_} requested`), _ === "/") {
          if (!d.headers.authorization || d.headers.authorization.indexOf("Basic ") === -1) {
            h.statusCode = 401, h.statusMessage = "Invalid Authentication Credentials", h.end(), o.warn("No authenthication info");
            return;
          }
          const y = d.headers.authorization.split(" ")[1], E = Buffer.from(y, "base64").toString("ascii"), [R, w] = E.split(":");
          if (R !== "autoupdater" || w !== f) {
            h.statusCode = 401, h.statusMessage = "Invalid Authentication Credentials", h.end(), o.warn("Invalid authenthication credentials");
            return;
          }
          const C = Buffer.from(`{ "url": "${c(this.server)}${p}" }`);
          h.writeHead(200, { "Content-Type": "application/json", "Content-Length": C.length }), h.end(C);
          return;
        }
        if (!_.startsWith(p)) {
          o.warn(`${_} requested, but not supported`), h.writeHead(404), h.end();
          return;
        }
        o.info(`${p} requested by Squirrel.Mac, pipe ${i}`);
        let g = !1;
        h.on("finish", () => {
          g || (this.nativeUpdater.removeListener("error", l), u([]));
        });
        const v = (0, gQ.createReadStream)(i);
        v.on("error", (y) => {
          try {
            h.end();
          } catch (E) {
            o.warn(`cannot end response: ${E}`);
          }
          g = !0, this.nativeUpdater.removeListener("error", l), l(new Error(`Cannot pipe "${i}": ${y}`));
        }), h.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": s
        }), v.pipe(h);
      }), this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${a})`), this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${c(this.server)}, ${a})`), this.nativeUpdater.setFeedURL({
          url: c(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${m.toString("base64")}`
          }
        }), this.dispatchUpdateDownloaded(r), this.autoInstallOnAppQuit ? (this.nativeUpdater.once("error", l), this.nativeUpdater.checkForUpdates()) : u([]);
      });
    });
  }
  handleUpdateDownloaded() {
    this.autoRunAppAfterInstall ? this.nativeUpdater.quitAndInstall() : this.app.quit(), this.closeServerIfExists();
  }
  quitAndInstall() {
    this.squirrelDownloadedUpdate ? this.handleUpdateDownloaded() : (this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded()), this.autoInstallOnAppQuit || this.nativeUpdater.checkForUpdates());
  }
}
Oa.MacUpdater = bQ;
var Pa = {}, Qy = {};
Object.defineProperty(Qy, "__esModule", { value: !0 });
Qy.verifySignature = wQ;
const SS = Rt, hP = _u, EQ = vu, xS = we;
function wQ(e, t, r) {
  return new Promise((n, i) => {
    const s = t.replace(/'/g, "''");
    r.info(`Verifying signature ${s}`), (0, hP.execFile)('set "PSModulePath=" & chcp 65001 >NUL & powershell.exe', ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${s}' | ConvertTo-Json -Compress"`], {
      shell: !0,
      timeout: 20 * 1e3
    }, (o, a, c) => {
      var u;
      try {
        if (o != null || c) {
          sh(r, o, c, i), n(null);
          return;
        }
        const l = SQ(a);
        if (l.Status === 0) {
          try {
            const d = xS.normalize(l.Path), h = xS.normalize(t);
            if (r.info(`LiteralPath: ${d}. Update Path: ${h}`), d !== h) {
              sh(r, new Error(`LiteralPath of ${d} is different than ${h}`), c, i), n(null);
              return;
            }
          } catch (d) {
            r.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(u = d.message) !== null && u !== void 0 ? u : d.stack}`);
          }
          const m = (0, SS.parseDn)(l.SignerCertificate.Subject);
          let p = !1;
          for (const d of e) {
            const h = (0, SS.parseDn)(d);
            if (h.size ? p = Array.from(h.keys()).every((g) => h.get(g) === m.get(g)) : d === m.get("CN") && (r.warn(`Signature validated using only CN ${d}. Please add your full Distinguished Name (DN) to publisherNames configuration`), p = !0), p) {
              n(null);
              return;
            }
          }
        }
        const f = `publisherNames: ${e.join(" | ")}, raw info: ` + JSON.stringify(l, (m, p) => m === "RawData" ? void 0 : p, 2);
        r.warn(`Sign verification failed, installer signed with incorrect certificate: ${f}`), n(f);
      } catch (l) {
        sh(r, l, null, i), n(null);
        return;
      }
    });
  });
}
function SQ(e) {
  const t = JSON.parse(e);
  delete t.PrivateKey, delete t.IsOSBinary, delete t.SignatureType;
  const r = t.SignerCertificate;
  return r != null && (delete r.Archived, delete r.Extensions, delete r.Handle, delete r.HasPrivateKey, delete r.SubjectName), t;
}
function sh(e, t, r, n) {
  if (xQ()) {
    e.warn(`Cannot execute Get-AuthenticodeSignature: ${t || r}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    (0, hP.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (i) {
    e.warn(`Cannot execute ConvertTo-Json: ${i.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  t != null && n(t), r && n(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${r}. Failing signature validation due to unknown stderr.`));
}
function xQ() {
  const e = EQ.release();
  return e.startsWith("6.") && !e.startsWith("6.3");
}
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.NsisUpdater = void 0;
const ol = Rt, RS = we, RQ = xn, $Q = fc, $S = ii, TQ = vt, OQ = ni, PQ = Qy, TS = Hr;
class CQ extends RQ.BaseUpdater {
  constructor(t, r) {
    super(t, r), this._verifyUpdateCodeSignature = (n, i) => (0, PQ.verifySignature)(n, i, this._logger);
  }
  /**
   * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
   * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
   */
  get verifyUpdateCodeSignature() {
    return this._verifyUpdateCodeSignature;
  }
  set verifyUpdateCodeSignature(t) {
    t && (this._verifyUpdateCodeSignature = t);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, TQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions: t,
      fileInfo: n,
      task: async (i, s, o, a) => {
        const c = n.packageInfo, u = c != null && o != null;
        if (u && t.disableWebInstaller)
          throw (0, ol.newError)(`Unable to download new version ${t.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        !u && !t.disableWebInstaller && this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version."), (u || t.disableDifferentialDownload || await this.differentialDownloadInstaller(n, t, i, r, ol.CURRENT_APP_INSTALLER_FILE_NAME)) && await this.httpExecutor.download(n.url, i, s);
        const l = await this.verifySignature(i);
        if (l != null)
          throw await a(), (0, ol.newError)(`New version ${t.updateInfoAndProvider.info.version} is not signed by the application owner: ${l}`, "ERR_UPDATER_INVALID_SIGNATURE");
        if (u && await this.differentialDownloadWebPackage(t, c, o, r))
          try {
            await this.httpExecutor.download(new TS.URL(c.path), o, {
              headers: t.requestHeaders,
              cancellationToken: t.cancellationToken,
              sha512: c.sha512
            });
          } catch (f) {
            try {
              await (0, OQ.unlink)(o);
            } catch {
            }
            throw f;
          }
      }
    });
  }
  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
  async verifySignature(t) {
    let r;
    try {
      if (r = (await this.configOnDisk.value).publisherName, r == null)
        return null;
    } catch (n) {
      if (n.code === "ENOENT")
        return null;
      throw n;
    }
    return await this._verifyUpdateCodeSignature(Array.isArray(r) ? r : [r], t);
  }
  doInstall(t) {
    const r = this.installerPath;
    if (r == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const n = ["--updated"];
    t.isSilent && n.push("/S"), t.isForceRunAfter && n.push("--force-run"), this.installDirectory && n.push(`/D=${this.installDirectory}`);
    const i = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    i != null && n.push(`--package-file=${i}`);
    const s = () => {
      this.spawnLog(RS.join(process.resourcesPath, "elevate.exe"), [r].concat(n)).catch((o) => this.dispatchError(o));
    };
    return t.isAdminRightsRequired ? (this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe"), s(), !0) : (this.spawnLog(r, n).catch((o) => {
      const a = o.code;
      this._logger.info(`Cannot run installer: error code: ${a}, error message: "${o.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`), a === "UNKNOWN" || a === "EACCES" ? s() : a === "ENOENT" ? ji.shell.openPath(r).catch((c) => this.dispatchError(c)) : this.dispatchError(o);
    }), !0);
  }
  async differentialDownloadWebPackage(t, r, n, i) {
    if (r.blockMapSize == null)
      return !0;
    try {
      const s = {
        newUrl: new TS.URL(r.path),
        oldFile: RS.join(this.downloadedUpdateHelper.cacheDir, ol.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: n,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        cancellationToken: t.cancellationToken
      };
      this.listenerCount($S.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit($S.DOWNLOAD_PROGRESS, o)), await new $Q.FileWithEmbeddedBlockMapDifferentialDownloader(r, this.httpExecutor, s).download();
    } catch (s) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${s.stack || s}`), process.platform === "win32";
    }
    return !1;
  }
}
Pa.NsisUpdater = CQ;
(function(e) {
  var t = me && me.__createBinding || (Object.create ? function(_, g, v, y) {
    y === void 0 && (y = v);
    var E = Object.getOwnPropertyDescriptor(g, v);
    (!E || ("get" in E ? !g.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
      return g[v];
    } }), Object.defineProperty(_, y, E);
  } : function(_, g, v, y) {
    y === void 0 && (y = v), _[y] = g[v];
  }), r = me && me.__exportStar || function(_, g) {
    for (var v in _) v !== "default" && !Object.prototype.hasOwnProperty.call(g, v) && t(g, _, v);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.NsisUpdater = e.MacUpdater = e.RpmUpdater = e.PacmanUpdater = e.DebUpdater = e.AppImageUpdater = e.Provider = e.NoOpLogger = e.AppUpdater = e.BaseUpdater = void 0;
  const n = ni, i = we;
  var s = xn;
  Object.defineProperty(e, "BaseUpdater", { enumerable: !0, get: function() {
    return s.BaseUpdater;
  } });
  var o = Zn;
  Object.defineProperty(e, "AppUpdater", { enumerable: !0, get: function() {
    return o.AppUpdater;
  } }), Object.defineProperty(e, "NoOpLogger", { enumerable: !0, get: function() {
    return o.NoOpLogger;
  } });
  var a = vt;
  Object.defineProperty(e, "Provider", { enumerable: !0, get: function() {
    return a.Provider;
  } });
  var c = xa;
  Object.defineProperty(e, "AppImageUpdater", { enumerable: !0, get: function() {
    return c.AppImageUpdater;
  } });
  var u = Ra;
  Object.defineProperty(e, "DebUpdater", { enumerable: !0, get: function() {
    return u.DebUpdater;
  } });
  var l = $a;
  Object.defineProperty(e, "PacmanUpdater", { enumerable: !0, get: function() {
    return l.PacmanUpdater;
  } });
  var f = Ta;
  Object.defineProperty(e, "RpmUpdater", { enumerable: !0, get: function() {
    return f.RpmUpdater;
  } });
  var m = Oa;
  Object.defineProperty(e, "MacUpdater", { enumerable: !0, get: function() {
    return m.MacUpdater;
  } });
  var p = Pa;
  Object.defineProperty(e, "NsisUpdater", { enumerable: !0, get: function() {
    return p.NsisUpdater;
  } }), r(ii, e);
  let d;
  function h() {
    if (process.platform === "win32")
      d = new Pa.NsisUpdater();
    else if (process.platform === "darwin")
      d = new Oa.MacUpdater();
    else {
      d = new xa.AppImageUpdater();
      try {
        const _ = i.join(process.resourcesPath, "package-type");
        if (!(0, n.existsSync)(_))
          return d;
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const g = (0, n.readFileSync)(_).toString().trim();
        switch (console.info("Found package-type:", g), g) {
          case "deb":
            d = new Ra.DebUpdater();
            break;
          case "rpm":
            d = new Ta.RpmUpdater();
            break;
          case "pacman":
            d = new $a.PacmanUpdater();
            break;
          default:
            break;
        }
      } catch (_) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", _.message);
      }
    }
    return d;
  }
  Object.defineProperty(e, "autoUpdater", {
    enumerable: !0,
    get: () => d || h()
  });
})(bs);
class AQ {
  constructor() {
    Te(this, "updateInProgress");
    this.updateInProgress = !1;
  }
  // 检查更新
  async checkUpdate() {
    this.updateInProgress || (this.updateInProgress = !0, bs.autoUpdater.checkForUpdates(), bs.autoUpdater.on("update-not-available", () => {
      this.updateInProgress = !1;
    }), bs.autoUpdater.on("error", () => {
      this.updateInProgress = !1;
    }), bs.autoUpdater.on("update-downloaded", () => {
      lC.showMessageBox({
        type: "info",
        title: "更新已下载",
        message: "新版本已准备好，是否现在安装？",
        buttons: ["安装并重启", "稍后"]
      }).then((t) => {
        t.response === 0 && bs.autoUpdater.quitAndInstall(), this.updateInProgress = !1;
      });
    }));
  }
}
const mP = hn.dirname(pC(import.meta.url));
process.env.APP_ROOT = hn.join(mP, "..");
const sm = process.env.VITE_DEV_SERVER_URL, Mee = hn.join(process.env.APP_ROOT, "dist-electron"), gP = hn.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = sm ? hn.join(process.env.APP_ROOT, "public") : gP;
let Ke, xe = null;
const IQ = new AQ();
function OS(e) {
  const r = (process.memoryUsage().rss / 1024 / 1024).toFixed(1);
  e == null || e.webContents.send("memory-usage", r);
}
function yP() {
  Ke = new AS({
=======
      const n = new s3(t);
      return await new Promise((s, i) => {
        n.extractAllToAsync(r, !0, (o) => {
          o ? i(o) : (this.sendLog("✅ 解压文件完成", "SUCCESS"), vt.unlinkSync(t), s(!0));
        });
      });
    } catch (n) {
      return this.sendLog(`解压文件失败: ${n}`, "ERROR"), vt.unlinkSync(t), !1;
    }
  }
}
const rS = vr.dirname(mS(import.meta.url));
process.env.APP_ROOT = vr.join(rS, "..");
const Mu = process.env.VITE_DEV_SERVER_URL, h4 = vr.join(process.env.APP_ROOT, "dist-electron"), nS = vr.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Mu ? vr.join(process.env.APP_ROOT, "public") : nS;
let Le, he = null;
function dv(e) {
  const r = (process.memoryUsage().rss / 1024 / 1024).toFixed(1);
  e == null || e.webContents.send("memory-usage", r);
}
function sS() {
  Le = new mv({
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
    width: 1200,
    height: 800,
    minWidth: 1200,
    minHeight: 800,
<<<<<<< HEAD
    icon: hn.join(process.env.VITE_PUBLIC, "logo.png"),
    webPreferences: {
      preload: hn.join(mP, "preload.mjs")
    }
  }), xe = new sW(Ke), Ke.webContents.on("did-finish-load", () => {
    OS(Ke), xe == null || xe.registerSchedule("*/2 * * * *", () => {
      OS(Ke);
    }), xe == null || xe.registerSchedule("0 */12 * * *", async () => {
      const e = await (xe == null ? void 0 : xe.checkUpdate());
      IQ.checkUpdate(), Ke == null || Ke.webContents.send("wcf:checkUpdateNotiy", e);
    }), Ke == null || Ke.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString()), xe == null || xe.reportConfig();
  }), sm ? (Ke.loadURL(sm), Ke.webContents.openDevTools()) : Ke.loadFile(hn.join(gP, "index.html")), ar.handle("wcf:checkUpdate", xe.checkUpdate), ar.handle("wcf:checkWCF", xe.checkWCF), ar.handle("wcf:downloadWCF", xe.downloadWCF), ar.handle("wcf:chekWcfIsRun", xe.checkWCFIsRun), ar.handle("wcf:startWcfHttpServer", xe.startWcfServer), ar.handle("wcf:closeWcfHttpServer", xe.closeWcfServer), ar.handle("wcf:updateConfig", xe.modifyWCFConfig), ar.handle("wcf:config", xe.getWCFConfig), ar.handle("wcf:restartWcf", xe.restartWCF), ar.handle("wcf:closeWcf", xe.closeWCF), ar.handle("wcf:startWCF", xe.startWCF), ar.handle("wcf:resetWcf", xe.resetWCF), ar.handle("wcf:injectVersionWcf", (e, t) => xe == null ? void 0 : xe.injectVersionDll(t.version, t.download_wechat || !1)), ar.handle("open:url", (e, t) => {
    uC.openExternal(t);
  }), fC.register("CommandOrControl+Shift+I", () => {
    Ke == null || Ke.webContents.toggleDevTools();
  });
}
const NQ = CS.buildFromTemplate([]);
CS.setApplicationMenu(NQ);
js.on("window-all-closed", () => {
  process.platform !== "darwin" && (js.quit(), xe == null || xe.closeWcfServer(), xe == null || xe.clearSchedule(), xe == null || xe.closeWCF(), Ke = null, xe = null);
});
js.on("activate", () => {
  AS.getAllWindows().length === 0 && yP();
});
process.on("uncaughtException", (e) => {
  Ke == null || Ke.webContents.send("unhandledRejection", e.message);
});
process.on("unhandledRejection", (e) => {
  Ke == null || Ke.webContents.send("unhandledRejection", e.message);
});
js.whenReady().then(yP);
export {
  Mee as MAIN_DIST,
  gP as RENDERER_DIST,
  sm as VITE_DEV_SERVER_URL
=======
    icon: vr.join(process.env.VITE_PUBLIC, "logo.png"),
    webPreferences: {
      preload: vr.join(rS, "preload.mjs")
    }
  }), he = new c3(Le), Le.webContents.on("did-finish-load", () => {
    dv(Le), he == null || he.registerSchedule("*/2 * * * *", () => {
      dv(Le);
    }), he == null || he.registerSchedule("0 */12 * * *", async () => {
      const e = await (he == null ? void 0 : he.checkUpdate());
      Le == null || Le.webContents.send("wcf:checkUpdateNotiy", e);
    }), Le == null || Le.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString()), he == null || he.reportConfig();
  }), Mu ? (Le.loadURL(Mu), Le.webContents.openDevTools()) : Le.loadFile(vr.join(nS, "index.html")), $t.handle("wcf:checkUpdate", he.checkUpdate), $t.handle("wcf:checkWCF", he.checkWCF), $t.handle("wcf:downloadWCF", he.downloadWCF), $t.handle("wcf:chekWcfIsRun", he.checkWCFIsRun), $t.handle("wcf:startWcfHttpServer", he.startWcfServer), $t.handle("wcf:closeWcfHttpServer", he.closeWcfServer), $t.handle("wcf:updateConfig", he.modifyWCFConfig), $t.handle("wcf:config", he.getWCFConfig), $t.handle("wcf:restartWcf", he.restartWCF), $t.handle("wcf:closeWcf", he.closeWCF), $t.handle("wcf:startWCF", he.startWCF), $t.handle("wcf:resetWcf", he.resetWCF), $t.handle("wcf:injectVersionWcf", (e, t) => he == null ? void 0 : he.injectVersionDll(t.version, t.download_wechat || !1)), $t.handle("open:url", (e, t) => {
    dS.openExternal(t);
  }), pS.register("CommandOrControl+Shift+I", () => {
    Le == null || Le.webContents.toggleDevTools();
  });
}
const l3 = hv.buildFromTemplate([]);
hv.setApplicationMenu(l3);
Gn.on("window-all-closed", () => {
  process.platform !== "darwin" && (Gn.quit(), he == null || he.closeWcfServer(), he == null || he.clearSchedule(), he == null || he.closeWCF(), Le = null, he = null);
});
Gn.on("activate", () => {
  mv.getAllWindows().length === 0 && sS();
});
process.on("uncaughtException", (e) => {
  Le == null || Le.webContents.send("unhandledRejection", e.message);
});
process.on("unhandledRejection", (e) => {
  Le == null || Le.webContents.send("unhandledRejection", e.message);
});
Gn.whenReady().then(sS);
export {
  h4 as MAIN_DIST,
  nS as RENDERER_DIST,
  Mu as VITE_DEV_SERVER_URL
>>>>>>> 3e21c46cae713b2c153e7c3d0b1e7d403b3b1cca
};
