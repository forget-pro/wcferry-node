var lC = Object.defineProperty;
var fv = (e) => {
  throw TypeError(e);
};
var uC = (e, t, r) => t in e ? lC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var we = (e, t, r) => uC(e, typeof t != "symbol" ? t + "" : t, r), jf = (e, t, r) => t.has(e) || fv("Cannot " + r);
var pt = (e, t, r) => (jf(e, t, "read from private field"), r ? r.call(e) : t.get(e)), pi = (e, t, r) => t.has(e) ? fv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), ns = (e, t, r, n) => (jf(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), ar = (e, t, r) => (jf(e, t, "access private method"), r);
import Mi, { app as yr, dialog as fC, Menu as AS, BrowserWindow as IS, ipcMain as Bt, shell as dC, globalShortcut as pC } from "electron";
import hC, { fileURLToPath as mC } from "node:url";
import { createRequire as gC } from "node:module";
import mu from "node:events";
import Gi from "node:util";
import gu from "node:http";
import am from "node:diagnostics_channel";
import yC from "node:https";
import vC from "node:dns";
import NS from "node:os";
import ka from "node:stream";
import Ue from "fs";
import yu, { EventEmitter as _C } from "events";
import Sn from "util";
import _e from "path";
import Da from "assert";
import kS from "worker_threads";
import bC from "module";
import mn from "node:path";
import qr from "url";
import EC from "buffer";
import wC from "node:async_hooks";
import Wi from "node:assert";
import SC from "node:crypto";
import It, { Readable as xC } from "stream";
import vu from "http";
import cm from "https";
import Ki from "crypto";
import DS from "tty";
import _u from "os";
import Pr from "zlib";
import bu, { execSync as cl } from "child_process";
import RC from "constants";
import $C from "string_decoder";
var me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function La(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Fa = { exports: {} }, lm = { exports: {} };
function TC(e) {
  var t = new e(), r = t;
  function n() {
    var s = t;
    return s.next ? t = s.next : (t = new e(), r = t), s.next = null, s;
  }
  function i(s) {
    r.next = s, r = s;
  }
  return {
    get: n,
    release: i
  };
}
var OC = TC, PC = OC;
function LS(e, t, r) {
  if (typeof e == "function" && (r = t, t = e, e = null), !(r >= 1))
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var n = PC(CC), i = null, s = null, o = 0, a = null, c = {
    push: h,
    drain: Or,
    saturated: Or,
    pause: l,
    paused: !1,
    get concurrency() {
      return r;
    },
    set concurrency(R) {
      if (!(R >= 1))
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      if (r = R, !c.paused)
        for (; i && o < r; )
          o++, g();
    },
    running: u,
    resume: p,
    idle: d,
    length: f,
    getQueue: m,
    unshift: _,
    empty: Or,
    kill: v,
    killAndDrain: y,
    error: E
  };
  return c;
  function u() {
    return o;
  }
  function l() {
    c.paused = !0;
  }
  function f() {
    for (var R = i, w = 0; R; )
      R = R.next, w++;
    return w;
  }
  function m() {
    for (var R = i, w = []; R; )
      w.push(R.value), R = R.next;
    return w;
  }
  function p() {
    if (c.paused) {
      if (c.paused = !1, i === null) {
        o++, g();
        return;
      }
      for (; i && o < r; )
        o++, g();
    }
  }
  function d() {
    return o === 0 && c.length() === 0;
  }
  function h(R, w) {
    var C = n.get();
    C.context = e, C.release = g, C.value = R, C.callback = w || Or, C.errorHandler = a, o >= r || c.paused ? s ? (s.next = C, s = C) : (i = C, s = C, c.saturated()) : (o++, t.call(e, C.value, C.worked));
  }
  function _(R, w) {
    var C = n.get();
    C.context = e, C.release = g, C.value = R, C.callback = w || Or, C.errorHandler = a, o >= r || c.paused ? i ? (C.next = i, i = C) : (i = C, s = C, c.saturated()) : (o++, t.call(e, C.value, C.worked));
  }
  function g(R) {
    R && n.release(R);
    var w = i;
    w && o <= r ? c.paused ? o-- : (s === i && (s = null), i = w.next, w.next = null, t.call(e, w.value, w.worked), s === null && c.empty()) : --o === 0 && c.drain();
  }
  function v() {
    i = null, s = null, c.drain = Or;
  }
  function y() {
    i = null, s = null, c.drain(), c.drain = Or;
  }
  function E(R) {
    a = R;
  }
}
function Or() {
}
function CC() {
  this.value = null, this.callback = Or, this.next = null, this.release = Or, this.context = null, this.errorHandler = null;
  var e = this;
  this.worked = function(r, n) {
    var i = e.callback, s = e.errorHandler, o = e.value;
    e.value = null, e.callback = Or, e.errorHandler && s(r, o), i.call(e.context, r, n), e.release(e);
  };
}
function AC(e, t, r) {
  typeof e == "function" && (r = t, t = e, e = null);
  function n(l, f) {
    t.call(this, l).then(function(m) {
      f(null, m);
    }, f);
  }
  var i = LS(e, n, r), s = i.push, o = i.unshift;
  return i.push = a, i.unshift = c, i.drained = u, i;
  function a(l) {
    var f = new Promise(function(m, p) {
      s(l, function(d, h) {
        if (d) {
          p(d);
          return;
        }
        m(h);
      });
    });
    return f.catch(Or), f;
  }
  function c(l) {
    var f = new Promise(function(m, p) {
      o(l, function(d, h) {
        if (d) {
          p(d);
          return;
        }
        m(h);
      });
    });
    return f.catch(Or), f;
  }
  function u() {
    var l = new Promise(function(f) {
      process.nextTick(function() {
        if (i.idle())
          f();
        else {
          var m = i.drain;
          i.drain = function() {
            typeof m == "function" && m(), f(), i.drain = m;
          };
        }
      });
    });
    return l;
  }
}
lm.exports = LS;
lm.exports.promise = AC;
var IC = lm.exports, Eu = { exports: {} };
const { format: NC } = Gi;
function kC() {
  return `${this.name} [${this.code}]: ${this.message}`;
}
function ja(e, t, r = 500, n = Error, i = ja.captureStackTrace) {
  if (!e) throw new Error("Fastify error code must not be empty");
  if (!t) throw new Error("Fastify error message must not be empty");
  e = e.toUpperCase(), !r && (r = void 0);
  function s(...o) {
    if (!new.target)
      return new s(...o);
    this.code = e, this.name = "FastifyError", this.statusCode = r;
    const a = o.length - 1;
    a !== -1 && o[a] && typeof o[a] == "object" && "cause" in o[a] && (this.cause = o.pop().cause), this.message = NC(t, ...o), Error.stackTraceLimit && i && Error.captureStackTrace(this, s);
  }
  return s.prototype = Object.create(n.prototype, {
    constructor: {
      value: s,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), s.prototype[Symbol.toStringTag] = "Error", s.prototype.toString = kC, s;
}
ja.captureStackTrace = !0;
Eu.exports = ja;
Eu.exports.default = ja;
Eu.exports.createError = ja;
var FS = Eu.exports;
const { createError: An } = FS;
var um = {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: An(
    "AVV_ERR_EXPOSE_ALREADY_DEFINED",
    "'%s' is already defined, specify an expose option for '%s'"
  ),
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: An(
    "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
    "'%s' is already defined"
  ),
  AVV_ERR_CALLBACK_NOT_FN: An(
    "AVV_ERR_CALLBACK_NOT_FN",
    "Callback for '%s' hook is not a function. Received: '%s'"
  ),
  AVV_ERR_PLUGIN_NOT_VALID: An(
    "AVV_ERR_PLUGIN_NOT_VALID",
    "Plugin must be a function or a promise. Received: '%s'"
  ),
  AVV_ERR_ROOT_PLG_BOOTED: An(
    "AVV_ERR_ROOT_PLG_BOOTED",
    "Root plugin has already booted"
  ),
  AVV_ERR_PARENT_PLG_LOADED: An(
    "AVV_ERR_PARENT_PLG_LOADED",
    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
  ),
  AVV_ERR_READY_TIMEOUT: An(
    "AVV_ERR_READY_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: An(
    "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
  )
};
const DC = Symbol("avvio.Boot"), LC = Symbol("isOnCloseHandler"), FC = Symbol("avvio.ThenifyDoNotWrap"), jC = Symbol("avvio.TimeTree.untrackNode"), UC = Symbol("avvio.TimeTree.trackNode"), MC = Symbol("avvio.TimeTree.getParent"), HC = Symbol("avvio.TimeTree.getNode"), qC = Symbol("avvio.TimeTree.addNode"), BC = Symbol.for("plugin-meta");
var Ua = {
  kAvvio: DC,
  kIsOnCloseHandler: LC,
  kThenifyDoNotWrap: FC,
  kUntrackNode: jC,
  kTrackNode: UC,
  kGetParent: MC,
  kGetNode: HC,
  kAddNode: qC,
  kPluginMeta: BC
};
const {
  kUntrackNode: dv,
  kTrackNode: Uf,
  kGetParent: pv,
  kGetNode: hv,
  kAddNode: mv
} = Ua;
let zC = class {
  constructor() {
    this.root = null, this.tableId = /* @__PURE__ */ new Map(), this.tableLabel = /* @__PURE__ */ new Map();
  }
  /**
   * @param {TimeTreeNode} node
   */
  [Uf](t) {
    this.tableId.set(t.id, t), this.tableLabel.has(t.label) ? this.tableLabel.get(t.label).push(t) : this.tableLabel.set(t.label, [t]);
  }
  /**
   * @param {TimeTreeNode} node
   */
  [dv](t) {
    this.tableId.delete(t.id);
    const r = this.tableLabel.get(t.label);
    r.pop(), r.length === 0 && this.tableLabel.delete(t.label);
  }
  /**
   * @param {string} parent
   * @returns {TimeTreeNode}
   */
  [pv](t) {
    if (t === null)
      return null;
    if (this.tableLabel.has(t)) {
      const r = this.tableLabel.get(t);
      return r[r.length - 1];
    } else
      return null;
  }
  /**
   *
   * @param {string} nodeId
   * @returns {TimeTreeNode}
   */
  [hv](t) {
    return this.tableId.get(t);
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number} start
   * @returns {TimeTreeNode["id"]}
   */
  [mv](t, r, n) {
    const i = this[pv](t);
    if (i === null)
      return this.root = {
        parent: null,
        id: "root",
        label: r,
        nodes: [],
        start: n,
        stop: null,
        diff: -1
      }, this[Uf](this.root), this.root.id;
    const o = `${r}-${Math.random()}`, a = {
      parent: t,
      id: o,
      label: r,
      nodes: [],
      start: n,
      stop: null,
      diff: -1
    };
    return i.nodes.push(a), this[Uf](a), o;
  }
  /**
   * @param {string} parent
   * @param {string} label
   * @param {number|undefined} start
   * @returns {TimeTreeNode["id"]}
   */
  start(t, r, n = Date.now()) {
    return this[mv](t, r, n);
  }
  /**
   * @param {string} nodeId
   * @param {number|undefined} stop
   */
  stop(t, r = Date.now()) {
    const n = this[hv](t);
    n && (n.stop = r, n.diff = n.stop - n.start || 0, this[dv](n));
  }
  /**
   * @returns {TimeTreeNode}
   */
  toJSON() {
    return Object.assign({}, this.root);
  }
  /**
   * @returns {string}
   */
  prettyPrint() {
    return jS(this.toJSON());
  }
};
function jS(e, t = "") {
  let r = t;
  const n = e.nodes.length, i = n - 1;
  r += `${e.label} ${e.diff} ms
`;
  for (let s = 0; s < n; ++s) {
    const o = e.nodes[s], a = t + (s === i ? "  " : "│ ");
    r += t, r += s === i ? "└─" : "├─", r += o.nodes.length === 0 ? "─ " : "┬ ", r += jS(o, a).slice(t.length + 2);
  }
  return r;
}
var VC = {
  TimeTree: zC
};
const { debuglog: GC } = Gi, WC = GC("avvio");
var fm = {
  debug: WC
};
function KC() {
  const e = {
    resolve: null,
    reject: null,
    promise: null
  };
  return e.promise = new Promise((t, r) => {
    e.resolve = t, e.reject = r;
  }), e;
}
var YC = {
  createPromise: KC
};
const { kPluginMeta: Mf } = Ua;
function JC(e, t) {
  return e[Mf] && e[Mf].name ? e[Mf].name : t && t.name ? t.name : e.name ? e.name : e.toString().split(`
`).slice(0, 2).map((r) => r.trim()).join(" -- ");
}
var XC = {
  getPluginName: JC
};
function ZC(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var dm = {
  isPromiseLike: ZC
};
const { EventEmitter: QC } = mu, { inherits: eA } = Gi, { debug: At } = fm, { createPromise: tA } = YC, { AVV_ERR_PLUGIN_EXEC_TIMEOUT: rA } = um, { getPluginName: nA } = XC, { isPromiseLike: iA } = dm;
function Zs(e, t, r, n, i) {
  this.queue = e, this.func = t, this.options = r, this.isAfter = n, this.timeout = i, this.started = !1, this.name = nA(t, r), this.queue.pause(), this._error = null, this.loaded = !1, this._promise = null, this.startTime = null;
}
eA(Zs, QC);
Zs.prototype.exec = function(e, t) {
  At("exec", this.name), this.server = e;
  const r = this.func, n = this.name;
  let i = !1;
  this.options = typeof this.options == "function" ? this.options(this.server) : this.options;
  let s = null;
  const o = (c) => {
    if (i) {
      At("loading complete", n);
      return;
    }
    this._error = c, At(c ? "exec errored" : "exec completed", n), i = !0, s && clearTimeout(s), t(c);
  };
  this.timeout > 0 && (At("setting up timeout", n, this.timeout), s = setTimeout(function() {
    At("timed out", n), s = null;
    const c = new rA(n);
    c.fn = r, o(c);
  }, this.timeout)), this.started = !0, this.startTime = Date.now(), this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
  const a = r(this.server, this.options, o);
  iA(a) ? (At("exec: resolving promise", n), a.then(
    () => process.nextTick(o),
    (c) => process.nextTick(o, c)
  )) : r.length < 3 && o();
};
Zs.prototype.loadedSoFar = function() {
  if (At("loadedSoFar", this.name), this.loaded)
    return Promise.resolve();
  const e = () => {
    this.server.after((r, n) => {
      this._error = r, this.queue.pause(), this._promise && (r ? (At("rejecting promise", this.name, r), this._promise.reject(r)) : (At("resolving promise", this.name), this._promise.resolve()), this._promise = null), process.nextTick(n, r);
    }), this.queue.resume();
  };
  let t;
  return this._promise ? t = Promise.resolve() : (this._promise = tA(), t = this._promise.promise, this.server ? e() : this.on("start", e)), t;
};
Zs.prototype.enqueue = function(e, t) {
  At("enqueue", this.name, e.name), this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now()), this.queue.push(e, t);
};
Zs.prototype.finish = function(e, t) {
  At("finish", this.name, e);
  const r = () => {
    this.loaded || (At("loaded", this.name), this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now()), this.loaded = !0, t(e));
  };
  if (e) {
    this._promise && (this._promise.reject(e), this._promise = null), r();
    return;
  }
  const n = () => {
    if (At("check", this.name, this.queue.length(), this.queue.running(), this._promise), this.queue.length() === 0 && this.queue.running() === 0)
      if (this._promise) {
        const i = () => {
          At("wrap"), queueMicrotask(n);
        };
        this._promise.resolve(), this._promise.promise.then(i, i), this._promise = null;
      } else
        r();
    else
      At("delayed", this.name), this.queue.drain = () => {
        At("drain", this.name), this.queue.drain = sA, queueMicrotask(n);
      };
  };
  queueMicrotask(n), this.queue.resume();
};
function sA() {
}
var oA = {
  Plugin: Zs
};
const { AVV_ERR_PLUGIN_NOT_VALID: Hf } = um;
function aA(e) {
  if (!(e && (typeof e == "function" || typeof e.then == "function")))
    throw Array.isArray(e) ? new Hf("array") : e === null ? new Hf("null") : new Hf(typeof e);
}
var cA = {
  validatePlugin: aA
};
function lA(e) {
  return e !== null && typeof e == "object" && typeof e.default == "function";
}
var uA = {
  isBundledOrTypescriptPlugin: lA
};
const { debug: gv } = fm, { kThenifyDoNotWrap: qf } = Ua;
function fA() {
  if (this.booted) {
    gv("thenify returning undefined because we are already booted");
    return;
  }
  if (this[qf]) {
    this[qf] = !1;
    return;
  }
  return gv("thenify"), (e, t) => this._loadRegistered().then(() => (this[qf] = !0, e(this._server)), t);
}
var dA = {
  thenify: fA
};
const { isPromiseLike: pA } = dm, { kAvvio: hA } = Ua;
function mA(e, t, r) {
  const n = e.apply(e, t);
  pA(n) && !n[hA] ? n.then(() => process.nextTick(r), (i) => process.nextTick(r, i)) : r && process.nextTick(r);
}
var gA = {
  executeWithThenable: mA
};
const ll = IC, yA = mu.EventEmitter, vA = Gi.inherits, {
  AVV_ERR_EXPOSE_ALREADY_DEFINED: wo,
  AVV_ERR_CALLBACK_NOT_FN: Is,
  AVV_ERR_ROOT_PLG_BOOTED: _A,
  AVV_ERR_READY_TIMEOUT: bA,
  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: EA
} = um, {
  kAvvio: US,
  kIsOnCloseHandler: MS
} = Ua, { TimeTree: wA } = VC, { Plugin: HS } = oA, { debug: Ms } = fm, { validatePlugin: SA } = cA, { isBundledOrTypescriptPlugin: xA } = uA, { isPromiseLike: RA } = dm, { thenify: qS } = dA, { executeWithThenable: yv } = gA;
function mt(e, t, r) {
  if (typeof e == "function" && arguments.length === 1 && (r = e, t = {}, e = null), typeof t == "function" && (r = t, t = {}), t = t || {}, t.autostart = t.autostart !== !1, t.timeout = Number(t.timeout) || 0, t.expose = t.expose || {}, !new.target)
    return new mt(e, t, r);
  this._server = e || this, this._opts = t, e && this._expose(), this._current = [], this._error = null, this._lastUsed = null, this.setMaxListeners(0), r && this.once("start", r), this.started = !1, this.booted = !1, this.pluginTree = new wA(), this._readyQ = ll(this, BS, 1), this._readyQ.pause(), this._readyQ.drain = () => {
    this.emit("start"), this._readyQ.drain = vv;
  }, this._closeQ = ll(this, TA, 1), this._closeQ.pause(), this._closeQ.drain = () => {
    this.emit("close"), this._closeQ.drain = vv;
  }, this._doStart = null;
  const n = this;
  this._root = new HS(ll(this, this._loadPluginNextTick, 1), function(s, o, a) {
    n._doStart = a, o.autostart && n.start();
  }, t, !1, 0), this._trackPluginLoading(this._root), this._loadPlugin(this._root, (i) => {
    Ms("root plugin ready");
    try {
      this.emit("preReady"), this._root = null;
    } catch (s) {
      i = i || this._error || s;
    }
    if (i) {
      if (this._error = i, this._readyQ.length() === 0)
        throw i;
    } else
      this.booted = !0;
    this._readyQ.resume();
  });
}
vA(mt, yA);
mt.prototype.start = function() {
  return this.started = !0, process.nextTick(this._doStart), this;
};
mt.prototype.override = function(e, t, r) {
  return e;
};
mt.prototype[US] = !0;
mt.prototype.use = function(e, t) {
  return this._lastUsed = this._addPlugin(e, t, !1), this;
};
mt.prototype._loadRegistered = function() {
  const e = this._current[0];
  return !this.started && !this.booted && process.nextTick(() => this._root.queue.resume()), e ? e.loadedSoFar() : Promise.resolve();
};
Object.defineProperty(mt.prototype, "then", { get: qS });
mt.prototype._addPlugin = function(e, t, r) {
  if (xA(e) && (e = e.default), SA(e), t = t || {}, this.booted)
    throw new _A();
  const n = this._current[0];
  let i = this._opts.timeout;
  if (!n.loaded && n.timeout > 0) {
    const o = Date.now() - n.startTime;
    i = n.timeout - (o + 3);
  }
  const s = new HS(ll(this, this._loadPluginNextTick, 1), e, t, r, i);
  if (this._trackPluginLoading(s), n.loaded)
    throw new Error(s.name, n.name);
  return n.enqueue(s, (o) => {
    o && (this._error = o);
  }), s;
};
mt.prototype._expose = function() {
  const t = this, r = t._server, {
    use: n = "use",
    after: i = "after",
    ready: s = "ready",
    onClose: o = "onClose",
    close: a = "close"
  } = this._opts.expose;
  if (r[n])
    throw new wo(n, "use");
  if (r[n] = function(c, u) {
    return t.use(c, u), this;
  }, r[i])
    throw new wo(i, "after");
  if (r[i] = function(c) {
    return typeof c != "function" ? t._loadRegistered() : (t.after(Bf(c, this)), this);
  }, r[s])
    throw new wo(s, "ready");
  if (r[s] = function(c) {
    if (c && typeof c != "function")
      throw new Is(s, typeof c);
    return t.ready(c ? Bf(c, this) : void 0);
  }, r[o])
    throw new wo(o, "onClose");
  if (r[o] = function(c) {
    if (typeof c != "function")
      throw new Is(o, typeof c);
    return t.onClose(OA(c, this)), this;
  }, r[a])
    throw new wo(a, "close");
  if (r[a] = function(c) {
    if (c && typeof c != "function")
      throw new Is(a, typeof c);
    return c ? (t.close(Bf(c, this)), this) : t.close();
  }, r.then)
    throw new EA("then");
  Object.defineProperty(r, "then", { get: qS.bind(t) }), r[US] = !0;
};
mt.prototype.after = function(e) {
  if (!e)
    return this._loadRegistered();
  this._addPlugin(t.bind(this), {}, !0);
  function t(r, n, i) {
    BS.call(this, e, i);
  }
  return this;
};
mt.prototype.onClose = function(e) {
  if (typeof e != "function")
    throw new Is("onClose", typeof e);
  return e[MS] = !0, this._closeQ.unshift(e, (t) => {
    t && (this._error = t);
  }), this;
};
mt.prototype.close = function(e) {
  let t;
  if (e) {
    if (typeof e != "function")
      throw new Is("close", typeof e);
  } else
    t = new Promise(function(r, n) {
      e = function(i) {
        if (i)
          return n(i);
        r();
      };
    });
  return this.ready(() => {
    this._error = null, this._closeQ.push(e), process.nextTick(this._closeQ.resume.bind(this._closeQ));
  }), t;
};
mt.prototype.ready = function(e) {
  if (e) {
    if (typeof e != "function")
      throw new Is("ready", typeof e);
    this._readyQ.push(e), queueMicrotask(this.start.bind(this));
    return;
  }
  return new Promise((t, r) => {
    this._readyQ.push(i), this.start();
    const n = this._current[0].server;
    function i(s, o, a) {
      s ? r(s) : t(n), process.nextTick(a);
    }
  });
};
mt.prototype._trackPluginLoading = function(e) {
  var r;
  const t = ((r = this._current[0]) == null ? void 0 : r.name) || null;
  e.once("start", (n, i, s) => {
    const o = this.pluginTree.start(t || null, i, s);
    e.once("loaded", (a, c, u) => {
      this.pluginTree.stop(o, u);
    });
  });
};
mt.prototype.prettyPrint = function() {
  return this.pluginTree.prettyPrint();
};
mt.prototype.toJSON = function() {
  return this.pluginTree.toJSON();
};
mt.prototype._loadPlugin = function(e, t) {
  const r = this;
  if (RA(e.func)) {
    e.func.then((o) => {
      typeof o.default == "function" && (o = o.default), e.func = o, this._loadPlugin(e, t);
    }, t);
    return;
  }
  const n = r._current[0];
  if (r._current.unshift(e), r._error && !e.isAfter) {
    Ms("skipping loading of plugin as instance errored and it is not an after", e.name), process.nextTick(s);
    return;
  }
  let i = n && n.server || r._server;
  if (!e.isAfter)
    try {
      i = r.override(i, e.func, e.options);
    } catch (o) {
      return Ms("override errored", e.name), s(o);
    }
  e.exec(i, s);
  function s(o) {
    e.finish(o, (a) => {
      r._current.shift(), t(a);
    });
  }
};
mt.prototype._loadPluginNextTick = function(e, t) {
  process.nextTick(this._loadPlugin.bind(this), e, t);
};
function vv() {
}
function BS(e, t) {
  const r = this._server, n = this._error;
  if (this._error = null, e.length === 0)
    this._error = n, yv(e, [], t);
  else if (e.length === 1)
    yv(e, [n], t);
  else if (this._opts.timeout === 0) {
    const i = (s) => {
      this._error = s, t(this._error);
    };
    e.length === 2 ? e(n, i) : e(n, r, i);
  } else
    $A.call(this, e, n, r, t);
}
function $A(e, t, r, n) {
  const i = e.unwrappedName ?? e.name;
  Ms("setting up ready timeout", i, this._opts.timeout);
  let s = setTimeout(() => {
    Ms("timed out", i), s = null;
    const a = new bA(i);
    a.fn = e, this._error = a, n(a);
  }, this._opts.timeout);
  e.length === 2 ? e(t, o.bind(this)) : e(t, r, o.bind(this));
  function o(a) {
    s && (clearTimeout(s), this._error = a, n(this._error));
  }
}
function TA(e, t) {
  const r = this._server, n = e[MS];
  if (e.length === 0 || e.length === 1) {
    let i;
    n ? i = e(r) : i = e(this._error), i && typeof i.then == "function" ? (Ms("resolving close/onClose promise"), i.then(
      () => process.nextTick(t),
      (s) => process.nextTick(t, s)
    )) : process.nextTick(t);
  } else e.length === 2 ? e(n ? r : this._error, t) : n ? e(r, t) : e(this._error, r, t);
}
function OA(e, t) {
  return r.bind(t);
  function r(n, i) {
    let s;
    e.length === 0 ? (s = e(), s && s.then ? s.then(function() {
      process.nextTick(i);
    }, i) : process.nextTick(i)) : e.length === 1 ? (s = e(this), s && s.then ? s.then(function() {
      process.nextTick(i);
    }, i) : process.nextTick(i)) : e(this, i);
  }
}
function Bf(e, t) {
  const r = n.bind(t);
  return r.unwrappedName = e.name, r;
  function n(i, s) {
    let o;
    e ? e.length === 0 ? (o = e(), o && o.then ? o.then(function() {
      process.nextTick(s, i);
    }, s) : process.nextTick(s, i)) : e.length === 1 ? (o = e(i), o && o.then ? o.then(function() {
      process.nextTick(s);
    }, s) : process.nextTick(s)) : e.length === 2 ? e(i, s) : e(i, this, s) : process.nextTick(s);
  }
}
var PA = mt;
const CA = {
  kAvvioBoot: Symbol("fastify.avvioBoot"),
  kChildren: Symbol("fastify.children"),
  kServerBindings: Symbol("fastify.serverBindings"),
  kBodyLimit: Symbol("fastify.bodyLimit"),
  kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
  kRoutePrefix: Symbol("fastify.routePrefix"),
  kLogLevel: Symbol("fastify.logLevel"),
  kLogSerializers: Symbol("fastify.logSerializers"),
  kHooks: Symbol("fastify.hooks"),
  kContentTypeParser: Symbol("fastify.contentTypeParser"),
  kState: Symbol("fastify.state"),
  kOptions: Symbol("fastify.options"),
  kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
  kPluginNameChain: Symbol("fastify.pluginNameChain"),
  kRouteContext: Symbol("fastify.context"),
  kGenReqId: Symbol("fastify.genReqId"),
  // Schema
  kSchemaController: Symbol("fastify.schemaController"),
  kSchemaHeaders: Symbol("headers-schema"),
  kSchemaParams: Symbol("params-schema"),
  kSchemaQuerystring: Symbol("querystring-schema"),
  kSchemaBody: Symbol("body-schema"),
  kSchemaResponse: Symbol("response-schema"),
  kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
  kSchemaVisited: Symbol("fastify.schemas.visited"),
  // Request
  kRequest: Symbol("fastify.Request"),
  kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
  kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
  kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
  kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
  // 404
  kFourOhFour: Symbol("fastify.404"),
  kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
  kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
  kFourOhFourContext: Symbol("fastify.404ContextKey"),
  kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
  // Reply
  kReply: Symbol("fastify.Reply"),
  kReplySerializer: Symbol("fastify.reply.serializer"),
  kReplyIsError: Symbol("fastify.reply.isError"),
  kReplyHeaders: Symbol("fastify.reply.headers"),
  kReplyTrailers: Symbol("fastify.reply.trailers"),
  kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
  kReplyHijacked: Symbol("fastify.reply.hijacked"),
  kReplyStartTime: Symbol("fastify.reply.startTime"),
  kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
  kReplyEndTime: Symbol("fastify.reply.endTime"),
  kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
  kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
  kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
  kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
  kTestInternals: Symbol("fastify.testInternals"),
  kErrorHandler: Symbol("fastify.errorHandler"),
  kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
  kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
  kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
  kRouteByFastify: Symbol("fastify.routeByFastify")
};
var Ft = CA, zS = {}, wu = { exports: {} };
const { format: zf } = Gi;
function AA(e) {
  return VS({ ...e, name: "DeprecationWarning" });
}
function VS({ name: e, code: t, message: r, unlimited: n = !1 } = {}) {
  if (!e) throw new Error("Warning name must not be empty");
  if (!t) throw new Error("Warning code must not be empty");
  if (!r) throw new Error("Warning message must not be empty");
  if (typeof n != "boolean") throw new Error("Warning opts.unlimited must be a boolean");
  t = t.toUpperCase();
  let i = {
    [e]: function(o, a, c) {
      s.emitted === !0 && s.unlimited !== !0 || (s.emitted = !0, process.emitWarning(s.format(o, a, c), s.name, s.code));
    }
  };
  n && (i = {
    [e]: function(o, a, c) {
      s.emitted = !0, process.emitWarning(s.format(o, a, c), s.name, s.code);
    }
  });
  const s = i[e];
  return s.emitted = !1, s.message = r, s.unlimited = n, s.code = t, s.format = function(o, a, c) {
    let u;
    return o && a && c ? u = zf(r, o, a, c) : o && a ? u = zf(r, o, a) : o ? u = zf(r, o) : u = r, u;
  }, s;
}
const pm = { createWarning: VS, createDeprecation: AA };
wu.exports = pm;
wu.exports.default = pm;
wu.exports.processWarning = pm;
var GS = wu.exports;
const { createWarning: hm } = GS, IA = hm({
  name: "FastifyWarning",
  code: "FSTWRN001",
  message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
  unlimited: !0
}), NA = hm({
  name: "FastifyWarning",
  code: "FSTWRN003",
  message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
  unlimited: !0
}), kA = hm({
  name: "FastifySecurity",
  code: "FSTSEC001",
  message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
  unlimited: !0
});
var mm = {
  FSTWRN001: IA,
  FSTWRN003: NA,
  FSTSEC001: kA
}, Su = { exports: {} };
const ie = FS, Ei = {
  /**
   * Basic
   */
  FST_ERR_NOT_FOUND: ie(
    "FST_ERR_NOT_FOUND",
    "Not Found",
    404
  ),
  FST_ERR_OPTIONS_NOT_OBJ: ie(
    "FST_ERR_OPTIONS_NOT_OBJ",
    "Options must be an object",
    500,
    TypeError
  ),
  FST_ERR_QSP_NOT_FN: ie(
    "FST_ERR_QSP_NOT_FN",
    "querystringParser option should be a function, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: ie(
    "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
    "schemaController.bucket option should be a function, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: ie(
    "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
    "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
    500,
    TypeError
  ),
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: ie(
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
    "ajv.customOptions option should be an object, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: ie(
    "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
    "ajv.plugins option should be an array, instead got '%s'",
    500,
    TypeError
  ),
  FST_ERR_VALIDATION: ie(
    "FST_ERR_VALIDATION",
    "%s",
    400
  ),
  FST_ERR_LISTEN_OPTIONS_INVALID: ie(
    "FST_ERR_LISTEN_OPTIONS_INVALID",
    "Invalid listen options: '%s'",
    500,
    TypeError
  ),
  FST_ERR_ERROR_HANDLER_NOT_FN: ie(
    "FST_ERR_ERROR_HANDLER_NOT_FN",
    "Error Handler must be a function",
    500,
    TypeError
  ),
  /**
   * ContentTypeParser
  */
  FST_ERR_CTP_ALREADY_PRESENT: ie(
    "FST_ERR_CTP_ALREADY_PRESENT",
    "Content type parser '%s' already present."
  ),
  FST_ERR_CTP_INVALID_TYPE: ie(
    "FST_ERR_CTP_INVALID_TYPE",
    "The content type should be a string or a RegExp",
    500,
    TypeError
  ),
  FST_ERR_CTP_EMPTY_TYPE: ie(
    "FST_ERR_CTP_EMPTY_TYPE",
    "The content type cannot be an empty string",
    500,
    TypeError
  ),
  FST_ERR_CTP_INVALID_HANDLER: ie(
    "FST_ERR_CTP_INVALID_HANDLER",
    "The content type handler should be a function",
    500,
    TypeError
  ),
  FST_ERR_CTP_INVALID_PARSE_TYPE: ie(
    "FST_ERR_CTP_INVALID_PARSE_TYPE",
    "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
    500,
    TypeError
  ),
  FST_ERR_CTP_BODY_TOO_LARGE: ie(
    "FST_ERR_CTP_BODY_TOO_LARGE",
    "Request body is too large",
    413,
    RangeError
  ),
  FST_ERR_CTP_INVALID_MEDIA_TYPE: ie(
    "FST_ERR_CTP_INVALID_MEDIA_TYPE",
    "Unsupported Media Type: %s",
    415
  ),
  FST_ERR_CTP_INVALID_CONTENT_LENGTH: ie(
    "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
    "Request body size did not match Content-Length",
    400,
    RangeError
  ),
  FST_ERR_CTP_EMPTY_JSON_BODY: ie(
    "FST_ERR_CTP_EMPTY_JSON_BODY",
    "Body cannot be empty when content-type is set to 'application/json'",
    400
  ),
  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: ie(
    "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
    'Cannot call "%s" when fastify instance is already started!',
    400
  ),
  /**
   * decorate
  */
  FST_ERR_DEC_ALREADY_PRESENT: ie(
    "FST_ERR_DEC_ALREADY_PRESENT",
    "The decorator '%s' has already been added!"
  ),
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: ie(
    "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
    "The dependencies of decorator '%s' must be of type Array.",
    500,
    TypeError
  ),
  FST_ERR_DEC_MISSING_DEPENDENCY: ie(
    "FST_ERR_DEC_MISSING_DEPENDENCY",
    "The decorator is missing dependency '%s'."
  ),
  FST_ERR_DEC_AFTER_START: ie(
    "FST_ERR_DEC_AFTER_START",
    "The decorator '%s' has been added after start!"
  ),
  FST_ERR_DEC_REFERENCE_TYPE: ie(
    "FST_ERR_DEC_REFERENCE_TYPE",
    "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
  ),
  /**
   * hooks
  */
  FST_ERR_HOOK_INVALID_TYPE: ie(
    "FST_ERR_HOOK_INVALID_TYPE",
    "The hook name must be a string",
    500,
    TypeError
  ),
  FST_ERR_HOOK_INVALID_HANDLER: ie(
    "FST_ERR_HOOK_INVALID_HANDLER",
    "%s hook should be a function, instead got %s",
    500,
    TypeError
  ),
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: ie(
    "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
    "Async function has too many arguments. Async hooks should not use the 'done' argument.",
    500,
    TypeError
  ),
  FST_ERR_HOOK_NOT_SUPPORTED: ie(
    "FST_ERR_HOOK_NOT_SUPPORTED",
    "%s hook not supported!",
    500,
    TypeError
  ),
  /**
   * Middlewares
   */
  FST_ERR_MISSING_MIDDLEWARE: ie(
    "FST_ERR_MISSING_MIDDLEWARE",
    "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
    500
  ),
  FST_ERR_HOOK_TIMEOUT: ie(
    "FST_ERR_HOOK_TIMEOUT",
    "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
  ),
  /**
   * logger
  */
  FST_ERR_LOG_INVALID_DESTINATION: ie(
    "FST_ERR_LOG_INVALID_DESTINATION",
    "Cannot specify both logger.stream and logger.file options"
  ),
  FST_ERR_LOG_INVALID_LOGGER: ie(
    "FST_ERR_LOG_INVALID_LOGGER",
    "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
    500,
    TypeError
  ),
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: ie(
    "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
    "loggerInstance only accepts a logger instance.",
    500,
    TypeError
  ),
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: ie(
    "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
    "logger options only accepts a configuration object.",
    500,
    TypeError
  ),
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: ie(
    "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
    "You cannot provide both logger and loggerInstance. Please provide only one.",
    500,
    TypeError
  ),
  /**
   * reply
  */
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: ie(
    "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
    "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
    500,
    TypeError
  ),
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: ie(
    "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
    "Response.body is already consumed."
  ),
  FST_ERR_REP_READABLE_STREAM_LOCKED: ie(
    "FST_ERR_REP_READABLE_STREAM_LOCKED",
    "ReadableStream was locked. You should call releaseLock() method on reader before sending."
  ),
  FST_ERR_REP_ALREADY_SENT: ie(
    "FST_ERR_REP_ALREADY_SENT",
    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
  ),
  FST_ERR_REP_SENT_VALUE: ie(
    "FST_ERR_REP_SENT_VALUE",
    "The only possible value for reply.sent is true.",
    500,
    TypeError
  ),
  FST_ERR_SEND_INSIDE_ONERR: ie(
    "FST_ERR_SEND_INSIDE_ONERR",
    "You cannot use `send` inside the `onError` hook"
  ),
  FST_ERR_SEND_UNDEFINED_ERR: ie(
    "FST_ERR_SEND_UNDEFINED_ERR",
    "Undefined error has occurred"
  ),
  FST_ERR_BAD_STATUS_CODE: ie(
    "FST_ERR_BAD_STATUS_CODE",
    "Called reply with an invalid status code: %s"
  ),
  FST_ERR_BAD_TRAILER_NAME: ie(
    "FST_ERR_BAD_TRAILER_NAME",
    "Called reply.trailer with an invalid header name: %s"
  ),
  FST_ERR_BAD_TRAILER_VALUE: ie(
    "FST_ERR_BAD_TRAILER_VALUE",
    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
  ),
  FST_ERR_FAILED_ERROR_SERIALIZATION: ie(
    "FST_ERR_FAILED_ERROR_SERIALIZATION",
    "Failed to serialize an error. Error: %s. Original error: %s"
  ),
  FST_ERR_MISSING_SERIALIZATION_FN: ie(
    "FST_ERR_MISSING_SERIALIZATION_FN",
    'Missing serialization function. Key "%s"'
  ),
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: ie(
    "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
    'Missing serialization function. Key "%s:%s"'
  ),
  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: ie(
    "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
    'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
  ),
  /**
   * schemas
  */
  FST_ERR_SCH_MISSING_ID: ie(
    "FST_ERR_SCH_MISSING_ID",
    "Missing schema $id property"
  ),
  FST_ERR_SCH_ALREADY_PRESENT: ie(
    "FST_ERR_SCH_ALREADY_PRESENT",
    "Schema with id '%s' already declared!"
  ),
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: ie(
    "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
    "Schema is missing for the content type '%s'"
  ),
  FST_ERR_SCH_DUPLICATE: ie(
    "FST_ERR_SCH_DUPLICATE",
    "Schema with '%s' already present!"
  ),
  FST_ERR_SCH_VALIDATION_BUILD: ie(
    "FST_ERR_SCH_VALIDATION_BUILD",
    "Failed building the validation schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_SERIALIZATION_BUILD: ie(
    "FST_ERR_SCH_SERIALIZATION_BUILD",
    "Failed building the serialization schema for %s: %s, due to error %s"
  ),
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: ie(
    "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
    'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
  ),
  /**
   * http2
   */
  FST_ERR_HTTP2_INVALID_VERSION: ie(
    "FST_ERR_HTTP2_INVALID_VERSION",
    "HTTP2 is available only from node >= 8.8.1"
  ),
  /**
   * initialConfig
   */
  FST_ERR_INIT_OPTS_INVALID: ie(
    "FST_ERR_INIT_OPTS_INVALID",
    "Invalid initialization options: '%s'"
  ),
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: ie(
    "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
    "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
  ),
  /**
   * router
   */
  FST_ERR_DUPLICATED_ROUTE: ie(
    "FST_ERR_DUPLICATED_ROUTE",
    "Method '%s' already declared for route '%s'"
  ),
  FST_ERR_BAD_URL: ie(
    "FST_ERR_BAD_URL",
    "'%s' is not a valid url component",
    400,
    URIError
  ),
  FST_ERR_ASYNC_CONSTRAINT: ie(
    "FST_ERR_ASYNC_CONSTRAINT",
    "Unexpected error from async constraint",
    500
  ),
  FST_ERR_INVALID_URL: ie(
    "FST_ERR_INVALID_URL",
    "URL must be a string. Received '%s'",
    400,
    TypeError
  ),
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: ie(
    "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
    'Options for "%s:%s" route must be an object',
    500,
    TypeError
  ),
  FST_ERR_ROUTE_DUPLICATED_HANDLER: ie(
    "FST_ERR_ROUTE_DUPLICATED_HANDLER",
    'Duplicate handler for "%s:%s" route is not allowed!',
    500
  ),
  FST_ERR_ROUTE_HANDLER_NOT_FN: ie(
    "FST_ERR_ROUTE_HANDLER_NOT_FN",
    "Error Handler for %s:%s route, if defined, must be a function",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_MISSING_HANDLER: ie(
    "FST_ERR_ROUTE_MISSING_HANDLER",
    'Missing handler function for "%s:%s" route.',
    500
  ),
  FST_ERR_ROUTE_METHOD_INVALID: ie(
    "FST_ERR_ROUTE_METHOD_INVALID",
    "Provided method is invalid!",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: ie(
    "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
    "%s method is not supported.",
    500
  ),
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: ie(
    "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
    "Body validation schema for %s:%s route is not supported!",
    500
  ),
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: ie(
    "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
    "'bodyLimit' option must be an integer > 0. Got '%s'",
    500,
    TypeError
  ),
  FST_ERR_ROUTE_REWRITE_NOT_STR: ie(
    "FST_ERR_ROUTE_REWRITE_NOT_STR",
    'Rewrite url for "%s" needs to be of type "string" but received "%s"',
    500,
    TypeError
  ),
  /**
   *  again listen when close server
   */
  FST_ERR_REOPENED_CLOSE_SERVER: ie(
    "FST_ERR_REOPENED_CLOSE_SERVER",
    "Fastify has already been closed and cannot be reopened"
  ),
  FST_ERR_REOPENED_SERVER: ie(
    "FST_ERR_REOPENED_SERVER",
    "Fastify is already listening"
  ),
  FST_ERR_INSTANCE_ALREADY_LISTENING: ie(
    "FST_ERR_INSTANCE_ALREADY_LISTENING",
    "Fastify instance is already listening. %s"
  ),
  /**
   * plugin
   */
  FST_ERR_PLUGIN_VERSION_MISMATCH: ie(
    "FST_ERR_PLUGIN_VERSION_MISMATCH",
    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
  ),
  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: ie(
    "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
    "The decorator '%s'%s is not present in %s"
  ),
  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: ie(
    "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
    "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
    500,
    TypeError
  ),
  /**
   *  Avvio Errors
   */
  FST_ERR_PLUGIN_CALLBACK_NOT_FN: ie(
    "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
    "fastify-plugin: %s",
    500,
    TypeError
  ),
  FST_ERR_PLUGIN_NOT_VALID: ie(
    "FST_ERR_PLUGIN_NOT_VALID",
    "fastify-plugin: %s"
  ),
  FST_ERR_ROOT_PLG_BOOTED: ie(
    "FST_ERR_ROOT_PLG_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PARENT_PLUGIN_BOOTED: ie(
    "FST_ERR_PARENT_PLUGIN_BOOTED",
    "fastify-plugin: %s"
  ),
  FST_ERR_PLUGIN_TIMEOUT: ie(
    "FST_ERR_PLUGIN_TIMEOUT",
    "fastify-plugin: %s"
  )
};
function DA(e, t) {
  return t.cause = e, t;
}
Su.exports = Ei;
Su.exports.appendStackTrace = DA;
Su.exports.AVVIO_ERRORS_MAP = {
  AVV_ERR_CALLBACK_NOT_FN: Ei.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
  AVV_ERR_PLUGIN_NOT_VALID: Ei.FST_ERR_PLUGIN_NOT_VALID,
  AVV_ERR_ROOT_PLG_BOOTED: Ei.FST_ERR_ROOT_PLG_BOOTED,
  AVV_ERR_PARENT_PLG_LOADED: Ei.FST_ERR_PARENT_PLUGIN_BOOTED,
  AVV_ERR_READY_TIMEOUT: Ei.FST_ERR_PLUGIN_TIMEOUT,
  AVV_ERR_PLUGIN_EXEC_TIMEOUT: Ei.FST_ERR_PLUGIN_TIMEOUT
};
var Kt = Su.exports;
const LA = [
  "onRoute",
  "onRegister",
  "onReady",
  "onListen",
  "preClose",
  "onClose"
], WS = [
  "onTimeout",
  "onRequest",
  "preParsing",
  "preValidation",
  "preSerialization",
  "preHandler",
  "onSend",
  "onResponse",
  "onError",
  "onRequestAbort"
], FA = WS.concat(LA), {
  FST_ERR_HOOK_INVALID_TYPE: jA,
  FST_ERR_HOOK_INVALID_HANDLER: UA,
  FST_ERR_SEND_UNDEFINED_ERR: xu,
  FST_ERR_HOOK_TIMEOUT: MA,
  FST_ERR_HOOK_NOT_SUPPORTED: HA,
  AVVIO_ERRORS_MAP: _v,
  appendStackTrace: bv
} = Kt, {
  kChildren: Wo,
  kHooks: KS,
  kRequestPayloadStream: Ev
} = Ft;
function Ma() {
  this.onRequest = [], this.preParsing = [], this.preValidation = [], this.preSerialization = [], this.preHandler = [], this.onResponse = [], this.onSend = [], this.onError = [], this.onRoute = [], this.onRegister = [], this.onReady = [], this.onListen = [], this.onTimeout = [], this.onRequestAbort = [], this.preClose = [];
}
Ma.prototype = /* @__PURE__ */ Object.create(null);
Ma.prototype.validate = function(e, t) {
  if (typeof e != "string") throw new jA();
  if (Array.isArray(this[e]) === !1)
    throw new HA(e);
  if (typeof t != "function") throw new UA(e, Object.prototype.toString.call(t));
};
Ma.prototype.add = function(e, t) {
  this.validate(e, t), this[e].push(t);
};
function qA(e) {
  const t = new Ma();
  return t.onRequest = e.onRequest.slice(), t.preParsing = e.preParsing.slice(), t.preValidation = e.preValidation.slice(), t.preSerialization = e.preSerialization.slice(), t.preHandler = e.preHandler.slice(), t.onSend = e.onSend.slice(), t.onResponse = e.onResponse.slice(), t.onError = e.onError.slice(), t.onRoute = e.onRoute.slice(), t.onRegister = e.onRegister.slice(), t.onTimeout = e.onTimeout.slice(), t.onRequestAbort = e.onRequestAbort.slice(), t.onReady = [], t.onListen = [], t.preClose = [], t;
}
function YS(e, t, r, n) {
  const i = r[KS][e];
  let s = 0, o = 0;
  c();
  function a(l) {
    var p;
    const f = (p = i[s - 1]) == null ? void 0 : p.name, m = f ? ` "${f}"` : "";
    if (l) {
      l.code === "AVV_ERR_READY_TIMEOUT" ? l = bv(l, new MA(e, m)) : l = _v[l.code] != null ? bv(l, new _v[l.code](l.message)) : l, n(l);
      return;
    }
    n();
  }
  function c(l) {
    if (l) {
      a(l);
      return;
    }
    if (s === i.length && o === r[Wo].length) {
      s === 0 && o === 0 ? a() : t(function(m, p) {
        a(m), p(m);
      });
      return;
    }
    if (s === i.length && o < r[Wo].length) {
      const f = r[Wo][o++];
      YS(e, t, f, c);
      return;
    }
    t(u(i[s++], r)), c();
  }
  function u(l, f) {
    return function(m, p) {
      if (m) {
        p(m);
        return;
      }
      if (l.length === 1) {
        try {
          l.call(f, p);
        } catch (d) {
          p(d);
        }
        return;
      }
      try {
        const d = l.call(f);
        if (d && typeof d.then == "function") {
          d.then(p, p);
          return;
        }
      } catch (d) {
        m = d;
      }
      p(m);
    };
  }
}
function JS(e) {
  const t = e[KS].onListen, r = t.length;
  let n = 0, i = 0;
  s();
  function s(a) {
    if (a && e.log.error(a), n === r) {
      for (; i < e[Wo].length; ) {
        const c = e[Wo][i++];
        JS(c);
      }
      return;
    }
    o(t[n++], e, s);
  }
  async function o(a, c, u) {
    if (a.length === 1) {
      try {
        a.call(c, u);
      } catch (l) {
        u(l);
      }
      return;
    }
    try {
      const l = a.call(c);
      if (l && typeof l.then == "function") {
        l.then(u, u);
        return;
      }
      u();
    } catch (l) {
      u(l);
    }
  }
}
function Ha(e) {
  return function(r, n, i, s) {
    let o = 0;
    function a(l) {
      if (l || o === r.length) {
        s(l, n, i);
        return;
      }
      let f;
      try {
        f = e(r[o++], n, i, a);
      } catch (m) {
        s(m, n, i);
        return;
      }
      f && typeof f.then == "function" && f.then(c, u);
    }
    function c() {
      a();
    }
    function u(l) {
      l || (l = new xu()), s(l, n, i);
    }
    a();
  };
}
function BA(e, t, r, n) {
  return e(t, r, n);
}
const zA = Ha(BA), VA = Ha(Ru), GA = Ha(Ru), WA = Ha(Ru), KA = Ha(Ru);
function XS(e, t, r, n, i) {
  let s = 0;
  function o(u, l) {
    if (u) {
      i(u, t, r, n);
      return;
    }
    if (l !== void 0 && (n = l), s === e.length) {
      i(null, t, r, n);
      return;
    }
    let f;
    try {
      f = e[s++](t, r, n, o);
    } catch (m) {
      i(m, t, r);
      return;
    }
    f && typeof f.then == "function" && f.then(a, c);
  }
  function a(u) {
    o(null, u);
  }
  function c(u) {
    u || (u = new xu()), i(u, t, r, n);
  }
  o();
}
const YA = XS;
function JA(e, t, r, n) {
  let i = 0;
  function s(c, u) {
    if (r.sent)
      return;
    if (u !== void 0 && (t[Ev] = u), c || i === e.length) {
      n(c, t, r);
      return;
    }
    let l;
    try {
      l = e[i++](t, r, t[Ev], s);
    } catch (f) {
      n(f, t, r);
      return;
    }
    l && typeof l.then == "function" && l.then(o, a);
  }
  function o(c) {
    s(null, c);
  }
  function a(c) {
    c || (c = new xu()), n(c, t, r);
  }
  s();
}
function XA(e, t, r) {
  let n = 0;
  function i(a) {
    if (a || n === e.length) {
      r(a, t);
      return;
    }
    let c;
    try {
      c = e[n++](t, i);
    } catch (u) {
      r(u, t);
      return;
    }
    c && typeof c.then == "function" && c.then(s, o);
  }
  function s() {
    i();
  }
  function o(a) {
    a || (a = new xu()), r(a, t);
  }
  i();
}
function Ru(e, t, r, n) {
  if (r.sent !== !0)
    return e(t, r, n);
}
var Yi = {
  Hooks: Ma,
  buildHooks: qA,
  preParsingHookRunner: JA,
  onResponseHookRunner: zA,
  onSendHookRunner: XS,
  preSerializationHookRunner: YA,
  onRequestAbortHookRunner: XA,
  hookRunnerApplication: YS,
  onListenHookRunner: JS,
  preHandlerHookRunner: GA,
  preValidationHookRunner: VA,
  onRequestHookRunner: KA,
  onTimeoutHookRunner: WA,
  lifecycleHooks: WS,
  supportedHooks: FA
};
const ZA = gu, QA = yC, eI = vC, tI = NS, { kState: Gt, kOptions: rI, kServerBindings: nI } = Ft, { FSTWRN003: iI } = mm, { onListenHookRunner: wc } = Yi, {
  FST_ERR_HTTP2_INVALID_VERSION: sI,
  FST_ERR_REOPENED_CLOSE_SERVER: ZS,
  FST_ERR_REOPENED_SERVER: QS,
  FST_ERR_LISTEN_OPTIONS_INVALID: oI
} = Kt;
zS.createServer = aI;
function ex(e) {
  return `Server listening at ${e}`;
}
function aI(e, t) {
  const r = rx(e, t);
  function n(i = { port: 0, host: "localhost" }, s = void 0) {
    if (typeof s == "function" && (s.constructor.name === "AsyncFunction" && iI("listen method"), i.cb = s), i.signal) {
      if (typeof i.signal.on != "function" && typeof i.signal.addEventListener != "function")
        throw new oI("Invalid options.signal");
      if (i.signal.aborted)
        this.close();
      else {
        const a = () => {
          this.close();
        };
        i.signal.addEventListener("abort", a, { once: !0 });
      }
    }
    let o;
    if (i.path == null ? o = i.host ?? "localhost" : o = i.host, (!Object.hasOwn(i, "host") || i.host == null) && (i.host = o), o === "localhost" ? i.cb = (a, c) => {
      if (a) {
        s(a, c);
        return;
      }
      wv.call(this, r, t, e, i, () => {
        this[Gt].listening = !0, s(null, c), wc(this);
      });
    } : i.cb = (a, c) => {
      if (a) {
        s(a, c);
        return;
      }
      this[Gt].listening = !0, s(null, c), wc(this);
    }, s === void 0)
      return cI.call(this, r, i).then((c) => new Promise((u, l) => {
        o === "localhost" ? wv.call(this, r, t, e, i, () => {
          this[Gt].listening = !0, u(c), wc(this);
        }) : (u(c), wc(this));
      }));
    this.ready(tx.call(this, r, i));
  }
  return { server: r, listen: n };
}
function wv(e, t, r, n, i) {
  this[Gt].listening = !1, eI.lookup(n.host, { all: !0 }, (s, o) => {
    if (s) {
      i();
      return;
    }
    const a = e.listening && r.serverFactory;
    let c = 0, u = 0;
    if (!a) {
      const f = e.address();
      for (const m of o)
        if (m.address !== f.address) {
          c++;
          const p = Object.assign({}, n, {
            host: m.address,
            port: f.port,
            cb: (_) => {
              u++, _ || this[nI].push(d), u === c && i();
            }
          }), d = rx(r, t), h = () => {
            d.close(() => {
            }), typeof d.closeAllConnections == "function" && r.forceCloseConnections === !0 && d.closeAllConnections();
          };
          d.on("upgrade", e.emit.bind(e, "upgrade")), e.on("unref", h), e.on("close", h), e.on("error", h), this[Gt].listening = !1, tx.call(this, d, p)();
        }
    }
    if (c === 0) {
      i();
      return;
    }
    const l = e.unref;
    e.unref = function() {
      l.call(e), e.emit("unref");
    };
  });
}
function tx(e, t) {
  const r = (n) => {
    if (e.removeListener("error", r), e.removeListener("listening", r), n)
      this[Gt].listening = !1, t.cb(n, null);
    else {
      const i = nx.call(this, e, t.listenTextResolver || ex);
      t.cb(null, i);
    }
  };
  return (n) => {
    if (n != null) return t.cb(n);
    if (this[Gt].listening && this[Gt].closing)
      return t.cb(new ZS(), null);
    if (this[Gt].listening)
      return t.cb(new QS(), null);
    e.once("error", r), this[Gt].closing || (e.once("listening", r), e.listen(t), this[Gt].listening = !0);
  };
}
function cI(e, t) {
  return this[Gt].listening && this[Gt].closing ? Promise.reject(new ZS()) : this[Gt].listening ? Promise.reject(new QS()) : this.ready().then(() => {
    let r, n;
    function i() {
      e.removeListener("error", r), e.removeListener("listening", n);
    }
    const s = new Promise((a, c) => {
      r = (u) => {
        i(), this[Gt].listening = !1, c(u);
      }, e.once("error", r);
    }), o = new Promise((a, c) => {
      n = () => {
        i(), this[Gt].listening = !0, a(nx.call(this, e, t.listenTextResolver || ex));
      }, e.once("listening", n);
    });
    return e.listen(t), Promise.race([
      s,
      // e.g invalid port range error is always emitted before the server listening
      o
    ]);
  });
}
function rx(e, t) {
  let r = null;
  const n = e.https === !0 ? {} : e.https;
  return e.serverFactory ? r = e.serverFactory(t, e) : e.http2 ? (typeof n == "object" ? r = Sv().createSecureServer(n, t) : r = Sv().createServer(t), r.on("session", uI(e.http2SessionTimeout))) : (n ? r = QA.createServer(n, t) : r = ZA.createServer(e.http, t), r.keepAliveTimeout = e.keepAliveTimeout, r.requestTimeout = e.requestTimeout, e.maxRequestsPerSocket > 0 && (r.maxRequestsPerSocket = e.maxRequestsPerSocket)), e.serverFactory || r.setTimeout(e.connectionTimeout), r;
}
function lI(e) {
  return e.address === "0.0.0.0" ? Object.values(tI.networkInterfaces()).flatMap((t) => t.filter((r) => r.family === "IPv4")).sort((t) => t.internal ? -1 : 1).map((t) => t.address) : [e.address];
}
function nx(e, t) {
  let r;
  typeof e.address() == "string" ? r = [e.address()] : (e.address().address.indexOf(":") === -1 ? r = lI(e.address()).map((i) => i + ":" + e.address().port) : r = ["[" + e.address().address + "]:" + e.address().port], r = r.map((i) => "http" + (this[rI].https ? "s" : "") + "://" + i));
  for (const i of r)
    this.log.info(t(i));
  return r[0];
}
function Sv() {
  try {
    return require("node:http2");
  } catch {
    throw new sI();
  }
}
function uI(e) {
  return function(t) {
    t.setTimeout(e, fI);
  };
}
function fI() {
  this.close();
}
var $u = { exports: {} }, ix = { exports: {} };
const {
  kSchemaHeaders: ah,
  kSchemaParams: sx,
  kSchemaQuerystring: ox,
  kSchemaBody: xs,
  kSchemaResponse: dI
} = Ft, pI = /^[1-5](?:\d{2}|xx)$|^default$/, {
  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: hI
} = Kt, { FSTWRN001: Sc } = mm;
function mI(e, t) {
  if (!e.schema || !e.schema.response)
    return;
  const { method: r, url: n } = e.config || {};
  e[dI] = Object.keys(e.schema.response).reduce(function(i, s) {
    const o = e.schema.response[s];
    if (s = s.toLowerCase(), !pI.test(s))
      throw new hI();
    if (o.content) {
      const a = {};
      for (const c of Object.keys(o.content)) {
        const u = o.content[c].schema;
        a[c] = t({
          schema: u,
          url: n,
          method: r,
          httpStatus: s,
          contentType: c
        });
      }
      i[s] = a;
    } else
      i[s] = t({
        schema: o,
        url: n,
        method: r,
        httpStatus: s
      });
    return i;
  }, {});
}
function gI(e, t, r) {
  const { schema: n } = e;
  if (!n)
    return;
  const { method: i, url: s } = e.config || {}, o = n.headers;
  if (o && (r || Object.getPrototypeOf(o) !== Object.prototype))
    e[ah] = t({ schema: o, method: i, url: s, httpPart: "headers" });
  else if (o) {
    const a = {};
    Object.keys(o).forEach((c) => {
      a[c] = o[c];
    }), a.required instanceof Array && (a.required = a.required.map((c) => c.toLowerCase())), o.properties && (a.properties = {}, Object.keys(o.properties).forEach((c) => {
      a.properties[c.toLowerCase()] = o.properties[c];
    })), e[ah] = t({ schema: a, method: i, url: s, httpPart: "headers" });
  } else Object.hasOwn(n, "headers") && Sc("headers", i, s);
  if (n.body) {
    const a = n.body.content;
    if (a) {
      const c = {};
      for (const u of Object.keys(a)) {
        const l = a[u].schema;
        c[u] = t({ schema: l, method: i, url: s, httpPart: "body", contentType: u });
      }
      e[xs] = c;
    } else
      e[xs] = t({ schema: n.body, method: i, url: s, httpPart: "body" });
  } else Object.hasOwn(n, "body") && Sc("body", i, s);
  n.querystring ? e[ox] = t({ schema: n.querystring, method: i, url: s, httpPart: "querystring" }) : Object.hasOwn(n, "querystring") && Sc("querystring", i, s), n.params ? e[sx] = t({ schema: n.params, method: i, url: s, httpPart: "params" }) : Object.hasOwn(n, "params") && Sc("params", i, s);
}
function xc(e, t, r) {
  const n = t[r] === void 0, i = e && e(n ? null : t[r]);
  if (i && typeof i.then == "function")
    return i.then((o) => s(o)).catch((o) => o);
  return s(i);
  function s(o) {
    return o === !1 ? e.errors : o && o.error ? o.error : (o && o.value && (t[r] = o.value), !1);
  }
}
function Tu(e, t, r) {
  var s;
  const n = r === void 0;
  if (n || !r.skipParams) {
    const o = xc(e[sx], t, "params");
    if (o)
      return typeof o.then != "function" ? Bn(o, "params", e.schemaErrorFormatter) : yI(o, e, t);
  }
  if (n || !r.skipBody) {
    let o = null;
    if (typeof e[xs] == "function")
      o = e[xs];
    else if (e[xs]) {
      const c = (s = t.headers["content-type"]) == null ? void 0 : s.split(";", 1)[0], u = e[xs][c];
      u && (o = u);
    }
    const a = xc(o, t, "body");
    if (a)
      return typeof a.then != "function" ? Bn(a, "body", e.schemaErrorFormatter) : vI(a, e, t);
  }
  if (n || !r.skipQuery) {
    const o = xc(e[ox], t, "query");
    if (o)
      return typeof o.then != "function" ? Bn(o, "querystring", e.schemaErrorFormatter) : _I(o, e, t);
  }
  const i = xc(e[ah], t, "headers");
  return i ? typeof i.then != "function" ? Bn(i, "headers", e.schemaErrorFormatter) : bI(i, e) : !1;
}
function yI(e, t, r) {
  return e.then((n) => n ? Bn(n, "params", t.schemaErrorFormatter) : Tu(t, r, { skipParams: !0 }));
}
function vI(e, t, r) {
  return e.then((n) => n ? Bn(n, "body", t.schemaErrorFormatter) : Tu(t, r, { skipParams: !0, skipBody: !0 }));
}
function _I(e, t, r) {
  return e.then((n) => n ? Bn(n, "querystring", t.schemaErrorFormatter) : Tu(t, r, { skipParams: !0, skipBody: !0, skipQuery: !0 }));
}
function bI(e, t, r) {
  return e.then((n) => n ? Bn(n, "headers", t.schemaErrorFormatter) : !1);
}
function Bn(e, t, r) {
  if (e instanceof Error)
    return e.statusCode = e.statusCode || 400, e.code = e.code || "FST_ERR_VALIDATION", e.validationContext = e.validationContext || t, e;
  const n = r(e, t);
  return n.statusCode = n.statusCode || 400, n.code = n.code || "FST_ERR_VALIDATION", n.validation = e, n.validationContext = t, n;
}
var ax = {
  compileSchemasForValidation: gI,
  compileSchemasForSerialization: mI,
  validate: Tu
};
const {
  kReplyIsError: xv,
  kReplyHijacked: EI
} = Ft, wI = am, So = wI.tracingChannel("fastify.request.handler");
function SI(e, t, r) {
  r && (r.async = !0), e.then(function(n) {
    if (t[EI] !== !0) {
      r && So.asyncStart.publish(r);
      try {
        if (n !== void 0 || //
        t.sent === !1 && //
        t.raw.headersSent === !1 && t.request.raw.aborted === !1 && t.request.socket && !t.request.socket.destroyed)
          try {
            t.send(n);
          } catch (i) {
            t[xv] = !0, t.send(i);
          }
      } finally {
        r && So.asyncEnd.publish(r);
      }
    }
  }, function(n) {
    r && (r.error = n, So.error.publish(r), So.asyncStart.publish(r));
    try {
      if (t.sent === !0) {
        t.log.error({ err: n }, "Promise errored, but reply.sent = true was set");
        return;
      }
      t[xv] = !0, t.send(n);
    } catch (i) {
      t.send(i);
    } finally {
      r && So.asyncEnd.publish(r);
    }
  });
}
var cx = SI;
(function(e) {
  const t = am, { validate: r } = ax, { preValidationHookRunner: n, preHandlerHookRunner: i } = Yi, s = cx, {
    kReplyIsError: o,
    kRouteContext: a,
    kFourOhFourContext: c,
    kSupportedHTTPMethods: u
  } = Ft, l = t.tracingChannel("fastify.request.handler");
  function f(g, v, y) {
    if (y.sent === !0) return;
    if (g != null) {
      y[o] = !0, y.send(g);
      return;
    }
    const E = v.raw.method, R = v.headers, w = v[a];
    if (this[u].bodyless.has(E)) {
      m(v, y);
      return;
    }
    if (this[u].bodywith.has(E)) {
      const C = R["content-type"], V = R["content-length"], b = R["transfer-encoding"];
      if (C === void 0)
        (V === void 0 || V === "0") && b === void 0 ? m(v, y) : w.contentTypeParser.run("", m, v, y);
      else {
        if (V === void 0 && b === void 0 && E === "OPTIONS") {
          m(v, y);
          return;
        }
        w.contentTypeParser.run(C, m, v, y);
      }
      return;
    }
    m(v, y);
  }
  function m(g, v) {
    try {
      g[a].preValidation !== null ? n(
        g[a].preValidation,
        g,
        v,
        p
      ) : p(null, g, v);
    } catch (y) {
      p(y, g, v);
    }
  }
  function p(g, v, y) {
    if (y.sent === !0) return;
    if (g != null) {
      y[o] = !0, y.send(g);
      return;
    }
    const E = r(y[a], v);
    if (E && typeof E.then == "function" || !1) {
      const w = d.bind(null, v, y);
      E.then(w, w);
    } else
      d(v, y, E);
  }
  function d(g, v, y) {
    if (y) {
      if (v[a].attachValidation === !1) {
        v.send(y);
        return;
      }
      v.request.validationError = y;
    }
    g[a].preHandler !== null ? i(
      g[a].preHandler,
      g,
      v,
      h
    ) : h(null, g, v);
  }
  function h(g, v, y) {
    if (y.sent) return;
    const E = v[a];
    if (!l.hasSubscribers || E[c] === null)
      _(g, v, y);
    else {
      const R = {
        request: v,
        reply: y,
        async: !1,
        route: {
          url: E.config.url,
          method: E.config.method
        }
      };
      l.start.runStores(R, _, void 0, g, v, y, R);
    }
  }
  function _(g, v, y, E) {
    const R = v[a];
    try {
      if (g != null) {
        y[o] = !0, y.send(g), E && (E.error = g, l.error.publish(E));
        return;
      }
      let w;
      try {
        w = R.handler(v, y);
      } catch (C) {
        E && (E.error = C, l.error.publish(E)), y[o] = !0, y.send(C);
        return;
      }
      w !== void 0 && (w !== null && typeof w.then == "function" ? s(w, y, E) : y.send(w));
    } finally {
      E && l.end.publish(E);
    }
  }
  e.exports = f, e.exports[Symbol.for("internals")] = { handler: m, preHandlerCallback: h };
})(ix);
var lx = ix.exports, ul = { exports: {} };
ul.exports;
var Rv;
function xI() {
  return Rv || (Rv = 1, function(e) {
    function t() {
    }
    const r = {
      fatal: t,
      error: t,
      warn: t,
      info: t,
      debug: t,
      trace: t
    };
    Object.defineProperty(e, "exports", {
      get() {
        return Object.create(r);
      }
    });
  }(ul)), ul.exports;
}
var hr = { exports: {} }, Vf, $v;
function ux() {
  if ($v) return Vf;
  $v = 1;
  const e = (o) => o && typeof o.message == "string", t = (o) => {
    if (!o) return;
    const a = o.cause;
    if (typeof a == "function") {
      const c = o.cause();
      return e(c) ? c : void 0;
    } else
      return e(a) ? a : void 0;
  }, r = (o, a) => {
    if (!e(o)) return "";
    const c = o.stack || "";
    if (a.has(o))
      return c + `
causes have become circular...`;
    const u = t(o);
    return u ? (a.add(o), c + `
caused by: ` + r(u, a)) : c;
  }, n = (o) => r(o, /* @__PURE__ */ new Set()), i = (o, a, c) => {
    if (!e(o)) return "";
    const u = c ? "" : o.message || "";
    if (a.has(o))
      return u + ": ...";
    const l = t(o);
    if (l) {
      a.add(o);
      const f = typeof o.cause == "function";
      return u + (f ? "" : ": ") + i(l, a, f);
    } else
      return u;
  };
  return Vf = {
    isErrorLike: e,
    getErrorCause: t,
    stackWithCauses: n,
    messageWithCauses: (o) => i(o, /* @__PURE__ */ new Set())
  }, Vf;
}
var Gf, Tv;
function fx() {
  if (Tv) return Gf;
  Tv = 1;
  const e = Symbol("circular-ref-tag"), t = Symbol("pino-raw-err-ref"), r = Object.create({}, {
    type: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    message: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    stack: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    aggregateErrors: {
      enumerable: !0,
      writable: !0,
      value: void 0
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[t];
      },
      set: function(n) {
        this[t] = n;
      }
    }
  });
  return Object.defineProperty(r, t, {
    writable: !0,
    value: {}
  }), Gf = {
    pinoErrProto: r,
    pinoErrorSymbols: {
      seen: e,
      rawSymbol: t
    }
  }, Gf;
}
var Wf, Ov;
function RI() {
  if (Ov) return Wf;
  Ov = 1, Wf = a;
  const { messageWithCauses: e, stackWithCauses: t, isErrorLike: r } = ux(), { pinoErrProto: n, pinoErrorSymbols: i } = fx(), { seen: s } = i, { toString: o } = Object.prototype;
  function a(c) {
    if (!r(c))
      return c;
    c[s] = void 0;
    const u = Object.create(n);
    u.type = o.call(c.constructor) === "[object Function]" ? c.constructor.name : c.name, u.message = e(c), u.stack = t(c), Array.isArray(c.errors) && (u.aggregateErrors = c.errors.map((l) => a(l)));
    for (const l in c)
      if (u[l] === void 0) {
        const f = c[l];
        r(f) ? l !== "cause" && !Object.prototype.hasOwnProperty.call(f, s) && (u[l] = a(f)) : u[l] = f;
      }
    return delete c[s], u.raw = c, u;
  }
  return Wf;
}
var Kf, Pv;
function $I() {
  if (Pv) return Kf;
  Pv = 1, Kf = s;
  const { isErrorLike: e } = ux(), { pinoErrProto: t, pinoErrorSymbols: r } = fx(), { seen: n } = r, { toString: i } = Object.prototype;
  function s(o) {
    if (!e(o))
      return o;
    o[n] = void 0;
    const a = Object.create(t);
    a.type = i.call(o.constructor) === "[object Function]" ? o.constructor.name : o.name, a.message = o.message, a.stack = o.stack, Array.isArray(o.errors) && (a.aggregateErrors = o.errors.map((c) => s(c))), e(o.cause) && !Object.prototype.hasOwnProperty.call(o.cause, n) && (a.cause = s(o.cause));
    for (const c in o)
      if (a[c] === void 0) {
        const u = o[c];
        e(u) ? Object.prototype.hasOwnProperty.call(u, n) || (a[c] = s(u)) : a[c] = u;
      }
    return delete o[n], a.raw = o, a;
  }
  return Kf;
}
var Yf, Cv;
function TI() {
  if (Cv) return Yf;
  Cv = 1, Yf = {
    mapHttpRequest: n,
    reqSerializer: r
  };
  const e = Symbol("pino-raw-req-ref"), t = Object.create({}, {
    id: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    method: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    url: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    query: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    params: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    headers: {
      enumerable: !0,
      writable: !0,
      value: {}
    },
    remoteAddress: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    remotePort: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[e];
      },
      set: function(i) {
        this[e] = i;
      }
    }
  });
  Object.defineProperty(t, e, {
    writable: !0,
    value: {}
  });
  function r(i) {
    const s = i.info || i.socket, o = Object.create(t);
    if (o.id = typeof i.id == "function" ? i.id() : i.id || (i.info ? i.info.id : void 0), o.method = i.method, i.originalUrl)
      o.url = i.originalUrl;
    else {
      const a = i.path;
      o.url = typeof a == "string" ? a : i.url ? i.url.path || i.url : void 0;
    }
    return i.query && (o.query = i.query), i.params && (o.params = i.params), o.headers = i.headers, o.remoteAddress = s && s.remoteAddress, o.remotePort = s && s.remotePort, o.raw = i.raw || i, o;
  }
  function n(i) {
    return {
      req: r(i)
    };
  }
  return Yf;
}
var Jf, Av;
function OI() {
  if (Av) return Jf;
  Av = 1, Jf = {
    mapHttpResponse: n,
    resSerializer: r
  };
  const e = Symbol("pino-raw-res-ref"), t = Object.create({}, {
    statusCode: {
      enumerable: !0,
      writable: !0,
      value: 0
    },
    headers: {
      enumerable: !0,
      writable: !0,
      value: ""
    },
    raw: {
      enumerable: !1,
      get: function() {
        return this[e];
      },
      set: function(i) {
        this[e] = i;
      }
    }
  });
  Object.defineProperty(t, e, {
    writable: !0,
    value: {}
  });
  function r(i) {
    const s = Object.create(t);
    return s.statusCode = i.headersSent ? i.statusCode : null, s.headers = i.getHeaders ? i.getHeaders() : i._headers, s.raw = i, s;
  }
  function n(i) {
    return {
      res: r(i)
    };
  }
  return Jf;
}
var Xf, Iv;
function dx() {
  if (Iv) return Xf;
  Iv = 1;
  const e = RI(), t = $I(), r = TI(), n = OI();
  return Xf = {
    err: e,
    errWithCause: t,
    mapHttpRequest: r.mapHttpRequest,
    mapHttpResponse: n.mapHttpResponse,
    req: r.reqSerializer,
    res: n.resSerializer,
    wrapErrorSerializer: function(s) {
      return s === e ? s : function(a) {
        return s(e(a));
      };
    },
    wrapRequestSerializer: function(s) {
      return s === r.reqSerializer ? s : function(a) {
        return s(r.reqSerializer(a));
      };
    },
    wrapResponseSerializer: function(s) {
      return s === n.resSerializer ? s : function(a) {
        return s(n.resSerializer(a));
      };
    }
  }, Xf;
}
var Zf, Nv;
function px() {
  if (Nv) return Zf;
  Nv = 1;
  function e(t, r) {
    return r;
  }
  return Zf = function() {
    const r = Error.prepareStackTrace;
    Error.prepareStackTrace = e;
    const n = new Error().stack;
    if (Error.prepareStackTrace = r, !Array.isArray(n))
      return;
    const i = n.slice(2), s = [];
    for (const o of i)
      o && s.push(o.getFileName());
    return s;
  }, Zf;
}
var Qf, kv;
function PI() {
  if (kv) return Qf;
  kv = 1, Qf = e;
  function e(t = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS: r = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH: n = (i) => `fast-redact – Invalid path (${i})`
    } = t;
    return function({ paths: s }) {
      s.forEach((o) => {
        if (typeof o != "string")
          throw Error(r());
        try {
          if (/〇/.test(o)) throw Error();
          const a = (o[0] === "[" ? "" : ".") + o.replace(/^\*/, "〇").replace(/\.\*/g, ".〇").replace(/\[\*\]/g, "[〇]");
          if (/\n|\r|;/.test(a) || /\/\*/.test(a)) throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const 〇 = null;
            o${a}
            if ([o${a}].length !== 1) throw Error()`)();
        } catch {
          throw Error(n(o));
        }
      });
    };
  }
  return Qf;
}
var ed, Dv;
function gm() {
  return Dv || (Dv = 1, ed = /[^.[\]]+|\[((?:.)*?)\]/g), ed;
}
var td, Lv;
function CI() {
  if (Lv) return td;
  Lv = 1;
  const e = gm();
  td = t;
  function t({ paths: r }) {
    const n = [];
    var i = 0;
    const s = r.reduce(function(o, a, c) {
      var u = a.match(e).map((m) => m.replace(/'|"|`/g, ""));
      const l = a[0] === "[";
      u = u.map((m) => m[0] === "[" ? m.substr(1, m.length - 2) : m);
      const f = u.indexOf("*");
      if (f > -1) {
        const m = u.slice(0, f), p = m.join("."), d = u.slice(f + 1, u.length), h = d.length > 0;
        i++, n.push({
          before: m,
          beforeStr: p,
          after: d,
          nested: h
        });
      } else
        o[a] = {
          path: u,
          val: void 0,
          precensored: !1,
          circle: "",
          escPath: JSON.stringify(a),
          leadingBracket: l
        };
      return o;
    }, {});
    return { wildcards: n, wcLen: i, secret: s };
  }
  return td;
}
var rd, Fv;
function AI() {
  if (Fv) return rd;
  Fv = 1;
  const e = gm();
  rd = t;
  function t({ secret: o, serialize: a, wcLen: c, strict: u, isCensorFct: l, censorFctTakesPath: f }, m) {
    const p = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${s(u, a)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${r(o, l, f)}
    this.compileRestore()
    ${n(c > 0, l, f)}
    this.secret = originalSecret
    ${i(a)}
  `).bind(m);
    return p.state = m, a === !1 && (p.restore = (d) => m.restore(d)), p;
  }
  function r(o, a, c) {
    return Object.keys(o).map((u) => {
      const { escPath: l, leadingBracket: f, path: m } = o[u], p = f ? 1 : 0, d = f ? "" : ".", h = [];
      for (var _; (_ = e.exec(u)) !== null; ) {
        const [, E] = _, { index: R, input: w } = _;
        R > p && h.push(w.substring(0, R - (E ? 0 : 1)));
      }
      var g = h.map((E) => `o${d}${E}`).join(" && ");
      g.length === 0 ? g += `o${d}${u} != null` : g += ` && o${d}${u} != null`;
      const v = `
      switch (true) {
        ${h.reverse().map((E) => `
          case o${d}${E} === censor:
            secret[${l}].circle = ${JSON.stringify(E)}
            break
        `).join(`
`)}
      }
    `, y = c ? `val, ${JSON.stringify(m)}` : "val";
      return `
      if (${g}) {
        const val = o${d}${u}
        if (val === censor) {
          secret[${l}].precensored = true
        } else {
          secret[${l}].val = val
          o${d}${u} = ${a ? `censor(${y})` : "censor"}
          ${v}
        }
      }
    `;
    }).join(`
`);
  }
  function n(o, a, c) {
    return o === !0 ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${a}, ${c})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${a}, ${c})
      }
    }
  ` : "";
  }
  function i(o) {
    return o === !1 ? "return o" : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
  function s(o, a) {
    return o === !0 ? "throw Error('fast-redact: primitives cannot be redacted')" : a === !1 ? "return o" : "return this.serialize(o)";
  }
  return rd;
}
var nd, jv;
function hx() {
  if (jv) return nd;
  jv = 1, nd = {
    groupRedact: t,
    groupRestore: e,
    nestedRedact: n,
    nestedRestore: r
  };
  function e({ keys: f, values: m, target: p }) {
    if (p == null || typeof p == "string") return;
    const d = f.length;
    for (var h = 0; h < d; h++) {
      const _ = f[h];
      p[_] = m[h];
    }
  }
  function t(f, m, p, d, h) {
    const _ = o(f, m);
    if (_ == null || typeof _ == "string") return { keys: null, values: null, target: _, flat: !0 };
    const g = Object.keys(_), v = g.length, y = m.length, E = h ? [...m] : void 0, R = new Array(v);
    for (var w = 0; w < v; w++) {
      const C = g[w];
      R[w] = _[C], h ? (E[y] = C, _[C] = p(_[C], E)) : d ? _[C] = p(_[C]) : _[C] = p;
    }
    return { keys: g, values: R, target: _, flat: !0 };
  }
  function r(f) {
    for (let m = 0; m < f.length; m++) {
      const { target: p, path: d, value: h } = f[m];
      let _ = p;
      for (let g = d.length - 1; g > 0; g--)
        _ = _[d[g]];
      _[d[0]] = h;
    }
  }
  function n(f, m, p, d, h, _, g) {
    const v = o(m, p);
    if (v == null) return;
    const y = Object.keys(v), E = y.length;
    for (var R = 0; R < E; R++) {
      const w = y[R];
      s(f, v, w, p, d, h, _, g);
    }
    return f;
  }
  function i(f, m) {
    return f != null ? "hasOwn" in Object ? Object.hasOwn(f, m) : Object.prototype.hasOwnProperty.call(f, m) : !1;
  }
  function s(f, m, p, d, h, _, g, v) {
    const y = h.length, E = y - 1, R = p;
    var w = -1, C, V, b, F = null, H, q, $ = !1, x = 0, A = 0, P = c();
    if (b = C = m[p], typeof C == "object") {
      for (; C != null && ++w < y && (A += 1, p = h[w], !(p !== "*" && !F && !(typeof C == "object" && p in C))); )
        if (!(p === "*" && (F === "*" && ($ = !0), F = p, w !== E))) {
          if (F) {
            const I = Object.keys(C);
            for (var D = 0; D < I.length; D++) {
              const L = I[D];
              if (q = C[L], H = p === "*", $)
                P = u(P, L, A), x = w, b = a(q, x - 1, p, d, h, _, g, v, R, C, V, b, H, L, w, E, P, f, m[R], A + 1);
              else if (H || typeof q == "object" && q !== null && p in q) {
                if (H ? b = q : b = q[p], V = w !== E ? b : g ? v ? _(b, [...d, R, ...h]) : _(b) : _, H) {
                  const j = l(u(P, L, A), b, m[R]);
                  f.push(j), C[L] = V;
                } else if (q[p] !== V) if (V === void 0 && _ !== void 0 || i(q, p) && V === b)
                  P = u(P, L, A);
                else {
                  P = u(P, L, A);
                  const j = l(u(P, p, A + 1), b, m[R]);
                  f.push(j), q[p] = V;
                }
              }
            }
            F = null;
          } else {
            if (b = C[p], P = u(P, p, A), V = w !== E ? b : g ? v ? _(b, [...d, R, ...h]) : _(b) : _, !(i(C, p) && V === b || V === void 0 && _ !== void 0)) {
              const I = l(P, b, m[R]);
              f.push(I), C[p] = V;
            }
            C = C[p];
          }
          if (typeof C != "object") break;
        }
    }
  }
  function o(f, m) {
    for (var p = -1, d = m.length, h = f; h != null && ++p < d; )
      h = h[m[p]];
    return h;
  }
  function a(f, m, p, d, h, _, g, v, y, E, R, w, C, V, b, F, H, q, $, x) {
    if (m === 0 && (C || typeof f == "object" && f !== null && p in f)) {
      if (C ? w = f : w = f[p], R = b !== F ? w : g ? v ? _(w, [...d, y, ...h]) : _(w) : _, C) {
        const A = l(H, w, $);
        q.push(A), E[V] = R;
      } else if (f[p] !== R) {
        if (!(R === void 0 && _ !== void 0 || i(f, p) && R === w)) {
          const A = l(u(H, p, x + 1), w, $);
          q.push(A), f[p] = R;
        }
      }
    }
    for (const A in f)
      typeof f[A] == "object" && (H = u(H, A, x), a(f[A], m - 1, p, d, h, _, g, v, y, E, R, w, C, V, b, F, H, q, $, x + 1));
  }
  function c() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
  function u(f, m, p) {
    if (f.depth === p)
      return u(f.parent, m, p);
    var d = {
      parent: f,
      key: m,
      depth: p,
      children: []
    };
    return f.children.push(d), d;
  }
  function l(f, m, p) {
    let d = f;
    const h = [];
    do
      h.push(d.key), d = d.parent;
    while (d.parent != null);
    return { path: h, value: m, target: p };
  }
  return nd;
}
var id, Uv;
function II() {
  if (Uv) return id;
  Uv = 1;
  const { groupRestore: e, nestedRestore: t } = hx();
  id = r;
  function r() {
    return function() {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
      const { secret: o, wcLen: a } = this, c = Object.keys(o), u = n(o, c), l = a > 0, f = l ? { secret: o, groupRestore: e, nestedRestore: t } : { secret: o };
      this.restore = Function(
        "o",
        i(u, c, l)
      ).bind(f), this.restore.state = f;
    };
  }
  function n(s, o) {
    return o.map((a) => {
      const { circle: c, escPath: u, leadingBracket: l } = s[a], m = c ? `o.${c} = secret[${u}].val` : `o${l ? "" : "."}${a} = secret[${u}].val`, p = `secret[${u}].val = undefined`;
      return `
      if (secret[${u}].val !== undefined) {
        try { ${m} } catch (e) {}
        ${p}
      }
    `;
    }).join("");
  }
  function i(s, o, a) {
    return `
    const secret = this.secret
    ${a === !0 ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${o.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : ""}
    ${s}
    return o
  `;
  }
  return id;
}
var sd, Mv;
function NI() {
  if (Mv) return sd;
  Mv = 1, sd = e;
  function e(t) {
    const {
      secret: r,
      censor: n,
      compileRestore: i,
      serialize: s,
      groupRedact: o,
      nestedRedact: a,
      wildcards: c,
      wcLen: u
    } = t, l = [{ secret: r, censor: n, compileRestore: i }];
    return s !== !1 && l.push({ serialize: s }), u > 0 && l.push({ groupRedact: o, nestedRedact: a, wildcards: c, wcLen: u }), Object.assign(...l);
  }
  return sd;
}
var od, Hv;
function kI() {
  if (Hv) return od;
  Hv = 1;
  const e = PI(), t = CI(), r = AI(), n = II(), { groupRedact: i, nestedRedact: s } = hx(), o = NI(), a = gm(), c = e(), u = (m) => m;
  u.restore = u;
  const l = "[REDACTED]";
  f.rx = a, f.validator = e, od = f;
  function f(m = {}) {
    const p = Array.from(new Set(m.paths || [])), d = "serialize" in m && (m.serialize === !1 || typeof m.serialize == "function") ? m.serialize : JSON.stringify, h = m.remove;
    if (h === !0 && d !== JSON.stringify)
      throw Error("fast-redact – remove option may only be set when serializer is JSON.stringify");
    const _ = h === !0 ? void 0 : "censor" in m ? m.censor : l, g = typeof _ == "function", v = g && _.length > 1;
    if (p.length === 0) return d || u;
    c({ paths: p, serialize: d, censor: _ });
    const { wildcards: y, wcLen: E, secret: R } = t({ paths: p, censor: _ }), w = n(), C = "strict" in m ? m.strict : !0;
    return r({ secret: R, wcLen: E, serialize: d, strict: C, isCensorFct: g, censorFctTakesPath: v }, o({
      secret: R,
      censor: _,
      compileRestore: w,
      serialize: d,
      groupRedact: i,
      nestedRedact: s,
      wildcards: y,
      wcLen: E
    }));
  }
  return od;
}
var ad, qv;
function qa() {
  if (qv) return ad;
  qv = 1;
  const e = Symbol("pino.setLevel"), t = Symbol("pino.getLevel"), r = Symbol("pino.levelVal"), n = Symbol("pino.levelComp"), i = Symbol("pino.useLevelLabels"), s = Symbol("pino.useOnlyCustomLevels"), o = Symbol("pino.mixin"), a = Symbol("pino.lsCache"), c = Symbol("pino.chindings"), u = Symbol("pino.asJson"), l = Symbol("pino.write"), f = Symbol("pino.redactFmt"), m = Symbol("pino.time"), p = Symbol("pino.timeSliceIndex"), d = Symbol("pino.stream"), h = Symbol("pino.stringify"), _ = Symbol("pino.stringifySafe"), g = Symbol("pino.stringifiers"), v = Symbol("pino.end"), y = Symbol("pino.formatOpts"), E = Symbol("pino.messageKey"), R = Symbol("pino.errorKey"), w = Symbol("pino.nestedKey"), C = Symbol("pino.nestedKeyStr"), V = Symbol("pino.mixinMergeStrategy"), b = Symbol("pino.msgPrefix"), F = Symbol("pino.wildcardFirst"), H = Symbol.for("pino.serializers"), q = Symbol.for("pino.formatters"), $ = Symbol.for("pino.hooks"), x = Symbol.for("pino.metadata");
  return ad = {
    setLevelSym: e,
    getLevelSym: t,
    levelValSym: r,
    levelCompSym: n,
    useLevelLabelsSym: i,
    mixinSym: o,
    lsCacheSym: a,
    chindingsSym: c,
    asJsonSym: u,
    writeSym: l,
    serializersSym: H,
    redactFmtSym: f,
    timeSym: m,
    timeSliceIndexSym: p,
    streamSym: d,
    stringifySym: h,
    stringifySafeSym: _,
    stringifiersSym: g,
    endSym: v,
    formatOptsSym: y,
    messageKeySym: E,
    errorKeySym: R,
    nestedKeySym: w,
    wildcardFirstSym: F,
    needsMetadataGsym: x,
    useOnlyCustomLevelsSym: s,
    formattersSym: q,
    hooksSym: $,
    nestedKeyStrSym: C,
    mixinMergeStrategySym: V,
    msgPrefixSym: b
  }, ad;
}
var cd, Bv;
function mx() {
  if (Bv) return cd;
  Bv = 1;
  const e = kI(), { redactFmtSym: t, wildcardFirstSym: r } = qa(), { rx: n, validator: i } = e, s = i({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino – redacted paths must be strings",
    ERR_INVALID_PATH: (l) => `pino – redact paths array contains an invalid path (${l})`
  }), o = "[Redacted]", a = !1;
  function c(l, f) {
    const { paths: m, censor: p } = u(l), d = m.reduce((g, v) => {
      n.lastIndex = 0;
      const y = n.exec(v), E = n.exec(v);
      let R = y[1] !== void 0 ? y[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : y[0];
      if (R === "*" && (R = r), E === null)
        return g[R] = null, g;
      if (g[R] === null)
        return g;
      const { index: w } = E, C = `${v.substr(w, v.length - 1)}`;
      return g[R] = g[R] || [], R !== r && g[R].length === 0 && g[R].push(...g[r] || []), R === r && Object.keys(g).forEach(function(V) {
        g[V] && g[V].push(C);
      }), g[R].push(C), g;
    }, {}), h = {
      [t]: e({ paths: m, censor: p, serialize: f, strict: a })
    }, _ = (...g) => f(typeof p == "function" ? p(...g) : p);
    return [...Object.keys(d), ...Object.getOwnPropertySymbols(d)].reduce((g, v) => {
      if (d[v] === null)
        g[v] = (y) => _(y, [v]);
      else {
        const y = typeof p == "function" ? (E, R) => p(E, [v, ...R]) : p;
        g[v] = e({
          paths: d[v],
          censor: y,
          serialize: f,
          strict: a
        });
      }
      return g;
    }, h);
  }
  function u(l) {
    if (Array.isArray(l))
      return l = { paths: l, censor: o }, s(l), l;
    let { paths: f, censor: m = o, remove: p } = l;
    if (Array.isArray(f) === !1)
      throw Error("pino – redact must contain an array of strings");
    return p === !0 && (m = void 0), s({ paths: f, censor: m }), { paths: f, censor: m };
  }
  return cd = c, cd;
}
var ld, zv;
function DI() {
  return zv || (zv = 1, ld = { nullTime: () => "", epochTime: () => `,"time":${Date.now()}`, unixTime: () => `,"time":${Math.round(Date.now() / 1e3)}`, isoTime: () => `,"time":"${new Date(Date.now()).toISOString()}"` }), ld;
}
var ud, Vv;
function LI() {
  if (Vv) return ud;
  Vv = 1;
  function e(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  ud = t;
  function t(r, n, i) {
    var s = i && i.stringify || e, o = 1;
    if (typeof r == "object" && r !== null) {
      var a = n.length + o;
      if (a === 1) return r;
      var c = new Array(a);
      c[0] = s(r);
      for (var u = 1; u < a; u++)
        c[u] = s(n[u]);
      return c.join(" ");
    }
    if (typeof r != "string")
      return r;
    var l = n.length;
    if (l === 0) return r;
    for (var f = "", m = 1 - o, p = -1, d = r && r.length || 0, h = 0; h < d; ) {
      if (r.charCodeAt(h) === 37 && h + 1 < d) {
        switch (p = p > -1 ? p : 0, r.charCodeAt(h + 1)) {
          case 100:
          case 102:
            if (m >= l || n[m] == null) break;
            p < h && (f += r.slice(p, h)), f += Number(n[m]), p = h + 2, h++;
            break;
          case 105:
            if (m >= l || n[m] == null) break;
            p < h && (f += r.slice(p, h)), f += Math.floor(Number(n[m])), p = h + 2, h++;
            break;
          case 79:
          case 111:
          case 106:
            if (m >= l || n[m] === void 0) break;
            p < h && (f += r.slice(p, h));
            var _ = typeof n[m];
            if (_ === "string") {
              f += "'" + n[m] + "'", p = h + 2, h++;
              break;
            }
            if (_ === "function") {
              f += n[m].name || "<anonymous>", p = h + 2, h++;
              break;
            }
            f += s(n[m]), p = h + 2, h++;
            break;
          case 115:
            if (m >= l)
              break;
            p < h && (f += r.slice(p, h)), f += String(n[m]), p = h + 2, h++;
            break;
          case 37:
            p < h && (f += r.slice(p, h)), f += "%", p = h + 2, h++, m--;
            break;
        }
        ++m;
      }
      ++h;
    }
    return p === -1 ? r : (p < d && (f += r.slice(p)), f);
  }
  return ud;
}
var Rc = { exports: {} }, Gv;
function gx() {
  if (Gv) return Rc.exports;
  if (Gv = 1, typeof SharedArrayBuffer < "u" && typeof Atomics < "u") {
    let t = function(r) {
      if ((r > 0 && r < 1 / 0) === !1)
        throw typeof r != "number" && typeof r != "bigint" ? TypeError("sleep: ms must be a number") : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      Atomics.wait(e, 0, 0, Number(r));
    };
    const e = new Int32Array(new SharedArrayBuffer(4));
    Rc.exports = t;
  } else {
    let e = function(t) {
      if ((t > 0 && t < 1 / 0) === !1)
        throw typeof t != "number" && typeof t != "bigint" ? TypeError("sleep: ms must be a number") : RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
    };
    Rc.exports = e;
  }
  return Rc.exports;
}
var fd, Wv;
function FI() {
  if (Wv) return fd;
  Wv = 1;
  const e = Ue, t = yu, r = Sn.inherits, n = _e, i = gx(), s = Da, o = 100, a = Buffer.allocUnsafe(0), c = 16 * 1024, u = "buffer", l = "utf8", [f, m] = (process.versions.node || "0.0").split(".").map(Number), p = f >= 22 && m >= 7;
  function d($, x) {
    x._opening = !0, x._writing = !0, x._asyncDrainScheduled = !1;
    function A(I, L) {
      if (I) {
        x._reopening = !1, x._writing = !1, x._opening = !1, x.sync ? process.nextTick(() => {
          x.listenerCount("error") > 0 && x.emit("error", I);
        }) : x.emit("error", I);
        return;
      }
      const j = x._reopening;
      x.fd = L, x.file = $, x._reopening = !1, x._opening = !1, x._writing = !1, x.sync ? process.nextTick(() => x.emit("ready")) : x.emit("ready"), !x.destroyed && (!x._writing && x._len > x.minLength || x._flushPending ? x._actualWrite() : j && process.nextTick(() => x.emit("drain")));
    }
    const P = x.append ? "a" : "w", D = x.mode;
    if (x.sync)
      try {
        x.mkdir && e.mkdirSync(n.dirname($), { recursive: !0 });
        const I = e.openSync($, P, D);
        A(null, I);
      } catch (I) {
        throw A(I), I;
      }
    else x.mkdir ? e.mkdir(n.dirname($), { recursive: !0 }, (I) => {
      if (I) return A(I);
      e.open($, P, D, A);
    }) : e.open($, P, D, A);
  }
  function h($) {
    if (!(this instanceof h))
      return new h($);
    let { fd: x, dest: A, minLength: P, maxLength: D, maxWrite: I, periodicFlush: L, sync: j, append: k = !0, mkdir: U, retryEAGAIN: M, fsync: T, contentMode: N, mode: G } = $ || {};
    x = x || A, this._len = 0, this.fd = -1, this._bufs = [], this._lens = [], this._writing = !1, this._ending = !1, this._reopening = !1, this._asyncDrainScheduled = !1, this._flushPending = !1, this._hwm = Math.max(P || 0, 16387), this.file = null, this.destroyed = !1, this.minLength = P || 0, this.maxLength = D || 0, this.maxWrite = I || c, this._periodicFlush = L || 0, this._periodicFlushTimer = void 0, this.sync = j || !1, this.writable = !0, this._fsync = T || !1, this.append = k || !1, this.mode = G, this.retryEAGAIN = M || (() => !0), this.mkdir = U || !1;
    let O, S;
    if (N === u)
      this._writingBuf = a, this.write = E, this.flush = C, this.flushSync = b, this._actualWrite = H, O = () => e.writeSync(this.fd, this._writingBuf), S = () => e.write(this.fd, this._writingBuf, this.release);
    else if (N === void 0 || N === l)
      this._writingBuf = "", this.write = y, this.flush = w, this.flushSync = V, this._actualWrite = F, O = () => e.writeSync(this.fd, this._writingBuf, "utf8"), S = () => e.write(this.fd, this._writingBuf, "utf8", this.release);
    else
      throw new Error(`SonicBoom supports "${l}" and "${u}", but passed ${N}`);
    if (typeof x == "number")
      this.fd = x, process.nextTick(() => this.emit("ready"));
    else if (typeof x == "string")
      d(x, this);
    else
      throw new Error("SonicBoom supports only file descriptors and files");
    if (this.minLength >= this.maxWrite)
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    this.release = (W, z) => {
      if (W) {
        if ((W.code === "EAGAIN" || W.code === "EBUSY") && this.retryEAGAIN(W, this._writingBuf.length, this._len - this._writingBuf.length))
          if (this.sync)
            try {
              i(o), this.release(void 0, 0);
            } catch (X) {
              this.release(X);
            }
          else
            setTimeout(S, o);
        else
          this._writing = !1, this.emit("error", W);
        return;
      }
      this.emit("write", z);
      const Q = _(this._writingBuf, this._len, z);
      if (this._len = Q.len, this._writingBuf = Q.writingBuf, this._writingBuf.length) {
        if (!this.sync) {
          S();
          return;
        }
        try {
          do {
            const X = O(), J = _(this._writingBuf, this._len, X);
            this._len = J.len, this._writingBuf = J.writingBuf;
          } while (this._writingBuf.length);
        } catch (X) {
          this.release(X);
          return;
        }
      }
      this._fsync && e.fsyncSync(this.fd);
      const K = this._len;
      this._reopening ? (this._writing = !1, this._reopening = !1, this.reopen()) : K > this.minLength ? this._actualWrite() : this._ending ? K > 0 ? this._actualWrite() : (this._writing = !1, q(this)) : (this._writing = !1, this.sync ? this._asyncDrainScheduled || (this._asyncDrainScheduled = !0, process.nextTick(g, this)) : this.emit("drain"));
    }, this.on("newListener", function(W) {
      W === "drain" && (this._asyncDrainScheduled = !1);
    }), this._periodicFlush !== 0 && (this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush), this._periodicFlushTimer.unref());
  }
  function _($, x, A) {
    return typeof $ == "string" && Buffer.byteLength($) !== A && (A = Buffer.from($).subarray(0, A).toString().length), x = Math.max(x - A, 0), $ = $.slice(A), { writingBuf: $, len: x };
  }
  function g($) {
    $.listenerCount("drain") > 0 && ($._asyncDrainScheduled = !1, $.emit("drain"));
  }
  r(h, t);
  function v($, x) {
    return $.length === 0 ? a : $.length === 1 ? $[0] : Buffer.concat($, x);
  }
  function y($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    const x = this._len + $.length, A = this._bufs;
    return this.maxLength && x > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (A.length === 0 || A[A.length - 1].length + $.length > this.maxWrite ? A.push("" + $) : A[A.length - 1] += $, this._len = x, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
  }
  function E($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    const x = this._len + $.length, A = this._bufs, P = this._lens;
    return this.maxLength && x > this.maxLength ? (this.emit("drop", $), this._len < this._hwm) : (A.length === 0 || P[P.length - 1] + $.length > this.maxWrite ? (A.push([$]), P.push($.length)) : (A[A.length - 1].push($), P[P.length - 1] += $.length), this._len = x, !this._writing && this._len >= this.minLength && this._actualWrite(), this._len < this._hwm);
  }
  function R($) {
    this._flushPending = !0;
    const x = () => {
      if (this._fsync)
        this._flushPending = !1, $();
      else
        try {
          e.fsync(this.fd, (P) => {
            this._flushPending = !1, $(P);
          });
        } catch (P) {
          $(P);
        }
      this.off("error", A);
    }, A = (P) => {
      this._flushPending = !1, $(P), this.off("drain", x);
    };
    this.once("drain", x), this.once("error", A);
  }
  function w($) {
    if ($ != null && typeof $ != "function")
      throw new Error("flush cb must be a function");
    if (this.destroyed) {
      const x = new Error("SonicBoom destroyed");
      if ($) {
        $(x);
        return;
      }
      throw x;
    }
    if (this.minLength <= 0) {
      $ == null || $();
      return;
    }
    $ && R.call(this, $), !this._writing && (this._bufs.length === 0 && this._bufs.push(""), this._actualWrite());
  }
  function C($) {
    if ($ != null && typeof $ != "function")
      throw new Error("flush cb must be a function");
    if (this.destroyed) {
      const x = new Error("SonicBoom destroyed");
      if ($) {
        $(x);
        return;
      }
      throw x;
    }
    if (this.minLength <= 0) {
      $ == null || $();
      return;
    }
    $ && R.call(this, $), !this._writing && (this._bufs.length === 0 && (this._bufs.push([]), this._lens.push(0)), this._actualWrite());
  }
  h.prototype.reopen = function($) {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.reopen($);
      });
      return;
    }
    if (this._ending)
      return;
    if (!this.file)
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    if ($ && (this.file = $), this._reopening = !0, this._writing)
      return;
    const x = this.fd;
    this.once("ready", () => {
      x !== this.fd && e.close(x, (A) => {
        if (A)
          return this.emit("error", A);
      });
    }), d(this.file, this);
  }, h.prototype.end = function() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    this._ending || (this._ending = !0, !this._writing && (this._len > 0 && this.fd >= 0 ? this._actualWrite() : q(this)));
  };
  function V() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this.fd < 0)
      throw new Error("sonic boom is not ready yet");
    !this._writing && this._writingBuf.length > 0 && (this._bufs.unshift(this._writingBuf), this._writingBuf = "");
    let $ = "";
    for (; this._bufs.length || $; ) {
      $.length <= 0 && ($ = this._bufs[0]);
      try {
        const x = e.writeSync(this.fd, $, "utf8"), A = _($, this._len, x);
        $ = A.writingBuf, this._len = A.len, $.length <= 0 && this._bufs.shift();
      } catch (x) {
        if ((x.code === "EAGAIN" || x.code === "EBUSY") && !this.retryEAGAIN(x, $.length, this._len - $.length))
          throw x;
        i(o);
      }
    }
    try {
      e.fsyncSync(this.fd);
    } catch {
    }
  }
  function b() {
    if (this.destroyed)
      throw new Error("SonicBoom destroyed");
    if (this.fd < 0)
      throw new Error("sonic boom is not ready yet");
    !this._writing && this._writingBuf.length > 0 && (this._bufs.unshift([this._writingBuf]), this._writingBuf = a);
    let $ = a;
    for (; this._bufs.length || $.length; ) {
      $.length <= 0 && ($ = v(this._bufs[0], this._lens[0]));
      try {
        const x = e.writeSync(this.fd, $);
        $ = $.subarray(x), this._len = Math.max(this._len - x, 0), $.length <= 0 && (this._bufs.shift(), this._lens.shift());
      } catch (x) {
        if ((x.code === "EAGAIN" || x.code === "EBUSY") && !this.retryEAGAIN(x, $.length, this._len - $.length))
          throw x;
        i(o);
      }
    }
  }
  h.prototype.destroy = function() {
    this.destroyed || q(this);
  };
  function F() {
    const $ = this.release;
    if (this._writing = !0, this._writingBuf = this._writingBuf || this._bufs.shift() || "", this.sync)
      try {
        const x = e.writeSync(this.fd, this._writingBuf, "utf8");
        $(null, x);
      } catch (x) {
        $(x);
      }
    else
      e.write(this.fd, this._writingBuf, "utf8", $);
  }
  function H() {
    const $ = this.release;
    if (this._writing = !0, this._writingBuf = this._writingBuf.length ? this._writingBuf : v(this._bufs.shift(), this._lens.shift()), this.sync)
      try {
        const x = e.writeSync(this.fd, this._writingBuf);
        $(null, x);
      } catch (x) {
        $(x);
      }
    else
      p && (this._writingBuf = Buffer.from(this._writingBuf)), e.write(this.fd, this._writingBuf, $);
  }
  function q($) {
    if ($.fd === -1) {
      $.once("ready", q.bind(null, $));
      return;
    }
    $._periodicFlushTimer !== void 0 && clearInterval($._periodicFlushTimer), $.destroyed = !0, $._bufs = [], $._lens = [], s(typeof $.fd == "number", `sonic.fd must be a number, got ${typeof $.fd}`);
    try {
      e.fsync($.fd, x);
    } catch {
    }
    function x() {
      $.fd !== 1 && $.fd !== 2 ? e.close($.fd, A) : A();
    }
    function A(P) {
      if (P) {
        $.emit("error", P);
        return;
      }
      $._ending && !$._writing && $.emit("finish"), $.emit("close");
    }
  }
  return h.SonicBoom = h, h.default = h, fd = h, fd;
}
var dd, Kv;
function yx() {
  if (Kv) return dd;
  Kv = 1;
  const e = {
    exit: [],
    beforeExit: []
  }, t = {
    exit: o,
    beforeExit: a
  };
  let r;
  function n() {
    r === void 0 && (r = new FinalizationRegistry(u));
  }
  function i(d) {
    e[d].length > 0 || process.on(d, t[d]);
  }
  function s(d) {
    e[d].length > 0 || (process.removeListener(d, t[d]), e.exit.length === 0 && e.beforeExit.length === 0 && (r = void 0));
  }
  function o() {
    c("exit");
  }
  function a() {
    c("beforeExit");
  }
  function c(d) {
    for (const h of e[d]) {
      const _ = h.deref(), g = h.fn;
      _ !== void 0 && g(_, d);
    }
    e[d] = [];
  }
  function u(d) {
    for (const h of ["exit", "beforeExit"]) {
      const _ = e[h].indexOf(d);
      e[h].splice(_, _ + 1), s(h);
    }
  }
  function l(d, h, _) {
    if (h === void 0)
      throw new Error("the object can't be undefined");
    i(d);
    const g = new WeakRef(h);
    g.fn = _, n(), r.register(h, g), e[d].push(g);
  }
  function f(d, h) {
    l("exit", d, h);
  }
  function m(d, h) {
    l("beforeExit", d, h);
  }
  function p(d) {
    if (r !== void 0) {
      r.unregister(d);
      for (const h of ["exit", "beforeExit"])
        e[h] = e[h].filter((_) => {
          const g = _.deref();
          return g && g !== d;
        }), s(h);
    }
  }
  return dd = {
    register: f,
    registerBeforeExit: m,
    unregister: p
  }, dd;
}
const jI = "3.1.0", UI = {
  version: jI
};
var pd, Yv;
function MI() {
  if (Yv) return pd;
  Yv = 1;
  const e = 1e3;
  function t(n, i, s, o, a) {
    const c = Date.now() + o;
    let u = Atomics.load(n, i);
    if (u === s) {
      a(null, "ok");
      return;
    }
    let l = u;
    const f = (m) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        l = u, u = Atomics.load(n, i), u === l ? f(m >= e ? e : m * 2) : u === s ? a(null, "ok") : a(null, "not-equal");
      }, m);
    };
    f(1);
  }
  function r(n, i, s, o, a) {
    const c = Date.now() + o;
    let u = Atomics.load(n, i);
    if (u !== s) {
      a(null, "ok");
      return;
    }
    const l = (f) => {
      Date.now() > c ? a(null, "timed-out") : setTimeout(() => {
        u = Atomics.load(n, i), u !== s ? a(null, "ok") : l(f >= e ? e : f * 2);
      }, f);
    };
    l(1);
  }
  return pd = { wait: t, waitDiff: r }, pd;
}
var hd, Jv;
function HI() {
  return Jv || (Jv = 1, hd = {
    WRITE_INDEX: 4,
    READ_INDEX: 8
  }), hd;
}
var md, Xv;
function qI() {
  if (Xv) return md;
  Xv = 1;
  const { version: e } = UI, { EventEmitter: t } = yu, { Worker: r } = kS, { join: n } = _e, { pathToFileURL: i } = qr, { wait: s } = MI(), {
    WRITE_INDEX: o,
    READ_INDEX: a
  } = HI(), c = EC, u = Da, l = Symbol("kImpl"), f = c.constants.MAX_STRING_LENGTH;
  class m {
    constructor(x) {
      this._value = x;
    }
    deref() {
      return this._value;
    }
  }
  class p {
    register() {
    }
    unregister() {
    }
  }
  const d = process.env.NODE_V8_COVERAGE ? p : me.FinalizationRegistry || p, h = process.env.NODE_V8_COVERAGE ? m : me.WeakRef || m, _ = new d(($) => {
    $.exited || $.terminate();
  });
  function g($, x) {
    const { filename: A, workerData: P } = x, I = ("__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {})["thread-stream-worker"] || n(__dirname, "lib", "worker.js"), L = new r(I, {
      ...x.workerOpts,
      trackUnmanagedFds: !1,
      workerData: {
        filename: A.indexOf("file://") === 0 ? A : i(A).href,
        dataBuf: $[l].dataBuf,
        stateBuf: $[l].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: e
          },
          ...P
        }
      }
    });
    return L.stream = new m($), L.on("message", E), L.on("exit", R), _.register($, L), L;
  }
  function v($) {
    u(!$[l].sync), $[l].needDrain && ($[l].needDrain = !1, $.emit("drain"));
  }
  function y($) {
    const x = Atomics.load($[l].state, o);
    let A = $[l].data.length - x;
    if (A > 0) {
      if ($[l].buf.length === 0) {
        $[l].flushing = !1, $[l].ending ? F($) : $[l].needDrain && process.nextTick(v, $);
        return;
      }
      let P = $[l].buf.slice(0, A), D = Buffer.byteLength(P);
      D <= A ? ($[l].buf = $[l].buf.slice(A), b($, P, y.bind(null, $))) : $.flush(() => {
        if (!$.destroyed) {
          for (Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); D > $[l].data.length; )
            A = A / 2, P = $[l].buf.slice(0, A), D = Buffer.byteLength(P);
          $[l].buf = $[l].buf.slice(A), b($, P, y.bind(null, $));
        }
      });
    } else if (A === 0) {
      if (x === 0 && $[l].buf.length === 0)
        return;
      $.flush(() => {
        Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0), y($);
      });
    } else
      V($, new Error("overwritten"));
  }
  function E($) {
    const x = this.stream.deref();
    if (x === void 0) {
      this.exited = !0, this.terminate();
      return;
    }
    switch ($.code) {
      case "READY":
        this.stream = new h(x), x.flush(() => {
          x[l].ready = !0, x.emit("ready");
        });
        break;
      case "ERROR":
        V(x, $.err);
        break;
      case "EVENT":
        Array.isArray($.args) ? x.emit($.name, ...$.args) : x.emit($.name, $.args);
        break;
      case "WARNING":
        process.emitWarning($.err);
        break;
      default:
        V(x, new Error("this should not happen: " + $.code));
    }
  }
  function R($) {
    const x = this.stream.deref();
    x !== void 0 && (_.unregister(x), x.worker.exited = !0, x.worker.off("exit", R), V(x, $ !== 0 ? new Error("the worker thread exited") : null));
  }
  class w extends t {
    constructor(x = {}) {
      if (super(), x.bufferSize < 4)
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      this[l] = {}, this[l].stateBuf = new SharedArrayBuffer(128), this[l].state = new Int32Array(this[l].stateBuf), this[l].dataBuf = new SharedArrayBuffer(x.bufferSize || 4 * 1024 * 1024), this[l].data = Buffer.from(this[l].dataBuf), this[l].sync = x.sync || !1, this[l].ending = !1, this[l].ended = !1, this[l].needDrain = !1, this[l].destroyed = !1, this[l].flushing = !1, this[l].ready = !1, this[l].finished = !1, this[l].errored = null, this[l].closed = !1, this[l].buf = "", this.worker = g(this, x), this.on("message", (A, P) => {
        this.worker.postMessage(A, P);
      });
    }
    write(x) {
      if (this[l].destroyed)
        return C(this, new Error("the worker has exited")), !1;
      if (this[l].ending)
        return C(this, new Error("the worker is ending")), !1;
      if (this[l].flushing && this[l].buf.length + x.length >= f)
        try {
          H(this), this[l].flushing = !0;
        } catch (A) {
          return V(this, A), !1;
        }
      if (this[l].buf += x, this[l].sync)
        try {
          return H(this), !0;
        } catch (A) {
          return V(this, A), !1;
        }
      return this[l].flushing || (this[l].flushing = !0, setImmediate(y, this)), this[l].needDrain = this[l].data.length - this[l].buf.length - Atomics.load(this[l].state, o) <= 0, !this[l].needDrain;
    }
    end() {
      this[l].destroyed || (this[l].ending = !0, F(this));
    }
    flush(x) {
      if (this[l].destroyed) {
        typeof x == "function" && process.nextTick(x, new Error("the worker has exited"));
        return;
      }
      const A = Atomics.load(this[l].state, o);
      s(this[l].state, a, A, 1 / 0, (P, D) => {
        if (P) {
          V(this, P), process.nextTick(x, P);
          return;
        }
        if (D === "not-equal") {
          this.flush(x);
          return;
        }
        process.nextTick(x);
      });
    }
    flushSync() {
      this[l].destroyed || (H(this), q(this));
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[l].ready;
    }
    get destroyed() {
      return this[l].destroyed;
    }
    get closed() {
      return this[l].closed;
    }
    get writable() {
      return !this[l].destroyed && !this[l].ending;
    }
    get writableEnded() {
      return this[l].ending;
    }
    get writableFinished() {
      return this[l].finished;
    }
    get writableNeedDrain() {
      return this[l].needDrain;
    }
    get writableObjectMode() {
      return !1;
    }
    get writableErrored() {
      return this[l].errored;
    }
  }
  function C($, x) {
    setImmediate(() => {
      $.emit("error", x);
    });
  }
  function V($, x) {
    $[l].destroyed || ($[l].destroyed = !0, x && ($[l].errored = x, C($, x)), $.worker.exited ? setImmediate(() => {
      $[l].closed = !0, $.emit("close");
    }) : $.worker.terminate().catch(() => {
    }).then(() => {
      $[l].closed = !0, $.emit("close");
    }));
  }
  function b($, x, A) {
    const P = Atomics.load($[l].state, o), D = Buffer.byteLength(x);
    return $[l].data.write(x, P), Atomics.store($[l].state, o, P + D), Atomics.notify($[l].state, o), A(), !0;
  }
  function F($) {
    if (!($[l].ended || !$[l].ending || $[l].flushing)) {
      $[l].ended = !0;
      try {
        $.flushSync();
        let x = Atomics.load($[l].state, a);
        Atomics.store($[l].state, o, -1), Atomics.notify($[l].state, o);
        let A = 0;
        for (; x !== -1; ) {
          if (Atomics.wait($[l].state, a, x, 1e3), x = Atomics.load($[l].state, a), x === -2) {
            V($, new Error("end() failed"));
            return;
          }
          if (++A === 10) {
            V($, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          $[l].finished = !0, $.emit("finish");
        });
      } catch (x) {
        V($, x);
      }
    }
  }
  function H($) {
    const x = () => {
      $[l].ending ? F($) : $[l].needDrain && process.nextTick(v, $);
    };
    for ($[l].flushing = !1; $[l].buf.length !== 0; ) {
      const A = Atomics.load($[l].state, o);
      let P = $[l].data.length - A;
      if (P === 0) {
        q($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0);
        continue;
      } else if (P < 0)
        throw new Error("overwritten");
      let D = $[l].buf.slice(0, P), I = Buffer.byteLength(D);
      if (I <= P)
        $[l].buf = $[l].buf.slice(P), b($, D, x);
      else {
        for (q($), Atomics.store($[l].state, a, 0), Atomics.store($[l].state, o, 0); I > $[l].buf.length; )
          P = P / 2, D = $[l].buf.slice(0, P), I = Buffer.byteLength(D);
        $[l].buf = $[l].buf.slice(P), b($, D, x);
      }
    }
  }
  function q($) {
    if ($[l].flushing)
      throw new Error("unable to flush while flushing");
    const x = Atomics.load($[l].state, o);
    let A = 0;
    for (; ; ) {
      const P = Atomics.load($[l].state, a);
      if (P === -2)
        throw Error("_flushSync failed");
      if (P !== x)
        Atomics.wait($[l].state, a, P, 1e3);
      else
        break;
      if (++A === 10)
        throw new Error("_flushSync took too long (10s)");
    }
  }
  return md = w, md;
}
var gd, Zv;
function vx() {
  if (Zv) return gd;
  Zv = 1;
  const { createRequire: e } = bC, t = px(), { join: r, isAbsolute: n, sep: i } = mn, s = gx(), o = yx(), a = qI();
  function c(p) {
    o.register(p, l), o.registerBeforeExit(p, f), p.on("close", function() {
      o.unregister(p);
    });
  }
  function u(p, d, h, _) {
    const g = new a({
      filename: p,
      workerData: d,
      workerOpts: h,
      sync: _
    });
    g.on("ready", v), g.on("close", function() {
      process.removeListener("exit", y);
    }), process.on("exit", y);
    function v() {
      process.removeListener("exit", y), g.unref(), h.autoEnd !== !1 && c(g);
    }
    function y() {
      g.closed || (g.flushSync(), s(100), g.end());
    }
    return g;
  }
  function l(p) {
    p.ref(), p.flushSync(), p.end(), p.once("close", function() {
      p.unref();
    });
  }
  function f(p) {
    p.flushSync();
  }
  function m(p) {
    const { pipeline: d, targets: h, levels: _, dedupe: g, worker: v = {}, caller: y = t(), sync: E = !1 } = p, R = {
      ...p.options
    }, w = typeof y == "string" ? [y] : y, C = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let V = p.target;
    if (V && h)
      throw new Error("only one of target or targets can be specified");
    return h ? (V = C["pino-worker"] || r(__dirname, "worker.js"), R.targets = h.filter((F) => F.target).map((F) => ({
      ...F,
      target: b(F.target)
    })), R.pipelines = h.filter((F) => F.pipeline).map((F) => F.pipeline.map((H) => ({
      ...H,
      level: F.level,
      // duplicate the pipeline `level` property defined in the upper level
      target: b(H.target)
    })))) : d && (V = C["pino-worker"] || r(__dirname, "worker.js"), R.pipelines = [d.map((F) => ({
      ...F,
      target: b(F.target)
    }))]), _ && (R.levels = _), g && (R.dedupe = g), R.pinoWillSendConfig = !0, u(b(V), R, v, E);
    function b(F) {
      if (F = C[F] || F, n(F) || F.indexOf("file://") === 0)
        return F;
      if (F === "pino/file")
        return r(__dirname, "..", "file.js");
      let H;
      for (const q of w)
        try {
          const $ = q === "node:repl" ? process.cwd() + i : q;
          H = e($).resolve(F);
          break;
        } catch {
          continue;
        }
      if (!H)
        throw new Error(`unable to determine transport target for "${F}"`);
      return H;
    }
  }
  return gd = m, gd;
}
var yd, Qv;
function ym() {
  if (Qv) return yd;
  Qv = 1;
  const e = LI(), { mapHttpRequest: t, mapHttpResponse: r } = dx(), n = FI(), i = yx(), {
    lsCacheSym: s,
    chindingsSym: o,
    writeSym: a,
    serializersSym: c,
    formatOptsSym: u,
    endSym: l,
    stringifiersSym: f,
    stringifySym: m,
    stringifySafeSym: p,
    wildcardFirstSym: d,
    nestedKeySym: h,
    formattersSym: _,
    messageKeySym: g,
    errorKeySym: v,
    nestedKeyStrSym: y,
    msgPrefixSym: E
  } = qa(), { isMainThread: R } = kS, w = vx();
  function C() {
  }
  function V(j, k) {
    if (!k) return U;
    return function(...T) {
      k.call(this, T, U, j);
    };
    function U(M, ...T) {
      if (typeof M == "object") {
        let N = M;
        M !== null && (M.method && M.headers && M.socket ? M = t(M) : typeof M.setHeader == "function" && (M = r(M)));
        let G;
        N === null && T.length === 0 ? G = [null] : (N = T.shift(), G = T), typeof this[E] == "string" && N !== void 0 && N !== null && (N = this[E] + N), this[a](M, e(N, G, this[u]), j);
      } else {
        let N = M === void 0 ? T.shift() : M;
        typeof this[E] == "string" && N !== void 0 && N !== null && (N = this[E] + N), this[a](null, e(N, T, this[u]), j);
      }
    }
  }
  function b(j) {
    let k = "", U = 0, M = !1, T = 255;
    const N = j.length;
    if (N > 100)
      return JSON.stringify(j);
    for (var G = 0; G < N && T >= 32; G++)
      T = j.charCodeAt(G), (T === 34 || T === 92) && (k += j.slice(U, G) + "\\", U = G, M = !0);
    return M ? k += j.slice(U) : k = j, T < 32 ? JSON.stringify(j) : '"' + k + '"';
  }
  function F(j, k, U, M) {
    const T = this[m], N = this[p], G = this[f], O = this[l], S = this[o], W = this[c], z = this[_], Q = this[g], K = this[v];
    let X = this[s][U] + M;
    X = X + S;
    let J;
    z.log && (j = z.log(j));
    const re = G[d];
    let fe = "";
    for (const le in j)
      if (J = j[le], Object.prototype.hasOwnProperty.call(j, le) && J !== void 0) {
        W[le] ? J = W[le](J) : le === K && W.err && (J = W.err(J));
        const xe = G[le] || re;
        switch (typeof J) {
          case "undefined":
          case "function":
            continue;
          case "number":
            Number.isFinite(J) === !1 && (J = null);
          case "boolean":
            xe && (J = xe(J));
            break;
          case "string":
            J = (xe || b)(J);
            break;
          default:
            J = (xe || T)(J, N);
        }
        if (J === void 0) continue;
        const ye = b(le);
        fe += "," + ye + ":" + J;
      }
    let ee = "";
    if (k !== void 0) {
      J = W[Q] ? W[Q](k) : k;
      const le = G[Q] || re;
      switch (typeof J) {
        case "function":
          break;
        case "number":
          Number.isFinite(J) === !1 && (J = null);
        case "boolean":
          le && (J = le(J)), ee = ',"' + Q + '":' + J;
          break;
        case "string":
          J = (le || b)(J), ee = ',"' + Q + '":' + J;
          break;
        default:
          J = (le || T)(J, N), ee = ',"' + Q + '":' + J;
      }
    }
    return this[h] && fe ? X + this[y] + fe.slice(1) + "}" + ee + O : X + fe + ee + O;
  }
  function H(j, k) {
    let U, M = j[o];
    const T = j[m], N = j[p], G = j[f], O = G[d], S = j[c], W = j[_].bindings;
    k = W(k);
    for (const z in k)
      if (U = k[z], (z !== "level" && z !== "serializers" && z !== "formatters" && z !== "customLevels" && k.hasOwnProperty(z) && U !== void 0) === !0) {
        if (U = S[z] ? S[z](U) : U, U = (G[z] || O || T)(U, N), U === void 0) continue;
        M += ',"' + z + '":' + U;
      }
    return M;
  }
  function q(j) {
    return j.write !== j.constructor.prototype.write;
  }
  const $ = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function x(j) {
    const k = new n(j);
    return k.on("error", U), !$ && !j.sync && R && (i.register(k, A), k.on("close", function() {
      i.unregister(k);
    })), k;
    function U(M) {
      if (M.code === "EPIPE") {
        k.write = C, k.end = C, k.flushSync = C, k.destroy = C;
        return;
      }
      k.removeListener("error", U), k.emit("error", M);
    }
  }
  function A(j, k) {
    j.destroyed || (k === "beforeExit" ? (j.flush(), j.on("drain", function() {
      j.end();
    })) : j.flushSync());
  }
  function P(j) {
    return function(U, M, T = {}, N) {
      if (typeof T == "string")
        N = x({ dest: T }), T = {};
      else if (typeof N == "string") {
        if (T && T.transport)
          throw Error("only one of option.transport or stream can be specified");
        N = x({ dest: N });
      } else if (T instanceof n || T.writable || T._writableState)
        N = T, T = {};
      else if (T.transport) {
        if (T.transport instanceof n || T.transport.writable || T.transport._writableState)
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        if (T.transport.targets && T.transport.targets.length && T.formatters && typeof T.formatters.level == "function")
          throw Error("option.transport.targets do not allow custom level formatters");
        let S;
        T.customLevels && (S = T.useOnlyCustomLevels ? T.customLevels : Object.assign({}, T.levels, T.customLevels)), N = w({ caller: M, ...T.transport, levels: S });
      }
      if (T = Object.assign({}, j, T), T.serializers = Object.assign({}, j.serializers, T.serializers), T.formatters = Object.assign({}, j.formatters, T.formatters), T.prettyPrint)
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      const { enabled: G, onChild: O } = T;
      return G === !1 && (T.level = "silent"), O || (T.onChild = C), N || (q(process.stdout) ? N = process.stdout : N = x({ fd: process.stdout.fd || 1 })), { opts: T, stream: N };
    };
  }
  function D(j, k) {
    try {
      return JSON.stringify(j);
    } catch {
      try {
        return (k || this[p])(j);
      } catch {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function I(j, k, U) {
    return {
      level: j,
      bindings: k,
      log: U
    };
  }
  function L(j) {
    const k = Number(j);
    return typeof j == "string" && Number.isFinite(k) ? k : j === void 0 ? 1 : j;
  }
  return yd = {
    noop: C,
    buildSafeSonicBoom: x,
    asChindings: H,
    asJson: F,
    genLog: V,
    createArgsNormalizer: P,
    stringify: D,
    buildFormatters: I,
    normalizeDestFileDescriptor: L
  }, yd;
}
var vd, e0;
function vm() {
  return e0 || (e0 = 1, vd = {
    DEFAULT_LEVELS: {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    },
    SORTING_ORDER: {
      ASC: "ASC",
      DESC: "DESC"
    }
  }), vd;
}
var _d, t0;
function _x() {
  if (t0) return _d;
  t0 = 1;
  const {
    lsCacheSym: e,
    levelValSym: t,
    useOnlyCustomLevelsSym: r,
    streamSym: n,
    formattersSym: i,
    hooksSym: s,
    levelCompSym: o
  } = qa(), { noop: a, genLog: c } = ym(), { DEFAULT_LEVELS: u, SORTING_ORDER: l } = vm(), f = {
    fatal: (b) => {
      const F = c(u.fatal, b);
      return function(...H) {
        const q = this[n];
        if (F.call(this, ...H), typeof q.flushSync == "function")
          try {
            q.flushSync();
          } catch {
          }
      };
    },
    error: (b) => c(u.error, b),
    warn: (b) => c(u.warn, b),
    info: (b) => c(u.info, b),
    debug: (b) => c(u.debug, b),
    trace: (b) => c(u.trace, b)
  }, m = Object.keys(u).reduce((b, F) => (b[u[F]] = F, b), {}), p = Object.keys(m).reduce((b, F) => (b[F] = '{"level":' + Number(F), b), {});
  function d(b) {
    const F = b[i].level, { labels: H } = b.levels, q = {};
    for (const $ in H) {
      const x = F(H[$], Number($));
      q[$] = JSON.stringify(x).slice(0, -1);
    }
    return b[e] = q, b;
  }
  function h(b, F) {
    if (F)
      return !1;
    switch (b) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return !0;
      default:
        return !1;
    }
  }
  function _(b) {
    const { labels: F, values: H } = this.levels;
    if (typeof b == "number") {
      if (F[b] === void 0) throw Error("unknown level value" + b);
      b = F[b];
    }
    if (H[b] === void 0) throw Error("unknown level " + b);
    const q = this[t], $ = this[t] = H[b], x = this[r], A = this[o], P = this[s].logMethod;
    for (const D in H) {
      if (A(H[D], $) === !1) {
        this[D] = a;
        continue;
      }
      this[D] = h(D, x) ? f[D](P) : c(H[D], P);
    }
    this.emit(
      "level-change",
      b,
      $,
      F[q],
      q,
      this
    );
  }
  function g(b) {
    const { levels: F, levelVal: H } = this;
    return F && F.labels ? F.labels[H] : "";
  }
  function v(b) {
    const { values: F } = this.levels, H = F[b];
    return H !== void 0 && this[o](H, this[t]);
  }
  function y(b, F, H) {
    return b === l.DESC ? F <= H : F >= H;
  }
  function E(b) {
    return typeof b == "string" ? y.bind(null, b) : b;
  }
  function R(b = null, F = !1) {
    const H = b ? Object.keys(b).reduce((x, A) => (x[b[A]] = A, x), {}) : null, q = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      F ? null : m,
      H
    ), $ = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      F ? null : u,
      b
    );
    return { labels: q, values: $ };
  }
  function w(b, F, H) {
    if (typeof b == "number") {
      if (![].concat(
        Object.keys(F || {}).map((x) => F[x]),
        H ? [] : Object.keys(m).map((x) => +x),
        1 / 0
      ).includes(b))
        throw Error(`default level:${b} must be included in custom levels`);
      return;
    }
    const q = Object.assign(
      Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
      H ? null : u,
      F
    );
    if (!(b in q))
      throw Error(`default level:${b} must be included in custom levels`);
  }
  function C(b, F) {
    const { labels: H, values: q } = b;
    for (const $ in F) {
      if ($ in q)
        throw Error("levels cannot be overridden");
      if (F[$] in H)
        throw Error("pre-existing level values cannot be used for new levels");
    }
  }
  function V(b) {
    if (typeof b != "function" && !(typeof b == "string" && Object.values(l).includes(b)))
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  return _d = {
    initialLsCache: p,
    genLsCache: d,
    levelMethods: f,
    getLevel: g,
    setLevel: _,
    isLevelEnabled: v,
    mappings: R,
    assertNoLevelCollisions: C,
    assertDefaultLevelFound: w,
    genLevelComparison: E,
    assertLevelComparison: V
  }, _d;
}
var bd, r0;
function bx() {
  return r0 || (r0 = 1, bd = { version: "9.6.0" }), bd;
}
var Ed, n0;
function BI() {
  if (n0) return Ed;
  n0 = 1;
  const { EventEmitter: e } = mu, {
    lsCacheSym: t,
    levelValSym: r,
    setLevelSym: n,
    getLevelSym: i,
    chindingsSym: s,
    parsedChindingsSym: o,
    mixinSym: a,
    asJsonSym: c,
    writeSym: u,
    mixinMergeStrategySym: l,
    timeSym: f,
    timeSliceIndexSym: m,
    streamSym: p,
    serializersSym: d,
    formattersSym: h,
    errorKeySym: _,
    messageKeySym: g,
    useOnlyCustomLevelsSym: v,
    needsMetadataGsym: y,
    redactFmtSym: E,
    stringifySym: R,
    formatOptsSym: w,
    stringifiersSym: C,
    msgPrefixSym: V,
    hooksSym: b
  } = qa(), {
    getLevel: F,
    setLevel: H,
    isLevelEnabled: q,
    mappings: $,
    initialLsCache: x,
    genLsCache: A,
    assertNoLevelCollisions: P
  } = _x(), {
    asChindings: D,
    asJson: I,
    buildFormatters: L,
    stringify: j
  } = ym(), {
    version: k
  } = bx(), U = mx(), T = {
    constructor: class {
    },
    child: G,
    bindings: O,
    setBindings: S,
    flush: K,
    isLevelEnabled: q,
    version: k,
    get level() {
      return this[i]();
    },
    set level(X) {
      this[n](X);
    },
    get levelVal() {
      return this[r];
    },
    set levelVal(X) {
      throw Error("levelVal is read-only");
    },
    [t]: x,
    [u]: z,
    [c]: I,
    [i]: F,
    [n]: H
  };
  Object.setPrototypeOf(T, e.prototype), Ed = function() {
    return Object.create(T);
  };
  const N = (X) => X;
  function G(X, J) {
    if (!X)
      throw Error("missing bindings for child Pino");
    J = J || {};
    const re = this[d], fe = this[h], ee = Object.create(this);
    if (J.hasOwnProperty("serializers") === !0) {
      ee[d] = /* @__PURE__ */ Object.create(null);
      for (const Ae in re)
        ee[d][Ae] = re[Ae];
      const ve = Object.getOwnPropertySymbols(re);
      for (var le = 0; le < ve.length; le++) {
        const Ae = ve[le];
        ee[d][Ae] = re[Ae];
      }
      for (const Ae in J.serializers)
        ee[d][Ae] = J.serializers[Ae];
      const ze = Object.getOwnPropertySymbols(J.serializers);
      for (var xe = 0; xe < ze.length; xe++) {
        const Ae = ze[xe];
        ee[d][Ae] = J.serializers[Ae];
      }
    } else ee[d] = re;
    if (J.hasOwnProperty("formatters")) {
      const { level: ve, bindings: ze, log: Ae } = J.formatters;
      ee[h] = L(
        ve || fe.level,
        ze || N,
        Ae || fe.log
      );
    } else
      ee[h] = L(
        fe.level,
        N,
        fe.log
      );
    if (J.hasOwnProperty("customLevels") === !0 && (P(this.levels, J.customLevels), ee.levels = $(J.customLevels, ee[v]), A(ee)), typeof J.redact == "object" && J.redact !== null || Array.isArray(J.redact)) {
      ee.redact = J.redact;
      const ve = U(ee.redact, j), ze = { stringify: ve[E] };
      ee[R] = j, ee[C] = ve, ee[w] = ze;
    }
    typeof J.msgPrefix == "string" && (ee[V] = (this[V] || "") + J.msgPrefix), ee[s] = D(ee, X);
    const ye = J.level || this.level;
    return ee[n](ye), this.onChild(ee), ee;
  }
  function O() {
    const J = `{${this[s].substr(1)}}`, re = JSON.parse(J);
    return delete re.pid, delete re.hostname, re;
  }
  function S(X) {
    const J = D(this, X);
    this[s] = J, delete this[o];
  }
  function W(X, J) {
    return Object.assign(J, X);
  }
  function z(X, J, re) {
    const fe = this[f](), ee = this[a], le = this[_], xe = this[g], ye = this[l] || W;
    let ve;
    const ze = this[b].streamWrite;
    X == null ? ve = {} : X instanceof Error ? (ve = { [le]: X }, J === void 0 && (J = X.message)) : (ve = X, J === void 0 && X[xe] === void 0 && X[le] && (J = X[le].message)), ee && (ve = ye(ve, ee(ve, re, this)));
    const Ae = this[c](ve, J, re, fe), $t = this[p];
    $t[y] === !0 && ($t.lastLevel = re, $t.lastObj = ve, $t.lastMsg = J, $t.lastTime = fe.slice(this[m]), $t.lastLogger = this), $t.write(ze ? ze(Ae) : Ae);
  }
  function Q() {
  }
  function K(X) {
    if (X != null && typeof X != "function")
      throw Error("callback must be a function");
    const J = this[p];
    typeof J.flush == "function" ? J.flush(X || Q) : X && X();
  }
  return Ed;
}
var $c = { exports: {} }, i0;
function zI() {
  return i0 || (i0 = 1, function(e, t) {
    const { hasOwnProperty: r } = Object.prototype, n = g();
    n.configure = g, n.stringify = n, n.default = n, t.stringify = n, t.configure = g, e.exports = n;
    const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function s(v) {
      return v.length < 5e3 && !i.test(v) ? `"${v}"` : JSON.stringify(v);
    }
    function o(v, y) {
      if (v.length > 200 || y)
        return v.sort(y);
      for (let E = 1; E < v.length; E++) {
        const R = v[E];
        let w = E;
        for (; w !== 0 && v[w - 1] > R; )
          v[w] = v[w - 1], w--;
        v[w] = R;
      }
      return v;
    }
    const a = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function c(v) {
      return a.call(v) !== void 0 && v.length !== 0;
    }
    function u(v, y, E) {
      v.length < E && (E = v.length);
      const R = y === "," ? "" : " ";
      let w = `"0":${R}${v[0]}`;
      for (let C = 1; C < E; C++)
        w += `${y}"${C}":${R}${v[C]}`;
      return w;
    }
    function l(v) {
      if (r.call(v, "circularValue")) {
        const y = v.circularValue;
        if (typeof y == "string")
          return `"${y}"`;
        if (y == null)
          return y;
        if (y === Error || y === TypeError)
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function f(v) {
      let y;
      if (r.call(v, "deterministic") && (y = v.deterministic, typeof y != "boolean" && typeof y != "function"))
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      return y === void 0 ? !0 : y;
    }
    function m(v, y) {
      let E;
      if (r.call(v, y) && (E = v[y], typeof E != "boolean"))
        throw new TypeError(`The "${y}" argument must be of type boolean`);
      return E === void 0 ? !0 : E;
    }
    function p(v, y) {
      let E;
      if (r.call(v, y)) {
        if (E = v[y], typeof E != "number")
          throw new TypeError(`The "${y}" argument must be of type number`);
        if (!Number.isInteger(E))
          throw new TypeError(`The "${y}" argument must be an integer`);
        if (E < 1)
          throw new RangeError(`The "${y}" argument must be >= 1`);
      }
      return E === void 0 ? 1 / 0 : E;
    }
    function d(v) {
      return v === 1 ? "1 item" : `${v} items`;
    }
    function h(v) {
      const y = /* @__PURE__ */ new Set();
      for (const E of v)
        (typeof E == "string" || typeof E == "number") && y.add(String(E));
      return y;
    }
    function _(v) {
      if (r.call(v, "strict")) {
        const y = v.strict;
        if (typeof y != "boolean")
          throw new TypeError('The "strict" argument must be of type boolean');
        if (y)
          return (E) => {
            let R = `Object can not safely be stringified. Received type ${typeof E}`;
            throw typeof E != "function" && (R += ` (${E.toString()})`), new Error(R);
          };
      }
    }
    function g(v) {
      v = { ...v };
      const y = _(v);
      y && (v.bigint === void 0 && (v.bigint = !1), "circularValue" in v || (v.circularValue = Error));
      const E = l(v), R = m(v, "bigint"), w = f(v), C = typeof w == "function" ? w : void 0, V = p(v, "maximumDepth"), b = p(v, "maximumBreadth");
      function F(A, P, D, I, L, j) {
        let k = P[A];
        switch (typeof k == "object" && k !== null && typeof k.toJSON == "function" && (k = k.toJSON(A)), k = I.call(P, A, k), typeof k) {
          case "string":
            return s(k);
          case "object": {
            if (k === null)
              return "null";
            if (D.indexOf(k) !== -1)
              return E;
            let U = "", M = ",";
            const T = j;
            if (Array.isArray(k)) {
              if (k.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(k), L !== "" && (j += L, U += `
${j}`, M = `,
${j}`);
              const z = Math.min(k.length, b);
              let Q = 0;
              for (; Q < z - 1; Q++) {
                const X = F(String(Q), k, D, I, L, j);
                U += X !== void 0 ? X : "null", U += M;
              }
              const K = F(String(Q), k, D, I, L, j);
              if (U += K !== void 0 ? K : "null", k.length - 1 > b) {
                const X = k.length - b - 1;
                U += `${M}"... ${d(X)} not stringified"`;
              }
              return L !== "" && (U += `
${T}`), D.pop(), `[${U}]`;
            }
            let N = Object.keys(k);
            const G = N.length;
            if (G === 0)
              return "{}";
            if (V < D.length + 1)
              return '"[Object]"';
            let O = "", S = "";
            L !== "" && (j += L, M = `,
${j}`, O = " ");
            const W = Math.min(G, b);
            w && !c(k) && (N = o(N, C)), D.push(k);
            for (let z = 0; z < W; z++) {
              const Q = N[z], K = F(Q, k, D, I, L, j);
              K !== void 0 && (U += `${S}${s(Q)}:${O}${K}`, S = M);
            }
            if (G > b) {
              const z = G - b;
              U += `${S}"...":${O}"${d(z)} not stringified"`, S = M;
            }
            return L !== "" && S.length > 1 && (U = `
${j}${U}
${T}`), D.pop(), `{${U}}`;
          }
          case "number":
            return isFinite(k) ? String(k) : y ? y(k) : "null";
          case "boolean":
            return k === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(k);
          default:
            return y ? y(k) : void 0;
        }
      }
      function H(A, P, D, I, L, j) {
        switch (typeof P == "object" && P !== null && typeof P.toJSON == "function" && (P = P.toJSON(A)), typeof P) {
          case "string":
            return s(P);
          case "object": {
            if (P === null)
              return "null";
            if (D.indexOf(P) !== -1)
              return E;
            const k = j;
            let U = "", M = ",";
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(P), L !== "" && (j += L, U += `
${j}`, M = `,
${j}`);
              const G = Math.min(P.length, b);
              let O = 0;
              for (; O < G - 1; O++) {
                const W = H(String(O), P[O], D, I, L, j);
                U += W !== void 0 ? W : "null", U += M;
              }
              const S = H(String(O), P[O], D, I, L, j);
              if (U += S !== void 0 ? S : "null", P.length - 1 > b) {
                const W = P.length - b - 1;
                U += `${M}"... ${d(W)} not stringified"`;
              }
              return L !== "" && (U += `
${k}`), D.pop(), `[${U}]`;
            }
            D.push(P);
            let T = "";
            L !== "" && (j += L, M = `,
${j}`, T = " ");
            let N = "";
            for (const G of I) {
              const O = H(G, P[G], D, I, L, j);
              O !== void 0 && (U += `${N}${s(G)}:${T}${O}`, N = M);
            }
            return L !== "" && N.length > 1 && (U = `
${j}${U}
${k}`), D.pop(), `{${U}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function q(A, P, D, I, L) {
        switch (typeof P) {
          case "string":
            return s(P);
          case "object": {
            if (P === null)
              return "null";
            if (typeof P.toJSON == "function") {
              if (P = P.toJSON(A), typeof P != "object")
                return q(A, P, D, I, L);
              if (P === null)
                return "null";
            }
            if (D.indexOf(P) !== -1)
              return E;
            const j = L;
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(P), L += I;
              let O = `
${L}`;
              const S = `,
${L}`, W = Math.min(P.length, b);
              let z = 0;
              for (; z < W - 1; z++) {
                const K = q(String(z), P[z], D, I, L);
                O += K !== void 0 ? K : "null", O += S;
              }
              const Q = q(String(z), P[z], D, I, L);
              if (O += Q !== void 0 ? Q : "null", P.length - 1 > b) {
                const K = P.length - b - 1;
                O += `${S}"... ${d(K)} not stringified"`;
              }
              return O += `
${j}`, D.pop(), `[${O}]`;
            }
            let k = Object.keys(P);
            const U = k.length;
            if (U === 0)
              return "{}";
            if (V < D.length + 1)
              return '"[Object]"';
            L += I;
            const M = `,
${L}`;
            let T = "", N = "", G = Math.min(U, b);
            c(P) && (T += u(P, M, b), k = k.slice(P.length), G -= P.length, N = M), w && (k = o(k, C)), D.push(P);
            for (let O = 0; O < G; O++) {
              const S = k[O], W = q(S, P[S], D, I, L);
              W !== void 0 && (T += `${N}${s(S)}: ${W}`, N = M);
            }
            if (U > b) {
              const O = U - b;
              T += `${N}"...": "${d(O)} not stringified"`, N = M;
            }
            return N !== "" && (T = `
${L}${T}
${j}`), D.pop(), `{${T}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function $(A, P, D) {
        switch (typeof P) {
          case "string":
            return s(P);
          case "object": {
            if (P === null)
              return "null";
            if (typeof P.toJSON == "function") {
              if (P = P.toJSON(A), typeof P != "object")
                return $(A, P, D);
              if (P === null)
                return "null";
            }
            if (D.indexOf(P) !== -1)
              return E;
            let I = "";
            const L = P.length !== void 0;
            if (L && Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (V < D.length + 1)
                return '"[Array]"';
              D.push(P);
              const T = Math.min(P.length, b);
              let N = 0;
              for (; N < T - 1; N++) {
                const O = $(String(N), P[N], D);
                I += O !== void 0 ? O : "null", I += ",";
              }
              const G = $(String(N), P[N], D);
              if (I += G !== void 0 ? G : "null", P.length - 1 > b) {
                const O = P.length - b - 1;
                I += `,"... ${d(O)} not stringified"`;
              }
              return D.pop(), `[${I}]`;
            }
            let j = Object.keys(P);
            const k = j.length;
            if (k === 0)
              return "{}";
            if (V < D.length + 1)
              return '"[Object]"';
            let U = "", M = Math.min(k, b);
            L && c(P) && (I += u(P, ",", b), j = j.slice(P.length), M -= P.length, U = ","), w && (j = o(j, C)), D.push(P);
            for (let T = 0; T < M; T++) {
              const N = j[T], G = $(N, P[N], D);
              G !== void 0 && (I += `${U}${s(N)}:${G}`, U = ",");
            }
            if (k > b) {
              const T = k - b;
              I += `${U}"...":"${d(T)} not stringified"`;
            }
            return D.pop(), `{${I}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : y ? y(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (R)
              return String(P);
          default:
            return y ? y(P) : void 0;
        }
      }
      function x(A, P, D) {
        if (arguments.length > 1) {
          let I = "";
          if (typeof D == "number" ? I = " ".repeat(Math.min(D, 10)) : typeof D == "string" && (I = D.slice(0, 10)), P != null) {
            if (typeof P == "function")
              return F("", { "": A }, [], P, I, "");
            if (Array.isArray(P))
              return H("", A, [], h(P), I, "");
          }
          if (I.length !== 0)
            return q("", A, [], I, "");
        }
        return $("", A, []);
      }
      return x;
    }
  }($c, $c.exports)), $c.exports;
}
var wd, s0;
function VI() {
  if (s0) return wd;
  s0 = 1;
  const e = Symbol.for("pino.metadata"), { DEFAULT_LEVELS: t } = vm(), r = t.info;
  function n(c, u) {
    let l = 0;
    c = c || [], u = u || { dedupe: !1 };
    const f = Object.create(t);
    f.silent = 1 / 0, u.levels && typeof u.levels == "object" && Object.keys(u.levels).forEach((y) => {
      f[y] = u.levels[y];
    });
    const m = {
      write: p,
      add: _,
      emit: d,
      flushSync: h,
      end: g,
      minLevel: 0,
      streams: [],
      clone: v,
      [e]: !0,
      streamLevels: f
    };
    return Array.isArray(c) ? c.forEach(_, m) : _.call(m, c), c = null, m;
    function p(y) {
      let E;
      const R = this.lastLevel, { streams: w } = this;
      let C = 0, V;
      for (let b = s(w.length, u.dedupe); a(b, w.length, u.dedupe); b = o(b, u.dedupe))
        if (E = w[b], E.level <= R) {
          if (C !== 0 && C !== E.level)
            break;
          if (V = E.stream, V[e]) {
            const { lastTime: F, lastMsg: H, lastObj: q, lastLogger: $ } = this;
            V.lastLevel = R, V.lastTime = F, V.lastMsg = H, V.lastObj = q, V.lastLogger = $;
          }
          V.write(y), u.dedupe && (C = E.level);
        } else if (!u.dedupe)
          break;
    }
    function d(...y) {
      for (const { stream: E } of this.streams)
        typeof E.emit == "function" && E.emit(...y);
    }
    function h() {
      for (const { stream: y } of this.streams)
        typeof y.flushSync == "function" && y.flushSync();
    }
    function _(y) {
      if (!y)
        return m;
      const E = typeof y.write == "function" || y.stream, R = y.write ? y : y.stream;
      if (!E)
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      const { streams: w, streamLevels: C } = this;
      let V;
      typeof y.levelVal == "number" ? V = y.levelVal : typeof y.level == "string" ? V = C[y.level] : typeof y.level == "number" ? V = y.level : V = r;
      const b = {
        stream: R,
        level: V,
        levelVal: void 0,
        id: l++
      };
      return w.unshift(b), w.sort(i), this.minLevel = w[0].level, m;
    }
    function g() {
      for (const { stream: y } of this.streams)
        typeof y.flushSync == "function" && y.flushSync(), y.end();
    }
    function v(y) {
      const E = new Array(this.streams.length);
      for (let R = 0; R < E.length; R++)
        E[R] = {
          level: y,
          stream: this.streams[R].stream
        };
      return {
        write: p,
        add: _,
        minLevel: y,
        streams: E,
        clone: v,
        emit: d,
        flushSync: h,
        [e]: !0
      };
    }
  }
  function i(c, u) {
    return c.level - u.level;
  }
  function s(c, u) {
    return u ? c - 1 : 0;
  }
  function o(c, u) {
    return u ? c - 1 : c + 1;
  }
  function a(c, u, l) {
    return l ? c >= 0 : c < u;
  }
  return wd = n, wd;
}
var o0;
function GI() {
  if (o0) return hr.exports;
  o0 = 1;
  const e = NS, t = dx(), r = px(), n = mx(), i = DI(), s = BI(), o = qa(), { configure: a } = zI(), { assertDefaultLevelFound: c, mappings: u, genLsCache: l, genLevelComparison: f, assertLevelComparison: m } = _x(), { DEFAULT_LEVELS: p, SORTING_ORDER: d } = vm(), {
    createArgsNormalizer: h,
    asChindings: _,
    buildSafeSonicBoom: g,
    buildFormatters: v,
    stringify: y,
    normalizeDestFileDescriptor: E,
    noop: R
  } = ym(), { version: w } = bx(), {
    chindingsSym: C,
    redactFmtSym: V,
    serializersSym: b,
    timeSym: F,
    timeSliceIndexSym: H,
    streamSym: q,
    stringifySym: $,
    stringifySafeSym: x,
    stringifiersSym: A,
    setLevelSym: P,
    endSym: D,
    formatOptsSym: I,
    messageKeySym: L,
    errorKeySym: j,
    nestedKeySym: k,
    mixinSym: U,
    levelCompSym: M,
    useOnlyCustomLevelsSym: T,
    formattersSym: N,
    hooksSym: G,
    nestedKeyStrSym: O,
    mixinMergeStrategySym: S,
    msgPrefixSym: W
  } = o, { epochTime: z, nullTime: Q } = i, { pid: K } = process, X = e.hostname(), J = t.err, re = {
    level: "info",
    levelComparison: d.ASC,
    levels: p,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: !0,
    base: { pid: K, hostname: X },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: J
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(xe) {
        return xe;
      },
      level(xe, ye) {
        return { level: ye };
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
    timestamp: z,
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: !1,
    depthLimit: 5,
    edgeLimit: 100
  }, fe = h(re), ee = Object.assign(/* @__PURE__ */ Object.create(null), t);
  function le(...xe) {
    const ye = {}, { opts: ve, stream: ze } = fe(ye, r(), ...xe);
    ve.level && typeof ve.level == "string" && p[ve.level.toLowerCase()] !== void 0 && (ve.level = ve.level.toLowerCase());
    const {
      redact: Ae,
      crlf: $t,
      serializers: $n,
      timestamp: Le,
      messageKey: Ut,
      errorKey: Er,
      nestedKey: Ne,
      base: je,
      name: mo,
      level: Mt,
      customLevels: dr,
      levelComparison: go,
      mixin: Ye,
      mixinMergeStrategy: ts,
      useOnlyCustomLevels: ai,
      formatters: _t,
      hooks: wr,
      depthLimit: pc,
      edgeLimit: Tn,
      onChild: Jt,
      msgPrefix: kr
    } = ve, Ht = a({
      maximumDepth: pc,
      maximumBreadth: Tn
    }), Sr = v(
      _t.level,
      _t.bindings,
      _t.log
    ), ln = y.bind({
      [x]: Ht
    }), or = Ae ? n(Ae, ln) : {}, ci = Ae ? { stringify: or[V] } : { stringify: ln }, Df = "}" + ($t ? `\r
` : `
`), hc = _.bind(null, {
      [C]: "",
      [b]: $n,
      [A]: or,
      [$]: y,
      [x]: Ht,
      [N]: Sr
    });
    let yo = "";
    je !== null && (mo === void 0 ? yo = hc(je) : yo = hc(Object.assign({}, je, { name: mo })));
    const mc = Le instanceof Function ? Le : Le ? z : Q, Lf = mc().indexOf(":") + 1;
    if (ai && !dr) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (Ye && typeof Ye != "function") throw Error(`Unknown mixin type "${typeof Ye}" - expected "function"`);
    if (kr && typeof kr != "string") throw Error(`Unknown msgPrefix type "${typeof kr}" - expected "string"`);
    c(Mt, dr, ai);
    const vo = u(dr, ai);
    typeof ze.emit == "function" && ze.emit("message", { code: "PINO_CONFIG", config: { levels: vo, messageKey: Ut, errorKey: Er } }), m(go);
    const _o = f(go);
    return Object.assign(ye, {
      levels: vo,
      [M]: _o,
      [T]: ai,
      [q]: ze,
      [F]: mc,
      [H]: Lf,
      [$]: y,
      [x]: Ht,
      [A]: or,
      [D]: Df,
      [I]: ci,
      [L]: Ut,
      [j]: Er,
      [k]: Ne,
      // protect against injection
      [O]: Ne ? `,${JSON.stringify(Ne)}:{` : "",
      [b]: $n,
      [U]: Ye,
      [S]: ts,
      [C]: yo,
      [N]: Sr,
      [G]: wr,
      silent: R,
      onChild: Jt,
      [W]: kr
    }), Object.setPrototypeOf(ye, s()), l(ye), ye[P](Mt), ye;
  }
  return hr.exports = le, hr.exports.destination = (xe = process.stdout.fd) => typeof xe == "object" ? (xe.dest = E(xe.dest || process.stdout.fd), g(xe)) : g({ dest: E(xe), minLength: 0 }), hr.exports.transport = vx(), hr.exports.multistream = VI(), hr.exports.levels = u(), hr.exports.stdSerializers = ee, hr.exports.stdTimeFunctions = Object.assign({}, i), hr.exports.symbols = o, hr.exports.version = w, hr.exports.default = le, hr.exports.pino = le, hr.exports;
}
var Sd, a0;
function WI() {
  if (a0) return Sd;
  a0 = 1;
  const e = GI(), { serializersSym: t } = e.symbols, {
    FST_ERR_LOG_INVALID_DESTINATION: r
  } = Kt;
  function n(s) {
    if (s.stream && s.file)
      throw new r();
    s.file && (s.stream = e.destination(s.file), delete s.file);
    const o = s.logger, a = s.genReqId;
    let c = null;
    return o ? (s.logger = void 0, s.genReqId = void 0, o[t] && (s.serializers = Object.assign({}, s.serializers, o[t])), c = o.child({}, s), s.logger = o, s.genReqId = a) : c = e(s, s.stream), c;
  }
  return Sd = {
    serializers: {
      req: function(o) {
        return {
          method: o.method,
          url: o.url,
          version: o.headers && o.headers["accept-version"],
          host: o.host,
          remoteAddress: o.ip,
          remotePort: o.socket ? o.socket.remotePort : void 0
        };
      },
      err: e.stdSerializers.err,
      res: function(o) {
        return {
          statusCode: o.statusCode
        };
      }
    },
    createPinoLogger: n
  }, Sd;
}
const {
  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: KI,
  FST_ERR_LOG_INVALID_LOGGER_CONFIG: YI,
  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: JI,
  FST_ERR_LOG_INVALID_LOGGER: XI
} = Kt;
function ZI(e, t, r, n, i) {
  const s = {
    [e.requestIdLogLabel]: n
  }, o = e.childLoggerFactory.call(e.server, t, s, i || {}, r);
  return e.childLoggerFactory !== Ex && ch(o, !0), o;
}
function Ex(e, t, r) {
  return e.child(t, r);
}
function ch(e, t) {
  const r = ["info", "error", "debug", "fatal", "warn", "trace", "child"], n = e ? r.filter((i) => !e[i] || typeof e[i] != "function") : r;
  if (n.length) {
    if (n.length === r.length && !t)
      return !1;
    throw XI(n.join(","));
  } else return !0;
}
function QI(e) {
  if (e.logger && e.loggerInstance)
    throw new KI();
  if (!e.loggerInstance && !e.logger) {
    const o = xI();
    return o.child = () => o, { logger: o, hasLogger: !1 };
  }
  const { createPinoLogger: t, serializers: r } = WI();
  if (ch(e.loggerInstance))
    return { logger: t({
      logger: e.loggerInstance,
      serializers: Object.assign({}, r, e.loggerInstance.serializers)
    }), hasLogger: !0 };
  if (ch(e.logger))
    throw YI();
  if (e.loggerInstance)
    throw JI();
  const n = {};
  return Object.prototype.toString.call(e.logger) === "[object Object]" && Reflect.ownKeys(e.logger).forEach((s) => {
    Object.defineProperty(n, s, {
      value: e.logger[s],
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }), n.level = n.level || "info", n.serializers = Object.assign({}, r, n.serializers), e.logger = n, { logger: t(e.logger), hasLogger: !0 };
}
function eN() {
  const e = process.hrtime();
  return e[0] * 1e3 + e[1] / 1e6;
}
var Ou = {
  createChildLogger: ZI,
  defaultChildLoggerFactory: Ex,
  createLogger: QI,
  now: eN
}, _m = tN;
function Ns(e) {
  return e instanceof Buffer ? Buffer.from(e) : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
}
function tN(e) {
  if (e = e || {}, e.circles) return rN(e);
  const t = /* @__PURE__ */ new Map();
  if (t.set(Date, (o) => new Date(o)), t.set(Map, (o, a) => new Map(n(Array.from(o), a))), t.set(Set, (o, a) => new Set(n(Array.from(o), a))), e.constructorHandlers)
    for (const o of e.constructorHandlers)
      t.set(o[0], o[1]);
  let r = null;
  return e.proto ? s : i;
  function n(o, a) {
    const c = Object.keys(o), u = new Array(c.length);
    for (let l = 0; l < c.length; l++) {
      const f = c[l], m = o[f];
      typeof m != "object" || m === null ? u[f] = m : m.constructor !== Object && (r = t.get(m.constructor)) ? u[f] = r(m, a) : ArrayBuffer.isView(m) ? u[f] = Ns(m) : u[f] = a(m);
    }
    return u;
  }
  function i(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, i);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, i);
    const a = {};
    for (const c in o) {
      if (Object.hasOwnProperty.call(o, c) === !1) continue;
      const u = o[c];
      typeof u != "object" || u === null ? a[c] = u : u.constructor !== Object && (r = t.get(u.constructor)) ? a[c] = r(u, i) : ArrayBuffer.isView(u) ? a[c] = Ns(u) : a[c] = i(u);
    }
    return a;
  }
  function s(o) {
    if (typeof o != "object" || o === null) return o;
    if (Array.isArray(o)) return n(o, s);
    if (o.constructor !== Object && (r = t.get(o.constructor)))
      return r(o, s);
    const a = {};
    for (const c in o) {
      const u = o[c];
      typeof u != "object" || u === null ? a[c] = u : u.constructor !== Object && (r = t.get(u.constructor)) ? a[c] = r(u, s) : ArrayBuffer.isView(u) ? a[c] = Ns(u) : a[c] = s(u);
    }
    return a;
  }
}
function rN(e) {
  const t = [], r = [], n = /* @__PURE__ */ new Map();
  if (n.set(Date, (c) => new Date(c)), n.set(Map, (c, u) => new Map(s(Array.from(c), u))), n.set(Set, (c, u) => new Set(s(Array.from(c), u))), e.constructorHandlers)
    for (const c of e.constructorHandlers)
      n.set(c[0], c[1]);
  let i = null;
  return e.proto ? a : o;
  function s(c, u) {
    const l = Object.keys(c), f = new Array(l.length);
    for (let m = 0; m < l.length; m++) {
      const p = l[m], d = c[p];
      if (typeof d != "object" || d === null)
        f[p] = d;
      else if (d.constructor !== Object && (i = n.get(d.constructor)))
        f[p] = i(d, u);
      else if (ArrayBuffer.isView(d))
        f[p] = Ns(d);
      else {
        const h = t.indexOf(d);
        h !== -1 ? f[p] = r[h] : f[p] = u(d);
      }
    }
    return f;
  }
  function o(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return s(c, o);
    if (c.constructor !== Object && (i = n.get(c.constructor)))
      return i(c, o);
    const u = {};
    t.push(c), r.push(u);
    for (const l in c) {
      if (Object.hasOwnProperty.call(c, l) === !1) continue;
      const f = c[l];
      if (typeof f != "object" || f === null)
        u[l] = f;
      else if (f.constructor !== Object && (i = n.get(f.constructor)))
        u[l] = i(f, o);
      else if (ArrayBuffer.isView(f))
        u[l] = Ns(f);
      else {
        const m = t.indexOf(f);
        m !== -1 ? u[l] = r[m] : u[l] = o(f);
      }
    }
    return t.pop(), r.pop(), u;
  }
  function a(c) {
    if (typeof c != "object" || c === null) return c;
    if (Array.isArray(c)) return s(c, a);
    if (c.constructor !== Object && (i = n.get(c.constructor)))
      return i(c, a);
    const u = {};
    t.push(c), r.push(u);
    for (const l in c) {
      const f = c[l];
      if (typeof f != "object" || f === null)
        u[l] = f;
      else if (f.constructor !== Object && (i = n.get(f.constructor)))
        u[l] = i(f, a);
      else if (ArrayBuffer.isView(f))
        u[l] = Ns(f);
      else {
        const m = t.indexOf(f);
        m !== -1 ? u[l] = r[m] : u[l] = a(f);
      }
    }
    return t.pop(), r.pop(), u;
  }
}
const nN = _m({ circles: !1, proto: !0 }), { kSchemaVisited: c0, kSchemaResponse: iN } = Ft, lh = Symbol.for("fluent-schema-object"), {
  FST_ERR_SCH_MISSING_ID: sN,
  FST_ERR_SCH_ALREADY_PRESENT: oN,
  FST_ERR_SCH_DUPLICATE: aN,
  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: l0
} = Kt, wx = ["params", "body", "querystring", "query", "headers"];
function Pu(e) {
  this.store = e || {};
}
Pu.prototype.add = function(e) {
  const t = nN(
    e.isFluentSchema || e.isFluentJSONSchema || e[lh] ? e.valueOf() : e
  ), r = t.$id;
  if (!r)
    throw new sN();
  if (this.store[r])
    throw new oN(r);
  this.store[r] = t;
};
Pu.prototype.getSchemas = function() {
  return Object.assign({}, this.store);
};
Pu.prototype.getSchema = function(e) {
  return this.store[e];
};
function u0(e) {
  return typeof e == "object" && Object.getPrototypeOf(e) !== Object.prototype;
}
function cN(e, t) {
  if (e[c0])
    return e;
  if (e.query) {
    if (e.querystring)
      throw new aN("querystring");
    e.querystring = e.query;
  }
  lN(e);
  for (const r of wx) {
    const n = e[r];
    if (n && !u0(n) && r === "body" && n.content) {
      const i = n.content, s = Object.keys(i);
      for (let o = 0; o < s.length; o++) {
        const a = s[o];
        if (!i[a].schema)
          throw new l0(a);
      }
      continue;
    }
  }
  if (e.response) {
    const r = Object.keys(e.response);
    for (const n of r) {
      if (u0(e.response[n]))
        continue;
      const i = e.response[n].content;
      if (i) {
        const s = Object.keys(i);
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (!i[a].schema)
            throw new l0(a);
        }
      }
    }
  }
  return e[c0] = !0, e;
}
function lN(e) {
  for (const t of wx)
    e[t] && (e[t].isFluentSchema || e[t][lh]) && (e[t] = e[t].valueOf());
  if (e.response) {
    const t = Object.keys(e.response);
    for (const r of t)
      (e.response[r].isFluentSchema || e.response[r][lh]) && (e.response[r] = e.response[r].valueOf());
  }
}
function uN(e, t, r) {
  const n = e[iN];
  if (!n)
    return !1;
  if (n[t]) {
    if (n[t].constructor === Object && r) {
      const s = r.split(";", 1)[0];
      return n[t][s] ? n[t][s] : n[t]["*/*"] ? n[t]["*/*"] : !1;
    }
    return n[t];
  }
  const i = (t + "")[0] + "xx";
  if (n[i]) {
    if (n[i].constructor === Object && r) {
      const s = r.split(";", 1)[0];
      return n[i][s] ? n[i][s] : n[i]["*/*"] ? n[i]["*/*"] : !1;
    }
    return n[i];
  }
  if (n.default) {
    if (n.default.constructor === Object && r) {
      const s = r.split(";", 1)[0];
      return n.default[s] ? n.default[s] : n.default["*/*"] ? n.default["*/*"] : !1;
    }
    return n.default;
  }
  return !1;
}
var Cu = {
  buildSchemas(e) {
    return new Pu(e);
  },
  getSchemaSerializer: uN,
  normalizeSchema: cN
};
const fN = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
var bm = class Sx {
  constructor(t) {
    switch (t && t.rounding) {
      case "floor":
        this.parseInteger = Math.floor;
        break;
      case "ceil":
        this.parseInteger = Math.ceil;
        break;
      case "round":
        this.parseInteger = Math.round;
        break;
      case "trunc":
      default:
        this.parseInteger = Math.trunc;
        break;
    }
    this._options = t;
  }
  asInteger(t) {
    if (Number.isInteger(t))
      return "" + t;
    if (typeof t == "bigint")
      return t.toString();
    const r = this.parseInteger(t);
    if (r === 1 / 0 || r === -1 / 0 || r !== r)
      throw new Error(`The value "${t}" cannot be converted to an integer.`);
    return "" + r;
  }
  asNumber(t) {
    const r = Number(t);
    if (r !== r)
      throw new Error(`The value "${t}" cannot be converted to a number.`);
    return r === 1 / 0 || r === -1 / 0 ? "null" : "" + r;
  }
  asBoolean(t) {
    return t && "true" || "false";
  }
  asDateTime(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + t.toISOString() + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date-time.`);
  }
  asDate(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a date.`);
  }
  asTime(t) {
    if (t === null) return '""';
    if (t instanceof Date)
      return '"' + new Date(t.getTime() - t.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
    if (typeof t == "string")
      return '"' + t + '"';
    throw new Error(`The value "${t}" cannot be converted to a time.`);
  }
  asString(t) {
    const r = t.length;
    if (r < 42) {
      let n = "", i = -1, s = 255;
      for (let o = 0; o < r; o++)
        if (s = t.charCodeAt(o), s === 34 || // '"'
        s === 92)
          i === -1 && (i = 0), n += t.slice(i, o) + "\\", i = o;
        else if (s < 32 || s >= 55296 && s <= 57343)
          return JSON.stringify(t);
      return i === -1 && '"' + t + '"' || '"' + n + t.slice(i) + '"';
    } else return r < 5e3 && fN.test(t) === !1 ? '"' + t + '"' : JSON.stringify(t);
  }
  asUnsafeString(t) {
    return '"' + t + '"';
  }
  getState() {
    return this._options;
  }
  static restoreFromState(t) {
    return new Sx(t);
  }
};
const dN = bm, pN = { mode: "standalone" }, hN = dN.restoreFromState(pN), mN = null;
var gN = function(t, r) {
  const n = "{", i = "}", s = ",", o = '"', a = n + i, c = o + o;
  function u(f) {
    const m = f && typeof f.toJSON == "function" ? f.toJSON() : f;
    if (m === null) return a;
    let p, d = n, h = !1;
    return p = m.statusCode, p !== void 0 && (!h && (h = !0) || (d += s), d += '"statusCode":', d += r.asNumber(p)), p = m.code, p !== void 0 && (!h && (h = !0) || (d += s), d += '"code":', typeof p != "string" ? p === null ? d += c : p instanceof Date ? d += o + p.toISOString() + o : p instanceof RegExp ? d += r.asString(p.source) : d += r.asString(p.toString()) : d += r.asString(p)), p = m.error, p !== void 0 && (!h && (h = !0) || (d += s), d += '"error":', typeof p != "string" ? p === null ? d += c : p instanceof Date ? d += o + p.toISOString() + o : p instanceof RegExp ? d += r.asString(p.source) : d += r.asString(p.toString()) : d += r.asString(p)), p = m.message, p !== void 0 && (!h && (h = !0) || (d += s), d += '"message":', typeof p != "string" ? p === null ? d += c : p instanceof Date ? d += o + p.toISOString() + o : p instanceof RegExp ? d += r.asString(p.source) : d += r.asString(p.toString()) : d += r.asString(p)), d + i;
  }
  return u;
}(mN, hN);
const f0 = gu.STATUS_CODES, yN = cx, {
  kReplyHeaders: Ai,
  kReplyNextErrorHandler: Tc,
  kReplyIsRunningOnErrorHook: vN,
  kReplyHasStatusCode: _N,
  kRouteContext: xx,
  kDisableRequestLogging: kl
} = Ft, {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: bN,
  FST_ERR_FAILED_ERROR_SERIALIZATION: EN
} = Kt, { getSchemaSerializer: wN } = Cu, xd = gN, SN = {
  func: RN,
  toJSON() {
    return this.func.name.toString() + "()";
  }
};
function xN(e, t, r) {
  e[vN] = !1;
  const n = e[xx];
  if (e[Tc] === !1) {
    d0(t, e, function(o, a) {
      try {
        o.raw.writeHead(o.raw.statusCode, o[Ai]);
      } catch (c) {
        o.log[kl] || o.log.warn(
          { req: o.request, res: o, err: c },
          c && c.message
        ), o.raw.writeHead(o.raw.statusCode);
      }
      o.raw.end(a);
    });
    return;
  }
  const i = e[Tc] || n.errorHandler;
  e[Tc] = Object.getPrototypeOf(i), delete e[Ai]["content-type"], delete e[Ai]["content-length"];
  const s = i.func;
  if (!s) {
    e[Tc] = !1, d0(t, e, r);
    return;
  }
  try {
    const o = s(t, e.request, e);
    o !== void 0 && (o !== null && typeof o.then == "function" ? yN(o, e) : e.send(o));
  } catch (o) {
    e.send(o);
  }
}
function RN(e, t, r) {
  if (TN(e, r), !r[_N] || r.statusCode === 200) {
    const n = e.statusCode || e.status;
    r.code(n >= 400 ? n : 500);
  }
  r.statusCode < 500 ? r.log[kl] || r.log.info(
    { res: r, err: e },
    e && e.message
  ) : r.log[kl] || r.log.error(
    { req: t, res: r, err: e },
    e && e.message
  ), r.send(e);
}
function d0(e, t, r) {
  const n = t.raw, i = t.statusCode;
  t[Ai]["content-type"] = t[Ai]["content-type"] ?? "application/json; charset=utf-8";
  let s;
  try {
    const o = wN(t[xx], i, t[Ai]["content-type"]);
    o === !1 ? s = xd({
      error: f0[i + ""],
      code: e.code,
      message: e.message,
      statusCode: i
    }) : s = o(Object.create(e, {
      error: { value: f0[i + ""] },
      message: { value: e.message },
      statusCode: { value: i }
    }));
  } catch (o) {
    t.log[kl] || t.log.error({ err: o, statusCode: n.statusCode }, "The serializer for the given status code failed"), t.code(500), s = xd(new EN(o.message, e.message));
  }
  typeof s != "string" && !Buffer.isBuffer(s) && (s = xd(new bN(typeof s))), t[Ai]["content-length"] = "" + Buffer.byteLength(s), r(t, s);
}
function $N(e = SN, t) {
  if (!t)
    return e;
  const r = Object.create(e);
  return r.func = t, r;
}
function TN(e, t) {
  const r = t.raw;
  let n = r.statusCode;
  n = n >= 400 ? n : 500, e != null && (e.headers !== void 0 && t.headers(e.headers), e.status >= 400 ? n = e.status : e.statusCode >= 400 && (n = e.statusCode)), r.statusCode = n;
}
var Au = {
  buildErrorHandler: $N,
  handleError: xN
};
const uh = ka.finished, ON = ka.Readable, {
  kFourOhFourContext: p0,
  kReplyErrorHandlerCalled: Rx,
  kReplyHijacked: Em,
  kReplyStartTime: ia,
  kReplyEndTime: wm,
  kReplySerializer: _n,
  kReplySerializerDefault: Dl,
  kReplyIsError: Ll,
  kReplyHeaders: Ve,
  kReplyTrailers: St,
  kReplyHasStatusCode: Sm,
  kReplyIsRunningOnErrorHook: xm,
  kReplyNextErrorHandler: PN,
  kDisableRequestLogging: $x,
  kSchemaResponse: Fl,
  kReplyCacheSerializeFns: Hn,
  kSchemaController: Rd,
  kOptions: CN,
  kRouteContext: Te
} = Ft, {
  onSendHookRunner: Tx,
  onResponseHookRunner: AN,
  preHandlerHookRunner: IN,
  preSerializationHookRunner: NN
} = Yi, h0 = lx[Symbol.for("internals")], kN = Ou, fh = kN.now, { handleError: m0 } = Au, { getSchemaSerializer: DN } = Cu, $d = {
  JSON: "application/json; charset=utf-8",
  PLAIN: "text/plain; charset=utf-8",
  OCTET: "application/octet-stream"
}, {
  FST_ERR_REP_INVALID_PAYLOAD_TYPE: LN,
  FST_ERR_REP_RESPONSE_BODY_CONSUMED: FN,
  FST_ERR_REP_READABLE_STREAM_LOCKED: jN,
  FST_ERR_REP_ALREADY_SENT: UN,
  FST_ERR_SEND_INSIDE_ONERR: MN,
  FST_ERR_BAD_STATUS_CODE: HN,
  FST_ERR_BAD_TRAILER_NAME: qN,
  FST_ERR_BAD_TRAILER_VALUE: BN,
  FST_ERR_MISSING_SERIALIZATION_FN: zN,
  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: VN
} = Kt, Ox = Object.prototype.toString;
function Be(e, t, r) {
  this.raw = e, this[_n] = null, this[Rx] = !1, this[Ll] = !1, this[xm] = !1, this.request = t, this[Ve] = {}, this[St] = null, this[Sm] = !1, this[ia] = void 0, this.log = r;
}
Be.props = [];
Object.defineProperties(Be.prototype, {
  [Te]: {
    get() {
      return this.request[Te];
    }
  },
  elapsedTime: {
    get() {
      return this[ia] === void 0 ? 0 : (this[wm] || fh()) - this[ia];
    }
  },
  server: {
    get() {
      return this.request[Te].server;
    }
  },
  sent: {
    enumerable: !0,
    get() {
      return (this[Em] || this.raw.writableEnded) === !0;
    }
  },
  statusCode: {
    get() {
      return this.raw.statusCode;
    },
    set(e) {
      this.code(e);
    }
  },
  routeOptions: {
    get() {
      return this.request.routeOptions;
    }
  }
});
Be.prototype.writeEarlyHints = function(e, t) {
  return this.raw.writeEarlyHints(e, t), this;
};
Be.prototype.hijack = function() {
  return this[Em] = !0, this;
};
Be.prototype.send = function(e) {
  if (this[xm] === !0)
    throw new MN();
  if (this.sent)
    return this.log.warn({ err: new UN(this.request.url, this.request.method) }), this;
  if (e instanceof Error || this[Ll] === !0)
    return this[Ll] = !1, sa(this, e, wi), this;
  if (e === void 0)
    return wi(this, e), this;
  const t = this.getHeader("content-type"), r = t !== void 0;
  if (e !== null) {
    if (
      // node:stream
      typeof e.pipe == "function" || // node:stream/web
      typeof e.getReader == "function" || // Response
      Ox.call(e) === "[object Response]"
    )
      return wi(this, e), this;
    if ((e == null ? void 0 : e.buffer) instanceof ArrayBuffer) {
      r === !1 && (this[Ve]["content-type"] = $d.OCTET);
      const n = Buffer.isBuffer(e) ? e : Buffer.from(e.buffer, e.byteOffset, e.byteLength);
      return wi(this, n), this;
    }
    if (r === !1 && typeof e == "string")
      return this[Ve]["content-type"] = $d.PLAIN, wi(this, e), this;
  }
  if (this[_n] !== null) {
    if (typeof e != "string")
      return g0(this, e), this;
    e = this[_n](e);
  } else if (r === !1 || t.indexOf("json") > -1) {
    if (r === !1)
      this[Ve]["content-type"] = $d.JSON;
    else if (t.indexOf("charset") === -1) {
      const n = t.trim();
      n.endsWith(";") ? this[Ve]["content-type"] = `${n} charset=utf-8` : this[Ve]["content-type"] = `${n}; charset=utf-8`;
    }
    if (typeof e != "string")
      return g0(this, e), this;
  }
  return wi(this, e), this;
};
Be.prototype.getHeader = function(e) {
  e = e.toLowerCase();
  const t = this.raw;
  let r = this[Ve][e];
  return r === void 0 && t.hasHeader(e) && (r = t.getHeader(e)), r;
};
Be.prototype.getHeaders = function() {
  return {
    ...this.raw.getHeaders(),
    ...this[Ve]
  };
};
Be.prototype.hasHeader = function(e) {
  return e = e.toLowerCase(), this[Ve][e] !== void 0 || this.raw.hasHeader(e);
};
Be.prototype.removeHeader = function(e) {
  return delete this[Ve][e.toLowerCase()], this;
};
Be.prototype.header = function(e, t = "") {
  return e = e.toLowerCase(), this[Ve][e] && e === "set-cookie" ? (typeof this[Ve][e] == "string" && (this[Ve][e] = [this[Ve][e]]), Array.isArray(t) ? Array.prototype.push.apply(this[Ve][e], t) : this[Ve][e].push(t)) : this[Ve][e] = t, this;
};
Be.prototype.headers = function(e) {
  const t = Object.keys(e);
  for (let r = 0; r !== t.length; ++r) {
    const n = t[r];
    this.header(n, e[n]);
  }
  return this;
};
const GN = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "content-length",
  "host",
  "cache-control",
  "max-forwards",
  "te",
  "authorization",
  "set-cookie",
  "content-encoding",
  "content-type",
  "content-range",
  "trailer"
]);
Be.prototype.trailer = function(e, t) {
  if (e = e.toLowerCase(), GN.has(e))
    throw new qN(e);
  if (typeof t != "function")
    throw new BN(e, typeof t);
  return this[St] === null && (this[St] = {}), this[St][e] = t, this;
};
Be.prototype.hasTrailer = function(e) {
  var t;
  return ((t = this[St]) == null ? void 0 : t[e.toLowerCase()]) !== void 0;
};
Be.prototype.removeTrailer = function(e) {
  return this[St] === null ? this : (this[St][e.toLowerCase()] = void 0, this);
};
Be.prototype.code = function(e) {
  const t = Number(e);
  if (isNaN(t) || t < 100 || t > 599)
    throw new HN(e || String(e));
  return this.raw.statusCode = t, this[Sm] = !0, this;
};
Be.prototype.status = Be.prototype.code;
Be.prototype.getSerializationFunction = function(e, t) {
  var n, i, s, o;
  let r;
  return typeof e == "string" || typeof e == "number" ? typeof t == "string" ? r = (i = (n = this[Te][Fl]) == null ? void 0 : n[e]) == null ? void 0 : i[t] : r = (s = this[Te][Fl]) == null ? void 0 : s[e] : typeof e == "object" && (r = (o = this[Te][Hn]) == null ? void 0 : o.get(e)), r;
};
Be.prototype.compileSerializationSchema = function(e, t = null, r = null) {
  var c;
  const { request: n } = this, { method: i, url: s } = n;
  if ((c = this[Te][Hn]) != null && c.has(e))
    return this[Te][Hn].get(e);
  const a = (this[Te].serializerCompiler || this.server[Rd].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
  // nor set
  this.server[Rd].setupSerializer(this.server[CN]) || this.server[Rd].serializerCompiler)({
    schema: e,
    method: i,
    url: s,
    httpStatus: t,
    contentType: r
  });
  return this[Te][Hn] == null && (this[Te][Hn] = /* @__PURE__ */ new WeakMap()), this[Te][Hn].set(e, a), a;
};
Be.prototype.serializeInput = function(e, t, r, n) {
  var o, a, c, u;
  const i = r;
  let s;
  if (r = typeof t == "string" || typeof t == "number" ? t : r, n = r && i !== r ? i : n, r != null) {
    if (n != null ? s = (a = (o = this[Te][Fl]) == null ? void 0 : o[r]) == null ? void 0 : a[n] : s = (c = this[Te][Fl]) == null ? void 0 : c[r], s == null)
      throw n ? new VN(r, n) : new zN(r);
  } else
    (u = this[Te][Hn]) != null && u.has(t) ? s = this[Te][Hn].get(t) : s = this.compileSerializationSchema(t, r, n);
  return s(e);
};
Be.prototype.serialize = function(e) {
  return this[_n] !== null ? this[_n](e) : this[Te] && this[Te][Dl] ? this[Te][Dl](e, this.raw.statusCode) : Ax(this[Te], e, this.raw.statusCode);
};
Be.prototype.serializer = function(e) {
  return this[_n] = e, this;
};
Be.prototype.type = function(e) {
  return this[Ve]["content-type"] = e, this;
};
Be.prototype.redirect = function(e, t) {
  return t || (t = this[Sm] ? this.raw.statusCode : 302), this.header("location", e).code(t).send();
};
Be.prototype.callNotFound = function() {
  return QN(this), this;
};
Be.prototype.then = function(e, t) {
  if (this.sent) {
    e();
    return;
  }
  uh(this.raw, (r) => {
    r && r.code !== "ERR_STREAM_PREMATURE_CLOSE" ? t ? t(r) : this.log && this.log.warn("unhandled rejection on reply.then") : e();
  });
};
function g0(e, t) {
  e[Te].preSerialization !== null ? NN(
    e[Te].preSerialization,
    e.request,
    e,
    t,
    y0
  ) : y0(null, e.request, e, t);
}
function y0(e, t, r, n) {
  if (e != null) {
    sa(r, e);
    return;
  }
  try {
    r[_n] !== null ? n = r[_n](n) : r[Te] && r[Te][Dl] ? n = r[Te][Dl](n, r.raw.statusCode) : n = Ax(r[Te], n, r.raw.statusCode, r[Ve]["content-type"]);
  } catch (i) {
    WN(i, r), sa(r, i);
    return;
  }
  wi(r, n);
}
function WN(e, t) {
  e.serialization = t[Te].config;
}
function wi(e, t) {
  e[Te].onSend !== null ? Tx(
    e[Te].onSend,
    e.request,
    e,
    t,
    KN
  ) : Px(e, t);
}
function KN(e, t, r, n) {
  e != null ? sa(r, e) : Px(r, n);
}
function Td(e, t) {
  const r = e.raw;
  try {
    r.writeHead(t, e[Ve]);
  } catch (n) {
    throw n.code === "ERR_HTTP_HEADERS_SENT" && e.log.warn(`Reply was already sent, did you forget to "return reply" in the "${e.request.raw.url}" (${e.request.raw.method}) route?`), n;
  }
}
function Px(e, t) {
  const r = e.raw, n = e.request;
  if (e[St] !== null) {
    const s = Object.keys(e[St]);
    let o = "";
    for (const a of s)
      typeof e[St][a] == "function" && (o += " ", o += a);
    e.header("Transfer-Encoding", "chunked"), e.header("Trailer", o.trim());
  }
  if (Ox.call(t) === "[object Response]") {
    if (typeof t.status == "number" && e.code(t.status), typeof t.headers == "object" && typeof t.headers.forEach == "function")
      for (const [s, o] of t.headers)
        e.header(s, o);
    if (t.body !== null && t.bodyUsed)
      throw new FN();
    t = t.body;
  }
  const i = r.statusCode;
  if (t == null) {
    i >= 200 && i !== 204 && i !== 304 && n.method !== "HEAD" && e[St] === null && (e[Ve]["content-length"] = "0"), Td(e, i), fl(t, r, e);
    return;
  }
  if (i >= 100 && i < 200 || i === 204) {
    e.removeHeader("content-type"), e.removeHeader("content-length"), Td(e, i), fl(void 0, r, e), typeof t.resume == "function" && (t.on("error", Ix), t.resume());
    return;
  }
  if (typeof t.pipe == "function") {
    Cx(t, r, e);
    return;
  }
  if (typeof t.getReader == "function") {
    YN(t, r, e);
    return;
  }
  if (typeof t != "string" && !Buffer.isBuffer(t))
    throw new LN(typeof t);
  if (e[St] === null) {
    const s = e[Ve]["content-length"];
    (!s || n.raw.method !== "HEAD" && Number(s) !== Buffer.byteLength(t)) && (e[Ve]["content-length"] = "" + Buffer.byteLength(t));
  }
  Td(e, i), r.write(t), fl(t, r, e);
}
function v0(e, t, r) {
  t.code === "ERR_STREAM_PREMATURE_CLOSE" ? e[$x] || e.info({ res: r }, "stream closed prematurely") : e.warn({ err: t }, "response terminated with an error with headers already sent");
}
function YN(e, t, r) {
  if (e.locked)
    throw jN();
  const n = ON.fromWeb(e);
  Cx(n, t, r);
}
function Cx(e, t, r) {
  let n = !0, i = !1;
  if (JN(e, t, r), uh(e, { readable: !0, writable: !1 }, function(s) {
    n = !1, s != null && (t.headersSent || r.request.raw.aborted === !0 ? (i || (i = !0, v0(r.log, s, r)), t.destroy()) : sa(r, s));
  }), uh(t, function(s) {
    n && (s != null && t.headersSent && !i && (i = !0, v0(r.log, s, t)), typeof e.destroy == "function" ? e.destroy() : typeof e.close == "function" ? e.close(Ix) : typeof e.abort == "function" ? e.abort() : r.log.warn("stream payload does not end properly"));
  }), t.headersSent)
    r.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
  else
    for (const s in r[Ve])
      t.setHeader(s, r[Ve][s]);
  e.pipe(t);
}
function fl(e, t, r) {
  if (r[St] === null) {
    t.end(null, null, null);
    return;
  }
  const n = Object.keys(r[St]), i = {};
  let s = 0, o = !0;
  function a() {
    s === 0 && (t.addTrailers(i), t.end(null, null, null));
  }
  for (const c of n) {
    let u = function(f, m) {
      s++, f ? r.log.debug(f) : i[c] = m, process.nextTick(a);
    };
    if (typeof r[St][c] != "function") continue;
    o = !1, s--;
    const l = r[St][c](r, e, u);
    typeof l == "object" && typeof l.then == "function" && l.then((f) => u(null, f), u);
  }
  o && t.end(null, null, null);
}
function JN(e, t, r) {
  r[St] !== null && e.on("end", () => fl(null, t, r));
}
function sa(e, t, r) {
  e[Te].onError !== null && !e[PN] ? (e[xm] = !0, Tx(
    e[Te].onError,
    e.request,
    e,
    t,
    () => m0(e, t, r)
  )) : m0(e, t, r);
}
function XN(e) {
  e[ia] = fh();
  const t = (r) => {
    e[wm] = fh(), e.raw.removeListener("finish", t), e.raw.removeListener("error", t);
    const n = e[Te];
    n && n.onResponse !== null ? AN(
      n.onResponse,
      e.request,
      e,
      _0
    ) : _0(r, e.request, e);
  };
  e.raw.on("finish", t), e.raw.on("error", t);
}
function _0(e, t, r) {
  if (r.log[$x])
    return;
  const n = r.elapsedTime;
  if (e != null) {
    r.log.error({
      res: r,
      err: e,
      responseTime: n
    }, "request errored");
    return;
  }
  r.log.info({
    res: r,
    responseTime: n
  }, "request completed");
}
function ZN(e) {
  const t = e.props.slice();
  function r(n, i, s) {
    this.raw = n, this[Ll] = !1, this[Rx] = !1, this[Em] = !1, this[_n] = null, this.request = i, this[Ve] = {}, this[St] = null, this[ia] = void 0, this[wm] = void 0, this.log = s;
    let o;
    for (let a = 0; a < t.length; a++)
      o = t[a], this[o.key] = o.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.parent = e, r.props = t, r;
}
function QN(e) {
  if (e[Te][p0] === null) {
    e.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response."), e.code(404).send("404 Not Found");
    return;
  }
  e.request[Te] = e[Te][p0], e[Te].preHandler !== null ? IN(
    e[Te].preHandler,
    e.request,
    e,
    h0.preHandlerCallback
  ) : h0.preHandlerCallback(null, e.request, e);
}
function Ax(e, t, r, n) {
  const i = DN(e, r, n);
  return i ? i(t) : JSON.stringify(t);
}
function Ix() {
}
$u.exports = Be;
$u.exports.buildReply = ZN;
$u.exports.setupResponseListeners = XN;
var Rm = $u.exports, $m = { exports: {} }, Qs = { exports: {} }, Iu = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
function Tm(e) {
  if (!e)
    throw new TypeError("argument req is required");
  const t = e.headers["x-forwarded-for"], r = e.socket.remoteAddress;
  if (!t || typeof t != "string")
    return [r];
  if (t.indexOf(",") === -1) {
    const n = t.trim();
    return n.length ? [r, n] : [r];
  } else
    return ek(t, r);
}
function ek(e, t) {
  const r = [t];
  let n = e.length, i = n, s, o;
  for (o = n - 1; o >= 0; --o)
    s = e[o], s === " " ? i === n && (i = n = o) : s === "," ? (i !== n && r.push(e.slice(i, n)), i = n = o) : i = o;
  return i !== n && r.push(e.substring(i, n)), r;
}
Iu.exports = Tm;
Iu.exports.default = Tm;
Iu.exports.forwarded = Tm;
var tk = Iu.exports, Nx = { exports: {} };
(function(e) {
  (function(t) {
    const r = "(0?\\d+|0x[a-f0-9]+)", n = {
      fourOctet: new RegExp(`^${r}\\.${r}\\.${r}\\.${r}$`, "i"),
      threeOctet: new RegExp(`^${r}\\.${r}\\.${r}$`, "i"),
      twoOctet: new RegExp(`^${r}\\.${r}$`, "i"),
      longValue: new RegExp(`^${r}$`, "i")
    }, i = new RegExp("^0[0-7]+$", "i"), s = new RegExp("^0x[a-f0-9]+$", "i"), o = "%[0-9a-z]{1,}", a = "(?:[0-9a-f]+::?)+", c = {
      zoneIndex: new RegExp(o, "i"),
      native: new RegExp(`^(::)?(${a})?([0-9a-f]+)?(::)?(${o})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${r}\\.${r}\\.${r}\\.${r}(${o})?)$`, "i"),
      transitional: new RegExp(`^((?:${a})|(?:::)(?:${a})?)${r}\\.${r}\\.${r}\\.${r}(${o})?$`, "i")
    };
    function u(d, h) {
      if (d.indexOf("::") !== d.lastIndexOf("::"))
        return null;
      let _ = 0, g = -1, v = (d.match(c.zoneIndex) || [])[0], y, E;
      for (v && (v = v.substring(1), d = d.replace(/%.+$/, "")); (g = d.indexOf(":", g + 1)) >= 0; )
        _++;
      if (d.substr(0, 2) === "::" && _--, d.substr(-2, 2) === "::" && _--, _ > h)
        return null;
      for (E = h - _, y = ":"; E--; )
        y += "0:";
      return d = d.replace("::", y), d[0] === ":" && (d = d.slice(1)), d[d.length - 1] === ":" && (d = d.slice(0, -1)), h = function() {
        const R = d.split(":"), w = [];
        for (let C = 0; C < R.length; C++)
          w.push(parseInt(R[C], 16));
        return w;
      }(), {
        parts: h,
        zoneId: v
      };
    }
    function l(d, h, _, g) {
      if (d.length !== h.length)
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      let v = 0, y;
      for (; g > 0; ) {
        if (y = _ - g, y < 0 && (y = 0), d[v] >> y !== h[v] >> y)
          return !1;
        g -= _, v += 1;
      }
      return !0;
    }
    function f(d) {
      if (s.test(d))
        return parseInt(d, 16);
      if (d[0] === "0" && !isNaN(parseInt(d[1], 10))) {
        if (i.test(d))
          return parseInt(d, 8);
        throw new Error(`ipaddr: cannot parse ${d} as octal`);
      }
      return parseInt(d, 10);
    }
    function m(d, h) {
      for (; d.length < h; )
        d = `0${d}`;
      return d;
    }
    const p = {};
    p.IPv4 = function() {
      function d(h) {
        if (h.length !== 4)
          throw new Error("ipaddr: ipv4 octet count should be 4");
        let _, g;
        for (_ = 0; _ < h.length; _++)
          if (g = h[_], !(0 <= g && g <= 255))
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        this.octets = h;
      }
      return d.prototype.SpecialRanges = {
        unspecified: [[new d([0, 0, 0, 0]), 8]],
        broadcast: [[new d([255, 255, 255, 255]), 32]],
        // RFC3171
        multicast: [[new d([224, 0, 0, 0]), 4]],
        // RFC3927
        linkLocal: [[new d([169, 254, 0, 0]), 16]],
        // RFC5735
        loopback: [[new d([127, 0, 0, 0]), 8]],
        // RFC6598
        carrierGradeNat: [[new d([100, 64, 0, 0]), 10]],
        // RFC1918
        private: [
          [new d([10, 0, 0, 0]), 8],
          [new d([172, 16, 0, 0]), 12],
          [new d([192, 168, 0, 0]), 16]
        ],
        // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
        reserved: [
          [new d([192, 0, 0, 0]), 24],
          [new d([192, 0, 2, 0]), 24],
          [new d([192, 88, 99, 0]), 24],
          [new d([198, 18, 0, 0]), 15],
          [new d([198, 51, 100, 0]), 24],
          [new d([203, 0, 113, 0]), 24],
          [new d([240, 0, 0, 0]), 4]
        ],
        // RFC7534, RFC7535
        as112: [
          [new d([192, 175, 48, 0]), 24],
          [new d([192, 31, 196, 0]), 24]
        ],
        // RFC7450
        amt: [
          [new d([192, 52, 193, 0]), 24]
        ]
      }, d.prototype.kind = function() {
        return "ipv4";
      }, d.prototype.match = function(h, _) {
        let g;
        if (_ === void 0 && (g = h, h = g[0], _ = g[1]), h.kind() !== "ipv4")
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        return l(this.octets, h.octets, 8, _);
      }, d.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, _ = !1;
        const g = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let v, y, E;
        for (v = 3; v >= 0; v -= 1)
          if (y = this.octets[v], y in g) {
            if (E = g[y], _ && E !== 0)
              return null;
            E !== 8 && (_ = !0), h += E;
          } else
            return null;
        return 32 - h;
      }, d.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, d.prototype.toByteArray = function() {
        return this.octets.slice(0);
      }, d.prototype.toIPv4MappedAddress = function() {
        return p.IPv6.parse(`::ffff:${this.toString()}`);
      }, d.prototype.toNormalizedString = function() {
        return this.toString();
      }, d.prototype.toString = function() {
        return this.octets.join(".");
      }, d;
    }(), p.IPv4.broadcastAddressFromCIDR = function(d) {
      try {
        const h = this.parseCIDR(d), _ = h[0].toByteArray(), g = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 4; )
          v.push(parseInt(_[y], 10) | parseInt(g[y], 10) ^ 255), y++;
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, p.IPv4.isIPv4 = function(d) {
      return this.parser(d) !== null;
    }, p.IPv4.isValid = function(d) {
      try {
        return new this(this.parser(d)), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidCIDR = function(d) {
      try {
        return this.parseCIDR(d), !0;
      } catch {
        return !1;
      }
    }, p.IPv4.isValidFourPartDecimal = function(d) {
      return !!(p.IPv4.isValid(d) && d.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
    }, p.IPv4.networkAddressFromCIDR = function(d) {
      let h, _, g, v, y;
      try {
        for (h = this.parseCIDR(d), g = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], _ = 0; _ < 4; )
          v.push(parseInt(g[_], 10) & parseInt(y[_], 10)), _++;
        return new this(v);
      } catch {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    }, p.IPv4.parse = function(d) {
      const h = this.parser(d);
      if (h === null)
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      return new this(h);
    }, p.IPv4.parseCIDR = function(d) {
      let h;
      if (h = d.match(/^(.+)\/(\d+)$/)) {
        const _ = parseInt(h[2]);
        if (_ >= 0 && _ <= 32) {
          const g = [this.parse(h[1]), _];
          return Object.defineProperty(g, "toString", {
            value: function() {
              return this.join("/");
            }
          }), g;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    }, p.IPv4.parser = function(d) {
      let h, _, g;
      if (h = d.match(n.fourOctet))
        return function() {
          const v = h.slice(1, 6), y = [];
          for (let E = 0; E < v.length; E++)
            _ = v[E], y.push(f(_));
          return y;
        }();
      if (h = d.match(n.longValue)) {
        if (g = f(h[1]), g > 4294967295 || g < 0)
          throw new Error("ipaddr: address outside defined range");
        return function() {
          const v = [];
          let y;
          for (y = 0; y <= 24; y += 8)
            v.push(g >> y & 255);
          return v;
        }().reverse();
      } else return (h = d.match(n.twoOctet)) ? function() {
        const v = h.slice(1, 4), y = [];
        if (g = f(v[1]), g > 16777215 || g < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(f(v[0])), y.push(g >> 16 & 255), y.push(g >> 8 & 255), y.push(g & 255), y;
      }() : (h = d.match(n.threeOctet)) ? function() {
        const v = h.slice(1, 5), y = [];
        if (g = f(v[2]), g > 65535 || g < 0)
          throw new Error("ipaddr: address outside defined range");
        return y.push(f(v[0])), y.push(f(v[1])), y.push(g >> 8 & 255), y.push(g & 255), y;
      }() : null;
    }, p.IPv4.subnetMaskFromPrefixLength = function(d) {
      if (d = parseInt(d), d < 0 || d > 32)
        throw new Error("ipaddr: invalid IPv4 prefix length");
      const h = [0, 0, 0, 0];
      let _ = 0;
      const g = Math.floor(d / 8);
      for (; _ < g; )
        h[_] = 255, _++;
      return g < 4 && (h[g] = Math.pow(2, d % 8) - 1 << 8 - d % 8), new this(h);
    }, p.IPv6 = function() {
      function d(h, _) {
        let g, v;
        if (h.length === 16)
          for (this.parts = [], g = 0; g <= 14; g += 2)
            this.parts.push(h[g] << 8 | h[g + 1]);
        else if (h.length === 8)
          this.parts = h;
        else
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        for (g = 0; g < this.parts.length; g++)
          if (v = this.parts[g], !(0 <= v && v <= 65535))
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        _ && (this.zoneId = _);
      }
      return d.prototype.SpecialRanges = {
        // RFC4291, here and after
        unspecified: [new d([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new d([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new d([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new d([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new d([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new d([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        // RFC6666
        discard: [new d([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        // RFC6145
        rfc6145: [new d([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        // RFC6052
        rfc6052: [new d([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        // RFC3056
        "6to4": [new d([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        // RFC6052, RFC6146
        teredo: [new d([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        // RFC5180
        benchmarking: [new d([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        // RFC7450
        amt: [new d([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new d([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new d([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new d([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new d([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new d([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          // RFC3849
          [new d([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          // RFC2928
          [new d([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      }, d.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      }, d.prototype.kind = function() {
        return "ipv6";
      }, d.prototype.match = function(h, _) {
        let g;
        if (_ === void 0 && (g = h, h = g[0], _ = g[1]), h.kind() !== "ipv6")
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        return l(this.parts, h.parts, 16, _);
      }, d.prototype.prefixLengthFromSubnetMask = function() {
        let h = 0, _ = !1;
        const g = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let v, y;
        for (let E = 7; E >= 0; E -= 1)
          if (v = this.parts[E], v in g) {
            if (y = g[v], _ && y !== 0)
              return null;
            y !== 16 && (_ = !0), h += y;
          } else
            return null;
        return 128 - h;
      }, d.prototype.range = function() {
        return p.subnetMatch(this, this.SpecialRanges);
      }, d.prototype.toByteArray = function() {
        let h;
        const _ = [], g = this.parts;
        for (let v = 0; v < g.length; v++)
          h = g[v], _.push(h >> 8), _.push(h & 255);
        return _;
      }, d.prototype.toFixedLengthString = function() {
        const h = (function() {
          const g = [];
          for (let v = 0; v < this.parts.length; v++)
            g.push(m(this.parts[v].toString(16), 4));
          return g;
        }).call(this).join(":");
        let _ = "";
        return this.zoneId && (_ = `%${this.zoneId}`), h + _;
      }, d.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress())
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        const h = this.parts.slice(-2), _ = h[0], g = h[1];
        return new p.IPv4([_ >> 8, _ & 255, g >> 8, g & 255]);
      }, d.prototype.toNormalizedString = function() {
        const h = (function() {
          const g = [];
          for (let v = 0; v < this.parts.length; v++)
            g.push(this.parts[v].toString(16));
          return g;
        }).call(this).join(":");
        let _ = "";
        return this.zoneId && (_ = `%${this.zoneId}`), h + _;
      }, d.prototype.toRFC5952String = function() {
        const h = /((^|:)(0(:|$)){2,})/g, _ = this.toNormalizedString();
        let g = 0, v = -1, y;
        for (; y = h.exec(_); )
          y[0].length > v && (g = y.index, v = y[0].length);
        return v < 0 ? _ : `${_.substring(0, g)}::${_.substring(g + v)}`;
      }, d.prototype.toString = function() {
        return this.toRFC5952String();
      }, d;
    }(), p.IPv6.broadcastAddressFromCIDR = function(d) {
      try {
        const h = this.parseCIDR(d), _ = h[0].toByteArray(), g = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [];
        let y = 0;
        for (; y < 16; )
          v.push(parseInt(_[y], 10) | parseInt(g[y], 10) ^ 255), y++;
        return new this(v);
      } catch (h) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${h})`);
      }
    }, p.IPv6.isIPv6 = function(d) {
      return this.parser(d) !== null;
    }, p.IPv6.isValid = function(d) {
      if (typeof d == "string" && d.indexOf(":") === -1)
        return !1;
      try {
        const h = this.parser(d);
        return new this(h.parts, h.zoneId), !0;
      } catch {
        return !1;
      }
    }, p.IPv6.isValidCIDR = function(d) {
      if (typeof d == "string" && d.indexOf(":") === -1)
        return !1;
      try {
        return this.parseCIDR(d), !0;
      } catch {
        return !1;
      }
    }, p.IPv6.networkAddressFromCIDR = function(d) {
      let h, _, g, v, y;
      try {
        for (h = this.parseCIDR(d), g = h[0].toByteArray(), y = this.subnetMaskFromPrefixLength(h[1]).toByteArray(), v = [], _ = 0; _ < 16; )
          v.push(parseInt(g[_], 10) & parseInt(y[_], 10)), _++;
        return new this(v);
      } catch (E) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${E})`);
      }
    }, p.IPv6.parse = function(d) {
      const h = this.parser(d);
      if (h.parts === null)
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      return new this(h.parts, h.zoneId);
    }, p.IPv6.parseCIDR = function(d) {
      let h, _, g;
      if ((_ = d.match(/^(.+)\/(\d+)$/)) && (h = parseInt(_[2]), h >= 0 && h <= 128))
        return g = [this.parse(_[1]), h], Object.defineProperty(g, "toString", {
          value: function() {
            return this.join("/");
          }
        }), g;
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    }, p.IPv6.parser = function(d) {
      let h, _, g, v, y, E;
      if (g = d.match(c.deprecatedTransitional))
        return this.parser(`::ffff:${g[1]}`);
      if (c.native.test(d))
        return u(d, 8);
      if ((g = d.match(c.transitional)) && (E = g[6] || "", h = g[1], g[1].endsWith("::") || (h = h.slice(0, -1)), h = u(h + E, 6), h.parts)) {
        for (y = [
          parseInt(g[2]),
          parseInt(g[3]),
          parseInt(g[4]),
          parseInt(g[5])
        ], _ = 0; _ < y.length; _++)
          if (v = y[_], !(0 <= v && v <= 255))
            return null;
        return h.parts.push(y[0] << 8 | y[1]), h.parts.push(y[2] << 8 | y[3]), {
          parts: h.parts,
          zoneId: h.zoneId
        };
      }
      return null;
    }, p.IPv6.subnetMaskFromPrefixLength = function(d) {
      if (d = parseInt(d), d < 0 || d > 128)
        throw new Error("ipaddr: invalid IPv6 prefix length");
      const h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let _ = 0;
      const g = Math.floor(d / 8);
      for (; _ < g; )
        h[_] = 255, _++;
      return g < 16 && (h[g] = Math.pow(2, d % 8) - 1 << 8 - d % 8), new this(h);
    }, p.fromByteArray = function(d) {
      const h = d.length;
      if (h === 4)
        return new p.IPv4(d);
      if (h === 16)
        return new p.IPv6(d);
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }, p.isValid = function(d) {
      return p.IPv6.isValid(d) || p.IPv4.isValid(d);
    }, p.isValidCIDR = function(d) {
      return p.IPv6.isValidCIDR(d) || p.IPv4.isValidCIDR(d);
    }, p.parse = function(d) {
      if (p.IPv6.isValid(d))
        return p.IPv6.parse(d);
      if (p.IPv4.isValid(d))
        return p.IPv4.parse(d);
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }, p.parseCIDR = function(d) {
      try {
        return p.IPv6.parseCIDR(d);
      } catch {
        try {
          return p.IPv4.parseCIDR(d);
        } catch {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    }, p.process = function(d) {
      const h = this.parse(d);
      return h.kind() === "ipv6" && h.isIPv4MappedAddress() ? h.toIPv4Address() : h;
    }, p.subnetMatch = function(d, h, _) {
      let g, v, y, E;
      _ == null && (_ = "unicast");
      for (v in h)
        if (Object.prototype.hasOwnProperty.call(h, v)) {
          for (y = h[v], y[0] && !(y[0] instanceof Array) && (y = [y]), g = 0; g < y.length; g++)
            if (E = y[g], d.kind() === E[0].kind() && d.match.apply(d, E))
              return v;
        }
      return _;
    }, e.exports ? e.exports = p : t.ipaddr = p;
  })(me);
})(Nx);
var rk = Nx.exports;
/*!
 * proxy-addr
 * Copyright(c) 2021 Fastify collaborators
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
Qs.exports = Om;
Qs.exports.default = Om;
Qs.exports.proxyaddr = Om;
Qs.exports.all = Dx;
Qs.exports.compile = Lx;
const nk = tk, kx = rk, ik = /^\d+$/u, jl = kx.isValid, Nu = kx.parse, b0 = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function Dx(e, t) {
  const r = nk(e);
  if (!t)
    return r;
  typeof t != "function" && (t = Lx(t));
  for (var n = 0; n < r.length - 1; n++)
    t(r[n], n) || (r.length = n + 1);
  return r;
}
function Lx(e) {
  if (!e)
    throw new TypeError("argument is required");
  let t;
  if (typeof e == "string")
    t = [e];
  else if (Array.isArray(e))
    t = e.slice();
  else
    throw new TypeError("unsupported trust argument");
  for (var r = 0; r < t.length; r++)
    e = t[r], Object.prototype.hasOwnProperty.call(b0, e) && (e = b0[e], t.splice.apply(t, [r, 1].concat(e)), r += e.length - 1);
  return ok(sk(t));
}
function sk(e) {
  const t = new Array(e.length);
  for (var r = 0; r < e.length; r++)
    t[r] = ak(e[r]);
  return t;
}
function ok(e) {
  const t = e.length;
  return t === 0 ? lk : t === 1 ? fk(e[0]) : uk(e);
}
function ak(e) {
  const t = e.lastIndexOf("/"), r = t !== -1 ? e.substring(0, t) : e;
  if (!jl(r))
    throw new TypeError("invalid IP address: " + r);
  let n = Nu(r);
  t === -1 && n.kind() === "ipv6" && n.isIPv4MappedAddress() && (n = n.toIPv4Address());
  const i = n.kind() === "ipv6" ? 128 : 32;
  let s = t !== -1 ? e.substring(t + 1, e.length) : null;
  if (s === null ? s = i : ik.test(s) ? s = parseInt(s, 10) : n.kind() === "ipv4" && jl(s) ? s = ck(s) : s = null, s <= 0 || s > i)
    throw new TypeError("invalid range on address: " + e);
  return [n, s];
}
function ck(e) {
  const t = Nu(e);
  return t.kind() === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
}
function Om(e, t) {
  if (!e)
    throw new TypeError("req argument is required");
  if (!t)
    throw new TypeError("trust argument is required");
  const r = Dx(e, t);
  return r[r.length - 1];
}
function lk() {
  return !1;
}
function uk(e) {
  return function(r) {
    if (!jl(r)) return !1;
    const n = Nu(r);
    let i;
    const s = n.kind();
    for (var o = 0; o < e.length; o++) {
      const a = e[o], c = a[0], u = c.kind(), l = a[1];
      let f = n;
      if (s !== u) {
        if (u === "ipv4" && !n.isIPv4MappedAddress())
          continue;
        i || (i = u === "ipv4" ? n.toIPv4Address() : n.toIPv4MappedAddress()), f = i;
      }
      if (f.match(c, l))
        return !0;
    }
    return !1;
  };
}
function fk(e) {
  const t = e[0], r = t.kind(), n = r === "ipv4", i = e[1];
  return function(o) {
    if (!jl(o)) return !1;
    let a = Nu(o);
    if (a.kind() !== r) {
      if (n && !a.isIPv4MappedAddress())
        return !1;
      a = n ? a.toIPv4Address() : a.toIPv4MappedAddress();
    }
    return a.match(t, i);
  };
}
var dk = Qs.exports;
const Ul = dk, {
  kHasBeenDecorated: pk,
  kSchemaBody: hk,
  kSchemaHeaders: mk,
  kSchemaParams: gk,
  kSchemaQuerystring: E0,
  kSchemaController: Od,
  kOptions: yk,
  kRequestCacheValidateFns: In,
  kRouteContext: Vt,
  kRequestOriginalUrl: Pd
} = Ft, { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: vk } = Kt, w0 = {
  body: hk,
  headers: mk,
  params: gk,
  querystring: E0,
  query: E0
};
function Pm(e, t, r, n, i, s) {
  this.id = e, this[Vt] = s, this.params = t, this.raw = r, this.query = n, this.log = i, this.body = void 0;
}
Pm.props = [];
function _k(e) {
  if (typeof e == "function")
    return e;
  if (e === !0)
    return null;
  if (typeof e == "number")
    return function(t, r) {
      return r < e;
    };
  if (typeof e == "string") {
    const t = e.split(",").map((r) => r.trim());
    return Ul.compile(t);
  }
  return Ul.compile(e);
}
function bk(e, t) {
  return t ? Ek(e, t) : Fx(e);
}
function Fx(e) {
  const t = e.props.slice();
  function r(n, i, s, o, a, c) {
    this.id = n, this[Vt] = c, this.params = i, this.raw = s, this.query = o, this.log = a, this.body = void 0;
    let u;
    for (let l = 0; l < t.length; l++)
      u = t[l], this[u.key] = u.value;
  }
  return Object.setPrototypeOf(r.prototype, e.prototype), Object.setPrototypeOf(r, e), r.props = t, r.parent = e, r;
}
function S0(e) {
  const t = e.lastIndexOf(",");
  return t === -1 ? e.trim() : e.slice(t + 1).trim();
}
function Ek(e, t) {
  const r = Fx(e), n = _k(t);
  return r[pk] = !0, Object.defineProperties(r.prototype, {
    ip: {
      get() {
        const i = Ul.all(this.raw, n);
        return i[i.length - 1];
      }
    },
    ips: {
      get() {
        return Ul.all(this.raw, n);
      }
    },
    host: {
      get() {
        return this.ip !== void 0 && this.headers["x-forwarded-host"] ? S0(this.headers["x-forwarded-host"]) : this.headers.host ?? this.headers[":authority"] ?? "";
      }
    },
    protocol: {
      get() {
        if (this.headers["x-forwarded-proto"])
          return S0(this.headers["x-forwarded-proto"]);
        if (this.socket)
          return this.socket.encrypted ? "https" : "http";
      }
    }
  }), r;
}
Object.defineProperties(Pm.prototype, {
  server: {
    get() {
      return this[Vt].server;
    }
  },
  url: {
    get() {
      return this.raw.url;
    }
  },
  originalUrl: {
    get() {
      return this[Pd] || (this[Pd] = this.raw.originalUrl || this.raw.url), this[Pd];
    }
  },
  method: {
    get() {
      return this.raw.method;
    }
  },
  routeOptions: {
    get() {
      var s, o;
      const e = this[Vt], t = e._parserOptions.limit, r = e.server.initialConfig.bodyLimit, n = e.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0, i = {
        method: (s = e.config) == null ? void 0 : s.method,
        url: (o = e.config) == null ? void 0 : o.url,
        bodyLimit: t || r,
        attachValidation: e.attachValidation,
        logLevel: e.logLevel,
        exposeHeadRoute: e.exposeHeadRoute,
        prefixTrailingSlash: e.prefixTrailingSlash,
        handler: e.handler,
        version: n
      };
      return Object.defineProperties(i, {
        config: {
          get: () => e.config
        },
        schema: {
          get: () => e.schema
        }
      }), Object.freeze(i);
    }
  },
  is404: {
    get() {
      var e;
      return ((e = this[Vt].config) == null ? void 0 : e.url) === void 0;
    }
  },
  socket: {
    get() {
      return this.raw.socket;
    }
  },
  ip: {
    get() {
      if (this.socket)
        return this.socket.remoteAddress;
    }
  },
  host: {
    get() {
      return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
    }
  },
  hostname: {
    get() {
      return this.host.split(":", 1)[0];
    }
  },
  port: {
    get() {
      const e = parseInt(this.host.split(":").slice(-1)[0]);
      if (!isNaN(e))
        return e;
      const t = this.headers.host ?? this.headers[":authority"] ?? "", r = parseInt(t.split(":").slice(-1)[0]);
      return isNaN(r) ? null : r;
    }
  },
  protocol: {
    get() {
      if (this.socket)
        return this.socket.encrypted ? "https" : "http";
    }
  },
  headers: {
    get() {
      return this.additionalHeaders ? Object.assign({}, this.raw.headers, this.additionalHeaders) : this.raw.headers;
    },
    set(e) {
      this.additionalHeaders = e;
    }
  },
  getValidationFunction: {
    value: function(e) {
      var t;
      if (typeof e == "string") {
        const r = w0[e];
        return this[Vt][r];
      } else if (typeof e == "object")
        return (t = this[Vt][In]) == null ? void 0 : t.get(e);
    }
  },
  compileValidationSchema: {
    value: function(e, t = null) {
      var o;
      const { method: r, url: n } = this;
      if ((o = this[Vt][In]) != null && o.has(e))
        return this[Vt][In].get(e);
      const s = (this[Vt].validatorCompiler || this.server[Od].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
      // nor set
      this.server[Od].setupValidator(this.server[yk]) || this.server[Od].validatorCompiler)({
        schema: e,
        method: r,
        url: n,
        httpPart: t
      });
      return this[Vt][In] == null && (this[Vt][In] = /* @__PURE__ */ new WeakMap()), this[Vt][In].set(e, s), s;
    }
  },
  validateInput: {
    value: function(e, t, r) {
      var s;
      r = typeof t == "string" ? t : r;
      const n = r != null && typeof r == "string" && w0[r];
      let i;
      if (n && (i = this[Vt][n]), i == null && (t == null || typeof t != "object" || Array.isArray(t)))
        throw new vk(r);
      return i == null && ((s = this[Vt][In]) != null && s.has(t) ? i = this[Vt][In].get(t) : i = this.compileValidationSchema(t, r)), i(e);
    }
  }
});
$m.exports = Pm;
$m.exports.buildRequest = bk;
var Cm = $m.exports;
const {
  kFourOhFourContext: wk,
  kReplySerializerDefault: Sk,
  kSchemaErrorFormatter: xk,
  kErrorHandler: Rk,
  kChildLoggerFactory: $k,
  kOptions: Tk,
  kReply: Ok,
  kRequest: Pk,
  kBodyLimit: Ck,
  kLogLevel: Ak,
  kContentTypeParser: Ik,
  kRouteByFastify: Nk,
  kRequestCacheValidateFns: kk,
  kReplyCacheSerializeFns: Dk
} = Ft;
function Lk({
  schema: e,
  handler: t,
  config: r,
  requestIdLogLabel: n,
  childLoggerFactory: i,
  errorHandler: s,
  bodyLimit: o,
  logLevel: a,
  logSerializers: c,
  attachValidation: u,
  validatorCompiler: l,
  serializerCompiler: f,
  replySerializer: m,
  schemaErrorFormatter: p,
  exposeHeadRoute: d,
  prefixTrailingSlash: h,
  server: _,
  isFastify: g
}) {
  this.schema = e, this.handler = t, this.Reply = _[Ok], this.Request = _[Pk], this.contentTypeParser = _[Ik], this.onRequest = null, this.onSend = null, this.onError = null, this.onTimeout = null, this.preHandler = null, this.onResponse = null, this.preSerialization = null, this.onRequestAbort = null, this.config = r, this.errorHandler = s || _[Rk], this.requestIdLogLabel = n || _[Tk].requestIdLogLabel, this.childLoggerFactory = i || _[$k], this._middie = null, this._parserOptions = {
    limit: o || _[Ck]
  }, this.exposeHeadRoute = d, this.prefixTrailingSlash = h, this.logLevel = a || _[Ak], this.logSerializers = c, this[wk] = null, this.attachValidation = u, this[Sk] = m, this.schemaErrorFormatter = p || _[xk] || Fk, this[Nk] = g, this[kk] = null, this[Dk] = null, this.validatorCompiler = l || null, this.serializerCompiler = f || null, this.server = _;
}
function Fk(e, t) {
  let r = "";
  const n = ", ";
  for (let i = 0; i !== e.length; ++i) {
    const s = e[i];
    r += t + (s.instancePath || "") + " " + s.message + n;
  }
  return new Error(r.slice(0, -n.length));
}
var Am = Lk;
const {
  kReply: dh,
  kRequest: ph,
  kState: jk,
  kHasBeenDecorated: Uk
} = Ft, {
  FST_ERR_DEC_ALREADY_PRESENT: jx,
  FST_ERR_DEC_MISSING_DEPENDENCY: Mk,
  FST_ERR_DEC_AFTER_START: Hk,
  FST_ERR_DEC_REFERENCE_TYPE: qk,
  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: Bk
} = Kt;
function zk(e, t, r, n) {
  if (Object.hasOwn(e, t))
    throw new jx(t);
  Hx(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(e, t, {
    get: r.getter,
    set: r.setter
  }) : e[t] = r;
}
function Ux(e, t, r, n) {
  const i = e.prototype;
  if (Object.hasOwn(i, t) || Du(e, t))
    throw new jx(t);
  e[Uk] = !0, Hx(e, t, n), r && (typeof r.getter == "function" || typeof r.setter == "function") ? Object.defineProperty(i, t, {
    get: r.getter,
    set: r.setter
  }) : typeof r == "function" ? i[t] = r : e.props.push({ key: t, value: r });
}
function Mx(e, t) {
  if (typeof t == "object" && t && !(typeof t.getter == "function" || typeof t.setter == "function"))
    throw new qk(e, typeof t);
}
function Vk(e, t, r) {
  return Im(this, e), zk(this, e, t, r), this;
}
function ku(e, t) {
  return t ? t in e || e.prototype && t in e.prototype || Du(e, t) : e in this;
}
function Du(e, t) {
  return e.props ? e.props.find(({ key: r }) => r === t) : !1;
}
function Gk(e) {
  return e && Du(this[ph], e) ? !0 : ku(this[ph].prototype, e);
}
function Wk(e) {
  return e && Du(this[dh], e) ? !0 : ku(this[dh].prototype, e);
}
function Hx(e, t, r) {
  if (r != null) {
    if (!Array.isArray(r))
      throw new Bk(t);
    for (let n = 0; n !== r.length; ++n)
      if (!ku(e, r[n]))
        throw new Mk(r[n]);
  }
}
function Kk(e, t, r) {
  return Im(this, e), Mx(e, t), Ux(this[dh], e, t, r), this;
}
function Yk(e, t, r) {
  return Im(this, e), Mx(e, t), Ux(this[ph], e, t, r), this;
}
function Im(e, t) {
  if (e[jk].started)
    throw new Hk(t);
}
var qx = {
  add: Vk,
  exist: ku,
  existRequest: Gk,
  existReply: Wk,
  decorateReply: Kk,
  decorateRequest: Yk
}, Bx = { exports: {} }, on = {};
/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */
class Jk {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ new Map(), this.last = null, this.max = t, this.ttl = r;
  }
  get size() {
    return this.items.size;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map(), this.first = null, this.last = null;
  }
  delete(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      this.items.delete(t), r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      this.items.delete(t.key), this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (this.items.has(t))
      return this.items.get(t).expiry;
  }
  get(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return this.items.keys();
  }
  set(t, r) {
    if (this.items.has(t)) {
      const i = this.items.get(t);
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items.set(t, n), this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
class Xk {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ new Map(), this.last = null, this.max = t, this.ttl = r;
  }
  get size() {
    return this.items.size;
  }
  bumpLru(t) {
    if (this.last === t)
      return;
    const r = this.last, n = t.next, i = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, i !== null && (i.next = n), n !== null && (n.prev = i), this.last = t;
  }
  clear() {
    this.items = /* @__PURE__ */ new Map(), this.first = null, this.last = null;
  }
  delete(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      this.items.delete(t), r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      this.items.delete(t.key), this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (this.items.has(t))
      return this.items.get(t).expiry;
  }
  get(t) {
    if (this.items.has(t)) {
      const r = this.items.get(t);
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.bumpLru(r), r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return this.items.keys();
  }
  set(t, r) {
    if (this.items.has(t)) {
      const i = this.items.get(t);
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== i && this.bumpLru(i);
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items.set(t, n), this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
class Nm {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this.max = t, this.ttl = r;
  }
  bumpLru(t) {
    if (this.last === t)
      return;
    const r = this.last, n = t.next, i = t.prev;
    this.first === t && (this.first = n), t.next = null, t.prev = r, r.next = t, i !== null && (i.next = n), n !== null && (n.prev = i), this.last = t;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null), this.first = null, this.last = null, this.size = 0;
  }
  delete(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      delete this.items[t], this.size--, r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t))
      return this.items[t].expiry;
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return this.bumpLru(r), r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(t, r) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const i = this.items[t];
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl, this.last !== i && this.bumpLru(i);
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items[t] = n, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
class zx {
  constructor() {
    this.records = {};
  }
  initForCache(t, r) {
    this.records[t] = {
      [r]: {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      }
    };
  }
  resetForCache(t) {
    for (let r of Object.keys(this.records[t]))
      this.records[t][r] = {
        cacheSize: 0,
        hits: 0,
        falsyHits: 0,
        emptyHits: 0,
        misses: 0,
        expirations: 0,
        evictions: 0,
        invalidateOne: 0,
        invalidateAll: 0,
        sets: 0
      };
  }
  getStatistics() {
    return this.records;
  }
}
function x0(e) {
  return `${e.getFullYear()}-${(e.getMonth() + 1).toString().padStart(2, "0")}-${e.getDate().toString().padStart(2, "0")}`;
}
class Zk {
  constructor(t, r, n) {
    this.cacheId = t, this.statisticTtlInHours = r, this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = x0(this.collectionStart), this.records = n || new zx(), this.records.initForCache(this.cacheId, this.currentTimeStamp);
  }
  get currentRecord() {
    return this.records.records[this.cacheId][this.currentTimeStamp] || (this.records.records[this.cacheId][this.currentTimeStamp] = {
      cacheSize: 0,
      hits: 0,
      falsyHits: 0,
      emptyHits: 0,
      misses: 0,
      expirations: 0,
      evictions: 0,
      sets: 0,
      invalidateOne: 0,
      invalidateAll: 0
    }), this.records.records[this.cacheId][this.currentTimeStamp];
  }
  hoursPassed() {
    return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
  }
  addHit() {
    this.archiveIfNeeded(), this.currentRecord.hits++;
  }
  addFalsyHit() {
    this.archiveIfNeeded(), this.currentRecord.falsyHits++;
  }
  addEmptyHit() {
    this.archiveIfNeeded(), this.currentRecord.emptyHits++;
  }
  addMiss() {
    this.archiveIfNeeded(), this.currentRecord.misses++;
  }
  addEviction() {
    this.archiveIfNeeded(), this.currentRecord.evictions++;
  }
  setCacheSize(t) {
    this.archiveIfNeeded(), this.currentRecord.cacheSize = t;
  }
  addExpiration() {
    this.archiveIfNeeded(), this.currentRecord.expirations++;
  }
  addSet() {
    this.archiveIfNeeded(), this.currentRecord.sets++;
  }
  addInvalidateOne() {
    this.archiveIfNeeded(), this.currentRecord.invalidateOne++;
  }
  addInvalidateAll() {
    this.archiveIfNeeded(), this.currentRecord.invalidateAll++;
  }
  getStatistics() {
    return this.records.getStatistics();
  }
  archiveIfNeeded() {
    this.hoursPassed() >= this.statisticTtlInHours && (this.collectionStart = /* @__PURE__ */ new Date(), this.currentTimeStamp = x0(this.collectionStart), this.records.initForCache(this.cacheId, this.currentTimeStamp));
  }
}
class Vx extends Nm {
  constructor(t, r, n, i, s) {
    if (super(t || 1e3, r || 0), !n)
      throw new Error("Cache id is mandatory");
    this.hitStatistics = new Zk(
      n,
      s !== void 0 ? s : 24,
      i
    );
  }
  getStatistics() {
    return this.hitStatistics.getStatistics();
  }
  set(t, r) {
    super.set(t, r), this.hitStatistics.addSet(), this.hitStatistics.setCacheSize(this.size);
  }
  evict() {
    super.evict(), this.hitStatistics.addEviction(), this.hitStatistics.setCacheSize(this.size);
  }
  delete(t, r = !1) {
    super.delete(t), r || this.hitStatistics.addInvalidateOne(), this.hitStatistics.setCacheSize(this.size);
  }
  clear() {
    super.clear(), this.hitStatistics.addInvalidateAll(), this.hitStatistics.setCacheSize(this.size);
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t, !0), this.hitStatistics.addExpiration();
        return;
      }
      return this.bumpLru(r), r.value || this.hitStatistics.addFalsyHit(), (r.value === void 0 || r.value === null || r.value === "") && this.hitStatistics.addEmptyHit(), this.hitStatistics.addHit(), r.value;
    }
    this.hitStatistics.addMiss();
  }
}
class Gx {
  constructor(t = 1e3, r = 0) {
    if (isNaN(t) || t < 0)
      throw new Error("Invalid max value");
    if (isNaN(r) || r < 0)
      throw new Error("Invalid ttl value");
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this.max = t, this.ttl = r;
  }
  clear() {
    this.items = /* @__PURE__ */ Object.create(null), this.first = null, this.last = null, this.size = 0;
  }
  delete(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      delete this.items[t], this.size--, r.prev !== null && (r.prev.next = r.next), r.next !== null && (r.next.prev = r.prev), this.first === r && (this.first = r.next), this.last === r && (this.last = r.prev);
    }
  }
  deleteMany(t) {
    for (var r = 0; r < t.length; r++)
      this.delete(t[r]);
  }
  evict() {
    if (this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
  }
  expiresAt(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t))
      return this.items[t].expiry;
  }
  get(t) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const r = this.items[t];
      if (this.ttl > 0 && r.expiry <= Date.now()) {
        this.delete(t);
        return;
      }
      return r.value;
    }
  }
  getMany(t) {
    const r = [];
    for (var n = 0; n < t.length; n++)
      r.push(this.get(t[n]));
    return r;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(t, r) {
    if (Object.prototype.hasOwnProperty.call(this.items, t)) {
      const i = this.items[t];
      i.value = r, i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      return;
    }
    this.max > 0 && this.size === this.max && this.evict();
    const n = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: t,
      prev: this.last,
      next: null,
      value: r
    };
    this.items[t] = n, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
  }
}
on.Fifo = Gx;
on.FifoMap = Jk;
on.FifoObject = Gx;
on.HitStatisticsRecord = zx;
on.Lru = Nm;
on.LruHitStatistics = Vx;
on.LruMap = Xk;
on.LruObject = Nm;
on.LruObjectHitStatistics = Vx;
var eo = { exports: {} };
const Qk = typeof Buffer < "u", R0 = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, $0 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function Wx(e, t, r) {
  r == null && t !== null && typeof t == "object" && (r = t, t = void 0), Qk && Buffer.isBuffer(e) && (e = e.toString()), e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
  const n = JSON.parse(e, t);
  if (n === null || typeof n != "object")
    return n;
  const i = r && r.protoAction || "error", s = r && r.constructorAction || "error";
  if (i === "ignore" && s === "ignore")
    return n;
  if (i !== "ignore" && s !== "ignore") {
    if (R0.test(e) === !1 && $0.test(e) === !1)
      return n;
  } else if (i !== "ignore" && s === "ignore") {
    if (R0.test(e) === !1)
      return n;
  } else if ($0.test(e) === !1)
    return n;
  return Kx(n, { protoAction: i, constructorAction: s, safe: r && r.safe });
}
function Kx(e, { protoAction: t = "error", constructorAction: r = "error", safe: n } = {}) {
  let i = [e];
  for (; i.length; ) {
    const s = i;
    i = [];
    for (const o of s) {
      if (t !== "ignore" && Object.prototype.hasOwnProperty.call(o, "__proto__")) {
        if (n === !0)
          return null;
        if (t === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.__proto__;
      }
      if (r !== "ignore" && Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype")) {
        if (n === !0)
          return null;
        if (r === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete o.constructor;
      }
      for (const a in o) {
        const c = o[a];
        c && typeof c == "object" && i.push(c);
      }
    }
  }
  return e;
}
function km(e, t, r) {
  const { stackTraceLimit: n } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Wx(e, t, r);
  } finally {
    Error.stackTraceLimit = n;
  }
}
function eD(e, t) {
  const { stackTraceLimit: r } = Error;
  Error.stackTraceLimit = 0;
  try {
    return Wx(e, t, { safe: !0 });
  } catch {
    return null;
  } finally {
    Error.stackTraceLimit = r;
  }
}
eo.exports = km;
eo.exports.default = km;
eo.exports.parse = km;
eo.exports.safeParse = eD;
eo.exports.scan = Kx;
var tD = eo.exports;
(function(e) {
  const { AsyncResource: t } = wC, { FifoMap: r } = on, { parse: n } = tD, {
    kDefaultJsonParse: i,
    kContentTypeParser: s,
    kBodyLimit: o,
    kRequestPayloadStream: a,
    kState: c,
    kTestInternals: u,
    kReplyIsError: l,
    kRouteContext: f
  } = Ft, {
    FST_ERR_CTP_INVALID_TYPE: m,
    FST_ERR_CTP_EMPTY_TYPE: p,
    FST_ERR_CTP_ALREADY_PRESENT: d,
    FST_ERR_CTP_INVALID_HANDLER: h,
    FST_ERR_CTP_INVALID_PARSE_TYPE: _,
    FST_ERR_CTP_BODY_TOO_LARGE: g,
    FST_ERR_CTP_INVALID_MEDIA_TYPE: v,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: y,
    FST_ERR_CTP_EMPTY_JSON_BODY: E,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: R
  } = Kt, { FSTSEC001: w } = mm;
  function C(I, L, j) {
    this[i] = b(L, j), this.customParsers = /* @__PURE__ */ new Map(), this.customParsers.set("application/json", new H(!0, !1, I, this[i])), this.customParsers.set("text/plain", new H(!0, !1, I, F)), this.parserList = ["application/json", "text/plain"], this.parserRegExpList = [], this.cache = new r(100);
  }
  C.prototype.add = function(I, L, j) {
    const k = typeof I == "string";
    if (k) {
      if (I = I.trim().toLowerCase(), I.length === 0) throw new p();
    } else if (!(I instanceof RegExp))
      throw new m();
    if (typeof j != "function")
      throw new h();
    if (this.existingParser(I))
      throw new d(I);
    if (L.parseAs !== void 0 && L.parseAs !== "string" && L.parseAs !== "buffer")
      throw new _(L.parseAs);
    const U = new H(
      L.parseAs === "string",
      L.parseAs === "buffer",
      L.bodyLimit,
      j
    );
    I === "*" ? this.customParsers.set("", U) : k ? (this.parserList.unshift(I), this.customParsers.set(I, U)) : (D(I), this.parserRegExpList.unshift(I), this.customParsers.set(I.toString(), U));
  }, C.prototype.hasParser = function(I) {
    if (typeof I == "string")
      I = I.trim().toLowerCase();
    else {
      if (!(I instanceof RegExp)) throw new m();
      I = I.toString();
    }
    return this.customParsers.has(I);
  }, C.prototype.existingParser = function(I) {
    return I === "application/json" && this.customParsers.has(I) ? this.customParsers.get(I).fn !== this[i] : I === "text/plain" && this.customParsers.has(I) ? this.customParsers.get(I).fn !== F : this.hasParser(I);
  }, C.prototype.getParser = function(I) {
    let L = this.customParsers.get(I);
    if (L !== void 0 || (L = this.cache.get(I), L !== void 0)) return L;
    const j = I.toLowerCase();
    for (let k = 0; k !== this.parserList.length; ++k) {
      const U = this.parserList[k];
      if (j.slice(0, U.length) === U && (j.length === U.length || j.charCodeAt(U.length) === 59 || j.charCodeAt(U.length) === 32))
        return L = this.customParsers.get(U), this.cache.set(I, L), L;
    }
    for (let k = 0; k !== this.parserRegExpList.length; ++k) {
      const U = this.parserRegExpList[k];
      if (U.test(I))
        return L = this.customParsers.get(U.toString()), this.cache.set(I, L), L;
    }
    return this.customParsers.get("");
  }, C.prototype.removeAll = function() {
    this.customParsers = /* @__PURE__ */ new Map(), this.parserRegExpList = [], this.parserList = [], this.cache = new r(100);
  }, C.prototype.remove = function(I) {
    let L;
    if (typeof I == "string")
      I = I.trim().toLowerCase(), L = this.parserList;
    else {
      if (!(I instanceof RegExp)) throw new m();
      I = I.toString(), L = this.parserRegExpList;
    }
    const j = this.customParsers.delete(I), k = L.findIndex((U) => U.toString() === I);
    return k > -1 && L.splice(k, 1), j || k > -1;
  }, C.prototype.run = function(I, L, j, k) {
    const U = this.getParser(I);
    if (U === void 0) {
      j.is404 ? L(j, k) : k.send(new v(I || void 0));
      return;
    }
    const M = new t("content-type-parser:run", j);
    if (U.asString === !0 || U.asBuffer === !0)
      V(
        j,
        k,
        k[f]._parserOptions,
        U,
        T
      );
    else {
      const N = U.fn(j, j[a], T);
      N && typeof N.then == "function" && N.then((G) => T(null, G), T);
    }
    function T(N, G) {
      M.runInAsyncScope(() => {
        M.emitDestroy(), N ? (k[l] = !0, k.send(N)) : (j.body = G, L(j, k));
      });
    }
  };
  function V(I, L, j, k, U) {
    const M = k.asString, T = j.limit === null ? k.bodyLimit : j.limit, N = Number(I.headers["content-length"]);
    if (N > T) {
      L.header("connection", "close"), L.send(new g());
      return;
    }
    let G = 0, O = M === !0 ? "" : [];
    const S = I[a] || I.raw;
    M === !0 && S.setEncoding("utf8"), S.on("data", W), S.on("end", z), S.on("error", z), S.resume();
    function W(Q) {
      G += Q.length;
      const { receivedEncodedLength: K = 0 } = S;
      if (G > T || K > T) {
        S.removeListener("data", W), S.removeListener("end", z), S.removeListener("error", z), L.send(new g());
        return;
      }
      M === !0 ? O += Q : O.push(Q);
    }
    function z(Q) {
      if (S.removeListener("data", W), S.removeListener("end", z), S.removeListener("error", z), Q !== void 0) {
        typeof Q.statusCode == "number" && Q.statusCode >= 400 || (Q.statusCode = 400), L[l] = !0, L.code(Q.statusCode).send(Q);
        return;
      }
      if (M === !0 && (G = Buffer.byteLength(O)), !Number.isNaN(N) && (S.receivedEncodedLength || G) !== N) {
        L.header("connection", "close"), L.send(new y());
        return;
      }
      M === !1 && (O = Buffer.concat(O));
      const K = k.fn(I, O, U);
      K && typeof K.then == "function" && K.then((X) => U(null, X), U);
    }
  }
  function b(I, L) {
    return j;
    function j(k, U, M) {
      if (U.length === 0) {
        M(new E(), void 0);
        return;
      }
      try {
        M(null, n(U, { protoAction: I, constructorAction: L }));
      } catch (T) {
        T.statusCode = 400, M(T, void 0);
      }
    }
  }
  function F(I, L, j) {
    j(null, L);
  }
  function H(I, L, j, k) {
    this.asString = I, this.asBuffer = L, this.bodyLimit = j, this.fn = k;
  }
  function q(I) {
    const L = new C();
    return L[i] = I[i], L.customParsers = new Map(I.customParsers.entries()), L.parserList = I.parserList.slice(), L.parserRegExpList = I.parserRegExpList.slice(), L;
  }
  function $(I, L, j) {
    if (this[c].started)
      throw new R("addContentTypeParser");
    return typeof L == "function" && (j = L, L = {}), L || (L = {}), L.bodyLimit || (L.bodyLimit = this[o]), Array.isArray(I) ? I.forEach((k) => this[s].add(k, L, j)) : this[s].add(I, L, j), this;
  }
  function x(I) {
    return this[s].hasParser(I);
  }
  function A(I) {
    if (this[c].started)
      throw new R("removeContentTypeParser");
    if (Array.isArray(I))
      for (const L of I)
        this[s].remove(L);
    else
      this[s].remove(I);
  }
  function P() {
    if (this[c].started)
      throw new R("removeAllContentTypeParsers");
    this[s].removeAll();
  }
  function D(I) {
    I.source[0] !== "^" && I.source.includes(";?") === !1 && w(I.source);
  }
  e.exports = C, e.exports.helpers = {
    buildContentTypeParser: q,
    addContentTypeParser: $,
    hasContentTypeParser: x,
    removeContentTypeParser: A,
    removeAllContentTypeParsers: P
  }, e.exports.defaultParsers = {
    getDefaultJsonParser: b,
    defaultTextParser: F
  }, e.exports[u] = { rawBody: V };
})(Bx);
var Yx = Bx.exports, Ba = { exports: {} }, Lu = {}, to = { exports: {} }, Fu = {}, T0 = Object.prototype.hasOwnProperty;
function O0(e, t, r) {
  for (r of e.keys())
    if (Ko(r, t)) return r;
}
function Ko(e, t) {
  var r, n, i;
  if (e === t) return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date) return e.getTime() === t.getTime();
    if (r === RegExp) return e.toString() === t.toString();
    if (r === Array) {
      if ((n = e.length) === t.length)
        for (; n-- && Ko(e[n], t[n]); ) ;
      return n === -1;
    }
    if (r === Set) {
      if (e.size !== t.size)
        return !1;
      for (n of e)
        if (i = n, i && typeof i == "object" && (i = O0(t, i), !i) || !t.has(i)) return !1;
      return !0;
    }
    if (r === Map) {
      if (e.size !== t.size)
        return !1;
      for (n of e)
        if (i = n[0], i && typeof i == "object" && (i = O0(t, i), !i) || !Ko(n[1], t.get(i)))
          return !1;
      return !0;
    }
    if (r === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (r === DataView) {
      if ((n = e.byteLength) === t.byteLength)
        for (; n-- && e.getInt8(n) === t.getInt8(n); ) ;
      return n === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((n = e.byteLength) === t.byteLength)
        for (; n-- && e[n] === t[n]; ) ;
      return n === -1;
    }
    if (!r || typeof e == "object") {
      n = 0;
      for (r in e)
        if (T0.call(e, r) && ++n && !T0.call(t, r) || !(r in t) || !Ko(e[r], t[r])) return !1;
      return Object.keys(t).length === n;
    }
  }
  return e !== e && t !== t;
}
Fu.dequal = Ko;
const { dequal: P0 } = Fu, rD = Symbol.for("json-schema-ref");
var gr, jr, Aa, Ia, Na, ot, hh, dl, mh, gh, Jx, yh, Xx, CS;
let nD = (CS = class {
  constructor(t = {}) {
    pi(this, ot);
    pi(this, gr);
    pi(this, jr);
    pi(this, Aa);
    pi(this, Ia);
    pi(this, Na);
    ns(this, gr, {}), ns(this, jr, {}), ns(this, Aa, t.insertRefSymbol ?? !1), ns(this, Ia, t.allowEqualDuplicates ?? !0), ns(this, Na, t.cloneSchemaWithoutRefs ?? !1);
  }
  addSchema(t, r, n = !0) {
    n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : ar(this, ot, gh).call(this, t, r));
    const i = t.$id;
    i !== void 0 && typeof i == "string" && (i.charAt(0) === "#" ? ar(this, ot, Jx).call(this, t, r, i) : (ar(this, ot, gh).call(this, t, i), r = i));
    const s = t.$ref;
    if (s !== void 0 && typeof s == "string") {
      const { refSchemaId: o, refJsonPointer: a } = ar(this, ot, hh).call(this, s, r);
      pt(this, gr)[r].refs.push({
        schemaId: o,
        jsonPointer: a
      });
    }
    for (const o in t)
      typeof t[o] == "object" && t[o] !== null && this.addSchema(t[o], r, !1);
  }
  getSchema(t, r = "#") {
    const n = pt(this, gr)[t];
    if (n === void 0)
      throw new Error(
        `Cannot resolve ref "${t}${r}". Schema with id "${t}" is not found.`
      );
    return n.anchors[r] !== void 0 ? n.anchors[r] : C0(n.schema, r);
  }
  hasSchema(t) {
    return pt(this, gr)[t] !== void 0;
  }
  getSchemaRefs(t) {
    const r = pt(this, gr)[t];
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    return r.refs;
  }
  getSchemaDependencies(t, r = {}) {
    const n = pt(this, gr)[t];
    for (const i of n.refs) {
      const s = i.schemaId;
      s === t || r[s] !== void 0 || (r[s] = this.getSchema(s), this.getSchemaDependencies(s, r));
    }
    return r;
  }
  derefSchema(t) {
    if (pt(this, jr)[t] !== void 0) return;
    const r = pt(this, gr)[t];
    if (r === void 0)
      throw new Error(`Schema with id "${t}" is not found.`);
    !pt(this, Na) && r.refs.length === 0 && (pt(this, jr)[t] = {
      schema: r.schema,
      anchors: r.anchors
    });
    const n = [];
    ar(this, ot, dl).call(this, r.schema, t, !0, n);
    const i = this.getSchemaDependencies(t);
    for (const s in i) {
      const o = i[s];
      ar(this, ot, dl).call(this, o, s, !0, n);
    }
    for (const s of n) {
      const {
        refSchemaId: o,
        refJsonPointer: a
      } = ar(this, ot, hh).call(this, s.ref, s.sourceSchemaId), c = this.getDerefSchema(o, a);
      if (c === null)
        throw new Error(
          `Cannot resolve ref "${s.ref}". Ref "${a}" is not found in schema "${o}".`
        );
      s.targetSchema = c, s.targetSchemaId = o;
    }
    for (const s of n)
      ar(this, ot, mh).call(this, s, n);
  }
  getDerefSchema(t, r = "#") {
    let n = pt(this, jr)[t];
    return n === void 0 && (this.derefSchema(t), n = pt(this, jr)[t]), n.anchors[r] !== void 0 ? n.anchors[r] : C0(n.schema, r);
  }
}, gr = new WeakMap(), jr = new WeakMap(), Aa = new WeakMap(), Ia = new WeakMap(), Na = new WeakMap(), ot = new WeakSet(), hh = function(t, r) {
  const n = t.indexOf("#");
  return n === -1 ? { refSchemaId: t, refJsonPointer: "#" } : n === 0 ? { refSchemaId: r, refJsonPointer: t } : {
    refSchemaId: t.slice(0, n),
    refJsonPointer: t.slice(n)
  };
}, dl = function(t, r, n, i = []) {
  const s = Array.isArray(t) ? [...t] : { ...t };
  n && (t.$id !== void 0 && t.$id.charAt(0) !== "#" ? r = t.$id : ar(this, ot, yh).call(this, s, r));
  const o = s.$id;
  o !== void 0 && typeof o == "string" && (o.charAt(0) === "#" ? ar(this, ot, Xx).call(this, s, r, o) : (ar(this, ot, yh).call(this, s, o), r = o)), s.$ref !== void 0 && i.push({
    ref: s.$ref,
    sourceSchemaId: r,
    sourceSchema: s
  });
  for (const a in s) {
    const c = s[a];
    typeof c == "object" && c !== null && (s[a] = ar(this, ot, dl).call(this, c, r, !1, i));
  }
  return s;
}, mh = function(t, r) {
  const { sourceSchema: n, targetSchema: i } = t;
  if (n.$ref) {
    if (pt(this, Aa) && (n[rD] = n.$ref), delete n.$ref, i.$ref) {
      const s = r.find((o) => o.sourceSchema === i);
      ar(this, ot, mh).call(this, s, r);
    }
    for (const s in i)
      if (s !== "$id") {
        if (n[s] !== void 0) {
          if (P0(n[s], i[s])) continue;
          throw new Error(
            `Cannot resolve ref "${t.ref}". Property "${s}" already exists in schema "${t.sourceSchemaId}".`
          );
        }
        n[s] = i[s];
      }
    t.isResolved = !0;
  }
}, gh = function(t, r) {
  const n = pt(this, gr)[r];
  if (n !== void 0) {
    if (pt(this, Ia) && P0(t, n.schema)) return;
    throw new Error(`There is already another schema with id "${r}".`);
  }
  pt(this, gr)[r] = { schema: t, anchors: {}, refs: [] };
}, Jx = function(t, r, n) {
  const { anchors: i } = pt(this, gr)[r];
  if (i[n] !== void 0)
    throw new Error(`There is already another anchor "${n}" in schema "${r}".`);
  i[n] = t;
}, yh = function(t, r) {
  pt(this, jr)[r] === void 0 && (pt(this, jr)[r] = { schema: t, anchors: {} });
}, Xx = function(t, r, n) {
  const { anchors: i } = pt(this, jr)[r];
  i[n] = t;
}, CS);
function C0(e, t) {
  const r = t.split("/");
  let n = e;
  for (const i of r)
    if (!(i === "" || i === "#")) {
      if (typeof n != "object" || n === null)
        return null;
      n = n[i];
    }
  return n ?? null;
}
var iD = { RefResolver: nD }, vh = { exports: {} }, Dm = {}, Cr = {}, Hs = {}, za = {}, he = {}, qs = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(v) {
      if (super(), !e.IDENTIFIER.test(v))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(v) {
      super(), this._items = typeof v == "string" ? [v] : v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const v = this._items[0];
      return v === "" || v === '""';
    }
    get str() {
      var v;
      return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((y, E) => `${y}${E}`, "");
    }
    get names() {
      var v;
      return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((y, E) => (E instanceof r && (y[E.str] = (y[E.str] || 0) + 1), y), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function i(g, ...v) {
    const y = [g[0]];
    let E = 0;
    for (; E < v.length; )
      a(y, v[E]), y.push(g[++E]);
    return new n(y);
  }
  e._ = i;
  const s = new n("+");
  function o(g, ...v) {
    const y = [p(g[0])];
    let E = 0;
    for (; E < v.length; )
      y.push(s), a(y, v[E]), y.push(s, p(g[++E]));
    return c(y), new n(y);
  }
  e.str = o;
  function a(g, v) {
    v instanceof n ? g.push(...v._items) : v instanceof r ? g.push(v) : g.push(f(v));
  }
  e.addCodeArg = a;
  function c(g) {
    let v = 1;
    for (; v < g.length - 1; ) {
      if (g[v] === s) {
        const y = u(g[v - 1], g[v + 1]);
        if (y !== void 0) {
          g.splice(v - 1, 3, y);
          continue;
        }
        g[v++] = "+";
      }
      v++;
    }
  }
  function u(g, v) {
    if (v === '""')
      return g;
    if (g === '""')
      return v;
    if (typeof g == "string")
      return v instanceof r || g[g.length - 1] !== '"' ? void 0 : typeof v != "string" ? `${g.slice(0, -1)}${v}"` : v[0] === '"' ? g.slice(0, -1) + v.slice(1) : void 0;
    if (typeof v == "string" && v[0] === '"' && !(g instanceof r))
      return `"${g}${v.slice(1)}`;
  }
  function l(g, v) {
    return v.emptyStr() ? g : g.emptyStr() ? v : o`${g}${v}`;
  }
  e.strConcat = l;
  function f(g) {
    return typeof g == "number" || typeof g == "boolean" || g === null ? g : p(Array.isArray(g) ? g.join(",") : g);
  }
  function m(g) {
    return new n(p(g));
  }
  e.stringify = m;
  function p(g) {
    return JSON.stringify(g).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function d(g) {
    return typeof g == "string" && e.IDENTIFIER.test(g) ? new n(`.${g}`) : i`[${g}]`;
  }
  e.getProperty = d;
  function h(g) {
    if (typeof g == "string" && e.IDENTIFIER.test(g))
      return new n(`${g}`);
    throw new Error(`CodeGen: invalid export name: ${g}, use explicit $id name mapping`);
  }
  e.getEsmExportName = h;
  function _(g) {
    return new n(g.toString());
  }
  e.regexpCode = _;
})(qs);
var Ml = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = qs;
  class r extends Error {
    constructor(u) {
      super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
    }
  }
  var n;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(n || (e.UsedValueState = n = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class i {
    constructor({ prefixes: u, parent: l } = {}) {
      this._names = {}, this._prefixes = u, this._parent = l;
    }
    toName(u) {
      return u instanceof t.Name ? u : this.name(u);
    }
    name(u) {
      return new t.Name(this._newName(u));
    }
    _newName(u) {
      const l = this._names[u] || this._nameGroup(u);
      return `${u}${l.index++}`;
    }
    _nameGroup(u) {
      var l, f;
      if (!((f = (l = this._parent) === null || l === void 0 ? void 0 : l._prefixes) === null || f === void 0) && f.has(u) || this._prefixes && !this._prefixes.has(u))
        throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
      return this._names[u] = { prefix: u, index: 0 };
    }
  }
  e.Scope = i;
  class s extends t.Name {
    constructor(u, l) {
      super(l), this.prefix = u;
    }
    setValue(u, { property: l, itemIndex: f }) {
      this.value = u, this.scopePath = (0, t._)`.${new t.Name(l)}[${f}]`;
    }
  }
  e.ValueScopeName = s;
  const o = (0, t._)`\n`;
  class a extends i {
    constructor(u) {
      super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? o : t.nil };
    }
    get() {
      return this._scope;
    }
    name(u) {
      return new s(u, this._newName(u));
    }
    value(u, l) {
      var f;
      if (l.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const m = this.toName(u), { prefix: p } = m, d = (f = l.key) !== null && f !== void 0 ? f : l.ref;
      let h = this._values[p];
      if (h) {
        const v = h.get(d);
        if (v)
          return v;
      } else
        h = this._values[p] = /* @__PURE__ */ new Map();
      h.set(d, m);
      const _ = this._scope[p] || (this._scope[p] = []), g = _.length;
      return _[g] = l.ref, m.setValue(l, { property: p, itemIndex: g }), m;
    }
    getValue(u, l) {
      const f = this._values[u];
      if (f)
        return f.get(l);
    }
    scopeRefs(u, l = this._values) {
      return this._reduceValues(l, (f) => {
        if (f.scopePath === void 0)
          throw new Error(`CodeGen: name "${f}" has no value`);
        return (0, t._)`${u}${f.scopePath}`;
      });
    }
    scopeCode(u = this._values, l, f) {
      return this._reduceValues(u, (m) => {
        if (m.value === void 0)
          throw new Error(`CodeGen: name "${m}" has no value`);
        return m.value.code;
      }, l, f);
    }
    _reduceValues(u, l, f = {}, m) {
      let p = t.nil;
      for (const d in u) {
        const h = u[d];
        if (!h)
          continue;
        const _ = f[d] = f[d] || /* @__PURE__ */ new Map();
        h.forEach((g) => {
          if (_.has(g))
            return;
          _.set(g, n.Started);
          let v = l(g);
          if (v) {
            const y = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${y} ${g} = ${v};${this.opts._n}`;
          } else if (v = m == null ? void 0 : m(g))
            p = (0, t._)`${p}${v}${this.opts._n}`;
          else
            throw new r(g);
          _.set(g, n.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = a;
})(Ml);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = qs, r = Ml;
  var n = qs;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var i = Ml;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return i.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return i.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(T, N) {
      return this;
    }
  }
  class o extends s {
    constructor(T, N, G) {
      super(), this.varKind = T, this.name = N, this.rhs = G;
    }
    render({ es5: T, _n: N }) {
      const G = T ? r.varKinds.var : this.varKind, O = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${G} ${this.name}${O};` + N;
    }
    optimizeNames(T, N) {
      if (T[this.name.str])
        return this.rhs && (this.rhs = x(this.rhs, T, N)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class a extends s {
    constructor(T, N, G) {
      super(), this.lhs = T, this.rhs = N, this.sideEffects = G;
    }
    render({ _n: T }) {
      return `${this.lhs} = ${this.rhs};` + T;
    }
    optimizeNames(T, N) {
      if (!(this.lhs instanceof t.Name && !T[this.lhs.str] && !this.sideEffects))
        return this.rhs = x(this.rhs, T, N), this;
    }
    get names() {
      const T = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return $(T, this.rhs);
    }
  }
  class c extends a {
    constructor(T, N, G, O) {
      super(T, G, O), this.op = N;
    }
    render({ _n: T }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + T;
    }
  }
  class u extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `${this.label}:` + T;
    }
  }
  class l extends s {
    constructor(T) {
      super(), this.label = T, this.names = {};
    }
    render({ _n: T }) {
      return `break${this.label ? ` ${this.label}` : ""};` + T;
    }
  }
  class f extends s {
    constructor(T) {
      super(), this.error = T;
    }
    render({ _n: T }) {
      return `throw ${this.error};` + T;
    }
    get names() {
      return this.error.names;
    }
  }
  class m extends s {
    constructor(T) {
      super(), this.code = T;
    }
    render({ _n: T }) {
      return `${this.code};` + T;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(T, N) {
      return this.code = x(this.code, T, N), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends s {
    constructor(T = []) {
      super(), this.nodes = T;
    }
    render(T) {
      return this.nodes.reduce((N, G) => N + G.render(T), "");
    }
    optimizeNodes() {
      const { nodes: T } = this;
      let N = T.length;
      for (; N--; ) {
        const G = T[N].optimizeNodes();
        Array.isArray(G) ? T.splice(N, 1, ...G) : G ? T[N] = G : T.splice(N, 1);
      }
      return T.length > 0 ? this : void 0;
    }
    optimizeNames(T, N) {
      const { nodes: G } = this;
      let O = G.length;
      for (; O--; ) {
        const S = G[O];
        S.optimizeNames(T, N) || (A(T, S.names), G.splice(O, 1));
      }
      return G.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((T, N) => q(T, N.names), {});
    }
  }
  class d extends p {
    render(T) {
      return "{" + T._n + super.render(T) + "}" + T._n;
    }
  }
  class h extends p {
  }
  class _ extends d {
  }
  _.kind = "else";
  class g extends d {
    constructor(T, N) {
      super(N), this.condition = T;
    }
    render(T) {
      let N = `if(${this.condition})` + super.render(T);
      return this.else && (N += "else " + this.else.render(T)), N;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const T = this.condition;
      if (T === !0)
        return this.nodes;
      let N = this.else;
      if (N) {
        const G = N.optimizeNodes();
        N = this.else = Array.isArray(G) ? new _(G) : G;
      }
      if (N)
        return T === !1 ? N instanceof g ? N : N.nodes : this.nodes.length ? this : new g(P(T), N instanceof g ? [N] : N.nodes);
      if (!(T === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(T, N) {
      var G;
      if (this.else = (G = this.else) === null || G === void 0 ? void 0 : G.optimizeNames(T, N), !!(super.optimizeNames(T, N) || this.else))
        return this.condition = x(this.condition, T, N), this;
    }
    get names() {
      const T = super.names;
      return $(T, this.condition), this.else && q(T, this.else.names), T;
    }
  }
  g.kind = "if";
  class v extends d {
  }
  v.kind = "for";
  class y extends v {
    constructor(T) {
      super(), this.iteration = T;
    }
    render(T) {
      return `for(${this.iteration})` + super.render(T);
    }
    optimizeNames(T, N) {
      if (super.optimizeNames(T, N))
        return this.iteration = x(this.iteration, T, N), this;
    }
    get names() {
      return q(super.names, this.iteration.names);
    }
  }
  class E extends v {
    constructor(T, N, G, O) {
      super(), this.varKind = T, this.name = N, this.from = G, this.to = O;
    }
    render(T) {
      const N = T.es5 ? r.varKinds.var : this.varKind, { name: G, from: O, to: S } = this;
      return `for(${N} ${G}=${O}; ${G}<${S}; ${G}++)` + super.render(T);
    }
    get names() {
      const T = $(super.names, this.from);
      return $(T, this.to);
    }
  }
  class R extends v {
    constructor(T, N, G, O) {
      super(), this.loop = T, this.varKind = N, this.name = G, this.iterable = O;
    }
    render(T) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(T);
    }
    optimizeNames(T, N) {
      if (super.optimizeNames(T, N))
        return this.iterable = x(this.iterable, T, N), this;
    }
    get names() {
      return q(super.names, this.iterable.names);
    }
  }
  class w extends d {
    constructor(T, N, G) {
      super(), this.name = T, this.args = N, this.async = G;
    }
    render(T) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(T);
    }
  }
  w.kind = "func";
  class C extends p {
    render(T) {
      return "return " + super.render(T);
    }
  }
  C.kind = "return";
  class V extends d {
    render(T) {
      let N = "try" + super.render(T);
      return this.catch && (N += this.catch.render(T)), this.finally && (N += this.finally.render(T)), N;
    }
    optimizeNodes() {
      var T, N;
      return super.optimizeNodes(), (T = this.catch) === null || T === void 0 || T.optimizeNodes(), (N = this.finally) === null || N === void 0 || N.optimizeNodes(), this;
    }
    optimizeNames(T, N) {
      var G, O;
      return super.optimizeNames(T, N), (G = this.catch) === null || G === void 0 || G.optimizeNames(T, N), (O = this.finally) === null || O === void 0 || O.optimizeNames(T, N), this;
    }
    get names() {
      const T = super.names;
      return this.catch && q(T, this.catch.names), this.finally && q(T, this.finally.names), T;
    }
  }
  class b extends d {
    constructor(T) {
      super(), this.error = T;
    }
    render(T) {
      return `catch(${this.error})` + super.render(T);
    }
  }
  b.kind = "catch";
  class F extends d {
    render(T) {
      return "finally" + super.render(T);
    }
  }
  F.kind = "finally";
  class H {
    constructor(T, N = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...N, _n: N.lines ? `
` : "" }, this._extScope = T, this._scope = new r.Scope({ parent: T }), this._nodes = [new h()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(T) {
      return this._scope.name(T);
    }
    // reserves unique name in the external scope
    scopeName(T) {
      return this._extScope.name(T);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(T, N) {
      const G = this._extScope.value(T, N);
      return (this._values[G.prefix] || (this._values[G.prefix] = /* @__PURE__ */ new Set())).add(G), G;
    }
    getScopeValue(T, N) {
      return this._extScope.getValue(T, N);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(T) {
      return this._extScope.scopeRefs(T, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(T, N, G, O) {
      const S = this._scope.toName(N);
      return G !== void 0 && O && (this._constants[S.str] = G), this._leafNode(new o(T, S, G)), S;
    }
    // `const` declaration (`var` in es5 mode)
    const(T, N, G) {
      return this._def(r.varKinds.const, T, N, G);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(T, N, G) {
      return this._def(r.varKinds.let, T, N, G);
    }
    // `var` declaration with optional assignment
    var(T, N, G) {
      return this._def(r.varKinds.var, T, N, G);
    }
    // assignment code
    assign(T, N, G) {
      return this._leafNode(new a(T, N, G));
    }
    // `+=` code
    add(T, N) {
      return this._leafNode(new c(T, e.operators.ADD, N));
    }
    // appends passed SafeExpr to code or executes Block
    code(T) {
      return typeof T == "function" ? T() : T !== t.nil && this._leafNode(new m(T)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...T) {
      const N = ["{"];
      for (const [G, O] of T)
        N.length > 1 && N.push(","), N.push(G), (G !== O || this.opts.es5) && (N.push(":"), (0, t.addCodeArg)(N, O));
      return N.push("}"), new t._Code(N);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(T, N, G) {
      if (this._blockNode(new g(T)), N && G)
        this.code(N).else().code(G).endIf();
      else if (N)
        this.code(N).endIf();
      else if (G)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(T) {
      return this._elseNode(new g(T));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new _());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(g, _);
    }
    _for(T, N) {
      return this._blockNode(T), N && this.code(N).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(T, N) {
      return this._for(new y(T), N);
    }
    // `for` statement for a range of values
    forRange(T, N, G, O, S = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const W = this._scope.toName(T);
      return this._for(new E(S, W, N, G), () => O(W));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(T, N, G, O = r.varKinds.const) {
      const S = this._scope.toName(T);
      if (this.opts.es5) {
        const W = N instanceof t.Name ? N : this.var("_arr", N);
        return this.forRange("_i", 0, (0, t._)`${W}.length`, (z) => {
          this.var(S, (0, t._)`${W}[${z}]`), G(S);
        });
      }
      return this._for(new R("of", O, S, N), () => G(S));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(T, N, G, O = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(T, (0, t._)`Object.keys(${N})`, G);
      const S = this._scope.toName(T);
      return this._for(new R("in", O, S, N), () => G(S));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(v);
    }
    // `label` statement
    label(T) {
      return this._leafNode(new u(T));
    }
    // `break` statement
    break(T) {
      return this._leafNode(new l(T));
    }
    // `return` statement
    return(T) {
      const N = new C();
      if (this._blockNode(N), this.code(T), N.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(C);
    }
    // `try` statement
    try(T, N, G) {
      if (!N && !G)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const O = new V();
      if (this._blockNode(O), this.code(T), N) {
        const S = this.name("e");
        this._currNode = O.catch = new b(S), N(S);
      }
      return G && (this._currNode = O.finally = new F(), this.code(G)), this._endBlockNode(b, F);
    }
    // `throw` statement
    throw(T) {
      return this._leafNode(new f(T));
    }
    // start self-balancing block
    block(T, N) {
      return this._blockStarts.push(this._nodes.length), T && this.code(T).endBlock(N), this;
    }
    // end the current self-balancing block
    endBlock(T) {
      const N = this._blockStarts.pop();
      if (N === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const G = this._nodes.length - N;
      if (G < 0 || T !== void 0 && G !== T)
        throw new Error(`CodeGen: wrong number of nodes: ${G} vs ${T} expected`);
      return this._nodes.length = N, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(T, N = t.nil, G, O) {
      return this._blockNode(new w(T, N, G)), O && this.code(O).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(w);
    }
    optimize(T = 1) {
      for (; T-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(T) {
      return this._currNode.nodes.push(T), this;
    }
    _blockNode(T) {
      this._currNode.nodes.push(T), this._nodes.push(T);
    }
    _endBlockNode(T, N) {
      const G = this._currNode;
      if (G instanceof T || N && G instanceof N)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${N ? `${T.kind}/${N.kind}` : T.kind}"`);
    }
    _elseNode(T) {
      const N = this._currNode;
      if (!(N instanceof g))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = N.else = T, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const T = this._nodes;
      return T[T.length - 1];
    }
    set _currNode(T) {
      const N = this._nodes;
      N[N.length - 1] = T;
    }
  }
  e.CodeGen = H;
  function q(M, T) {
    for (const N in T)
      M[N] = (M[N] || 0) + (T[N] || 0);
    return M;
  }
  function $(M, T) {
    return T instanceof t._CodeOrName ? q(M, T.names) : M;
  }
  function x(M, T, N) {
    if (M instanceof t.Name)
      return G(M);
    if (!O(M))
      return M;
    return new t._Code(M._items.reduce((S, W) => (W instanceof t.Name && (W = G(W)), W instanceof t._Code ? S.push(...W._items) : S.push(W), S), []));
    function G(S) {
      const W = N[S.str];
      return W === void 0 || T[S.str] !== 1 ? S : (delete T[S.str], W);
    }
    function O(S) {
      return S instanceof t._Code && S._items.some((W) => W instanceof t.Name && T[W.str] === 1 && N[W.str] !== void 0);
    }
  }
  function A(M, T) {
    for (const N in T)
      M[N] = (M[N] || 0) - (T[N] || 0);
  }
  function P(M) {
    return typeof M == "boolean" || typeof M == "number" || M === null ? !M : (0, t._)`!${U(M)}`;
  }
  e.not = P;
  const D = k(e.operators.AND);
  function I(...M) {
    return M.reduce(D);
  }
  e.and = I;
  const L = k(e.operators.OR);
  function j(...M) {
    return M.reduce(L);
  }
  e.or = j;
  function k(M) {
    return (T, N) => T === t.nil ? N : N === t.nil ? T : (0, t._)`${U(T)} ${M} ${U(N)}`;
  }
  function U(M) {
    return M instanceof t.Name ? M : (0, t._)`(${M})`;
  }
})(he);
var se = {};
Object.defineProperty(se, "__esModule", { value: !0 });
se.checkStrictMode = se.getErrorPath = se.Type = se.useFunc = se.setEvaluated = se.evaluatedPropsToName = se.mergeEvaluated = se.eachItem = se.unescapeJsonPointer = se.escapeJsonPointer = se.escapeFragment = se.unescapeFragment = se.schemaRefOrVal = se.schemaHasRulesButRef = se.schemaHasRules = se.checkUnknownRules = se.alwaysValidSchema = se.toHash = void 0;
const He = he, sD = qs;
function oD(e) {
  const t = {};
  for (const r of e)
    t[r] = !0;
  return t;
}
se.toHash = oD;
function aD(e, t) {
  return typeof t == "boolean" ? t : Object.keys(t).length === 0 ? !0 : (Zx(e, t), !Qx(t, e.self.RULES.all));
}
se.alwaysValidSchema = aD;
function Zx(e, t = e.schema) {
  const { opts: r, self: n } = e;
  if (!r.strictSchema || typeof t == "boolean")
    return;
  const i = n.RULES.keywords;
  for (const s in t)
    i[s] || rR(e, `unknown keyword: "${s}"`);
}
se.checkUnknownRules = Zx;
function Qx(e, t) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t[r])
      return !0;
  return !1;
}
se.schemaHasRules = Qx;
function cD(e, t) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (r !== "$ref" && t.all[r])
      return !0;
  return !1;
}
se.schemaHasRulesButRef = cD;
function lD({ topSchemaRef: e, schemaPath: t }, r, n, i) {
  if (!i) {
    if (typeof r == "number" || typeof r == "boolean")
      return r;
    if (typeof r == "string")
      return (0, He._)`${r}`;
  }
  return (0, He._)`${e}${t}${(0, He.getProperty)(n)}`;
}
se.schemaRefOrVal = lD;
function uD(e) {
  return eR(decodeURIComponent(e));
}
se.unescapeFragment = uD;
function fD(e) {
  return encodeURIComponent(Lm(e));
}
se.escapeFragment = fD;
function Lm(e) {
  return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
se.escapeJsonPointer = Lm;
function eR(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
se.unescapeJsonPointer = eR;
function dD(e, t) {
  if (Array.isArray(e))
    for (const r of e)
      t(r);
  else
    t(e);
}
se.eachItem = dD;
function A0({ mergeNames: e, mergeToName: t, mergeValues: r, resultToName: n }) {
  return (i, s, o, a) => {
    const c = o === void 0 ? s : o instanceof He.Name ? (s instanceof He.Name ? e(i, s, o) : t(i, s, o), o) : s instanceof He.Name ? (t(i, o, s), s) : r(s, o);
    return a === He.Name && !(c instanceof He.Name) ? n(i, c) : c;
  };
}
se.mergeEvaluated = {
  props: A0({
    mergeNames: (e, t, r) => e.if((0, He._)`${r} !== true && ${t} !== undefined`, () => {
      e.if((0, He._)`${t} === true`, () => e.assign(r, !0), () => e.assign(r, (0, He._)`${r} || {}`).code((0, He._)`Object.assign(${r}, ${t})`));
    }),
    mergeToName: (e, t, r) => e.if((0, He._)`${r} !== true`, () => {
      t === !0 ? e.assign(r, !0) : (e.assign(r, (0, He._)`${r} || {}`), Fm(e, r, t));
    }),
    mergeValues: (e, t) => e === !0 ? !0 : { ...e, ...t },
    resultToName: tR
  }),
  items: A0({
    mergeNames: (e, t, r) => e.if((0, He._)`${r} !== true && ${t} !== undefined`, () => e.assign(r, (0, He._)`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)),
    mergeToName: (e, t, r) => e.if((0, He._)`${r} !== true`, () => e.assign(r, t === !0 ? !0 : (0, He._)`${r} > ${t} ? ${r} : ${t}`)),
    mergeValues: (e, t) => e === !0 ? !0 : Math.max(e, t),
    resultToName: (e, t) => e.var("items", t)
  })
};
function tR(e, t) {
  if (t === !0)
    return e.var("props", !0);
  const r = e.var("props", (0, He._)`{}`);
  return t !== void 0 && Fm(e, r, t), r;
}
se.evaluatedPropsToName = tR;
function Fm(e, t, r) {
  Object.keys(r).forEach((n) => e.assign((0, He._)`${t}${(0, He.getProperty)(n)}`, !0));
}
se.setEvaluated = Fm;
const I0 = {};
function pD(e, t) {
  return e.scopeValue("func", {
    ref: t,
    code: I0[t.code] || (I0[t.code] = new sD._Code(t.code))
  });
}
se.useFunc = pD;
var _h;
(function(e) {
  e[e.Num = 0] = "Num", e[e.Str = 1] = "Str";
})(_h || (se.Type = _h = {}));
function hD(e, t, r) {
  if (e instanceof He.Name) {
    const n = t === _h.Num;
    return r ? n ? (0, He._)`"[" + ${e} + "]"` : (0, He._)`"['" + ${e} + "']"` : n ? (0, He._)`"/" + ${e}` : (0, He._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return r ? (0, He.getProperty)(e).toString() : "/" + Lm(e);
}
se.getErrorPath = hD;
function rR(e, t, r = e.opts.strictSchema) {
  if (r) {
    if (t = `strict mode: ${t}`, r === !0)
      throw new Error(t);
    e.self.logger.warn(t);
  }
}
se.checkStrictMode = rR;
var br = {};
Object.defineProperty(br, "__esModule", { value: !0 });
const zt = he, mD = {
  // validation function arguments
  data: new zt.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new zt.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new zt.Name("instancePath"),
  parentData: new zt.Name("parentData"),
  parentDataProperty: new zt.Name("parentDataProperty"),
  rootData: new zt.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new zt.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new zt.Name("vErrors"),
  // null or array of validation errors
  errors: new zt.Name("errors"),
  // counter of validation errors
  this: new zt.Name("this"),
  // "globals"
  self: new zt.Name("self"),
  scope: new zt.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new zt.Name("json"),
  jsonPos: new zt.Name("jsonPos"),
  jsonLen: new zt.Name("jsonLen"),
  jsonPart: new zt.Name("jsonPart")
};
br.default = mD;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = he, r = se, n = br;
  e.keywordError = {
    message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: _, schemaType: g }) => g ? (0, t.str)`"${_}" keyword must be ${g} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
  };
  function i(_, g = e.keywordError, v, y) {
    const { it: E } = _, { gen: R, compositeRule: w, allErrors: C } = E, V = f(_, g, v);
    y ?? (w || C) ? c(R, V) : u(E, (0, t._)`[${V}]`);
  }
  e.reportError = i;
  function s(_, g = e.keywordError, v) {
    const { it: y } = _, { gen: E, compositeRule: R, allErrors: w } = y, C = f(_, g, v);
    c(E, C), R || w || u(y, n.default.vErrors);
  }
  e.reportExtraError = s;
  function o(_, g) {
    _.assign(n.default.errors, g), _.if((0, t._)`${n.default.vErrors} !== null`, () => _.if(g, () => _.assign((0, t._)`${n.default.vErrors}.length`, g), () => _.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = o;
  function a({ gen: _, keyword: g, schemaValue: v, data: y, errsCount: E, it: R }) {
    if (E === void 0)
      throw new Error("ajv implementation error");
    const w = _.name("err");
    _.forRange("i", E, n.default.errors, (C) => {
      _.const(w, (0, t._)`${n.default.vErrors}[${C}]`), _.if((0, t._)`${w}.instancePath === undefined`, () => _.assign((0, t._)`${w}.instancePath`, (0, t.strConcat)(n.default.instancePath, R.errorPath))), _.assign((0, t._)`${w}.schemaPath`, (0, t.str)`${R.errSchemaPath}/${g}`), R.opts.verbose && (_.assign((0, t._)`${w}.schema`, v), _.assign((0, t._)`${w}.data`, y));
    });
  }
  e.extendErrors = a;
  function c(_, g) {
    const v = _.const("err", g);
    _.if((0, t._)`${n.default.vErrors} === null`, () => _.assign(n.default.vErrors, (0, t._)`[${v}]`), (0, t._)`${n.default.vErrors}.push(${v})`), _.code((0, t._)`${n.default.errors}++`);
  }
  function u(_, g) {
    const { gen: v, validateName: y, schemaEnv: E } = _;
    E.$async ? v.throw((0, t._)`new ${_.ValidationError}(${g})`) : (v.assign((0, t._)`${y}.errors`, g), v.return(!1));
  }
  const l = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    // also used in JTD errors
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function f(_, g, v) {
    const { createErrors: y } = _.it;
    return y === !1 ? (0, t._)`{}` : m(_, g, v);
  }
  function m(_, g, v = {}) {
    const { gen: y, it: E } = _, R = [
      p(E, v),
      d(_, v)
    ];
    return h(_, g, R), y.object(...R);
  }
  function p({ errorPath: _ }, { instancePath: g }) {
    const v = g ? (0, t.str)`${_}${(0, r.getErrorPath)(g, r.Type.Str)}` : _;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, v)];
  }
  function d({ keyword: _, it: { errSchemaPath: g } }, { schemaPath: v, parentSchema: y }) {
    let E = y ? g : (0, t.str)`${g}/${_}`;
    return v && (E = (0, t.str)`${E}${(0, r.getErrorPath)(v, r.Type.Str)}`), [l.schemaPath, E];
  }
  function h(_, { params: g, message: v }, y) {
    const { keyword: E, data: R, schemaValue: w, it: C } = _, { opts: V, propertyName: b, topSchemaRef: F, schemaPath: H } = C;
    y.push([l.keyword, E], [l.params, typeof g == "function" ? g(_) : g || (0, t._)`{}`]), V.messages && y.push([l.message, typeof v == "function" ? v(_) : v]), V.verbose && y.push([l.schema, w], [l.parentSchema, (0, t._)`${F}${H}`], [n.default.data, R]), b && y.push([l.propertyName, b]);
  }
})(za);
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.boolOrEmptySchema = Hs.topBoolOrEmptySchema = void 0;
const gD = za, yD = he, vD = br, _D = {
  message: "boolean schema is false"
};
function bD(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? nR(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(vD.default.data) : (t.assign((0, yD._)`${n}.errors`, null), t.return(!0));
}
Hs.topBoolOrEmptySchema = bD;
function ED(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), nR(e)) : r.var(t, !0);
}
Hs.boolOrEmptySchema = ED;
function nR(e, t) {
  const { gen: r, data: n } = e, i = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, gD.reportError)(i, _D, void 0, t);
}
var yt = {}, Hi = {};
Object.defineProperty(Hi, "__esModule", { value: !0 });
Hi.getRules = Hi.isJSONType = void 0;
const wD = ["string", "number", "integer", "boolean", "null", "object", "array"], SD = new Set(wD);
function xD(e) {
  return typeof e == "string" && SD.has(e);
}
Hi.isJSONType = xD;
function RD() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
Hi.getRules = RD;
var gn = {};
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.shouldUseRule = gn.shouldUseGroup = gn.schemaHasRulesForType = void 0;
function $D({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && iR(e, n);
}
gn.schemaHasRulesForType = $D;
function iR(e, t) {
  return t.rules.some((r) => sR(e, r));
}
gn.shouldUseGroup = iR;
function sR(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
gn.shouldUseRule = sR;
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.reportTypeError = yt.checkDataTypes = yt.checkDataType = yt.coerceAndCheckDataType = yt.getJSONTypes = yt.getSchemaTypes = yt.DataType = void 0;
const TD = Hi, OD = gn, PD = za, Se = he, oR = se;
var ks;
(function(e) {
  e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong";
})(ks || (yt.DataType = ks = {}));
function CD(e) {
  const t = aR(e.type);
  if (t.includes("null")) {
    if (e.nullable === !1)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!t.length && e.nullable !== void 0)
      throw new Error('"nullable" cannot be used without "type"');
    e.nullable === !0 && t.push("null");
  }
  return t;
}
yt.getSchemaTypes = CD;
function aR(e) {
  const t = Array.isArray(e) ? e : e ? [e] : [];
  if (t.every(TD.isJSONType))
    return t;
  throw new Error("type must be JSONType or JSONType[]: " + t.join(","));
}
yt.getJSONTypes = aR;
function AD(e, t) {
  const { gen: r, data: n, opts: i } = e, s = ID(t, i.coerceTypes), o = t.length > 0 && !(s.length === 0 && t.length === 1 && (0, OD.schemaHasRulesForType)(e, t[0]));
  if (o) {
    const a = jm(t, n, i.strictNumbers, ks.Wrong);
    r.if(a, () => {
      s.length ? ND(e, t, s) : Um(e);
    });
  }
  return o;
}
yt.coerceAndCheckDataType = AD;
const cR = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function ID(e, t) {
  return t ? e.filter((r) => cR.has(r) || t === "array" && r === "array") : [];
}
function ND(e, t, r) {
  const { gen: n, data: i, opts: s } = e, o = n.let("dataType", (0, Se._)`typeof ${i}`), a = n.let("coerced", (0, Se._)`undefined`);
  s.coerceTypes === "array" && n.if((0, Se._)`${o} == 'object' && Array.isArray(${i}) && ${i}.length == 1`, () => n.assign(i, (0, Se._)`${i}[0]`).assign(o, (0, Se._)`typeof ${i}`).if(jm(t, i, s.strictNumbers), () => n.assign(a, i))), n.if((0, Se._)`${a} !== undefined`);
  for (const u of r)
    (cR.has(u) || u === "array" && s.coerceTypes === "array") && c(u);
  n.else(), Um(e), n.endIf(), n.if((0, Se._)`${a} !== undefined`, () => {
    n.assign(i, a), kD(e, a);
  });
  function c(u) {
    switch (u) {
      case "string":
        n.elseIf((0, Se._)`${o} == "number" || ${o} == "boolean"`).assign(a, (0, Se._)`"" + ${i}`).elseIf((0, Se._)`${i} === null`).assign(a, (0, Se._)`""`);
        return;
      case "number":
        n.elseIf((0, Se._)`${o} == "boolean" || ${i} === null
              || (${o} == "string" && ${i} && ${i} == +${i})`).assign(a, (0, Se._)`+${i}`);
        return;
      case "integer":
        n.elseIf((0, Se._)`${o} === "boolean" || ${i} === null
              || (${o} === "string" && ${i} && ${i} == +${i} && !(${i} % 1))`).assign(a, (0, Se._)`+${i}`);
        return;
      case "boolean":
        n.elseIf((0, Se._)`${i} === "false" || ${i} === 0 || ${i} === null`).assign(a, !1).elseIf((0, Se._)`${i} === "true" || ${i} === 1`).assign(a, !0);
        return;
      case "null":
        n.elseIf((0, Se._)`${i} === "" || ${i} === 0 || ${i} === false`), n.assign(a, null);
        return;
      case "array":
        n.elseIf((0, Se._)`${o} === "string" || ${o} === "number"
              || ${o} === "boolean" || ${i} === null`).assign(a, (0, Se._)`[${i}]`);
    }
  }
}
function kD({ gen: e, parentData: t, parentDataProperty: r }, n) {
  e.if((0, Se._)`${t} !== undefined`, () => e.assign((0, Se._)`${t}[${r}]`, n));
}
function bh(e, t, r, n = ks.Correct) {
  const i = n === ks.Correct ? Se.operators.EQ : Se.operators.NEQ;
  let s;
  switch (e) {
    case "null":
      return (0, Se._)`${t} ${i} null`;
    case "array":
      s = (0, Se._)`Array.isArray(${t})`;
      break;
    case "object":
      s = (0, Se._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
      break;
    case "integer":
      s = o((0, Se._)`!(${t} % 1) && !isNaN(${t})`);
      break;
    case "number":
      s = o();
      break;
    default:
      return (0, Se._)`typeof ${t} ${i} ${e}`;
  }
  return n === ks.Correct ? s : (0, Se.not)(s);
  function o(a = Se.nil) {
    return (0, Se.and)((0, Se._)`typeof ${t} == "number"`, a, r ? (0, Se._)`isFinite(${t})` : Se.nil);
  }
}
yt.checkDataType = bh;
function jm(e, t, r, n) {
  if (e.length === 1)
    return bh(e[0], t, r, n);
  let i;
  const s = (0, oR.toHash)(e);
  if (s.array && s.object) {
    const o = (0, Se._)`typeof ${t} != "object"`;
    i = s.null ? o : (0, Se._)`!${t} || ${o}`, delete s.null, delete s.array, delete s.object;
  } else
    i = Se.nil;
  s.number && delete s.integer;
  for (const o in s)
    i = (0, Se.and)(i, bh(o, t, r, n));
  return i;
}
yt.checkDataTypes = jm;
const DD = {
  message: ({ schema: e }) => `must be ${e}`,
  params: ({ schema: e, schemaValue: t }) => typeof e == "string" ? (0, Se._)`{type: ${e}}` : (0, Se._)`{type: ${t}}`
};
function Um(e) {
  const t = LD(e);
  (0, PD.reportError)(t, DD);
}
yt.reportTypeError = Um;
function LD(e) {
  const { gen: t, data: r, schema: n } = e, i = (0, oR.schemaRefOrVal)(e, n, "type");
  return {
    gen: t,
    keyword: "type",
    data: r,
    schema: n.type,
    schemaCode: i,
    schemaValue: i,
    parentSchema: n,
    params: {},
    it: e
  };
}
var ju = {};
Object.defineProperty(ju, "__esModule", { value: !0 });
ju.assignDefaults = void 0;
const is = he, FD = se;
function jD(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const i in r)
      N0(e, i, r[i].default);
  else t === "array" && Array.isArray(n) && n.forEach((i, s) => N0(e, s, i.default));
}
ju.assignDefaults = jD;
function N0(e, t, r) {
  const { gen: n, compositeRule: i, data: s, opts: o } = e;
  if (r === void 0)
    return;
  const a = (0, is._)`${s}${(0, is.getProperty)(t)}`;
  if (i) {
    (0, FD.checkStrictMode)(e, `default is ignored for: ${a}`);
    return;
  }
  let c = (0, is._)`${a} === undefined`;
  o.useDefaults === "empty" && (c = (0, is._)`${c} || ${a} === null || ${a} === ""`), n.if(c, (0, is._)`${a} = ${(0, is.stringify)(r)}`);
}
var Qr = {}, be = {};
Object.defineProperty(be, "__esModule", { value: !0 });
be.validateUnion = be.validateArray = be.usePattern = be.callValidateCode = be.schemaProperties = be.allSchemaProperties = be.noPropertyInData = be.propertyInData = be.isOwnProperty = be.hasPropFunc = be.reportMissingProp = be.checkMissingProp = be.checkReportMissingProp = void 0;
const Ke = he, Mm = se, Nn = br, UD = se;
function MD(e, t) {
  const { gen: r, data: n, it: i } = e;
  r.if(qm(r, n, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, Ke._)`${t}` }, !0), e.error();
  });
}
be.checkReportMissingProp = MD;
function HD({ gen: e, data: t, it: { opts: r } }, n, i) {
  return (0, Ke.or)(...n.map((s) => (0, Ke.and)(qm(e, t, s, r.ownProperties), (0, Ke._)`${i} = ${s}`)));
}
be.checkMissingProp = HD;
function qD(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
be.reportMissingProp = qD;
function lR(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, Ke._)`Object.prototype.hasOwnProperty`
  });
}
be.hasPropFunc = lR;
function Hm(e, t, r) {
  return (0, Ke._)`${lR(e)}.call(${t}, ${r})`;
}
be.isOwnProperty = Hm;
function BD(e, t, r, n) {
  const i = (0, Ke._)`${t}${(0, Ke.getProperty)(r)} !== undefined`;
  return n ? (0, Ke._)`${i} && ${Hm(e, t, r)}` : i;
}
be.propertyInData = BD;
function qm(e, t, r, n) {
  const i = (0, Ke._)`${t}${(0, Ke.getProperty)(r)} === undefined`;
  return n ? (0, Ke.or)(i, (0, Ke.not)(Hm(e, t, r))) : i;
}
be.noPropertyInData = qm;
function uR(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
be.allSchemaProperties = uR;
function zD(e, t) {
  return uR(t).filter((r) => !(0, Mm.alwaysValidSchema)(e, t[r]));
}
be.schemaProperties = zD;
function VD({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: i, errorPath: s }, it: o }, a, c, u) {
  const l = u ? (0, Ke._)`${e}, ${t}, ${n}${i}` : t, f = [
    [Nn.default.instancePath, (0, Ke.strConcat)(Nn.default.instancePath, s)],
    [Nn.default.parentData, o.parentData],
    [Nn.default.parentDataProperty, o.parentDataProperty],
    [Nn.default.rootData, Nn.default.rootData]
  ];
  o.opts.dynamicRef && f.push([Nn.default.dynamicAnchors, Nn.default.dynamicAnchors]);
  const m = (0, Ke._)`${l}, ${r.object(...f)}`;
  return c !== Ke.nil ? (0, Ke._)`${a}.call(${c}, ${m})` : (0, Ke._)`${a}(${m})`;
}
be.callValidateCode = VD;
const GD = (0, Ke._)`new RegExp`;
function WD({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: i } = t.code, s = i(r, n);
  return e.scopeValue("pattern", {
    key: s.toString(),
    ref: s,
    code: (0, Ke._)`${i.code === "new RegExp" ? GD : (0, UD.useFunc)(e, i)}(${r}, ${n})`
  });
}
be.usePattern = WD;
function KD(e) {
  const { gen: t, data: r, keyword: n, it: i } = e, s = t.name("valid");
  if (i.allErrors) {
    const a = t.let("valid", !0);
    return o(() => t.assign(a, !1)), a;
  }
  return t.var(s, !0), o(() => t.break()), s;
  function o(a) {
    const c = t.const("len", (0, Ke._)`${r}.length`);
    t.forRange("i", 0, c, (u) => {
      e.subschema({
        keyword: n,
        dataProp: u,
        dataPropType: Mm.Type.Num
      }, s), t.if((0, Ke.not)(s), a);
    });
  }
}
be.validateArray = KD;
function YD(e) {
  const { gen: t, schema: r, keyword: n, it: i } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, Mm.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const o = t.let("valid", !1), a = t.name("_valid");
  t.block(() => r.forEach((c, u) => {
    const l = e.subschema({
      keyword: n,
      schemaProp: u,
      compositeRule: !0
    }, a);
    t.assign(o, (0, Ke._)`${o} || ${a}`), e.mergeValidEvaluated(l, a) || t.if((0, Ke.not)(o));
  })), e.result(o, () => e.reset(), () => e.error(!0));
}
be.validateUnion = YD;
Object.defineProperty(Qr, "__esModule", { value: !0 });
Qr.validateKeywordUsage = Qr.validSchemaType = Qr.funcKeywordCode = Qr.macroKeywordCode = void 0;
const Qt = he, $i = br, JD = be, XD = za;
function ZD(e, t) {
  const { gen: r, keyword: n, schema: i, parentSchema: s, it: o } = e, a = t.macro.call(o.self, i, s, o), c = fR(r, n, a);
  o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
  const u = r.name("valid");
  e.subschema({
    schema: a,
    schemaPath: Qt.nil,
    errSchemaPath: `${o.errSchemaPath}/${n}`,
    topSchemaRef: c,
    compositeRule: !0
  }, u), e.pass(u, () => e.error(!0));
}
Qr.macroKeywordCode = ZD;
function QD(e, t) {
  var r;
  const { gen: n, keyword: i, schema: s, parentSchema: o, $data: a, it: c } = e;
  tL(c, t);
  const u = !a && t.compile ? t.compile.call(c.self, s, o, c) : t.validate, l = fR(n, i, u), f = n.let("valid");
  e.block$data(f, m), e.ok((r = t.valid) !== null && r !== void 0 ? r : f);
  function m() {
    if (t.errors === !1)
      h(), t.modifying && k0(e), _(() => e.error());
    else {
      const g = t.async ? p() : d();
      t.modifying && k0(e), _(() => eL(e, g));
    }
  }
  function p() {
    const g = n.let("ruleErrs", null);
    return n.try(() => h((0, Qt._)`await `), (v) => n.assign(f, !1).if((0, Qt._)`${v} instanceof ${c.ValidationError}`, () => n.assign(g, (0, Qt._)`${v}.errors`), () => n.throw(v))), g;
  }
  function d() {
    const g = (0, Qt._)`${l}.errors`;
    return n.assign(g, null), h(Qt.nil), g;
  }
  function h(g = t.async ? (0, Qt._)`await ` : Qt.nil) {
    const v = c.opts.passContext ? $i.default.this : $i.default.self, y = !("compile" in t && !a || t.schema === !1);
    n.assign(f, (0, Qt._)`${g}${(0, JD.callValidateCode)(e, l, v, y)}`, t.modifying);
  }
  function _(g) {
    var v;
    n.if((0, Qt.not)((v = t.valid) !== null && v !== void 0 ? v : f), g);
  }
}
Qr.funcKeywordCode = QD;
function k0(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, Qt._)`${n.parentData}[${n.parentDataProperty}]`));
}
function eL(e, t) {
  const { gen: r } = e;
  r.if((0, Qt._)`Array.isArray(${t})`, () => {
    r.assign($i.default.vErrors, (0, Qt._)`${$i.default.vErrors} === null ? ${t} : ${$i.default.vErrors}.concat(${t})`).assign($i.default.errors, (0, Qt._)`${$i.default.vErrors}.length`), (0, XD.extendErrors)(e);
  }, () => e.error());
}
function tL({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function fR(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, Qt.stringify)(r) });
}
function rL(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
Qr.validSchemaType = rL;
function nL({ schema: e, opts: t, self: r, errSchemaPath: n }, i, s) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(s) : i.keyword !== s)
    throw new Error("ajv implementation error");
  const o = i.dependencies;
  if (o != null && o.some((a) => !Object.prototype.hasOwnProperty.call(e, a)))
    throw new Error(`parent schema must have dependencies of ${s}: ${o.join(",")}`);
  if (i.validateSchema && !i.validateSchema(e[s])) {
    const c = `keyword "${s}" value is invalid at path "${n}": ` + r.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(c);
    else
      throw new Error(c);
  }
}
Qr.validateKeywordUsage = nL;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.extendSubschemaMode = Yn.extendSubschemaData = Yn.getSubschema = void 0;
const Zr = he, dR = se;
function iL(e, { keyword: t, schemaProp: r, schema: n, schemaPath: i, errSchemaPath: s, topSchemaRef: o }) {
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const a = e.schema[t];
    return r === void 0 ? {
      schema: a,
      schemaPath: (0, Zr._)`${e.schemaPath}${(0, Zr.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: a[r],
      schemaPath: (0, Zr._)`${e.schemaPath}${(0, Zr.getProperty)(t)}${(0, Zr.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, dR.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (i === void 0 || s === void 0 || o === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: i,
      topSchemaRef: o,
      errSchemaPath: s
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Yn.getSubschema = iL;
function sL(e, t, { dataProp: r, dataPropType: n, data: i, dataTypes: s, propertyName: o }) {
  if (i !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = t;
  if (r !== void 0) {
    const { errorPath: u, dataPathArr: l, opts: f } = t, m = a.let("data", (0, Zr._)`${t.data}${(0, Zr.getProperty)(r)}`, !0);
    c(m), e.errorPath = (0, Zr.str)`${u}${(0, dR.getErrorPath)(r, n, f.jsPropertySyntax)}`, e.parentDataProperty = (0, Zr._)`${r}`, e.dataPathArr = [...l, e.parentDataProperty];
  }
  if (i !== void 0) {
    const u = i instanceof Zr.Name ? i : a.let("data", i, !0);
    c(u), o !== void 0 && (e.propertyName = o);
  }
  s && (e.dataTypes = s);
  function c(u) {
    e.data = u, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, u];
  }
}
Yn.extendSubschemaData = sL;
function oL(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: i, allErrors: s }) {
  n !== void 0 && (e.compositeRule = n), i !== void 0 && (e.createErrors = i), s !== void 0 && (e.allErrors = s), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
Yn.extendSubschemaMode = oL;
var Nt = {}, Uu = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var n, i, s;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length) return !1;
      for (i = n; i-- !== 0; )
        if (!e(t[i], r[i])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
    if (s = Object.keys(t), n = s.length, n !== Object.keys(r).length) return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, s[i])) return !1;
    for (i = n; i-- !== 0; ) {
      var o = s[i];
      if (!e(t[o], r[o])) return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, pR = { exports: {} }, zn = pR.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, i = r.post || function() {
  };
  pl(t, n, i, e, "", e);
};
zn.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
zn.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
zn.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
zn.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function pl(e, t, r, n, i, s, o, a, c, u) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, i, s, o, a, c, u);
    for (var l in n) {
      var f = n[l];
      if (Array.isArray(f)) {
        if (l in zn.arrayKeywords)
          for (var m = 0; m < f.length; m++)
            pl(e, t, r, f[m], i + "/" + l + "/" + m, s, i, l, n, m);
      } else if (l in zn.propsKeywords) {
        if (f && typeof f == "object")
          for (var p in f)
            pl(e, t, r, f[p], i + "/" + l + "/" + aL(p), s, i, l, n, p);
      } else (l in zn.keywords || e.allKeys && !(l in zn.skipKeywords)) && pl(e, t, r, f, i + "/" + l, s, i, l, n);
    }
    r(n, i, s, o, a, c, u);
  }
}
function aL(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var cL = pR.exports;
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.getSchemaRefs = Nt.resolveUrl = Nt.normalizeId = Nt._getFullPath = Nt.getFullPath = Nt.inlineRef = void 0;
const lL = se, uL = Uu, fL = cL, dL = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function pL(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !Eh(e) : t ? hR(e) <= t : !1;
}
Nt.inlineRef = pL;
const hL = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Eh(e) {
  for (const t in e) {
    if (hL.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(Eh) || typeof r == "object" && Eh(r))
      return !0;
  }
  return !1;
}
function hR(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !dL.has(r) && (typeof e[r] == "object" && (0, lL.eachItem)(e[r], (n) => t += hR(n)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function mR(e, t = "", r) {
  r !== !1 && (t = Ds(t));
  const n = e.parse(t);
  return gR(e, n);
}
Nt.getFullPath = mR;
function gR(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
Nt._getFullPath = gR;
const mL = /#\/?$/;
function Ds(e) {
  return e ? e.replace(mL, "") : "";
}
Nt.normalizeId = Ds;
function gL(e, t, r) {
  return r = Ds(r), e.resolve(t, r);
}
Nt.resolveUrl = gL;
const yL = /^[a-z_][-a-z0-9._]*$/i;
function vL(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, i = Ds(e[r] || t), s = { "": i }, o = mR(n, i, !1), a = {}, c = /* @__PURE__ */ new Set();
  return fL(e, { allKeys: !0 }, (f, m, p, d) => {
    if (d === void 0)
      return;
    const h = o + m;
    let _ = s[d];
    typeof f[r] == "string" && (_ = g.call(this, f[r])), v.call(this, f.$anchor), v.call(this, f.$dynamicAnchor), s[m] = _;
    function g(y) {
      const E = this.opts.uriResolver.resolve;
      if (y = Ds(_ ? E(_, y) : y), c.has(y))
        throw l(y);
      c.add(y);
      let R = this.refs[y];
      return typeof R == "string" && (R = this.refs[R]), typeof R == "object" ? u(f, R.schema, y) : y !== Ds(h) && (y[0] === "#" ? (u(f, a[y], y), a[y] = f) : this.refs[y] = h), y;
    }
    function v(y) {
      if (typeof y == "string") {
        if (!yL.test(y))
          throw new Error(`invalid anchor "${y}"`);
        g.call(this, `#${y}`);
      }
    }
  }), a;
  function u(f, m, p) {
    if (m !== void 0 && !uL(f, m))
      throw l(p);
  }
  function l(f) {
    return new Error(`reference "${f}" resolves to more than one schema`);
  }
}
Nt.getSchemaRefs = vL;
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.getData = Cr.KeywordCxt = Cr.validateFunctionCode = void 0;
const yR = Hs, D0 = yt, Bm = gn, Hl = yt, _L = ju, Yo = Qr, Cd = Yn, ue = he, ge = br, bL = Nt, yn = se, xo = za;
function EL(e) {
  if (bR(e) && (ER(e), _R(e))) {
    xL(e);
    return;
  }
  vR(e, () => (0, yR.topBoolOrEmptySchema)(e));
}
Cr.validateFunctionCode = EL;
function vR({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: i }, s) {
  i.code.es5 ? e.func(t, (0, ue._)`${ge.default.data}, ${ge.default.valCxt}`, n.$async, () => {
    e.code((0, ue._)`"use strict"; ${L0(r, i)}`), SL(e, i), e.code(s);
  }) : e.func(t, (0, ue._)`${ge.default.data}, ${wL(i)}`, n.$async, () => e.code(L0(r, i)).code(s));
}
function wL(e) {
  return (0, ue._)`{${ge.default.instancePath}="", ${ge.default.parentData}, ${ge.default.parentDataProperty}, ${ge.default.rootData}=${ge.default.data}${e.dynamicRef ? (0, ue._)`, ${ge.default.dynamicAnchors}={}` : ue.nil}}={}`;
}
function SL(e, t) {
  e.if(ge.default.valCxt, () => {
    e.var(ge.default.instancePath, (0, ue._)`${ge.default.valCxt}.${ge.default.instancePath}`), e.var(ge.default.parentData, (0, ue._)`${ge.default.valCxt}.${ge.default.parentData}`), e.var(ge.default.parentDataProperty, (0, ue._)`${ge.default.valCxt}.${ge.default.parentDataProperty}`), e.var(ge.default.rootData, (0, ue._)`${ge.default.valCxt}.${ge.default.rootData}`), t.dynamicRef && e.var(ge.default.dynamicAnchors, (0, ue._)`${ge.default.valCxt}.${ge.default.dynamicAnchors}`);
  }, () => {
    e.var(ge.default.instancePath, (0, ue._)`""`), e.var(ge.default.parentData, (0, ue._)`undefined`), e.var(ge.default.parentDataProperty, (0, ue._)`undefined`), e.var(ge.default.rootData, ge.default.data), t.dynamicRef && e.var(ge.default.dynamicAnchors, (0, ue._)`{}`);
  });
}
function xL(e) {
  const { schema: t, opts: r, gen: n } = e;
  vR(e, () => {
    r.$comment && t.$comment && SR(e), PL(e), n.let(ge.default.vErrors, null), n.let(ge.default.errors, 0), r.unevaluated && RL(e), wR(e), IL(e);
  });
}
function RL(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, ue._)`${r}.evaluated`), t.if((0, ue._)`${e.evaluated}.dynamicProps`, () => t.assign((0, ue._)`${e.evaluated}.props`, (0, ue._)`undefined`)), t.if((0, ue._)`${e.evaluated}.dynamicItems`, () => t.assign((0, ue._)`${e.evaluated}.items`, (0, ue._)`undefined`));
}
function L0(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, ue._)`/*# sourceURL=${r} */` : ue.nil;
}
function $L(e, t) {
  if (bR(e) && (ER(e), _R(e))) {
    TL(e, t);
    return;
  }
  (0, yR.boolOrEmptySchema)(e, t);
}
function _R({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
function bR(e) {
  return typeof e.schema != "boolean";
}
function TL(e, t) {
  const { schema: r, gen: n, opts: i } = e;
  i.$comment && r.$comment && SR(e), CL(e), AL(e);
  const s = n.const("_errs", ge.default.errors);
  wR(e, s), n.var(t, (0, ue._)`${s} === ${ge.default.errors}`);
}
function ER(e) {
  (0, yn.checkUnknownRules)(e), OL(e);
}
function wR(e, t) {
  if (e.opts.jtd)
    return F0(e, [], !1, t);
  const r = (0, D0.getSchemaTypes)(e.schema), n = (0, D0.coerceAndCheckDataType)(e, r);
  F0(e, r, !n, t);
}
function OL(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: i } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, yn.schemaHasRulesButRef)(t, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function PL(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, yn.checkStrictMode)(e, "default is ignored in the schema root");
}
function CL(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, bL.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function AL(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function SR({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: i }) {
  const s = r.$comment;
  if (i.$comment === !0)
    e.code((0, ue._)`${ge.default.self}.logger.log(${s})`);
  else if (typeof i.$comment == "function") {
    const o = (0, ue.str)`${n}/$comment`, a = e.scopeValue("root", { ref: t.root });
    e.code((0, ue._)`${ge.default.self}.opts.$comment(${s}, ${o}, ${a}.schema)`);
  }
}
function IL(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: i, opts: s } = e;
  r.$async ? t.if((0, ue._)`${ge.default.errors} === 0`, () => t.return(ge.default.data), () => t.throw((0, ue._)`new ${i}(${ge.default.vErrors})`)) : (t.assign((0, ue._)`${n}.errors`, ge.default.vErrors), s.unevaluated && NL(e), t.return((0, ue._)`${ge.default.errors} === 0`));
}
function NL({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof ue.Name && e.assign((0, ue._)`${t}.props`, r), n instanceof ue.Name && e.assign((0, ue._)`${t}.items`, n);
}
function F0(e, t, r, n) {
  const { gen: i, schema: s, data: o, allErrors: a, opts: c, self: u } = e, { RULES: l } = u;
  if (s.$ref && (c.ignoreKeywordsWithRef || !(0, yn.schemaHasRulesButRef)(s, l))) {
    i.block(() => $R(e, "$ref", l.all.$ref.definition));
    return;
  }
  c.jtd || kL(e, t), i.block(() => {
    for (const m of l.rules)
      f(m);
    f(l.post);
  });
  function f(m) {
    (0, Bm.shouldUseGroup)(s, m) && (m.type ? (i.if((0, Hl.checkDataType)(m.type, o, c.strictNumbers)), j0(e, m), t.length === 1 && t[0] === m.type && r && (i.else(), (0, Hl.reportTypeError)(e)), i.endIf()) : j0(e, m), a || i.if((0, ue._)`${ge.default.errors} === ${n || 0}`));
  }
}
function j0(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: i } } = e;
  i && (0, _L.assignDefaults)(e, t.type), r.block(() => {
    for (const s of t.rules)
      (0, Bm.shouldUseRule)(n, s) && $R(e, s.keyword, s.definition, t.type);
  });
}
function kL(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (DL(e, t), e.opts.allowUnionTypes || LL(e, t), FL(e, e.dataTypes));
}
function DL(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      xR(e.dataTypes, r) || zm(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), UL(e, t);
  }
}
function LL(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && zm(e, "use allowUnionTypes to allow union type keyword");
}
function FL(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const i = r[n];
    if (typeof i == "object" && (0, Bm.shouldUseRule)(e.schema, i)) {
      const { type: s } = i.definition;
      s.length && !s.some((o) => jL(t, o)) && zm(e, `missing type "${s.join(",")}" for keyword "${n}"`);
    }
  }
}
function jL(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function xR(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function UL(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    xR(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function zm(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, yn.checkStrictMode)(e, t, e.opts.strictTypes);
}
class RR {
  constructor(t, r, n) {
    if ((0, Yo.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, yn.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", TR(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Yo.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", ge.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, ue.not)(t), r, n);
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, ue.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, ue._)`${r} !== undefined && (${(0, ue.or)(this.invalid$data(), t)})`);
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
    (t ? xo.reportExtraError : xo.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, xo.reportError)(this, this.def.$dataError || xo.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, xo.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, n = ue.nil) {
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
  check$data(t = ue.nil, r = ue.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: i, schemaType: s, def: o } = this;
    n.if((0, ue.or)((0, ue._)`${i} === undefined`, r)), t !== ue.nil && n.assign(t, !0), (s.length || o.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== ue.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: i, it: s } = this;
    return (0, ue.or)(o(), a());
    function o() {
      if (n.length) {
        if (!(r instanceof ue.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(n) ? n : [n];
        return (0, ue._)`${(0, Hl.checkDataTypes)(c, r, s.opts.strictNumbers, Hl.DataType.Wrong)}`;
      }
      return ue.nil;
    }
    function a() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, ue._)`!${c}(${r})`;
      }
      return ue.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Cd.getSubschema)(this.it, t);
    (0, Cd.extendSubschemaData)(n, this.it, t), (0, Cd.extendSubschemaMode)(n, t);
    const i = { ...this.it, ...n, items: void 0, props: void 0 };
    return $L(i, r), i;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: i } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = yn.mergeEvaluated.props(i, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = yn.mergeEvaluated.items(i, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: i } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return i.if(r, () => this.mergeEvaluated(t, ue.Name)), !0;
  }
}
Cr.KeywordCxt = RR;
function $R(e, t, r, n) {
  const i = new RR(e, r, t);
  "code" in r ? r.code(i, n) : i.$data && r.validate ? (0, Yo.funcKeywordCode)(i, r) : "macro" in r ? (0, Yo.macroKeywordCode)(i, r) : (r.compile || r.validate) && (0, Yo.funcKeywordCode)(i, r);
}
const ML = /^\/(?:[^~]|~0|~1)*$/, HL = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function TR(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let i, s;
  if (e === "")
    return ge.default.rootData;
  if (e[0] === "/") {
    if (!ML.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    i = e, s = ge.default.rootData;
  } else {
    const u = HL.exec(e);
    if (!u)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const l = +u[1];
    if (i = u[2], i === "#") {
      if (l >= t)
        throw new Error(c("property/index", l));
      return n[t - l];
    }
    if (l > t)
      throw new Error(c("data", l));
    if (s = r[t - l], !i)
      return s;
  }
  let o = s;
  const a = i.split("/");
  for (const u of a)
    u && (s = (0, ue._)`${s}${(0, ue.getProperty)((0, yn.unescapeJsonPointer)(u))}`, o = (0, ue._)`${o} && ${s}`);
  return o;
  function c(u, l) {
    return `Cannot access ${u} ${l} levels up, current level is ${t}`;
  }
}
Cr.getData = TR;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
class qL extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
ro.default = qL;
var an = {};
Object.defineProperty(an, "__esModule", { value: !0 });
const Ad = Nt;
class BL extends Error {
  constructor(t, r, n, i) {
    super(i || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, Ad.resolveUrl)(t, r, n), this.missingSchema = (0, Ad.normalizeId)((0, Ad.getFullPath)(t, this.missingRef));
  }
}
an.default = BL;
var kt = {};
Object.defineProperty(kt, "__esModule", { value: !0 });
kt.resolveSchema = kt.getCompilingSchema = kt.resolveRef = kt.compileSchema = kt.SchemaEnv = void 0;
const Lr = he, zL = ro, hi = br, Mr = Nt, U0 = se, VL = Cr;
class Mu {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, Mr.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
kt.SchemaEnv = Mu;
function Vm(e) {
  const t = OR.call(this, e);
  if (t)
    return t;
  const r = (0, Mr.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new Lr.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s });
  let a;
  e.$async && (a = o.scopeValue("Error", {
    ref: zL.default,
    code: (0, Lr._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = o.scopeName("validate");
  e.validateName = c;
  const u = {
    gen: o,
    allErrors: this.opts.allErrors,
    data: hi.default.data,
    parentData: hi.default.parentData,
    parentDataProperty: hi.default.parentDataProperty,
    dataNames: [hi.default.data],
    dataPathArr: [Lr.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: o.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, Lr.stringify)(e.schema) } : { ref: e.schema }),
    validateName: c,
    ValidationError: a,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: Lr.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Lr._)`""`,
    opts: this.opts,
    self: this
  };
  let l;
  try {
    this._compilations.add(e), (0, VL.validateFunctionCode)(u), o.optimize(this.opts.code.optimize);
    const f = o.toString();
    l = `${o.scopeRefs(hi.default.scope)}return ${f}`, this.opts.code.process && (l = this.opts.code.process(l, e));
    const p = new Function(`${hi.default.self}`, `${hi.default.scope}`, l)(this, this.scope.get());
    if (this.scope.value(c, { ref: p }), p.errors = null, p.schema = e.schema, p.schemaEnv = e, e.$async && (p.$async = !0), this.opts.code.source === !0 && (p.source = { validateName: c, validateCode: f, scopeValues: o._values }), this.opts.unevaluated) {
      const { props: d, items: h } = u;
      p.evaluated = {
        props: d instanceof Lr.Name ? void 0 : d,
        items: h instanceof Lr.Name ? void 0 : h,
        dynamicProps: d instanceof Lr.Name,
        dynamicItems: h instanceof Lr.Name
      }, p.source && (p.source.evaluated = (0, Lr.stringify)(p.evaluated));
    }
    return e.validate = p, e;
  } catch (f) {
    throw delete e.validate, delete e.validateName, l && this.logger.error("Error compiling schema, function code:", l), f;
  } finally {
    this._compilations.delete(e);
  }
}
kt.compileSchema = Vm;
function GL(e, t, r) {
  var n;
  r = (0, Mr.resolveUrl)(this.opts.uriResolver, t, r);
  const i = e.refs[r];
  if (i)
    return i;
  let s = YL.call(this, e, r);
  if (s === void 0) {
    const o = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: a } = this.opts;
    o && (s = new Mu({ schema: o, schemaId: a, root: e, baseId: t }));
  }
  if (s !== void 0)
    return e.refs[r] = WL.call(this, s);
}
kt.resolveRef = GL;
function WL(e) {
  return (0, Mr.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : Vm.call(this, e);
}
function OR(e) {
  for (const t of this._compilations)
    if (KL(t, e))
      return t;
}
kt.getCompilingSchema = OR;
function KL(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function YL(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Hu.call(this, e, t);
}
function Hu(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, Mr._getFullPath)(this.opts.uriResolver, r);
  let i = (0, Mr.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === i)
    return Id.call(this, r, e);
  const s = (0, Mr.normalizeId)(n), o = this.refs[s] || this.schemas[s];
  if (typeof o == "string") {
    const a = Hu.call(this, e, o);
    return typeof (a == null ? void 0 : a.schema) != "object" ? void 0 : Id.call(this, r, a);
  }
  if (typeof (o == null ? void 0 : o.schema) == "object") {
    if (o.validate || Vm.call(this, o), s === (0, Mr.normalizeId)(t)) {
      const { schema: a } = o, { schemaId: c } = this.opts, u = a[c];
      return u && (i = (0, Mr.resolveUrl)(this.opts.uriResolver, i, u)), new Mu({ schema: a, schemaId: c, root: e, baseId: i });
    }
    return Id.call(this, r, o);
  }
}
kt.resolveSchema = Hu;
const JL = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Id(e, { baseId: t, schema: r, root: n }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const a of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const c = r[(0, U0.unescapeFragment)(a)];
    if (c === void 0)
      return;
    r = c;
    const u = typeof r == "object" && r[this.opts.schemaId];
    !JL.has(a) && u && (t = (0, Mr.resolveUrl)(this.opts.uriResolver, t, u));
  }
  let s;
  if (typeof r != "boolean" && r.$ref && !(0, U0.schemaHasRulesButRef)(r, this.RULES)) {
    const a = (0, Mr.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    s = Hu.call(this, n, a);
  }
  const { schemaId: o } = this.opts;
  if (s = s || new Mu({ schema: r, schemaId: o, root: n, baseId: t }), s.schema !== s.root.schema)
    return s;
}
const XL = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", ZL = "Meta-schema for $data reference (JSON AnySchema extension proposal)", QL = "object", eF = [
  "$data"
], tF = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, rF = !1, nF = {
  $id: XL,
  description: ZL,
  type: QL,
  required: eF,
  properties: tF,
  additionalProperties: rF
};
var Gm = {}, qu = { exports: {} };
const iF = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var sF = {
  HEX: iF
};
const { HEX: oF } = sF, aF = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
function PR(e) {
  if (AR(e, ".") < 3)
    return { host: e, isIPV4: !1 };
  const t = e.match(aF) || [], [r] = t;
  return r ? { host: lF(r, "."), isIPV4: !0 } : { host: e, isIPV4: !1 };
}
function M0(e, t = !1) {
  let r = "", n = !0;
  for (const i of e) {
    if (oF[i] === void 0) return;
    i !== "0" && n === !0 && (n = !1), n || (r += i);
  }
  return t && r.length === 0 && (r = "0"), r;
}
function cF(e) {
  let t = 0;
  const r = { error: !1, address: "", zone: "" }, n = [], i = [];
  let s = !1, o = !1, a = !1;
  function c() {
    if (i.length) {
      if (s === !1) {
        const u = M0(i);
        if (u !== void 0)
          n.push(u);
        else
          return r.error = !0, !1;
      }
      i.length = 0;
    }
    return !0;
  }
  for (let u = 0; u < e.length; u++) {
    const l = e[u];
    if (!(l === "[" || l === "]"))
      if (l === ":") {
        if (o === !0 && (a = !0), !c())
          break;
        if (t++, n.push(":"), t > 7) {
          r.error = !0;
          break;
        }
        u - 1 >= 0 && e[u - 1] === ":" && (o = !0);
        continue;
      } else if (l === "%") {
        if (!c())
          break;
        s = !0;
      } else {
        i.push(l);
        continue;
      }
  }
  return i.length && (s ? r.zone = i.join("") : a ? n.push(i.join("")) : n.push(M0(i))), r.address = n.join(""), r;
}
function CR(e) {
  if (AR(e, ":") < 2)
    return { host: e, isIPV6: !1 };
  const t = cF(e);
  if (t.error)
    return { host: e, isIPV6: !1 };
  {
    let r = t.address, n = t.address;
    return t.zone && (r += "%" + t.zone, n += "%25" + t.zone), { host: r, escapedHost: n, isIPV6: !0 };
  }
}
function lF(e, t) {
  let r = "", n = !0;
  const i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    o === "0" && n ? (s + 1 <= i && e[s + 1] === t || s + 1 === i) && (r += o, n = !1) : (o === t ? n = !0 : n = !1, r += o);
  }
  return r;
}
function AR(e, t) {
  let r = 0;
  for (let n = 0; n < e.length; n++)
    e[n] === t && r++;
  return r;
}
const H0 = /^\.\.?\//u, q0 = /^\/\.(?:\/|$)/u, B0 = /^\/\.\.(?:\/|$)/u, uF = /^\/?(?:.|\n)*?(?=\/|$)/u;
function fF(e) {
  const t = [];
  for (; e.length; )
    if (e.match(H0))
      e = e.replace(H0, "");
    else if (e.match(q0))
      e = e.replace(q0, "/");
    else if (e.match(B0))
      e = e.replace(B0, "/"), t.pop();
    else if (e === "." || e === "..")
      e = "";
    else {
      const r = e.match(uF);
      if (r) {
        const n = r[0];
        e = e.slice(n.length), t.push(n);
      } else
        throw new Error("Unexpected dot segment condition");
    }
  return t.join("");
}
function dF(e, t) {
  const r = t !== !0 ? escape : unescape;
  return e.scheme !== void 0 && (e.scheme = r(e.scheme)), e.userinfo !== void 0 && (e.userinfo = r(e.userinfo)), e.host !== void 0 && (e.host = r(e.host)), e.path !== void 0 && (e.path = r(e.path)), e.query !== void 0 && (e.query = r(e.query)), e.fragment !== void 0 && (e.fragment = r(e.fragment)), e;
}
function pF(e) {
  const t = [];
  if (e.userinfo !== void 0 && (t.push(e.userinfo), t.push("@")), e.host !== void 0) {
    let r = unescape(e.host);
    const n = PR(r);
    if (n.isIPV4)
      r = n.host;
    else {
      const i = CR(n.host);
      i.isIPV6 === !0 ? r = `[${i.escapedHost}]` : r = e.host;
    }
    t.push(r);
  }
  return (typeof e.port == "number" || typeof e.port == "string") && (t.push(":"), t.push(String(e.port))), t.length ? t.join("") : void 0;
}
var hF = {
  recomposeAuthority: pF,
  normalizeComponentEncoding: dF,
  removeDotSegments: fF,
  normalizeIPv4: PR,
  normalizeIPv6: CR
};
const mF = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, gF = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function IR(e) {
  return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss";
}
function NR(e) {
  return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
}
function kR(e) {
  const t = String(e.scheme).toLowerCase() === "https";
  return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0), e.path || (e.path = "/"), e;
}
function yF(e) {
  return e.secure = IR(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e;
}
function vF(e) {
  if ((e.port === (IR(e) ? 443 : 80) || e.port === "") && (e.port = void 0), typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
    const [t, r] = e.resourceName.split("?");
    e.path = t && t !== "/" ? t : void 0, e.query = r, e.resourceName = void 0;
  }
  return e.fragment = void 0, e;
}
function _F(e, t) {
  if (!e.path)
    return e.error = "URN can not be parsed", e;
  const r = e.path.match(gF);
  if (r) {
    const n = t.scheme || e.scheme || "urn";
    e.nid = r[1].toLowerCase(), e.nss = r[2];
    const i = `${n}:${t.nid || e.nid}`, s = Wm[i];
    e.path = void 0, s && (e = s.parse(e, t));
  } else
    e.error = e.error || "URN can not be parsed.";
  return e;
}
function bF(e, t) {
  const r = t.scheme || e.scheme || "urn", n = e.nid.toLowerCase(), i = `${r}:${t.nid || n}`, s = Wm[i];
  s && (e = s.serialize(e, t));
  const o = e, a = e.nss;
  return o.path = `${n || t.nid}:${a}`, t.skipEscape = !0, o;
}
function EF(e, t) {
  const r = e;
  return r.uuid = r.nss, r.nss = void 0, !t.tolerant && (!r.uuid || !mF.test(r.uuid)) && (r.error = r.error || "UUID is not valid."), r;
}
function wF(e) {
  const t = e;
  return t.nss = (e.uuid || "").toLowerCase(), t;
}
const DR = {
  scheme: "http",
  domainHost: !0,
  parse: NR,
  serialize: kR
}, SF = {
  scheme: "https",
  domainHost: DR.domainHost,
  parse: NR,
  serialize: kR
}, hl = {
  scheme: "ws",
  domainHost: !0,
  parse: yF,
  serialize: vF
}, xF = {
  scheme: "wss",
  domainHost: hl.domainHost,
  parse: hl.parse,
  serialize: hl.serialize
}, RF = {
  scheme: "urn",
  parse: _F,
  serialize: bF,
  skipNormalize: !0
}, $F = {
  scheme: "urn:uuid",
  parse: EF,
  serialize: wF,
  skipNormalize: !0
}, Wm = {
  http: DR,
  https: SF,
  ws: hl,
  wss: xF,
  urn: RF,
  "urn:uuid": $F
};
var TF = Wm;
const { normalizeIPv6: OF, normalizeIPv4: PF, removeDotSegments: Bo, recomposeAuthority: CF, normalizeComponentEncoding: Oc } = hF, Km = TF;
function AF(e, t) {
  return typeof e == "string" ? e = en(bn(e, t), t) : typeof e == "object" && (e = bn(en(e, t), t)), e;
}
function IF(e, t, r) {
  const n = Object.assign({ scheme: "null" }, r), i = LR(bn(e, n), bn(t, n), n, !0);
  return en(i, { ...n, skipEscape: !0 });
}
function LR(e, t, r, n) {
  const i = {};
  return n || (e = bn(en(e, r), r), t = bn(en(t, r), r)), r = r || {}, !r.tolerant && t.scheme ? (i.scheme = t.scheme, i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = Bo(t.path || ""), i.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = Bo(t.path || ""), i.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? i.path = Bo(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? i.path = "/" + t.path : e.path ? i.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : i.path = t.path, i.path = Bo(i.path)), i.query = t.query) : (i.path = e.path, t.query !== void 0 ? i.query = t.query : i.query = e.query), i.userinfo = e.userinfo, i.host = e.host, i.port = e.port), i.scheme = e.scheme), i.fragment = t.fragment, i;
}
function NF(e, t, r) {
  return typeof e == "string" ? (e = unescape(e), e = en(Oc(bn(e, r), !0), { ...r, skipEscape: !0 })) : typeof e == "object" && (e = en(Oc(e, !0), { ...r, skipEscape: !0 })), typeof t == "string" ? (t = unescape(t), t = en(Oc(bn(t, r), !0), { ...r, skipEscape: !0 })) : typeof t == "object" && (t = en(Oc(t, !0), { ...r, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase();
}
function en(e, t) {
  const r = {
    host: e.host,
    scheme: e.scheme,
    userinfo: e.userinfo,
    port: e.port,
    path: e.path,
    query: e.query,
    nid: e.nid,
    nss: e.nss,
    uuid: e.uuid,
    fragment: e.fragment,
    reference: e.reference,
    resourceName: e.resourceName,
    secure: e.secure,
    error: ""
  }, n = Object.assign({}, t), i = [], s = Km[(n.scheme || r.scheme || "").toLowerCase()];
  s && s.serialize && s.serialize(r, n), r.path !== void 0 && (n.skipEscape ? r.path = unescape(r.path) : (r.path = escape(r.path), r.scheme !== void 0 && (r.path = r.path.split("%3A").join(":")))), n.reference !== "suffix" && r.scheme && i.push(r.scheme, ":");
  const o = CF(r);
  if (o !== void 0 && (n.reference !== "suffix" && i.push("//"), i.push(o), r.path && r.path.charAt(0) !== "/" && i.push("/")), r.path !== void 0) {
    let a = r.path;
    !n.absolutePath && (!s || !s.absolutePath) && (a = Bo(a)), o === void 0 && (a = a.replace(/^\/\//u, "/%2F")), i.push(a);
  }
  return r.query !== void 0 && i.push("?", r.query), r.fragment !== void 0 && i.push("#", r.fragment), i.join("");
}
const kF = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
function DF(e) {
  let t = 0;
  for (let r = 0, n = e.length; r < n; ++r)
    if (t = e.charCodeAt(r), t > 126 || kF[t])
      return !0;
  return !1;
}
const LF = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function bn(e, t) {
  const r = Object.assign({}, t), n = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  }, i = e.indexOf("%") !== -1;
  let s = !1;
  r.reference === "suffix" && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e);
  const o = e.match(LF);
  if (o) {
    if (n.scheme = o[1], n.userinfo = o[3], n.host = o[4], n.port = parseInt(o[5], 10), n.path = o[6] || "", n.query = o[7], n.fragment = o[8], isNaN(n.port) && (n.port = o[5]), n.host) {
      const c = PF(n.host);
      if (c.isIPV4 === !1) {
        const u = OF(c.host);
        n.host = u.host.toLowerCase(), s = u.isIPV6;
      } else
        n.host = c.host, s = !0;
    }
    n.scheme === void 0 && n.userinfo === void 0 && n.host === void 0 && n.port === void 0 && n.query === void 0 && !n.path ? n.reference = "same-document" : n.scheme === void 0 ? n.reference = "relative" : n.fragment === void 0 ? n.reference = "absolute" : n.reference = "uri", r.reference && r.reference !== "suffix" && r.reference !== n.reference && (n.error = n.error || "URI is not a " + r.reference + " reference.");
    const a = Km[(r.scheme || n.scheme || "").toLowerCase()];
    if (!r.unicodeSupport && (!a || !a.unicodeSupport) && n.host && (r.domainHost || a && a.domainHost) && s === !1 && DF(n.host))
      try {
        n.host = URL.domainToASCII(n.host.toLowerCase());
      } catch (c) {
        n.error = n.error || "Host's domain name can not be converted to ASCII: " + c;
      }
    (!a || a && !a.skipNormalize) && (i && n.scheme !== void 0 && (n.scheme = unescape(n.scheme)), i && n.host !== void 0 && (n.host = unescape(n.host)), n.path && (n.path = escape(unescape(n.path))), n.fragment && (n.fragment = encodeURI(decodeURIComponent(n.fragment)))), a && a.parse && a.parse(n, r);
  } else
    n.error = n.error || "URI can not be parsed.";
  return n;
}
const Ym = {
  SCHEMES: Km,
  normalize: AF,
  resolve: IF,
  resolveComponents: LR,
  equal: NF,
  serialize: en,
  parse: bn
};
qu.exports = Ym;
qu.exports.default = Ym;
qu.exports.fastUri = Ym;
var Jm = qu.exports;
Object.defineProperty(Gm, "__esModule", { value: !0 });
const FR = Jm;
FR.code = 'require("ajv/dist/runtime/uri").default';
Gm.default = FR;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = Cr;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = he;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = ro, i = an, s = Hi, o = kt, a = he, c = Nt, u = yt, l = se, f = nF, m = Gm, p = (j, k) => new RegExp(j, k);
  p.code = "new RegExp";
  const d = ["removeAdditional", "useDefaults", "coerceTypes"], h = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), _ = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, g = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, v = 200;
  function y(j) {
    var k, U, M, T, N, G, O, S, W, z, Q, K, X, J, re, fe, ee, le, xe, ye, ve, ze, Ae, $t, $n;
    const Le = j.strict, Ut = (k = j.code) === null || k === void 0 ? void 0 : k.optimize, Er = Ut === !0 || Ut === void 0 ? 1 : Ut || 0, Ne = (M = (U = j.code) === null || U === void 0 ? void 0 : U.regExp) !== null && M !== void 0 ? M : p, je = (T = j.uriResolver) !== null && T !== void 0 ? T : m.default;
    return {
      strictSchema: (G = (N = j.strictSchema) !== null && N !== void 0 ? N : Le) !== null && G !== void 0 ? G : !0,
      strictNumbers: (S = (O = j.strictNumbers) !== null && O !== void 0 ? O : Le) !== null && S !== void 0 ? S : !0,
      strictTypes: (z = (W = j.strictTypes) !== null && W !== void 0 ? W : Le) !== null && z !== void 0 ? z : "log",
      strictTuples: (K = (Q = j.strictTuples) !== null && Q !== void 0 ? Q : Le) !== null && K !== void 0 ? K : "log",
      strictRequired: (J = (X = j.strictRequired) !== null && X !== void 0 ? X : Le) !== null && J !== void 0 ? J : !1,
      code: j.code ? { ...j.code, optimize: Er, regExp: Ne } : { optimize: Er, regExp: Ne },
      loopRequired: (re = j.loopRequired) !== null && re !== void 0 ? re : v,
      loopEnum: (fe = j.loopEnum) !== null && fe !== void 0 ? fe : v,
      meta: (ee = j.meta) !== null && ee !== void 0 ? ee : !0,
      messages: (le = j.messages) !== null && le !== void 0 ? le : !0,
      inlineRefs: (xe = j.inlineRefs) !== null && xe !== void 0 ? xe : !0,
      schemaId: (ye = j.schemaId) !== null && ye !== void 0 ? ye : "$id",
      addUsedSchema: (ve = j.addUsedSchema) !== null && ve !== void 0 ? ve : !0,
      validateSchema: (ze = j.validateSchema) !== null && ze !== void 0 ? ze : !0,
      validateFormats: (Ae = j.validateFormats) !== null && Ae !== void 0 ? Ae : !0,
      unicodeRegExp: ($t = j.unicodeRegExp) !== null && $t !== void 0 ? $t : !0,
      int32range: ($n = j.int32range) !== null && $n !== void 0 ? $n : !0,
      uriResolver: je
    };
  }
  class E {
    constructor(k = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), k = this.opts = { ...k, ...y(k) };
      const { es5: U, lines: M } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: h, es5: U, lines: M }), this.logger = q(k.logger);
      const T = k.validateFormats;
      k.validateFormats = !1, this.RULES = (0, s.getRules)(), R.call(this, _, k, "NOT SUPPORTED"), R.call(this, g, k, "DEPRECATED", "warn"), this._metaOpts = F.call(this), k.formats && V.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), k.keywords && b.call(this, k.keywords), typeof k.meta == "object" && this.addMetaSchema(k.meta), C.call(this), k.validateFormats = T;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: k, meta: U, schemaId: M } = this.opts;
      let T = f;
      M === "id" && (T = { ...f }, T.id = T.$id, delete T.$id), U && k && this.addMetaSchema(T, T[M], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: U } = this.opts;
      return this.opts.defaultMeta = typeof k == "object" ? k[U] || k : void 0;
    }
    validate(k, U) {
      let M;
      if (typeof k == "string") {
        if (M = this.getSchema(k), !M)
          throw new Error(`no schema with key or ref "${k}"`);
      } else
        M = this.compile(k);
      const T = M(U);
      return "$async" in M || (this.errors = M.errors), T;
    }
    compile(k, U) {
      const M = this._addSchema(k, U);
      return M.validate || this._compileSchemaEnv(M);
    }
    compileAsync(k, U) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: M } = this.opts;
      return T.call(this, k, U);
      async function T(z, Q) {
        await N.call(this, z.$schema);
        const K = this._addSchema(z, Q);
        return K.validate || G.call(this, K);
      }
      async function N(z) {
        z && !this.getSchema(z) && await T.call(this, { $ref: z }, !0);
      }
      async function G(z) {
        try {
          return this._compileSchemaEnv(z);
        } catch (Q) {
          if (!(Q instanceof i.default))
            throw Q;
          return O.call(this, Q), await S.call(this, Q.missingSchema), G.call(this, z);
        }
      }
      function O({ missingSchema: z, missingRef: Q }) {
        if (this.refs[z])
          throw new Error(`AnySchema ${z} is loaded but ${Q} cannot be resolved`);
      }
      async function S(z) {
        const Q = await W.call(this, z);
        this.refs[z] || await N.call(this, Q.$schema), this.refs[z] || this.addSchema(Q, z, U);
      }
      async function W(z) {
        const Q = this._loading[z];
        if (Q)
          return Q;
        try {
          return await (this._loading[z] = M(z));
        } finally {
          delete this._loading[z];
        }
      }
    }
    // Adds schema to the instance
    addSchema(k, U, M, T = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const G of k)
          this.addSchema(G, void 0, M, T);
        return this;
      }
      let N;
      if (typeof k == "object") {
        const { schemaId: G } = this.opts;
        if (N = k[G], N !== void 0 && typeof N != "string")
          throw new Error(`schema ${G} must be string`);
      }
      return U = (0, c.normalizeId)(U || N), this._checkUnique(U), this.schemas[U] = this._addSchema(k, M, U, T, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(k, U, M = this.opts.validateSchema) {
      return this.addSchema(k, U, !0, M), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(k, U) {
      if (typeof k == "boolean")
        return !0;
      let M;
      if (M = k.$schema, M !== void 0 && typeof M != "string")
        throw new Error("$schema must be a string");
      if (M = M || this.opts.defaultMeta || this.defaultMeta(), !M)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const T = this.validate(M, k);
      if (!T && U) {
        const N = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(N);
        else
          throw new Error(N);
      }
      return T;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(k) {
      let U;
      for (; typeof (U = w.call(this, k)) == "string"; )
        k = U;
      if (U === void 0) {
        const { schemaId: M } = this.opts, T = new o.SchemaEnv({ schema: {}, schemaId: M });
        if (U = o.resolveSchema.call(this, T, k), !U)
          return;
        this.refs[k] = U;
      }
      return U.validate || this._compileSchemaEnv(U);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(k) {
      if (k instanceof RegExp)
        return this._removeAllSchemas(this.schemas, k), this._removeAllSchemas(this.refs, k), this;
      switch (typeof k) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const U = w.call(this, k);
          return typeof U == "object" && this._cache.delete(U.schema), delete this.schemas[k], delete this.refs[k], this;
        }
        case "object": {
          const U = k;
          this._cache.delete(U);
          let M = k[this.opts.schemaId];
          return M && (M = (0, c.normalizeId)(M), delete this.schemas[M], delete this.refs[M]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(k) {
      for (const U of k)
        this.addKeyword(U);
      return this;
    }
    addKeyword(k, U) {
      let M;
      if (typeof k == "string")
        M = k, typeof U == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), U.keyword = M);
      else if (typeof k == "object" && U === void 0) {
        if (U = k, M = U.keyword, Array.isArray(M) && !M.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (x.call(this, M, U), !U)
        return (0, l.eachItem)(M, (N) => A.call(this, N)), this;
      D.call(this, U);
      const T = {
        ...U,
        type: (0, u.getJSONTypes)(U.type),
        schemaType: (0, u.getJSONTypes)(U.schemaType)
      };
      return (0, l.eachItem)(M, T.type.length === 0 ? (N) => A.call(this, N, T) : (N) => T.type.forEach((G) => A.call(this, N, T, G))), this;
    }
    getKeyword(k) {
      const U = this.RULES.all[k];
      return typeof U == "object" ? U.definition : !!U;
    }
    // Remove keyword
    removeKeyword(k) {
      const { RULES: U } = this;
      delete U.keywords[k], delete U.all[k];
      for (const M of U.rules) {
        const T = M.rules.findIndex((N) => N.keyword === k);
        T >= 0 && M.rules.splice(T, 1);
      }
      return this;
    }
    // Add format
    addFormat(k, U) {
      return typeof U == "string" && (U = new RegExp(U)), this.formats[k] = U, this;
    }
    errorsText(k = this.errors, { separator: U = ", ", dataVar: M = "data" } = {}) {
      return !k || k.length === 0 ? "No errors" : k.map((T) => `${M}${T.instancePath} ${T.message}`).reduce((T, N) => T + U + N);
    }
    $dataMetaSchema(k, U) {
      const M = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const T of U) {
        const N = T.split("/").slice(1);
        let G = k;
        for (const O of N)
          G = G[O];
        for (const O in M) {
          const S = M[O];
          if (typeof S != "object")
            continue;
          const { $data: W } = S.definition, z = G[O];
          W && z && (G[O] = L(z));
        }
      }
      return k;
    }
    _removeAllSchemas(k, U) {
      for (const M in k) {
        const T = k[M];
        (!U || U.test(M)) && (typeof T == "string" ? delete k[M] : T && !T.meta && (this._cache.delete(T.schema), delete k[M]));
      }
    }
    _addSchema(k, U, M, T = this.opts.validateSchema, N = this.opts.addUsedSchema) {
      let G;
      const { schemaId: O } = this.opts;
      if (typeof k == "object")
        G = k[O];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let S = this._cache.get(k);
      if (S !== void 0)
        return S;
      M = (0, c.normalizeId)(G || M);
      const W = c.getSchemaRefs.call(this, k, M);
      return S = new o.SchemaEnv({ schema: k, schemaId: O, meta: U, baseId: M, localRefs: W }), this._cache.set(S.schema, S), N && !M.startsWith("#") && (M && this._checkUnique(M), this.refs[M] = S), T && this.validateSchema(k, !0), S;
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (k.meta ? this._compileMetaSchema(k) : o.compileSchema.call(this, k), !k.validate)
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const U = this.opts;
      this.opts = this._metaOpts;
      try {
        o.compileSchema.call(this, k);
      } finally {
        this.opts = U;
      }
    }
  }
  E.ValidationError = n.default, E.MissingRefError = i.default, e.default = E;
  function R(j, k, U, M = "error") {
    for (const T in j) {
      const N = T;
      N in k && this.logger[M](`${U}: option ${T}. ${j[N]}`);
    }
  }
  function w(j) {
    return j = (0, c.normalizeId)(j), this.schemas[j] || this.refs[j];
  }
  function C() {
    const j = this.opts.schemas;
    if (j)
      if (Array.isArray(j))
        this.addSchema(j);
      else
        for (const k in j)
          this.addSchema(j[k], k);
  }
  function V() {
    for (const j in this.opts.formats) {
      const k = this.opts.formats[j];
      k && this.addFormat(j, k);
    }
  }
  function b(j) {
    if (Array.isArray(j)) {
      this.addVocabulary(j);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in j) {
      const U = j[k];
      U.keyword || (U.keyword = k), this.addKeyword(U);
    }
  }
  function F() {
    const j = { ...this.opts };
    for (const k of d)
      delete j[k];
    return j;
  }
  const H = { log() {
  }, warn() {
  }, error() {
  } };
  function q(j) {
    if (j === !1)
      return H;
    if (j === void 0)
      return console;
    if (j.log && j.warn && j.error)
      return j;
    throw new Error("logger must implement log, warn and error methods");
  }
  const $ = /^[a-z_$][a-z0-9_$:-]*$/i;
  function x(j, k) {
    const { RULES: U } = this;
    if ((0, l.eachItem)(j, (M) => {
      if (U.keywords[M])
        throw new Error(`Keyword ${M} is already defined`);
      if (!$.test(M))
        throw new Error(`Keyword ${M} has invalid name`);
    }), !!k && k.$data && !("code" in k || "validate" in k))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function A(j, k, U) {
    var M;
    const T = k == null ? void 0 : k.post;
    if (U && T)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: N } = this;
    let G = T ? N.post : N.rules.find(({ type: S }) => S === U);
    if (G || (G = { type: U, rules: [] }, N.rules.push(G)), N.keywords[j] = !0, !k)
      return;
    const O = {
      keyword: j,
      definition: {
        ...k,
        type: (0, u.getJSONTypes)(k.type),
        schemaType: (0, u.getJSONTypes)(k.schemaType)
      }
    };
    k.before ? P.call(this, G, O, k.before) : G.rules.push(O), N.all[j] = O, (M = k.implements) === null || M === void 0 || M.forEach((S) => this.addKeyword(S));
  }
  function P(j, k, U) {
    const M = j.rules.findIndex((T) => T.keyword === U);
    M >= 0 ? j.rules.splice(M, 0, k) : (j.rules.push(k), this.logger.warn(`rule ${U} is not defined`));
  }
  function D(j) {
    let { metaSchema: k } = j;
    k !== void 0 && (j.$data && this.opts.$data && (k = L(k)), j.validateSchema = this.compile(k, !0));
  }
  const I = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function L(j) {
    return { anyOf: [j, I] };
  }
})(Dm);
var Xm = {}, Zm = {}, Qm = {};
Object.defineProperty(Qm, "__esModule", { value: !0 });
const FF = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
Qm.default = FF;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.callRef = Zn.getValidate = void 0;
const jF = an, z0 = be, cr = he, ss = br, V0 = kt, Pc = se, UF = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: i, schemaEnv: s, validateName: o, opts: a, self: c } = n, { root: u } = s;
    if ((r === "#" || r === "#/") && i === u.baseId)
      return f();
    const l = V0.resolveRef.call(c, u, i, r);
    if (l === void 0)
      throw new jF.default(n.opts.uriResolver, i, r);
    if (l instanceof V0.SchemaEnv)
      return m(l);
    return p(l);
    function f() {
      if (s === u)
        return ml(e, o, s, s.$async);
      const d = t.scopeValue("root", { ref: u });
      return ml(e, (0, cr._)`${d}.validate`, u, u.$async);
    }
    function m(d) {
      const h = jR(e, d);
      ml(e, h, d, d.$async);
    }
    function p(d) {
      const h = t.scopeValue("schema", a.code.source === !0 ? { ref: d, code: (0, cr.stringify)(d) } : { ref: d }), _ = t.name("valid"), g = e.subschema({
        schema: d,
        dataTypes: [],
        schemaPath: cr.nil,
        topSchemaRef: h,
        errSchemaPath: r
      }, _);
      e.mergeEvaluated(g), e.ok(_);
    }
  }
};
function jR(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, cr._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
Zn.getValidate = jR;
function ml(e, t, r, n) {
  const { gen: i, it: s } = e, { allErrors: o, schemaEnv: a, opts: c } = s, u = c.passContext ? ss.default.this : cr.nil;
  n ? l() : f();
  function l() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const d = i.let("valid");
    i.try(() => {
      i.code((0, cr._)`await ${(0, z0.callValidateCode)(e, t, u)}`), p(t), o || i.assign(d, !0);
    }, (h) => {
      i.if((0, cr._)`!(${h} instanceof ${s.ValidationError})`, () => i.throw(h)), m(h), o || i.assign(d, !1);
    }), e.ok(d);
  }
  function f() {
    e.result((0, z0.callValidateCode)(e, t, u), () => p(t), () => m(t));
  }
  function m(d) {
    const h = (0, cr._)`${d}.errors`;
    i.assign(ss.default.vErrors, (0, cr._)`${ss.default.vErrors} === null ? ${h} : ${ss.default.vErrors}.concat(${h})`), i.assign(ss.default.errors, (0, cr._)`${ss.default.vErrors}.length`);
  }
  function p(d) {
    var h;
    if (!s.opts.unevaluated)
      return;
    const _ = (h = r == null ? void 0 : r.validate) === null || h === void 0 ? void 0 : h.evaluated;
    if (s.props !== !0)
      if (_ && !_.dynamicProps)
        _.props !== void 0 && (s.props = Pc.mergeEvaluated.props(i, _.props, s.props));
      else {
        const g = i.var("props", (0, cr._)`${d}.evaluated.props`);
        s.props = Pc.mergeEvaluated.props(i, g, s.props, cr.Name);
      }
    if (s.items !== !0)
      if (_ && !_.dynamicItems)
        _.items !== void 0 && (s.items = Pc.mergeEvaluated.items(i, _.items, s.items));
      else {
        const g = i.var("items", (0, cr._)`${d}.evaluated.items`);
        s.items = Pc.mergeEvaluated.items(i, g, s.items, cr.Name);
      }
  }
}
Zn.callRef = ml;
Zn.default = UF;
Object.defineProperty(Zm, "__esModule", { value: !0 });
const MF = Qm, HF = Zn, qF = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  MF.default,
  HF.default
];
Zm.default = qF;
var eg = {}, tg = {};
Object.defineProperty(tg, "__esModule", { value: !0 });
const ql = he, kn = ql.operators, Bl = {
  maximum: { okStr: "<=", ok: kn.LTE, fail: kn.GT },
  minimum: { okStr: ">=", ok: kn.GTE, fail: kn.LT },
  exclusiveMaximum: { okStr: "<", ok: kn.LT, fail: kn.GTE },
  exclusiveMinimum: { okStr: ">", ok: kn.GT, fail: kn.LTE }
}, BF = {
  message: ({ keyword: e, schemaCode: t }) => (0, ql.str)`must be ${Bl[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, ql._)`{comparison: ${Bl[e].okStr}, limit: ${t}}`
}, zF = {
  keyword: Object.keys(Bl),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: BF,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, ql._)`${r} ${Bl[t].fail} ${n} || isNaN(${r})`);
  }
};
tg.default = zF;
var rg = {};
Object.defineProperty(rg, "__esModule", { value: !0 });
const Jo = he, VF = {
  message: ({ schemaCode: e }) => (0, Jo.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, Jo._)`{multipleOf: ${e}}`
}, GF = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: VF,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: i } = e, s = i.opts.multipleOfPrecision, o = t.let("res"), a = s ? (0, Jo._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${s}` : (0, Jo._)`${o} !== parseInt(${o})`;
    e.fail$data((0, Jo._)`(${n} === 0 || (${o} = ${r}/${n}, ${a}))`);
  }
};
rg.default = GF;
var ng = {}, ig = {};
Object.defineProperty(ig, "__esModule", { value: !0 });
function UR(e) {
  const t = e.length;
  let r = 0, n = 0, i;
  for (; n < t; )
    r++, i = e.charCodeAt(n++), i >= 55296 && i <= 56319 && n < t && (i = e.charCodeAt(n), (i & 64512) === 56320 && n++);
  return r;
}
ig.default = UR;
UR.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(ng, "__esModule", { value: !0 });
const Ti = he, WF = se, KF = ig, YF = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, Ti.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, Ti._)`{limit: ${e}}`
}, JF = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: YF,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: i } = e, s = t === "maxLength" ? Ti.operators.GT : Ti.operators.LT, o = i.opts.unicode === !1 ? (0, Ti._)`${r}.length` : (0, Ti._)`${(0, WF.useFunc)(e.gen, KF.default)}(${r})`;
    e.fail$data((0, Ti._)`${o} ${s} ${n}`);
  }
};
ng.default = JF;
var sg = {};
Object.defineProperty(sg, "__esModule", { value: !0 });
const XF = be, zl = he, ZF = {
  message: ({ schemaCode: e }) => (0, zl.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, zl._)`{pattern: ${e}}`
}, QF = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: ZF,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: i, it: s } = e, o = s.opts.unicodeRegExp ? "u" : "", a = r ? (0, zl._)`(new RegExp(${i}, ${o}))` : (0, XF.usePattern)(e, n);
    e.fail$data((0, zl._)`!${a}.test(${t})`);
  }
};
sg.default = QF;
var og = {};
Object.defineProperty(og, "__esModule", { value: !0 });
const Xo = he, ej = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Xo.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Xo._)`{limit: ${e}}`
}, tj = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: ej,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxProperties" ? Xo.operators.GT : Xo.operators.LT;
    e.fail$data((0, Xo._)`Object.keys(${r}).length ${i} ${n}`);
  }
};
og.default = tj;
var ag = {};
Object.defineProperty(ag, "__esModule", { value: !0 });
const Ro = be, Zo = he, rj = se, nj = {
  message: ({ params: { missingProperty: e } }) => (0, Zo.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, Zo._)`{missingProperty: ${e}}`
}, ij = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: nj,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: i, $data: s, it: o } = e, { opts: a } = o;
    if (!s && r.length === 0)
      return;
    const c = r.length >= a.loopRequired;
    if (o.allErrors ? u() : l(), a.strictRequired) {
      const p = e.parentSchema.properties, { definedProperties: d } = e.it;
      for (const h of r)
        if ((p == null ? void 0 : p[h]) === void 0 && !d.has(h)) {
          const _ = o.schemaEnv.baseId + o.errSchemaPath, g = `required property "${h}" is not defined at "${_}" (strictRequired)`;
          (0, rj.checkStrictMode)(o, g, o.opts.strictRequired);
        }
    }
    function u() {
      if (c || s)
        e.block$data(Zo.nil, f);
      else
        for (const p of r)
          (0, Ro.checkReportMissingProp)(e, p);
    }
    function l() {
      const p = t.let("missing");
      if (c || s) {
        const d = t.let("valid", !0);
        e.block$data(d, () => m(p, d)), e.ok(d);
      } else
        t.if((0, Ro.checkMissingProp)(e, r, p)), (0, Ro.reportMissingProp)(e, p), t.else();
    }
    function f() {
      t.forOf("prop", n, (p) => {
        e.setParams({ missingProperty: p }), t.if((0, Ro.noPropertyInData)(t, i, p, a.ownProperties), () => e.error());
      });
    }
    function m(p, d) {
      e.setParams({ missingProperty: p }), t.forOf(p, n, () => {
        t.assign(d, (0, Ro.propertyInData)(t, i, p, a.ownProperties)), t.if((0, Zo.not)(d), () => {
          e.error(), t.break();
        });
      }, Zo.nil);
    }
  }
};
ag.default = ij;
var cg = {};
Object.defineProperty(cg, "__esModule", { value: !0 });
const Qo = he, sj = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, Qo.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, Qo._)`{limit: ${e}}`
}, oj = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: sj,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxItems" ? Qo.operators.GT : Qo.operators.LT;
    e.fail$data((0, Qo._)`${r}.length ${i} ${n}`);
  }
};
cg.default = oj;
var lg = {}, no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
const MR = Uu;
MR.code = 'require("ajv/dist/runtime/equal").default';
no.default = MR;
Object.defineProperty(lg, "__esModule", { value: !0 });
const Nd = yt, Pt = he, aj = se, cj = no, lj = {
  message: ({ params: { i: e, j: t } }) => (0, Pt.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, Pt._)`{i: ${e}, j: ${t}}`
}, uj = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: lj,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, parentSchema: s, schemaCode: o, it: a } = e;
    if (!n && !i)
      return;
    const c = t.let("valid"), u = s.items ? (0, Nd.getSchemaTypes)(s.items) : [];
    e.block$data(c, l, (0, Pt._)`${o} === false`), e.ok(c);
    function l() {
      const d = t.let("i", (0, Pt._)`${r}.length`), h = t.let("j");
      e.setParams({ i: d, j: h }), t.assign(c, !0), t.if((0, Pt._)`${d} > 1`, () => (f() ? m : p)(d, h));
    }
    function f() {
      return u.length > 0 && !u.some((d) => d === "object" || d === "array");
    }
    function m(d, h) {
      const _ = t.name("item"), g = (0, Nd.checkDataTypes)(u, _, a.opts.strictNumbers, Nd.DataType.Wrong), v = t.const("indices", (0, Pt._)`{}`);
      t.for((0, Pt._)`;${d}--;`, () => {
        t.let(_, (0, Pt._)`${r}[${d}]`), t.if(g, (0, Pt._)`continue`), u.length > 1 && t.if((0, Pt._)`typeof ${_} == "string"`, (0, Pt._)`${_} += "_"`), t.if((0, Pt._)`typeof ${v}[${_}] == "number"`, () => {
          t.assign(h, (0, Pt._)`${v}[${_}]`), e.error(), t.assign(c, !1).break();
        }).code((0, Pt._)`${v}[${_}] = ${d}`);
      });
    }
    function p(d, h) {
      const _ = (0, aj.useFunc)(t, cj.default), g = t.name("outer");
      t.label(g).for((0, Pt._)`;${d}--;`, () => t.for((0, Pt._)`${h} = ${d}; ${h}--;`, () => t.if((0, Pt._)`${_}(${r}[${d}], ${r}[${h}])`, () => {
        e.error(), t.assign(c, !1).break(g);
      })));
    }
  }
};
lg.default = uj;
var ug = {};
Object.defineProperty(ug, "__esModule", { value: !0 });
const wh = he, fj = se, dj = no, pj = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, wh._)`{allowedValue: ${e}}`
}, hj = {
  keyword: "const",
  $data: !0,
  error: pj,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: i, schema: s } = e;
    n || s && typeof s == "object" ? e.fail$data((0, wh._)`!${(0, fj.useFunc)(t, dj.default)}(${r}, ${i})`) : e.fail((0, wh._)`${s} !== ${r}`);
  }
};
ug.default = hj;
var fg = {};
Object.defineProperty(fg, "__esModule", { value: !0 });
const zo = he, mj = se, gj = no, yj = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, zo._)`{allowedValues: ${e}}`
}, vj = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: yj,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, schemaCode: s, it: o } = e;
    if (!n && i.length === 0)
      throw new Error("enum must have non-empty array");
    const a = i.length >= o.opts.loopEnum;
    let c;
    const u = () => c ?? (c = (0, mj.useFunc)(t, gj.default));
    let l;
    if (a || n)
      l = t.let("valid"), e.block$data(l, f);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const p = t.const("vSchema", s);
      l = (0, zo.or)(...i.map((d, h) => m(p, h)));
    }
    e.pass(l);
    function f() {
      t.assign(l, !1), t.forOf("v", s, (p) => t.if((0, zo._)`${u()}(${r}, ${p})`, () => t.assign(l, !0).break()));
    }
    function m(p, d) {
      const h = i[d];
      return typeof h == "object" && h !== null ? (0, zo._)`${u()}(${r}, ${p}[${d}])` : (0, zo._)`${r} === ${h}`;
    }
  }
};
fg.default = vj;
Object.defineProperty(eg, "__esModule", { value: !0 });
const _j = tg, bj = rg, Ej = ng, wj = sg, Sj = og, xj = ag, Rj = cg, $j = lg, Tj = ug, Oj = fg, Pj = [
  // number
  _j.default,
  bj.default,
  // string
  Ej.default,
  wj.default,
  // object
  Sj.default,
  xj.default,
  // array
  Rj.default,
  $j.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  Tj.default,
  Oj.default
];
eg.default = Pj;
var dg = {}, io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.validateAdditionalItems = void 0;
const Oi = he, Sh = se, Cj = {
  message: ({ params: { len: e } }) => (0, Oi.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, Oi._)`{limit: ${e}}`
}, Aj = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: Cj,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, Sh.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    HR(e, n);
  }
};
function HR(e, t) {
  const { gen: r, schema: n, data: i, keyword: s, it: o } = e;
  o.items = !0;
  const a = r.const("len", (0, Oi._)`${i}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, Oi._)`${a} <= ${t.length}`);
  else if (typeof n == "object" && !(0, Sh.alwaysValidSchema)(o, n)) {
    const u = r.var("valid", (0, Oi._)`${a} <= ${t.length}`);
    r.if((0, Oi.not)(u), () => c(u)), e.ok(u);
  }
  function c(u) {
    r.forRange("i", t.length, a, (l) => {
      e.subschema({ keyword: s, dataProp: l, dataPropType: Sh.Type.Num }, u), o.allErrors || r.if((0, Oi.not)(u), () => r.break());
    });
  }
}
io.validateAdditionalItems = HR;
io.default = Aj;
var pg = {}, so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
so.validateTuple = void 0;
const G0 = he, gl = se, Ij = be, Nj = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return qR(e, "additionalItems", t);
    r.items = !0, !(0, gl.alwaysValidSchema)(r, t) && e.ok((0, Ij.validateArray)(e));
  }
};
function qR(e, t, r = e.schema) {
  const { gen: n, parentSchema: i, data: s, keyword: o, it: a } = e;
  l(i), a.opts.unevaluated && r.length && a.items !== !0 && (a.items = gl.mergeEvaluated.items(n, r.length, a.items));
  const c = n.name("valid"), u = n.const("len", (0, G0._)`${s}.length`);
  r.forEach((f, m) => {
    (0, gl.alwaysValidSchema)(a, f) || (n.if((0, G0._)`${u} > ${m}`, () => e.subschema({
      keyword: o,
      schemaProp: m,
      dataProp: m
    }, c)), e.ok(c));
  });
  function l(f) {
    const { opts: m, errSchemaPath: p } = a, d = r.length, h = d === f.minItems && (d === f.maxItems || f[t] === !1);
    if (m.strictTuples && !h) {
      const _ = `"${o}" is ${d}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, gl.checkStrictMode)(a, _, m.strictTuples);
    }
  }
}
so.validateTuple = qR;
so.default = Nj;
Object.defineProperty(pg, "__esModule", { value: !0 });
const kj = so, Dj = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, kj.validateTuple)(e, "items")
};
pg.default = Dj;
var hg = {};
Object.defineProperty(hg, "__esModule", { value: !0 });
const W0 = he, Lj = se, Fj = be, jj = io, Uj = {
  message: ({ params: { len: e } }) => (0, W0.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, W0._)`{limit: ${e}}`
}, Mj = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: Uj,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: i } = r;
    n.items = !0, !(0, Lj.alwaysValidSchema)(n, t) && (i ? (0, jj.validateAdditionalItems)(e, i) : e.ok((0, Fj.validateArray)(e)));
  }
};
hg.default = Mj;
var mg = {};
Object.defineProperty(mg, "__esModule", { value: !0 });
const Tr = he, Cc = se, Hj = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Tr.str)`must contain at least ${e} valid item(s)` : (0, Tr.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Tr._)`{minContains: ${e}}` : (0, Tr._)`{minContains: ${e}, maxContains: ${t}}`
}, qj = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: Hj,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: s } = e;
    let o, a;
    const { minContains: c, maxContains: u } = n;
    s.opts.next ? (o = c === void 0 ? 1 : c, a = u) : o = 1;
    const l = t.const("len", (0, Tr._)`${i}.length`);
    if (e.setParams({ min: o, max: a }), a === void 0 && o === 0) {
      (0, Cc.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && o > a) {
      (0, Cc.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, Cc.alwaysValidSchema)(s, r)) {
      let h = (0, Tr._)`${l} >= ${o}`;
      a !== void 0 && (h = (0, Tr._)`${h} && ${l} <= ${a}`), e.pass(h);
      return;
    }
    s.items = !0;
    const f = t.name("valid");
    a === void 0 && o === 1 ? p(f, () => t.if(f, () => t.break())) : o === 0 ? (t.let(f, !0), a !== void 0 && t.if((0, Tr._)`${i}.length > 0`, m)) : (t.let(f, !1), m()), e.result(f, () => e.reset());
    function m() {
      const h = t.name("_valid"), _ = t.let("count", 0);
      p(h, () => t.if(h, () => d(_)));
    }
    function p(h, _) {
      t.forRange("i", 0, l, (g) => {
        e.subschema({
          keyword: "contains",
          dataProp: g,
          dataPropType: Cc.Type.Num,
          compositeRule: !0
        }, h), _();
      });
    }
    function d(h) {
      t.code((0, Tr._)`${h}++`), a === void 0 ? t.if((0, Tr._)`${h} >= ${o}`, () => t.assign(f, !0).break()) : (t.if((0, Tr._)`${h} > ${a}`, () => t.assign(f, !1).break()), o === 1 ? t.assign(f, !0) : t.if((0, Tr._)`${h} >= ${o}`, () => t.assign(f, !0)));
    }
  }
};
mg.default = qj;
var BR = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = he, r = se, n = be;
  e.error = {
    message: ({ params: { property: c, depsCount: u, deps: l } }) => {
      const f = u === 1 ? "property" : "properties";
      return (0, t.str)`must have ${f} ${l} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: u, deps: l, missingProperty: f } }) => (0, t._)`{property: ${c},
    missingProperty: ${f},
    depsCount: ${u},
    deps: ${l}}`
    // TODO change to reference
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [u, l] = s(c);
      o(c, u), a(c, l);
    }
  };
  function s({ schema: c }) {
    const u = {}, l = {};
    for (const f in c) {
      if (f === "__proto__")
        continue;
      const m = Array.isArray(c[f]) ? u : l;
      m[f] = c[f];
    }
    return [u, l];
  }
  function o(c, u = c.schema) {
    const { gen: l, data: f, it: m } = c;
    if (Object.keys(u).length === 0)
      return;
    const p = l.let("missing");
    for (const d in u) {
      const h = u[d];
      if (h.length === 0)
        continue;
      const _ = (0, n.propertyInData)(l, f, d, m.opts.ownProperties);
      c.setParams({
        property: d,
        depsCount: h.length,
        deps: h.join(", ")
      }), m.allErrors ? l.if(_, () => {
        for (const g of h)
          (0, n.checkReportMissingProp)(c, g);
      }) : (l.if((0, t._)`${_} && (${(0, n.checkMissingProp)(c, h, p)})`), (0, n.reportMissingProp)(c, p), l.else());
    }
  }
  e.validatePropertyDeps = o;
  function a(c, u = c.schema) {
    const { gen: l, data: f, keyword: m, it: p } = c, d = l.name("valid");
    for (const h in u)
      (0, r.alwaysValidSchema)(p, u[h]) || (l.if(
        (0, n.propertyInData)(l, f, h, p.opts.ownProperties),
        () => {
          const _ = c.subschema({ keyword: m, schemaProp: h }, d);
          c.mergeValidEvaluated(_, d);
        },
        () => l.var(d, !0)
        // TODO var
      ), c.ok(d));
  }
  e.validateSchemaDeps = a, e.default = i;
})(BR);
var gg = {};
Object.defineProperty(gg, "__esModule", { value: !0 });
const zR = he, Bj = se, zj = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, zR._)`{propertyName: ${e.propertyName}}`
}, Vj = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: zj,
  code(e) {
    const { gen: t, schema: r, data: n, it: i } = e;
    if ((0, Bj.alwaysValidSchema)(i, r))
      return;
    const s = t.name("valid");
    t.forIn("key", n, (o) => {
      e.setParams({ propertyName: o }), e.subschema({
        keyword: "propertyNames",
        data: o,
        dataTypes: ["string"],
        propertyName: o,
        compositeRule: !0
      }, s), t.if((0, zR.not)(s), () => {
        e.error(!0), i.allErrors || t.break();
      });
    }), e.ok(s);
  }
};
gg.default = Vj;
var Bu = {};
Object.defineProperty(Bu, "__esModule", { value: !0 });
const Ac = be, Fr = he, Gj = br, Ic = se, Wj = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, Fr._)`{additionalProperty: ${e.additionalProperty}}`
}, Kj = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: Wj,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, errsCount: s, it: o } = e;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: c } = o;
    if (o.props = !0, c.removeAdditional !== "all" && (0, Ic.alwaysValidSchema)(o, r))
      return;
    const u = (0, Ac.allSchemaProperties)(n.properties), l = (0, Ac.allSchemaProperties)(n.patternProperties);
    f(), e.ok((0, Fr._)`${s} === ${Gj.default.errors}`);
    function f() {
      t.forIn("key", i, (_) => {
        !u.length && !l.length ? d(_) : t.if(m(_), () => d(_));
      });
    }
    function m(_) {
      let g;
      if (u.length > 8) {
        const v = (0, Ic.schemaRefOrVal)(o, n.properties, "properties");
        g = (0, Ac.isOwnProperty)(t, v, _);
      } else u.length ? g = (0, Fr.or)(...u.map((v) => (0, Fr._)`${_} === ${v}`)) : g = Fr.nil;
      return l.length && (g = (0, Fr.or)(g, ...l.map((v) => (0, Fr._)`${(0, Ac.usePattern)(e, v)}.test(${_})`))), (0, Fr.not)(g);
    }
    function p(_) {
      t.code((0, Fr._)`delete ${i}[${_}]`);
    }
    function d(_) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        p(_);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: _ }), e.error(), a || t.break();
        return;
      }
      if (typeof r == "object" && !(0, Ic.alwaysValidSchema)(o, r)) {
        const g = t.name("valid");
        c.removeAdditional === "failing" ? (h(_, g, !1), t.if((0, Fr.not)(g), () => {
          e.reset(), p(_);
        })) : (h(_, g), a || t.if((0, Fr.not)(g), () => t.break()));
      }
    }
    function h(_, g, v) {
      const y = {
        keyword: "additionalProperties",
        dataProp: _,
        dataPropType: Ic.Type.Str
      };
      v === !1 && Object.assign(y, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema(y, g);
    }
  }
};
Bu.default = Kj;
var yg = {};
Object.defineProperty(yg, "__esModule", { value: !0 });
const Yj = Cr, K0 = be, kd = se, Y0 = Bu, Jj = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: s } = e;
    s.opts.removeAdditional === "all" && n.additionalProperties === void 0 && Y0.default.code(new Yj.KeywordCxt(s, Y0.default, "additionalProperties"));
    const o = (0, K0.allSchemaProperties)(r);
    for (const f of o)
      s.definedProperties.add(f);
    s.opts.unevaluated && o.length && s.props !== !0 && (s.props = kd.mergeEvaluated.props(t, (0, kd.toHash)(o), s.props));
    const a = o.filter((f) => !(0, kd.alwaysValidSchema)(s, r[f]));
    if (a.length === 0)
      return;
    const c = t.name("valid");
    for (const f of a)
      u(f) ? l(f) : (t.if((0, K0.propertyInData)(t, i, f, s.opts.ownProperties)), l(f), s.allErrors || t.else().var(c, !0), t.endIf()), e.it.definedProperties.add(f), e.ok(c);
    function u(f) {
      return s.opts.useDefaults && !s.compositeRule && r[f].default !== void 0;
    }
    function l(f) {
      e.subschema({
        keyword: "properties",
        schemaProp: f,
        dataProp: f
      }, c);
    }
  }
};
yg.default = Jj;
var vg = {};
Object.defineProperty(vg, "__esModule", { value: !0 });
const J0 = be, Nc = he, X0 = se, Z0 = se, Xj = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: n, parentSchema: i, it: s } = e, { opts: o } = s, a = (0, J0.allSchemaProperties)(r), c = a.filter((h) => (0, X0.alwaysValidSchema)(s, r[h]));
    if (a.length === 0 || c.length === a.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const u = o.strictSchema && !o.allowMatchingProperties && i.properties, l = t.name("valid");
    s.props !== !0 && !(s.props instanceof Nc.Name) && (s.props = (0, Z0.evaluatedPropsToName)(t, s.props));
    const { props: f } = s;
    m();
    function m() {
      for (const h of a)
        u && p(h), s.allErrors ? d(h) : (t.var(l, !0), d(h), t.if(l));
    }
    function p(h) {
      for (const _ in u)
        new RegExp(h).test(_) && (0, X0.checkStrictMode)(s, `property ${_} matches pattern ${h} (use allowMatchingProperties)`);
    }
    function d(h) {
      t.forIn("key", n, (_) => {
        t.if((0, Nc._)`${(0, J0.usePattern)(e, h)}.test(${_})`, () => {
          const g = c.includes(h);
          g || e.subschema({
            keyword: "patternProperties",
            schemaProp: h,
            dataProp: _,
            dataPropType: Z0.Type.Str
          }, l), s.opts.unevaluated && f !== !0 ? t.assign((0, Nc._)`${f}[${_}]`, !0) : !g && !s.allErrors && t.if((0, Nc.not)(l), () => t.break());
        });
      });
    }
  }
};
vg.default = Xj;
var _g = {};
Object.defineProperty(_g, "__esModule", { value: !0 });
const Zj = se, Qj = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if ((0, Zj.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const i = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, i), e.failResult(i, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
_g.default = Qj;
var bg = {};
Object.defineProperty(bg, "__esModule", { value: !0 });
const e2 = be, t2 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: e2.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
bg.default = t2;
var Eg = {};
Object.defineProperty(Eg, "__esModule", { value: !0 });
const yl = he, r2 = se, n2 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, yl._)`{passingSchemas: ${e.passing}}`
}, i2 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: n2,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && n.discriminator)
      return;
    const s = r, o = t.let("valid", !1), a = t.let("passing", null), c = t.name("_valid");
    e.setParams({ passing: a }), t.block(u), e.result(o, () => e.reset(), () => e.error(!0));
    function u() {
      s.forEach((l, f) => {
        let m;
        (0, r2.alwaysValidSchema)(i, l) ? t.var(c, !0) : m = e.subschema({
          keyword: "oneOf",
          schemaProp: f,
          compositeRule: !0
        }, c), f > 0 && t.if((0, yl._)`${c} && ${o}`).assign(o, !1).assign(a, (0, yl._)`[${a}, ${f}]`).else(), t.if(c, () => {
          t.assign(o, !0), t.assign(a, f), m && e.mergeEvaluated(m, yl.Name);
        });
      });
    }
  }
};
Eg.default = i2;
var wg = {};
Object.defineProperty(wg, "__esModule", { value: !0 });
const s2 = se, o2 = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const i = t.name("valid");
    r.forEach((s, o) => {
      if ((0, s2.alwaysValidSchema)(n, s))
        return;
      const a = e.subschema({ keyword: "allOf", schemaProp: o }, i);
      e.ok(i), e.mergeEvaluated(a);
    });
  }
};
wg.default = o2;
var Sg = {};
Object.defineProperty(Sg, "__esModule", { value: !0 });
const Vl = he, VR = se, a2 = {
  message: ({ params: e }) => (0, Vl.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, Vl._)`{failingKeyword: ${e.ifClause}}`
}, c2 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: a2,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, VR.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const i = Q0(n, "then"), s = Q0(n, "else");
    if (!i && !s)
      return;
    const o = t.let("valid", !0), a = t.name("_valid");
    if (c(), e.reset(), i && s) {
      const l = t.let("ifClause");
      e.setParams({ ifClause: l }), t.if(a, u("then", l), u("else", l));
    } else i ? t.if(a, u("then")) : t.if((0, Vl.not)(a), u("else"));
    e.pass(o, () => e.error(!0));
    function c() {
      const l = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, a);
      e.mergeEvaluated(l);
    }
    function u(l, f) {
      return () => {
        const m = e.subschema({ keyword: l }, a);
        t.assign(o, a), e.mergeValidEvaluated(m, o), f ? t.assign(f, (0, Vl._)`${l}`) : e.setParams({ ifClause: l });
      };
    }
  }
};
function Q0(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, VR.alwaysValidSchema)(e, r);
}
Sg.default = c2;
var xg = {};
Object.defineProperty(xg, "__esModule", { value: !0 });
const l2 = se, u2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, l2.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
xg.default = u2;
Object.defineProperty(dg, "__esModule", { value: !0 });
const f2 = io, d2 = pg, p2 = so, h2 = hg, m2 = mg, g2 = BR, y2 = gg, v2 = Bu, _2 = yg, b2 = vg, E2 = _g, w2 = bg, S2 = Eg, x2 = wg, R2 = Sg, $2 = xg;
function T2(e = !1) {
  const t = [
    // any
    E2.default,
    w2.default,
    S2.default,
    x2.default,
    R2.default,
    $2.default,
    // object
    y2.default,
    v2.default,
    g2.default,
    _2.default,
    b2.default
  ];
  return e ? t.push(d2.default, h2.default) : t.push(f2.default, p2.default), t.push(m2.default), t;
}
dg.default = T2;
var Rg = {}, $g = {};
Object.defineProperty($g, "__esModule", { value: !0 });
const ft = he, O2 = {
  message: ({ schemaCode: e }) => (0, ft.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, ft._)`{format: ${e}}`
}, P2 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: O2,
  code(e, t) {
    const { gen: r, data: n, $data: i, schema: s, schemaCode: o, it: a } = e, { opts: c, errSchemaPath: u, schemaEnv: l, self: f } = a;
    if (!c.validateFormats)
      return;
    i ? m() : p();
    function m() {
      const d = r.scopeValue("formats", {
        ref: f.formats,
        code: c.code.formats
      }), h = r.const("fDef", (0, ft._)`${d}[${o}]`), _ = r.let("fType"), g = r.let("format");
      r.if((0, ft._)`typeof ${h} == "object" && !(${h} instanceof RegExp)`, () => r.assign(_, (0, ft._)`${h}.type || "string"`).assign(g, (0, ft._)`${h}.validate`), () => r.assign(_, (0, ft._)`"string"`).assign(g, h)), e.fail$data((0, ft.or)(v(), y()));
      function v() {
        return c.strictSchema === !1 ? ft.nil : (0, ft._)`${o} && !${g}`;
      }
      function y() {
        const E = l.$async ? (0, ft._)`(${h}.async ? await ${g}(${n}) : ${g}(${n}))` : (0, ft._)`${g}(${n})`, R = (0, ft._)`(typeof ${g} == "function" ? ${E} : ${g}.test(${n}))`;
        return (0, ft._)`${g} && ${g} !== true && ${_} === ${t} && !${R}`;
      }
    }
    function p() {
      const d = f.formats[s];
      if (!d) {
        v();
        return;
      }
      if (d === !0)
        return;
      const [h, _, g] = y(d);
      h === t && e.pass(E());
      function v() {
        if (c.strictSchema === !1) {
          f.logger.warn(R());
          return;
        }
        throw new Error(R());
        function R() {
          return `unknown format "${s}" ignored in schema at path "${u}"`;
        }
      }
      function y(R) {
        const w = R instanceof RegExp ? (0, ft.regexpCode)(R) : c.code.formats ? (0, ft._)`${c.code.formats}${(0, ft.getProperty)(s)}` : void 0, C = r.scopeValue("formats", { key: s, ref: R, code: w });
        return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, ft._)`${C}.validate`] : ["string", R, C];
      }
      function E() {
        if (typeof d == "object" && !(d instanceof RegExp) && d.async) {
          if (!l.$async)
            throw new Error("async format in sync schema");
          return (0, ft._)`await ${g}(${n})`;
        }
        return typeof _ == "function" ? (0, ft._)`${g}(${n})` : (0, ft._)`${g}.test(${n})`;
      }
    }
  }
};
$g.default = P2;
Object.defineProperty(Rg, "__esModule", { value: !0 });
const C2 = $g, A2 = [C2.default];
Rg.default = A2;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.contentVocabulary = Bs.metadataVocabulary = void 0;
Bs.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Bs.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Xm, "__esModule", { value: !0 });
const I2 = Zm, N2 = eg, k2 = dg, D2 = Rg, e_ = Bs, L2 = [
  I2.default,
  N2.default,
  (0, k2.default)(),
  D2.default,
  e_.metadataVocabulary,
  e_.contentVocabulary
];
Xm.default = L2;
var Tg = {}, Va = {};
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.DiscrError = void 0;
var t_;
(function(e) {
  e.Tag = "tag", e.Mapping = "mapping";
})(t_ || (Va.DiscrError = t_ = {}));
Object.defineProperty(Tg, "__esModule", { value: !0 });
const _s = he, xh = Va, r_ = kt, F2 = an, j2 = se, U2 = {
  message: ({ params: { discrError: e, tagName: t } }) => e === xh.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, _s._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, M2 = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: U2,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: i, it: s } = e, { oneOf: o } = i;
    if (!s.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const a = n.propertyName;
    if (typeof a != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!o)
      throw new Error("discriminator: requires oneOf keyword");
    const c = t.let("valid", !1), u = t.const("tag", (0, _s._)`${r}${(0, _s.getProperty)(a)}`);
    t.if((0, _s._)`typeof ${u} == "string"`, () => l(), () => e.error(!1, { discrError: xh.DiscrError.Tag, tag: u, tagName: a })), e.ok(c);
    function l() {
      const p = m();
      t.if(!1);
      for (const d in p)
        t.elseIf((0, _s._)`${u} === ${d}`), t.assign(c, f(p[d]));
      t.else(), e.error(!1, { discrError: xh.DiscrError.Mapping, tag: u, tagName: a }), t.endIf();
    }
    function f(p) {
      const d = t.name("valid"), h = e.subschema({ keyword: "oneOf", schemaProp: p }, d);
      return e.mergeEvaluated(h, _s.Name), d;
    }
    function m() {
      var p;
      const d = {}, h = g(i);
      let _ = !0;
      for (let E = 0; E < o.length; E++) {
        let R = o[E];
        if (R != null && R.$ref && !(0, j2.schemaHasRulesButRef)(R, s.self.RULES)) {
          const C = R.$ref;
          if (R = r_.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, C), R instanceof r_.SchemaEnv && (R = R.schema), R === void 0)
            throw new F2.default(s.opts.uriResolver, s.baseId, C);
        }
        const w = (p = R == null ? void 0 : R.properties) === null || p === void 0 ? void 0 : p[a];
        if (typeof w != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        _ = _ && (h || g(R)), v(w, E);
      }
      if (!_)
        throw new Error(`discriminator: "${a}" must be required`);
      return d;
      function g({ required: E }) {
        return Array.isArray(E) && E.includes(a);
      }
      function v(E, R) {
        if (E.const)
          y(E.const, R);
        else if (E.enum)
          for (const w of E.enum)
            y(w, R);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function y(E, R) {
        if (typeof E != "string" || E in d)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        d[E] = R;
      }
    }
  }
};
Tg.default = M2;
const H2 = "http://json-schema.org/draft-07/schema#", q2 = "http://json-schema.org/draft-07/schema#", B2 = "Core schema meta-schema", z2 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, V2 = [
  "object",
  "boolean"
], G2 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, W2 = {
  $schema: H2,
  $id: q2,
  title: B2,
  definitions: z2,
  type: V2,
  properties: G2,
  default: !0
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const r = Dm, n = Xm, i = Tg, s = W2, o = ["/properties"], a = "http://json-schema.org/draft-07/schema";
  class c extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((d) => this.addVocabulary(d)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const d = this.opts.$data ? this.$dataMetaSchema(s, o) : s;
      this.addMetaSchema(d, a, !1), this.refs["http://json-schema.org/schema"] = a;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var u = Cr;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return u.KeywordCxt;
  } });
  var l = he;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var f = ro;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var m = an;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return m.default;
  } });
})(vh, vh.exports);
var Og = vh.exports, kc = { exports: {} }, zu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(H, q) {
    return { validate: H, compare: q };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(s, o),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(c(!0), u),
    "date-time": t(m(!0), p),
    "iso-time": t(c(), l),
    "iso-date-time": t(m(), d),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: g,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: F,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y,
    // signed 32 bit integer
    int32: { type: "number", validate: w },
    // signed 64 bit integer
    int64: { type: "number", validate: C },
    // C-type float
    float: { type: "number", validate: V },
    // C-type double
    double: { type: "number", validate: V },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, o),
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, u),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    "iso-time": t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, l),
    "iso-date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, d),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
  function r(H) {
    return H % 4 === 0 && (H % 100 !== 0 || H % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function s(H) {
    const q = n.exec(H);
    if (!q)
      return !1;
    const $ = +q[1], x = +q[2], A = +q[3];
    return x >= 1 && x <= 12 && A >= 1 && A <= (x === 2 && r($) ? 29 : i[x]);
  }
  function o(H, q) {
    if (H && q)
      return H > q ? 1 : H < q ? -1 : 0;
  }
  const a = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function c(H) {
    return function($) {
      const x = a.exec($);
      if (!x)
        return !1;
      const A = +x[1], P = +x[2], D = +x[3], I = x[4], L = x[5] === "-" ? -1 : 1, j = +(x[6] || 0), k = +(x[7] || 0);
      if (j > 23 || k > 59 || H && !I)
        return !1;
      if (A <= 23 && P <= 59 && D < 60)
        return !0;
      const U = P - k * L, M = A - j * L - (U < 0 ? 1 : 0);
      return (M === 23 || M === -1) && (U === 59 || U === -1) && D < 61;
    };
  }
  function u(H, q) {
    if (!(H && q))
      return;
    const $ = (/* @__PURE__ */ new Date("2020-01-01T" + H)).valueOf(), x = (/* @__PURE__ */ new Date("2020-01-01T" + q)).valueOf();
    if ($ && x)
      return $ - x;
  }
  function l(H, q) {
    if (!(H && q))
      return;
    const $ = a.exec(H), x = a.exec(q);
    if ($ && x)
      return H = $[1] + $[2] + $[3], q = x[1] + x[2] + x[3], H > q ? 1 : H < q ? -1 : 0;
  }
  const f = /t|\s/i;
  function m(H) {
    const q = c(H);
    return function(x) {
      const A = x.split(f);
      return A.length === 2 && s(A[0]) && q(A[1]);
    };
  }
  function p(H, q) {
    if (!(H && q))
      return;
    const $ = new Date(H).valueOf(), x = new Date(q).valueOf();
    if ($ && x)
      return $ - x;
  }
  function d(H, q) {
    if (!(H && q))
      return;
    const [$, x] = H.split(f), [A, P] = q.split(f), D = o($, A);
    if (D !== void 0)
      return D || u(x, P);
  }
  const h = /\/|:/, _ = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function g(H) {
    return h.test(H) && _.test(H);
  }
  const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(H) {
    return v.lastIndex = 0, v.test(H);
  }
  const E = -2147483648, R = 2 ** 31 - 1;
  function w(H) {
    return Number.isInteger(H) && H <= R && H >= E;
  }
  function C(H) {
    return Number.isInteger(H);
  }
  function V() {
    return !0;
  }
  const b = /[^\\]\\Z/;
  function F(H) {
    if (b.test(H))
      return !1;
    try {
      return new RegExp(H), !0;
    } catch {
      return !1;
    }
  }
})(zu);
var Dd = {}, n_;
function K2() {
  return n_ || (n_ = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = Og, r = he, n = r.operators, i = {
      formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
      formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
      formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
    }, s = {
      message: ({ keyword: a, schemaCode: c }) => (0, r.str)`should be ${i[a].okStr} ${c}`,
      params: ({ keyword: a, schemaCode: c }) => (0, r._)`{comparison: ${i[a].okStr}, limit: ${c}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(i),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: s,
      code(a) {
        const { gen: c, data: u, schemaCode: l, keyword: f, it: m } = a, { opts: p, self: d } = m;
        if (!p.validateFormats)
          return;
        const h = new t.KeywordCxt(m, d.RULES.all.format.definition, "format");
        h.$data ? _() : g();
        function _() {
          const y = c.scopeValue("formats", {
            ref: d.formats,
            code: p.code.formats
          }), E = c.const("fmt", (0, r._)`${y}[${h.schemaCode}]`);
          a.fail$data((0, r.or)((0, r._)`typeof ${E} != "object"`, (0, r._)`${E} instanceof RegExp`, (0, r._)`typeof ${E}.compare != "function"`, v(E)));
        }
        function g() {
          const y = h.schema, E = d.formats[y];
          if (!E || E === !0)
            return;
          if (typeof E != "object" || E instanceof RegExp || typeof E.compare != "function")
            throw new Error(`"${f}": format "${y}" does not define "compare" function`);
          const R = c.scopeValue("formats", {
            key: y,
            ref: E,
            code: p.code.formats ? (0, r._)`${p.code.formats}${(0, r.getProperty)(y)}` : void 0
          });
          a.fail$data(v(R));
        }
        function v(y) {
          return (0, r._)`${y}.compare(${u}, ${l}) ${i[f].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const o = (a) => (a.addKeyword(e.formatLimitDefinition), a);
    e.default = o;
  }(Dd)), Dd;
}
<<<<<<< HEAD
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$2.exports;
  hasRequiredDist$1 = 1;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const formats_1 = formats;
    const limit_1 = requireLimit();
    const codegen_12 = codegen;
    const fullName = new codegen_12.Name("fullFormats");
    const fastName = new codegen_12.Name("fastFormats");
    const formatsPlugin = (ajv2, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv2, opts, formats_1.fullFormats, fullName);
        return ajv2;
      }
      const [formats3, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv2, list, formats3, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv2);
      return ajv2;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats3 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats3[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv2, list, fs2, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = (0, codegen_12._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv2.addFormat(f, fs2[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  })(dist$2, dist$2.exports);
  return dist$2.exports;
}
const Ajv$1 = ajvExports;
const fastUri$1 = fastUriExports;
const ajvFormats = requireDist$1();
const clone$2 = rfdc_1({ proto: true });
let Validator$1 = class Validator {
  constructor(ajvOptions) {
    this.ajv = new Ajv$1({
      ...ajvOptions,
      strictSchema: false,
      validateSchema: false,
      allowUnionTypes: true,
      uriResolver: fastUri$1
    });
    ajvFormats(this.ajv);
    this.ajv.addKeyword({
=======
var i_;
function GR() {
  return i_ || (i_ = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const r = zu, n = K2(), i = he, s = new i.Name("fullFormats"), o = new i.Name("fastFormats"), a = (u, l = { keywords: !0 }) => {
      if (Array.isArray(l))
        return c(u, l, r.fullFormats, s), u;
      const [f, m] = l.mode === "fast" ? [r.fastFormats, o] : [r.fullFormats, s], p = l.formats || r.formatNames;
      return c(u, p, f, m), l.keywords && (0, n.default)(u), u;
    };
    a.get = (u, l = "full") => {
      const m = (l === "fast" ? r.fastFormats : r.fullFormats)[u];
      if (!m)
        throw new Error(`Unknown format "${u}"`);
      return m;
    };
    function c(u, l, f, m) {
      var p, d;
      (p = (d = u.opts.code).formats) !== null && p !== void 0 || (d.formats = (0, i._)`require("ajv-formats/dist/formats").${m}`);
      for (const h of l)
        u.addFormat(h, f[h]);
    }
    e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
  }(kc, kc.exports)), kc.exports;
}
const Y2 = Og, J2 = Jm, X2 = GR(), Z2 = _m({ proto: !0 });
let Q2 = class WR {
  constructor(t) {
    this.ajv = new Y2({
      ...t,
      strictSchema: !1,
      validateSchema: !1,
      allowUnionTypes: !0,
      uriResolver: J2
    }), X2(this.ajv), this.ajv.addKeyword({
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
      keyword: "fjs_type",
      type: "object",
      errors: !1,
      validate: (r, n) => n instanceof Date
    }), this._ajvSchemas = {}, this._ajvOptions = t || {};
  }
  addSchema(t, r) {
    let n = t.$id || r;
    if (t.$id !== void 0 && t.$id[0] === "#" && (n = r + t.$id), this.ajv.refs[n] === void 0 && this.ajv.schemas[n] === void 0) {
      const i = Z2(t);
      this.convertSchemaToAjvFormat(i), this.ajv.addSchema(i, n), this._ajvSchemas[n] = t;
    }
  }
  validate(t, r) {
    return this.ajv.validate(t, r);
  }
  // Ajv does not support js date format. In order to properly validate objects containing a date,
  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
  // (see https://github.com/fastify/fast-json-stringify/pull/441)
  convertSchemaToAjvFormat(t) {
    if (t !== null) {
      t.type === "string" ? (t.fjs_type = "string", t.type = ["string", "object"]) : Array.isArray(t.type) && t.type.includes("string") && !t.type.includes("object") && (t.fjs_type = "string", t.type.push("object"));
      for (const r in t)
        typeof t[r] == "object" && this.convertSchemaToAjvFormat(t[r]);
    }
  }
  getState() {
    return {
      ajvOptions: this._ajvOptions,
      ajvSchemas: this._ajvSchemas
    };
  }
  static restoreFromState(t) {
    const r = new WR(t.ajvOptions);
    for (const [n, i] of Object.entries(t.ajvSchemas))
      r.ajv.addSchema(i, n);
    return r;
  }
};
var KR = Q2;
let eU = class YR {
  constructor(t, r, n = "#") {
    this.schema = t, this.schemaId = r, this.jsonPointer = n;
  }
  getPropertyLocation(t) {
    return new YR(
      this.schema[t],
      this.schemaId,
      this.jsonPointer + "/" + t
    );
  }
  getSchemaRef() {
    return this.schemaId + this.jsonPointer;
  }
};
var tU = eU, Pg = { exports: {} };
Pg.exports = ne;
Pg.exports.default = ne;
const rU = { type: ["object", "boolean"] }, s_ = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, o_ = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, nU = zu.fullFormats.uri, a_ = zu.fullFormats.regex;
function $r(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  return typeof e == "number" && !(e % 1) && !isNaN(e) && isFinite(e) ? typeof e == "number" && isFinite(e) && (e < 0 || isNaN(e)) ? ($r.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1) : ($r.errors = s, o === 0) : ($r.errors = [{ instancePath: t, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1);
}
const Ld = { validate: ne };
function Zt(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (o === 0)
    if (Array.isArray(e)) {
      if (e.length < 1)
        return Zt.errors = [{ instancePath: t, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
      {
        var a = !0;
        const c = e.length;
        for (let u = 0; u < c; u++) {
          const l = o;
          Ld.validate(e[u], { instancePath: t + "/" + u, parentData: e, parentDataProperty: u, rootData: i }) || (s = s === null ? Ld.validate.errors : s.concat(Ld.validate.errors), o = s.length);
          var a = l === o;
          if (!a)
            break;
        }
      }
    } else
      return Zt.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
  return Zt.errors = s, o === 0;
}
const c_ = no.default;
function ne(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (!(e && typeof e == "object" && !Array.isArray(e)) && typeof e != "boolean")
    return ne.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: rU.type }, message: "must be object,boolean" }], !1;
  if (o === 0 && e && typeof e == "object" && !Array.isArray(e)) {
    if (e.$id !== void 0) {
      let y = e.$id;
      const E = o;
      if (o === E && o === E)
        if (typeof y == "string") {
          if (!o_.test(y))
            return ne.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
        } else
          return ne.errors = [{ instancePath: t + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
      var a = E === o;
    } else
      var a = !0;
    if (a) {
      if (e.$schema !== void 0) {
        let y = e.$schema;
        const E = o;
        if (o === E && o === E)
          if (typeof y == "string") {
            if (!nU(y))
              return ne.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }], !1;
          } else
            return ne.errors = [{ instancePath: t + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
        var a = E === o;
      } else
        var a = !0;
      if (a) {
        if (e.$ref !== void 0) {
          let y = e.$ref;
          const E = o;
          if (o === E && o === E)
            if (typeof y == "string") {
              if (!o_.test(y))
                return ne.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }], !1;
            } else
              return ne.errors = [{ instancePath: t + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
          var a = E === o;
        } else
          var a = !0;
        if (a) {
          if (e.$comment !== void 0) {
            const y = o;
            if (typeof e.$comment != "string")
              return ne.errors = [{ instancePath: t + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
            var a = y === o;
          } else
            var a = !0;
          if (a) {
            if (e.title !== void 0) {
              const y = o;
              if (typeof e.title != "string")
                return ne.errors = [{ instancePath: t + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
              var a = y === o;
            } else
              var a = !0;
            if (a) {
              if (e.description !== void 0) {
                const y = o;
                if (typeof e.description != "string")
                  return ne.errors = [{ instancePath: t + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                var a = y === o;
              } else
                var a = !0;
              if (a) {
                if (e.readOnly !== void 0) {
                  const y = o;
                  if (typeof e.readOnly != "boolean")
                    return ne.errors = [{ instancePath: t + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                  var a = y === o;
                } else
                  var a = !0;
                if (a) {
                  if (e.examples !== void 0) {
                    const y = o;
                    if (o === y && !Array.isArray(e.examples))
                      return ne.errors = [{ instancePath: t + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                    var a = y === o;
                  } else
                    var a = !0;
                  if (a) {
                    if (e.multipleOf !== void 0) {
                      let y = e.multipleOf;
                      const E = o;
                      if (o === E)
                        if (typeof y == "number" && isFinite(y)) {
                          if (y <= 0 || isNaN(y))
                            return ne.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }], !1;
                        } else
                          return ne.errors = [{ instancePath: t + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                      var a = E === o;
                    } else
                      var a = !0;
                    if (a) {
                      if (e.maximum !== void 0) {
                        let y = e.maximum;
                        const E = o;
                        if (!(typeof y == "number" && isFinite(y)))
                          return ne.errors = [{ instancePath: t + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                        var a = E === o;
                      } else
                        var a = !0;
                      if (a) {
                        if (e.exclusiveMaximum !== void 0) {
                          let y = e.exclusiveMaximum;
                          const E = o;
                          if (!(typeof y == "number" && isFinite(y)))
                            return ne.errors = [{ instancePath: t + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                          var a = E === o;
                        } else
                          var a = !0;
                        if (a) {
                          if (e.minimum !== void 0) {
                            let y = e.minimum;
                            const E = o;
                            if (!(typeof y == "number" && isFinite(y)))
                              return ne.errors = [{ instancePath: t + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                            var a = E === o;
                          } else
                            var a = !0;
                          if (a) {
                            if (e.exclusiveMinimum !== void 0) {
                              let y = e.exclusiveMinimum;
                              const E = o;
                              if (!(typeof y == "number" && isFinite(y)))
                                return ne.errors = [{ instancePath: t + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                              var a = E === o;
                            } else
                              var a = !0;
                            if (a) {
                              if (e.maxLength !== void 0) {
                                let y = e.maxLength;
                                const E = o, R = o;
                                if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                  return ne.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                  return ne.errors = [{ instancePath: t + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                var a = E === o;
                              } else
                                var a = !0;
                              if (a) {
                                if (e.minLength !== void 0) {
                                  const y = o;
                                  $r(e.minLength, { instancePath: t + "/minLength", parentData: e, parentDataProperty: "minLength", rootData: i }) || (s = s === null ? $r.errors : s.concat($r.errors), o = s.length);
                                  var a = y === o;
                                } else
                                  var a = !0;
                                if (a) {
                                  if (e.pattern !== void 0) {
                                    let y = e.pattern;
                                    const E = o;
                                    if (o === E && o === E)
                                      if (typeof y == "string") {
                                        if (!a_(y))
                                          return ne.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }], !1;
                                      } else
                                        return ne.errors = [{ instancePath: t + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                    var a = E === o;
                                  } else
                                    var a = !0;
                                  if (a) {
                                    if (e.additionalItems !== void 0) {
                                      const y = o;
                                      ne(e.additionalItems, { instancePath: t + "/additionalItems", parentData: e, parentDataProperty: "additionalItems", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                      var a = y === o;
                                    } else
                                      var a = !0;
                                    if (a) {
                                      if (e.items !== void 0) {
                                        let y = e.items;
                                        const E = o, R = o;
                                        let w = !1;
                                        const C = o;
                                        ne(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                        var c = C === o;
                                        if (w = w || c, !w) {
                                          const b = o;
                                          Zt(y, { instancePath: t + "/items", parentData: e, parentDataProperty: "items", rootData: i }) || (s = s === null ? Zt.errors : s.concat(Zt.errors), o = s.length);
                                          var c = b === o;
                                          w = w || c;
                                        }
                                        if (w)
                                          o = R, s !== null && (R ? s.length = R : s = null);
                                        else {
                                          const b = { instancePath: t + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                          return s === null ? s = [b] : s.push(b), o++, ne.errors = s, !1;
                                        }
                                        var a = E === o;
                                      } else
                                        var a = !0;
                                      if (a) {
                                        if (e.maxItems !== void 0) {
                                          let y = e.maxItems;
                                          const E = o, R = o;
                                          if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                            return ne.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                            return ne.errors = [{ instancePath: t + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                          var a = E === o;
                                        } else
                                          var a = !0;
                                        if (a) {
                                          if (e.minItems !== void 0) {
                                            const y = o;
                                            $r(e.minItems, { instancePath: t + "/minItems", parentData: e, parentDataProperty: "minItems", rootData: i }) || (s = s === null ? $r.errors : s.concat($r.errors), o = s.length);
                                            var a = y === o;
                                          } else
                                            var a = !0;
                                          if (a) {
                                            if (e.uniqueItems !== void 0) {
                                              const y = o;
                                              if (typeof e.uniqueItems != "boolean")
                                                return ne.errors = [{ instancePath: t + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                              var a = y === o;
                                            } else
                                              var a = !0;
                                            if (a) {
                                              if (e.contains !== void 0) {
                                                const y = o;
                                                ne(e.contains, { instancePath: t + "/contains", parentData: e, parentDataProperty: "contains", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                var a = y === o;
                                              } else
                                                var a = !0;
                                              if (a) {
                                                if (e.maxProperties !== void 0) {
                                                  let y = e.maxProperties;
                                                  const E = o, R = o;
                                                  if (!(typeof y == "number" && !(y % 1) && !isNaN(y) && isFinite(y)))
                                                    return ne.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                  if (o === R && typeof y == "number" && isFinite(y) && (y < 0 || isNaN(y)))
                                                    return ne.errors = [{ instancePath: t + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }], !1;
                                                  var a = E === o;
                                                } else
                                                  var a = !0;
                                                if (a) {
                                                  if (e.minProperties !== void 0) {
                                                    const y = o;
                                                    $r(e.minProperties, { instancePath: t + "/minProperties", parentData: e, parentDataProperty: "minProperties", rootData: i }) || (s = s === null ? $r.errors : s.concat($r.errors), o = s.length);
                                                    var a = y === o;
                                                  } else
                                                    var a = !0;
                                                  if (a) {
                                                    if (e.required !== void 0) {
                                                      let y = e.required;
                                                      const E = o;
                                                      if (o === o)
                                                        if (Array.isArray(y)) {
                                                          var u = !0;
                                                          const C = y.length;
                                                          for (let V = 0; V < C; V++) {
                                                            const b = o;
                                                            if (typeof y[V] != "string")
                                                              return ne.errors = [{ instancePath: t + "/required/" + V, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                            var u = b === o;
                                                            if (!u)
                                                              break;
                                                          }
                                                          if (u) {
                                                            let V = y.length, b;
                                                            if (V > 1) {
                                                              const F = {};
                                                              for (; V--; ) {
                                                                let H = y[V];
                                                                if (typeof H == "string") {
                                                                  if (typeof F[H] == "number")
                                                                    return b = F[H], ne.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: V, j: b }, message: "must NOT have duplicate items (items ## " + b + " and " + V + " are identical)" }], !1;
                                                                  F[H] = V;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        } else
                                                          return ne.errors = [{ instancePath: t + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                      var a = E === o;
                                                    } else
                                                      var a = !0;
                                                    if (a) {
                                                      if (e.additionalProperties !== void 0) {
                                                        const y = o;
                                                        ne(e.additionalProperties, { instancePath: t + "/additionalProperties", parentData: e, parentDataProperty: "additionalProperties", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                        var a = y === o;
                                                      } else
                                                        var a = !0;
                                                      if (a) {
                                                        if (e.definitions !== void 0) {
                                                          let y = e.definitions;
                                                          const E = o;
                                                          if (o === E)
                                                            if (y && typeof y == "object" && !Array.isArray(y))
                                                              for (const w in y) {
                                                                const C = o;
                                                                ne(y[w], { instancePath: t + "/definitions/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                var l = C === o;
                                                                if (!l)
                                                                  break;
                                                              }
                                                            else
                                                              return ne.errors = [{ instancePath: t + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                          var a = E === o;
                                                        } else
                                                          var a = !0;
                                                        if (a) {
                                                          if (e.properties !== void 0) {
                                                            let y = e.properties;
                                                            const E = o;
                                                            if (o === E)
                                                              if (y && typeof y == "object" && !Array.isArray(y))
                                                                for (const w in y) {
                                                                  const C = o;
                                                                  ne(y[w], { instancePath: t + "/properties/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                  var f = C === o;
                                                                  if (!f)
                                                                    break;
                                                                }
                                                              else
                                                                return ne.errors = [{ instancePath: t + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var a = E === o;
                                                          } else
                                                            var a = !0;
                                                          if (a) {
                                                            if (e.patternProperties !== void 0) {
                                                              let y = e.patternProperties;
                                                              const E = o;
                                                              if (o === E)
                                                                if (y && typeof y == "object" && !Array.isArray(y)) {
                                                                  for (const w in y) {
                                                                    const C = o;
                                                                    if (o === C && typeof w == "string" && !a_(w)) {
                                                                      const V = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: w };
                                                                      s === null ? s = [V] : s.push(V), o++;
                                                                    }
                                                                    var m = C === o;
                                                                    if (!m) {
                                                                      const V = { instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: w }, message: "property name must be valid" };
                                                                      return s === null ? s = [V] : s.push(V), o++, ne.errors = s, !1;
                                                                    }
                                                                  }
                                                                  if (m)
                                                                    for (const w in y) {
                                                                      const C = o;
                                                                      ne(y[w], { instancePath: t + "/patternProperties/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                      var p = C === o;
                                                                      if (!p)
                                                                        break;
                                                                    }
                                                                } else
                                                                  return ne.errors = [{ instancePath: t + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                              var a = E === o;
                                                            } else
                                                              var a = !0;
                                                            if (a) {
                                                              if (e.dependencies !== void 0) {
                                                                let y = e.dependencies;
                                                                const E = o;
                                                                if (o === E)
                                                                  if (y && typeof y == "object" && !Array.isArray(y))
                                                                    for (const w in y) {
                                                                      let C = y[w];
                                                                      const V = o, b = o;
                                                                      let F = !1;
                                                                      const H = o;
                                                                      ne(C, { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: y, parentDataProperty: w, rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                      var d = H === o;
                                                                      if (F = F || d, !F) {
                                                                        const q = o;
                                                                        if (o === o)
                                                                          if (Array.isArray(C)) {
                                                                            var h = !0;
                                                                            const A = C.length;
                                                                            for (let P = 0; P < A; P++) {
                                                                              const D = o;
                                                                              if (typeof C[P] != "string") {
                                                                                const L = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + P, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                s === null ? s = [L] : s.push(L), o++;
                                                                              }
                                                                              var h = D === o;
                                                                              if (!h)
                                                                                break;
                                                                            }
                                                                            if (h) {
                                                                              let P = C.length, D;
                                                                              if (P > 1) {
                                                                                const I = {};
                                                                                for (; P--; ) {
                                                                                  let L = C[P];
                                                                                  if (typeof L == "string") {
                                                                                    if (typeof I[L] == "number") {
                                                                                      D = I[L];
                                                                                      const j = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: P, j: D }, message: "must NOT have duplicate items (items ## " + D + " and " + P + " are identical)" };
                                                                                      s === null ? s = [j] : s.push(j), o++;
                                                                                      break;
                                                                                    }
                                                                                    I[L] = P;
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            const A = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            s === null ? s = [A] : s.push(A), o++;
                                                                          }
                                                                        var d = q === o;
                                                                        F = F || d;
                                                                      }
                                                                      if (F)
                                                                        o = b, s !== null && (b ? s.length = b : s = null);
                                                                      else {
                                                                        const q = { instancePath: t + "/dependencies/" + w.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return s === null ? s = [q] : s.push(q), o++, ne.errors = s, !1;
                                                                      }
                                                                      var _ = V === o;
                                                                      if (!_)
                                                                        break;
                                                                    }
                                                                  else
                                                                    return ne.errors = [{ instancePath: t + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                var a = E === o;
                                                              } else
                                                                var a = !0;
                                                              if (a) {
                                                                if (e.propertyNames !== void 0) {
                                                                  const y = o;
                                                                  ne(e.propertyNames, { instancePath: t + "/propertyNames", parentData: e, parentDataProperty: "propertyNames", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                  var a = y === o;
                                                                } else
                                                                  var a = !0;
                                                                if (a) {
                                                                  if (e.enum !== void 0) {
                                                                    let y = e.enum;
                                                                    const E = o;
                                                                    if (o === E)
                                                                      if (Array.isArray(y)) {
                                                                        if (y.length < 1)
                                                                          return ne.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }], !1;
                                                                        {
                                                                          let w = y.length, C;
                                                                          if (w > 1) {
                                                                            for (; w--; )
                                                                              for (C = w; C--; )
                                                                                if (c_(y[w], y[C]))
                                                                                  return ne.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: w, j: C }, message: "must NOT have duplicate items (items ## " + C + " and " + w + " are identical)" }], !1;
                                                                          }
                                                                        }
                                                                      } else
                                                                        return ne.errors = [{ instancePath: t + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                                    var a = E === o;
                                                                  } else
                                                                    var a = !0;
                                                                  if (a) {
                                                                    if (e.type !== void 0) {
                                                                      let y = e.type;
                                                                      const E = o, R = o;
                                                                      let w = !1;
                                                                      const C = o;
                                                                      if (!(y === "array" || y === "boolean" || y === "integer" || y === "null" || y === "number" || y === "object" || y === "string")) {
                                                                        const b = { instancePath: t + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: s_.enum }, message: "must be equal to one of the allowed values" };
                                                                        s === null ? s = [b] : s.push(b), o++;
                                                                      }
                                                                      var g = C === o;
                                                                      if (w = w || g, !w) {
                                                                        const b = o;
                                                                        if (o === b)
                                                                          if (Array.isArray(y))
                                                                            if (y.length < 1) {
                                                                              const H = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                              s === null ? s = [H] : s.push(H), o++;
                                                                            } else {
                                                                              var v = !0;
                                                                              const H = y.length;
                                                                              for (let q = 0; q < H; q++) {
                                                                                let $ = y[q];
                                                                                const x = o;
                                                                                if (!($ === "array" || $ === "boolean" || $ === "integer" || $ === "null" || $ === "number" || $ === "object" || $ === "string")) {
                                                                                  const P = { instancePath: t + "/type/" + q, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: s_.enum }, message: "must be equal to one of the allowed values" };
                                                                                  s === null ? s = [P] : s.push(P), o++;
                                                                                }
                                                                                var v = x === o;
                                                                                if (!v)
                                                                                  break;
                                                                              }
                                                                              if (v) {
                                                                                let q = y.length, $;
                                                                                if (q > 1) {
                                                                                  e:
                                                                                    for (; q--; )
                                                                                      for ($ = q; $--; )
                                                                                        if (c_(y[q], y[$])) {
                                                                                          const x = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: q, j: $ }, message: "must NOT have duplicate items (items ## " + $ + " and " + q + " are identical)" };
                                                                                          s === null ? s = [x] : s.push(x), o++;
                                                                                          break e;
                                                                                        }
                                                                                }
                                                                              }
                                                                            }
                                                                          else {
                                                                            const H = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                            s === null ? s = [H] : s.push(H), o++;
                                                                          }
                                                                        var g = b === o;
                                                                        w = w || g;
                                                                      }
                                                                      if (w)
                                                                        o = R, s !== null && (R ? s.length = R : s = null);
                                                                      else {
                                                                        const b = { instancePath: t + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                        return s === null ? s = [b] : s.push(b), o++, ne.errors = s, !1;
                                                                      }
                                                                      var a = E === o;
                                                                    } else
                                                                      var a = !0;
                                                                    if (a) {
                                                                      if (e.format !== void 0) {
                                                                        const y = o;
                                                                        if (typeof e.format != "string")
                                                                          return ne.errors = [{ instancePath: t + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                        var a = y === o;
                                                                      } else
                                                                        var a = !0;
                                                                      if (a) {
                                                                        if (e.contentMediaType !== void 0) {
                                                                          const y = o;
                                                                          if (typeof e.contentMediaType != "string")
                                                                            return ne.errors = [{ instancePath: t + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                          var a = y === o;
                                                                        } else
                                                                          var a = !0;
                                                                        if (a) {
                                                                          if (e.contentEncoding !== void 0) {
                                                                            const y = o;
                                                                            if (typeof e.contentEncoding != "string")
                                                                              return ne.errors = [{ instancePath: t + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                            var a = y === o;
                                                                          } else
                                                                            var a = !0;
                                                                          if (a) {
                                                                            if (e.if !== void 0) {
                                                                              const y = o;
                                                                              ne(e.if, { instancePath: t + "/if", parentData: e, parentDataProperty: "if", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                              var a = y === o;
                                                                            } else
                                                                              var a = !0;
                                                                            if (a) {
                                                                              if (e.then !== void 0) {
                                                                                const y = o;
                                                                                ne(e.then, { instancePath: t + "/then", parentData: e, parentDataProperty: "then", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                                var a = y === o;
                                                                              } else
                                                                                var a = !0;
                                                                              if (a) {
                                                                                if (e.else !== void 0) {
                                                                                  const y = o;
                                                                                  ne(e.else, { instancePath: t + "/else", parentData: e, parentDataProperty: "else", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                                  var a = y === o;
                                                                                } else
                                                                                  var a = !0;
                                                                                if (a) {
                                                                                  if (e.allOf !== void 0) {
                                                                                    const y = o;
                                                                                    Zt(e.allOf, { instancePath: t + "/allOf", parentData: e, parentDataProperty: "allOf", rootData: i }) || (s = s === null ? Zt.errors : s.concat(Zt.errors), o = s.length);
                                                                                    var a = y === o;
                                                                                  } else
                                                                                    var a = !0;
                                                                                  if (a) {
                                                                                    if (e.anyOf !== void 0) {
                                                                                      const y = o;
                                                                                      Zt(e.anyOf, { instancePath: t + "/anyOf", parentData: e, parentDataProperty: "anyOf", rootData: i }) || (s = s === null ? Zt.errors : s.concat(Zt.errors), o = s.length);
                                                                                      var a = y === o;
                                                                                    } else
                                                                                      var a = !0;
                                                                                    if (a) {
                                                                                      if (e.oneOf !== void 0) {
                                                                                        const y = o;
                                                                                        Zt(e.oneOf, { instancePath: t + "/oneOf", parentData: e, parentDataProperty: "oneOf", rootData: i }) || (s = s === null ? Zt.errors : s.concat(Zt.errors), o = s.length);
                                                                                        var a = y === o;
                                                                                      } else
                                                                                        var a = !0;
                                                                                      if (a)
                                                                                        if (e.not !== void 0) {
                                                                                          const y = o;
                                                                                          ne(e.not, { instancePath: t + "/not", parentData: e, parentDataProperty: "not", rootData: i }) || (s = s === null ? ne.errors : s.concat(ne.errors), o = s.length);
                                                                                          var a = y === o;
                                                                                        } else
                                                                                          var a = !0;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ne.errors = s, o === 0;
}
var iU = Pg.exports;
let sU = class extends Error {
  constructor(t, r) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Failed to merge "${t}" keyword schemas.`, this.schemas = r;
  }
};
class oU extends Error {
  constructor(t, r) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Resolver for "${t}" keyword not found.`, this.schemas = r;
  }
}
class aU extends Error {
  constructor(t) {
    super(), this.name = "JsonSchemaMergeError", this.code = "JSON_SCHEMA_MERGE_ERROR", this.message = `Invalid "onConflict" option: "${t}".`;
  }
}
var JR = {
  MergeError: sU,
  ResolverNotFoundError: oU,
  InvalidOnConflictOptionError: aU
};
const { dequal: cU } = Fu, { MergeError: Cg } = JR;
function XR(e) {
  let t = e[0];
  for (let r = 1; r < e.length; r++)
    t = t.filter(
      (n) => e[r].includes(n)
    );
  return t;
}
function lU(e, t, r) {
  const n = XR(t);
  if (n.length === 0)
    throw new Cg(e, t);
  r[e] = n;
}
function uU(e, t, r) {
  for (let i = 0; i < t.length; i++)
    Array.isArray(t[i]) || (t[i] = [t[i]]);
  const n = XR(t);
  if (n.length === 0)
    throw new Cg(e, t);
  n.length === 1 ? r[e] = n[0] : r[e] = n;
}
function fU(e, t, r) {
  const n = [];
  for (const i of t)
    for (const s of i)
      n.includes(s) || n.push(s);
  r[e] = n;
}
function dU(e, t, r) {
  r[e] = Math.min(...t);
}
function pU(e, t, r) {
  r[e] = Math.max(...t);
}
function hU(e, t, r) {
  const n = (a, c) => c ? n(c, a % c) : a, i = (a, c) => a * c / n(a, c);
  let s = 1;
  for (const a of t)
    for (; a * s % 1 !== 0; )
      s *= 10;
  let o = t[0] * s;
  for (const a of t)
    o = i(o, a * s);
  r[e] = o / s;
}
function mU(e, t, r) {
  const n = t[0];
  for (let i = 1; i < t.length; i++)
    if (!cU(t[i], n))
      throw new Cg(e, t);
  r[e] = n;
}
function gU() {
}
function yU(e, t, r) {
  for (const n of t)
    if (n === !1) {
      r[e] = !1;
      return;
    }
  r[e] = !0;
}
function vU(e, t, r) {
  for (const n of t)
    if (n === !0) {
      r[e] = !0;
      return;
    }
  r[e] = !1;
}
var _U = {
  arraysIntersection: lU,
  hybridArraysIntersection: uU,
  arraysUnion: fU,
  minNumber: dU,
  maxNumber: pU,
  commonMultiple: hU,
  allEqual: mU,
  booleanAnd: yU,
  booleanOr: vU,
  skip: gU
};
const { dequal: bU } = Fu, Xe = _U, Gl = JR, EU = {
  $id: Xe.skip,
  type: Xe.hybridArraysIntersection,
  enum: Xe.arraysIntersection,
  minLength: Xe.maxNumber,
  maxLength: Xe.minNumber,
  minimum: Xe.maxNumber,
  maximum: Xe.minNumber,
  multipleOf: Xe.commonMultiple,
  exclusiveMinimum: Xe.maxNumber,
  exclusiveMaximum: Xe.minNumber,
  minItems: Xe.maxNumber,
  maxItems: Xe.minNumber,
  maxProperties: Xe.minNumber,
  minProperties: Xe.maxNumber,
  const: Xe.allEqual,
  default: Xe.allEqual,
  format: Xe.allEqual,
  required: Xe.arraysUnion,
  properties: TU,
  patternProperties: Lc,
  additionalProperties: Dc,
  items: xU,
  additionalItems: RU,
  definitions: Lc,
  $defs: Lc,
  nullable: Xe.booleanAnd,
  oneOf: l_,
  anyOf: l_,
  allOf: Xe.arraysUnion,
  not: Dc,
  if: OU,
  then: Xe.skip,
  else: Xe.skip,
  dependencies: u_,
  dependentRequired: u_,
  dependentSchemas: Lc,
  propertyNames: Dc,
  uniqueItems: Xe.booleanOr,
  contains: Dc
};
function Dc(e, t, r, n, i) {
  r[e] = Hr(t, i);
}
function wU(e) {
  let t = [[]];
  for (const r of e) {
    const n = [];
    for (const i of t)
      for (const s of r)
        n.push([...i, s]);
    t = n;
  }
  return t;
}
function l_(e, t, r, n, i) {
  if (t.length === 1) {
    r[e] = t[0];
    return;
  }
  const s = wU(t), o = [];
  for (const a of s)
    try {
      const c = Hr(a, i);
      c !== void 0 && o.push(c);
    } catch (c) {
      if (c instanceof Gl.MergeError) continue;
      throw c;
    }
  r[e] = o;
}
function SU(e, t) {
  const { items: r, additionalItems: n } = e;
  return Array.isArray(r) ? t < r.length ? r[t] : n : r !== void 0 ? r : n;
}
function xU(e, t, r, n, i) {
  let s = 0;
  for (const a of t)
    Array.isArray(a) && (s = Math.max(s, a.length));
  if (s === 0) {
    r[e] = Hr(t, i);
    return;
  }
  const o = [];
  for (let a = 0; a < s; a++) {
    const c = [];
    for (const u of n) {
      const l = SU(u, a);
      l !== void 0 && c.push(l);
    }
    o[a] = Hr(c, i);
  }
  r[e] = o;
}
function RU(e, t, r, n, i) {
  let s = !1;
  for (const a of n)
    if (Array.isArray(a.items)) {
      s = !0;
      break;
    }
  if (!s) {
    r[e] = Hr(t, i);
    return;
  }
  const o = [];
  for (const a of n) {
    let c = a.additionalItems;
    c === void 0 && !Array.isArray(a.items) && (c = a.items), c !== void 0 && o.push(c);
  }
  r[e] = Hr(o, i);
}
function $U(e, t) {
  const { properties: r, patternProperties: n, additionalProperties: i } = e;
  if ((r == null ? void 0 : r[t]) !== void 0)
    return r[t];
  for (const s of Object.keys(n ?? {}))
    if (new RegExp(s).test(t))
      return n[s];
  return i;
}
function TU(e, t, r, n, i) {
  const s = {};
  for (const a of n) {
    const c = a.properties ?? {};
    for (const u of Object.keys(c)) {
      if (s[u] !== void 0) continue;
      const l = c[u];
      s[u] = [l];
      for (const f of n) {
        if (a === f) continue;
        const m = $U(f, u);
        m !== void 0 && s[u].push(m);
      }
    }
  }
  const o = {};
  for (const a of Object.keys(s)) {
    const c = s[a];
    o[a] = Hr(c, i);
  }
  r[e] = o;
}
function Lc(e, t, r, n, i) {
  const s = {};
  for (const a of t)
    for (const c of Object.keys(a))
      s[c] === void 0 && (s[c] = []), s[c].push(a[c]);
  const o = {};
  for (const a of Object.keys(s)) {
    const c = s[a], u = Hr(c, i);
    o[a] = u;
  }
  r[e] = o;
}
function OU(e, t, r, n, i) {
  for (let s = 0; s < n.length; s++) {
    const o = {
      if: n[s].if,
      then: n[s].then,
      else: n[s].else
    };
    if (o.if !== void 0) {
      if (r.if === void 0) {
        r.if = o.if, o.then !== void 0 && (r.then = o.then), o.else !== void 0 && (r.else = o.else);
        continue;
      }
      r.then !== void 0 && (r.then = Hr([r.then, o], i)), r.else !== void 0 && (r.else = Hr([r.else, o], i));
    }
  }
}
function u_(e, t, r) {
  const n = {};
  for (const i of t)
    for (const s of Object.keys(i)) {
      n[s] === void 0 && (n[s] = []);
      const o = n[s];
      for (const a of i[s])
        o.includes(a) || o.push(a);
    }
  r[e] = n;
}
function Hr(e, t) {
  if (e.length === 0) return {};
  if (e.length === 1) return e[0];
  const r = {}, n = {};
  let i = !0;
  for (const s of e) {
    if (s === !1) return !1;
    if (s !== !0) {
      i = !1;
      for (const o of Object.keys(s))
        n[o] === void 0 && (n[o] = []), n[o].push(s[o]);
    }
  }
  if (i) return !0;
  for (const s of Object.keys(n)) {
    const o = n[s];
    (t.resolvers[s] ?? t.defaultResolver)(s, o, r, e, t);
  }
  return r;
}
function PU(e, t, r, n, i) {
  const s = i.onConflict ?? "throw";
  if (t.length === 1 || s === "first") {
    r[e] = t[0];
    return;
  }
  let o = !0;
  for (let a = 1; a < t.length; a++)
    if (!bU(t[a], t[0])) {
      o = !1;
      break;
    }
  if (o) {
    r[e] = t[0];
    return;
  }
  if (s === "throw")
    throw new Gl.ResolverNotFoundError(e, t);
  if (s !== "skip")
    throw new Gl.InvalidOnConflictOptionError(s);
}
function CU(e, t = {}) {
  return t.defaultResolver === void 0 && (t.defaultResolver = PU), t.resolvers = { ...EU, ...t.resolvers }, Hr(e, t);
}
var AU = { mergeSchemas: CU, ...Gl };
const { mergeSchemas: IU } = AU;
function NU(e) {
  return IU(e, { onConflict: "skip" });
}
var kU = NU, Fc = { exports: {} }, f_;
function DU() {
  if (f_) return Fc.exports;
  f_ = 1;
  function e(t, r, n, i) {
    let s = "";
    r.validatorSchemasIds.size > 0 ? (s += `const Validator = require('fast-json-stringify/lib/validator')
`, s += `const validatorState = ${JSON.stringify(i.getState())}
`, s += `const validator = Validator.restoreFromState(validatorState)
`) : s += `const validator = null
`;
    const { schema: o, ...a } = n.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(a)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${s}

  module.exports = ${t.toString()}(validator, serializer)`;
  }
  return Fc.exports = e, Fc.exports.dependencies = {
    Serializer: bm,
    Validator: KR
  }, Fc.exports;
}
const { RefResolver: LU } = iD, FU = bm, jU = KR, Ji = tU, d_ = iU, UU = kU, MU = /'/g;
let vl = 2e4, ZR = "default";
const HU = [
  "floor",
  "ceil",
  "round",
  "trunc"
], QR = [
  "default",
  "json-stringify"
];
let oa = 0;
function Rh(e, t) {
  if (!d_(e)) {
    t ? t = `"${t}" ` : t = "";
    const r = d_.errors[0], n = new Error(`${t}schema is invalid: data${r.instancePath} ${r.message}`);
    throw n.errors = Rh.errors, n;
  }
}
function Ga(e, t) {
  const r = t.schema.$ref;
  let n = r.indexOf("#");
  n === -1 && (n = r.length);
  const i = r.slice(0, n) || t.schemaId, s = r.slice(n) || "#", o = e.refResolver.getSchema(i, s);
  if (o === null)
    throw new Error(`Cannot find reference "${r}"`);
  const a = new Ji(o, i, s);
  return o.$ref !== void 0 ? Ga(e, a) : a;
}
function Wl(e, t) {
  const r = e.refResolver.getSchema(t, "#");
  return new Ji(r, t, "#");
}
function p_(e, t) {
  return e.$id && e.$id.charAt(0) !== "#" ? e.$id : t;
}
function Ag(e, t) {
  Rh(e), t = t || {};
  const r = {
    functions: [],
    functionsCounter: 0,
    functionsNamesBySchema: /* @__PURE__ */ new Map(),
    options: t,
    refResolver: new LU(),
    rootSchemaId: e.$id || `__fjs_root_${oa++}`,
    validatorSchemasIds: /* @__PURE__ */ new Set(),
    mergedSchemasIds: /* @__PURE__ */ new Map()
  }, n = p_(e, r.rootSchemaId);
  if (r.refResolver.hasSchema(n) || r.refResolver.addSchema(e, r.rootSchemaId), t.schema)
    for (const l in t.schema) {
      const f = t.schema[l], m = p_(f, l);
      r.refResolver.hasSchema(m) || (Rh(f, l), r.refResolver.addSchema(f, l));
    }
  if (t.rounding && !HU.includes(t.rounding))
    throw new Error(`Unsupported integer rounding method ${t.rounding}`);
  if (t.largeArrayMechanism)
    if (QR.includes(t.largeArrayMechanism))
      ZR = t.largeArrayMechanism;
    else
      throw new Error(`Unsupported large array mechanism ${t.largeArrayMechanism}`);
  if (t.largeArraySize)
    if (typeof t.largeArraySize == "string" && Number.isFinite(Number.parseInt(t.largeArraySize, 10)))
      vl = Number.parseInt(t.largeArraySize, 10);
    else if (typeof t.largeArraySize == "number" && Number.isInteger(t.largeArraySize))
      vl = t.largeArraySize;
    else if (typeof t.largeArraySize == "bigint")
      vl = Number(t.largeArraySize);
    else
      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof t.largeArraySize} with value ${t.largeArraySize}`);
  const i = new Ji(e, r.rootSchemaId), s = vr(r, i, "input");
  let o = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
  s === "json += anonymous0(input)" ? o += `
    ${r.functions.join(`
`)}
    const main = anonymous0
    return main
    ` : o += `
    function main (input) {
      let json = ''
      ${s}
      return json
    }
    ${r.functions.join(`
`)}
    return main
    `;
  const a = new FU(t), c = new jU(t.ajv);
  for (const l of r.validatorSchemasIds) {
    const f = r.refResolver.getSchema(l);
    c.addSchema(f, l);
    const m = r.refResolver.getSchemaDependencies(l);
    for (const [p, d] of Object.entries(m))
      c.addSchema(d, p);
  }
  if (t.debugMode && (t.mode = "debug"), t.mode === "debug")
    return {
      validator: c,
      serializer: a,
      code: `validator
serializer
${o}`,
      ajv: c.ajv
    };
  const u = new Function("validator", "serializer", o);
  return t.mode === "standalone" ? DU()(u, r, a, c) : u(c, a);
}
const qU = [
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "maxProperties",
  "minProperties",
  "dependencies"
], BU = [
  "items",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "contains"
], zU = [
  "maxLength",
  "minLength",
  "pattern"
], VU = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum"
];
function GU(e) {
  for (const t of qU)
    if (t in e) return "object";
  for (const t of BU)
    if (t in e) return "array";
  for (const t of zU)
    if (t in e) return "string";
  for (const t of VU)
    if (t in e) return "number";
  return e.type;
}
function WU(e, t, r) {
  const n = t.schema, i = Object.keys(n.properties || {});
  let s = `
    const propertiesKeys = ${JSON.stringify(i)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
  const o = t.getPropertyLocation("patternProperties"), a = o.schema;
  if (a !== void 0)
    for (const l in a) {
      const f = o.getPropertyLocation(l);
      s += `
        if (/${l.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${r}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${vr(e, f, "value")}
          continue
        }
      `;
    }
  const u = t.getPropertyLocation("additionalProperties").schema;
  if (u !== void 0)
    if (u === !0)
      s += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
    else {
      const l = t.getPropertyLocation("additionalProperties");
      s += `
        ${r}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${vr(e, l, "value")}
      `;
    }
  return s += `
    }
  `, s;
}
function KU(e, t) {
  const r = t.schema, n = t.getPropertyLocation("properties"), i = r.required || [], s = Object.keys(r.properties || {}).sort(
    (u, l) => {
      const f = i.includes(u), m = i.includes(l);
      return f === m ? 0 : f ? -1 : 1;
    }
  ), o = i.includes(s[0]);
  let a = `let value
`;
  for (const u of i)
    if (!s.includes(u)) {
      const l = JSON.stringify(u);
      a += `if (obj[${l}] === undefined) throw new Error('${l.replace(/'/g, "\\'")} is required!')
`;
    }
  a += `let json = JSON_STR_BEGIN_OBJECT
`;
  let c = "";
  o || (a += `let addComma = false
`, c = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)");
  for (const u of s) {
    let l = n.getPropertyLocation(u);
    l.schema.$ref && (l = Ga(e, l));
    const f = JSON.stringify(u), m = l.schema.default, p = i.includes(u);
    a += `
      value = obj[${f}]
      if (value !== undefined) {
        ${c}
        json += ${JSON.stringify(f + ":")}
        ${vr(e, l, "value")}
      }`, m !== void 0 ? a += ` else {
        ${c}
        json += ${JSON.stringify(f + ":" + JSON.stringify(m))}
      }
      ` : p ? a += ` else {
        throw new Error('${f.replace(/'/g, "\\'")} is required!')
      }
      ` : a += `
`, o && (c = "json += ','");
  }
  return (r.patternProperties || r.additionalProperties) && (a += WU(e, t, c)), a += `
    return json + JSON_STR_END_OBJECT
  `, a;
}
function Kl(e, t, r) {
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    a.schema.$ref && (r[o] = Ga(e, a));
  }
  const n = [];
  for (const o of r) {
    const a = e$(e, o.schema, o.schemaId);
    delete a.$id, n.push(a);
  }
  const i = UU(n), s = new Ji(i, t);
  return e.refResolver.addSchema(i, t), s;
}
function e$(e, t, r) {
  const n = Array.isArray(t) ? [] : {};
  t.$id !== void 0 && t.$id.charAt(0) !== "#" && (r = t.$id);
  const i = e.mergedSchemasIds.get(t);
  i && e.mergedSchemasIds.set(n, i);
  for (const s in t) {
    let o = t[s];
    s === "$ref" && typeof o == "string" && o.charAt(0) === "#" && (o = r + o), typeof o == "object" && o !== null && (o = e$(e, o, r)), n[s] = o;
  }
  return n;
}
function YU(e) {
  return `(${e} && typeof ${e}.toJSON === 'function')
    ? ${e}.toJSON()
    : ${e}
  `;
}
function JU(e, t) {
  const r = t.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const n = r$(e);
  e.functionsNamesBySchema.set(r, n);
  let i = t.getSchemaRef();
  i.startsWith(e.rootSchemaId) && (i = i.replace(e.rootSchemaId, ""));
  let s = `
  `;
  const o = r.nullable === !0;
  return s += `
    // ${i}
    function ${n} (input) {
      const obj = ${YU("input")}
      ${o ? "" : "if (obj === null) return JSON_STR_EMPTY_OBJECT"}

      ${KU(e, t)}
    }
  `, e.functions.push(s), n;
}
function XU(e, t) {
  const r = t.schema;
  let n = t.getPropertyLocation("items");
  n.schema = n.schema || {}, n.schema.$ref && (n = Ga(e, n));
  const i = n.schema;
  if (e.functionsNamesBySchema.has(r))
    return e.functionsNamesBySchema.get(r);
  const s = r$(e);
  e.functionsNamesBySchema.set(r, s);
  let o = t.getSchemaRef();
  o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, ""));
  let a = `
    function ${s} (obj) {
      // ${o}
  `;
  const c = r.nullable === !0;
  if (a += `
    ${c ? "" : "if (obj === null) return JSON_STR_EMPTY_ARRAY"}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `, !r.additionalItems && Array.isArray(i) && (a += `
      if (arrayLength > ${i.length}) {
        throw new Error(\`Item at ${i.length} does not match schema definition.\`)
      }
    `), ZR === "json-stringify" && (a += `if (arrayLength >= ${vl}) return JSON.stringify(obj)
`), a += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `, Array.isArray(i)) {
    for (let u = 0; u < i.length; u++) {
      const l = i[u];
      a += `value = obj[${u}]`;
      const f = vr(e, n.getPropertyLocation(u), "value");
      a += `
        if (${u} < arrayLength) {
          if (${t$(l.type)}) {
            ${f}
            if (${u} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${u} does not match schema definition.\`)
          }
        }
        `;
    }
    r.additionalItems && (a += `
        for (let i = ${i.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`);
  } else {
    const u = vr(e, n, "obj[i]");
    a += `
      for (let i = 0; i < arrayLength; i++) {
        ${u}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
  }
  return a += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`, e.functions.push(a), s;
}
function t$(e, t) {
  let r;
  switch (e) {
    case "null":
      r = "value === null";
      break;
    case "string":
      r = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
      break;
    case "integer":
      r = "Number.isInteger(value)";
      break;
    case "number":
      r = "Number.isFinite(value)";
      break;
    case "boolean":
      r = "typeof value === 'boolean'";
      break;
    case "object":
      r = "value && typeof value === 'object' && value.constructor === Object";
      break;
    case "array":
      r = "Array.isArray(value)";
      break;
    default:
      Array.isArray(e) && (r = `(${e.map((i) => t$(i)).join(" || ")})`);
  }
  return r;
}
function r$(e) {
  return "anonymous" + e.functionsCounter++;
}
function ZU(e, t, r) {
  const i = t.schema.type.sort((a) => a === "null" ? -1 : 1);
  let s = "";
  i.forEach((a, c) => {
    t.schema = { ...t.schema, type: a };
    const u = n$(e, t, r), l = c === 0 ? "if" : "else if";
    switch (a) {
      case "null":
        s += `
          ${l} (${r} === null)
            ${u}
          `;
        break;
      case "string": {
        s += `
          ${l}(
            typeof ${r} === "string" ||
            ${r} === null ||
            ${r} instanceof Date ||
            ${r} instanceof RegExp ||
            (
              typeof ${r} === "object" &&
              typeof ${r}.toString === "function" &&
              ${r}.toString !== Object.prototype.toString
            )
          )
            ${u}
        `;
        break;
      }
      case "array": {
        s += `
          ${l}(Array.isArray(${r}))
            ${u}
        `;
        break;
      }
      case "integer": {
        s += `
          ${l}(Number.isInteger(${r}) || ${r} === null)
            ${u}
        `;
        break;
      }
      default: {
        s += `
          ${l}(typeof ${r} === "${a}" || ${r} === null)
            ${u}
        `;
        break;
      }
    }
  });
  let o = t.getSchemaRef();
  return o.startsWith(e.rootSchemaId) && (o = o.replace(e.rootSchemaId, "")), s += `
    else throw new TypeError(\`The value of '${o}' does not match schema definition.\`)
  `, s;
}
function n$(e, t, r) {
  const n = t.schema;
  switch (n.type) {
    case "null":
      return "json += JSON_STR_NULL";
    case "string":
      return n.format === "date-time" ? `json += serializer.asDateTime(${r})` : n.format === "date" ? `json += serializer.asDate(${r})` : n.format === "time" ? `json += serializer.asTime(${r})` : n.format === "unsafe" ? `json += serializer.asUnsafeString(${r})` : `
        if (typeof ${r} !== 'string') {
          if (${r} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${r} instanceof Date) {
            json += JSON_STR_QUOTE + ${r}.toISOString() + JSON_STR_QUOTE
          } else if (${r} instanceof RegExp) {
            json += serializer.asString(${r}.source)
          } else {
            json += serializer.asString(${r}.toString())
          }
        } else {
          json += serializer.asString(${r})
        }
        `;
    case "integer":
      return `json += serializer.asInteger(${r})`;
    case "number":
      return `json += serializer.asNumber(${r})`;
    case "boolean":
      return `json += serializer.asBoolean(${r})`;
    case "object":
      return `json += ${JU(e, t)}(${r})`;
    case "array":
      return `json += ${XU(e, t)}(${r})`;
    case void 0:
      return `json += JSON.stringify(${r})`;
    default:
      throw new Error(`${n.type} unsupported`);
  }
}
function QU(e, t) {
  const r = e.schema, n = r.type, i = Array.isArray(n) && n.includes("null");
  let s = "";
  return i && (s += `
      if (${t} === null) {
        json += JSON_STR_NULL
      } else {
    `), s += `json += '${JSON.stringify(r.const).replace(MU, "\\'")}'`, i && (s += `
      }
    `), s;
}
function eM(e, t, r) {
  const n = t.schema;
  let i = e.mergedSchemasIds.get(n);
  if (i) {
    const l = Wl(e, i);
    return vr(e, l, r);
  }
  i = `__fjs_merged_${oa++}`, e.mergedSchemasIds.set(n, i);
  const { allOf: s, ...o } = t.schema, a = [
    new Ji(
      o,
      t.schemaId,
      t.jsonPointer
    )
  ], c = t.getPropertyLocation("allOf");
  for (let l = 0; l < s.length; l++)
    a.push(c.getPropertyLocation(l));
  const u = Kl(e, i, a);
  return vr(e, u, r);
}
function tM(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const i = t.schema.anyOf ? "anyOf" : "oneOf", { [i]: s, ...o } = t.schema, a = new Ji(
    o,
    t.schemaId,
    t.jsonPointer
  ), c = t.getPropertyLocation(i);
  let u = "";
  for (let f = 0; f < s.length; f++) {
    const m = c.getPropertyLocation(f), p = m.schema;
    let d = e.mergedSchemasIds.get(p), h = null;
    d ? h = Wl(e, d) : (d = `__fjs_merged_${oa++}`, e.mergedSchemasIds.set(p, d), h = Kl(e, d, [
      a,
      m
    ]));
    const _ = vr(e, h, r), g = m.getSchemaRef();
    u += `
      ${f === 0 ? "if" : "else if"}(validator.validate("${g}", ${r}))
        ${_}
    `;
  }
  let l = t.getSchemaRef();
  return l.startsWith(e.rootSchemaId) && (l = l.replace(e.rootSchemaId, "")), u += `
    else throw new TypeError(\`The value of '${l}' does not match schema definition.\`)
  `, u;
}
function rM(e, t, r) {
  e.validatorSchemasIds.add(t.schemaId);
  const {
    if: n,
    then: i,
    else: s,
    ...o
  } = t.schema, a = new Ji(
    o,
    t.schemaId,
    t.jsonPointer
  ), u = t.getPropertyLocation("if").getSchemaRef(), l = t.getPropertyLocation("then");
  let f = e.mergedSchemasIds.get(i), m = null;
  if (f ? m = Wl(e, f) : (f = `__fjs_merged_${oa++}`, e.mergedSchemasIds.set(i, f), m = Kl(e, f, [
    a,
    l
  ])), !s)
    return `
      if (validator.validate("${u}", ${r})) {
        ${vr(e, m, r)}
      } else {
        ${vr(e, a, r)}
      }
    `;
  const p = t.getPropertyLocation("else");
  let d = e.mergedSchemasIds.get(s), h = null;
  return d ? h = Wl(e, d) : (d = `__fjs_merged_${oa++}`, e.mergedSchemasIds.set(s, d), h = Kl(e, d, [
    a,
    p
  ])), `
    if (validator.validate("${u}", ${r})) {
      ${vr(e, m, r)}
    } else {
      ${vr(e, h, r)}
    }
  `;
}
function vr(e, t, r) {
  let n = t.schema;
  if (typeof n == "boolean")
    return `json += JSON.stringify(${r})`;
  if (n.$ref && (t = Ga(e, t), n = t.schema), n.allOf)
    return eM(e, t, r);
  if (n.anyOf || n.oneOf)
    return tM(e, t, r);
  if (n.if && n.then)
    return rM(e, t, r);
  if (n.type === void 0) {
    const a = GU(n);
    a && (n.type = a);
  }
  let i = "";
  const s = n.type, o = n.nullable === !0;
  return o && (i += `
      if (${r} === null) {
        json += JSON_STR_NULL
      } else {
    `), n.const !== void 0 ? i += QU(t, r) : Array.isArray(s) ? i += ZU(e, t, r) : i += n$(e, t, r), o && (i += `
      }
    `), i;
}
to.exports = Ag;
to.exports.default = Ag;
to.exports.build = Ag;
to.exports.validLargeArrayMechanisms = QR;
to.exports.restore = function({ code: e, validator: t, serializer: r }) {
  return Function.apply(null, ["validator", "serializer", e]).apply(null, [t, r]);
};
var nM = to.exports;
const iM = nM;
function i$() {
  return function(t, r) {
    const n = Object.assign({}, r, { schema: t });
    return sM.bind(null, n);
  };
}
function sM(e, {
  schema: t
  /* method, url, httpStatus */
}) {
  return e.schema && t.$id && e.schema[t.$id] && (e.schema = { ...e.schema }, delete e.schema[t.$id]), iM(t, e);
}
function s$(e = { readMode: !0 }) {
  if (e.readMode === !0 && typeof e.restoreFunction != "function")
    throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
  if (e.readMode !== !0 && typeof e.storeFunction != "function")
    throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
  if (e.readMode === !0)
    return function() {
      return function(n) {
        return e.restoreFunction(n);
      };
    };
  const t = i$();
  return function(n, i = {}) {
    i.mode = "standalone";
    const s = t(n, i);
    return function(o) {
      const a = s(o);
      return e.storeFunction(o, a), new Function(a);
    };
  };
}
Lu.SerializerSelector = i$;
Lu.StandaloneSerializer = s$;
Lu.default = s$;
const { SerializerSelector: Ig, StandaloneSerializer: oM } = Lu;
Ba.exports = Ig;
Ba.exports.default = Ig;
Ba.exports.SerializerSelector = Ig;
Ba.exports.StandaloneSerializer = oM;
var aM = Ba.exports, mi = { exports: {} }, $h = { exports: {} }, Ng = {}, Xi = {}, Ir = {};
Object.defineProperty(Ir, "__esModule", { value: !0 });
Ir.checkMetadata = void 0;
const cM = se, lM = {
  keyword: "metadata",
  schemaType: "object",
  code(e) {
    o$(e);
    const { gen: t, schema: r, it: n } = e;
    if ((0, cM.alwaysValidSchema)(n, r))
      return;
    const i = t.name("valid");
    e.subschema({ keyword: "metadata", jtdMetadata: !0 }, i), e.ok(i);
  }
};
function o$({ it: e, keyword: t }, r) {
  if (e.jtdMetadata !== r)
    throw new Error(`JTD: "${t}" cannot be used in this schema location`);
}
Ir.checkMetadata = o$;
Ir.default = lM;
Object.defineProperty(Xi, "__esModule", { value: !0 });
Xi.hasRef = void 0;
const h_ = kt, $o = he, uM = an, m_ = br, g_ = Zn, fM = Ir, dM = {
  keyword: "ref",
  schemaType: "string",
  code(e) {
    (0, fM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: i, it: s } = e, { schemaEnv: { root: o } } = s, a = t.name("valid");
    i.nullable ? (t.var(a, (0, $o._)`${r} === null`), t.if((0, $o.not)(a), c)) : (t.var(a, !1), c()), e.ok(a);
    function c() {
      var f;
      const m = (f = o.schema.definitions) === null || f === void 0 ? void 0 : f[n];
      if (!m)
        throw new uM.default(s.opts.uriResolver, "", n, `No definition ${n}`);
      kg(m) || !s.opts.inlineRefs ? u(m) : l(m);
    }
    function u(f) {
      const m = h_.compileSchema.call(s.self, new h_.SchemaEnv({ schema: f, root: o, schemaPath: `/definitions/${n}` })), p = (0, g_.getValidate)(e, m), d = t.const("_errs", m_.default.errors);
      (0, g_.callRef)(e, p, m, m.$async), t.assign(a, (0, $o._)`${d} === ${m_.default.errors}`);
    }
    function l(f) {
      const m = t.scopeValue("schema", s.opts.code.source === !0 ? { ref: f, code: (0, $o.stringify)(f) } : { ref: f });
      e.subschema({
        schema: f,
        dataTypes: [],
        schemaPath: $o.nil,
        topSchemaRef: m,
        errSchemaPath: `/definitions/${n}`
      }, a);
    }
  }
};
function kg(e) {
  for (const t in e) {
    let r;
    if (t === "ref" || typeof (r = e[t]) == "object" && kg(r))
      return !0;
  }
  return !1;
}
Xi.hasRef = kg;
Xi.default = dM;
var Dg = {}, Vu = {};
Object.defineProperty(Vu, "__esModule", { value: !0 });
const pM = /t|\s/i, hM = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, mM = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i, gM = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function a$(e, t) {
  const r = e.split(pM);
  return r.length === 2 && y_(r[0]) && yM(r[1]) || t && r.length === 1 && y_(r[0]);
}
Vu.default = a$;
function y_(e) {
  const t = hM.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], i = +t[3];
  return n >= 1 && n <= 12 && i >= 1 && (i <= gM[n] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
  n === 2 && i === 29 && (r % 100 === 0 ? r % 400 === 0 : r % 4 === 0));
}
function yM(e) {
  const t = mM.exec(e);
  if (!t)
    return !1;
  const r = +t[1], n = +t[2], i = +t[3], s = +(t[4] || 0), o = +(t[5] || 0);
  return r <= 23 && n <= 59 && i <= 59 || // leap second
  r - s === 23 && n - o === 59 && i === 60;
}
a$.code = 'require("ajv/dist/runtime/timestamp").default';
var Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.typeErrorParams = Ar.typeErrorMessage = Ar.typeError = void 0;
const vM = he;
function _M(e) {
  return {
    message: (t) => c$(t, e),
    params: (t) => l$(t, e)
  };
}
Ar.typeError = _M;
function c$({ parentSchema: e }, t) {
  return e != null && e.nullable ? `must be ${t} or null` : `must be ${t}`;
}
Ar.typeErrorMessage = c$;
function l$({ parentSchema: e }, t) {
  return (0, vM._)`{type: ${t}, nullable: ${!!(e != null && e.nullable)}}`;
}
Ar.typeErrorParams = l$;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intRange = void 0;
  const t = he, r = Vu, n = se, i = Ir, s = Ar;
  e.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10]
  };
  const o = {
    message: (u) => (0, s.typeErrorMessage)(u, u.schema),
    params: (u) => (0, s.typeErrorParams)(u, u.schema)
  };
  function a(u) {
    const { gen: l, data: f, it: m } = u, { timestamp: p, allowDate: d } = m.opts;
    if (p === "date")
      return (0, t._)`${f} instanceof Date `;
    const h = (0, n.useFunc)(l, r.default), _ = d ? (0, t._)`, true` : t.nil, g = (0, t._)`typeof ${f} == "string" && ${h}(${f}${_})`;
    return p === "string" ? g : (0, t.or)((0, t._)`${f} instanceof Date`, g);
  }
  const c = {
    keyword: "type",
    schemaType: "string",
    error: o,
    code(u) {
      (0, i.checkMetadata)(u);
      const { data: l, schema: f, parentSchema: m, it: p } = u;
      let d;
      switch (f) {
        case "boolean":
        case "string":
          d = (0, t._)`typeof ${l} == ${f}`;
          break;
        case "timestamp": {
          d = a(u);
          break;
        }
        case "float32":
        case "float64":
          d = (0, t._)`typeof ${l} == "number"`;
          break;
        default: {
          const h = f;
          if (d = (0, t._)`typeof ${l} == "number" && isFinite(${l}) && !(${l} % 1)`, !p.opts.int32range && (h === "int32" || h === "uint32"))
            h === "uint32" && (d = (0, t._)`${d} && ${l} >= 0`);
          else {
            const [_, g] = e.intRange[h];
            d = (0, t._)`${d} && ${l} >= ${_} && ${l} <= ${g}`;
          }
        }
      }
      u.pass(m.nullable ? (0, t.or)((0, t._)`${l} === null`, d) : d);
    }
  };
  e.default = c;
})(Dg);
var Lg = {}, nn = {};
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.checkNullableObject = nn.checkNullable = void 0;
const _l = he;
function u$({ gen: e, data: t, parentSchema: r }, n = _l.nil) {
  const i = e.name("valid");
  return r.nullable ? (e.let(i, (0, _l._)`${t} === null`), n = (0, _l.not)(i)) : e.let(i, !1), [i, n];
}
nn.checkNullable = u$;
function bM(e, t) {
  const [r, n] = u$(e, t);
  return [r, (0, _l._)`${n} && typeof ${e.data} == "object" && !Array.isArray(${e.data})`];
}
nn.checkNullableObject = bM;
Object.defineProperty(Lg, "__esModule", { value: !0 });
const jn = he, EM = Ir, wM = nn, SM = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, jn._)`{allowedValues: ${e}}`
}, xM = {
  keyword: "enum",
  schemaType: "array",
  error: SM,
  code(e) {
    (0, EM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, schemaValue: i, parentSchema: s, it: o } = e;
    if (n.length === 0)
      throw new Error("enum must have non-empty array");
    if (n.length !== new Set(n).size)
      throw new Error("enum items must be unique");
    let a;
    const c = (0, jn._)`typeof ${r} == "string"`;
    if (n.length >= o.opts.loopEnum) {
      let l;
      [a, l] = (0, wM.checkNullable)(e, c), t.if(l, u);
    } else {
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      a = (0, jn.and)(c, (0, jn.or)(...n.map((l) => (0, jn._)`${r} === ${l}`))), s.nullable && (a = (0, jn.or)((0, jn._)`${r} === null`, a));
    }
    e.pass(a);
    function u() {
      t.forOf("v", i, (l) => t.if((0, jn._)`${a} = ${r} === ${l}`, () => t.break()));
    }
  }
};
Lg.default = xM;
var Fg = {};
Object.defineProperty(Fg, "__esModule", { value: !0 });
const RM = se, $M = be, v_ = he, TM = Ir, OM = nn, PM = Ar, CM = {
  keyword: "elements",
  schemaType: "object",
  error: (0, PM.typeError)("array"),
  code(e) {
    (0, TM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: i } = e;
    if ((0, RM.alwaysValidSchema)(i, n))
      return;
    const [s] = (0, OM.checkNullable)(e);
    t.if((0, v_.not)(s), () => t.if((0, v_._)`Array.isArray(${r})`, () => t.assign(s, (0, $M.validateArray)(e)), () => e.error())), e.ok(s);
  }
};
Fg.default = CM;
var jg = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateProperties = e.error = void 0;
  const t = be, r = se, n = he, i = Ir, s = nn, o = Ar;
  var a;
  (function(l) {
    l.Additional = "additional", l.Missing = "missing";
  })(a || (a = {})), e.error = {
    message: (l) => {
      const { params: f } = l;
      return f.propError ? f.propError === a.Additional ? "must NOT have additional properties" : `must have property '${f.missingProperty}'` : (0, o.typeErrorMessage)(l, "object");
    },
    params: (l) => {
      const { params: f } = l;
      return f.propError ? f.propError === a.Additional ? (0, n._)`{error: ${f.propError}, additionalProperty: ${f.additionalProperty}}` : (0, n._)`{error: ${f.propError}, missingProperty: ${f.missingProperty}}` : (0, o.typeErrorParams)(l, "object");
    }
  };
  const c = {
    keyword: "properties",
    schemaType: "object",
    error: e.error,
    code: u
  };
  function u(l) {
    (0, i.checkMetadata)(l);
    const { gen: f, data: m, parentSchema: p, it: d } = l, { additionalProperties: h, nullable: _ } = p;
    if (d.jtdDiscriminator && _)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (C())
      throw new Error("JTD: properties and optionalProperties have common members");
    const [g, v] = V("properties"), [y, E] = V("optionalProperties");
    if (v.length === 0 && E.length === 0 && h)
      return;
    const [R, w] = d.jtdDiscriminator === void 0 ? (0, s.checkNullableObject)(l, m) : [f.let("valid", !1), !0];
    f.if(w, () => f.assign(R, !0).block(() => {
      b(v, "properties", !0), b(E, "optionalProperties"), h || H();
    })), l.pass(R);
    function C() {
      const $ = p.properties, x = p.optionalProperties;
      if (!($ && x))
        return !1;
      for (const A in $)
        if (Object.prototype.hasOwnProperty.call(x, A))
          return !0;
      return !1;
    }
    function V($) {
      const x = p[$], A = x ? (0, t.allSchemaProperties)(x) : [];
      if (d.jtdDiscriminator && A.some((D) => D === d.jtdDiscriminator))
        throw new Error(`JTD: discriminator tag used in ${$}`);
      const P = A.filter((D) => !(0, r.alwaysValidSchema)(d, x[D]));
      return [A, P];
    }
    function b($, x, A) {
      const P = f.var("valid");
      for (const I of $)
        f.if((0, t.propertyInData)(f, m, I, d.opts.ownProperties), () => F(I, x, P), () => D(I)), l.ok(P);
      function D(I) {
        A ? (f.assign(P, !1), l.error(!1, { propError: a.Missing, missingProperty: I }, { schemaPath: I })) : f.assign(P, !0);
      }
    }
    function F($, x, A) {
      l.subschema({
        keyword: x,
        schemaProp: $,
        dataProp: $
      }, A);
    }
    function H() {
      f.forIn("key", m, ($) => {
        const x = q($, g, "properties", d.jtdDiscriminator), A = q($, y, "optionalProperties"), P = x === !0 ? A : A === !0 ? x : (0, n.and)(x, A);
        f.if(P, () => {
          d.opts.removeAdditional ? f.code((0, n._)`delete ${m}[${$}]`) : (l.error(!1, { propError: a.Additional, additionalProperty: $ }, { instancePath: $, parentSchema: !0 }), d.opts.allErrors || f.break());
        });
      });
    }
    function q($, x, A, P) {
      let D;
      if (x.length > 8) {
        const I = (0, r.schemaRefOrVal)(d, p[A], A);
        D = (0, n.not)((0, t.isOwnProperty)(f, I, $)), P !== void 0 && (D = (0, n.and)(D, (0, n._)`${$} !== ${P}`));
      } else if (x.length || P !== void 0) {
        const I = P === void 0 ? x : [P].concat(x);
        D = (0, n.and)(...I.map((L) => (0, n._)`${$} !== ${L}`));
      } else
        D = !0;
      return D;
    }
  }
  e.validateProperties = u, e.default = c;
})(jg);
var Ug = {};
Object.defineProperty(Ug, "__esModule", { value: !0 });
const __ = jg, AM = {
  keyword: "optionalProperties",
  schemaType: "object",
  error: __.error,
  code(e) {
    e.parentSchema.properties || (0, __.validateProperties)(e);
  }
};
Ug.default = AM;
var Mg = {};
Object.defineProperty(Mg, "__esModule", { value: !0 });
const Si = he, IM = Ir, NM = nn, b_ = Ar, bl = Va, kM = {
  message: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? r.discrError === bl.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in mapping` : (0, b_.typeErrorMessage)(e, "object");
  },
  params: (e) => {
    const { schema: t, params: r } = e;
    return r.discrError ? (0, Si._)`{error: ${r.discrError}, tag: ${t}, tagValue: ${r.tag}}` : (0, b_.typeErrorParams)(e, "object");
  }
}, DM = {
  keyword: "discriminator",
  schemaType: "string",
  implements: ["mapping"],
  error: kM,
  code(e) {
    (0, IM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, parentSchema: i } = e, [s, o] = (0, NM.checkNullableObject)(e, r);
    t.if(o), a(), t.elseIf((0, Si.not)(s)), e.error(), t.endIf(), e.ok(s);
    function a() {
      const l = t.const("tag", (0, Si._)`${r}${(0, Si.getProperty)(n)}`);
      t.if((0, Si._)`${l} === undefined`), e.error(!1, { discrError: bl.DiscrError.Tag, tag: l }), t.elseIf((0, Si._)`typeof ${l} == "string"`), c(l), t.else(), e.error(!1, { discrError: bl.DiscrError.Tag, tag: l }, { instancePath: n }), t.endIf();
    }
    function c(l) {
      t.if(!1);
      for (const f in i.mapping)
        t.elseIf((0, Si._)`${l} === ${f}`), t.assign(s, u(f));
      t.else(), e.error(!1, { discrError: bl.DiscrError.Mapping, tag: l }, { instancePath: n, schemaPath: "mapping", parentSchema: !0 }), t.endIf();
    }
    function u(l) {
      const f = t.name("valid");
      return e.subschema({
        keyword: "mapping",
        schemaProp: l,
        jtdDiscriminator: n
      }, f), f;
    }
  }
};
Mg.default = DM;
var Hg = {};
Object.defineProperty(Hg, "__esModule", { value: !0 });
const E_ = se, jc = he, LM = Ir, FM = nn, jM = Ar, UM = {
  keyword: "values",
  schemaType: "object",
  error: (0, jM.typeError)("object"),
  code(e) {
    (0, LM.checkMetadata)(e);
    const { gen: t, data: r, schema: n, it: i } = e, [s, o] = (0, FM.checkNullableObject)(e, r);
    (0, E_.alwaysValidSchema)(i, n) ? t.if((0, jc.not)((0, jc.or)(o, s)), () => e.error()) : (t.if(o), t.assign(s, a()), t.elseIf((0, jc.not)(s)), e.error(), t.endIf()), e.ok(s);
    function a() {
      const c = t.name("valid");
      if (i.allErrors) {
        const l = t.let("valid", !0);
        return u(() => t.assign(l, !1)), l;
      }
      return t.var(c, !0), u(() => t.break()), c;
      function u(l) {
        t.forIn("key", r, (f) => {
          e.subschema({
            keyword: "values",
            dataProp: f,
            dataPropType: E_.Type.Str
          }, c), t.if((0, jc.not)(c), l);
        });
      }
    }
  }
};
Hg.default = UM;
var qg = {};
Object.defineProperty(qg, "__esModule", { value: !0 });
const MM = be, HM = {
  keyword: "union",
  schemaType: "array",
  trackErrors: !0,
  code: MM.validateUnion,
  error: { message: "must match a schema in union" }
};
qg.default = HM;
Object.defineProperty(Ng, "__esModule", { value: !0 });
const qM = Xi, BM = Dg, zM = Lg, VM = Fg, GM = jg, WM = Ug, KM = Mg, YM = Hg, JM = qg, XM = Ir, ZM = [
  "definitions",
  qM.default,
  BM.default,
  zM.default,
  VM.default,
  GM.default,
  WM.default,
  KM.default,
  YM.default,
  JM.default,
  XM.default,
  { keyword: "additionalProperties", schemaType: "boolean" },
  { keyword: "nullable", schemaType: "boolean" }
];
Ng.default = ZM;
var Bg = {};
Object.defineProperty(Bg, "__esModule", { value: !0 });
const xn = (e) => {
  const t = {
    nullable: { type: "boolean" },
    metadata: {
      optionalProperties: {
        union: { elements: { ref: "schema" } }
      },
      additionalProperties: !0
    }
  };
  return e && (t.definitions = { values: { ref: "schema" } }), t;
}, QM = (e) => ({
  optionalProperties: xn(e)
}), eH = (e) => ({
  properties: {
    ref: { type: "string" }
  },
  optionalProperties: xn(e)
}), tH = (e) => ({
  properties: {
    type: {
      enum: [
        "boolean",
        "timestamp",
        "string",
        "float32",
        "float64",
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32"
      ]
    }
  },
  optionalProperties: xn(e)
}), rH = (e) => ({
  properties: {
    enum: { elements: { type: "string" } }
  },
  optionalProperties: xn(e)
}), nH = (e) => ({
  properties: {
    elements: { ref: "schema" }
  },
  optionalProperties: xn(e)
}), f$ = (e) => ({
  properties: {
    properties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    optionalProperties: { values: { ref: "schema" } },
    additionalProperties: { type: "boolean" },
    ...xn(e)
  }
}), d$ = (e) => ({
  properties: {
    optionalProperties: { values: { ref: "schema" } }
  },
  optionalProperties: {
    additionalProperties: { type: "boolean" },
    ...xn(e)
  }
}), iH = (e) => ({
  properties: {
    discriminator: { type: "string" },
    mapping: {
      values: {
        metadata: {
          union: [f$(!1), d$(!1)]
        }
      }
    }
  },
  optionalProperties: xn(e)
}), sH = (e) => ({
  properties: {
    values: { ref: "schema" }
  },
  optionalProperties: xn(e)
}), w_ = (e) => ({
  metadata: {
    union: [
      QM,
      eH,
      tH,
      rH,
      nH,
      f$,
      d$,
      iH,
      sH
    ].map((t) => t(e))
  }
}), oH = {
  definitions: {
    schema: w_(!1)
  },
  ...w_(!0)
};
Bg.default = oH;
var zg = {}, Wa = {};
Object.defineProperty(Wa, "__esModule", { value: !0 });
Wa.jtdForms = void 0;
Wa.jtdForms = [
  "elements",
  "values",
  "discriminator",
  "properties",
  "optionalProperties",
  "enum",
  "type",
  "ref"
];
var Vg = {};
Object.defineProperty(Vg, "__esModule", { value: !0 });
const Fd = (
  // eslint-disable-next-line no-control-regex, no-misleading-character-class
  /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
), aH = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};
function p$(e) {
  return Fd.lastIndex = 0, '"' + (Fd.test(e) ? e.replace(Fd, (t) => {
    const r = aH[t];
    return typeof r == "string" ? r : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
  }) : e) + '"';
}
Vg.default = p$;
p$.code = 'require("ajv/dist/runtime/quote").default';
Object.defineProperty(zg, "__esModule", { value: !0 });
const cH = Wa, h$ = kt, Pe = he, lH = an, Ge = br, uH = be, fH = Xi, dH = se, pH = Vg, hH = {
  elements: gH,
  values: yH,
  discriminator: vH,
  properties: S_,
  optionalProperties: S_,
  enum: aa,
  type: _H,
  ref: EH
};
function m$(e, t) {
  const r = h$.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new Pe.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s }), a = o.scopeName("serialize"), c = {
    self: this,
    gen: o,
    schema: e.schema,
    schemaEnv: e,
    definitions: t,
    data: Ge.default.data
  };
  let u;
  try {
    this._compilations.add(e), e.serializeName = a, o.func(a, Ge.default.data, !1, () => {
      o.let(Ge.default.json, (0, Pe.str)``), Ka(c), o.return(Ge.default.json);
    }), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    u = `${o.scopeRefs(Ge.default.scope)}return ${l}`;
    const m = new Function(`${Ge.default.scope}`, u)(this.scope.get());
    this.scope.value(a, { ref: m }), e.serialize = m;
  } catch (l) {
    throw u && this.logger.error("Error compiling serializer, function code:", u), delete e.serialize, delete e.serializeName, l;
  } finally {
    this._compilations.delete(e);
  }
  return e;
}
zg.default = m$;
function Ka(e) {
  let t;
  for (const r of cH.jtdForms)
    if (r in e.schema) {
      t = r;
      break;
    }
  mH(e, t ? hH[t] : SH);
}
function mH(e, t) {
  const { gen: r, schema: n, data: i } = e;
  if (!n.nullable)
    return t(e);
  r.if((0, Pe._)`${i} === undefined || ${i} === null`, () => r.add(Ge.default.json, (0, Pe._)`"null"`), () => t(e));
}
function gH(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(Ge.default.json, (0, Pe.str)`[`);
  const i = t.let("first", !0);
  t.forOf("el", n, (s) => {
    Gg(e, i), Ka({ ...e, schema: r.elements, data: s });
  }), t.add(Ge.default.json, (0, Pe.str)`]`);
}
function yH(e) {
  const { gen: t, schema: r, data: n } = e;
  t.add(Ge.default.json, (0, Pe.str)`{`);
  const i = t.let("first", !0);
  t.forIn("key", n, (s) => g$(e, s, r.values, i)), t.add(Ge.default.json, (0, Pe.str)`}`);
}
function g$(e, t, r, n) {
  const { gen: i, data: s } = e;
  Gg(e, n), aa({ ...e, data: t }), i.add(Ge.default.json, (0, Pe.str)`:`);
  const o = i.const("value", (0, Pe._)`${s}${(0, Pe.getProperty)(t)}`);
  Ka({ ...e, schema: r, data: o });
}
function vH(e) {
  const { gen: t, schema: r, data: n } = e, { discriminator: i } = r;
  t.add(Ge.default.json, (0, Pe.str)`{${JSON.stringify(i)}:`);
  const s = t.const("tag", (0, Pe._)`${n}${(0, Pe.getProperty)(i)}`);
  aa({ ...e, data: s }), t.if(!1);
  for (const o in r.mapping) {
    t.elseIf((0, Pe._)`${s} === ${o}`);
    const a = r.mapping[o];
    y$({ ...e, schema: a }, i);
  }
  t.endIf(), t.add(Ge.default.json, (0, Pe.str)`}`);
}
function S_(e) {
  const { gen: t } = e;
  t.add(Ge.default.json, (0, Pe.str)`{`), y$(e), t.add(Ge.default.json, (0, Pe.str)`}`);
}
function y$(e, t) {
  const { gen: r, schema: n, data: i } = e, { properties: s, optionalProperties: o } = n, a = m(s), c = m(o), u = p(a.concat(c));
  let l = !t, f;
  for (const g of a)
    l ? l = !1 : r.add(Ge.default.json, (0, Pe.str)`,`), h(g, s[g], d(g));
  l && (f = r.let("first", !0));
  for (const g of c) {
    const v = d(g);
    r.if((0, Pe.and)((0, Pe._)`${v} !== undefined`, (0, uH.isOwnProperty)(r, i, g)), () => {
      Gg(e, f), h(g, o[g], v);
    });
  }
  n.additionalProperties && r.forIn("key", i, (g) => r.if(_(g, u), () => g$(e, g, {}, f)));
  function m(g) {
    return g ? Object.keys(g) : [];
  }
  function p(g) {
    if (t && g.push(t), new Set(g).size !== g.length)
      throw new Error("JTD: properties/optionalProperties/disciminator overlap");
    return g;
  }
  function d(g) {
    return r.const("value", (0, Pe._)`${i}${(0, Pe.getProperty)(g)}`);
  }
  function h(g, v, y) {
    r.add(Ge.default.json, (0, Pe.str)`${JSON.stringify(g)}:`), Ka({ ...e, schema: v, data: y });
  }
  function _(g, v) {
    return v.length ? (0, Pe.and)(...v.map((y) => (0, Pe._)`${g} !== ${y}`)) : !0;
  }
}
function _H(e) {
  const { gen: t, schema: r, data: n } = e;
  switch (r.type) {
    case "boolean":
      t.add(Ge.default.json, (0, Pe._)`${n} ? "true" : "false"`);
      break;
    case "string":
      aa(e);
      break;
    case "timestamp":
      t.if((0, Pe._)`${n} instanceof Date`, () => t.add(Ge.default.json, (0, Pe._)`'"' + ${n}.toISOString() + '"'`), () => aa(e));
      break;
    default:
      bH(e);
  }
}
function aa({ gen: e, data: t }) {
  e.add(Ge.default.json, (0, Pe._)`${(0, dH.useFunc)(e, pH.default)}(${t})`);
}
function bH({ gen: e, data: t }) {
  e.add(Ge.default.json, (0, Pe._)`"" + ${t}`);
}
function EH(e) {
  const { gen: t, self: r, data: n, definitions: i, schema: s, schemaEnv: o } = e, { ref: a } = s, c = i[a];
  if (!c)
    throw new lH.default(r.opts.uriResolver, "", a, `No definition ${a}`);
  if (!(0, fH.hasRef)(c))
    return Ka({ ...e, schema: c });
  const { root: u } = o, l = m$.call(r, new h$.SchemaEnv({ schema: c, root: u }), i);
  t.add(Ge.default.json, (0, Pe._)`${wH(t, l)}(${n})`);
}
function wH(e, t) {
  return t.serialize ? e.scopeValue("serialize", { ref: t.serialize }) : (0, Pe._)`${e.scopeValue("wrapper", { ref: t })}.serialize`;
}
function SH({ gen: e, data: t }) {
  e.add(Ge.default.json, (0, Pe._)`JSON.stringify(${t})`);
}
function Gg({ gen: e }, t) {
  t ? e.if(t, () => e.assign(t, !1), () => e.add(Ge.default.json, (0, Pe.str)`,`)) : e.add(Ge.default.json, (0, Pe.str)`,`);
}
var Wg = {}, Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.parseJsonString = Jn.parseJsonNumber = Jn.parseJson = void 0;
const xH = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
function pn(e, t) {
  let r;
  pn.message = void 0;
  let n;
  t && (e = e.slice(t));
  try {
    return pn.position = t + e.length, JSON.parse(e);
  } catch (i) {
    if (n = xH.exec(i.message), !n) {
      pn.message = "unexpected end";
      return;
    }
    r = +n[1];
    const s = e[r];
    e = e.slice(0, r), pn.position = t + r;
    try {
      return JSON.parse(e);
    } catch {
      pn.message = `unexpected token ${s}`;
      return;
    }
  }
}
Jn.parseJson = pn;
pn.message = void 0;
pn.position = 0;
pn.code = 'require("ajv/dist/runtime/parseJson").parseJson';
function hn(e, t, r) {
  let n = "", i;
  if (hn.message = void 0, e[t] === "-" && (n += "-", t++), e[t] === "0")
    n += "0", t++;
  else if (!s(r)) {
    o();
    return;
  }
  if (r)
    return hn.position = t, +n;
  if (e[t] === "." && (n += ".", t++, !s())) {
    o();
    return;
  }
  if (i = e[t], (i === "e" || i === "E") && (n += "e", t++, i = e[t], (i === "+" || i === "-") && (n += i, t++), !s())) {
    o();
    return;
  }
  return hn.position = t, +n;
  function s(a) {
    let c = !1;
    for (; i = e[t], i >= "0" && i <= "9" && (a === void 0 || a-- > 0); )
      c = !0, n += i, t++;
    return c;
  }
  function o() {
    hn.position = t, hn.message = t < e.length ? `unexpected token ${e[t]}` : "unexpected end";
  }
}
Jn.parseJsonNumber = hn;
hn.message = void 0;
hn.position = 0;
hn.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
const x_ = {
  b: "\b",
  f: "\f",
  n: `
`,
  r: "\r",
  t: "	",
  '"': '"',
  "/": "/",
  "\\": "\\"
}, RH = 97, $H = 48;
function Vn(e, t) {
  let r = "", n;
  for (Vn.message = void 0; n = e[t++], n !== '"'; )
    if (n === "\\")
      if (n = e[t], n in x_)
        r += x_[n], t++;
      else if (n === "u") {
        t++;
        let s = 4, o = 0;
        for (; s--; ) {
          if (o <<= 4, n = e[t], n === void 0) {
            i("unexpected end");
            return;
          }
          if (n = n.toLowerCase(), n >= "a" && n <= "f")
            o += n.charCodeAt(0) - RH + 10;
          else if (n >= "0" && n <= "9")
            o += n.charCodeAt(0) - $H;
          else {
            i(`unexpected token ${n}`);
            return;
          }
          t++;
        }
        r += String.fromCharCode(o);
      } else {
        i(`unexpected token ${n}`);
        return;
      }
    else if (n === void 0) {
      i("unexpected end");
      return;
    } else if (n.charCodeAt(0) >= 32)
      r += n;
    else {
      i(`unexpected token ${n}`);
      return;
    }
  return Vn.position = t, r;
  function i(s) {
    Vn.position = t, Vn.message = s;
  }
}
Jn.parseJsonString = Vn;
Vn.message = void 0;
Vn.position = 0;
Vn.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
Object.defineProperty(Wg, "__esModule", { value: !0 });
const TH = Wa, v$ = kt, de = he, OH = an, $e = br, PH = be, CH = Xi, AH = Dg, Kg = Jn, _$ = se, IH = Vu, NH = {
  elements: FH,
  values: jH,
  discriminator: MH,
  properties: R_,
  optionalProperties: R_,
  enum: qH,
  type: HH,
  ref: BH
};
function b$(e, t) {
  const r = v$.getCompilingSchema.call(this, e);
  if (r)
    return r;
  const { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new de.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s }), a = o.scopeName("parse"), c = {
    self: this,
    gen: o,
    schema: e.schema,
    schemaEnv: e,
    definitions: t,
    data: $e.default.data,
    parseName: a,
    char: o.name("c")
  };
  let u;
  try {
    this._compilations.add(e), e.parseName = a, kH(c), o.optimize(this.opts.code.optimize);
    const l = o.toString();
    u = `${o.scopeRefs($e.default.scope)}return ${l}`;
    const m = new Function(`${$e.default.scope}`, u)(this.scope.get());
    this.scope.value(a, { ref: m }), e.parse = m;
  } catch (l) {
    throw u && this.logger.error("Error compiling parser, function code:", u), delete e.parse, delete e.parseName, l;
  } finally {
    this._compilations.delete(e);
  }
  return e;
}
Wg.default = b$;
const Th = (0, de._)`undefined`;
function kH(e) {
  const { gen: t, parseName: r, char: n } = e;
  t.func(r, (0, de._)`${$e.default.json}, ${$e.default.jsonPos}, ${$e.default.jsonPart}`, !1, () => {
    t.let($e.default.data), t.let(n), t.assign((0, de._)`${r}.message`, Th), t.assign((0, de._)`${r}.position`, Th), t.assign($e.default.jsonPos, (0, de._)`${$e.default.jsonPos} || 0`), t.const($e.default.jsonLen, (0, de._)`${$e.default.json}.length`), Gu(e), Zg(e), t.if($e.default.jsonPart, () => {
      t.assign((0, de._)`${r}.position`, $e.default.jsonPos), t.return($e.default.data);
    }), t.if((0, de._)`${$e.default.jsonPos} === ${$e.default.jsonLen}`, () => t.return($e.default.data)), oo(e);
  });
}
function Gu(e) {
  let t;
  for (const r of TH.jtdForms)
    if (r in e.schema) {
      t = r;
      break;
    }
  t ? LH(e, NH[t]) : Jg(e);
}
const DH = T_(!0, T_(!1, oo));
function LH(e, t) {
  const { gen: r, schema: n, data: i } = e;
  if (!n.nullable)
    return t(e);
  ca(e, "null", t, () => r.assign(i, null));
}
function FH(e) {
  const { gen: t, schema: r, data: n } = e;
  sn(e, "[");
  const i = t.let("i", 0);
  t.assign(n, (0, de._)`[]`), Yg(e, "]", () => {
    const s = t.let("el");
    Gu({ ...e, schema: r.elements, data: s }), t.assign((0, de._)`${n}[${i}++]`, s);
  });
}
function jH(e) {
  const { gen: t, schema: r, data: n } = e;
  sn(e, "{"), t.assign(n, (0, de._)`{}`), Yg(e, "}", () => UH(e, r.values));
}
function Yg(e, t, r) {
  E$(e, t, r), sn(e, t);
}
function E$(e, t, r) {
  const { gen: n } = e;
  n.for((0, de._)`;${$e.default.jsonPos}<${$e.default.jsonLen} && ${Wu(1)}!==${t};`, () => {
    r(), ca(e, ",", () => n.break(), i);
  });
  function i() {
    ca(e, t, () => {
    }, oo);
  }
}
function UH(e, t) {
  const { gen: r } = e, n = r.let("key");
  qi({ ...e, data: n }), sn(e, ":"), S$(e, n, t);
}
function MH(e) {
  const { gen: t, data: r, schema: n } = e, { discriminator: i, mapping: s } = n;
  sn(e, "{"), t.assign(r, (0, de._)`{}`);
  const o = t.const("pos", $e.default.jsonPos), a = t.let("value"), c = t.let("tag");
  E$(e, "}", () => {
    const u = t.let("key");
    qi({ ...e, data: u }), sn(e, ":"), t.if(
      (0, de._)`${u} === ${i}`,
      () => {
        qi({ ...e, data: c }), t.assign((0, de._)`${r}[${u}]`, c), t.break();
      },
      () => Jg({ ...e, data: a })
      // can be discarded/skipped
    );
  }), t.assign($e.default.jsonPos, o), t.if((0, de._)`${c} === undefined`), vn(e, (0, de.str)`discriminator tag not found`);
  for (const u in s)
    t.elseIf((0, de._)`${c} === ${u}`), w$({ ...e, schema: s[u] }, i);
  t.else(), vn(e, (0, de.str)`discriminator value not in schema`), t.endIf();
}
function R_(e) {
  const { gen: t, data: r } = e;
  sn(e, "{"), t.assign(r, (0, de._)`{}`), w$(e);
}
function w$(e, t) {
  const { gen: r, schema: n, data: i } = e, { properties: s, optionalProperties: o, additionalProperties: a } = n;
  if (Yg(e, "}", () => {
    const c = r.let("key");
    if (qi({ ...e, data: c }), sn(e, ":"), r.if(!1), $_(e, c, s), $_(e, c, o), t) {
      r.elseIf((0, de._)`${c} === ${t}`);
      const u = r.let("tag");
      qi({ ...e, data: u });
    }
    r.else(), a ? Jg({ ...e, data: (0, de._)`${i}[${c}]` }) : vn(e, (0, de.str)`property ${c} not allowed`), r.endIf();
  }), s) {
    const c = (0, PH.hasPropFunc)(r), u = (0, de.and)(...Object.keys(s).map((l) => (0, de._)`${c}.call(${i}, ${l})`));
    r.if((0, de.not)(u), () => vn(e, (0, de.str)`missing required properties`));
  }
}
function $_(e, t, r = {}) {
  const { gen: n } = e;
  for (const i in r)
    n.elseIf((0, de._)`${t} === ${i}`), S$(e, t, r[i]);
}
function S$(e, t, r) {
  Gu({ ...e, schema: r, data: (0, de._)`${e.data}[${t}]` });
}
function HH(e) {
  const { gen: t, schema: r, data: n, self: i } = e;
  switch (r.type) {
    case "boolean":
      DH(e);
      break;
    case "string":
      qi(e);
      break;
    case "timestamp": {
      qi(e);
      const s = (0, _$.useFunc)(t, IH.default), { allowDate: o, parseDate: a } = i.opts, c = o ? (0, de._)`!${s}(${n}, true)` : (0, de._)`!${s}(${n})`, u = a ? (0, de.or)(c, (0, de._)`(${n} = new Date(${n}), false)`, (0, de._)`isNaN(${n}.valueOf())`) : c;
      t.if(u, () => vn(e, (0, de.str)`invalid timestamp`));
      break;
    }
    case "float32":
    case "float64":
      jd(e);
      break;
    default: {
      const s = r.type;
      if (!i.opts.int32range && (s === "int32" || s === "uint32"))
        jd(e, 16), s === "uint32" && t.if((0, de._)`${n} < 0`, () => vn(e, (0, de.str)`integer out of range`));
      else {
        const [o, a, c] = AH.intRange[s];
        jd(e, c), t.if((0, de._)`${n} < ${o} || ${n} > ${a}`, () => vn(e, (0, de.str)`integer out of range`));
      }
    }
  }
}
function qi(e) {
  sn(e, '"'), Xg(e, Kg.parseJsonString);
}
function qH(e) {
  const { gen: t, data: r, schema: n } = e, i = n.enum;
  sn(e, '"'), t.if(!1);
  for (const s of i) {
    const o = JSON.stringify(s).slice(1);
    t.elseIf((0, de._)`${Wu(o.length)} === ${o}`), t.assign(r, (0, de.str)`${s}`), t.add($e.default.jsonPos, o.length);
  }
  t.else(), oo(e), t.endIf();
}
function jd(e, t) {
  const { gen: r } = e;
  Zg(e), r.if((0, de._)`"-0123456789".indexOf(${Wu(1)}) < 0`, () => oo(e), () => Xg(e, Kg.parseJsonNumber, t));
}
function T_(e, t) {
  return (r) => {
    const { gen: n, data: i } = r;
    ca(r, `${e}`, () => t(r), () => n.assign(i, e));
  };
}
function BH(e) {
  const { gen: t, self: r, definitions: n, schema: i, schemaEnv: s } = e, { ref: o } = i, a = n[o];
  if (!a)
    throw new OH.default(r.opts.uriResolver, "", o, `No definition ${o}`);
  if (!(0, CH.hasRef)(a))
    return Gu({ ...e, schema: a });
  const { root: c } = s, u = b$.call(r, new v$.SchemaEnv({ schema: a, root: c }), n);
  x$(e, zH(t, u), !0);
}
function zH(e, t) {
  return t.parse ? e.scopeValue("parse", { ref: t.parse }) : (0, de._)`${e.scopeValue("wrapper", { ref: t })}.parse`;
}
function Jg(e) {
  Xg(e, Kg.parseJson);
}
function Xg(e, t, r) {
  x$(e, (0, _$.useFunc)(e.gen, t), r);
}
function x$(e, t, r) {
  const { gen: n, data: i } = e;
  n.assign(i, (0, de._)`${t}(${$e.default.json}, ${$e.default.jsonPos}${r ? (0, de._)`, ${r}` : de.nil})`), n.assign($e.default.jsonPos, (0, de._)`${t}.position`), n.if((0, de._)`${i} === undefined`, () => vn(e, (0, de._)`${t}.message`));
}
function sn(e, t) {
  ca(e, t, oo);
}
function ca(e, t, r, n) {
  const { gen: i } = e, s = t.length;
  Zg(e), i.if((0, de._)`${Wu(s)} === ${t}`, () => {
    i.add($e.default.jsonPos, s), n == null || n(e);
  }, () => r(e));
}
function Zg({ gen: e, char: t }) {
  e.code((0, de._)`while((${t}=${$e.default.json}[${$e.default.jsonPos}],${t}===" "||${t}==="\\n"||${t}==="\\r"||${t}==="\\t"))${$e.default.jsonPos}++;`);
}
function Wu(e) {
  return e === 1 ? (0, de._)`${$e.default.json}[${$e.default.jsonPos}]` : (0, de._)`${$e.default.json}.slice(${$e.default.jsonPos}, ${$e.default.jsonPos}+${e})`;
}
function oo(e) {
  vn(e, (0, de._)`"unexpected token " + ${$e.default.json}[${$e.default.jsonPos}]`);
}
function vn({ gen: e, parseName: t }, r) {
  e.assign((0, de._)`${t}.message`, r), e.assign((0, de._)`${t}.position`, $e.default.jsonPos), e.return(Th);
}
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
  const r = Dm, n = Ng, i = Bg, s = zg, o = Wg, a = "JTD-meta-schema";
  class c extends r.default {
    constructor(d = {}) {
      super({
        ...d,
        jtd: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), this.addVocabulary(n.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema(), this.opts.meta && this.addMetaSchema(i.default, a, !1);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
    compileSerializer(d) {
      const h = this._addSchema(d);
      return h.serialize || this._compileSerializer(h);
    }
    compileParser(d) {
      const h = this._addSchema(d);
      return h.parse || this._compileParser(h);
    }
    _compileSerializer(d) {
      if (s.default.call(this, d, d.schema.definitions || {}), !d.serialize)
        throw new Error("ajv implementation error");
      return d.serialize;
    }
    _compileParser(d) {
      if (o.default.call(this, d, d.schema.definitions || {}), !d.parse)
        throw new Error("ajv implementation error");
      return d.parse;
    }
  }
  t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  var u = Cr;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return u.KeywordCxt;
  } });
  var l = he;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return l._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return l.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return l.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return l.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return l.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return l.CodeGen;
  } });
  var f = ro;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var m = an;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return m.default;
  } });
})($h, $h.exports);
var R$ = $h.exports;
const VH = Jm;
var $$ = Object.freeze({
  coerceTypes: "array",
  useDefaults: !0,
  removeAdditional: !0,
  uriResolver: VH,
  addUsedSchema: !1,
  // Explicitly set allErrors to `false`.
  // When set to `true`, a DoS attack is possible.
  allErrors: !1
});
<<<<<<< HEAD
const Ajv = ajvExports.default;
const AjvJTD$1 = jtdExports;
const defaultAjvOptions$1 = defaultAjvOptions$2;
class ValidatorCompiler {
  constructor(externalSchemas, options) {
    var _a2;
    if (options.mode === "JTD") {
      this.ajv = new AjvJTD$1(Object.assign({}, defaultAjvOptions$1, options.customOptions));
    } else {
      this.ajv = new Ajv(Object.assign({}, defaultAjvOptions$1, options.customOptions));
    }
    let addFormatPlugin = true;
    if (options.plugins && options.plugins.length > 0) {
      for (const plugin2 of options.plugins) {
        if (Array.isArray(plugin2)) {
          addFormatPlugin = addFormatPlugin && plugin2[0].name !== "formatsPlugin";
          plugin2[0](this.ajv, plugin2[1]);
        } else {
          addFormatPlugin = addFormatPlugin && plugin2.name !== "formatsPlugin";
          plugin2(this.ajv);
        }
      }
    }
    if (addFormatPlugin) {
      requireDist$1()(this.ajv);
    }
    (_a2 = options.onCreate) == null ? void 0 : _a2.call(options, this.ajv);
    const sourceSchemas = Object.values(externalSchemas);
    for (const extSchema of sourceSchemas) {
      this.ajv.addSchema(extSchema);
    }
=======
const GH = Og.default, WH = R$, O_ = $$;
class KH {
  constructor(t, r) {
    var s;
    r.mode === "JTD" ? this.ajv = new WH(Object.assign({}, O_, r.customOptions)) : this.ajv = new GH(Object.assign({}, O_, r.customOptions));
    let n = !0;
    if (r.plugins && r.plugins.length > 0)
      for (const o of r.plugins)
        Array.isArray(o) ? (n = n && o[0].name !== "formatsPlugin", o[0](this.ajv, o[1])) : (n = n && o.name !== "formatsPlugin", o(this.ajv));
    n && GR()(this.ajv), (s = r.onCreate) == null || s.call(r, this.ajv);
    const i = Object.values(t);
    for (const o of i)
      this.ajv.addSchema(o);
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
  }
  buildValidatorFunction({
    schema: t
    /*, method, url, httpPart */
  }) {
    if (t.$id) {
      const r = this.ajv.getSchema(t.$id);
      if (r)
        return r;
    }
    return this.ajv.compile(t);
  }
}
var YH = KH;
const JH = R$, XH = $$;
class ZH {
  constructor(t, r) {
    this.ajv = new JH(Object.assign({}, XH, r));
  }
  buildSerializerFunction({
    schema: t
    /*, method, url, httpStatus */
  }) {
    return this.ajv.compileSerializer(t);
  }
}
var QH = ZH, Oh = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = Ml, n = qs;
  function i(s, o) {
    if (!s.opts.code.source)
      throw new Error("moduleCode: ajv instance must have code.source option");
    const { _n: a } = s.scope.opts;
    return typeof o == "function" ? u(o.source) : o !== void 0 ? l(o, c) : l(s.schemas, (m) => m.meta ? void 0 : s.compile(m.schema));
    function c(m) {
      const p = s.getSchema(m);
      if (!p)
        throw new Error(`moduleCode: no schema with id ${m}`);
      return p;
    }
    function u(m) {
      const p = {}, d = m == null ? void 0 : m.validateName, h = f(p, m);
      return s.opts.code.esm ? `"use strict";${a}export const validate = ${d};${a}export default ${d};${a}${h}` : `"use strict";${a}module.exports = ${d};${a}module.exports.default = ${d};${a}${h}`;
    }
    function l(m, p) {
      var d;
      const h = {};
      let _ = (0, n._)`"use strict";`;
      for (const g in m) {
        const v = p(m[g]);
        if (v) {
          const y = f(h, v.source), E = s.opts.code.esm ? (0, n._)`export const ${(0, n.getEsmExportName)(g)}` : (0, n._)`exports${(0, n.getProperty)(g)}`;
          _ = (0, n._)`${_}${a}${E} = ${(d = v.source) === null || d === void 0 ? void 0 : d.validateName};${a}${y}`;
        }
      }
      return `${_}`;
    }
    function f(m, p) {
      if (!p)
        throw new Error('moduleCode: function does not have "source" property');
      if (g(p.validateName) === r.UsedValueState.Completed)
        return n.nil;
      v(p.validateName, r.UsedValueState.Started);
      const d = s.scope.scopeCode(p.scopeValues, m, _), h = new n._Code(`${d}${a}${p.validateCode}`);
      return p.evaluated ? (0, n._)`${h}${p.validateName}.evaluated = ${p.evaluated};${a}` : h;
      function _(y) {
        var E;
        const R = (E = y.value) === null || E === void 0 ? void 0 : E.ref;
        if (y.prefix === "validate" && typeof R == "function")
          return f(m, R.source);
        if ((y.prefix === "root" || y.prefix === "wrapper") && typeof R == "object") {
          const { validate: w, validateName: C } = R;
          if (!C)
            throw new Error("ajv internal error");
          const V = s.opts.code.es5 ? r.varKinds.var : r.varKinds.const, b = (0, n._)`${V} ${y} = {validate: ${C}};`;
          if (g(C) === r.UsedValueState.Started)
            return b;
          const F = f(m, w == null ? void 0 : w.source);
          return (0, n._)`${b}${a}${F}`;
        }
      }
      function g(y) {
        var E;
        return (E = m[y.prefix]) === null || E === void 0 ? void 0 : E.get(y);
      }
      function v(y, E) {
        const { prefix: R } = y;
        (m[R] = m[R] || /* @__PURE__ */ new Map()).set(y, E);
      }
    }
  }
  e.exports = t = i, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = i;
})(Oh, Oh.exports);
var eq = Oh.exports, Ud, P_;
function tq() {
  if (P_) return Ud;
  P_ = 1;
  const e = T$(), t = eq.default;
  function r(n = { readMode: !0 }) {
    if (n.readMode === !0 && !n.restoreFunction)
      throw new Error("You must provide a restoreFunction options when readMode ON");
    if (n.readMode !== !0 && !n.storeFunction)
      throw new Error("You must provide a storeFunction options when readMode OFF");
    if (n.readMode === !0)
      return function() {
        return function(o) {
          return n.restoreFunction(o);
        };
      };
    const i = e();
    return function(o, a = {}) {
      (!a.customOptions || !a.customOptions.code) && (a.customOptions = Object.assign({}, a.customOptions, { code: { source: !0 } }));
      const c = i(o, a);
      return function(u) {
        const l = c(u), f = t(c[e.AjvReference].ajv, l);
        return n.storeFunction(u, f), l;
      };
    };
  }
  return Ud = r, Ud;
}
var C_;
function T$() {
  if (C_) return mi.exports;
  C_ = 1;
  const e = Symbol.for("fastify.ajv-compiler.reference"), t = YH, r = QH;
  function n(s) {
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    return s && s.jtdSerializer === !0 ? function(u, l) {
      const f = i({}, l);
      if (a.has(f))
        return a.get(f);
      const m = new r(u, l), p = m.buildSerializerFunction.bind(m);
      return a.set(f, p), p;
    } : function(u, l) {
      const f = i(u, l.customOptions);
      if (o.has(f))
        return o.get(f);
      const m = new t(u, l), p = m.buildValidatorFunction.bind(m);
      return o.set(f, p), l.customOptions.code !== void 0 && (p[e] = m), p;
    };
  }
  function i(s, o) {
    const a = JSON.stringify(s), c = JSON.stringify(o);
    return `${a}${c}`;
  }
  return mi.exports = n, mi.exports.default = n, mi.exports.AjvCompiler = n, mi.exports.AjvReference = e, mi.exports.StandaloneValidator = tq(), mi.exports;
}
const { buildSchemas: rq } = Cu, nq = aM, iq = T$();
function sq(e, t) {
  var i, s;
  if (e)
    return new Yl(e, t);
  const r = Object.assign({
    buildValidator: null,
    buildSerializer: null
  }, t == null ? void 0 : t.compilersFactory);
  r.buildValidator || (r.buildValidator = iq()), r.buildSerializer || (r.buildSerializer = nq());
  const n = {
    bucket: t && t.bucket || rq,
    compilersFactory: r,
    isCustomValidatorCompiler: typeof ((i = t == null ? void 0 : t.compilersFactory) == null ? void 0 : i.buildValidator) == "function",
    isCustomSerializerCompiler: typeof ((s = t == null ? void 0 : t.compilersFactory) == null ? void 0 : s.buildValidator) == "function"
  };
  return new Yl(void 0, n);
}
let Yl = class {
  constructor(t, r) {
    this.opts = r || (t == null ? void 0 : t.opts), this.addedSchemas = !1, this.compilersFactory = this.opts.compilersFactory, t ? (this.schemaBucket = this.opts.bucket(t.getSchemas()), this.validatorCompiler = t.getValidatorCompiler(), this.serializerCompiler = t.getSerializerCompiler(), this.isCustomValidatorCompiler = t.isCustomValidatorCompiler, this.isCustomSerializerCompiler = t.isCustomSerializerCompiler, this.parent = t) : (this.schemaBucket = this.opts.bucket(), this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || !1, this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || !1);
  }
  // Bucket interface
  add(t) {
    return this.addedSchemas = !0, this.schemaBucket.add(t);
  }
  getSchema(t) {
    return this.schemaBucket.getSchema(t);
  }
  getSchemas() {
    return this.schemaBucket.getSchemas();
  }
  setValidatorCompiler(t) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildValidator: () => t }
    ), this.validatorCompiler = t, this.isCustomValidatorCompiler = !0;
  }
  setSerializerCompiler(t) {
    this.compilersFactory = Object.assign(
      {},
      this.compilersFactory,
      { buildSerializer: () => t }
    ), this.serializerCompiler = t, this.isCustomSerializerCompiler = !0;
  }
  getValidatorCompiler() {
    return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
  }
  getSerializerCompiler() {
    return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
  }
  getSerializerBuilder() {
    return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
  }
  getValidatorBuilder() {
    return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
  }
  /**
   * This method will be called when a validator must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupValidator(t) {
    this.validatorCompiler !== void 0 && !this.addedSchemas || (this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), t.ajv));
  }
  /**
   * This method will be called when a serializer must be setup.
   * Do not setup the compiler more than once
   * @param {object} serverOptions the fastify server options
   */
  setupSerializer(t) {
    this.serializerCompiler !== void 0 && !this.addedSchemas || (this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), t.serializerOpts));
  }
};
Yl.buildSchemaController = sq;
var O$ = Yl, P$ = { exports: {} }, Ph = { exports: {} };
const oq = "2.0.0", C$ = 256, aq = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, cq = 16, lq = C$ - 6, uq = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Ku = {
  MAX_LENGTH: C$,
  MAX_SAFE_COMPONENT_LENGTH: cq,
  MAX_SAFE_BUILD_LENGTH: lq,
  MAX_SAFE_INTEGER: aq,
  RELEASE_TYPES: uq,
  SEMVER_SPEC_VERSION: oq,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const fq = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Yu = fq;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: n,
    MAX_LENGTH: i
  } = Ku, s = Yu;
  t = e.exports = {};
  const o = t.re = [], a = t.safeRe = [], c = t.src = [], u = t.safeSrc = [], l = t.t = {};
  let f = 0;
  const m = "[a-zA-Z0-9-]", p = [
    ["\\s", 1],
    ["\\d", i],
    [m, n]
  ], d = (_) => {
    for (const [g, v] of p)
      _ = _.split(`${g}*`).join(`${g}{0,${v}}`).split(`${g}+`).join(`${g}{1,${v}}`);
    return _;
  }, h = (_, g, v) => {
    const y = d(g), E = f++;
    s(_, E, g), l[_] = E, c[E] = g, u[E] = y, o[E] = new RegExp(g, v ? "g" : void 0), a[E] = new RegExp(y, v ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${m}*`), h("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${m}+`), h("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), h("FULL", `^${c[l.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), h("LOOSE", `^${c[l.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), h("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), h("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), h("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), h("COERCERTL", c[l.COERCE], !0), h("COERCERTLFULL", c[l.COERCEFULL], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Ph, Ph.exports);
var Ya = Ph.exports;
const dq = Object.freeze({ loose: !0 }), pq = Object.freeze({}), hq = (e) => e ? typeof e != "object" ? dq : e : pq;
var Qg = hq;
const A_ = /^[0-9]+$/, A$ = (e, t) => {
  const r = A_.test(e), n = A_.test(t);
  return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
}, mq = (e, t) => A$(t, e);
var I$ = {
  compareIdentifiers: A$,
  rcompareIdentifiers: mq
};
const Uc = Yu, { MAX_LENGTH: I_, MAX_SAFE_INTEGER: Mc } = Ku, { safeRe: N_, safeSrc: k_, t: Hc } = Ya, gq = Qg, { compareIdentifiers: os } = I$;
let yq = class Xr {
  constructor(t, r) {
    if (r = gq(r), t instanceof Xr) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > I_)
      throw new TypeError(
        `version is longer than ${I_} characters`
      );
    Uc("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = t.trim().match(r.loose ? N_[Hc.LOOSE] : N_[Hc.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Mc || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Mc || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Mc || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const s = +i;
        if (s >= 0 && s < Mc)
          return s;
      }
      return i;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Uc("SemVer.compare", this.version, this.options, t), !(t instanceof Xr)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new Xr(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof Xr || (t = new Xr(t, this.options)), os(this.major, t.major) || os(this.minor, t.minor) || os(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof Xr || (t = new Xr(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const n = this.prerelease[r], i = t.prerelease[r];
      if (Uc("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return os(n, i);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof Xr || (t = new Xr(t, this.options));
    let r = 0;
    do {
      const n = this.build[r], i = t.build[r];
      if (Uc("build compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return os(n, i);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r, n) {
    if (t.startsWith("pre")) {
      if (!r && n === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (r) {
        const i = new RegExp(`^${this.options.loose ? k_[Hc.PRERELEASELOOSE] : k_[Hc.PRERELEASE]}$`), s = `-${r}`.match(i);
        if (!s || s[1] !== r)
          throw new Error(`invalid identifier: ${r}`);
      }
    }
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const i = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let s = this.prerelease.length;
          for (; --s >= 0; )
            typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
          if (s === -1) {
            if (r === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (r) {
          let s = [r, i];
          n === !1 && (s = [r]), os(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = s) : this.prerelease = s;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var rr = yq;
const D_ = rr, vq = (e, t, r = !1) => {
  if (e instanceof D_)
    return e;
  try {
    return new D_(e, t);
  } catch (n) {
    if (!r)
      return null;
    throw n;
  }
};
var ao = vq;
const _q = ao, bq = (e, t) => {
  const r = _q(e, t);
  return r ? r.version : null;
};
var Eq = bq;
const wq = ao, Sq = (e, t) => {
  const r = wq(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var xq = Sq;
const L_ = rr, Rq = (e, t, r, n, i) => {
  typeof r == "string" && (i = n, n = r, r = void 0);
  try {
    return new L_(
      e instanceof L_ ? e.version : e,
      r
    ).inc(t, n, i).version;
  } catch {
    return null;
  }
};
var $q = Rq;
const F_ = ao, Tq = (e, t) => {
  const r = F_(e, null, !0), n = F_(t, null, !0), i = r.compare(n);
  if (i === 0)
    return null;
  const s = i > 0, o = s ? r : n, a = s ? n : r, c = !!o.prerelease.length;
  if (!!a.prerelease.length && !c) {
    if (!a.patch && !a.minor)
      return "major";
    if (a.compareMain(o) === 0)
      return a.minor && !a.patch ? "minor" : "patch";
  }
  const l = c ? "pre" : "";
  return r.major !== n.major ? l + "major" : r.minor !== n.minor ? l + "minor" : r.patch !== n.patch ? l + "patch" : "prerelease";
};
var Oq = Tq;
const Pq = rr, Cq = (e, t) => new Pq(e, t).major;
var Aq = Cq;
const Iq = rr, Nq = (e, t) => new Iq(e, t).minor;
var kq = Nq;
const Dq = rr, Lq = (e, t) => new Dq(e, t).patch;
var Fq = Lq;
const jq = ao, Uq = (e, t) => {
  const r = jq(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var Mq = Uq;
const j_ = rr, Hq = (e, t, r) => new j_(e, r).compare(new j_(t, r));
var Br = Hq;
const qq = Br, Bq = (e, t, r) => qq(t, e, r);
var zq = Bq;
const Vq = Br, Gq = (e, t) => Vq(e, t, !0);
var Wq = Gq;
const U_ = rr, Kq = (e, t, r) => {
  const n = new U_(e, r), i = new U_(t, r);
  return n.compare(i) || n.compareBuild(i);
};
var ey = Kq;
const Yq = ey, Jq = (e, t) => e.sort((r, n) => Yq(r, n, t));
var Xq = Jq;
const Zq = ey, Qq = (e, t) => e.sort((r, n) => Zq(n, r, t));
var eB = Qq;
const tB = Br, rB = (e, t, r) => tB(e, t, r) > 0;
var Ju = rB;
const nB = Br, iB = (e, t, r) => nB(e, t, r) < 0;
var ty = iB;
const sB = Br, oB = (e, t, r) => sB(e, t, r) === 0;
var N$ = oB;
const aB = Br, cB = (e, t, r) => aB(e, t, r) !== 0;
var k$ = cB;
const lB = Br, uB = (e, t, r) => lB(e, t, r) >= 0;
var ry = uB;
const fB = Br, dB = (e, t, r) => fB(e, t, r) <= 0;
var ny = dB;
const pB = N$, hB = k$, mB = Ju, gB = ry, yB = ty, vB = ny, _B = (e, t, r, n) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return pB(e, r, n);
    case "!=":
      return hB(e, r, n);
    case ">":
      return mB(e, r, n);
    case ">=":
      return gB(e, r, n);
    case "<":
      return yB(e, r, n);
    case "<=":
      return vB(e, r, n);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var D$ = _B;
const bB = rr, EB = ao, { safeRe: qc, t: Bc } = Ya, wB = (e, t) => {
  if (e instanceof bB)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
    r = e.match(t.includePrerelease ? qc[Bc.COERCEFULL] : qc[Bc.COERCE]);
  else {
    const c = t.includePrerelease ? qc[Bc.COERCERTLFULL] : qc[Bc.COERCERTL];
    let u;
    for (; (u = c.exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || u.index + u[0].length !== r.index + r[0].length) && (r = u), c.lastIndex = u.index + u[1].length + u[2].length;
    c.lastIndex = -1;
  }
  if (r === null)
    return null;
  const n = r[2], i = r[3] || "0", s = r[4] || "0", o = t.includePrerelease && r[5] ? `-${r[5]}` : "", a = t.includePrerelease && r[6] ? `+${r[6]}` : "";
  return EB(`${n}.${i}.${s}${o}${a}`, t);
};
var SB = wB;
class xB {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const r = this.map.get(t);
    if (r !== void 0)
      return this.map.delete(t), this.map.set(t, r), r;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, r) {
    if (!this.delete(t) && r !== void 0) {
      if (this.map.size >= this.max) {
        const i = this.map.keys().next().value;
        this.delete(i);
      }
      this.map.set(t, r);
    }
    return this;
  }
}
var RB = xB, Md, M_;
function zr() {
  if (M_) return Md;
  M_ = 1;
  const e = /\s+/g;
  class t {
    constructor(A, P) {
      if (P = i(P), A instanceof t)
        return A.loose === !!P.loose && A.includePrerelease === !!P.includePrerelease ? A : new t(A.raw, P);
      if (A instanceof s)
        return this.raw = A.value, this.set = [[A]], this.formatted = void 0, this;
      if (this.options = P, this.loose = !!P.loose, this.includePrerelease = !!P.includePrerelease, this.raw = A.trim().replace(e, " "), this.set = this.raw.split("||").map((D) => this.parseRange(D.trim())).filter((D) => D.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const D = this.set[0];
        if (this.set = this.set.filter((I) => !h(I[0])), this.set.length === 0)
          this.set = [D];
        else if (this.set.length > 1) {
          for (const I of this.set)
            if (I.length === 1 && _(I[0])) {
              this.set = [I];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let A = 0; A < this.set.length; A++) {
          A > 0 && (this.formatted += "||");
          const P = this.set[A];
          for (let D = 0; D < P.length; D++)
            D > 0 && (this.formatted += " "), this.formatted += P[D].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(A) {
      const D = ((this.options.includePrerelease && p) | (this.options.loose && d)) + ":" + A, I = n.get(D);
      if (I)
        return I;
      const L = this.options.loose, j = L ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      A = A.replace(j, q(this.options.includePrerelease)), o("hyphen replace", A), A = A.replace(c[u.COMPARATORTRIM], l), o("comparator trim", A), A = A.replace(c[u.TILDETRIM], f), o("tilde trim", A), A = A.replace(c[u.CARETTRIM], m), o("caret trim", A);
      let k = A.split(" ").map((N) => v(N, this.options)).join(" ").split(/\s+/).map((N) => H(N, this.options));
      L && (k = k.filter((N) => (o("loose invalid filter", N, this.options), !!N.match(c[u.COMPARATORLOOSE])))), o("range list", k);
      const U = /* @__PURE__ */ new Map(), M = k.map((N) => new s(N, this.options));
      for (const N of M) {
        if (h(N))
          return [N];
        U.set(N.value, N);
      }
      U.size > 1 && U.has("") && U.delete("");
      const T = [...U.values()];
      return n.set(D, T), T;
    }
    intersects(A, P) {
      if (!(A instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((D) => g(D, P) && A.set.some((I) => g(I, P) && D.every((L) => I.every((j) => L.intersects(j, P)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(A) {
      if (!A)
        return !1;
      if (typeof A == "string")
        try {
          A = new a(A, this.options);
        } catch {
          return !1;
        }
      for (let P = 0; P < this.set.length; P++)
        if ($(this.set[P], A, this.options))
          return !0;
      return !1;
    }
  }
  Md = t;
  const r = RB, n = new r(), i = Qg, s = Xu(), o = Yu, a = rr, {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: f,
    caretTrimReplace: m
  } = Ya, { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: d } = Ku, h = (x) => x.value === "<0.0.0-0", _ = (x) => x.value === "", g = (x, A) => {
    let P = !0;
    const D = x.slice();
    let I = D.pop();
    for (; P && D.length; )
      P = D.every((L) => I.intersects(L, A)), I = D.pop();
    return P;
  }, v = (x, A) => (o("comp", x, A), x = w(x, A), o("caret", x), x = E(x, A), o("tildes", x), x = V(x, A), o("xrange", x), x = F(x, A), o("stars", x), x), y = (x) => !x || x.toLowerCase() === "x" || x === "*", E = (x, A) => x.trim().split(/\s+/).map((P) => R(P, A)).join(" "), R = (x, A) => {
    const P = A.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return x.replace(P, (D, I, L, j, k) => {
      o("tilde", x, D, I, L, j, k);
      let U;
      return y(I) ? U = "" : y(L) ? U = `>=${I}.0.0 <${+I + 1}.0.0-0` : y(j) ? U = `>=${I}.${L}.0 <${I}.${+L + 1}.0-0` : k ? (o("replaceTilde pr", k), U = `>=${I}.${L}.${j}-${k} <${I}.${+L + 1}.0-0`) : U = `>=${I}.${L}.${j} <${I}.${+L + 1}.0-0`, o("tilde return", U), U;
    });
  }, w = (x, A) => x.trim().split(/\s+/).map((P) => C(P, A)).join(" "), C = (x, A) => {
    o("caret", x, A);
    const P = A.loose ? c[u.CARETLOOSE] : c[u.CARET], D = A.includePrerelease ? "-0" : "";
    return x.replace(P, (I, L, j, k, U) => {
      o("caret", x, I, L, j, k, U);
      let M;
      return y(L) ? M = "" : y(j) ? M = `>=${L}.0.0${D} <${+L + 1}.0.0-0` : y(k) ? L === "0" ? M = `>=${L}.${j}.0${D} <${L}.${+j + 1}.0-0` : M = `>=${L}.${j}.0${D} <${+L + 1}.0.0-0` : U ? (o("replaceCaret pr", U), L === "0" ? j === "0" ? M = `>=${L}.${j}.${k}-${U} <${L}.${j}.${+k + 1}-0` : M = `>=${L}.${j}.${k}-${U} <${L}.${+j + 1}.0-0` : M = `>=${L}.${j}.${k}-${U} <${+L + 1}.0.0-0`) : (o("no pr"), L === "0" ? j === "0" ? M = `>=${L}.${j}.${k}${D} <${L}.${j}.${+k + 1}-0` : M = `>=${L}.${j}.${k}${D} <${L}.${+j + 1}.0-0` : M = `>=${L}.${j}.${k} <${+L + 1}.0.0-0`), o("caret return", M), M;
    });
  }, V = (x, A) => (o("replaceXRanges", x, A), x.split(/\s+/).map((P) => b(P, A)).join(" ")), b = (x, A) => {
    x = x.trim();
    const P = A.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return x.replace(P, (D, I, L, j, k, U) => {
      o("xRange", x, D, I, L, j, k, U);
      const M = y(L), T = M || y(j), N = T || y(k), G = N;
      return I === "=" && G && (I = ""), U = A.includePrerelease ? "-0" : "", M ? I === ">" || I === "<" ? D = "<0.0.0-0" : D = "*" : I && G ? (T && (j = 0), k = 0, I === ">" ? (I = ">=", T ? (L = +L + 1, j = 0, k = 0) : (j = +j + 1, k = 0)) : I === "<=" && (I = "<", T ? L = +L + 1 : j = +j + 1), I === "<" && (U = "-0"), D = `${I + L}.${j}.${k}${U}`) : T ? D = `>=${L}.0.0${U} <${+L + 1}.0.0-0` : N && (D = `>=${L}.${j}.0${U} <${L}.${+j + 1}.0-0`), o("xRange return", D), D;
    });
  }, F = (x, A) => (o("replaceStars", x, A), x.trim().replace(c[u.STAR], "")), H = (x, A) => (o("replaceGTE0", x, A), x.trim().replace(c[A.includePrerelease ? u.GTE0PRE : u.GTE0], "")), q = (x) => (A, P, D, I, L, j, k, U, M, T, N, G) => (y(D) ? P = "" : y(I) ? P = `>=${D}.0.0${x ? "-0" : ""}` : y(L) ? P = `>=${D}.${I}.0${x ? "-0" : ""}` : j ? P = `>=${P}` : P = `>=${P}${x ? "-0" : ""}`, y(M) ? U = "" : y(T) ? U = `<${+M + 1}.0.0-0` : y(N) ? U = `<${M}.${+T + 1}.0-0` : G ? U = `<=${M}.${T}.${N}-${G}` : x ? U = `<${M}.${T}.${+N + 1}-0` : U = `<=${U}`, `${P} ${U}`.trim()), $ = (x, A, P) => {
    for (let D = 0; D < x.length; D++)
      if (!x[D].test(A))
        return !1;
    if (A.prerelease.length && !P.includePrerelease) {
      for (let D = 0; D < x.length; D++)
        if (o(x[D].semver), x[D].semver !== s.ANY && x[D].semver.prerelease.length > 0) {
          const I = x[D].semver;
          if (I.major === A.major && I.minor === A.minor && I.patch === A.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Md;
}
var Hd, H_;
function Xu() {
  if (H_) return Hd;
  H_ = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, f) {
      if (f = r(f), l instanceof t) {
        if (l.loose === !!f.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, f), this.options = f, this.loose = !!f.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const f = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], m = l.match(f);
      if (!m)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new a(m[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (o("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new a(l, this.options);
        } catch {
          return !1;
        }
      return s(l, this.operator, this.semver, this.options);
    }
    intersects(l, f) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, f).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, f).test(l.semver) : (f = r(f), f.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || s(this.semver, "<", l.semver, f) && this.operator.startsWith(">") && l.operator.startsWith("<") || s(this.semver, ">", l.semver, f) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  Hd = t;
  const r = Qg, { safeRe: n, t: i } = Ya, s = D$, o = Yu, a = rr, c = zr();
  return Hd;
}
const $B = zr(), TB = (e, t, r) => {
  try {
    t = new $B(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var Zu = TB;
const OB = zr(), PB = (e, t) => new OB(e, t).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var CB = PB;
const AB = rr, IB = zr(), NB = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new IB(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === -1) && (n = o, i = new AB(n, r));
  }), n;
};
var kB = NB;
const DB = rr, LB = zr(), FB = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new LB(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === 1) && (n = o, i = new DB(n, r));
  }), n;
};
var jB = FB;
const qd = rr, UB = zr(), q_ = Ju, MB = (e, t) => {
  e = new UB(e, t);
  let r = new qd("0.0.0");
  if (e.test(r) || (r = new qd("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let n = 0; n < e.set.length; ++n) {
    const i = e.set[n];
    let s = null;
    i.forEach((o) => {
      const a = new qd(o.semver.version);
      switch (o.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
          (!s || q_(a, s)) && (s = a);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), s && (!r || q_(r, s)) && (r = s);
  }
  return r && e.test(r) ? r : null;
};
var HB = MB;
const qB = zr(), BB = (e, t) => {
  try {
    return new qB(e, t).range || "*";
  } catch {
    return null;
  }
};
var zB = BB;
const VB = rr, L$ = Xu(), { ANY: GB } = L$, WB = zr(), KB = Zu, B_ = Ju, z_ = ty, YB = ny, JB = ry, XB = (e, t, r, n) => {
  e = new VB(e, n), t = new WB(t, n);
  let i, s, o, a, c;
  switch (r) {
    case ">":
      i = B_, s = YB, o = z_, a = ">", c = ">=";
      break;
    case "<":
      i = z_, s = JB, o = B_, a = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (KB(e, t, n))
    return !1;
  for (let u = 0; u < t.set.length; ++u) {
    const l = t.set[u];
    let f = null, m = null;
    if (l.forEach((p) => {
      p.semver === GB && (p = new L$(">=0.0.0")), f = f || p, m = m || p, i(p.semver, f.semver, n) ? f = p : o(p.semver, m.semver, n) && (m = p);
    }), f.operator === a || f.operator === c || (!m.operator || m.operator === a) && s(e, m.semver))
      return !1;
    if (m.operator === c && o(e, m.semver))
      return !1;
  }
  return !0;
};
var iy = XB;
const ZB = iy, QB = (e, t, r) => ZB(e, t, ">", r);
var e3 = QB;
const t3 = iy, r3 = (e, t, r) => t3(e, t, "<", r);
var n3 = r3;
const V_ = zr(), i3 = (e, t, r) => (e = new V_(e, r), t = new V_(t, r), e.intersects(t, r));
var s3 = i3;
const o3 = Zu, a3 = Br;
var c3 = (e, t, r) => {
  const n = [];
  let i = null, s = null;
  const o = e.sort((l, f) => a3(l, f, r));
  for (const l of o)
    o3(l, t, r) ? (s = l, i || (i = l)) : (s && n.push([i, s]), s = null, i = null);
  i && n.push([i, null]);
  const a = [];
  for (const [l, f] of n)
    l === f ? a.push(l) : !f && l === o[0] ? a.push("*") : f ? l === o[0] ? a.push(`<=${f}`) : a.push(`${l} - ${f}`) : a.push(`>=${l}`);
  const c = a.join(" || "), u = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < u.length ? c : t;
};
const G_ = zr(), sy = Xu(), { ANY: Bd } = sy, To = Zu, oy = Br, l3 = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new G_(e, r), t = new G_(t, r);
  let n = !1;
  e: for (const i of e.set) {
    for (const s of t.set) {
      const o = f3(i, s, r);
      if (n = n || o !== null, o)
        continue e;
    }
    if (n)
      return !1;
  }
  return !0;
}, u3 = [new sy(">=0.0.0-0")], W_ = [new sy(">=0.0.0")], f3 = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === Bd) {
    if (t.length === 1 && t[0].semver === Bd)
      return !0;
    r.includePrerelease ? e = u3 : e = W_;
  }
  if (t.length === 1 && t[0].semver === Bd) {
    if (r.includePrerelease)
      return !0;
    t = W_;
  }
  const n = /* @__PURE__ */ new Set();
  let i, s;
  for (const p of e)
    p.operator === ">" || p.operator === ">=" ? i = K_(i, p, r) : p.operator === "<" || p.operator === "<=" ? s = Y_(s, p, r) : n.add(p.semver);
  if (n.size > 1)
    return null;
  let o;
  if (i && s) {
    if (o = oy(i.semver, s.semver, r), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || s.operator !== "<="))
      return null;
  }
  for (const p of n) {
    if (i && !To(p, String(i), r) || s && !To(p, String(s), r))
      return null;
    for (const d of t)
      if (!To(p, String(d), r))
        return !1;
    return !0;
  }
  let a, c, u, l, f = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1, m = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  f && f.prerelease.length === 1 && s.operator === "<" && f.prerelease[0] === 0 && (f = !1);
  for (const p of t) {
    if (l = l || p.operator === ">" || p.operator === ">=", u = u || p.operator === "<" || p.operator === "<=", i) {
      if (m && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === m.major && p.semver.minor === m.minor && p.semver.patch === m.patch && (m = !1), p.operator === ">" || p.operator === ">=") {
        if (a = K_(i, p, r), a === p && a !== i)
          return !1;
      } else if (i.operator === ">=" && !To(i.semver, String(p), r))
        return !1;
    }
    if (s) {
      if (f && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === f.major && p.semver.minor === f.minor && p.semver.patch === f.patch && (f = !1), p.operator === "<" || p.operator === "<=") {
        if (c = Y_(s, p, r), c === p && c !== s)
          return !1;
      } else if (s.operator === "<=" && !To(s.semver, String(p), r))
        return !1;
    }
    if (!p.operator && (s || i) && o !== 0)
      return !1;
  }
  return !(i && u && !s && o !== 0 || s && l && !i && o !== 0 || m || f);
}, K_ = (e, t, r) => {
  if (!e)
    return t;
  const n = oy(e.semver, t.semver, r);
  return n > 0 ? e : n < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, Y_ = (e, t, r) => {
  if (!e)
    return t;
  const n = oy(e.semver, t.semver, r);
  return n < 0 ? e : n > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var d3 = l3;
const zd = Ya, J_ = Ku, p3 = rr, X_ = I$, h3 = ao, m3 = Eq, g3 = xq, y3 = $q, v3 = Oq, _3 = Aq, b3 = kq, E3 = Fq, w3 = Mq, S3 = Br, x3 = zq, R3 = Wq, $3 = ey, T3 = Xq, O3 = eB, P3 = Ju, C3 = ty, A3 = N$, I3 = k$, N3 = ry, k3 = ny, D3 = D$, L3 = SB, F3 = Xu(), j3 = zr(), U3 = Zu, M3 = CB, H3 = kB, q3 = jB, B3 = HB, z3 = zB, V3 = iy, G3 = e3, W3 = n3, K3 = s3, Y3 = c3, J3 = d3;
var ay = {
  parse: h3,
  valid: m3,
  clean: g3,
  inc: y3,
  diff: v3,
  major: _3,
  minor: b3,
  patch: E3,
  prerelease: w3,
  compare: S3,
  rcompare: x3,
  compareLoose: R3,
  compareBuild: $3,
  sort: T3,
  rsort: O3,
  gt: P3,
  lt: C3,
  eq: A3,
  neq: I3,
  gte: N3,
  lte: k3,
  cmp: D3,
  coerce: L3,
  Comparator: F3,
  Range: j3,
  satisfies: U3,
  toComparators: M3,
  maxSatisfying: H3,
  minSatisfying: q3,
  minVersion: B3,
  validRange: z3,
  outside: V3,
  gtr: G3,
  ltr: W3,
  intersects: K3,
  simplifyRange: Y3,
  subset: J3,
  SemVer: p3,
  re: zd.re,
  src: zd.src,
  tokens: zd.t,
  SEMVER_SPEC_VERSION: J_.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: J_.RELEASE_TYPES,
  compareIdentifiers: X_.compareIdentifiers,
  rcompareIdentifiers: X_.rcompareIdentifiers
};
(function(e) {
  const t = ay, r = Wi, n = Symbol.for("registered-plugin"), {
    kTestInternals: i
  } = Ft, { exist: s, existReply: o, existRequest: a } = qx, {
    FST_ERR_PLUGIN_VERSION_MISMATCH: c,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: u,
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: l
  } = Kt, f = /-(?:rc|pre|alpha).+$/u;
  function m(b) {
    return b[Symbol.for("plugin-meta")];
  }
  function p(b) {
    const F = h(b);
    if (F)
      return F;
    const H = require.cache;
    if (H) {
      const q = Object.keys(H);
      for (let $ = 0; $ < q.length; $++) {
        const x = q[$];
        if (H[x].exports === b)
          return x;
      }
    }
    return b.name ? b.name : null;
  }
  function d(b) {
    return b.toString().split(`
`, 2).map((F) => F.trim()).join(" -- ");
  }
  function h(b) {
    return b[Symbol.for("fastify.display-name")];
  }
  function _(b) {
    return !!b[Symbol.for("skip-override")];
  }
  function g(b) {
    const F = m(b);
    if (!F) return;
    const H = F.dependencies;
    H && (r(Array.isArray(H), "The dependencies should be an array of strings"), H.forEach((q) => {
      r(
        this[n].indexOf(q) > -1,
        `The dependency '${q}' of plugin '${F.name}' is not registered`
      );
    }));
  }
  function v(b) {
    const F = m(b);
    if (!F) return;
    const { decorators: H, name: q } = F;
    H && (H.fastify && E(this, "Fastify", H.fastify, q), H.reply && E(this, "Reply", H.reply, q), H.request && E(this, "Request", H.request, q));
  }
  const y = {
    Fastify: s,
    Request: a,
    Reply: o
  };
  function E(b, F, H, q) {
    r(Array.isArray(H), "The decorators should be an array of strings"), H.forEach(($) => {
      const x = typeof q == "string" ? ` required by '${q}'` : "";
      if (!y[F].call(b, $))
        throw new u($, x, F);
    });
  }
  function R(b) {
    const F = m(b);
    if ((F == null ? void 0 : F.fastify) == null) return;
    const H = F.fastify, q = f.test(this.version);
    if (!(q === !0 && t.gt(this.version, t.coerce(H)) === !0) && H && t.satisfies(this.version, H, { includePrerelease: q }) === !1)
      throw new c(F.name, H, this.version);
  }
  function w(b) {
    const F = m(b);
    if (!F) return;
    const H = F.name;
    if (H)
      return this[n].push(H), H;
  }
  function C(b, F) {
    if (b.constructor.name === "AsyncFunction" && b.length === 3)
      throw new l(F);
  }
  function V(b) {
    const F = w.call(this, b) || p(b);
    return C.call(this, b, F), R.call(this, b), v.call(this, b), g.call(this, b), _(b);
  }
  e.exports = {
    getPluginName: p,
    getFuncPreview: d,
    kRegisteredPlugins: n,
    getDisplayName: h,
    registerPlugin: V
  }, e.exports[i] = {
    shouldSkipOverride: _,
    getMeta: m,
    checkDecorators: v,
    checkDependencies: g
  };
})(P$);
var F$ = P$.exports;
function X3(e, t) {
  const r = t || Q3();
  return e ? ez(e, r) : r;
}
function Z3(e, t) {
  return e.genReqId(t);
}
function Q3() {
  let t = 0;
  return function() {
    return t = t + 1 & 2147483647, `req-${t.toString(36)}`;
  };
}
function ez(e, t) {
  return function(r) {
    return r.headers[e] || t(r);
  };
}
var cy = {
  getGenReqId: Z3,
  reqIdGenFactory: X3
}, Ja = { exports: {} }, Z_ = 12, tz = 0, Vd = [
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
function rz(e) {
  var t = e.indexOf("%");
  if (t === -1) return e;
  for (var r = e.length, n = "", i = 0, s = 0, o = t, a = Z_; t > -1 && t < r; ) {
    var c = Q_(e[t + 1], 4), u = Q_(e[t + 2], 0), l = c | u, f = Vd[l];
    if (a = Vd[256 + a + f], s = s << 6 | l & Vd[364 + f], a === Z_)
      n += e.slice(i, o), n += s <= 65535 ? String.fromCharCode(s) : String.fromCharCode(
        55232 + (s >> 10),
        56320 + (s & 1023)
      ), s = 0, i = t + 3, t = o = e.indexOf("%", i);
    else {
      if (a === tz)
        return null;
      if (t += 3, t < r && e.charCodeAt(t) === 37) continue;
      return null;
    }
  }
  return n + e.slice(i);
}
var nz = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
function Q_(e, t) {
  var r = nz[e];
  return r === void 0 ? 255 : r << t;
}
var iz = rz;
const eb = iz, tb = /\+/g, j$ = function() {
};
j$.prototype = /* @__PURE__ */ Object.create(null);
function sz(e) {
  const t = new j$();
  if (typeof e != "string")
    return t;
  let r = e.length, n = "", i = "", s = -1, o = -1, a = !1, c = !1, u = !1, l = !1, f = !1, m = 0;
  for (let p = 0; p < r + 1; p++)
    if (m = p !== r ? e.charCodeAt(p) : 38, m === 38) {
      if (f = o > s, f || (o = p), n = e.slice(s + 1, o), f || n.length > 0) {
        u && (n = n.replace(tb, " ")), a && (n = eb(n) || n), f && (i = e.slice(o + 1, p), l && (i = i.replace(tb, " ")), c && (i = eb(i) || i));
        const d = t[n];
        d === void 0 ? t[n] = i : d.pop ? d.push(i) : t[n] = [d, i];
      }
      i = "", s = p, o = p, a = !1, c = !1, u = !1, l = !1;
    } else m === 61 ? o <= s ? o = p : c = !0 : m === 43 ? o > s ? l = !0 : u = !0 : m === 37 && (o > s ? c = !0 : a = !0);
  return t;
}
var oz = sz;
const Kr = Array.from(
  { length: 256 },
  (e, t) => "%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase()
), az = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  // 80 - 95
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
  // 112 - 127
]);
function cz(e) {
  const t = e.length;
  if (t === 0) return "";
  let r = "", n = 0, i = 0;
  e: for (; i < t; i++) {
    let s = e.charCodeAt(i);
    for (; s < 128; ) {
      if (az[s] !== 1 && (n < i && (r += e.slice(n, i)), n = i + 1, r += Kr[s]), ++i === t) break e;
      s = e.charCodeAt(i);
    }
    if (n < i && (r += e.slice(n, i)), s < 2048) {
      n = i + 1, r += Kr[192 | s >> 6] + Kr[128 | s & 63];
      continue;
    }
    if (s < 55296 || s >= 57344) {
      n = i + 1, r += Kr[224 | s >> 12] + Kr[128 | s >> 6 & 63] + Kr[128 | s & 63];
      continue;
    }
    if (++i, i >= t)
      throw new Error("URI malformed");
    const o = e.charCodeAt(i) & 1023;
    n = i + 1, s = 65536 + ((s & 1023) << 10 | o), r += Kr[240 | s >> 18] + Kr[128 | s >> 12 & 63] + Kr[128 | s >> 6 & 63] + Kr[128 | s & 63];
  }
  return n === 0 ? e : n < t ? r + e.slice(n) : r;
}
var lz = { encodeString: cz };
const { encodeString: Ch } = lz;
function rb(e) {
  const t = typeof e;
  return t === "string" ? Ch(e) : t === "bigint" ? e.toString() : t === "boolean" ? e ? "true" : "false" : t === "number" && Number.isFinite(e) ? e < 1e21 ? "" + e : Ch("" + e) : "";
}
function uz(e) {
  let t = "";
  if (e === null || typeof e != "object")
    return t;
  const r = "&", n = Object.keys(e), i = n.length;
  let s = 0;
  for (let o = 0; o < i; o++) {
    const a = n[o], c = e[a], u = Ch(a) + "=";
    if (o && (t += r), Array.isArray(c)) {
      s = c.length;
      for (let l = 0; l < s; l++)
        l && (t += r), t += u, t += rb(c[l]);
    } else
      t += u, t += rb(c);
  }
  return t;
}
var fz = uz;
const U$ = oz, M$ = fz, H$ = {
  parse: U$,
  stringify: M$
};
Ja.exports = H$;
Ja.exports.default = H$;
Ja.exports.parse = U$;
Ja.exports.stringify = M$;
var dz = Ja.exports, Qu = { exports: {} }, Ah = { exports: {} }, En = {}, q$ = {};
Object.defineProperty(q$, "__esModule", { value: !0 });
var B$ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.types = void 0, function(t) {
    t[t.ROOT = 0] = "ROOT", t[t.GROUP = 1] = "GROUP", t[t.POSITION = 2] = "POSITION", t[t.SET = 3] = "SET", t[t.RANGE = 4] = "RANGE", t[t.REPETITION = 5] = "REPETITION", t[t.REFERENCE = 6] = "REFERENCE", t[t.CHAR = 7] = "CHAR";
  }(e.types || (e.types = {}));
})(B$);
var z$ = {};
Object.defineProperty(z$, "__esModule", { value: !0 });
(function(e) {
  var t = me && me.__createBinding || (Object.create ? function(n, i, s, o) {
    o === void 0 && (o = s), Object.defineProperty(n, o, { enumerable: !0, get: function() {
      return i[s];
    } });
  } : function(n, i, s, o) {
    o === void 0 && (o = s), n[o] = i[s];
  }), r = me && me.__exportStar || function(n, i) {
    for (var s in n) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, n, s);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(q$, e), r(B$, e), r(z$, e);
})(En);
var la = {}, zs = {}, wt = {};
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.anyChar = wt.notWhitespace = wt.whitespace = wt.notInts = wt.ints = wt.notWords = wt.words = void 0;
const ke = En, V$ = () => [{ type: ke.types.RANGE, from: 48, to: 57 }], G$ = () => [
  { type: ke.types.CHAR, value: 95 },
  { type: ke.types.RANGE, from: 97, to: 122 },
  { type: ke.types.RANGE, from: 65, to: 90 },
  { type: ke.types.RANGE, from: 48, to: 57 }
], W$ = () => [
  { type: ke.types.CHAR, value: 9 },
  { type: ke.types.CHAR, value: 10 },
  { type: ke.types.CHAR, value: 11 },
  { type: ke.types.CHAR, value: 12 },
  { type: ke.types.CHAR, value: 13 },
  { type: ke.types.CHAR, value: 32 },
  { type: ke.types.CHAR, value: 160 },
  { type: ke.types.CHAR, value: 5760 },
  { type: ke.types.RANGE, from: 8192, to: 8202 },
  { type: ke.types.CHAR, value: 8232 },
  { type: ke.types.CHAR, value: 8233 },
  { type: ke.types.CHAR, value: 8239 },
  { type: ke.types.CHAR, value: 8287 },
  { type: ke.types.CHAR, value: 12288 },
  { type: ke.types.CHAR, value: 65279 }
], pz = () => [
  { type: ke.types.CHAR, value: 10 },
  { type: ke.types.CHAR, value: 13 },
  { type: ke.types.CHAR, value: 8232 },
  { type: ke.types.CHAR, value: 8233 }
];
wt.words = () => ({ type: ke.types.SET, set: G$(), not: !1 });
wt.notWords = () => ({ type: ke.types.SET, set: G$(), not: !0 });
wt.ints = () => ({ type: ke.types.SET, set: V$(), not: !1 });
wt.notInts = () => ({ type: ke.types.SET, set: V$(), not: !0 });
wt.whitespace = () => ({ type: ke.types.SET, set: W$(), not: !1 });
wt.notWhitespace = () => ({ type: ke.types.SET, set: W$(), not: !0 });
wt.anyChar = () => ({ type: ke.types.SET, set: pz(), not: !0 });
var hz = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), mz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), gz = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && hz(t, e, r);
  return mz(t, e), t;
};
Object.defineProperty(zs, "__esModule", { value: !0 });
zs.tokenizeClass = zs.strToChars = void 0;
const nb = En, as = gz(wt), yz = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
zs.strToChars = (e) => {
  const t = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
  return e.replace(t, (r, n, i, s, o, a, c) => {
    if (i)
      return r;
    let u = n ? 8 : s ? parseInt(s, 16) : o ? parseInt(o, 16) : a ? yz.indexOf(a) : {
      0: 0,
      t: 9,
      n: 10,
      v: 11,
      f: 12,
      r: 13
    }[c], l = String.fromCharCode(u);
    return /[[\]{}^$.|?*+()]/.test(l) ? `\\${l}` : l;
  });
};
zs.tokenizeClass = (e, t) => {
  var r, n, i, s, o, a, c;
  let u = [], l, f;
  const m = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (l = m.exec(e)) !== null; ) {
    const p = (c = (a = (o = (s = (i = (n = (r = l[1] && as.words()) !== null && r !== void 0 ? r : l[2] && as.ints()) !== null && n !== void 0 ? n : l[3] && as.whitespace()) !== null && i !== void 0 ? i : l[4] && as.notWords()) !== null && s !== void 0 ? s : l[5] && as.notInts()) !== null && o !== void 0 ? o : l[6] && as.notWhitespace()) !== null && a !== void 0 ? a : l[7] && {
      type: nb.types.RANGE,
      from: (l[8] || l[9]).charCodeAt(0),
      to: (f = l[10]).charCodeAt(f.length - 1)
    }) !== null && c !== void 0 ? c : (f = l[16]) && { type: nb.types.CHAR, value: f.charCodeAt(0) };
    if (p)
      u.push(p);
    else
      return [u, m.lastIndex];
  }
  throw new SyntaxError(`Invalid regular expression: /${t}/: Unterminated character class`);
};
var vz = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), _z = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), K$ = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && vz(t, e, r);
  return _z(t, e), t;
};
Object.defineProperty(la, "__esModule", { value: !0 });
la.tokenizer = void 0;
const ib = K$(zs), Ct = En, gi = K$(wt), bz = /^[a-zA-Z_$]$/i, Ez = /^[a-zA-Z0-9_$]$/i, sb = /\d/;
la.tokenizer = (e) => {
  let t = 0, r, n = { type: Ct.types.ROOT, stack: [] }, i = n, s = n.stack, o = [], a = [], c = 0;
  const u = (f) => {
    throw new SyntaxError(`Invalid regular expression: /${e}/: Nothing to repeat at column ${f - 1}`);
  };
  let l = ib.strToChars(e);
  for (; t < l.length; )
    switch (r = l[t++]) {
      case "\\":
        if (t === l.length)
          throw new SyntaxError(`Invalid regular expression: /${e}/: \\ at end of pattern`);
        switch (r = l[t++]) {
          case "b":
            s.push({ type: Ct.types.POSITION, value: "b" });
            break;
          case "B":
            s.push({ type: Ct.types.POSITION, value: "B" });
            break;
          case "w":
            s.push(gi.words());
            break;
          case "W":
            s.push(gi.notWords());
            break;
          case "d":
            s.push(gi.ints());
            break;
          case "D":
            s.push(gi.notInts());
            break;
          case "s":
            s.push(gi.whitespace());
            break;
          case "S":
            s.push(gi.notWhitespace());
            break;
          default:
            if (sb.test(r)) {
              let f = r;
              for (; t < l.length && sb.test(l[t]); )
                f += l[t++];
              let m = parseInt(f, 10);
              const p = { type: Ct.types.REFERENCE, value: m };
              s.push(p), a.push({ reference: p, stack: s, index: s.length - 1 });
            } else
              s.push({ type: Ct.types.CHAR, value: r.charCodeAt(0) });
        }
        break;
      case "^":
        s.push({ type: Ct.types.POSITION, value: "^" });
        break;
      case "$":
        s.push({ type: Ct.types.POSITION, value: "$" });
        break;
      case "[": {
        let f;
        l[t] === "^" ? (f = !0, t++) : f = !1;
        let m = ib.tokenizeClass(l.slice(t), e);
        t += m[1], s.push({
          type: Ct.types.SET,
          set: m[0],
          not: f
        });
        break;
      }
      case ".":
        s.push(gi.anyChar());
        break;
      case "(": {
        let f = {
          type: Ct.types.GROUP,
          stack: [],
          remember: !0
        };
        if (l[t] === "?")
          if (r = l[t + 1], t += 2, r === "=")
            f.followedBy = !0, f.remember = !1;
          else if (r === "!")
            f.notFollowedBy = !0, f.remember = !1;
          else if (r === "<") {
            let m = "";
            if (bz.test(l[t]))
              m += l[t], t++;
            else
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            for (; t < l.length && Ez.test(l[t]); )
              m += l[t], t++;
            if (!m)
              throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid capture group name, character '${l[t]}' after '<' at column ${t + 1}`);
            if (l[t] !== ">")
              throw new SyntaxError(`Invalid regular expression: /${e}/: Unclosed capture group name, expected '>', found '${l[t]}' at column ${t + 1}`);
            f.name = m, t++;
          } else if (r === ":")
            f.remember = !1;
          else
            throw new SyntaxError(`Invalid regular expression: /${e}/: Invalid group, character '${r}' after '?' at column ${t - 1}`);
        else
          c += 1;
        s.push(f), o.push(i), i = f, s = f.stack;
        break;
      }
      case ")":
        if (o.length === 0)
          throw new SyntaxError(`Invalid regular expression: /${e}/: Unmatched ) at column ${t - 1}`);
        i = o.pop(), s = i.options ? i.options[i.options.length - 1] : i.stack;
        break;
      case "|": {
        i.options || (i.options = [i.stack], delete i.stack);
        let f = [];
        i.options.push(f), s = f;
        break;
      }
      case "{": {
        let f = /^(\d+)(,(\d+)?)?\}/.exec(l.slice(t)), m, p;
        f !== null ? (s.length === 0 && u(t), m = parseInt(f[1], 10), p = f[2] ? f[3] ? parseInt(f[3], 10) : 1 / 0 : m, t += f[0].length, s.push({
          type: Ct.types.REPETITION,
          min: m,
          max: p,
          value: s.pop()
        })) : s.push({
          type: Ct.types.CHAR,
          value: 123
        });
        break;
      }
      case "?":
        s.length === 0 && u(t), s.push({
          type: Ct.types.REPETITION,
          min: 0,
          max: 1,
          value: s.pop()
        });
        break;
      case "+":
        s.length === 0 && u(t), s.push({
          type: Ct.types.REPETITION,
          min: 1,
          max: 1 / 0,
          value: s.pop()
        });
        break;
      case "*":
        s.length === 0 && u(t), s.push({
          type: Ct.types.REPETITION,
          min: 0,
          max: 1 / 0,
          value: s.pop()
        });
        break;
      default:
        s.push({
          type: Ct.types.CHAR,
          value: r.charCodeAt(0)
        });
    }
  if (o.length !== 0)
    throw new SyntaxError(`Invalid regular expression: /${e}/: Unterminated group`);
  return wz(a, c), n;
};
function wz(e, t) {
  for (const r of e.reverse())
    if (t < r.reference.value) {
      r.reference.type = Ct.types.CHAR;
      const n = r.reference.value.toString();
      if (r.reference.value = parseInt(n, 8), !/^[0-7]+$/.test(n)) {
        let i = 0;
        for (; n[i] !== "8" && n[i] !== "9"; )
          i += 1;
        if (i === 0 ? (r.reference.value = n.charCodeAt(0), i += 1) : r.reference.value = parseInt(n.slice(0, i), 8), n.length > i) {
          const s = r.stack.splice(r.index + 1);
          for (const o of n.slice(i))
            r.stack.push({
              type: Ct.types.CHAR,
              value: o.charCodeAt(0)
            });
          r.stack.push(...s);
        }
      }
    }
}
var Ih = {}, Vs = {}, tn = {}, Sz = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), xz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), Rz = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Sz(t, e, r);
  return xz(t, e), t;
};
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.NOTANYCHAR = tn.WHITESPACE = tn.WORDS = tn.INTS = void 0;
const ef = Rz(wt), ob = En;
function tf(e) {
  let t = {}, r = 0;
  for (const n of e)
    n.type === ob.types.CHAR && (t[n.value] = !0), n.type === ob.types.RANGE && (t[`${n.from}-${n.to}`] = !0), r += 1;
  return {
    lookup: () => Object.assign({}, t),
    len: r
  };
}
tn.INTS = tf(ef.ints().set);
tn.WORDS = tf(ef.words().set);
tn.WHITESPACE = tf(ef.whitespace().set);
tn.NOTANYCHAR = tf(ef.anyChar().set);
var $z = me && me.__createBinding || (Object.create ? function(e, t, r, n) {
  n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function() {
    return t[r];
  } });
} : function(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}), Tz = me && me.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), Oz = me && me.__importStar || function(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && $z(t, e, r);
  return Tz(t, e), t;
};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.writeSetTokens = Vs.setChar = void 0;
const Jl = En, zc = Oz(tn);
function El(e) {
  return e === 94 ? "\\^" : e === 92 ? "\\\\" : e === 93 ? "\\]" : e === 45 ? "\\-" : String.fromCharCode(e);
}
Vs.setChar = El;
function Vc(e, { lookup: t, len: r }) {
  if (r !== e.length)
    return !1;
  const n = t();
  for (const i of e) {
    if (i.type === Jl.types.SET)
      return !1;
    const s = i.type === Jl.types.CHAR ? i.value : `${i.from}-${i.to}`;
    if (n[s])
      n[s] = !1;
    else
      return !1;
  }
  return !0;
}
function Y$(e, t = !1) {
  if (Vc(e.set, zc.INTS))
    return e.not ? "\\D" : "\\d";
  if (Vc(e.set, zc.WORDS))
    return e.not ? "\\W" : "\\w";
  if (e.not && Vc(e.set, zc.NOTANYCHAR))
    return ".";
  if (Vc(e.set, zc.WHITESPACE))
    return e.not ? "\\S" : "\\s";
  let r = "";
  for (let i = 0; i < e.set.length; i++) {
    const s = e.set[i];
    r += Pz(s);
  }
  const n = `${e.not ? "^" : ""}${r}`;
  return t ? n : `[${n}]`;
}
Vs.writeSetTokens = Y$;
function Pz(e) {
  return e.type === Jl.types.CHAR ? El(e.value) : e.type === Jl.types.RANGE ? `${El(e.from)}-${El(e.to)}` : Y$(e, !0);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reconstruct = void 0;
  const t = En, r = Vs, n = (s) => s.map(e.reconstruct).join(""), i = (s) => {
    if ("options" in s)
      return s.options.map(n).join("|");
    if ("stack" in s)
      return n(s.stack);
    throw new Error("options or stack must be Root or Group token");
  };
  e.reconstruct = (s) => {
    switch (s.type) {
      case t.types.ROOT:
        return i(s);
      case t.types.CHAR: {
        const o = String.fromCharCode(s.value);
        return (/[[\\{}$^.|?*+()]/.test(o) ? "\\" : "") + o;
      }
      case t.types.POSITION:
        return s.value === "^" || s.value === "$" ? s.value : `\\${s.value}`;
      case t.types.REFERENCE:
        return `\\${s.value}`;
      case t.types.SET:
        return r.writeSetTokens(s);
      case t.types.GROUP:
        return `(${s.name ? `?<${s.name}>` : s.remember ? "" : s.followedBy ? "?=" : s.notFollowedBy ? "?!" : "?:"}${i(s)})`;
      case t.types.REPETITION: {
        const { min: o, max: a } = s;
        let c;
        return o === 0 && a === 1 ? c = "?" : o === 1 && a === 1 / 0 ? c = "+" : o === 0 && a === 1 / 0 ? c = "*" : a === 1 / 0 ? c = `{${o},}` : o === a ? c = `{${o}}` : c = `{${o},${a}}`, `${e.reconstruct(s.value)}${c}`;
      }
      case t.types.RANGE:
        return `${r.setChar(s.from)}-${r.setChar(s.to)}`;
      default:
        throw new Error(`Invalid token type ${s}`);
    }
  };
})(Ih);
(function(e, t) {
  var r = me && me.__createBinding || (Object.create ? function(a, c, u, l) {
    l === void 0 && (l = u), Object.defineProperty(a, l, { enumerable: !0, get: function() {
      return c[u];
    } });
  } : function(a, c, u, l) {
    l === void 0 && (l = u), a[l] = c[u];
  }), n = me && me.__exportStar || function(a, c) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(c, u) && r(c, a, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.types = void 0;
  const i = En;
  Object.defineProperty(t, "types", { enumerable: !0, get: function() {
    return i.types;
  } }), n(la, t), n(Ih, t);
  const s = la, o = Ih;
  n(En, t), t.default = s.tokenizer, e.exports = s.tokenizer, e.exports.types = i.types, e.exports.reconstruct = o.reconstruct;
})(Ah, Ah.exports);
var Cz = Ah.exports;
const J$ = Cz, Az = J$.types;
function ly(e, t) {
  t || (t = {});
  const r = t.limit === void 0 ? 25 : t.limit;
  Iz(e) ? e = e.source : typeof e != "string" && (e = String(e));
  try {
    e = J$(e);
  } catch {
    return !1;
  }
  let n = 0;
  return function i(s, o) {
    var f;
    let a, c, u;
    if (s.type === Az.REPETITION && (o++, n++, o > 1 || n > r))
      return !1;
    if (s.options) {
      for (a = 0, u = s.options.length; a < u; a++)
        if (c = i({ stack: s.options[a] }, o), !c) return !1;
    }
    const l = s.stack || ((f = s.value) == null ? void 0 : f.stack);
    if (!l) return !0;
    for (a = 0; a < l.length; a++)
      if (c = i(l[a], o), !c) return !1;
    return !0;
  }(e, 0);
}
function Iz(e) {
  return {}.toString.call(e) === "[object RegExp]";
}
Qu.exports = ly;
Qu.exports.default = ly;
Qu.exports.safeRegex = ly;
var Nz = Qu.exports, uy = {
  name: "__fmw_internal_strategy_merged_tree_http_method__",
  storage: function() {
    const e = /* @__PURE__ */ new Map();
    return {
      get: (t) => e.get(t) || null,
      set: (t, r) => {
        e.set(t, r);
      }
    };
  },
  /* c8 ignore next 1 */
  deriveConstraint: (e) => e.method,
  mustMatchWhenDerived: !0
};
const ab = Uu, cb = uy, X$ = Symbol("treeData");
function Z$(e, t = "") {
  let r = "";
  const n = Object.keys(e);
  for (let i = 0; i < n.length; i++) {
    const s = n[i], o = e[s], a = i === n.length - 1, c = a ? "└── " : "├── ", u = a ? "    " : "│   ", f = (o[X$] || "").replaceAll(`
`, `
` + t + u);
    r += t + c + s + f + `
`, r += Z$(o, t + u);
  }
  return r;
}
function kz(e) {
  let t = e.name || "";
  return t = t.replace("bound", "").trim(), t = (t || "anonymous") + "()", t;
}
function Q$(e) {
  return Array.isArray(e) ? e.map((t) => Q$(t)) : typeof e == "symbol" ? e.toString() : typeof e == "function" ? kz(e) : e;
}
function Dz(e, t) {
  if (!t.includeMeta) return {};
  const r = t.buildPrettyMeta(e), n = {};
  let i = t.includeMeta;
  Array.isArray(i) || (i = Reflect.ownKeys(r));
  for (const s of i) {
    if (!Object.prototype.hasOwnProperty.call(r, s)) continue;
    const o = s.toString(), a = r[s];
    if (a != null) {
      const c = JSON.stringify(Q$(a));
      n[o] = c;
    }
  }
  return n;
}
function Lz(e) {
  let t = "";
  for (const [r, n] of Object.entries(e))
    t += `
• (${r}) ${n}`;
  return t;
}
function Fz(e) {
  const t = { ...e.opts.constraints }, r = t[cb.name];
  return delete t[cb.name], { ...e, method: r, opts: { constraints: t } };
}
function jz(e) {
  let t = ` (${e.method})`;
  const r = e.opts.constraints || {};
  return Object.keys(r).length !== 0 && (t += " " + JSON.stringify(r)), t += Lz(e.metaData), t;
}
function Uz(e) {
  return e.reduce((t, r) => {
    for (const n of t)
      if (ab(r.opts.constraints, n.opts.constraints) && ab(r.metaData, n.metaData))
        return n.method += ", " + r.method, t;
    return t.push(r), t;
  }, []);
}
function Mz(e, t, r) {
  let n = e.routes;
  return r.method === void 0 && (n = n.map(Fz)), n = n.map((i) => (i.metaData = Dz(i, r), i)), r.method === void 0 && (n = Uz(n)), n.map(jz).join(`
${t}`);
}
function wl(e, t, r, n) {
  if ((e.isLeafNode || n.commonPrefix !== !1) && (r = r || "(empty root node)", t = t[r] = {}, e.isLeafNode && (t[X$] = Mz(e, r, n)), r = ""), e.staticChildren)
    for (const i of Object.values(e.staticChildren))
      wl(i, t, r + i.prefix, n);
  if (e.parametricChildren)
    for (const i of Object.values(e.parametricChildren)) {
      const s = Array.from(i.nodePaths).join("|");
      wl(i, t, r + s, n);
    }
  e.wildcardChild && wl(e.wildcardChild, t, "*", n);
}
function Hz(e, t) {
  const r = {};
  return wl(e, r, e.prefix, t), Z$(r);
}
var qz = { prettyPrintTree: Hz };
const e1 = function() {
};
e1.prototype = /* @__PURE__ */ Object.create(null);
var Bz = {
  NullObject: e1
};
const { NullObject: zz } = Bz, Vz = uy;
let Gz = class {
  constructor() {
    this.unconstrainedHandler = null, this.constraints = [], this.handlers = [], this.constrainedHandlerStores = null;
  }
  // This is the hot path for node handler finding -- change with care!
  getMatchingHandler(t) {
    return t === void 0 ? this.unconstrainedHandler : this._getHandlerMatchingConstraints(t);
  }
  addHandler(t, r) {
    const n = r.params, i = r.opts.constraints || {}, s = {
      params: n,
      constraints: i,
      handler: r.handler,
      store: r.store || null,
      _createParamsObject: this._compileCreateParamsObject(n)
    }, o = Object.keys(i);
    o.length === 0 && (this.unconstrainedHandler = s);
    for (const c of o)
      this.constraints.includes(c) || (c === "version" ? this.constraints.unshift(c) : this.constraints.push(c));
    const a = o.includes(Vz.name);
    if (!a && this.handlers.length >= 31)
      throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
    this.handlers.push(s), this.handlers.sort((c, u) => Object.keys(c.constraints).length - Object.keys(u.constraints).length), a || this._compileGetHandlerMatchingConstraints(t, i);
  }
  _compileCreateParamsObject(t) {
    const r = [];
    r.push("const fn = function _createParamsObject (paramsArray) {"), r.push("const params = new NullObject()");
    for (let n = 0; n < t.length; n++)
      r.push(`params['${t[n]}'] = paramsArray[${n}]`);
    return r.push("return params"), r.push("}"), r.push("return fn"), new Function("NullObject", r.join(`
`))(zz);
  }
  _getHandlerMatchingConstraints() {
    return null;
  }
  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
  // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
  // The store's implementation comes from the strategies provided to the Router.
  _buildConstraintStore(t, r) {
    for (let n = 0; n < this.handlers.length; n++) {
      const s = this.handlers[n].constraints[r];
      if (s !== void 0) {
        let o = t.get(s) || 0;
        o |= 1 << n, t.set(s, o);
      }
    }
  }
  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
  _constrainedIndexBitmask(t) {
    let r = 0;
    for (let n = 0; n < this.handlers.length; n++)
      this.handlers[n].constraints[t] !== void 0 && (r |= 1 << n);
    return ~r;
  }
  // Compile a fast function to match the handlers for this node
  // The function implements a general case multi-constraint matching algorithm.
  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
  _compileGetHandlerMatchingConstraints(t) {
    this.constrainedHandlerStores = {};
    for (const n of this.constraints) {
      const i = t.newStoreForConstraint(n);
      this.constrainedHandlerStores[n] = i, this._buildConstraintStore(i, n);
    }
    const r = [];
    r.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
    for (const n of this.constraints) {
      r.push(`
      mask = ${this._constrainedIndexBitmask(n)}
      value = derivedConstraints.${n}
      `);
      const s = t.strategies[n].mustMatchWhenDerived ? "matches" : "(matches | mask)";
      r.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${n}.get(value) || 0
        candidates &= ${s}
      }
      if (candidates === 0) return null;
      `);
    }
    for (const n in t.strategies)
      t.strategies[n].mustMatchWhenDerived && !this.constraints.includes(n) && r.push(`if (derivedConstraints.${n} !== undefined) return null`);
    r.push("return this.handlers[Math.floor(Math.log2(candidates))]"), this._getHandlerMatchingConstraints = new Function("derivedConstraints", r.join(`
`));
  }
};
var Wz = Gz;
const Kz = Wz, rf = {
  STATIC: 0,
  PARAMETRIC: 1,
  WILDCARD: 2
};
class t1 {
  constructor() {
    this.isLeafNode = !1, this.routes = null, this.handlerStorage = null;
  }
  addRoute(t, r) {
    this.routes === null && (this.routes = []), this.handlerStorage === null && (this.handlerStorage = new Kz()), this.isLeafNode = !0, this.routes.push(t), this.handlerStorage.addHandler(r, t);
  }
}
class r1 extends t1 {
  constructor() {
    super(), this.staticChildren = {};
  }
  findStaticMatchingChild(t, r) {
    const n = this.staticChildren[t.charAt(r)];
    return n === void 0 || !n.matchPrefix(t, r) ? null : n;
  }
  getStaticChild(t, r = 0) {
    if (t.length === r)
      return this;
    const n = this.findStaticMatchingChild(t, r);
    return n ? n.getStaticChild(t, r + n.prefix.length) : null;
  }
  createStaticChild(t) {
    if (t.length === 0)
      return this;
    let r = this.staticChildren[t.charAt(0)];
    if (r) {
      let i = 1;
      for (; i < r.prefix.length; i++)
        if (t.charCodeAt(i) !== r.prefix.charCodeAt(i)) {
          r = r.split(this, i);
          break;
        }
      return r.createStaticChild(t.slice(i));
    }
    const n = t.charAt(0);
    return this.staticChildren[n] = new n1(t), this.staticChildren[n];
  }
}
let n1 = class i1 extends r1 {
  constructor(t) {
    super(), this.prefix = t, this.wildcardChild = null, this.parametricChildren = [], this.kind = rf.STATIC, this._compilePrefixMatch();
  }
  getParametricChild(t) {
    const r = t && t.source, n = this.parametricChildren.find((i) => (i.regex && i.regex.source) === r);
    return n || null;
  }
  createParametricChild(t, r, n) {
    let i = this.getParametricChild(t);
    return i ? (i.nodePaths.add(n), i) : (i = new Yz(t, r, n), this.parametricChildren.push(i), this.parametricChildren.sort((s, o) => s.isRegex ? o.isRegex ? s.staticSuffix === null ? 1 : o.staticSuffix === null ? -1 : o.staticSuffix.endsWith(s.staticSuffix) ? 1 : s.staticSuffix.endsWith(o.staticSuffix) ? -1 : 0 : -1 : 1), i);
  }
  getWildcardChild() {
    return this.wildcardChild;
  }
  createWildcardChild() {
    return this.wildcardChild = this.getWildcardChild() || new Jz(), this.wildcardChild;
  }
  split(t, r) {
    const n = this.prefix.slice(0, r), i = this.prefix.slice(r);
    this.prefix = i, this._compilePrefixMatch();
    const s = new i1(n);
    return s.staticChildren[i.charAt(0)] = this, t.staticChildren[n.charAt(0)] = s, s;
  }
  getNextNode(t, r, n, i) {
    let s = this.findStaticMatchingChild(t, r), o = 0;
    if (s === null) {
      if (this.parametricChildren.length === 0)
        return this.wildcardChild;
      s = this.parametricChildren[0], o = 1;
    }
    this.wildcardChild !== null && n.push({
      paramsCount: i,
      brotherPathIndex: r,
      brotherNode: this.wildcardChild
    });
    for (let a = this.parametricChildren.length - 1; a >= o; a--)
      n.push({
        paramsCount: i,
        brotherPathIndex: r,
        brotherNode: this.parametricChildren[a]
      });
    return s;
  }
  _compilePrefixMatch() {
    if (this.prefix.length === 1) {
      this.matchPrefix = () => !0;
      return;
    }
    const t = [];
    for (let r = 1; r < this.prefix.length; r++) {
      const n = this.prefix.charCodeAt(r);
      t.push(`path.charCodeAt(i + ${r}) === ${n}`);
    }
    this.matchPrefix = new Function("path", "i", `return ${t.join(" && ")}`);
  }
};
class Yz extends r1 {
  constructor(t, r, n) {
    super(), this.isRegex = !!t, this.regex = t || null, this.staticSuffix = r || null, this.kind = rf.PARAMETRIC, this.nodePaths = /* @__PURE__ */ new Set([n]);
  }
  getNextNode(t, r) {
    return this.findStaticMatchingChild(t, r);
  }
}
class Jz extends t1 {
  constructor() {
    super(), this.kind = rf.WILDCARD;
  }
  getNextNode() {
    return null;
  }
}
var Xz = { StaticNode: n1, NODE_TYPES: rf };
const Zz = Wi;
function ua() {
  if (!(this instanceof ua))
    return new ua();
  this.store = /* @__PURE__ */ new Map(), this.maxMajor = 0, this.maxMinors = {}, this.maxPatches = {};
}
ua.prototype.set = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("Version should be a string");
  let [r, n, i] = e.split(".", 3);
  if (isNaN(r))
    throw new TypeError("Major version must be a numeric value");
  return r = Number(r), n = Number(n) || 0, i = Number(i) || 0, r >= this.maxMajor && (this.maxMajor = r, this.store.set("x", t), this.store.set("*", t), this.store.set("x.x", t), this.store.set("x.x.x", t)), n >= (this.maxMinors[r] || 0) && (this.maxMinors[r] = n, this.store.set(`${r}.x`, t), this.store.set(`${r}.x.x`, t)), i >= (this.maxPatches[`${r}.${n}`] || 0) && (this.maxPatches[`${r}.${n}`] = i, this.store.set(`${r}.${n}.x`, t)), this.store.set(`${r}.${n}.${i}`, t), this;
};
ua.prototype.get = function(e) {
  return this.store.get(e);
};
var Qz = {
  name: "version",
  mustMatchWhenDerived: !0,
  storage: ua,
  validate(e) {
    Zz(typeof e == "string", "Version should be a string");
  }
};
const e4 = Wi;
function t4() {
  const e = /* @__PURE__ */ new Map(), t = [];
  return {
    get: (r) => {
      const n = e.get(r);
      if (n)
        return n;
      for (const i of t)
        if (i.host.test(r))
          return i.value;
    },
    set: (r, n) => {
      r instanceof RegExp ? t.push({ host: r, value: n }) : e.set(r, n);
    }
  };
}
var r4 = {
  name: "host",
  mustMatchWhenDerived: !1,
  storage: t4,
  validate(e) {
    e4(typeof e == "string" || Object.prototype.toString.call(e) === "[object RegExp]", "Host should be a string or a RegExp");
  }
};
const n4 = Qz, i4 = r4, Gd = Wi;
let s4 = class {
  constructor(t) {
    if (this.strategies = {
      version: n4,
      host: i4
    }, this.strategiesInUse = /* @__PURE__ */ new Set(), this.asyncStrategiesInUse = /* @__PURE__ */ new Set(), t)
      for (const r of Object.values(t))
        this.addConstraintStrategy(r);
  }
  isStrategyUsed(t) {
    return this.strategiesInUse.has(t) || this.asyncStrategiesInUse.has(t);
  }
  hasConstraintStrategy(t) {
    const r = this.strategies[t];
    return r !== void 0 ? r.isCustom || this.isStrategyUsed(t) : !1;
  }
  addConstraintStrategy(t) {
    if (Gd(typeof t.name == "string" && t.name !== "", "strategy.name is required."), Gd(t.storage && typeof t.storage == "function", "strategy.storage function is required."), Gd(t.deriveConstraint && typeof t.deriveConstraint == "function", "strategy.deriveConstraint function is required."), this.strategies[t.name] && this.strategies[t.name].isCustom)
      throw new Error(`There already exists a custom constraint with the name ${t.name}.`);
    if (this.isStrategyUsed(t.name))
      throw new Error(`There already exists a route with ${t.name} constraint.`);
    t.isCustom = !0, t.isAsync = t.deriveConstraint.length === 3, this.strategies[t.name] = t, t.mustMatchWhenDerived && this.noteUsage({ [t.name]: t });
  }
  deriveConstraints(t, r, n) {
    const i = this.deriveSyncConstraints(t, r);
    if (n === void 0)
      return i;
    this.deriveAsyncConstraints(i, t, r, n);
  }
  deriveSyncConstraints(t, r) {
  }
  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
  noteUsage(t) {
    if (t) {
      const r = this.strategiesInUse.size;
      for (const n in t)
        this.strategies[n].isAsync ? this.asyncStrategiesInUse.add(n) : this.strategiesInUse.add(n);
      r !== this.strategiesInUse.size && this._buildDeriveConstraints();
    }
  }
  newStoreForConstraint(t) {
    if (!this.strategies[t])
      throw new Error(`No strategy registered for constraint key ${t}`);
    return this.strategies[t].storage();
  }
  validateConstraints(t) {
    for (const r in t) {
      const n = t[r];
      if (typeof n > "u")
        throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
      const i = this.strategies[r];
      if (!i)
        throw new Error(`No strategy registered for constraint key ${r}`);
      i.validate && i.validate(n);
    }
  }
  deriveAsyncConstraints(t, r, n, i) {
    let s = this.asyncStrategiesInUse.size;
    if (s === 0) {
      i(null, t);
      return;
    }
    t = t || {};
    for (const o of this.asyncStrategiesInUse)
      this.strategies[o].deriveConstraint(r, n, (c, u) => {
        if (c !== null) {
          i(c);
          return;
        }
        t[o] = u, --s === 0 && i(null, t);
      });
  }
  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
  // This allows us to not allocate an object to hold constraint values if no constraints are defined.
  _buildDeriveConstraints() {
    if (this.strategiesInUse.size === 0) return;
    const t = ["return {"];
    for (const r of this.strategiesInUse) {
      const n = this.strategies[r];
      n.isCustom ? t.push(`  ${n.name}: this.strategies.${r}.deriveConstraint(req, ctx),`) : r === "version" ? t.push("   version: req.headers['accept-version'],") : t.push("   host: req.headers.host || req.headers[':authority'],");
    }
    t.push("}"), this.deriveSyncConstraints = new Function("req", "ctx", t.join(`
`)).bind(this);
  }
};
var o4 = s4;
const a4 = [
  "ACL",
  "BIND",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LINK",
  "LOCK",
  "M-SEARCH",
  "MERGE",
  "MKACTIVITY",
  "MKCALENDAR",
  "MKCOL",
  "MOVE",
  "NOTIFY",
  "OPTIONS",
  "PATCH",
  "POST",
  "PROPFIND",
  "PROPPATCH",
  "PURGE",
  "PUT",
  "QUERY",
  "REBIND",
  "REPORT",
  "SEARCH",
  "SOURCE",
  "SUBSCRIBE",
  "TRACE",
  "UNBIND",
  "UNLINK",
  "UNLOCK",
  "UNSUBSCRIBE"
];
var c4 = a4;
function s1(e, t) {
  return e === 50 ? t === 53 ? "%" : t === 51 ? "#" : t === 52 ? "$" : t === 54 ? "&" : t === 66 || t === 98 ? "+" : t === 67 || t === 99 ? "," : t === 70 || t === 102 ? "/" : null : e === 51 ? t === 65 || t === 97 ? ":" : t === 66 || t === 98 ? ";" : t === 68 || t === 100 ? "=" : t === 70 || t === 102 ? "?" : null : e === 52 && t === 48 ? "@" : null;
}
function l4(e, t) {
  let r = !1, n = !1, i = "";
  for (let o = 1; o < e.length; o++) {
    const a = e.charCodeAt(o);
    if (a === 37) {
      const c = e.charCodeAt(o + 1), u = e.charCodeAt(o + 2);
      s1(c, u) === null ? r = !0 : (n = !0, c === 50 && u === 53 && (r = !0, e = e.slice(0, o + 1) + "25" + e.slice(o + 1), o += 2), o += 2);
    } else if (a === 63 || a === 35 || a === 59 && t) {
      i = e.slice(o + 1), e = e.slice(0, o);
      break;
    }
  }
  return { path: r ? decodeURI(e) : e, querystring: i, shouldDecodeParam: n };
}
function u4(e) {
  const t = e.indexOf("%");
  if (t === -1) return e;
  let r = "", n = t;
  for (let i = t; i < e.length; i++)
    if (e.charCodeAt(i) === 37) {
      const s = e.charCodeAt(i + 1), o = e.charCodeAt(i + 2), a = s1(s, o);
      r += e.slice(n, i) + a, n = i + 3;
    }
  return e.slice(0, t) + r + e.slice(n);
}
var f4 = { safeDecodeURI: l4, safeDecodeURIComponent: u4 };
const dt = Wi, d4 = dz, co = Nz, fy = Uu, { prettyPrintTree: p4 } = qz, { StaticNode: lb, NODE_TYPES: ub } = Xz, h4 = o4, Ls = c4, Wd = uy, { safeDecodeURI: m4, safeDecodeURIComponent: fb } = f4, o1 = /^https?:\/\/.*?\//, ki = /(\/:[^/()]*?)\?(\/?)/, a1 = /[.*+?^${}()|[\]\\]/g, c1 = /\/\/+/g;
if (!co(o1))
  throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
if (!co(ki))
  throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
if (!co(a1))
  throw new Error("the ESCAPE_REGEXP is not safe, update this module");
if (!co(c1))
  throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
function at(e) {
  if (!(this instanceof at))
    return new at(e);
  e = e || {}, this._opts = e, e.defaultRoute ? (dt(typeof e.defaultRoute == "function", "The default route must be a function"), this.defaultRoute = e.defaultRoute) : this.defaultRoute = null, e.onBadUrl ? (dt(typeof e.onBadUrl == "function", "The bad url handler must be a function"), this.onBadUrl = e.onBadUrl) : this.onBadUrl = null, e.buildPrettyMeta ? (dt(typeof e.buildPrettyMeta == "function", "buildPrettyMeta must be a function"), this.buildPrettyMeta = e.buildPrettyMeta) : this.buildPrettyMeta = g4, e.querystringParser ? (dt(typeof e.querystringParser == "function", "querystringParser must be a function"), this.querystringParser = e.querystringParser) : this.querystringParser = (t) => t.length === 0 ? {} : d4.parse(t), this.caseSensitive = e.caseSensitive === void 0 ? !0 : e.caseSensitive, this.ignoreTrailingSlash = e.ignoreTrailingSlash || !1, this.ignoreDuplicateSlashes = e.ignoreDuplicateSlashes || !1, this.maxParamLength = e.maxParamLength || 100, this.allowUnsafeRegex = e.allowUnsafeRegex || !1, this.constrainer = new h4(e.constraints), this.useSemicolonDelimiter = e.useSemicolonDelimiter || !1, this.routes = [], this.trees = {};
}
at.prototype.on = function(t, r, n, i, s) {
  typeof n == "function" && (i !== void 0 && (s = i), i = n, n = {}), dt(typeof r == "string", "Path should be a string"), dt(r.length > 0, "The path could not be empty"), dt(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), dt(typeof i == "function", "Handler should be a function");
  const o = r.match(ki);
  if (o) {
    dt(r.length === o.index + o[0].length, "Optional Parameter needs to be the last parameter of the path");
    const u = r.replace(ki, "$1$2"), l = r.replace(ki, "$2") || "/";
    this.on(t, u, n, i, s), this.on(t, l, n, i, s);
    return;
  }
  const a = r;
  this.ignoreDuplicateSlashes && (r = dy(r)), this.ignoreTrailingSlash && (r = py(r));
  const c = Array.isArray(t) ? t : [t];
  for (const u of c)
    dt(typeof u == "string", "Method should be a string"), dt(Ls.includes(u), `Method '${u}' is not an http method.`), this._on(u, r, n, i, s, a);
};
at.prototype._on = function(t, r, n, i, s) {
  let o = {};
  n.constraints !== void 0 && (dt(typeof n.constraints == "object" && n.constraints !== null, "Constraints should be an object"), Object.keys(n.constraints).length !== 0 && (o = n.constraints)), this.constrainer.validateConstraints(o), this.constrainer.noteUsage(o), this.trees[t] === void 0 && (this.trees[t] = new lb("/"));
  let a = r;
  if (a === "*" && this.trees[t].prefix.length !== 0) {
    const m = this.trees[t];
    this.trees[t] = new lb(""), this.trees[t].staticChildren["/"] = m;
  }
  let c = this.trees[t], u = c.prefix.length;
  const l = [];
  for (let m = 0; m <= a.length; m++) {
    if (a.charCodeAt(m) === 58 && a.charCodeAt(m + 1) === 58) {
      m++;
      continue;
    }
    const p = a.charCodeAt(m) === 58 && a.charCodeAt(m + 1) !== 58, d = a.charCodeAt(m) === 42;
    if (p || d || m === a.length && m !== u) {
      let h = a.slice(u, m);
      this.caseSensitive || (h = h.toLowerCase()), h = h.replaceAll("::", ":"), h = h.replaceAll("%", "%25"), c = c.createStaticChild(h);
    }
    if (p) {
      let h = !1, _ = !0, g = "";
      const v = [];
      let y = m + 1;
      for (let E = y; ; E++) {
        const R = a.charCodeAt(E), w = R === 40, C = R === 45 || R === 46, V = R === 47 || E === a.length;
        if (w || C || V) {
          const b = a.slice(y, E);
          if (l.push(b), h = h || w || C, w) {
            const q = d1(a, E), $ = a.slice(E, q + 1);
            this.allowUnsafeRegex || dt(co(new RegExp($)), `The regex '${$}' is not safe!`), v.push(f1($)), E = q + 1, _ = !0;
          } else
            v.push(_ ? "(.*?)" : `(${g}|(?:(?!${g}).)*)`), _ = !1;
          const F = E;
          for (; E < a.length; E++) {
            const q = a.charCodeAt(E);
            if (q === 47) break;
            if (q === 58)
              if (a.charCodeAt(E + 1) === 58) E++;
              else break;
          }
          let H = a.slice(F, E);
          if (H && (H = H.replaceAll("::", ":"), H = H.replaceAll("%", "%25"), v.push(g = u1(H))), y = E + 1, V || a.charCodeAt(E) === 47 || E === a.length) {
            const q = h ? "()" + H : H, $ = a.slice(m, E);
            a = a.slice(0, m + 1) + q + a.slice(E), m += q.length;
            const x = h ? new RegExp("^" + v.join("") + "$") : null;
            c = c.createParametricChild(x, H || null, $), u = m + 1;
            break;
          }
        }
      }
    } else if (d && (l.push("*"), c = c.createWildcardChild(), u = m + 1, m !== a.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (a = a.toLowerCase()), a === "*" && (a = "/*");
  for (const m of this.routes) {
    const p = m.opts.constraints || {};
    if (m.method === t && m.pattern === a && fy(p, o))
      throw new Error(`Method '${t}' already declared for route '${a}' with constraints '${JSON.stringify(o)}'`);
  }
  const f = { method: t, path: r, pattern: a, params: l, opts: n, handler: i, store: s };
  this.routes.push(f), c.addRoute(f, this.constrainer);
};
at.prototype.hasRoute = function(t, r, n) {
  return this.findRoute(t, r, n) !== null;
};
at.prototype.findRoute = function(t, r, n = {}) {
  if (this.trees[t] === void 0)
    return null;
  let i = r, s = this.trees[t], o = s.prefix.length;
  for (let a = 0; a <= i.length; a++) {
    if (i.charCodeAt(a) === 58 && i.charCodeAt(a + 1) === 58) {
      a++;
      continue;
    }
    const c = i.charCodeAt(a) === 58 && i.charCodeAt(a + 1) !== 58, u = i.charCodeAt(a) === 42;
    if (c || u || a === i.length && a !== o) {
      let l = i.slice(o, a);
      if (this.caseSensitive || (l = l.toLowerCase()), l = l.replaceAll("::", ":"), l = l.replaceAll("%", "%25"), s = s.getStaticChild(l), s === null)
        return null;
    }
    if (c) {
      let l = !1, f = !0, m = "";
      const p = [];
      let d = a + 1;
      for (let h = d; ; h++) {
        const _ = i.charCodeAt(h), g = _ === 40, v = _ === 45 || _ === 46, y = _ === 47 || h === i.length;
        if (g || v || y) {
          if (i.slice(d, h), l = l || g || v, g) {
            const w = d1(i, h), C = i.slice(h, w + 1);
            this.allowUnsafeRegex || dt(co(new RegExp(C)), `The regex '${C}' is not safe!`), p.push(f1(C)), h = w + 1, f = !1;
          } else
            p.push(f ? "(.*?)" : `(${m}|(?:(?!${m}).)*)`), f = !1;
          const E = h;
          for (; h < i.length; h++) {
            const w = i.charCodeAt(h);
            if (w === 47) break;
            if (w === 58)
              if (i.charCodeAt(h + 1) === 58) h++;
              else break;
          }
          let R = i.slice(E, h);
          if (R && (R = R.replaceAll("::", ":"), R = R.replaceAll("%", "%25"), p.push(m = u1(R))), d = h + 1, y || i.charCodeAt(h) === 47 || h === i.length) {
            const w = l ? "()" + R : R, C = i.slice(a, h);
            i = i.slice(0, a + 1) + w + i.slice(h), a += w.length;
            const V = l ? new RegExp("^" + p.join("") + "$") : null;
            if (s = s.getParametricChild(V, R || null, C), s === null)
              return null;
            o = a + 1;
            break;
          }
        }
      }
    } else if (u && (s = s.getWildcardChild(), o = a + 1, a !== i.length - 1))
      throw new Error("Wildcard must be the last character in the route");
  }
  this.caseSensitive || (i = i.toLowerCase());
  for (const a of this.routes) {
    const c = a.opts.constraints || {};
    if (a.method === t && a.pattern === i && fy(c, n))
      return {
        handler: a.handler,
        store: a.store,
        params: a.params
      };
  }
  return null;
};
at.prototype.hasConstraintStrategy = function(e) {
  return this.constrainer.hasConstraintStrategy(e);
};
at.prototype.addConstraintStrategy = function(e) {
  this.constrainer.addConstraintStrategy(e), this._rebuild(this.routes);
};
at.prototype.reset = function() {
  this.trees = {}, this.routes = [];
};
at.prototype.off = function(t, r, n) {
  dt(typeof r == "string", "Path should be a string"), dt(r.length > 0, "The path could not be empty"), dt(r[0] === "/" || r[0] === "*", "The first character of a path should be `/` or `*`"), dt(
    typeof n > "u" || typeof n == "object" && !Array.isArray(n) && n !== null,
    "Constraints should be an object or undefined."
  );
  const i = r.match(ki);
  if (i) {
    dt(r.length === i.index + i[0].length, "Optional Parameter needs to be the last parameter of the path");
    const o = r.replace(ki, "$1$2"), a = r.replace(ki, "$2");
    this.off(t, o, n), this.off(t, a, n);
    return;
  }
  this.ignoreDuplicateSlashes && (r = dy(r)), this.ignoreTrailingSlash && (r = py(r));
  const s = Array.isArray(t) ? t : [t];
  for (const o of s)
    this._off(o, r, n);
};
at.prototype._off = function(t, r, n) {
  dt(typeof t == "string", "Method should be a string"), dt(Ls.includes(t), `Method '${t}' is not an http method.`);
  function i(c) {
    return t !== c.method || r !== c.path;
  }
  function s(c) {
    return i(c) || !fy(n, c.opts.constraints || {});
  }
  const o = n ? s : i, a = this.routes.filter(o);
  this._rebuild(a);
};
at.prototype.lookup = function(t, r, n, i) {
  if (typeof n == "function" && (i = n, n = void 0), i === void 0) {
    const s = this.constrainer.deriveConstraints(t, n), o = this.find(t.method, t.url, s);
    return this.callHandler(o, t, r, n);
  }
  this.constrainer.deriveConstraints(t, n, (s, o) => {
    if (s !== null) {
      i(s);
      return;
    }
    try {
      const a = this.find(t.method, t.url, o), c = this.callHandler(a, t, r, n);
      i(null, c);
    } catch (a) {
      i(a);
    }
  });
};
at.prototype.callHandler = function(t, r, n, i) {
  return t === null ? this._defaultRoute(r, n, i) : i === void 0 ? t.handler(r, n, t.params, t.store, t.searchParams) : t.handler.call(i, r, n, t.params, t.store, t.searchParams);
};
at.prototype.find = function(t, r, n) {
  let i = this.trees[t];
  if (i === void 0) return null;
  r.charCodeAt(0) !== 47 && (r = r.replace(o1, "/")), this.ignoreDuplicateSlashes && (r = dy(r));
  let s, o, a;
  try {
    s = m4(r, this.useSemicolonDelimiter), r = s.path, o = s.querystring, a = s.shouldDecodeParam;
  } catch {
    return this._onBadUrl(r);
  }
  this.ignoreTrailingSlash && (r = py(r));
  const c = r;
  this.caseSensitive === !1 && (r = r.toLowerCase());
  const u = this.maxParamLength;
  let l = i.prefix.length;
  const f = [], m = r.length, p = [];
  for (; ; ) {
    if (l === m && i.isLeafNode) {
      const g = i.handlerStorage.getMatchingHandler(n);
      if (g !== null)
        return {
          handler: g.handler,
          store: g.store,
          params: g._createParamsObject(f),
          searchParams: this.querystringParser(o)
        };
    }
    let d = i.getNextNode(r, l, p, f.length);
    if (d === null) {
      if (p.length === 0)
        return null;
      const g = p.pop();
      l = g.brotherPathIndex, f.splice(g.paramsCount), d = g.brotherNode;
    }
    if (i = d, i.kind === ub.STATIC) {
      l += i.prefix.length;
      continue;
    }
    if (i.kind === ub.WILDCARD) {
      let g = c.slice(l);
      a && (g = fb(g)), f.push(g), l = m;
      continue;
    }
    let h = c.indexOf("/", l);
    h === -1 && (h = m);
    let _ = c.slice(l, h);
    if (a && (_ = fb(_)), i.isRegex) {
      const g = i.regex.exec(_);
      if (g === null) continue;
      for (let v = 1; v < g.length; v++) {
        const y = g[v];
        if (y.length > u)
          return null;
        f.push(y);
      }
    } else {
      if (_.length > u)
        return null;
      f.push(_);
    }
    l = h;
  }
};
at.prototype._rebuild = function(e) {
  this.reset();
  for (const t of e) {
    const { method: r, path: n, opts: i, handler: s, store: o } = t;
    this._on(r, n, i, s, o);
  }
};
at.prototype._defaultRoute = function(e, t, r) {
  if (this.defaultRoute !== null)
    return r === void 0 ? this.defaultRoute(e, t) : this.defaultRoute.call(r, e, t);
  t.statusCode = 404, t.end();
};
at.prototype._onBadUrl = function(e) {
  if (this.onBadUrl === null)
    return null;
  const t = this.onBadUrl;
  return {
    handler: (r, n, i) => t(e, r, n),
    params: {},
    store: null
  };
};
at.prototype.prettyPrint = function(e = {}) {
  const t = e.method;
  e.buildPrettyMeta = this.buildPrettyMeta.bind(this);
  let r = null;
  if (t === void 0) {
    const { version: n, host: i, ...s } = this.constrainer.strategies;
    s[Wd.name] = Wd;
    const o = new at({ ...this._opts, constraints: s }), a = this.routes.map((c) => {
      const u = {
        ...c.opts.constraints,
        [Wd.name]: c.method
      };
      return { ...c, method: "MERGED", opts: { constraints: u } };
    });
    o._rebuild(a), r = o.trees.MERGED;
  } else
    r = this.trees[t];
  return r == null ? "(empty tree)" : p4(r, e);
};
for (const e in Ls) {
  if (!Ls.hasOwnProperty(e)) continue;
  const t = Ls[e], r = t.toLowerCase();
  at.prototype[r] = function(n, i, s) {
    return this.on(t, n, i, s);
  };
}
at.prototype.all = function(e, t, r) {
  this.on(Ls, e, t, r);
};
var l1 = at;
function u1(e) {
  return e.replace(a1, "\\$&");
}
function dy(e) {
  return e.indexOf("//") !== -1 ? e.replace(c1, "/") : e;
}
function py(e) {
  return e.length > 1 && e.charCodeAt(e.length - 1) === 47 ? e.slice(0, -1) : e;
}
function f1(e) {
  return e.charCodeAt(1) === 94 && (e = e.slice(0, 1) + e.slice(2)), e.charCodeAt(e.length - 2) === 36 && (e = e.slice(0, e.length - 2) + e.slice(e.length - 1)), e;
}
function d1(e, t) {
  let r = 1;
  for (; t < e.length; ) {
    if (t++, e.charCodeAt(t) === 92) {
      t++;
      continue;
    }
    if (e.charCodeAt(t) === 41 ? r-- : e.charCodeAt(t) === 40 && r++, !r) return t;
  }
  throw new TypeError('Invalid regexp expression in "' + e + '"');
}
function g4(e) {
  return e ? e.store ? Object.assign({}, e.store) : {} : {};
}
function Kd(e, t, r, n) {
  if (r === void 0) {
    t.header("content-length", "0"), n(null, null);
    return;
  }
  if (typeof r.resume == "function") {
    r.on("error", (s) => {
      t.log.error({ err: s }, "Error on Stream found for HEAD route");
    }), r.resume(), n(null, null);
    return;
  }
  const i = "" + Buffer.byteLength(r);
  t.header("content-length", i), n(null, null);
}
function y4(e) {
  return e == null ? Kd : Array.isArray(e) ? [...e, Kd] : [e, Kd];
}
var v4 = {
  parseHeadOnSendHandlers: y4
};
const _4 = l1, b4 = Am, db = lx, { onRequestAbortHookRunner: E4, lifecycleHooks: pb, preParsingHookRunner: w4, onTimeoutHookRunner: S4, onRequestHookRunner: x4 } = Yi, { normalizeSchema: R4 } = Cu, { parseHeadOnSendHandlers: $4 } = v4, {
  compileSchemasForValidation: T4,
  compileSchemasForSerialization: O4
} = ax, {
  FST_ERR_SCH_VALIDATION_BUILD: P4,
  FST_ERR_SCH_SERIALIZATION_BUILD: C4,
  FST_ERR_DUPLICATED_ROUTE: A4,
  FST_ERR_INVALID_URL: I4,
  FST_ERR_HOOK_INVALID_HANDLER: hb,
  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: N4,
  FST_ERR_ROUTE_DUPLICATED_HANDLER: k4,
  FST_ERR_ROUTE_HANDLER_NOT_FN: mb,
  FST_ERR_ROUTE_MISSING_HANDLER: D4,
  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: L4,
  FST_ERR_ROUTE_METHOD_INVALID: F4,
  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: j4,
  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: U4,
  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: Yd
} = Kt, {
  kRoutePrefix: M4,
  kSupportedHTTPMethods: Nh,
  kLogLevel: H4,
  kLogSerializers: gb,
  kHooks: yb,
  kSchemaController: q4,
  kOptions: vb,
  kReplySerializerDefault: Jd,
  kReplyIsError: B4,
  kRequestPayloadStream: z4,
  kDisableRequestLogging: V4,
  kSchemaErrorFormatter: G4,
  kErrorHandler: _b,
  kHasBeenDecorated: bb,
  kRequestAcceptVersion: Xd,
  kRouteByFastify: W4,
  kRouteContext: Eb
} = Ft, { buildErrorHandler: K4 } = Au, { createChildLogger: Y4 } = Ou, { getGenReqId: J4 } = cy;
function X4(e) {
  const t = _4(e.config);
  let r, n, i, s, o, a, c, u, l, f, m, p, d = !1;
  return {
    /**
     * @param {import('../fastify').FastifyServerOptions} options
     * @param {*} fastifyArgs
     */
    setup(C, V) {
      r = V.avvio, n = V.fourOhFour, i = V.logger, s = V.hasLogger, o = V.setupResponseListeners, a = V.throwIfAlreadyStarted, m = C.exposeHeadRoutes, c = C.disableRequestLogging, u = C.ignoreTrailingSlash, l = C.ignoreDuplicateSlashes, f = Object.hasOwn(C, "return503OnClosing") ? C.return503OnClosing : !0, p = V.keepAliveConnections;
    },
    routing: t.lookup.bind(t),
    // router func to find the right handler to call
    route: R,
    // configure a route in the fastify instance
    hasRoute: y,
    prepareRoute: v,
    routeHandler: w,
    closeRoutes: () => {
      d = !0;
    },
    printRoutes: t.prettyPrint.bind(t),
    addConstraintStrategy: h,
    hasConstraintStrategy: _,
    isAsyncConstraint: g,
    findRoute: E
  };
  function h(C) {
    return a("Cannot add constraint strategy!"), t.addConstraintStrategy(C);
  }
  function _(C) {
    return t.hasConstraintStrategy(C);
  }
  function g() {
    return t.constrainer.asyncStrategiesInUse.size > 0;
  }
  function v({ method: C, url: V, options: b, handler: F, isFastify: H }) {
    if (typeof V != "string")
      throw new I4(typeof V);
    if (!F && typeof b == "function")
      F = b, b = {};
    else if (F && typeof F == "function") {
      if (Object.prototype.toString.call(b) !== "[object Object]")
        throw new N4(C, V);
      if (b.handler)
        throw typeof b.handler == "function" ? new k4(C, V) : new mb(C, V);
    }
    return b = Object.assign({}, b, {
      method: C,
      url: V,
      path: V,
      handler: F || b && b.handler
    }), R.call(this, { options: b, isFastify: H });
  }
  function y({ options: C }) {
    var b;
    const V = ((b = C.method) == null ? void 0 : b.toUpperCase()) ?? "";
    return t.hasRoute(
      V,
      C.url || "",
      C.constraints
    );
  }
  function E(C) {
    const V = t.find(
      C.method,
      C.url || "",
      C.constraints
    );
    return V ? {
      handler: V.handler,
      params: V.params,
      searchParams: V.searchParams
    } : null;
  }
  function R({ options: C, isFastify: V }) {
    a("Cannot add route!");
    const b = { ...C }, F = b.url || b.path || "";
    if (!b.handler)
      throw new D4(b.method, F);
    if (b.errorHandler !== void 0 && typeof b.errorHandler != "function")
      throw new mb(b.method, F);
    p1(b.bodyLimit);
    const H = b.exposeHeadRoute ?? m;
    let q = !1, $ = !1;
    if (Array.isArray(b.method))
      for (let D = 0; D < b.method.length; ++D)
        b.method[D] = wb.call(this, b.method[D]), Sb.call(this, b.method[D], F, b.schema), q = b.method.includes("GET"), $ = b.method.includes("HEAD");
    else
      b.method = wb.call(this, b.method), Sb.call(this, b.method, F, b.schema), q = b.method === "GET", $ = b.method === "HEAD";
    const x = H && q ? { ...C } : null, A = this[M4];
    if (F === "/" && A.length > 0 && b.method !== "HEAD")
      switch (b.prefixTrailingSlash) {
        case "slash":
          P.call(this, { path: F, isFastify: V });
          break;
        case "no-slash":
          P.call(this, { path: "", isFastify: V });
          break;
        case "both":
        default:
          P.call(this, { path: "", isFastify: V }), u !== !0 && (l !== !0 || !A.endsWith("/")) && P.call(this, { path: F, prefixing: !0, isFastify: V });
      }
    else F[0] === "/" && A.endsWith("/") ? P.call(this, { path: F.slice(1), isFastify: V }) : P.call(this, { path: F, isFastify: V });
    return this;
    function P({ path: D, prefixing: I = !1, isFastify: L = !1 }) {
      const j = A + D;
      if (b.url = j, b.path = j, b.routePath = D, b.prefix = A, b.logLevel = b.logLevel || this[H4], (this[gb] || b.logSerializers) && (b.logSerializers = Object.assign(Object.create(this[gb]), b.logSerializers)), b.attachValidation == null && (b.attachValidation = !1), I === !1)
        for (const G of this[yb].onRoute)
          G.call(this, b);
      for (const G of pb)
        if (b && G in b) {
          if (Array.isArray(b[G]))
            for (const O of b[G]) {
              if (typeof O != "function")
                throw new hb(G, Object.prototype.toString.call(O));
              if (G === "onSend" || G === "preSerialization" || G === "onError" || G === "preParsing") {
                if (O.constructor.name === "AsyncFunction" && O.length === 4)
                  throw new Yd();
              } else if (G === "onRequestAbort") {
                if (O.constructor.name === "AsyncFunction" && O.length !== 1)
                  throw new Yd();
              } else if (O.constructor.name === "AsyncFunction" && O.length === 3)
                throw new Yd();
            }
          else if (b[G] !== void 0 && typeof b[G] != "function")
            throw new hb(G, Object.prototype.toString.call(b[G]));
        }
      const k = b.constraints || {}, U = {
        ...b.config,
        url: j,
        method: b.method
      }, M = new b4({
        schema: b.schema,
        handler: b.handler.bind(this),
        config: U,
        errorHandler: b.errorHandler,
        childLoggerFactory: b.childLoggerFactory,
        bodyLimit: b.bodyLimit,
        logLevel: b.logLevel,
        logSerializers: b.logSerializers,
        attachValidation: b.attachValidation,
        schemaErrorFormatter: b.schemaErrorFormatter,
        replySerializer: this[Jd],
        validatorCompiler: b.validatorCompiler,
        serializerCompiler: b.serializerCompiler,
        exposeHeadRoute: H,
        prefixTrailingSlash: b.prefixTrailingSlash || "both",
        server: this,
        isFastify: L
      }), N = t.findRoute("HEAD", b.url, k) !== null;
      try {
        t.on(b.method, b.url, { constraints: k }, w, M);
      } catch (G) {
        if (!M[W4])
          throw G.message.includes(`Method '${b.method}' already declared for route`) ? new A4(b.method, b.url) : G;
      }
      if (this.after((G, O) => {
        M.errorHandler = b.errorHandler ? K4(this[_b], b.errorHandler) : this[_b], M._parserOptions.limit = b.bodyLimit || null, M.logLevel = b.logLevel, M.logSerializers = b.logSerializers, M.attachValidation = b.attachValidation, M[Jd] = this[Jd], M.schemaErrorFormatter = b.schemaErrorFormatter || this[G4] || M.schemaErrorFormatter, r.once("preReady", () => {
          for (const S of pb) {
            const W = this[yb][S].concat(b[S] || []).map((z) => z.bind(this));
            M[S] = W.length ? W : null;
          }
          for (; !M.Request[bb] && M.Request.parent; )
            M.Request = M.Request.parent;
          for (; !M.Reply[bb] && M.Reply.parent; )
            M.Reply = M.Reply.parent;
          if (n.setContext(this, M), b.schema) {
            M.schema = R4(M.schema, this.initialConfig);
            const S = this[q4];
            !b.validatorCompiler && (b.schema.body || b.schema.headers || b.schema.querystring || b.schema.params) && S.setupValidator(this[vb]);
            try {
              const W = typeof (b == null ? void 0 : b.validatorCompiler) == "function" || S.isCustomValidatorCompiler;
              T4(M, b.validatorCompiler || S.validatorCompiler, W);
            } catch (W) {
              throw new P4(b.method, j, W.message);
            }
            b.schema.response && !b.serializerCompiler && S.setupSerializer(this[vb]);
            try {
              O4(M, b.serializerCompiler || S.serializerCompiler);
            } catch (W) {
              throw new C4(b.method, j, W.message);
            }
          }
        }), O(G);
      }), H && q && !$ && !N) {
        const G = $4(x.onSend);
        v.call(this, { method: "HEAD", url: D, options: { ...x, onSend: G }, isFastify: !0 });
      }
    }
  }
  function w(C, V, b, F, H) {
    const q = J4(F.server, C), $ = {
      level: F.logLevel
    };
    F.logSerializers && ($.serializers = F.logSerializers);
    const x = Y4(F, i, C, q, $);
    if (x[V4] = c, d === !0 && (C.httpVersionMajor !== 2 && V.setHeader("Connection", "close"), f)) {
      const I = {
        "Content-Type": "application/json",
        "Content-Length": "80"
      };
      V.writeHead(503, I), V.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}'), x.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
      return;
    }
    String.prototype.toLowerCase.call(C.headers.connection || "") === "keep-alive" && p.has(C.socket) === !1 && (p.add(C.socket), C.socket.on("close", eV.bind({ keepAliveConnections: p, socket: C.socket }))), C.headers[Xd] !== void 0 && (C.headers["accept-version"] = C.headers[Xd], C.headers[Xd] = void 0);
    const P = new F.Request(q, b, C, H, x, F), D = new F.Reply(V, P, x);
    c === !1 && x.info({ req: P }, "incoming request"), (s === !0 || F.onResponse !== null) && o(D), F.onRequest !== null ? x4(
      F.onRequest,
      P,
      D,
      xb
    ) : xb(null, P, D), F.onRequestAbort !== null && C.on("close", () => {
      C.aborted && E4(
        F.onRequestAbort,
        P,
        Z4.bind(null, D)
      );
    }), F.onTimeout !== null && (P.raw.socket._meta || P.raw.socket.on("timeout", Q4), P.raw.socket._meta = { context: F, request: P, reply: D });
  }
}
function Z4(e, t) {
  t && e.log.error({ err: t }, "onRequestAborted hook failed");
}
function Q4() {
  const { context: e, request: t, reply: r } = this._meta;
  S4(
    e.onTimeout,
    t,
    r,
    tV
  );
}
function wb(e) {
  if (typeof e != "string")
    throw new F4();
  if (e = e.toUpperCase(), !this[Nh].bodyless.has(e) && !this[Nh].bodywith.has(e))
    throw new L4(e);
  return e;
}
function Sb(e, t, r) {
  if (this[Nh].bodyless.has(e) && (r != null && r.body))
    throw new j4(e, t);
}
function p1(e) {
  if (e !== void 0 && (!Number.isInteger(e) || e <= 0))
    throw new U4(e);
}
function xb(e, t, r) {
  if (r.sent !== !0) {
    if (e != null) {
      r[B4] = !0, r.send(e);
      return;
    }
    t[z4] = t.raw, t[Eb].preParsing !== null ? w4(t[Eb].preParsing, t, r, db.bind(t.server)) : db.call(t.server, null, t, r);
  }
}
function eV() {
  this.keepAliveConnections.delete(this.socket);
}
function tV() {
}
var rV = { buildRouting: X4, validateBodyLimitOption: p1 };
const nV = l1, Rb = Rm, $b = Cm, iV = Am, {
  kRoutePrefix: sV,
  kCanSetNotFoundHandler: Oo,
  kFourOhFourLevelInstance: Po,
  kFourOhFourContext: Yr,
  kHooks: oV,
  kErrorHandler: Tb
} = Ft, { lifecycleHooks: aV } = Yi, { buildErrorHandler: cV } = Au, {
  FST_ERR_NOT_FOUND: lV
} = Kt, { createChildLogger: Ob } = Ou, { getGenReqId: Pb } = cy;
function uV(e) {
  const { logger: t, disableRequestLogging: r } = e, n = nV({ onBadUrl: a(), defaultRoute: f });
  let i = null;
  return { router: n, setNotFoundHandler: u, setContext: c, arrange404: s };
  function s(m) {
    m[Po] = m, m[Oo] = !0, n.onBadUrl = n.onBadUrl.bind(m), n.defaultRoute = n.defaultRoute.bind(m);
  }
  function o(m, p) {
    const { url: d, method: h } = m.raw, _ = `Route ${h}:${d} not found`;
    r || m.log.info(_), p.code(404).send({
      message: _,
      error: "Not Found",
      statusCode: 404
    });
  }
  function a() {
    return function(p, d, h) {
      const _ = this[Po][Yr], g = Pb(_.server, d), v = Ob(_, t, d, g), y = new $b(g, null, d, null, v, _), E = new Rb(h, y, v);
      i(y, E);
    };
  }
  function c(m, p) {
    const d = Object.assign({}, m[Yr]);
    d.onSend = p.onSend, p[Yr] = d;
  }
  function u(m, p, d, h) {
    this[Oo] === void 0 && (this[Oo] = !0), this[Yr] === void 0 && (this[Yr] = null);
    const _ = this, g = this[sV] || "/";
    if (this[Oo] === !1)
      throw new Error(`Not found handler already set for Fastify instance with prefix: '${g}'`);
    typeof m == "object" && (m.preHandler && (Array.isArray(m.preHandler) ? m.preHandler = m.preHandler.map((v) => v.bind(_)) : m.preHandler = m.preHandler.bind(_)), m.preValidation && (Array.isArray(m.preValidation) ? m.preValidation = m.preValidation.map((v) => v.bind(_)) : m.preValidation = m.preValidation.bind(_))), typeof m == "function" && (p = m, m = void 0), m = m || {}, p ? (this[Po][Oo] = !1, p = p.bind(this), i = p) : (p = o, i = o), this.after((v, y) => {
      l.call(this, g, m, p, d, h), y(v);
    });
  }
  function l(m, p, d, h, _) {
    const g = new iV({
      schema: p.schema,
      handler: d,
      config: p.config || {},
      server: this
    });
    if (h.once("preReady", () => {
      const v = this[Yr];
      for (const y of aV) {
        const E = this[oV][y].concat(p[y] || []).map((R) => R.bind(this));
        v[y] = E.length ? E : null;
      }
      v.errorHandler = p.errorHandler ? cV(this[Tb], p.errorHandler) : this[Tb];
    }), this[Yr] !== null && m === "/") {
      Object.assign(this[Yr], g);
      return;
    }
    this[Po][Yr] = g, n.all(m + (m.endsWith("/") ? "*" : "/*"), _, g), n.all(m, _, g);
  }
  function f(m, p) {
    const d = this[Po][Yr], h = Pb(d.server, m), _ = Ob(d, t, m, h);
    _.info({ req: m }, "incoming request");
    const g = new $b(h, null, m, null, _, d), v = new Rb(p, g, _);
    g.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it"), g.log.warn(n.prettyPrint()), v.code(404).send(new lV());
  }
}
var fV = uV, nf = { exports: {} }, sf = { exports: {} };
sf.exports = De;
sf.exports.default = De;
const dV = { properties: { connectionTimeout: { type: "integer", default: 0 }, keepAliveTimeout: { type: "integer", default: 72e3 }, forceCloseConnections: { oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }] }, maxRequestsPerSocket: { type: "integer", default: 0, nullable: !0 }, requestTimeout: { type: "integer", default: 0 }, bodyLimit: { type: "integer", default: 1048576 }, caseSensitive: { type: "boolean", default: !0 }, allowUnsafeRegex: { type: "boolean", default: !1 }, http2: { type: "boolean" }, https: { if: { not: { oneOf: [{ type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: !1, required: ["allowHTTP1"], properties: { allowHTTP1: { type: "boolean" } } }] } }, then: { setDefaultValue: !0 } }, ignoreTrailingSlash: { type: "boolean", default: !1 }, ignoreDuplicateSlashes: { type: "boolean", default: !1 }, disableRequestLogging: { type: "boolean", default: !1 }, maxParamLength: { type: "integer", default: 100 }, onProtoPoisoning: { type: "string", default: "error" }, onConstructorPoisoning: { type: "string", default: "error" }, pluginTimeout: { type: "integer", default: 1e4 }, requestIdHeader: { anyOf: [{ type: "boolean" }, { type: "string" }], default: !1 }, requestIdLogLabel: { type: "string", default: "reqId" }, http2SessionTimeout: { type: "integer", default: 72e3 }, exposeHeadRoutes: { type: "boolean", default: !0 }, useSemicolonDelimiter: { type: "boolean", default: !1 }, constraints: { type: "object", additionalProperties: { type: "object", required: ["name", "storage", "validate", "deriveConstraint"], additionalProperties: !0, properties: { name: { type: "string" }, storage: {}, validate: {}, deriveConstraint: {} } } } } }, pV = Object.prototype.hasOwnProperty, hV = new RegExp("idle", "u");
function De(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) {
  let s = null, o = 0;
  if (o === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      e.connectionTimeout === void 0 && (e.connectionTimeout = 0), e.keepAliveTimeout === void 0 && (e.keepAliveTimeout = 72e3), e.maxRequestsPerSocket === void 0 && (e.maxRequestsPerSocket = 0), e.requestTimeout === void 0 && (e.requestTimeout = 0), e.bodyLimit === void 0 && (e.bodyLimit = 1048576), e.caseSensitive === void 0 && (e.caseSensitive = !0), e.allowUnsafeRegex === void 0 && (e.allowUnsafeRegex = !1), e.ignoreTrailingSlash === void 0 && (e.ignoreTrailingSlash = !1), e.ignoreDuplicateSlashes === void 0 && (e.ignoreDuplicateSlashes = !1), e.disableRequestLogging === void 0 && (e.disableRequestLogging = !1), e.maxParamLength === void 0 && (e.maxParamLength = 100), e.onProtoPoisoning === void 0 && (e.onProtoPoisoning = "error"), e.onConstructorPoisoning === void 0 && (e.onConstructorPoisoning = "error"), e.pluginTimeout === void 0 && (e.pluginTimeout = 1e4), e.requestIdHeader === void 0 && (e.requestIdHeader = !1), e.requestIdLogLabel === void 0 && (e.requestIdLogLabel = "reqId"), e.http2SessionTimeout === void 0 && (e.http2SessionTimeout = 72e3), e.exposeHeadRoutes === void 0 && (e.exposeHeadRoutes = !0), e.useSemicolonDelimiter === void 0 && (e.useSemicolonDelimiter = !1);
      const d = o;
      for (const h in e)
        pV.call(dV.properties, h) || delete e[h];
      if (d === o) {
        let h = e.connectionTimeout;
        const _ = o;
        if (!(typeof h == "number" && !(h % 1) && !isNaN(h) && isFinite(h))) {
          let g = typeof h, v;
          if (v === void 0)
            if (g === "boolean" || h === null || g === "string" && h && h == +h && !(h % 1))
              v = +h;
            else
              return De.errors = [{ instancePath: t + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
          v !== void 0 && (h = v, e !== void 0 && (e.connectionTimeout = v));
        }
        var a = _ === o;
        if (a) {
          let g = e.keepAliveTimeout;
          const v = o;
          if (!(typeof g == "number" && !(g % 1) && !isNaN(g) && isFinite(g))) {
            let E = typeof g, R;
            if (R === void 0)
              if (E === "boolean" || g === null || E === "string" && g && g == +g && !(g % 1))
                R = +g;
              else
                return De.errors = [{ instancePath: t + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
            R !== void 0 && (g = R, e !== void 0 && (e.keepAliveTimeout = R));
          }
          var a = v === o;
          if (a) {
            if (e.forceCloseConnections !== void 0) {
              let E = e.forceCloseConnections;
              const R = o, w = o;
              let C = !1, V = null;
              const b = o;
              if (typeof E != "string") {
                let q = typeof E, $;
                if ($ === void 0)
                  if (q == "number" || q == "boolean")
                    $ = "" + E;
                  else if (E === null)
                    $ = "";
                  else {
                    const x = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    s === null ? s = [x] : s.push(x), o++;
                  }
                $ !== void 0 && (E = $, e !== void 0 && (e.forceCloseConnections = $));
              }
              if (o === b && typeof E == "string" && !hV.test(E)) {
                const q = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                s === null ? s = [q] : s.push(q), o++;
              }
              var c = b === o;
              c && (C = !0, V = 0);
              const F = o;
              if (typeof E != "boolean") {
                let q;
                if (q === void 0)
                  if (E === "false" || E === 0 || E === null)
                    q = !1;
                  else if (E === "true" || E === 1)
                    q = !0;
                  else {
                    const $ = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    s === null ? s = [$] : s.push($), o++;
                  }
                q !== void 0 && (E = q, e !== void 0 && (e.forceCloseConnections = q));
              }
              var c = F === o;
              if (c && C ? (C = !1, V = [V, 1]) : c && (C = !0, V = 1), C)
                o = w, s !== null && (w ? s.length = w : s = null);
              else {
                const q = { instancePath: t + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: V }, message: "must match exactly one schema in oneOf" };
                return s === null ? s = [q] : s.push(q), o++, De.errors = s, !1;
              }
              var a = R === o;
            } else
              var a = !0;
            if (a) {
              let E = e.maxRequestsPerSocket;
              const R = o;
              if (!(typeof E == "number" && !(E % 1) && !isNaN(E) && isFinite(E)) && E !== null) {
                let C = typeof E, V;
                if (V === void 0)
                  if (C === "boolean" || E === null || C === "string" && E && E == +E && !(E % 1))
                    V = +E;
                  else if (E === "" || E === 0 || E === !1)
                    V = null;
                  else
                    return De.errors = [{ instancePath: t + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                V !== void 0 && (E = V, e !== void 0 && (e.maxRequestsPerSocket = V));
              }
              var a = R === o;
              if (a) {
                let C = e.requestTimeout;
                const V = o;
                if (!(typeof C == "number" && !(C % 1) && !isNaN(C) && isFinite(C))) {
                  let F = typeof C, H;
                  if (H === void 0)
                    if (F === "boolean" || C === null || F === "string" && C && C == +C && !(C % 1))
                      H = +C;
                    else
                      return De.errors = [{ instancePath: t + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                  H !== void 0 && (C = H, e !== void 0 && (e.requestTimeout = H));
                }
                var a = V === o;
                if (a) {
                  let F = e.bodyLimit;
                  const H = o;
                  if (!(typeof F == "number" && !(F % 1) && !isNaN(F) && isFinite(F))) {
                    let $ = typeof F, x;
                    if (x === void 0)
                      if ($ === "boolean" || F === null || $ === "string" && F && F == +F && !(F % 1))
                        x = +F;
                      else
                        return De.errors = [{ instancePath: t + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                    x !== void 0 && (F = x, e !== void 0 && (e.bodyLimit = x));
                  }
                  var a = H === o;
                  if (a) {
                    let $ = e.caseSensitive;
                    const x = o;
                    if (typeof $ != "boolean") {
                      let P;
                      if (P === void 0)
                        if ($ === "false" || $ === 0 || $ === null)
                          P = !1;
                        else if ($ === "true" || $ === 1)
                          P = !0;
                        else
                          return De.errors = [{ instancePath: t + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                      P !== void 0 && ($ = P, e !== void 0 && (e.caseSensitive = P));
                    }
                    var a = x === o;
                    if (a) {
                      let P = e.allowUnsafeRegex;
                      const D = o;
                      if (typeof P != "boolean") {
                        let L;
                        if (L === void 0)
                          if (P === "false" || P === 0 || P === null)
                            L = !1;
                          else if (P === "true" || P === 1)
                            L = !0;
                          else
                            return De.errors = [{ instancePath: t + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                        L !== void 0 && (P = L, e !== void 0 && (e.allowUnsafeRegex = L));
                      }
                      var a = D === o;
                      if (a) {
                        if (e.http2 !== void 0) {
                          let L = e.http2;
                          const j = o;
                          if (typeof L != "boolean") {
                            let U;
                            if (U === void 0)
                              if (L === "false" || L === 0 || L === null)
                                U = !1;
                              else if (L === "true" || L === 1)
                                U = !0;
                              else
                                return De.errors = [{ instancePath: t + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            U !== void 0 && (L = U, e !== void 0 && (e.http2 = U));
                          }
                          var a = j === o;
                        } else
                          var a = !0;
                        if (a) {
                          if (e.https !== void 0) {
                            let L = e.https;
                            const j = o, k = o;
                            let U = !0;
                            const M = o, T = o, N = o, G = o;
                            let O = !1;
                            const S = o;
                            if (typeof L != "boolean") {
                              let Q;
                              if (Q === void 0)
                                if (L === "false" || L === 0 || L === null)
                                  Q = !1;
                                else if (L === "true" || L === 1)
                                  Q = !0;
                                else {
                                  const K = {};
                                  s === null ? s = [K] : s.push(K), o++;
                                }
                              Q !== void 0 && (L = Q, e !== void 0 && (e.https = Q));
                            }
                            var u = S === o;
                            u && (O = !0);
                            const W = o;
                            if (L !== null) {
                              let Q;
                              if (Q === void 0)
                                if (L === "" || L === 0 || L === !1)
                                  Q = null;
                                else {
                                  const K = {};
                                  s === null ? s = [K] : s.push(K), o++;
                                }
                              Q !== void 0 && (L = Q, e !== void 0 && (e.https = Q));
                            }
                            var u = W === o;
                            if (u && O)
                              O = !1;
                            else {
                              u && (O = !0);
                              const Q = o;
                              if (o === Q)
                                if (L && typeof L == "object" && !Array.isArray(L))
                                  if (L.allowHTTP1 === void 0) {
                                    const X = {};
                                    s === null ? s = [X] : s.push(X), o++;
                                  } else {
                                    const X = o;
                                    for (const J in L)
                                      J !== "allowHTTP1" && delete L[J];
                                    if (X === o && L.allowHTTP1 !== void 0) {
                                      let J = L.allowHTTP1;
                                      if (typeof J != "boolean") {
                                        let re;
                                        if (re === void 0)
                                          if (J === "false" || J === 0 || J === null)
                                            re = !1;
                                          else if (J === "true" || J === 1)
                                            re = !0;
                                          else {
                                            const fe = {};
                                            s === null ? s = [fe] : s.push(fe), o++;
                                          }
                                        re !== void 0 && (J = re, L !== void 0 && (L.allowHTTP1 = re));
                                      }
                                    }
                                  }
                                else {
                                  const X = {};
                                  s === null ? s = [X] : s.push(X), o++;
                                }
                              var u = Q === o;
                              u && O ? O = !1 : u && (O = !0);
                            }
                            if (O)
                              o = G, s !== null && (G ? s.length = G : s = null);
                            else {
                              const Q = {};
                              s === null ? s = [Q] : s.push(Q), o++;
                            }
                            var l = N === o;
                            if (l) {
                              const Q = {};
                              s === null ? s = [Q] : s.push(Q), o++;
                            } else
                              o = T, s !== null && (T ? s.length = T : s = null);
                            var f = M === o;
                            if (o = k, s !== null && (k ? s.length = k : s = null), f) {
                              const Q = o;
                              e.https = !0;
                              var f = Q === o;
                              U = f;
                            }
                            if (!U) {
                              const Q = { instancePath: t + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                              return s === null ? s = [Q] : s.push(Q), o++, De.errors = s, !1;
                            }
                            var a = j === o;
                          } else
                            var a = !0;
                          if (a) {
                            let L = e.ignoreTrailingSlash;
                            const j = o;
                            if (typeof L != "boolean") {
                              let U;
                              if (U === void 0)
                                if (L === "false" || L === 0 || L === null)
                                  U = !1;
                                else if (L === "true" || L === 1)
                                  U = !0;
                                else
                                  return De.errors = [{ instancePath: t + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              U !== void 0 && (L = U, e !== void 0 && (e.ignoreTrailingSlash = U));
                            }
                            var a = j === o;
                            if (a) {
                              let U = e.ignoreDuplicateSlashes;
                              const M = o;
                              if (typeof U != "boolean") {
                                let N;
                                if (N === void 0)
                                  if (U === "false" || U === 0 || U === null)
                                    N = !1;
                                  else if (U === "true" || U === 1)
                                    N = !0;
                                  else
                                    return De.errors = [{ instancePath: t + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                N !== void 0 && (U = N, e !== void 0 && (e.ignoreDuplicateSlashes = N));
                              }
                              var a = M === o;
                              if (a) {
                                let N = e.disableRequestLogging;
                                const G = o;
                                if (typeof N != "boolean") {
                                  let S;
                                  if (S === void 0)
                                    if (N === "false" || N === 0 || N === null)
                                      S = !1;
                                    else if (N === "true" || N === 1)
                                      S = !0;
                                    else
                                      return De.errors = [{ instancePath: t + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  S !== void 0 && (N = S, e !== void 0 && (e.disableRequestLogging = S));
                                }
                                var a = G === o;
                                if (a) {
                                  let S = e.maxParamLength;
                                  const W = o;
                                  if (!(typeof S == "number" && !(S % 1) && !isNaN(S) && isFinite(S))) {
                                    let Q = typeof S, K;
                                    if (K === void 0)
                                      if (Q === "boolean" || S === null || Q === "string" && S && S == +S && !(S % 1))
                                        K = +S;
                                      else
                                        return De.errors = [{ instancePath: t + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                    K !== void 0 && (S = K, e !== void 0 && (e.maxParamLength = K));
                                  }
                                  var a = W === o;
                                  if (a) {
                                    let Q = e.onProtoPoisoning;
                                    const K = o;
                                    if (typeof Q != "string") {
                                      let J = typeof Q, re;
                                      if (re === void 0)
                                        if (J == "number" || J == "boolean")
                                          re = "" + Q;
                                        else if (Q === null)
                                          re = "";
                                        else
                                          return De.errors = [{ instancePath: t + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                      re !== void 0 && (Q = re, e !== void 0 && (e.onProtoPoisoning = re));
                                    }
                                    var a = K === o;
                                    if (a) {
                                      let J = e.onConstructorPoisoning;
                                      const re = o;
                                      if (typeof J != "string") {
                                        let ee = typeof J, le;
                                        if (le === void 0)
                                          if (ee == "number" || ee == "boolean")
                                            le = "" + J;
                                          else if (J === null)
                                            le = "";
                                          else
                                            return De.errors = [{ instancePath: t + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                        le !== void 0 && (J = le, e !== void 0 && (e.onConstructorPoisoning = le));
                                      }
                                      var a = re === o;
                                      if (a) {
                                        let ee = e.pluginTimeout;
                                        const le = o;
                                        if (!(typeof ee == "number" && !(ee % 1) && !isNaN(ee) && isFinite(ee))) {
                                          let ye = typeof ee, ve;
                                          if (ve === void 0)
                                            if (ye === "boolean" || ee === null || ye === "string" && ee && ee == +ee && !(ee % 1))
                                              ve = +ee;
                                            else
                                              return De.errors = [{ instancePath: t + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                          ve !== void 0 && (ee = ve, e !== void 0 && (e.pluginTimeout = ve));
                                        }
                                        var a = le === o;
                                        if (a) {
                                          let ye = e.requestIdHeader;
                                          const ve = o, ze = o;
                                          let Ae = !1;
                                          const $t = o;
                                          if (typeof ye != "boolean") {
                                            let Le;
                                            if (Le === void 0)
                                              if (ye === "false" || ye === 0 || ye === null)
                                                Le = !1;
                                              else if (ye === "true" || ye === 1)
                                                Le = !0;
                                              else {
                                                const Ut = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                s === null ? s = [Ut] : s.push(Ut), o++;
                                              }
                                            Le !== void 0 && (ye = Le, e !== void 0 && (e.requestIdHeader = Le));
                                          }
                                          var m = $t === o;
                                          if (Ae = Ae || m, !Ae) {
                                            const Le = o;
                                            if (typeof ye != "string") {
                                              let Er = typeof ye, Ne;
                                              if (Ne === void 0)
                                                if (Er == "number" || Er == "boolean")
                                                  Ne = "" + ye;
                                                else if (ye === null)
                                                  Ne = "";
                                                else {
                                                  const je = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                  s === null ? s = [je] : s.push(je), o++;
                                                }
                                              Ne !== void 0 && (ye = Ne, e !== void 0 && (e.requestIdHeader = Ne));
                                            }
                                            var m = Le === o;
                                            Ae = Ae || m;
                                          }
                                          if (Ae)
                                            o = ze, s !== null && (ze ? s.length = ze : s = null);
                                          else {
                                            const Le = { instancePath: t + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            return s === null ? s = [Le] : s.push(Le), o++, De.errors = s, !1;
                                          }
                                          var a = ve === o;
                                          if (a) {
                                            let Le = e.requestIdLogLabel;
                                            const Ut = o;
                                            if (typeof Le != "string") {
                                              let Ne = typeof Le, je;
                                              if (je === void 0)
                                                if (Ne == "number" || Ne == "boolean")
                                                  je = "" + Le;
                                                else if (Le === null)
                                                  je = "";
                                                else
                                                  return De.errors = [{ instancePath: t + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                              je !== void 0 && (Le = je, e !== void 0 && (e.requestIdLogLabel = je));
                                            }
                                            var a = Ut === o;
                                            if (a) {
                                              let Ne = e.http2SessionTimeout;
                                              const je = o;
                                              if (!(typeof Ne == "number" && !(Ne % 1) && !isNaN(Ne) && isFinite(Ne))) {
                                                let Mt = typeof Ne, dr;
                                                if (dr === void 0)
                                                  if (Mt === "boolean" || Ne === null || Mt === "string" && Ne && Ne == +Ne && !(Ne % 1))
                                                    dr = +Ne;
                                                  else
                                                    return De.errors = [{ instancePath: t + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }], !1;
                                                dr !== void 0 && (Ne = dr, e !== void 0 && (e.http2SessionTimeout = dr));
                                              }
                                              var a = je === o;
                                              if (a) {
                                                let Mt = e.exposeHeadRoutes;
                                                const dr = o;
                                                if (typeof Mt != "boolean") {
                                                  let Ye;
                                                  if (Ye === void 0)
                                                    if (Mt === "false" || Mt === 0 || Mt === null)
                                                      Ye = !1;
                                                    else if (Mt === "true" || Mt === 1)
                                                      Ye = !0;
                                                    else
                                                      return De.errors = [{ instancePath: t + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                  Ye !== void 0 && (Mt = Ye, e !== void 0 && (e.exposeHeadRoutes = Ye));
                                                }
                                                var a = dr === o;
                                                if (a) {
                                                  let Ye = e.useSemicolonDelimiter;
                                                  const ts = o;
                                                  if (typeof Ye != "boolean") {
                                                    let _t;
                                                    if (_t === void 0)
                                                      if (Ye === "false" || Ye === 0 || Ye === null)
                                                        _t = !1;
                                                      else if (Ye === "true" || Ye === 1)
                                                        _t = !0;
                                                      else
                                                        return De.errors = [{ instancePath: t + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                    _t !== void 0 && (Ye = _t, e !== void 0 && (e.useSemicolonDelimiter = _t));
                                                  }
                                                  var a = ts === o;
                                                  if (a)
                                                    if (e.constraints !== void 0) {
                                                      let _t = e.constraints;
                                                      const wr = o;
                                                      if (o === wr)
                                                        if (_t && typeof _t == "object" && !Array.isArray(_t))
                                                          for (const Tn in _t) {
                                                            let Jt = _t[Tn];
                                                            const kr = o;
                                                            if (o === kr)
                                                              if (Jt && typeof Jt == "object" && !Array.isArray(Jt)) {
                                                                let Ht;
                                                                if (Jt.name === void 0 && (Ht = "name") || Jt.storage === void 0 && (Ht = "storage") || Jt.validate === void 0 && (Ht = "validate") || Jt.deriveConstraint === void 0 && (Ht = "deriveConstraint"))
                                                                  return De.errors = [{ instancePath: t + "/constraints/" + Tn.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: Ht }, message: "must have required property '" + Ht + "'" }], !1;
                                                                if (Jt.name !== void 0) {
                                                                  let Sr = Jt.name;
                                                                  if (typeof Sr != "string") {
                                                                    let ln = typeof Sr, or;
                                                                    if (or === void 0)
                                                                      if (ln == "number" || ln == "boolean")
                                                                        or = "" + Sr;
                                                                      else if (Sr === null)
                                                                        or = "";
                                                                      else
                                                                        return De.errors = [{ instancePath: t + "/constraints/" + Tn.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                    or !== void 0 && (Sr = or, Jt !== void 0 && (Jt.name = or));
                                                                  }
                                                                }
                                                              } else
                                                                return De.errors = [{ instancePath: t + "/constraints/" + Tn.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                            var p = kr === o;
                                                            if (!p)
                                                              break;
                                                          }
                                                        else
                                                          return De.errors = [{ instancePath: t + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                      var a = wr === o;
                                                    } else
                                                      var a = !0;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
      return De.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
  return De.errors = s, o === 0;
}
sf.exports.defaultInitOptions = { connectionTimeout: 0, keepAliveTimeout: 72e3, maxRequestsPerSocket: 0, requestTimeout: 0, bodyLimit: 1048576, caseSensitive: !0, allowUnsafeRegex: !1, disableRequestLogging: !1, ignoreTrailingSlash: !1, ignoreDuplicateSlashes: !1, maxParamLength: 100, onProtoPoisoning: "error", onConstructorPoisoning: "error", pluginTimeout: 1e4, requestIdHeader: !1, requestIdLogLabel: "reqId", http2SessionTimeout: 72e3, exposeHeadRoutes: !0, useSemicolonDelimiter: !1 };
var mV = sf.exports;
const Sl = mV, gV = _m({ circles: !0, proto: !1 }), { FST_ERR_INIT_OPTS_INVALID: yV } = Kt;
function vV(e) {
  const t = gV(e);
  if (!Sl(t)) {
    const r = new yV(JSON.stringify(Sl.errors.map((n) => n.message)));
    throw r.errors = Sl.errors, r;
  }
  return hy(t);
}
function hy(e) {
  const t = Object.getOwnPropertyNames(e);
  for (const r of t) {
    const n = e[r];
    ArrayBuffer.isView(n) && !(n instanceof DataView) || (e[r] = n && typeof n == "object" ? hy(n) : n);
  }
  return Object.freeze(e);
}
nf.exports = vV;
nf.exports.defaultInitOptions = Sl.defaultInitOptions;
nf.exports.utils = { deepFreezeObject: hy };
var _V = nf.exports;
const {
  kAvvioBoot: bV,
  kChildren: Cb,
  kRoutePrefix: Ab,
  kLogLevel: Ib,
  kLogSerializers: Zd,
  kHooks: Qd,
  kSchemaController: cs,
  kContentTypeParser: Nb,
  kReply: kb,
  kRequest: Db,
  kFourOhFour: EV,
  kPluginNameChain: Lb
} = Ft, wV = Rm, SV = Cm, xV = O$, RV = Yx, { buildHooks: $V } = Yi, Co = F$;
var TV = function(t, r, n) {
  const i = Co.registerPlugin.call(t, r), s = Co.getPluginName(r) || Co.getFuncPreview(r);
  if (i)
    return t[Lb].push(s), t;
  const o = Object.create(t);
  t[Cb].push(o), o.ready = t[bV].bind(o), o[Cb] = [], o[kb] = wV.buildReply(o[kb]), o[Db] = SV.buildRequest(o[Db]), o[Nb] = RV.helpers.buildContentTypeParser(o[Nb]), o[Qd] = $V(o[Qd]), o[Ab] = OV(o[Ab], n.prefix), o[Ib] = n.logLevel || o[Ib], o[cs] = xV.buildSchemaController(t[cs]), o.getSchema = o[cs].getSchema.bind(o[cs]), o.getSchemas = o[cs].getSchemas.bind(o[cs]), o[Co.kRegisteredPlugins] = Object.create(o[Co.kRegisteredPlugins]), o[Lb] = [s], (o[Zd] || n.logSerializers) && (o[Zd] = Object.assign(Object.create(o[Zd]), n.logSerializers)), n.prefix && o[EV].arrange404(o);
  for (const a of o[Qd].onRegister) a.call(t, o, n);
  return o;
};
function OV(e, t) {
  return t ? (e.endsWith("/") && t[0] === "/" ? t = t.slice(1) : t[0] !== "/" && (t = "/" + t), e + t) : e;
}
var PV = function() {
  return {
    [Symbol.iterator]: function* () {
    },
    add() {
    },
    delete() {
    },
    has() {
      return !0;
    }
  };
}, ls = { exports: {} }, Ao = { exports: {} }, Io = {}, Fb;
function CV() {
  if (Fb) return Io;
  Fb = 1, Object.defineProperty(Io, "__esModule", { value: !0 }), Io.parse = o, Io.serialize = u;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, n = /^[\u0020-\u003A\u003D-\u007E]*$/, i = Object.prototype.toString, s = /* @__PURE__ */ (() => {
    const m = function() {
    };
    return m.prototype = /* @__PURE__ */ Object.create(null), m;
  })();
  function o(m, p) {
    const d = new s(), h = m.length;
    if (h < 2)
      return d;
    const _ = (p == null ? void 0 : p.decode) || l;
    let g = 0;
    do {
      const v = m.indexOf("=", g);
      if (v === -1)
        break;
      const y = m.indexOf(";", g), E = y === -1 ? h : y;
      if (v > E) {
        g = m.lastIndexOf(";", v - 1) + 1;
        continue;
      }
      const R = a(m, g, v), w = c(m, v, R), C = m.slice(R, w);
      if (d[C] === void 0) {
        let V = a(m, v + 1, E), b = c(m, E, V);
        const F = _(m.slice(V, b));
        d[C] = F;
      }
      g = E + 1;
    } while (g < h);
    return d;
  }
  function a(m, p, d) {
    do {
      const h = m.charCodeAt(p);
      if (h !== 32 && h !== 9)
        return p;
    } while (++p < d);
    return d;
  }
  function c(m, p, d) {
    for (; p > d; ) {
      const h = m.charCodeAt(--p);
      if (h !== 32 && h !== 9)
        return p + 1;
    }
    return d;
  }
  function u(m, p, d) {
    const h = (d == null ? void 0 : d.encode) || encodeURIComponent;
    if (!e.test(m))
      throw new TypeError(`argument name is invalid: ${m}`);
    const _ = h(p);
    if (!t.test(_))
      throw new TypeError(`argument val is invalid: ${p}`);
    let g = m + "=" + _;
    if (!d)
      return g;
    if (d.maxAge !== void 0) {
      if (!Number.isInteger(d.maxAge))
        throw new TypeError(`option maxAge is invalid: ${d.maxAge}`);
      g += "; Max-Age=" + d.maxAge;
    }
    if (d.domain) {
      if (!r.test(d.domain))
        throw new TypeError(`option domain is invalid: ${d.domain}`);
      g += "; Domain=" + d.domain;
    }
    if (d.path) {
      if (!n.test(d.path))
        throw new TypeError(`option path is invalid: ${d.path}`);
      g += "; Path=" + d.path;
    }
    if (d.expires) {
      if (!f(d.expires) || !Number.isFinite(d.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${d.expires}`);
      g += "; Expires=" + d.expires.toUTCString();
    }
    if (d.httpOnly && (g += "; HttpOnly"), d.secure && (g += "; Secure"), d.partitioned && (g += "; Partitioned"), d.priority)
      switch (typeof d.priority == "string" ? d.priority.toLowerCase() : void 0) {
        case "low":
          g += "; Priority=Low";
          break;
        case "medium":
          g += "; Priority=Medium";
          break;
        case "high":
          g += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${d.priority}`);
      }
    if (d.sameSite)
      switch (typeof d.sameSite == "string" ? d.sameSite.toLowerCase() : d.sameSite) {
        case !0:
        case "strict":
          g += "; SameSite=Strict";
          break;
        case "lax":
          g += "; SameSite=Lax";
          break;
        case "none":
          g += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${d.sameSite}`);
      }
    return g;
  }
  function l(m) {
    if (m.indexOf("%") === -1)
      return m;
    try {
      return decodeURIComponent(m);
    } catch {
      return m;
    }
  }
  function f(m) {
    return i.call(m) === "[object Date]";
  }
  return Io;
}
var ep, jb;
function AV() {
  if (jb) return ep;
  jb = 1;
  const { URL: e } = hC, t = "http://localhost";
  return ep = function(n, i) {
    (typeof n == "string" || Object.prototype.toString.call(n) === "[object String]") && n.startsWith("//") && (n = t + n);
    const s = typeof n == "object" ? Object.assign(new e(t), n) : new e(n, t);
    if (typeof i == "string") {
      i = new URLSearchParams(i);
      for (const o of i.keys()) {
        s.searchParams.delete(o);
        for (const a of i.getAll(o))
          s.searchParams.append(o, a);
      }
    } else {
      const o = Object.assign({}, n.query, i);
      for (const a in o) {
        const c = o[a];
        if (Array.isArray(c)) {
          s.searchParams.delete(a);
          for (const u of c)
            s.searchParams.append(a, u);
        } else
          s.searchParams.set(a, c);
      }
    }
    return s;
  }, ep;
}
var Gc = {}, Ub;
function IV() {
  if (Ub) return Gc;
  Ub = 1;
  const { randomUUID: e } = SC, { Readable: t } = ka;
  let r;
  function n(s) {
    return s && typeof s == "object" && typeof s.append == "function" && typeof s.delete == "function" && typeof s.get == "function" && typeof s.getAll == "function" && typeof s.has == "function" && typeof s.set == "function" && s[Symbol.toStringTag] === "FormData";
  }
  function i(s) {
    r = r ?? new TextEncoder();
    const o = `----formdata-${e()}`, a = `--${o}\r
Content-Disposition: form-data`;
    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
    const c = (p) => p.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), u = (p) => p.replace(/\r?\n|\r/g, `\r
`), l = new Uint8Array([13, 10]);
    async function* f() {
      for (const [p, d] of s)
        if (typeof d == "string")
          yield r.encode(`${a}; name="${c(u(p))}"\r
\r
`), yield r.encode(`${u(d)}\r
`);
        else {
          let h = `${a}; name="${c(u(p))}"`;
          d.name && (h += `; filename="${c(d.name)}"`), h += `\r
Content-Type: ${d.type || "application/octet-stream"}\r
\r
`, yield r.encode(h), d.stream ? yield* d.stream() : yield d, yield l;
        }
      yield r.encode(`--${o}--`);
    }
    return {
      stream: t.from(f()),
      contentType: `multipart/form-data; boundary=${o}`
    };
  }
  return Gc.isFormDataLike = n, Gc.formDataToStream = i, Gc;
}
var Mb;
function NV() {
  if (Mb) return Ao.exports;
  Mb = 1;
  const { Readable: e, addAbortSignal: t } = ka, r = Gi, n = CV(), i = Wi, { createDeprecation: s } = GS, o = AV(), { isFormDataLike: a, formDataToStream: c } = IV(), { EventEmitter: u } = mu, l = s({
    name: "FastifyDeprecationLightMyRequest",
    code: "FST_LIGHTMYREQUEST_DEP01",
    message: 'You are accessing "request.connection", use "request.socket" instead.'
  });
  function f(g) {
    return g.port ? g.host : g.hostname + (g.protocol === "https:" ? ":443" : ":80");
  }
  class m extends u {
    constructor(v) {
      super(), this.remoteAddress = v;
    }
  }
  function p(g) {
    return new v(this);
    function v(y) {
      d.call(y, {
        ...g,
        Request: void 0
      }), Object.assign(this, y);
      for (const E of Object.keys(d.prototype))
        this.constructor.prototype[E] = d.prototype[E];
      return r.inherits(this.constructor, g.Request), this;
    }
  }
  function d(g) {
    e.call(this, {
      autoDestroy: !1
    });
    const v = o(g.url || g.path, g.query);
    this.url = v.pathname + v.search, this.aborted = !1, this.httpVersionMajor = 1, this.httpVersionMinor = 1, this.httpVersion = "1.1", this.method = g.method ? g.method.toUpperCase() : "GET", this.headers = {}, this.rawHeaders = [];
    const y = g.headers || {};
    for (const C in y) {
      const V = C.toLowerCase();
      if ((V === "user-agent" || V === "content-type") && y[C] === void 0) {
        this.headers[V] = void 0;
        continue;
      }
      const b = y[C];
      i(b !== void 0, 'invalid value "undefined" for header ' + C), this.headers[V] = "" + b;
    }
    if ("user-agent" in this.headers || (this.headers["user-agent"] = "lightMyRequest"), this.headers.host = this.headers.host || g.authority || f(v), g.cookies) {
      const { cookies: C } = g, V = Object.keys(C).map((b) => n.serialize(b, C[b]));
      this.headers.cookie && V.unshift(this.headers.cookie), this.headers.cookie = V.join("; ");
    }
    this.socket = new m(g.remoteAddress || "127.0.0.1"), Object.defineProperty(this, "connection", {
      get() {
        return l(), this.socket;
      },
      configurable: !0
    });
    let E = g.payload || g.body || null, R = E && typeof E.resume == "function";
    if (a(E)) {
      const C = c(E);
      E = C.stream, R = !0, this.headers["content-type"] = C.contentType, this.headers["transfer-encoding"] = "chunked";
    }
    E && typeof E != "string" && !R && !Buffer.isBuffer(E) && (E = JSON.stringify(E), "content-type" in this.headers || (this.headers["content-type"] = "application/json")), E && !R && !Object.hasOwn(this.headers, "content-length") && (this.headers["content-length"] = (Buffer.isBuffer(E) ? E.length : Buffer.byteLength(E)).toString());
    for (const C of Object.keys(this.headers))
      this.rawHeaders.push(C, this.headers[C]);
    this._lightMyRequest = {
      payload: E,
      isDone: !1,
      simulate: g.simulate || {},
      payloadAsStream: g.payloadAsStream,
      signal: g.signal
    };
    const w = g.signal;
    w && t(w, this);
    {
      const C = this._lightMyRequest.payload;
      C != null && C._readableState ? (this._read = h, C.on("error", (V) => {
        this.destroy(V);
      }), C.on("end", () => {
        this.push(null);
      })) : this._read = _;
    }
    return this;
  }
  function h() {
    const g = this._lightMyRequest.payload;
    let v = !0, y = !1, E;
    for (; v && (E = g.read()); )
      y = !0, v = this.push(E);
    v && !y && this._lightMyRequest.payload.once("readable", this._read.bind(this));
  }
  function _() {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        this._lightMyRequest.simulate.end !== !1 && this.push(null);
        return;
      }
      this._lightMyRequest.isDone = !0, this._lightMyRequest.payload && (this._lightMyRequest.simulate.split ? (this.push(this._lightMyRequest.payload.slice(0, 1)), this.push(this._lightMyRequest.payload.slice(1))) : this.push(this._lightMyRequest.payload)), this._lightMyRequest.simulate.error && this.emit("error", new Error("Simulated")), this._lightMyRequest.simulate.close && this.emit("close"), this._lightMyRequest.simulate.end !== !1 && this.push(null);
    });
  }
  return r.inherits(d, e), r.inherits(p, d), d.prototype.destroy = function(g) {
    this.destroyed || this._lightMyRequest.isDone || (this.destroyed = !0, g && (this._error = !0, process.nextTick(() => this.emit("error", g))), process.nextTick(() => this.emit("close")));
  }, Ao.exports = d, Ao.exports.Request = d, Ao.exports.CustomRequest = p, Ao.exports;
}
var us = { exports: {} }, Hb;
function kV() {
  if (Hb) return us.exports;
  Hb = 1;
  var e = {
    decodeValues: !0,
    map: !1,
    silent: !1
  };
  function t(o) {
    return typeof o == "string" && !!o.trim();
  }
  function r(o, a) {
    var c = o.split(";").filter(t), u = c.shift(), l = n(u), f = l.name, m = l.value;
    a = a ? Object.assign({}, e, a) : e;
    try {
      m = a.decodeValues ? decodeURIComponent(m) : m;
    } catch (d) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + m + "'. Set options.decodeValues to false to disable this feature.",
        d
      );
    }
    var p = {
      name: f,
      value: m
    };
    return c.forEach(function(d) {
      var h = d.split("="), _ = h.shift().trimLeft().toLowerCase(), g = h.join("=");
      _ === "expires" ? p.expires = new Date(g) : _ === "max-age" ? p.maxAge = parseInt(g, 10) : _ === "secure" ? p.secure = !0 : _ === "httponly" ? p.httpOnly = !0 : _ === "samesite" ? p.sameSite = g : _ === "partitioned" ? p.partitioned = !0 : p[_] = g;
    }), p;
  }
  function n(o) {
    var a = "", c = "", u = o.split("=");
    return u.length > 1 ? (a = u.shift(), c = u.join("=")) : c = o, { name: a, value: c };
  }
  function i(o, a) {
    if (a = a ? Object.assign({}, e, a) : e, !o)
      return a.map ? {} : [];
    if (o.headers)
      if (typeof o.headers.getSetCookie == "function")
        o = o.headers.getSetCookie();
      else if (o.headers["set-cookie"])
        o = o.headers["set-cookie"];
      else {
        var c = o.headers[Object.keys(o.headers).find(function(l) {
          return l.toLowerCase() === "set-cookie";
        })];
        !c && o.headers.cookie && !a.silent && console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        ), o = c;
      }
    if (Array.isArray(o) || (o = [o]), a.map) {
      var u = {};
      return o.filter(t).reduce(function(l, f) {
        var m = r(f, a);
        return l[m.name] = m, l;
      }, u);
    } else
      return o.filter(t).map(function(l) {
        return r(l, a);
      });
  }
  function s(o) {
    if (Array.isArray(o))
      return o;
    if (typeof o != "string")
      return [];
    var a = [], c = 0, u, l, f, m, p;
    function d() {
      for (; c < o.length && /\s/.test(o.charAt(c)); )
        c += 1;
      return c < o.length;
    }
    function h() {
      return l = o.charAt(c), l !== "=" && l !== ";" && l !== ",";
    }
    for (; c < o.length; ) {
      for (u = c, p = !1; d(); )
        if (l = o.charAt(c), l === ",") {
          for (f = c, c += 1, d(), m = c; c < o.length && h(); )
            c += 1;
          c < o.length && o.charAt(c) === "=" ? (p = !0, c = m, a.push(o.substring(u, f)), u = c) : c = f + 1;
        } else
          c += 1;
      (!p || c >= o.length) && a.push(o.substring(u, o.length));
    }
    return a;
  }
  return us.exports = i, us.exports.parse = i, us.exports.parseString = r, us.exports.splitCookiesString = s, us.exports;
}
var tp, qb;
function DV() {
  if (qb) return tp;
  qb = 1;
  const e = gu, { Writable: t, Readable: r, addAbortSignal: n } = ka, i = Gi, s = kV();
  function o(f, m, p) {
    var v;
    if (e.ServerResponse.call(this, f), (v = f._lightMyRequest) != null && v.payloadAsStream) {
      const y = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new r({ read: y }) };
      const E = f._lightMyRequest.signal;
      E && n(E, this._lightMyRequest.stream);
    } else
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    this.setHeader("foo", "bar"), this.removeHeader("foo"), this.assignSocket(c()), this._promiseCallback = typeof p == "function";
    let d = !1;
    const h = (y) => {
      if (!d) {
        if (d = !0, this._promiseCallback)
          return process.nextTick(() => m(y));
        process.nextTick(() => m(null, y));
      }
    };
    this._lightMyRequest.onEndSuccess = h;
    let _ = !1;
    const g = (y) => {
      if (d) {
        this._lightMyRequest.stream && !_ && (y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._lightMyRequest.stream.destroy(y), this._lightMyRequest.stream.on("error", () => {
        }));
        return;
      }
      if (d = !0, y || (y = new Error("response destroyed before completion"), y.code = "LIGHT_ECONNRESET"), this._promiseCallback)
        return process.nextTick(() => p(y));
      process.nextTick(() => m(y, null));
    };
    this._lightMyRequest.stream ? this.once("finish", () => {
      _ = !0, this._lightMyRequest.stream.push(null);
    }) : this.once("finish", () => {
      const y = a(this);
      y.raw.req = f, h(y);
    }), this.connection.once("error", g), this.once("error", g), this.once("close", g);
  }
  i.inherits(o, e.ServerResponse), o.prototype.setTimeout = function(f, m) {
    return this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, f), this.on("timeout", m), this;
  }, o.prototype.writeHead = function() {
    const f = e.ServerResponse.prototype.writeHead.apply(this, arguments);
    return l(this), this._lightMyRequest.stream && this._lightMyRequest.onEndSuccess(a(this)), f;
  }, o.prototype.write = function(f, m, p) {
    return this.timeoutHandle && clearTimeout(this.timeoutHandle), e.ServerResponse.prototype.write.call(this, f, m, p), this._lightMyRequest.stream ? this._lightMyRequest.stream.push(Buffer.from(f, m)) : (this._lightMyRequest.payloadChunks.push(Buffer.from(f, m)), !0);
  }, o.prototype.end = function(f, m, p) {
    f && this.write(f, m), e.ServerResponse.prototype.end.call(this, p), this.emit("finish"), this.destroy();
  }, o.prototype.destroy = function(f) {
    this.destroyed || (this.destroyed = !0, f && process.nextTick(() => this.emit("error", f)), process.nextTick(() => this.emit("close")));
  }, o.prototype.addTrailers = function(f) {
    for (const m in f)
      this._lightMyRequest.trailers[m.toLowerCase().trim()] = f[m].toString().trim();
  };
  function a(f) {
    f._lightMyRequest.headers === null && l(f), u(f);
    const m = {
      raw: {
        res: f
      },
      headers: f._lightMyRequest.headers,
      statusCode: f.statusCode,
      statusMessage: f.statusMessage,
      trailers: {},
      get cookies() {
        return s.parse(this);
      }
    };
    if (m.trailers = f._lightMyRequest.trailers, f._lightMyRequest.payloadChunks) {
      const p = Buffer.concat(f._lightMyRequest.payloadChunks);
      m.rawPayload = p, m.payload = p.toString(), m.body = m.payload, m.json = function() {
        return JSON.parse(m.payload);
      };
    } else
      m.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    return m.stream = function() {
      return f._lightMyRequest.stream ? f._lightMyRequest.stream : r.from(f._lightMyRequest.payloadChunks);
    }, m;
  }
  function c() {
    return new t({
      write(f, m, p) {
        setImmediate(p);
      }
    });
  }
  function u(f) {
    const m = f._lightMyRequest.headers;
    for (const p of Object.keys(m)) {
      const d = m[p];
      Array.isArray(d) ? m[p] = d.map((h) => "" + h) : m[p] = "" + d;
    }
  }
  function l(f) {
    f._lightMyRequest.headers = Object.assign({}, f.getHeaders()), ["Date", "Connection", "Transfer-Encoding"].forEach((m) => {
      var h;
      const p = new RegExp("\\r\\n" + m + ": ([^\\r]*)\\r\\n"), d = (h = f._header) == null ? void 0 : h.match(p);
      d && (f._lightMyRequest.headers[m.toLowerCase()] = d[1]);
    });
  }
  return tp = o, tp;
}
var Wc = { exports: {} }, Bb;
function LV() {
  if (Bb) return Wc.exports;
  Bb = 1, Wc.exports = t, Wc.exports.default = t;
  const e = { properties: { method: { enum: ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] } } };
  function t(r, { instancePath: n = "", parentData: i, parentDataProperty: s, rootData: o = r } = {}) {
    let a = null, c = 0;
    const u = c;
    let l = !1, f = null;
    const m = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let w;
      if (r.url === void 0 && (w = "url")) {
        const C = { instancePath: n, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: w }, message: "must have required property '" + w + "'" };
        a === null ? a = [C] : a.push(C), c++;
      }
    }
    var d = m === c;
    d && (l = !0, f = 0);
    const p = c;
    if (r && typeof r == "object" && !Array.isArray(r)) {
      let w;
      if (r.path === void 0 && (w = "path")) {
        const C = { instancePath: n, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: w }, message: "must have required property '" + w + "'" };
        a === null ? a = [C] : a.push(C), c++;
      }
    }
    var d = p === c;
    if (d && l ? (l = !1, f = [f, 1]) : d && (l = !0, f = 1), l)
      c = u, a !== null && (u ? a.length = u : a = null);
    else {
      const w = { instancePath: n, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: f }, message: "must match exactly one schema in oneOf" };
      return a === null ? a = [w] : a.push(w), c++, t.errors = a, !1;
    }
    if (c === 0)
      if (r && typeof r == "object" && !Array.isArray(r)) {
        if (r.url !== void 0) {
          let w = r.url;
          const C = c, V = c;
          let b = !1, F = null;
          const H = c;
          if (typeof w != "string") {
            let $ = typeof w, x;
            if (x === void 0)
              if ($ == "number" || $ == "boolean")
                x = "" + w;
              else if (w === null)
                x = "";
              else {
                const A = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                a === null ? a = [A] : a.push(A), c++;
              }
            x !== void 0 && (w = x, r !== void 0 && (r.url = x));
          }
          var _ = H === c;
          _ && (b = !0, F = 0);
          const q = c;
          if (c === q)
            if (w && typeof w == "object" && !Array.isArray(w)) {
              let $;
              if (w.pathname === void 0 && ($ = "pathname")) {
                const x = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: $ }, message: "must have required property '" + $ + "'" };
                a === null ? a = [x] : a.push(x), c++;
              } else {
                if (w.protocol !== void 0) {
                  let x = w.protocol;
                  const A = c;
                  if (typeof x != "string") {
                    let P = typeof x, D;
                    if (D === void 0)
                      if (P == "number" || P == "boolean")
                        D = "" + x;
                      else if (x === null)
                        D = "";
                      else {
                        const I = { instancePath: n + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        a === null ? a = [I] : a.push(I), c++;
                      }
                    D !== void 0 && (x = D, w !== void 0 && (w.protocol = D));
                  }
                  var h = A === c;
                } else
                  var h = !0;
                if (h) {
                  if (w.hostname !== void 0) {
                    let x = w.hostname;
                    const A = c;
                    if (typeof x != "string") {
                      let D = typeof x, I;
                      if (I === void 0)
                        if (D == "number" || D == "boolean")
                          I = "" + x;
                        else if (x === null)
                          I = "";
                        else {
                          const L = { instancePath: n + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [L] : a.push(L), c++;
                        }
                      I !== void 0 && (x = I, w !== void 0 && (w.hostname = I));
                    }
                    var h = A === c;
                  } else
                    var h = !0;
                  if (h)
                    if (w.pathname !== void 0) {
                      let x = w.pathname;
                      const A = c;
                      if (typeof x != "string") {
                        let D = typeof x, I;
                        if (I === void 0)
                          if (D == "number" || D == "boolean")
                            I = "" + x;
                          else if (x === null)
                            I = "";
                          else {
                            const L = { instancePath: n + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [L] : a.push(L), c++;
                          }
                        I !== void 0 && (x = I, w !== void 0 && (w.pathname = I));
                      }
                      var h = A === c;
                    } else
                      var h = !0;
                }
              }
            } else {
              const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              a === null ? a = [$] : a.push($), c++;
            }
          var _ = q === c;
          if (_ && b ? (b = !1, F = [F, 1]) : _ && (b = !0, F = 1), b)
            c = V, a !== null && (V ? a.length = V : a = null);
          else {
            const $ = { instancePath: n + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: F }, message: "must match exactly one schema in oneOf" };
            return a === null ? a = [$] : a.push($), c++, t.errors = a, !1;
          }
          var g = C === c;
        } else
          var g = !0;
        if (g) {
          if (r.path !== void 0) {
            let w = r.path;
            const C = c, V = c;
            let b = !1, F = null;
            const H = c;
            if (typeof w != "string") {
              let x = typeof w, A;
              if (A === void 0)
                if (x == "number" || x == "boolean")
                  A = "" + w;
                else if (w === null)
                  A = "";
                else {
                  const P = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  a === null ? a = [P] : a.push(P), c++;
                }
              A !== void 0 && (w = A, r !== void 0 && (r.path = A));
            }
            var y = H === c;
            y && (b = !0, F = 0);
            const q = c;
            if (c === q)
              if (w && typeof w == "object" && !Array.isArray(w)) {
                let x;
                if (w.pathname === void 0 && (x = "pathname")) {
                  const A = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: x }, message: "must have required property '" + x + "'" };
                  a === null ? a = [A] : a.push(A), c++;
                } else {
                  if (w.protocol !== void 0) {
                    let A = w.protocol;
                    const P = c;
                    if (typeof A != "string") {
                      let D = typeof A, I;
                      if (I === void 0)
                        if (D == "number" || D == "boolean")
                          I = "" + A;
                        else if (A === null)
                          I = "";
                        else {
                          const L = { instancePath: n + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [L] : a.push(L), c++;
                        }
                      I !== void 0 && (A = I, w !== void 0 && (w.protocol = I));
                    }
                    var v = P === c;
                  } else
                    var v = !0;
                  if (v) {
                    if (w.hostname !== void 0) {
                      let A = w.hostname;
                      const P = c;
                      if (typeof A != "string") {
                        let I = typeof A, L;
                        if (L === void 0)
                          if (I == "number" || I == "boolean")
                            L = "" + A;
                          else if (A === null)
                            L = "";
                          else {
                            const j = { instancePath: n + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            a === null ? a = [j] : a.push(j), c++;
                          }
                        L !== void 0 && (A = L, w !== void 0 && (w.hostname = L));
                      }
                      var v = P === c;
                    } else
                      var v = !0;
                    if (v)
                      if (w.pathname !== void 0) {
                        let A = w.pathname;
                        const P = c;
                        if (typeof A != "string") {
                          let I = typeof A, L;
                          if (L === void 0)
                            if (I == "number" || I == "boolean")
                              L = "" + A;
                            else if (A === null)
                              L = "";
                            else {
                              const j = { instancePath: n + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              a === null ? a = [j] : a.push(j), c++;
                            }
                          L !== void 0 && (A = L, w !== void 0 && (w.pathname = L));
                        }
                        var v = P === c;
                      } else
                        var v = !0;
                  }
                }
              } else {
                const x = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                a === null ? a = [x] : a.push(x), c++;
              }
            var y = q === c;
            if (y && b ? (b = !1, F = [F, 1]) : y && (b = !0, F = 1), b)
              c = V, a !== null && (V ? a.length = V : a = null);
            else {
              const x = { instancePath: n + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: F }, message: "must match exactly one schema in oneOf" };
              return a === null ? a = [x] : a.push(x), c++, t.errors = a, !1;
            }
            var g = C === c;
          } else
            var g = !0;
          if (g) {
            if (r.cookies !== void 0) {
              let w = r.cookies;
              const C = c;
              if (c === C && !(w && typeof w == "object" && !Array.isArray(w)))
                return t.errors = [{ instancePath: n + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
              var g = C === c;
            } else
              var g = !0;
            if (g) {
              if (r.headers !== void 0) {
                let w = r.headers;
                const C = c;
                if (c === C && !(w && typeof w == "object" && !Array.isArray(w)))
                  return t.errors = [{ instancePath: n + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                var g = C === c;
              } else
                var g = !0;
              if (g) {
                if (r.query !== void 0) {
                  let w = r.query;
                  const C = c, V = c;
                  let b = !1;
                  const F = c;
                  if (c === F && !(w && typeof w == "object" && !Array.isArray(w))) {
                    const q = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    a === null ? a = [q] : a.push(q), c++;
                  }
                  var E = F === c;
                  if (b = b || E, !b) {
                    const q = c;
                    if (typeof w != "string") {
                      let x = typeof w, A;
                      if (A === void 0)
                        if (x == "number" || x == "boolean")
                          A = "" + w;
                        else if (w === null)
                          A = "";
                        else {
                          const P = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          a === null ? a = [P] : a.push(P), c++;
                        }
                      A !== void 0 && (w = A, r !== void 0 && (r.query = A));
                    }
                    var E = q === c;
                    b = b || E;
                  }
                  if (b)
                    c = V, a !== null && (V ? a.length = V : a = null);
                  else {
                    const q = { instancePath: n + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    return a === null ? a = [q] : a.push(q), c++, t.errors = a, !1;
                  }
                  var g = C === c;
                } else
                  var g = !0;
                if (g) {
                  if (r.simulate !== void 0) {
                    let w = r.simulate;
                    const C = c;
                    if (c === C)
                      if (w && typeof w == "object" && !Array.isArray(w)) {
                        if (w.end !== void 0) {
                          let b = w.end;
                          const F = c;
                          if (typeof b != "boolean") {
                            let H;
                            if (H === void 0)
                              if (b === "false" || b === 0 || b === null)
                                H = !1;
                              else if (b === "true" || b === 1)
                                H = !0;
                              else
                                return t.errors = [{ instancePath: n + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                            H !== void 0 && (b = H, w !== void 0 && (w.end = H));
                          }
                          var R = F === c;
                        } else
                          var R = !0;
                        if (R) {
                          if (w.split !== void 0) {
                            let b = w.split;
                            const F = c;
                            if (typeof b != "boolean") {
                              let q;
                              if (q === void 0)
                                if (b === "false" || b === 0 || b === null)
                                  q = !1;
                                else if (b === "true" || b === 1)
                                  q = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              q !== void 0 && (b = q, w !== void 0 && (w.split = q));
                            }
                            var R = F === c;
                          } else
                            var R = !0;
                          if (R) {
                            if (w.error !== void 0) {
                              let b = w.error;
                              const F = c;
                              if (typeof b != "boolean") {
                                let q;
                                if (q === void 0)
                                  if (b === "false" || b === 0 || b === null)
                                    q = !1;
                                  else if (b === "true" || b === 1)
                                    q = !0;
                                  else
                                    return t.errors = [{ instancePath: n + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                q !== void 0 && (b = q, w !== void 0 && (w.error = q));
                              }
                              var R = F === c;
                            } else
                              var R = !0;
                            if (R)
                              if (w.close !== void 0) {
                                let b = w.close;
                                const F = c;
                                if (typeof b != "boolean") {
                                  let q;
                                  if (q === void 0)
                                    if (b === "false" || b === 0 || b === null)
                                      q = !1;
                                    else if (b === "true" || b === 1)
                                      q = !0;
                                    else
                                      return t.errors = [{ instancePath: n + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                  q !== void 0 && (b = q, w !== void 0 && (w.close = q));
                                }
                                var R = F === c;
                              } else
                                var R = !0;
                          }
                        }
                      } else
                        return t.errors = [{ instancePath: n + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                    var g = C === c;
                  } else
                    var g = !0;
                  if (g) {
                    if (r.authority !== void 0) {
                      let w = r.authority;
                      const C = c;
                      if (typeof w != "string") {
                        let b = typeof w, F;
                        if (F === void 0)
                          if (b == "number" || b == "boolean")
                            F = "" + w;
                          else if (w === null)
                            F = "";
                          else
                            return t.errors = [{ instancePath: n + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                        F !== void 0 && (w = F, r !== void 0 && (r.authority = F));
                      }
                      var g = C === c;
                    } else
                      var g = !0;
                    if (g) {
                      if (r.remoteAddress !== void 0) {
                        let w = r.remoteAddress;
                        const C = c;
                        if (typeof w != "string") {
                          let b = typeof w, F;
                          if (F === void 0)
                            if (b == "number" || b == "boolean")
                              F = "" + w;
                            else if (w === null)
                              F = "";
                            else
                              return t.errors = [{ instancePath: n + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                          F !== void 0 && (w = F, r !== void 0 && (r.remoteAddress = F));
                        }
                        var g = C === c;
                      } else
                        var g = !0;
                      if (g) {
                        if (r.method !== void 0) {
                          let w = r.method;
                          const C = c;
                          if (typeof w != "string") {
                            let b = typeof w, F;
                            if (F === void 0)
                              if (b == "number" || b == "boolean")
                                F = "" + w;
                              else if (w === null)
                                F = "";
                              else
                                return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                            F !== void 0 && (w = F, r !== void 0 && (r.method = F));
                          }
                          if (!(w === "ACL" || w === "BIND" || w === "CHECKOUT" || w === "CONNECT" || w === "COPY" || w === "DELETE" || w === "GET" || w === "HEAD" || w === "LINK" || w === "LOCK" || w === "M-SEARCH" || w === "MERGE" || w === "MKACTIVITY" || w === "MKCALENDAR" || w === "MKCOL" || w === "MOVE" || w === "NOTIFY" || w === "OPTIONS" || w === "PATCH" || w === "POST" || w === "PROPFIND" || w === "PROPPATCH" || w === "PURGE" || w === "PUT" || w === "QUERY" || w === "REBIND" || w === "REPORT" || w === "SEARCH" || w === "SOURCE" || w === "SUBSCRIBE" || w === "TRACE" || w === "UNBIND" || w === "UNLINK" || w === "UNLOCK" || w === "UNSUBSCRIBE" || w === "acl" || w === "bind" || w === "checkout" || w === "connect" || w === "copy" || w === "delete" || w === "get" || w === "head" || w === "link" || w === "lock" || w === "m-search" || w === "merge" || w === "mkactivity" || w === "mkcalendar" || w === "mkcol" || w === "move" || w === "notify" || w === "options" || w === "patch" || w === "post" || w === "propfind" || w === "proppatch" || w === "purge" || w === "put" || w === "query" || w === "rebind" || w === "report" || w === "search" || w === "source" || w === "subscribe" || w === "trace" || w === "unbind" || w === "unlink" || w === "unlock" || w === "unsubscribe"))
                            return t.errors = [{ instancePath: n + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: e.properties.method.enum }, message: "must be equal to one of the allowed values" }], !1;
                          var g = C === c;
                        } else
                          var g = !0;
                        if (g)
                          if (r.validate !== void 0) {
                            let w = r.validate;
                            const C = c;
                            if (typeof w != "boolean") {
                              let b;
                              if (b === void 0)
                                if (w === "false" || w === 0 || w === null)
                                  b = !1;
                                else if (w === "true" || w === 1)
                                  b = !0;
                                else
                                  return t.errors = [{ instancePath: n + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                              b !== void 0 && (w = b, r !== void 0 && (r.validate = b));
                            }
                            var g = C === c;
                          } else
                            var g = !0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else
        return t.errors = [{ instancePath: n, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    return t.errors = a, c === 0;
  }
  return Wc.exports;
}
var zb;
function FV() {
  if (zb) return ls.exports;
  zb = 1;
  const e = Wi, t = NV(), r = DV(), n = "The dispatch function has already been invoked", i = LV();
  function s(p, d, h) {
    return h === void 0 ? new u(p, d) : c(p, d, h);
  }
  function o(p, d) {
    const h = p._lightMyRequest.payload;
    if (!h || h._readableState || typeof h.resume != "function")
      return d();
    const _ = [];
    h.on("data", (g) => _.push(Buffer.from(g))), h.on("end", () => {
      const g = Buffer.concat(_);
      return p.headers["content-length"] = p.headers["content-length"] || "" + g.length, delete p.headers["transfer-encoding"], p._lightMyRequest.payload = g, d();
    }), h.resume();
  }
  function a(p, d, h, _) {
    return h.once("error", function(g) {
      this.destroyed && _.destroy(g);
    }), h.once("close", function() {
      this.destroyed && !this._error && _.destroy();
    }), o(h, () => p.call(d, h, _));
  }
  function c(p, d, h) {
    if (d = typeof d == "string" ? { url: d } : d, d.validate !== !1 && (e(typeof p == "function", "dispatchFunc should be a function"), !i(d)))
      throw new Error(i.errors.map((y) => y.message));
    const _ = d.server || {}, g = d.Request ? t.CustomRequest : t;
    if (p.request && p.request.app === p && (Object.setPrototypeOf(Object.getPrototypeOf(p.request), g.prototype), Object.setPrototypeOf(Object.getPrototypeOf(p.response), r.prototype)), typeof h == "function") {
      const v = new g(d), y = new r(v, h);
      return a(p, _, v, y);
    } else
      return new Promise((v, y) => {
        const E = new g(d), R = new r(E, v, y);
        a(p, _, E, R);
      });
  }
  function u(p, d) {
    typeof d == "string" ? this.option = { url: d } : this.option = Object.assign({}, d), this.dispatch = p, this._hasInvoked = !1, this._promise = null, this.option.autoStart !== !1 && process.nextTick(() => {
      this._hasInvoked || this.end();
    });
  }
  [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ].forEach((p) => {
    u.prototype[p] = function(d) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option.url = d, this.option.method = p.toUpperCase(), this;
    };
  }), [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ].forEach((p) => {
    u.prototype[p] = function(d) {
      if (this._hasInvoked === !0 || this._promise)
        throw new Error(n);
      return this.option[p] = d, this;
    };
  }), u.prototype.end = function(p) {
    if (this._hasInvoked === !0 || this._promise)
      throw new Error(n);
    if (this._hasInvoked = !0, typeof p == "function")
      c(this.dispatch, this.option, p);
    else
      return this._promise = c(this.dispatch, this.option), this._promise;
  }, Object.getOwnPropertyNames(Promise.prototype).forEach((p) => {
    p !== "constructor" && (u.prototype[p] = function(...d) {
      if (!this._promise) {
        if (this._hasInvoked === !0)
          throw new Error(n);
        this._hasInvoked = !0, this._promise = c(this.dispatch, this.option);
      }
      return this._promise[p](...d);
    });
  });
  function m(p) {
    var d;
    return p instanceof t || p instanceof r || ((d = p == null ? void 0 : p.constructor) == null ? void 0 : d.name) === "_CustomLMRRequest";
  }
  return ls.exports = s, ls.exports.default = s, ls.exports.inject = s, ls.exports.isInjection = m, ls.exports;
}
const jV = "5.2.2", UV = PA, Kc = gu, MV = am;
let No;
const {
  kAvvioBoot: ko,
  kChildren: rp,
  kServerBindings: Vb,
  kBodyLimit: HV,
  kSupportedHTTPMethods: yi,
  kRoutePrefix: Gb,
  kLogLevel: qV,
  kLogSerializers: BV,
  kHooks: np,
  kSchemaController: Dn,
  kRequestAcceptVersion: zV,
  kReplySerializerDefault: Wb,
  kContentTypeParser: VV,
  kReply: GV,
  kRequest: WV,
  kFourOhFour: KV,
  kState: ut,
  kOptions: ip,
  kPluginNameChain: Do,
  kSchemaErrorFormatter: sp,
  kErrorHandler: Yc,
  kKeepAliveConnections: op,
  kChildLoggerFactory: ap,
  kGenReqId: cp
} = Ft, { createServer: YV } = zS, Lo = Rm, Jc = Cm, JV = Am, fs = qx, vi = Yx, Kb = O$, { Hooks: XV, hookRunnerApplication: Yb, supportedHooks: kh } = Yi, { createChildLogger: Jb, defaultChildLoggerFactory: ZV, createLogger: QV } = Ou, Xb = F$, { getGenReqId: Zb, reqIdGenFactory: Qb } = cy, { buildRouting: e6, validateBodyLimitOption: t6 } = rV, r6 = fV, h1 = _V, n6 = TV, i6 = PV, {
  appendStackTrace: s6,
  AVVIO_ERRORS_MAP: eE,
  ...Pi
} = Kt, { defaultInitOptions: mr } = h1, {
  FST_ERR_ASYNC_CONSTRAINT: o6,
  FST_ERR_BAD_URL: a6,
  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: c6,
  FST_ERR_OPTIONS_NOT_OBJ: l6,
  FST_ERR_QSP_NOT_FN: u6,
  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: f6,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: d6,
  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: p6,
  FST_ERR_INSTANCE_ALREADY_LISTENING: h6,
  FST_ERR_REOPENED_CLOSE_SERVER: m6,
  FST_ERR_ROUTE_REWRITE_NOT_STR: g6,
  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: tE,
  FST_ERR_ERROR_HANDLER_NOT_FN: y6,
  FST_ERR_ROUTE_METHOD_INVALID: v6
} = Pi, { buildErrorHandler: rE } = Au, nE = MV.channel("fastify.initialization");
function _6(e) {
  const t = {};
  return ["errorHandler", "logLevel", "logSerializers"].concat(kh).forEach((n) => {
    t[n] = e.store[n];
  }), Object.assign({}, t);
}
function my(e) {
  if (e && typeof e != "object")
    throw new l6();
  if (e = Object.assign({}, e), e.querystringParser && typeof e.querystringParser != "function")
    throw new u6(typeof e.querystringParser);
  if (e.schemaController && e.schemaController.bucket && typeof e.schemaController.bucket != "function")
    throw new f6(typeof e.schemaController.bucket);
  t6(e.bodyLimit);
  const t = typeof e.requestIdHeader == "string" && e.requestIdHeader.length !== 0 ? e.requestIdHeader.toLowerCase() : e.requestIdHeader === !0 && "request-id", r = Qb(t, e.genReqId), n = e.requestIdLogLabel || "reqId", i = e.bodyLimit || mr.bodyLimit, s = e.disableRequestLogging || !1, o = Object.assign({
    customOptions: {},
    plugins: []
  }, e.ajv), a = e.frameworkErrors;
  if (!o.customOptions || Object.prototype.toString.call(o.customOptions) !== "[object Object]")
    throw new d6(typeof o.customOptions);
  if (!o.plugins || !Array.isArray(o.plugins))
    throw new p6(typeof o.plugins);
  const { logger: c, hasLogger: u } = QV(e);
  e.connectionTimeout = e.connectionTimeout || mr.connectionTimeout, e.keepAliveTimeout = e.keepAliveTimeout || mr.keepAliveTimeout, e.maxRequestsPerSocket = e.maxRequestsPerSocket || mr.maxRequestsPerSocket, e.requestTimeout = e.requestTimeout || mr.requestTimeout, e.logger = c, e.requestIdHeader = t, e.requestIdLogLabel = n, e.disableRequestLogging = s, e.ajv = o, e.clientErrorHandler = e.clientErrorHandler || P;
  const l = h1(e);
  e.exposeHeadRoutes = l.exposeHeadRoutes;
  const f = e6({
    config: {
      defaultRoute: D,
      onBadUrl: I,
      constraints: e.constraints,
      ignoreTrailingSlash: e.ignoreTrailingSlash || mr.ignoreTrailingSlash,
      ignoreDuplicateSlashes: e.ignoreDuplicateSlashes || mr.ignoreDuplicateSlashes,
      maxParamLength: e.maxParamLength || mr.maxParamLength,
      caseSensitive: e.caseSensitive,
      allowUnsafeRegex: e.allowUnsafeRegex || mr.allowUnsafeRegex,
      buildPrettyMeta: _6,
      querystringParser: e.querystringParser,
      useSemicolonDelimiter: e.useSemicolonDelimiter ?? mr.useSemicolonDelimiter
    }
  }), m = r6(e), p = W(f, e);
  e.http2SessionTimeout = l.http2SessionTimeout;
  const { server: d, listen: h } = YV(e, p), _ = typeof d.closeAllConnections == "function", g = typeof d.closeIdleConnections == "function";
  let v = e.forceCloseConnections;
  if (v === "idle" && !g)
    throw new c6();
  typeof v != "boolean" && (v = g ? "idle" : !1);
  const y = !_ && v === !0 ? /* @__PURE__ */ new Set() : i6(), E = Lo.setupResponseListeners, R = Kb.buildSchemaController(null, e.schemaController), w = {
    // Fastify internals
    [ut]: {
      listening: !1,
      closing: !1,
      started: !1,
      ready: !1,
      booting: !1,
      readyPromise: null
    },
    [op]: y,
    [yi]: {
      bodyless: /* @__PURE__ */ new Set([
        // Standard
        "GET",
        "HEAD",
        "TRACE"
      ]),
      bodywith: /* @__PURE__ */ new Set([
        // Standard
        "DELETE",
        "OPTIONS",
        "PATCH",
        "PUT",
        "POST"
      ])
    },
    [ip]: e,
    [rp]: [],
    [Vb]: [],
    [HV]: i,
    [Gb]: "",
    [qV]: "",
    [BV]: null,
    [np]: new XV(),
    [Dn]: R,
    [sp]: null,
    [Yc]: rE(),
    [ap]: ZV,
    [Wb]: null,
    [VV]: new vi(
      i,
      e.onProtoPoisoning || mr.onProtoPoisoning,
      e.onConstructorPoisoning || mr.onConstructorPoisoning
    ),
    [GV]: Lo.buildReply(Lo),
    [WV]: Jc.buildRequest(Jc, e.trustProxy),
    [KV]: m,
    [Xb.kRegisteredPlugins]: [],
    [Do]: ["fastify"],
    [ko]: null,
    [cp]: r,
    // routing method
    routing: p,
    // routes shorthand methods
    delete: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "DELETE", url: X, options: J, handler: re });
    },
    get: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "GET", url: X, options: J, handler: re });
    },
    head: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "HEAD", url: X, options: J, handler: re });
    },
    trace: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "TRACE", url: X, options: J, handler: re });
    },
    patch: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "PATCH", url: X, options: J, handler: re });
    },
    post: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "POST", url: X, options: J, handler: re });
    },
    put: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "PUT", url: X, options: J, handler: re });
    },
    options: function(X, J, re) {
      return f.prepareRoute.call(this, { method: "OPTIONS", url: X, options: J, handler: re });
    },
    all: function(X, J, re) {
      return f.prepareRoute.call(this, { method: this.supportedMethods, url: X, options: J, handler: re });
    },
    // extended route
    route: function(X) {
      return f.route.call(this, { options: X });
    },
    hasRoute: function(X) {
      return f.hasRoute.call(this, { options: X });
    },
    findRoute: function(X) {
      return f.findRoute(X);
    },
    // expose logger instance
    log: c,
    // type provider
    withTypeProvider: $,
    // hooks
    addHook: x,
    // schemas
    addSchema: A,
    getSchema: R.getSchema.bind(R),
    getSchemas: R.getSchemas.bind(R),
    setValidatorCompiler: k,
    setSerializerCompiler: M,
    setSchemaController: T,
    setReplySerializer: N,
    setSchemaErrorFormatter: U,
    // set generated request id
    setGenReqId: z,
    // custom parsers
    addContentTypeParser: vi.helpers.addContentTypeParser,
    hasContentTypeParser: vi.helpers.hasContentTypeParser,
    getDefaultJsonParser: vi.defaultParsers.getDefaultJsonParser,
    defaultTextParser: vi.defaultParsers.defaultTextParser,
    removeContentTypeParser: vi.helpers.removeContentTypeParser,
    removeAllContentTypeParsers: vi.helpers.removeAllContentTypeParsers,
    // Fastify architecture methods (initialized by Avvio)
    register: null,
    after: null,
    ready: null,
    onClose: null,
    close: null,
    printPlugins: null,
    hasPlugin: function(K) {
      return this[Xb.kRegisteredPlugins].includes(K) || this[Do].includes(K);
    },
    // http server
    listen: h,
    server: d,
    addresses: function() {
      const K = this[Vb].map((X) => X.address());
      return K.push(this.server.address()), K.filter((X) => X);
    },
    // extend fastify objects
    decorate: fs.add,
    hasDecorator: fs.exist,
    decorateReply: fs.decorateReply,
    decorateRequest: fs.decorateRequest,
    hasRequestDecorator: fs.existRequest,
    hasReplyDecorator: fs.existReply,
    addHttpMethod: Q,
    // fake http injection
    inject: H,
    // pretty print of the registered routes
    printRoutes: S,
    // custom error handling
    setNotFoundHandler: j,
    setErrorHandler: G,
    // child logger
    setChildLoggerFactory: O,
    // Set fastify initial configuration options read-only object
    initialConfig: l,
    // constraint strategies
    addConstraintStrategy: f.addConstraintStrategy.bind(f),
    hasConstraintStrategy: f.hasConstraintStrategy.bind(f)
  };
  Object.defineProperties(w, {
    listeningOrigin: {
      get() {
        const K = this.addresses().slice(-1).pop();
        if (typeof K == "string")
          return K;
        const X = K.family === "IPv6" ? `[${K.address}]` : K.address;
        return `${this[ip].https ? "https" : "http"}://${X}:${K.port}`;
      }
    },
    pluginName: {
      configurable: !0,
      get() {
        return this[Do].length > 1 ? this[Do].join(" -> ") : this[Do][0];
      }
    },
    prefix: {
      configurable: !0,
      get() {
        return this[Gb];
      }
    },
    validatorCompiler: {
      configurable: !0,
      get() {
        return this[Dn].getValidatorCompiler();
      }
    },
    serializerCompiler: {
      configurable: !0,
      get() {
        return this[Dn].getSerializerCompiler();
      }
    },
    childLoggerFactory: {
      configurable: !0,
      get() {
        return this[ap];
      }
    },
    version: {
      configurable: !0,
      get() {
        return jV;
      }
    },
    errorHandler: {
      configurable: !0,
      get() {
        return this[Yc].func;
      }
    },
    genReqId: {
      configurable: !0,
      get() {
        return this[cp];
      }
    },
    supportedMethods: {
      configurable: !1,
      get() {
        return [
          ...this[yi].bodyless,
          ...this[yi].bodywith
        ];
      }
    }
  }), e.schemaErrorFormatter && (iE(e.schemaErrorFormatter), w[sp] = e.schemaErrorFormatter.bind(w));
  const C = Number(e.pluginTimeout), V = UV(w, {
    autostart: !1,
    timeout: isNaN(C) === !1 ? C : mr.pluginTimeout,
    expose: {
      use: "register"
    }
  });
  V.override = n6, V.on("start", () => w[ut].started = !0), w[ko] = w.ready, w.ready = q, w.printPlugins = V.prettyPrint.bind(V), V.once("preReady", () => {
    w.onClose((K, X) => {
      w[ut].closing = !0, f.closeRoutes(), Yb("preClose", w[ko], w, function() {
        if (w[ut].listening) {
          if (v === "idle")
            K.server.closeIdleConnections();
          else if (_ && v)
            K.server.closeAllConnections();
          else if (v === !0)
            for (const J of w[op])
              J.destroy(), w[op].delete(J);
        }
        !e.serverFactory || w[ut].listening ? K.server.close(function(J) {
          J && J.code !== "ERR_SERVER_NOT_RUNNING" ? X(null) : X();
        }) : process.nextTick(X, null);
      });
    });
  });
  const b = new JV({
    server: w,
    config: {}
  });
  return w.setNotFoundHandler(), m.arrange404(w), f.setup(e, {
    avvio: V,
    fourOhFour: m,
    logger: c,
    hasLogger: u,
    setupResponseListeners: E,
    throwIfAlreadyStarted: F,
    keepAliveConnections: y
  }), d.on("clientError", e.clientErrorHandler.bind(w)), nE.hasSubscribers && nE.publish({ fastify: w }), "asyncDispose" in Symbol && (w[Symbol.asyncDispose] = function() {
    return w.close();
  }), w;
  function F(K) {
    if (w[ut].started) throw new h6(K);
  }
  function H(K, X) {
    if (No === void 0 && (No = FV()), w[ut].started) {
      if (w[ut].closing) {
        const J = new m6();
        if (X) {
          X(J);
          return;
        } else
          return Promise.reject(J);
      }
      return No(p, K, X);
    }
    if (X)
      this.ready((J) => {
        J ? X(J, null) : No(p, K, X);
      });
    else
      return No((J, re) => {
        this.ready(function(fe) {
          if (fe) {
            re.emit("error", fe);
            return;
          }
          p(J, re);
        });
      }, K);
  }
  function q(K) {
    if (this[ut].readyPromise !== null) {
      if (K != null) {
        this[ut].readyPromise.then(() => K(null, w), K);
        return;
      }
      return this[ut].readyPromise;
    }
    let X, J;
    if (process.nextTick(re), this[ut].readyPromise = new Promise(function(ee, le) {
      X = ee, J = le;
    }), K)
      this[ut].readyPromise.then(() => K(null, w), K);
    else
      return this[ut].readyPromise;
    function re() {
      w[ko]((ee, le) => {
        ee || w[ut].started || w[ut].ready || w[ut].booting ? fe(ee) : (w[ut].booting = !0, Yb("onReady", w[ko], w, fe)), le();
      });
    }
    function fe(ee) {
      if (ee = ee != null && eE[ee.code] != null ? s6(ee, new eE[ee.code](ee.message)) : ee, ee)
        return J(ee);
      X(w), w[ut].booting = !1, w[ut].ready = !0, w[ut].promise = null;
    }
  }
  function $() {
    return this;
  }
  function x(K, X) {
    if (F('Cannot call "addHook"!'), X == null)
      throw new Pi.FST_ERR_HOOK_INVALID_HANDLER(K, X);
    if (K === "onSend" || K === "preSerialization" || K === "onError" || K === "preParsing") {
      if (X.constructor.name === "AsyncFunction" && X.length === 4)
        throw new Pi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (K === "onReady" || K === "onListen") {
      if (X.constructor.name === "AsyncFunction" && X.length !== 0)
        throw new Pi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (K === "onRequestAbort") {
      if (X.constructor.name === "AsyncFunction" && X.length !== 1)
        throw new Pi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    } else if (X.constructor.name === "AsyncFunction" && X.length === 3)
      throw new Pi.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
    return K === "onClose" ? this.onClose(X.bind(this)) : K === "onReady" || K === "onListen" || K === "onRoute" ? this[np].add(K, X) : this.after((re, fe) => {
      J.call(this, K, X), fe(re);
    }), this;
    function J(re, fe) {
      this[np].add(re, fe), this[rp].forEach((ee) => J.call(ee, re, fe));
    }
  }
  function A(K) {
    return F('Cannot call "addSchema"!'), this[Dn].add(K), this[rp].forEach((X) => X.addSchema(K)), this;
  }
  function P(K, X) {
    if (K.code === "ECONNRESET" || X.destroyed)
      return;
    let J, re, fe, ee;
    K.code === "ERR_HTTP_REQUEST_TIMEOUT" ? (re = "408", fe = Kc.STATUS_CODES[re], J = `{"error":"${fe}","message":"Client Timeout","statusCode":408}`, ee = "timeout") : K.code === "HPE_HEADER_OVERFLOW" ? (re = "431", fe = Kc.STATUS_CODES[re], J = `{"error":"${fe}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`, ee = "header_overflow") : (re = "400", fe = Kc.STATUS_CODES[re], J = `{"error":"${fe}","message":"Client Error","statusCode":400}`, ee = "error"), this.log.trace({ err: K }, `client ${ee}`), X.writable && X.write(`HTTP/1.1 ${re} ${fe}\r
Content-Length: ${J.length}\r
Content-Type: application/json\r
\r
${J}`), X.destroy(K);
  }
  function D(K, X) {
    K.headers["accept-version"] !== void 0 && (K.headers[zV] = K.headers["accept-version"], K.headers["accept-version"] = void 0), m.router.lookup(K, X);
  }
  function I(K, X, J) {
    if (a) {
      const fe = Zb(b.server, X), ee = Jb(b, c, X, fe), le = new Jc(fe, null, X, null, ee, b), xe = new Lo(J, le, ee);
      return s === !1 && ee.info({ req: le }, "incoming request"), a(new a6(K), le, xe);
    }
    const re = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${K}' is not a valid url component","statusCode":400}`;
    J.writeHead(400, {
      "Content-Type": "application/json",
      "Content-Length": re.length
    }), J.end(re);
  }
  function L(K, X, J) {
    if (K !== !1)
      return function(fe) {
        if (fe) {
          if (a) {
            const le = Zb(b.server, X), xe = Jb(b, c, X, le), ye = new Jc(le, null, X, null, xe, b), ve = new Lo(J, ye, xe);
            return s === !1 && xe.info({ req: ye }, "incoming request"), a(new o6(), ye, ve);
          }
          const ee = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          J.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": ee.length
          }), J.end(ee);
        }
      };
  }
  function j(K, X) {
    return F('Cannot call "setNotFoundHandler"!'), m.setNotFoundHandler.call(this, K, X, V, f.routeHandler), this;
  }
  function k(K) {
    return F('Cannot call "setValidatorCompiler"!'), this[Dn].setValidatorCompiler(K), this;
  }
  function U(K) {
    return F('Cannot call "setSchemaErrorFormatter"!'), iE(K), this[sp] = K.bind(this), this;
  }
  function M(K) {
    return F('Cannot call "setSerializerCompiler"!'), this[Dn].setSerializerCompiler(K), this;
  }
  function T(K) {
    F('Cannot call "setSchemaController"!');
    const X = this[Dn], J = Kb.buildSchemaController(X, Object.assign({}, X.opts, K));
    return this[Dn] = J, this.getSchema = J.getSchema.bind(J), this.getSchemas = J.getSchemas.bind(J), this;
  }
  function N(K) {
    return F('Cannot call "setReplySerializer"!'), this[Wb] = K, this;
  }
  function G(K) {
    if (F('Cannot call "setErrorHandler"!'), typeof K != "function")
      throw new y6();
    return this[Yc] = rE(this[Yc], K.bind(this)), this;
  }
  function O(K) {
    return F('Cannot call "setChildLoggerFactory"!'), this[ap] = K, this;
  }
  function S(K = {}) {
    return K.includeMeta = K.includeHooks ? K.includeMeta ? kh.concat(K.includeMeta) : kh : K.includeMeta, f.printRoutes(K);
  }
  function W(K, { rewriteUrl: X, logger: J }) {
    let re;
    return function(ee, le) {
      if (re === void 0 && (re = K.isAsyncConstraint()), X) {
        ee.originalUrl = ee.url;
        const xe = X.call(w, ee);
        if (typeof xe == "string")
          ee.url = xe;
        else {
          const ye = new g6(ee.url, typeof xe);
          ee.destroy(ye);
        }
      }
      K.routing(ee, le, L(re, ee, le));
    };
  }
  function z(K) {
    return F('Cannot call "setGenReqId"!'), this[cp] = Qb(this[ip].requestIdHeader, K), this;
  }
  function Q(K, { hasBody: X = !1 } = {}) {
    if (typeof K != "string" || Kc.METHODS.indexOf(K) === -1)
      throw new v6();
    X === !0 ? (this[yi].bodywith.add(K), this[yi].bodyless.delete(K)) : (this[yi].bodywith.delete(K), this[yi].bodyless.add(K));
    const J = K.toLowerCase();
    return this.hasDecorator(J) || this.decorate(J, function(re, fe, ee) {
      return f.prepareRoute.call(this, { method: K, url: re, options: fe, handler: ee });
    }), this;
  }
}
function iE(e) {
  if (typeof e != "function")
    throw new tE(typeof e);
  if (e.constructor.name === "AsyncFunction")
    throw new tE("AsyncFunction");
}
Fa.exports = my;
Fa.exports.errorCodes = Pi;
Fa.exports.fastify = my;
Fa.exports.default = my;
var b6 = Fa.exports;
const E6 = /* @__PURE__ */ La(b6);
function m1(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: w6 } = Object.prototype, { getPrototypeOf: gy } = Object, of = /* @__PURE__ */ ((e) => (t) => {
  const r = w6.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Vr = (e) => (e = e.toLowerCase(), (t) => of(t) === e), af = (e) => (t) => typeof t === e, { isArray: lo } = Array, fa = af("undefined");
function S6(e) {
  return e !== null && !fa(e) && e.constructor !== null && !fa(e.constructor) && _r(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const g1 = Vr("ArrayBuffer");
function x6(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && g1(e.buffer), t;
}
const R6 = af("string"), _r = af("function"), y1 = af("number"), cf = (e) => e !== null && typeof e == "object", $6 = (e) => e === !0 || e === !1, xl = (e) => {
  if (of(e) !== "object")
    return !1;
  const t = gy(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, T6 = Vr("Date"), O6 = Vr("File"), P6 = Vr("Blob"), C6 = Vr("FileList"), A6 = (e) => cf(e) && _r(e.pipe), I6 = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || _r(e.append) && ((t = of(e)) === "formdata" || // detect form-data instance
  t === "object" && _r(e.toString) && e.toString() === "[object FormData]"));
}, N6 = Vr("URLSearchParams"), [k6, D6, L6, F6] = ["ReadableStream", "Request", "Response", "Headers"].map(Vr), j6 = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Xa(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, i;
  if (typeof e != "object" && (e = [e]), lo(e))
    for (n = 0, i = e.length; n < i; n++)
      t.call(null, e[n], n, e);
  else {
    const s = r ? Object.getOwnPropertyNames(e) : Object.keys(e), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], t.call(null, e[a], a, e);
  }
}
function v1(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], t === i.toLowerCase())
      return i;
  return null;
}
const Ii = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, _1 = (e) => !fa(e) && e !== Ii;
function Dh() {
  const { caseless: e } = _1(this) && this || {}, t = {}, r = (n, i) => {
    const s = e && v1(t, i) || i;
    xl(t[s]) && xl(n) ? t[s] = Dh(t[s], n) : xl(n) ? t[s] = Dh({}, n) : lo(n) ? t[s] = n.slice() : t[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && Xa(arguments[n], r);
  return t;
}
const U6 = (e, t, r, { allOwnKeys: n } = {}) => (Xa(t, (i, s) => {
  r && _r(i) ? e[s] = m1(i, r) : e[s] = i;
}, { allOwnKeys: n }), e), M6 = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), H6 = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, q6 = (e, t, r, n) => {
  let i, s, o;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = r !== !1 && gy(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, B6 = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, z6 = (e) => {
  if (!e) return null;
  if (lo(e)) return e;
  let t = e.length;
  if (!y1(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, V6 = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && gy(Uint8Array)), G6 = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, W6 = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, K6 = Vr("HTMLFormElement"), Y6 = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), sE = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), J6 = Vr("RegExp"), b1 = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  Xa(r, (i, s) => {
    let o;
    (o = t(i, s, e)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(e, n);
}, X6 = (e) => {
  b1(e, (t, r) => {
    if (_r(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (_r(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, Z6 = (e, t) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return lo(e) ? n(e) : n(String(e).split(t)), r;
}, Q6 = () => {
}, e9 = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function t9(e) {
  return !!(e && _r(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const r9 = (e) => {
  const t = new Array(10), r = (n, i) => {
    if (cf(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[i] = n;
        const s = lo(n) ? [] : {};
        return Xa(n, (o, a) => {
          const c = r(o, i + 1);
          !fa(c) && (s[a] = c);
        }), t[i] = void 0, s;
      }
    }
    return n;
  };
  return r(e, 0);
}, n9 = Vr("AsyncFunction"), i9 = (e) => e && (cf(e) || _r(e)) && _r(e.then) && _r(e.catch), E1 = ((e, t) => e ? setImmediate : t ? ((r, n) => (Ii.addEventListener("message", ({ source: i, data: s }) => {
  i === Ii && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), Ii.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  _r(Ii.postMessage)
), s9 = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ii) : typeof process < "u" && process.nextTick || E1, Z = {
  isArray: lo,
  isArrayBuffer: g1,
  isBuffer: S6,
  isFormData: I6,
  isArrayBufferView: x6,
  isString: R6,
  isNumber: y1,
  isBoolean: $6,
  isObject: cf,
  isPlainObject: xl,
  isReadableStream: k6,
  isRequest: D6,
  isResponse: L6,
  isHeaders: F6,
  isUndefined: fa,
  isDate: T6,
  isFile: O6,
  isBlob: P6,
  isRegExp: J6,
  isFunction: _r,
  isStream: A6,
  isURLSearchParams: N6,
  isTypedArray: V6,
  isFileList: C6,
  forEach: Xa,
  merge: Dh,
  extend: U6,
  trim: j6,
  stripBOM: M6,
  inherits: H6,
  toFlatObject: q6,
  kindOf: of,
  kindOfTest: Vr,
  endsWith: B6,
  toArray: z6,
  forEachEntry: G6,
  matchAll: W6,
  isHTMLForm: K6,
  hasOwnProperty: sE,
  hasOwnProp: sE,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: b1,
  freezeMethods: X6,
  toObjectSet: Z6,
  toCamelCase: Y6,
  noop: Q6,
  toFiniteNumber: e9,
  findKey: v1,
  global: Ii,
  isContextDefined: _1,
  isSpecCompliantForm: t9,
  toJSONObject: r9,
  isAsyncFn: n9,
  isThenable: i9,
  setImmediate: E1,
  asap: s9
};
function ae(e, t, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Z.inherits(ae, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Z.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const w1 = ae.prototype, S1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  S1[e] = { value: e };
});
Object.defineProperties(ae, S1);
Object.defineProperty(w1, "isAxiosError", { value: !0 });
ae.from = (e, t, r, n, i, s) => {
  const o = Object.create(w1);
  return Z.toFlatObject(e, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), ae.call(o, e.message, t, r, n, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o;
};
var x1 = It.Stream, o9 = Sn, a9 = Gr;
function Gr() {
  this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
}
o9.inherits(Gr, x1);
Gr.create = function(e, t) {
  var r = new this();
  t = t || {};
  for (var n in t)
    r[n] = t[n];
  r.source = e;
  var i = e.emit;
  return e.emit = function() {
    return r._handleEmit(arguments), i.apply(e, arguments);
  }, e.on("error", function() {
  }), r.pauseStream && e.pause(), r;
};
Object.defineProperty(Gr.prototype, "readable", {
  configurable: !0,
  enumerable: !0,
  get: function() {
    return this.source.readable;
  }
});
Gr.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
Gr.prototype.resume = function() {
  this._released || this.release(), this.source.resume();
};
Gr.prototype.pause = function() {
  this.source.pause();
};
Gr.prototype.release = function() {
  this._released = !0, this._bufferedEvents.forEach((function(e) {
    this.emit.apply(this, e);
  }).bind(this)), this._bufferedEvents = [];
};
Gr.prototype.pipe = function() {
  var e = x1.prototype.pipe.apply(this, arguments);
  return this.resume(), e;
};
Gr.prototype._handleEmit = function(e) {
  if (this._released) {
    this.emit.apply(this, e);
    return;
  }
  e[0] === "data" && (this.dataSize += e[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(e);
};
Gr.prototype._checkIfMaxDataSizeExceeded = function() {
  if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
    this._maxDataSizeExceeded = !0;
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(e));
  }
};
var c9 = Sn, R1 = It.Stream, oE = a9, l9 = ct;
function ct() {
  this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
}
c9.inherits(ct, R1);
ct.create = function(e) {
  var t = new this();
  e = e || {};
  for (var r in e)
    t[r] = e[r];
  return t;
};
ct.isStreamLike = function(e) {
  return typeof e != "function" && typeof e != "string" && typeof e != "boolean" && typeof e != "number" && !Buffer.isBuffer(e);
};
ct.prototype.append = function(e) {
  var t = ct.isStreamLike(e);
  if (t) {
    if (!(e instanceof oE)) {
      var r = oE.create(e, {
        maxDataSize: 1 / 0,
        pauseStream: this.pauseStreams
      });
      e.on("data", this._checkDataSize.bind(this)), e = r;
    }
    this._handleErrors(e), this.pauseStreams && e.pause();
  }
  return this._streams.push(e), this;
};
ct.prototype.pipe = function(e, t) {
  return R1.prototype.pipe.call(this, e, t), this.resume(), e;
};
ct.prototype._getNext = function() {
  if (this._currentStream = null, this._insideLoop) {
    this._pendingNext = !0;
    return;
  }
  this._insideLoop = !0;
  try {
    do
      this._pendingNext = !1, this._realGetNext();
    while (this._pendingNext);
  } finally {
    this._insideLoop = !1;
  }
};
ct.prototype._realGetNext = function() {
  var e = this._streams.shift();
  if (typeof e > "u") {
    this.end();
    return;
  }
  if (typeof e != "function") {
    this._pipeNext(e);
    return;
  }
  var t = e;
  t((function(r) {
    var n = ct.isStreamLike(r);
    n && (r.on("data", this._checkDataSize.bind(this)), this._handleErrors(r)), this._pipeNext(r);
  }).bind(this));
};
ct.prototype._pipeNext = function(e) {
  this._currentStream = e;
  var t = ct.isStreamLike(e);
  if (t) {
    e.on("end", this._getNext.bind(this)), e.pipe(this, { end: !1 });
    return;
  }
  var r = e;
  this.write(r), this._getNext();
};
ct.prototype._handleErrors = function(e) {
  var t = this;
  e.on("error", function(r) {
    t._emitError(r);
  });
};
ct.prototype.write = function(e) {
  this.emit("data", e);
};
ct.prototype.pause = function() {
  this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
};
ct.prototype.resume = function() {
  this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
};
ct.prototype.end = function() {
  this._reset(), this.emit("end");
};
ct.prototype.destroy = function() {
  this._reset(), this.emit("close");
};
ct.prototype._reset = function() {
  this.writable = !1, this._streams = [], this._currentStream = null;
};
ct.prototype._checkDataSize = function() {
  if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(e));
  }
};
ct.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var e = this;
  this._streams.forEach(function(t) {
    t.dataSize && (e.dataSize += t.dataSize);
  }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
};
ct.prototype._emitError = function(e) {
  this._reset(), this.emit("error", e);
};
var $1 = {};
const u9 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: !0
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: !0
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: !0
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: !1
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/calendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: !0
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: !0
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: !0
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: !0
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/csvm+json": {
    source: "iana",
    compressible: !0
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: !0
  },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: !0
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: !0
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: !1
  },
  "application/edifact": {
    source: "iana",
    compressible: !1
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/elm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: !0
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fido.trusted-apps+json": {
    compressible: !0
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: !1
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: !0
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: !0
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: !0
  },
  "application/jrd+json": {
    source: "iana",
    compressible: !0
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: !1
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: !0
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: !0
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: !1
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: !1
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: !0
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: !0,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: !0
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: !0
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: !0
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sarif+json": {
    source: "iana",
    compressible: !0
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/scim+json": {
    source: "iana",
    compressible: !0
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: !0
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: !0
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: !0
  },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: !0
  },
  "application/taxii+json": {
    source: "iana",
    compressible: !0
  },
  "application/td+json": {
    source: "iana",
    compressible: !0
  },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: !0
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: !0,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: !1,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+json": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: !1,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-outlook": {
    compressible: !1,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: !0
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: !0
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: !1,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: !1
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: !0,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: !0
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: !1
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: !0,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: !0,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: !0,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: !0,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: !0,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: !0,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: !0,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: !0
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: !0
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: !1,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: !1
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: !1,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: !1
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: !1
  },
  "audio/vorbis": {
    source: "iana",
    compressible: !1
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: !1,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: !1,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: !1,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: !1
  },
  "image/png": {
    source: "iana",
    compressible: !1,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: !0,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: !1
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: !1
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: !0
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: !1
  },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: !1
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: !1
  },
  "multipart/form-data": {
    source: "iana",
    compressible: !1
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: !1
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: !1
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: !0
  },
  "text/cmd": {
    compressible: !0
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: !0
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: !0,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: !0,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: !0,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: !0
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: !0
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: !0,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: !0,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: !0,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: !0,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: !0,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: !0
  },
  "x-shader/x-vertex": {
    compressible: !0
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var f9 = u9;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(e) {
  var t = f9, r = _e.extname, n = /^\s*([^;\s]*)(?:;|\s|$)/, i = /^text\//i;
  e.charset = s, e.charsets = { lookup: s }, e.contentType = o, e.extension = a, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = c, e.types = /* @__PURE__ */ Object.create(null), u(e.extensions, e.types);
  function s(l) {
    if (!l || typeof l != "string")
      return !1;
    var f = n.exec(l), m = f && t[f[1].toLowerCase()];
    return m && m.charset ? m.charset : f && i.test(f[1]) ? "UTF-8" : !1;
  }
  function o(l) {
    if (!l || typeof l != "string")
      return !1;
    var f = l.indexOf("/") === -1 ? e.lookup(l) : l;
    if (!f)
      return !1;
    if (f.indexOf("charset") === -1) {
      var m = e.charset(f);
      m && (f += "; charset=" + m.toLowerCase());
    }
    return f;
  }
  function a(l) {
    if (!l || typeof l != "string")
      return !1;
    var f = n.exec(l), m = f && e.extensions[f[1].toLowerCase()];
    return !m || !m.length ? !1 : m[0];
  }
  function c(l) {
    if (!l || typeof l != "string")
      return !1;
    var f = r("x." + l).toLowerCase().substr(1);
    return f && e.types[f] || !1;
  }
  function u(l, f) {
    var m = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function(d) {
      var h = t[d], _ = h.extensions;
      if (!(!_ || !_.length)) {
        l[d] = _;
        for (var g = 0; g < _.length; g++) {
          var v = _[g];
          if (f[v]) {
            var y = m.indexOf(t[f[v]].source), E = m.indexOf(h.source);
            if (f[v] !== "application/octet-stream" && (y > E || y === E && f[v].substr(0, 12) === "application/"))
              continue;
          }
          f[v] = d;
        }
      }
    });
  }
})($1);
var d9 = p9;
function p9(e) {
  var t = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  t ? t(e) : setTimeout(e, 0);
}
var aE = d9, T1 = h9;
function h9(e) {
  var t = !1;
  return aE(function() {
    t = !0;
  }), function(n, i) {
    t ? e(n, i) : aE(function() {
      e(n, i);
    });
  };
}
var O1 = m9;
function m9(e) {
  Object.keys(e.jobs).forEach(g9.bind(e)), e.jobs = {};
}
function g9(e) {
  typeof this.jobs[e] == "function" && this.jobs[e]();
}
var cE = T1, y9 = O1, P1 = v9;
function v9(e, t, r, n) {
  var i = r.keyedList ? r.keyedList[r.index] : r.index;
  r.jobs[i] = _9(t, i, e[i], function(s, o) {
    i in r.jobs && (delete r.jobs[i], s ? y9(r) : r.results[i] = o, n(s, r.results));
  });
}
function _9(e, t, r, n) {
  var i;
  return e.length == 2 ? i = e(r, cE(n)) : i = e(r, t, cE(n)), i;
}
var C1 = b9;
function b9(e, t) {
  var r = !Array.isArray(e), n = {
    index: 0,
    keyedList: r || t ? Object.keys(e) : null,
    jobs: {},
    results: r ? {} : [],
    size: r ? Object.keys(e).length : e.length
  };
  return t && n.keyedList.sort(r ? t : function(i, s) {
    return t(e[i], e[s]);
  }), n;
}
var E9 = O1, w9 = T1, A1 = S9;
function S9(e) {
  Object.keys(this.jobs).length && (this.index = this.size, E9(this), w9(e)(null, this.results));
}
var x9 = P1, R9 = C1, $9 = A1, T9 = O9;
function O9(e, t, r) {
  for (var n = R9(e); n.index < (n.keyedList || e).length; )
    x9(e, t, n, function(i, s) {
      if (i) {
        r(i, s);
        return;
      }
      if (Object.keys(n.jobs).length === 0) {
        r(null, n.results);
        return;
      }
    }), n.index++;
  return $9.bind(n, r);
}
var lf = { exports: {} }, lE = P1, P9 = C1, C9 = A1;
lf.exports = A9;
lf.exports.ascending = I1;
lf.exports.descending = I9;
function A9(e, t, r, n) {
  var i = P9(e, r);
  return lE(e, t, i, function s(o, a) {
    if (o) {
      n(o, a);
      return;
    }
    if (i.index++, i.index < (i.keyedList || e).length) {
      lE(e, t, i, s);
      return;
    }
    n(null, i.results);
  }), C9.bind(i, n);
}
function I1(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function I9(e, t) {
  return -1 * I1(e, t);
}
var N1 = lf.exports, N9 = N1, k9 = D9;
function D9(e, t, r) {
  return N9(e, t, null, r);
}
var L9 = {
  parallel: T9,
  serial: k9,
  serialOrdered: N1
}, k1 = Object, F9 = Error, j9 = EvalError, U9 = RangeError, M9 = ReferenceError, H9 = SyntaxError, yy = TypeError, q9 = URIError, B9 = Math.abs, z9 = Math.floor, V9 = Math.max, G9 = Math.min, W9 = Math.pow, K9 = Math.round, Y9 = Number.isNaN || function(t) {
  return t !== t;
}, J9 = Y9, X9 = function(t) {
  return J9(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, Z9 = Object.getOwnPropertyDescriptor, Rl = Z9;
if (Rl)
  try {
    Rl([], "length");
  } catch {
    Rl = null;
  }
var D1 = Rl, $l = Object.defineProperty || !1;
if ($l)
  try {
    $l({}, "a", { value: 1 });
  } catch {
    $l = !1;
  }
var Q9 = $l, lp, uE;
function L1() {
  return uE || (uE = 1, lp = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = Symbol("test"), n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var i = 42;
    t[r] = i;
    for (var s in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(t);
    if (o.length !== 1 || o[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (a.value !== i || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), lp;
}
var up, fE;
function e5() {
  if (fE) return up;
  fE = 1;
  var e = typeof Symbol < "u" && Symbol, t = L1();
  return up = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, up;
}
var fp, dE;
function F1() {
  return dE || (dE = 1, fp = typeof Reflect < "u" && Reflect.getPrototypeOf || null), fp;
}
var dp, pE;
function j1() {
  if (pE) return dp;
  pE = 1;
  var e = k1;
  return dp = e.getPrototypeOf || null, dp;
}
var pp, hE;
function t5() {
  if (hE) return pp;
  hE = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", i = function(c, u) {
    for (var l = [], f = 0; f < c.length; f += 1)
      l[f] = c[f];
    for (var m = 0; m < u.length; m += 1)
      l[m + c.length] = u[m];
    return l;
  }, s = function(c, u) {
    for (var l = [], f = u, m = 0; f < c.length; f += 1, m += 1)
      l[m] = c[f];
    return l;
  }, o = function(a, c) {
    for (var u = "", l = 0; l < a.length; l += 1)
      u += a[l], l + 1 < a.length && (u += c);
    return u;
  };
  return pp = function(c) {
    var u = this;
    if (typeof u != "function" || t.apply(u) !== n)
      throw new TypeError(e + u);
    for (var l = s(arguments, 1), f, m = function() {
      if (this instanceof f) {
        var g = u.apply(
          this,
          i(l, arguments)
        );
        return Object(g) === g ? g : this;
      }
      return u.apply(
        c,
        i(l, arguments)
      );
    }, p = r(0, u.length - l.length), d = [], h = 0; h < p; h++)
      d[h] = "$" + h;
    if (f = Function("binder", "return function (" + o(d, ",") + "){ return binder.apply(this,arguments); }")(m), u.prototype) {
      var _ = function() {
      };
      _.prototype = u.prototype, f.prototype = new _(), _.prototype = null;
    }
    return f;
  }, pp;
}
var hp, mE;
function uf() {
  if (mE) return hp;
  mE = 1;
  var e = t5();
  return hp = Function.prototype.bind || e, hp;
}
var mp, gE;
function vy() {
  return gE || (gE = 1, mp = Function.prototype.call), mp;
}
var gp, yE;
function U1() {
  return yE || (yE = 1, gp = Function.prototype.apply), gp;
}
var yp, vE;
function r5() {
  return vE || (vE = 1, yp = typeof Reflect < "u" && Reflect && Reflect.apply), yp;
}
var vp, _E;
function n5() {
  if (_E) return vp;
  _E = 1;
  var e = uf(), t = U1(), r = vy(), n = r5();
  return vp = n || e.call(r, t), vp;
}
var _p, bE;
function i5() {
  if (bE) return _p;
  bE = 1;
  var e = uf(), t = yy, r = vy(), n = n5();
  return _p = function(s) {
    if (s.length < 1 || typeof s[0] != "function")
      throw new t("a function is required");
    return n(e, r, s);
  }, _p;
}
var bp, EE;
function s5() {
  if (EE) return bp;
  EE = 1;
  var e = i5(), t = D1, r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return bp = n && typeof n.get == "function" ? e([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(a) {
      return s(a == null ? a : i(a));
    }
  ) : !1, bp;
}
var Ep, wE;
function o5() {
  if (wE) return Ep;
  wE = 1;
  var e = F1(), t = j1(), r = s5();
  return Ep = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return t(i);
  } : r ? function(i) {
    return r(i);
  } : null, Ep;
}
var wp, SE;
function M1() {
  if (SE) return wp;
  SE = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = uf();
  return wp = r.call(e, t), wp;
}
var Oe, a5 = k1, c5 = F9, l5 = j9, u5 = U9, f5 = M9, Gs = H9, Fs = yy, d5 = q9, p5 = B9, h5 = z9, m5 = V9, g5 = G9, y5 = W9, v5 = K9, _5 = X9, H1 = Function, Sp = function(e) {
  try {
    return H1('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, da = D1, b5 = Q9, xp = function() {
  throw new Fs();
}, E5 = da ? function() {
  try {
    return arguments.callee, xp;
  } catch {
    try {
      return da(arguments, "callee").get;
    } catch {
      return xp;
    }
  }
}() : xp, ds = e5()(), Et = o5(), w5 = j1(), S5 = F1(), q1 = U1(), Za = vy(), bs = {}, x5 = typeof Uint8Array > "u" || !Et ? Oe : Et(Uint8Array), Di = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Oe : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Oe : ArrayBuffer,
  "%ArrayIteratorPrototype%": ds && Et ? Et([][Symbol.iterator]()) : Oe,
  "%AsyncFromSyncIteratorPrototype%": Oe,
  "%AsyncFunction%": bs,
  "%AsyncGenerator%": bs,
  "%AsyncGeneratorFunction%": bs,
  "%AsyncIteratorPrototype%": bs,
  "%Atomics%": typeof Atomics > "u" ? Oe : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Oe : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Oe : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Oe : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Oe : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": c5,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": l5,
  "%Float16Array%": typeof Float16Array > "u" ? Oe : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? Oe : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Oe : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Oe : FinalizationRegistry,
  "%Function%": H1,
  "%GeneratorFunction%": bs,
  "%Int8Array%": typeof Int8Array > "u" ? Oe : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Oe : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Oe : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": ds && Et ? Et(Et([][Symbol.iterator]())) : Oe,
  "%JSON%": typeof JSON == "object" ? JSON : Oe,
  "%Map%": typeof Map > "u" ? Oe : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !ds || !Et ? Oe : Et((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": a5,
  "%Object.getOwnPropertyDescriptor%": da,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Oe : Promise,
  "%Proxy%": typeof Proxy > "u" ? Oe : Proxy,
  "%RangeError%": u5,
  "%ReferenceError%": f5,
  "%Reflect%": typeof Reflect > "u" ? Oe : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Oe : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !ds || !Et ? Oe : Et((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Oe : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": ds && Et ? Et(""[Symbol.iterator]()) : Oe,
  "%Symbol%": ds ? Symbol : Oe,
  "%SyntaxError%": Gs,
  "%ThrowTypeError%": E5,
  "%TypedArray%": x5,
  "%TypeError%": Fs,
  "%Uint8Array%": typeof Uint8Array > "u" ? Oe : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Oe : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Oe : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Oe : Uint32Array,
  "%URIError%": d5,
  "%WeakMap%": typeof WeakMap > "u" ? Oe : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Oe : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Oe : WeakSet,
  "%Function.prototype.call%": Za,
  "%Function.prototype.apply%": q1,
  "%Object.defineProperty%": b5,
  "%Object.getPrototypeOf%": w5,
  "%Math.abs%": p5,
  "%Math.floor%": h5,
  "%Math.max%": m5,
  "%Math.min%": g5,
  "%Math.pow%": y5,
  "%Math.round%": v5,
  "%Math.sign%": _5,
  "%Reflect.getPrototypeOf%": S5
};
if (Et)
  try {
    null.error;
  } catch (e) {
    var R5 = Et(Et(e));
    Di["%Error.prototype%"] = R5;
  }
var $5 = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Sp("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Sp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Sp("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var n = e("%AsyncGeneratorFunction%");
    n && (r = n.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && Et && (r = Et(i.prototype));
  }
  return Di[t] = r, r;
}, xE = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Qa = uf(), Xl = M1(), T5 = Qa.call(Za, Array.prototype.concat), O5 = Qa.call(q1, Array.prototype.splice), RE = Qa.call(Za, String.prototype.replace), Zl = Qa.call(Za, String.prototype.slice), P5 = Qa.call(Za, RegExp.prototype.exec), C5 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, A5 = /\\(\\)?/g, I5 = function(t) {
  var r = Zl(t, 0, 1), n = Zl(t, -1);
  if (r === "%" && n !== "%")
    throw new Gs("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && r !== "%")
    throw new Gs("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return RE(t, C5, function(s, o, a, c) {
    i[i.length] = a ? RE(c, A5, "$1") : o || s;
  }), i;
}, N5 = function(t, r) {
  var n = t, i;
  if (Xl(xE, n) && (i = xE[n], n = "%" + i[0] + "%"), Xl(Di, n)) {
    var s = Di[n];
    if (s === bs && (s = $5(n)), typeof s > "u" && !r)
      throw new Fs("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: n,
      value: s
    };
  }
  throw new Gs("intrinsic " + t + " does not exist!");
}, k5 = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new Fs("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Fs('"allowMissing" argument must be a boolean');
  if (P5(/^%?[^%]*%?$/, t) === null)
    throw new Gs("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = I5(t), i = n.length > 0 ? n[0] : "", s = N5("%" + i + "%", r), o = s.name, a = s.value, c = !1, u = s.alias;
  u && (i = u[0], O5(n, T5([0, 1], u)));
  for (var l = 1, f = !0; l < n.length; l += 1) {
    var m = n[l], p = Zl(m, 0, 1), d = Zl(m, -1);
    if ((p === '"' || p === "'" || p === "`" || d === '"' || d === "'" || d === "`") && p !== d)
      throw new Gs("property names with quotes must have matching quotes");
    if ((m === "constructor" || !f) && (c = !0), i += "." + m, o = "%" + i + "%", Xl(Di, o))
      a = Di[o];
    else if (a != null) {
      if (!(m in a)) {
        if (!r)
          throw new Fs("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (da && l + 1 >= n.length) {
        var h = da(a, m);
        f = !!h, f && "get" in h && !("originalValue" in h.get) ? a = h.get : a = a[m];
      } else
        f = Xl(a, m), a = a[m];
      f && !c && (Di[o] = a);
    }
  }
  return a;
}, Rp, $E;
function D5() {
  if ($E) return Rp;
  $E = 1;
  var e = L1();
  return Rp = function() {
    return e() && !!Symbol.toStringTag;
  }, Rp;
}
var L5 = k5, TE = L5("%Object.defineProperty%", !0), F5 = D5()(), j5 = M1(), U5 = yy, Xc = F5 ? Symbol.toStringTag : null, M5 = function(t, r) {
  var n = arguments.length > 2 && !!arguments[2] && arguments[2].force, i = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof n < "u" && typeof n != "boolean" || typeof i < "u" && typeof i != "boolean")
    throw new U5("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  Xc && (n || !j5(t, Xc)) && (TE ? TE(t, Xc, {
    configurable: !i,
    enumerable: !1,
    value: r,
    writable: !1
  }) : t[Xc] = r);
}, H5 = function(e, t) {
  return Object.keys(t).forEach(function(r) {
    e[r] = e[r] || t[r];
  }), e;
}, _y = l9, q5 = Sn, $p = _e, B5 = vu, z5 = cm, V5 = qr.parse, G5 = Ue, W5 = It.Stream, Tp = $1, K5 = L9, Y5 = M5, Lh = H5, J5 = Ce;
q5.inherits(Ce, _y);
function Ce(e) {
  if (!(this instanceof Ce))
    return new Ce(e);
  this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], _y.call(this), e = e || {};
  for (var t in e)
    this[t] = e[t];
}
Ce.LINE_BREAK = `\r
`;
Ce.DEFAULT_CONTENT_TYPE = "application/octet-stream";
Ce.prototype.append = function(e, t, r) {
  r = r || {}, typeof r == "string" && (r = { filename: r });
  var n = _y.prototype.append.bind(this);
  if (typeof t == "number" && (t = "" + t), Array.isArray(t)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var i = this._multiPartHeader(e, t, r), s = this._multiPartFooter();
  n(i), n(t), n(s), this._trackLength(i, t, r);
};
Ce.prototype._trackLength = function(e, t, r) {
  var n = 0;
  r.knownLength != null ? n += +r.knownLength : Buffer.isBuffer(t) ? n = t.length : typeof t == "string" && (n = Buffer.byteLength(t)), this._valueLength += n, this._overheadLength += Buffer.byteLength(e) + Ce.LINE_BREAK.length, !(!t || !t.path && !(t.readable && Object.prototype.hasOwnProperty.call(t, "httpVersion")) && !(t instanceof W5)) && (r.knownLength || this._valuesToMeasure.push(t));
};
Ce.prototype._lengthRetriever = function(e, t) {
  Object.prototype.hasOwnProperty.call(e, "fd") ? e.end != null && e.end != 1 / 0 && e.start != null ? t(null, e.end + 1 - (e.start ? e.start : 0)) : G5.stat(e.path, function(r, n) {
    var i;
    if (r) {
      t(r);
      return;
    }
    i = n.size - (e.start ? e.start : 0), t(null, i);
  }) : Object.prototype.hasOwnProperty.call(e, "httpVersion") ? t(null, +e.headers["content-length"]) : Object.prototype.hasOwnProperty.call(e, "httpModule") ? (e.on("response", function(r) {
    e.pause(), t(null, +r.headers["content-length"]);
  }), e.resume()) : t("Unknown stream");
};
Ce.prototype._multiPartHeader = function(e, t, r) {
  if (typeof r.header == "string")
    return r.header;
  var n = this._getContentDisposition(t, r), i = this._getContentType(t, r), s = "", o = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + e + '"'].concat(n || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(i || [])
  };
  typeof r.header == "object" && Lh(o, r.header);
  var a;
  for (var c in o)
    if (Object.prototype.hasOwnProperty.call(o, c)) {
      if (a = o[c], a == null)
        continue;
      Array.isArray(a) || (a = [a]), a.length && (s += c + ": " + a.join("; ") + Ce.LINE_BREAK);
    }
  return "--" + this.getBoundary() + Ce.LINE_BREAK + s + Ce.LINE_BREAK;
};
Ce.prototype._getContentDisposition = function(e, t) {
  var r, n;
  return typeof t.filepath == "string" ? r = $p.normalize(t.filepath).replace(/\\/g, "/") : t.filename || e.name || e.path ? r = $p.basename(t.filename || e.name || e.path) : e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = $p.basename(e.client._httpMessage.path || "")), r && (n = 'filename="' + r + '"'), n;
};
Ce.prototype._getContentType = function(e, t) {
  var r = t.contentType;
  return !r && e.name && (r = Tp.lookup(e.name)), !r && e.path && (r = Tp.lookup(e.path)), !r && e.readable && Object.prototype.hasOwnProperty.call(e, "httpVersion") && (r = e.headers["content-type"]), !r && (t.filepath || t.filename) && (r = Tp.lookup(t.filepath || t.filename)), !r && typeof e == "object" && (r = Ce.DEFAULT_CONTENT_TYPE), r;
};
Ce.prototype._multiPartFooter = function() {
  return (function(e) {
    var t = Ce.LINE_BREAK, r = this._streams.length === 0;
    r && (t += this._lastBoundary()), e(t);
  }).bind(this);
};
Ce.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + Ce.LINE_BREAK;
};
Ce.prototype.getHeaders = function(e) {
  var t, r = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (r[t.toLowerCase()] = e[t]);
  return r;
};
Ce.prototype.setBoundary = function(e) {
  this._boundary = e;
};
Ce.prototype.getBoundary = function() {
  return this._boundary || this._generateBoundary(), this._boundary;
};
Ce.prototype.getBuffer = function() {
  for (var e = new Buffer.alloc(0), t = this.getBoundary(), r = 0, n = this._streams.length; r < n; r++)
    typeof this._streams[r] != "function" && (Buffer.isBuffer(this._streams[r]) ? e = Buffer.concat([e, this._streams[r]]) : e = Buffer.concat([e, Buffer.from(this._streams[r])]), (typeof this._streams[r] != "string" || this._streams[r].substring(2, t.length + 2) !== t) && (e = Buffer.concat([e, Buffer.from(Ce.LINE_BREAK)])));
  return Buffer.concat([e, Buffer.from(this._lastBoundary())]);
};
Ce.prototype._generateBoundary = function() {
  for (var e = "--------------------------", t = 0; t < 24; t++)
    e += Math.floor(Math.random() * 10).toString(16);
  this._boundary = e;
};
Ce.prototype.getLengthSync = function() {
  var e = this._overheadLength + this._valueLength;
  return this._streams.length && (e += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), e;
};
Ce.prototype.hasKnownLength = function() {
  var e = !0;
  return this._valuesToMeasure.length && (e = !1), e;
};
Ce.prototype.getLength = function(e) {
  var t = this._overheadLength + this._valueLength;
  if (this._streams.length && (t += this._lastBoundary().length), !this._valuesToMeasure.length) {
    process.nextTick(e.bind(this, null, t));
    return;
  }
  K5.parallel(this._valuesToMeasure, this._lengthRetriever, function(r, n) {
    if (r) {
      e(r);
      return;
    }
    n.forEach(function(i) {
      t += i;
    }), e(null, t);
  });
};
Ce.prototype.submit = function(e, t) {
  var r, n, i = { method: "post" };
  return typeof e == "string" ? (e = V5(e), n = Lh({
    port: e.port,
    path: e.pathname,
    host: e.hostname,
    protocol: e.protocol
  }, i)) : (n = Lh(e, i), n.port || (n.port = n.protocol == "https:" ? 443 : 80)), n.headers = this.getHeaders(e.headers), n.protocol == "https:" ? r = z5.request(n) : r = B5.request(n), this.getLength((function(s, o) {
    if (s && s !== "Unknown stream") {
      this._error(s);
      return;
    }
    if (o && r.setHeader("Content-Length", o), this.pipe(r), t) {
      var a, c = function(u, l) {
        return r.removeListener("error", c), r.removeListener("response", a), t.call(this, u, l);
      };
      a = c.bind(this, null), r.on("error", c), r.on("response", a);
    }
  }).bind(this)), r;
};
Ce.prototype._error = function(e) {
  this.error || (this.error = e, this.pause(), this.emit("error", e));
};
Ce.prototype.toString = function() {
  return "[object FormData]";
};
Y5(Ce, "FormData");
const B1 = /* @__PURE__ */ La(J5);
function Fh(e) {
  return Z.isPlainObject(e) || Z.isArray(e);
}
function z1(e) {
  return Z.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function OE(e, t, r) {
  return e ? e.concat(t).map(function(i, s) {
    return i = z1(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : t;
}
function X5(e) {
  return Z.isArray(e) && !e.some(Fh);
}
const Z5 = Z.toFlatObject(Z, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function ff(e, t, r) {
  if (!Z.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (B1 || FormData)(), r = Z.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, _) {
    return !Z.isUndefined(_[h]);
  });
  const n = r.metaTokens, i = r.visitor || l, s = r.dots, o = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && Z.isSpecCompliantForm(t);
  if (!Z.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(d) {
    if (d === null) return "";
    if (Z.isDate(d))
      return d.toISOString();
    if (!c && Z.isBlob(d))
      throw new ae("Blob is not supported. Use a Buffer instead.");
    return Z.isArrayBuffer(d) || Z.isTypedArray(d) ? c && typeof Blob == "function" ? new Blob([d]) : Buffer.from(d) : d;
  }
  function l(d, h, _) {
    let g = d;
    if (d && !_ && typeof d == "object") {
      if (Z.endsWith(h, "{}"))
        h = n ? h : h.slice(0, -2), d = JSON.stringify(d);
      else if (Z.isArray(d) && X5(d) || (Z.isFileList(d) || Z.endsWith(h, "[]")) && (g = Z.toArray(d)))
        return h = z1(h), g.forEach(function(y, E) {
          !(Z.isUndefined(y) || y === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? OE([h], E, s) : o === null ? h : h + "[]",
            u(y)
          );
        }), !1;
    }
    return Fh(d) ? !0 : (t.append(OE(_, h, s), u(d)), !1);
  }
  const f = [], m = Object.assign(Z5, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: Fh
  });
  function p(d, h) {
    if (!Z.isUndefined(d)) {
      if (f.indexOf(d) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      f.push(d), Z.forEach(d, function(g, v) {
        (!(Z.isUndefined(g) || g === null) && i.call(
          t,
          g,
          Z.isString(v) ? v.trim() : v,
          h,
          m
        )) === !0 && p(g, h ? h.concat(v) : [v]);
      }), f.pop();
    }
  }
  if (!Z.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function PE(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function V1(e, t) {
  this._pairs = [], e && ff(e, this, t);
}
const G1 = V1.prototype;
G1.append = function(t, r) {
  this._pairs.push([t, r]);
};
G1.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, PE);
  } : PE;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function Q5(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function by(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || Q5;
  Z.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(t, r) : s = Z.isURLSearchParams(t) ? t.toString() : new V1(t, r).toString(n), s) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class CE {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Z.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const Ey = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, e8 = qr.URLSearchParams, Op = "abcdefghijklmnopqrstuvwxyz", AE = "0123456789", W1 = {
  DIGIT: AE,
  ALPHA: Op,
  ALPHA_DIGIT: Op + Op.toUpperCase() + AE
}, t8 = (e = 16, t = W1.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t, i = new Uint32Array(e);
  Ki.randomFillSync(i);
  for (let s = 0; s < e; s++)
    r += t[i[s] % n];
  return r;
}, r8 = {
  isNode: !0,
  classes: {
    URLSearchParams: e8,
    FormData: B1,
    Blob: typeof Blob < "u" && Blob || null
  },
  ALPHABET: W1,
  generateString: t8,
  protocols: ["http", "https", "file", "data"]
}, wy = typeof window < "u" && typeof document < "u", jh = typeof navigator == "object" && navigator || void 0, n8 = wy && (!jh || ["ReactNative", "NativeScript", "NS"].indexOf(jh.product) < 0), i8 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", s8 = wy && window.location.href || "http://localhost", o8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: wy,
  hasStandardBrowserEnv: n8,
  hasStandardBrowserWebWorkerEnv: i8,
  navigator: jh,
  origin: s8
}, Symbol.toStringTag, { value: "Module" })), st = {
  ...o8,
  ...r8
};
function a8(e, t) {
  return ff(e, new st.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return st.isNode && Z.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function c8(e) {
  return Z.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function l8(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], t[s] = e[s];
  return t;
}
function K1(e) {
  function t(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), c = s >= r.length;
    return o = !o && Z.isArray(i) ? i.length : o, c ? (Z.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Z.isObject(i[o])) && (i[o] = []), t(r, n, i[o], s) && Z.isArray(i[o]) && (i[o] = l8(i[o])), !a);
  }
  if (Z.isFormData(e) && Z.isFunction(e.entries)) {
    const r = {};
    return Z.forEachEntry(e, (n, i) => {
      t(c8(n), i, r, 0);
    }), r;
  }
  return null;
}
function u8(e, t, r) {
  if (Z.isString(e))
    try {
      return (t || JSON.parse)(e), Z.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
const ec = {
  transitional: Ey,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Z.isObject(t);
    if (s && Z.isHTMLForm(t) && (t = new FormData(t)), Z.isFormData(t))
      return i ? JSON.stringify(K1(t)) : t;
    if (Z.isArrayBuffer(t) || Z.isBuffer(t) || Z.isStream(t) || Z.isFile(t) || Z.isBlob(t) || Z.isReadableStream(t))
      return t;
    if (Z.isArrayBufferView(t))
      return t.buffer;
    if (Z.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return a8(t, this.formSerializer).toString();
      if ((a = Z.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return ff(
          a ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), u8(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || ec.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Z.isResponse(t) || Z.isReadableStream(t))
      return t;
    if (t && Z.isString(t) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? ae.from(a, ae.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: st.classes.FormData,
    Blob: st.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Z.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  ec.headers[e] = {};
});
const f8 = Z.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), d8 = (e) => {
  const t = {};
  let r, n, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || t[r] && f8[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, IE = Symbol("internals");
function Fo(e) {
  return e && String(e).trim().toLowerCase();
}
function Tl(e) {
  return e === !1 || e == null ? e : Z.isArray(e) ? e.map(Tl) : String(e);
}
function p8(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const h8 = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Pp(e, t, r, n, i) {
  if (Z.isFunction(n))
    return n.call(this, t, r);
  if (i && (t = r), !!Z.isString(t)) {
    if (Z.isString(n))
      return t.indexOf(n) !== -1;
    if (Z.isRegExp(n))
      return n.test(t);
  }
}
function m8(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function g8(e, t) {
  const r = Z.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, t, i, s, o);
      },
      configurable: !0
    });
  });
}
let Lt = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const i = this;
    function s(a, c, u) {
      const l = Fo(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const f = Z.findKey(i, l);
      (!f || i[f] === void 0 || u === !0 || u === void 0 && i[f] !== !1) && (i[f || c] = Tl(a));
    }
    const o = (a, c) => Z.forEach(a, (u, l) => s(u, l, c));
    if (Z.isPlainObject(t) || t instanceof this.constructor)
      o(t, r);
    else if (Z.isString(t) && (t = t.trim()) && !h8(t))
      o(d8(t), r);
    else if (Z.isHeaders(t))
      for (const [a, c] of t.entries())
        s(c, a, n);
    else
      t != null && s(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = Fo(t), t) {
      const n = Z.findKey(this, t);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return p8(i);
        if (Z.isFunction(r))
          return r.call(this, i, n);
        if (Z.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = Fo(t), t) {
      const n = Z.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || Pp(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = Fo(o), o) {
        const a = Z.findKey(n, o);
        a && (!r || Pp(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Z.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!t || Pp(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const r = this, n = {};
    return Z.forEach(this, (i, s) => {
      const o = Z.findKey(n, s);
      if (o) {
        r[o] = Tl(i), delete r[s];
        return;
      }
      const a = t ? m8(s) : String(s).trim();
      a !== s && delete r[s], r[a] = Tl(i), n[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return Z.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = t && Z.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(t) {
    const n = (this[IE] = this[IE] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Fo(o);
      n[a] || (g8(i, o), n[a] = !0);
    }
    return Z.isArray(t) ? t.forEach(s) : s(t), this;
  }
};
Lt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Z.reduceDescriptors(Lt.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
Z.freezeMethods(Lt);
function Cp(e, t) {
  const r = this || ec, n = t || r, i = Lt.from(n.headers);
  let s = n.data;
  return Z.forEach(e, function(a) {
    s = a.call(r, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function Y1(e) {
  return !!(e && e.__CANCEL__);
}
function Qn(e, t, r) {
  ae.call(this, e ?? "canceled", ae.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Z.inherits(Qn, ae, {
  __CANCEL__: !0
});
function Rs(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new ae(
    "Request failed with status code " + r.status,
    [ae.ERR_BAD_REQUEST, ae.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function y8(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function v8(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Sy(e, t, r) {
  let n = !y8(t);
  return e && (n || r == !1) ? v8(e, t) : t;
}
var J1 = {}, _8 = qr.parse, b8 = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
}, E8 = String.prototype.endsWith || function(e) {
  return e.length <= this.length && this.indexOf(e, this.length - e.length) !== -1;
};
function w8(e) {
  var t = typeof e == "string" ? _8(e) : e || {}, r = t.protocol, n = t.host, i = t.port;
  if (typeof n != "string" || !n || typeof r != "string" || (r = r.split(":", 1)[0], n = n.replace(/:\d*$/, ""), i = parseInt(i) || b8[r] || 0, !S8(n, i)))
    return "";
  var s = $s("npm_config_" + r + "_proxy") || $s(r + "_proxy") || $s("npm_config_proxy") || $s("all_proxy");
  return s && s.indexOf("://") === -1 && (s = r + "://" + s), s;
}
function S8(e, t) {
  var r = ($s("npm_config_no_proxy") || $s("no_proxy")).toLowerCase();
  return r ? r === "*" ? !1 : r.split(/[,\s]/).every(function(n) {
    if (!n)
      return !0;
    var i = n.match(/^(.+):(\d+)$/), s = i ? i[1] : n, o = i ? parseInt(i[2]) : 0;
    return o && o !== t ? !0 : /^[.*]/.test(s) ? (s.charAt(0) === "*" && (s = s.slice(1)), !E8.call(e, s)) : e !== s;
  }) : !0;
}
function $s(e) {
  return process.env[e.toLowerCase()] || process.env[e.toUpperCase()] || "";
}
J1.getProxyForUrl = w8;
var xy = { exports: {} }, Uh = { exports: {} }, Zc = { exports: {} }, Ap, NE;
function x8() {
  if (NE) return Ap;
  NE = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, i = n * 7, s = n * 365.25;
  Ap = function(l, f) {
    f = f || {};
    var m = typeof l;
    if (m === "string" && l.length > 0)
      return o(l);
    if (m === "number" && isFinite(l))
      return f.long ? c(l) : a(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function o(l) {
    if (l = String(l), !(l.length > 100)) {
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (f) {
        var m = parseFloat(f[1]), p = (f[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return m * s;
          case "weeks":
          case "week":
          case "w":
            return m * i;
          case "days":
          case "day":
          case "d":
            return m * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return m * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return m * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return m * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return m;
          default:
            return;
        }
      }
    }
  }
  function a(l) {
    var f = Math.abs(l);
    return f >= n ? Math.round(l / n) + "d" : f >= r ? Math.round(l / r) + "h" : f >= t ? Math.round(l / t) + "m" : f >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function c(l) {
    var f = Math.abs(l);
    return f >= n ? u(l, f, n, "day") : f >= r ? u(l, f, r, "hour") : f >= t ? u(l, f, t, "minute") : f >= e ? u(l, f, e, "second") : l + " ms";
  }
  function u(l, f, m, p) {
    var d = f >= m * 1.5;
    return Math.round(l / m) + " " + p + (d ? "s" : "");
  }
  return Ap;
}
var Ip, kE;
function X1() {
  if (kE) return Ip;
  kE = 1;
  function e(t) {
    n.debug = n, n.default = n, n.coerce = u, n.disable = a, n.enable = s, n.enabled = c, n.humanize = x8(), n.destroy = l, Object.keys(t).forEach((f) => {
      n[f] = t[f];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(f) {
      let m = 0;
      for (let p = 0; p < f.length; p++)
        m = (m << 5) - m + f.charCodeAt(p), m |= 0;
      return n.colors[Math.abs(m) % n.colors.length];
    }
    n.selectColor = r;
    function n(f) {
      let m, p = null, d, h;
      function _(...g) {
        if (!_.enabled)
          return;
        const v = _, y = Number(/* @__PURE__ */ new Date()), E = y - (m || y);
        v.diff = E, v.prev = m, v.curr = y, m = y, g[0] = n.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let R = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (C, V) => {
          if (C === "%%")
            return "%";
          R++;
          const b = n.formatters[V];
          if (typeof b == "function") {
            const F = g[R];
            C = b.call(v, F), g.splice(R, 1), R--;
          }
          return C;
        }), n.formatArgs.call(v, g), (v.log || n.log).apply(v, g);
      }
      return _.namespace = f, _.useColors = n.useColors(), _.color = n.selectColor(f), _.extend = i, _.destroy = n.destroy, Object.defineProperty(_, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (d !== n.namespaces && (d = n.namespaces, h = n.enabled(f)), h),
        set: (g) => {
          p = g;
        }
      }), typeof n.init == "function" && n.init(_), _;
    }
    function i(f, m) {
      const p = n(this.namespace + (typeof m > "u" ? ":" : m) + f);
      return p.log = this.log, p;
    }
    function s(f) {
      n.save(f), n.namespaces = f, n.names = [], n.skips = [];
      const m = (typeof f == "string" ? f : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const p of m)
        p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
    }
    function o(f, m) {
      let p = 0, d = 0, h = -1, _ = 0;
      for (; p < f.length; )
        if (d < m.length && (m[d] === f[p] || m[d] === "*"))
          m[d] === "*" ? (h = d, _ = p, d++) : (p++, d++);
        else if (h !== -1)
          d = h + 1, _++, p = _;
        else
          return !1;
      for (; d < m.length && m[d] === "*"; )
        d++;
      return d === m.length;
    }
    function a() {
      const f = [
        ...n.names,
        ...n.skips.map((m) => "-" + m)
      ].join(",");
      return n.enable(""), f;
    }
    function c(f) {
      for (const m of n.skips)
        if (o(f, m))
          return !1;
      for (const m of n.names)
        if (o(f, m))
          return !0;
      return !1;
    }
    function u(f) {
      return f instanceof Error ? f.stack || f.message : f;
    }
    function l() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
  return Ip = e, Ip;
}
var DE;
function R8() {
  return DE || (DE = 1, function(e, t) {
    t.formatArgs = n, t.save = i, t.load = s, t.useColors = r, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
      let c = !1;
      return () => {
        c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let c;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (c = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(c[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(c) {
      if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      c.splice(1, 0, u, "color: inherit");
      let l = 0, f = 0;
      c[0].replace(/%[a-zA-Z%]/g, (m) => {
        m !== "%%" && (l++, m === "%c" && (f = l));
      }), c.splice(f, 0, u);
    }
    t.log = console.debug || console.log || (() => {
    });
    function i(c) {
      try {
        c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function s() {
      let c;
      try {
        c = t.storage.getItem("debug");
      } catch {
      }
      return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = X1()(t);
    const { formatters: a } = e.exports;
    a.j = function(c) {
      try {
        return JSON.stringify(c);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(Zc, Zc.exports)), Zc.exports;
}
var Qc = { exports: {} }, Np, LE;
function $8() {
  return LE || (LE = 1, Np = (e, t = process.argv) => {
    const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
    return n !== -1 && (i === -1 || n < i);
  }), Np;
}
var kp, FE;
function T8() {
  if (FE) return kp;
  FE = 1;
  const e = _u, t = DS, r = $8(), { env: n } = process;
  let i;
  r("no-color") || r("no-colors") || r("color=false") || r("color=never") ? i = 0 : (r("color") || r("colors") || r("color=true") || r("color=always")) && (i = 1), "FORCE_COLOR" in n && (n.FORCE_COLOR === "true" ? i = 1 : n.FORCE_COLOR === "false" ? i = 0 : i = n.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(n.FORCE_COLOR, 10), 3));
  function s(c) {
    return c === 0 ? !1 : {
      level: c,
      hasBasic: !0,
      has256: c >= 2,
      has16m: c >= 3
    };
  }
  function o(c, u) {
    if (i === 0)
      return 0;
    if (r("color=16m") || r("color=full") || r("color=truecolor"))
      return 3;
    if (r("color=256"))
      return 2;
    if (c && !u && i === void 0)
      return 0;
    const l = i || 0;
    if (n.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const f = e.release().split(".");
      return Number(f[0]) >= 10 && Number(f[2]) >= 10586 ? Number(f[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in n)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((f) => f in n) || n.CI_NAME === "codeship" ? 1 : l;
    if ("TEAMCITY_VERSION" in n)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0;
    if (n.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in n) {
      const f = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (n.TERM_PROGRAM) {
        case "iTerm.app":
          return f >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(n.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(n.TERM) || "COLORTERM" in n ? 1 : l;
  }
  function a(c) {
    const u = o(c, c && c.isTTY);
    return s(u);
  }
  return kp = {
    supportsColor: a,
    stdout: s(o(!0, t.isatty(1))),
    stderr: s(o(!0, t.isatty(2)))
  }, kp;
}
var jE;
function O8() {
  return jE || (jE = 1, function(e, t) {
    const r = DS, n = Sn;
    t.init = l, t.log = a, t.formatArgs = s, t.save = c, t.load = u, t.useColors = i, t.destroy = n.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), t.colors = [6, 2, 3, 4, 5, 1];
    try {
      const m = T8();
      m && (m.stderr || m).level >= 2 && (t.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    t.inspectOpts = Object.keys(process.env).filter((m) => /^debug_/i.test(m)).reduce((m, p) => {
      const d = p.substring(6).toLowerCase().replace(/_([a-z])/g, (_, g) => g.toUpperCase());
      let h = process.env[p];
      return /^(yes|on|true|enabled)$/i.test(h) ? h = !0 : /^(no|off|false|disabled)$/i.test(h) ? h = !1 : h === "null" ? h = null : h = Number(h), m[d] = h, m;
    }, {});
    function i() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : r.isatty(process.stderr.fd);
    }
    function s(m) {
      const { namespace: p, useColors: d } = this;
      if (d) {
        const h = this.color, _ = "\x1B[3" + (h < 8 ? h : "8;5;" + h), g = `  ${_};1m${p} \x1B[0m`;
        m[0] = g + m[0].split(`
`).join(`
` + g), m.push(_ + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        m[0] = o() + p + " " + m[0];
    }
    function o() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function a(...m) {
      return process.stderr.write(n.formatWithOptions(t.inspectOpts, ...m) + `
`);
    }
    function c(m) {
      m ? process.env.DEBUG = m : delete process.env.DEBUG;
    }
    function u() {
      return process.env.DEBUG;
    }
    function l(m) {
      m.inspectOpts = {};
      const p = Object.keys(t.inspectOpts);
      for (let d = 0; d < p.length; d++)
        m.inspectOpts[p[d]] = t.inspectOpts[p[d]];
    }
    e.exports = X1()(t);
    const { formatters: f } = e.exports;
    f.o = function(m) {
      return this.inspectOpts.colors = this.useColors, n.inspect(m, this.inspectOpts).split(`
`).map((p) => p.trim()).join(" ");
    }, f.O = function(m) {
      return this.inspectOpts.colors = this.useColors, n.inspect(m, this.inspectOpts);
    };
  }(Qc, Qc.exports)), Qc.exports;
}
typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? Uh.exports = R8() : Uh.exports = O8();
var Z1 = Uh.exports, jo, P8 = function() {
  if (!jo) {
    try {
      jo = Z1("follow-redirects");
    } catch {
    }
    typeof jo != "function" && (jo = function() {
    });
  }
  jo.apply(null, arguments);
}, tc = qr, pa = tc.URL, C8 = vu, A8 = cm, Ry = It.Writable, $y = Da, Q1 = P8;
(function() {
  var t = typeof process < "u", r = typeof window < "u" && typeof document < "u", n = Bi(Error.captureStackTrace);
  !t && (r || !n) && console.warn("The follow-redirects package should be excluded from browser builds.");
})();
var Ty = !1;
try {
  $y(new pa(""));
} catch (e) {
  Ty = e.code === "ERR_INVALID_URL";
}
var I8 = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
], Oy = ["abort", "aborted", "connect", "error", "socket", "timeout"], Py = /* @__PURE__ */ Object.create(null);
Oy.forEach(function(e) {
  Py[e] = function(t, r, n) {
    this._redirectable.emit(e, t, r, n);
  };
});
var Mh = rc(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
), Hh = rc(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
), N8 = rc(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  Hh
), k8 = rc(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
), D8 = rc(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
), L8 = Ry.prototype.destroy || tT;
function fr(e, t) {
  Ry.call(this), this._sanitizeOptions(e), this._options = e, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], t && this.on("response", t);
  var r = this;
  this._onNativeResponse = function(n) {
    try {
      r._processResponse(n);
    } catch (i) {
      r.emit("error", i instanceof Hh ? i : new Hh({ cause: i }));
    }
  }, this._performRequest();
}
fr.prototype = Object.create(Ry.prototype);
fr.prototype.abort = function() {
  Ay(this._currentRequest), this._currentRequest.abort(), this.emit("abort");
};
fr.prototype.destroy = function(e) {
  return Ay(this._currentRequest, e), L8.call(this, e), this;
};
fr.prototype.write = function(e, t, r) {
  if (this._ending)
    throw new D8();
  if (!Li(e) && !U8(e))
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  if (Bi(t) && (r = t, t = null), e.length === 0) {
    r && r();
    return;
  }
  this._requestBodyLength + e.length <= this._options.maxBodyLength ? (this._requestBodyLength += e.length, this._requestBodyBuffers.push({ data: e, encoding: t }), this._currentRequest.write(e, t, r)) : (this.emit("error", new k8()), this.abort());
};
fr.prototype.end = function(e, t, r) {
  if (Bi(e) ? (r = e, e = t = null) : Bi(t) && (r = t, t = null), !e)
    this._ended = this._ending = !0, this._currentRequest.end(null, null, r);
  else {
    var n = this, i = this._currentRequest;
    this.write(e, t, function() {
      n._ended = !0, i.end(null, null, r);
    }), this._ending = !0;
  }
};
fr.prototype.setHeader = function(e, t) {
  this._options.headers[e] = t, this._currentRequest.setHeader(e, t);
};
fr.prototype.removeHeader = function(e) {
  delete this._options.headers[e], this._currentRequest.removeHeader(e);
};
fr.prototype.setTimeout = function(e, t) {
  var r = this;
  function n(o) {
    o.setTimeout(e), o.removeListener("timeout", o.destroy), o.addListener("timeout", o.destroy);
  }
  function i(o) {
    r._timeout && clearTimeout(r._timeout), r._timeout = setTimeout(function() {
      r.emit("timeout"), s();
    }, e), n(o);
  }
  function s() {
    r._timeout && (clearTimeout(r._timeout), r._timeout = null), r.removeListener("abort", s), r.removeListener("error", s), r.removeListener("response", s), r.removeListener("close", s), t && r.removeListener("timeout", t), r.socket || r._currentRequest.removeListener("socket", i);
  }
  return t && this.on("timeout", t), this.socket ? i(this.socket) : this._currentRequest.once("socket", i), this.on("socket", n), this.on("abort", s), this.on("error", s), this.on("response", s), this.on("close", s), this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(e) {
  fr.prototype[e] = function(t, r) {
    return this._currentRequest[e](t, r);
  };
});
["aborted", "connection", "socket"].forEach(function(e) {
  Object.defineProperty(fr.prototype, e, {
    get: function() {
      return this._currentRequest[e];
    }
  });
});
fr.prototype._sanitizeOptions = function(e) {
  if (e.headers || (e.headers = {}), e.host && (e.hostname || (e.hostname = e.host), delete e.host), !e.pathname && e.path) {
    var t = e.path.indexOf("?");
    t < 0 ? e.pathname = e.path : (e.pathname = e.path.substring(0, t), e.search = e.path.substring(t));
  }
};
fr.prototype._performRequest = function() {
  var e = this._options.protocol, t = this._options.nativeProtocols[e];
  if (!t)
    throw new TypeError("Unsupported protocol " + e);
  if (this._options.agents) {
    var r = e.slice(0, -1);
    this._options.agent = this._options.agents[r];
  }
  var n = this._currentRequest = t.request(this._options, this._onNativeResponse);
  n._redirectable = this;
  for (var i of Oy)
    n.on(i, Py[i]);
  if (this._currentUrl = /^\//.test(this._options.path) ? tc.format(this._options) : (
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path
  ), this._isRedirect) {
    var s = 0, o = this, a = this._requestBodyBuffers;
    (function c(u) {
      if (n === o._currentRequest)
        if (u)
          o.emit("error", u);
        else if (s < a.length) {
          var l = a[s++];
          n.finished || n.write(l.data, l.encoding, c);
        } else o._ended && n.end();
    })();
  }
};
fr.prototype._processResponse = function(e) {
  var t = e.statusCode;
  this._options.trackRedirects && this._redirects.push({
    url: this._currentUrl,
    headers: e.headers,
    statusCode: t
  });
  var r = e.headers.location;
  if (!r || this._options.followRedirects === !1 || t < 300 || t >= 400) {
    e.responseUrl = this._currentUrl, e.redirects = this._redirects, this.emit("response", e), this._requestBodyBuffers = [];
    return;
  }
  if (Ay(this._currentRequest), e.destroy(), ++this._redirectCount > this._options.maxRedirects)
    throw new N8();
  var n, i = this._options.beforeRedirect;
  i && (n = Object.assign({
    // The Host header was set by nativeProtocol.request
    Host: e.req.getHeader("host")
  }, this._options.headers));
  var s = this._options.method;
  ((t === 301 || t === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource […]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) […]
  t === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], Dp(/^content-/i, this._options.headers));
  var o = Dp(/^host$/i, this._options.headers), a = Cy(this._currentUrl), c = o || a.host, u = /^\w+:/.test(r) ? this._currentUrl : tc.format(Object.assign(a, { host: c })), l = F8(r, u);
  if (Q1("redirecting to", l.href), this._isRedirect = !0, qh(l, this._options), (l.protocol !== a.protocol && l.protocol !== "https:" || l.host !== c && !j8(l.host, c)) && Dp(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers), Bi(i)) {
    var f = {
      headers: e.headers,
      statusCode: t
    }, m = {
      url: u,
      method: s,
      headers: n
    };
    i(this._options, f, m), this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function eT(e) {
  var t = {
    maxRedirects: 21,
    maxBodyLength: 10485760
  }, r = {};
  return Object.keys(e).forEach(function(n) {
    var i = n + ":", s = r[i] = e[n], o = t[n] = Object.create(s);
    function a(u, l, f) {
      return M8(u) ? u = qh(u) : Li(u) ? u = qh(Cy(u)) : (f = l, l = rT(u), u = { protocol: i }), Bi(l) && (f = l, l = null), l = Object.assign({
        maxRedirects: t.maxRedirects,
        maxBodyLength: t.maxBodyLength
      }, u, l), l.nativeProtocols = r, !Li(l.host) && !Li(l.hostname) && (l.hostname = "::1"), $y.equal(l.protocol, i, "protocol mismatch"), Q1("options", l), new fr(l, f);
    }
    function c(u, l, f) {
      var m = o.request(u, l, f);
      return m.end(), m;
    }
    Object.defineProperties(o, {
      request: { value: a, configurable: !0, enumerable: !0, writable: !0 },
      get: { value: c, configurable: !0, enumerable: !0, writable: !0 }
    });
  }), t;
}
function tT() {
}
function Cy(e) {
  var t;
  if (Ty)
    t = new pa(e);
  else if (t = rT(tc.parse(e)), !Li(t.protocol))
    throw new Mh({ input: e });
  return t;
}
function F8(e, t) {
  return Ty ? new pa(e, t) : Cy(tc.resolve(t, e));
}
function rT(e) {
  if (/^\[/.test(e.hostname) && !/^\[[:0-9a-f]+\]$/i.test(e.hostname))
    throw new Mh({ input: e.href || e });
  if (/^\[/.test(e.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(e.host))
    throw new Mh({ input: e.href || e });
  return e;
}
function qh(e, t) {
  var r = t || {};
  for (var n of I8)
    r[n] = e[n];
  return r.hostname.startsWith("[") && (r.hostname = r.hostname.slice(1, -1)), r.port !== "" && (r.port = Number(r.port)), r.path = r.search ? r.pathname + r.search : r.pathname, r;
}
function Dp(e, t) {
  var r;
  for (var n in t)
    e.test(n) && (r = t[n], delete t[n]);
  return r === null || typeof r > "u" ? void 0 : String(r).trim();
}
function rc(e, t, r) {
  function n(i) {
    Bi(Error.captureStackTrace) && Error.captureStackTrace(this, this.constructor), Object.assign(this, i || {}), this.code = e, this.message = this.cause ? t + ": " + this.cause.message : t;
  }
  return n.prototype = new (r || Error)(), Object.defineProperties(n.prototype, {
    constructor: {
      value: n,
      enumerable: !1
    },
    name: {
      value: "Error [" + e + "]",
      enumerable: !1
    }
  }), n;
}
function Ay(e, t) {
  for (var r of Oy)
    e.removeListener(r, Py[r]);
  e.on("error", tT), e.destroy(t);
}
function j8(e, t) {
  $y(Li(e) && Li(t));
  var r = e.length - t.length - 1;
  return r > 0 && e[r] === "." && e.endsWith(t);
}
function Li(e) {
  return typeof e == "string" || e instanceof String;
}
function Bi(e) {
  return typeof e == "function";
}
function U8(e) {
  return typeof e == "object" && "length" in e;
}
function M8(e) {
  return pa && e instanceof pa;
}
xy.exports = eT({ http: C8, https: A8 });
xy.exports.wrap = eT;
var H8 = xy.exports;
const q8 = /* @__PURE__ */ La(H8), Ql = "1.8.4";
function nT(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
const B8 = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function z8(e, t, r) {
  const n = r && r.Blob || st.classes.Blob, i = nT(e);
  if (t === void 0 && n && (t = !0), i === "data") {
    e = i.length ? e.slice(i.length + 1) : e;
    const s = B8.exec(e);
    if (!s)
      throw new ae("Invalid URL", ae.ERR_INVALID_URL);
    const o = s[1], a = s[2], c = s[3], u = Buffer.from(decodeURIComponent(c), a ? "base64" : "utf8");
    if (t) {
      if (!n)
        throw new ae("Blob is not supported", ae.ERR_NOT_SUPPORT);
      return new n([u], { type: o });
    }
    return u;
  }
  throw new ae("Unsupported protocol " + i, ae.ERR_NOT_SUPPORT);
}
const Lp = Symbol("internals");
class UE extends It.Transform {
  constructor(t) {
    t = Z.toFlatObject(t, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (n, i) => !Z.isUndefined(i[n])), super({
      readableHighWaterMark: t.chunkSize
    });
    const r = this[Lp] = {
      timeWindow: t.timeWindow,
      chunkSize: t.chunkSize,
      maxRate: t.maxRate,
      minChunkSize: t.minChunkSize,
      bytesSeen: 0,
      isCaptured: !1,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (n) => {
      n === "progress" && (r.isCaptured || (r.isCaptured = !0));
    });
  }
  _read(t) {
    const r = this[Lp];
    return r.onReadCallback && r.onReadCallback(), super._read(t);
  }
  _transform(t, r, n) {
    const i = this[Lp], s = i.maxRate, o = this.readableHighWaterMark, a = i.timeWindow, c = 1e3 / a, u = s / c, l = i.minChunkSize !== !1 ? Math.max(i.minChunkSize, u * 0.01) : 0, f = (p, d) => {
      const h = Buffer.byteLength(p);
      i.bytesSeen += h, i.bytes += h, i.isCaptured && this.emit("progress", i.bytesSeen), this.push(p) ? process.nextTick(d) : i.onReadCallback = () => {
        i.onReadCallback = null, process.nextTick(d);
      };
    }, m = (p, d) => {
      const h = Buffer.byteLength(p);
      let _ = null, g = o, v, y = 0;
      if (s) {
        const E = Date.now();
        (!i.ts || (y = E - i.ts) >= a) && (i.ts = E, v = u - i.bytes, i.bytes = v < 0 ? -v : 0, y = 0), v = u - i.bytes;
      }
      if (s) {
        if (v <= 0)
          return setTimeout(() => {
            d(null, p);
          }, a - y);
        v < g && (g = v);
      }
      g && h > g && h - g > l && (_ = p.subarray(g), p = p.subarray(0, g)), f(p, _ ? () => {
        process.nextTick(d, null, _);
      } : d);
    };
    m(t, function p(d, h) {
      if (d)
        return n(d);
      h ? m(h, p) : n(null);
    });
  }
}
const { asyncIterator: ME } = Symbol, iT = async function* (e) {
  e.stream ? yield* e.stream() : e.arrayBuffer ? yield await e.arrayBuffer() : e[ME] ? yield* e[ME]() : yield e;
}, V8 = st.ALPHABET.ALPHA_DIGIT + "-_", ha = typeof TextEncoder == "function" ? new TextEncoder() : new Sn.TextEncoder(), Gn = `\r
`, G8 = ha.encode(Gn), W8 = 2;
class K8 {
  constructor(t, r) {
    const { escapeName: n } = this.constructor, i = Z.isString(r);
    let s = `Content-Disposition: form-data; name="${n(t)}"${!i && r.name ? `; filename="${n(r.name)}"` : ""}${Gn}`;
    i ? r = ha.encode(String(r).replace(/\r?\n|\r\n?/g, Gn)) : s += `Content-Type: ${r.type || "application/octet-stream"}${Gn}`, this.headers = ha.encode(s + Gn), this.contentLength = i ? r.byteLength : r.size, this.size = this.headers.byteLength + this.contentLength + W8, this.name = t, this.value = r;
  }
  async *encode() {
    yield this.headers;
    const { value: t } = this;
    Z.isTypedArray(t) ? yield t : yield* iT(t), yield G8;
  }
  static escapeName(t) {
    return String(t).replace(/[\r\n"]/g, (r) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[r]);
  }
}
const Y8 = (e, t, r) => {
  const {
    tag: n = "form-data-boundary",
    size: i = 25,
    boundary: s = n + "-" + st.generateString(i, V8)
  } = r || {};
  if (!Z.isFormData(e))
    throw TypeError("FormData instance required");
  if (s.length < 1 || s.length > 70)
    throw Error("boundary must be 10-70 characters long");
  const o = ha.encode("--" + s + Gn), a = ha.encode("--" + s + "--" + Gn + Gn);
  let c = a.byteLength;
  const u = Array.from(e.entries()).map(([f, m]) => {
    const p = new K8(f, m);
    return c += p.size, p;
  });
  c += o.byteLength * u.length, c = Z.toFiniteNumber(c);
  const l = {
    "Content-Type": `multipart/form-data; boundary=${s}`
  };
  return Number.isFinite(c) && (l["Content-Length"] = c), t && t(l), xC.from(async function* () {
    for (const f of u)
      yield o, yield* f.encode();
    yield a;
  }());
};
class J8 extends It.Transform {
  __transform(t, r, n) {
    this.push(t), n();
  }
  _transform(t, r, n) {
    if (t.length !== 0 && (this._transform = this.__transform, t[0] !== 120)) {
      const i = Buffer.alloc(2);
      i[0] = 120, i[1] = 156, this.push(i, r);
    }
    this.__transform(t, r, n);
  }
}
const X8 = (e, t) => Z.isAsyncFn(e) ? function(...r) {
  const n = r.pop();
  e.apply(this, r).then((i) => {
    try {
      t ? n(null, ...t(i)) : n(null, i);
    } catch (s) {
      n(s);
    }
  }, n);
} : e;
function Z8(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let i = 0, s = 0, o;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const u = Date.now(), l = n[s];
    o || (o = u), r[i] = c, n[i] = u;
    let f = s, m = 0;
    for (; f !== i; )
      m += r[f++], f = f % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), u - o < t)
      return;
    const p = l && u - l;
    return p ? Math.round(m * 1e3 / p) : void 0;
  };
}
function Q8(e, t) {
  let r = 0, n = 1e3 / t, i, s;
  const o = (u, l = Date.now()) => {
    r = l, i = null, s && (clearTimeout(s), s = null), e.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), f = l - r;
    f >= n ? o(u, l) : (i = u, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - f)));
  }, () => i && o(i)];
}
const Ws = (e, t, r = 3) => {
  let n = 0;
  const i = Z8(50, 250);
  return Q8((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, c = o - n, u = i(c), l = o <= a;
    n = o;
    const f = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && a && l ? (a - o) / u : void 0,
      event: s,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, r);
}, eu = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
}, tu = (e) => (...t) => Z.asap(() => e(...t)), HE = {
  flush: Pr.constants.Z_SYNC_FLUSH,
  finishFlush: Pr.constants.Z_SYNC_FLUSH
}, eG = {
  flush: Pr.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: Pr.constants.BROTLI_OPERATION_FLUSH
}, qE = Z.isFunction(Pr.createBrotliDecompress), { http: tG, https: rG } = q8, nG = /https:?/, BE = st.protocols.map((e) => e + ":"), zE = (e, [t, r]) => (e.on("end", r).on("error", r), t);
function iG(e, t) {
  e.beforeRedirects.proxy && e.beforeRedirects.proxy(e), e.beforeRedirects.config && e.beforeRedirects.config(e, t);
}
function sT(e, t, r) {
  let n = t;
  if (!n && n !== !1) {
    const i = J1.getProxyForUrl(r);
    i && (n = new URL(i));
  }
  if (n) {
    if (n.username && (n.auth = (n.username || "") + ":" + (n.password || "")), n.auth) {
      (n.auth.username || n.auth.password) && (n.auth = (n.auth.username || "") + ":" + (n.auth.password || ""));
      const s = Buffer.from(n.auth, "utf8").toString("base64");
      e.headers["Proxy-Authorization"] = "Basic " + s;
    }
    e.headers.host = e.hostname + (e.port ? ":" + e.port : "");
    const i = n.hostname || n.host;
    e.hostname = i, e.host = i, e.port = n.port, e.path = r, n.protocol && (e.protocol = n.protocol.includes(":") ? n.protocol : `${n.protocol}:`);
  }
  e.beforeRedirects.proxy = function(s) {
    sT(s, t, s.href);
  };
}
const sG = typeof process < "u" && Z.kindOf(process) === "process", oG = (e) => new Promise((t, r) => {
  let n, i;
  const s = (c, u) => {
    i || (i = !0, n && n(c, u));
  }, o = (c) => {
    s(c), t(c);
  }, a = (c) => {
    s(c, !0), r(c);
  };
  e(o, a, (c) => n = c).catch(a);
}), aG = ({ address: e, family: t }) => {
  if (!Z.isString(e))
    throw TypeError("address must be a string");
  return {
    address: e,
    family: t || (e.indexOf(".") < 0 ? 6 : 4)
  };
}, VE = (e, t) => aG(Z.isObject(e) ? e : { address: e, family: t }), cG = sG && function(t) {
  return oG(async function(n, i, s) {
    let { data: o, lookup: a, family: c } = t;
    const { responseType: u, responseEncoding: l } = t, f = t.method.toUpperCase();
    let m, p = !1, d;
    if (a) {
      const D = X8(a, (I) => Z.isArray(I) ? I : [I]);
      a = (I, L, j) => {
        D(I, L, (k, U, M) => {
          if (k)
            return j(k);
          const T = Z.isArray(U) ? U.map((N) => VE(N)) : [VE(U, M)];
          L.all ? j(k, T) : j(k, T[0].address, T[0].family);
        });
      };
    }
    const h = new _C(), _ = () => {
      t.cancelToken && t.cancelToken.unsubscribe(g), t.signal && t.signal.removeEventListener("abort", g), h.removeAllListeners();
    };
    s((D, I) => {
      m = !0, I && (p = !0, _());
    });
    function g(D) {
      h.emit("abort", !D || D.type ? new Qn(null, t, d) : D);
    }
    h.once("abort", i), (t.cancelToken || t.signal) && (t.cancelToken && t.cancelToken.subscribe(g), t.signal && (t.signal.aborted ? g() : t.signal.addEventListener("abort", g)));
    const v = Sy(t.baseURL, t.url, t.allowAbsoluteUrls), y = new URL(v, st.hasBrowserEnv ? st.origin : void 0), E = y.protocol || BE[0];
    if (E === "data:") {
      let D;
      if (f !== "GET")
        return Rs(n, i, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: t
        });
      try {
        D = z8(t.url, u === "blob", {
          Blob: t.env && t.env.Blob
        });
      } catch (I) {
        throw ae.from(I, ae.ERR_BAD_REQUEST, t);
      }
      return u === "text" ? (D = D.toString(l), (!l || l === "utf8") && (D = Z.stripBOM(D))) : u === "stream" && (D = It.Readable.from(D)), Rs(n, i, {
        data: D,
        status: 200,
        statusText: "OK",
        headers: new Lt(),
        config: t
      });
    }
    if (BE.indexOf(E) === -1)
      return i(new ae(
        "Unsupported protocol " + E,
        ae.ERR_BAD_REQUEST,
        t
      ));
    const R = Lt.from(t.headers).normalize();
    R.set("User-Agent", "axios/" + Ql, !1);
    const { onUploadProgress: w, onDownloadProgress: C } = t, V = t.maxRate;
    let b, F;
    if (Z.isSpecCompliantForm(o)) {
      const D = R.getContentType(/boundary=([-_\w\d]{10,70})/i);
      o = Y8(o, (I) => {
        R.set(I);
      }, {
        tag: `axios-${Ql}-boundary`,
        boundary: D && D[1] || void 0
      });
    } else if (Z.isFormData(o) && Z.isFunction(o.getHeaders)) {
      if (R.set(o.getHeaders()), !R.hasContentLength())
        try {
          const D = await Sn.promisify(o.getLength).call(o);
          Number.isFinite(D) && D >= 0 && R.setContentLength(D);
        } catch {
        }
    } else if (Z.isBlob(o) || Z.isFile(o))
      o.size && R.setContentType(o.type || "application/octet-stream"), R.setContentLength(o.size || 0), o = It.Readable.from(iT(o));
    else if (o && !Z.isStream(o)) {
      if (!Buffer.isBuffer(o)) if (Z.isArrayBuffer(o))
        o = Buffer.from(new Uint8Array(o));
      else if (Z.isString(o))
        o = Buffer.from(o, "utf-8");
      else
        return i(new ae(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          ae.ERR_BAD_REQUEST,
          t
        ));
      if (R.setContentLength(o.length, !1), t.maxBodyLength > -1 && o.length > t.maxBodyLength)
        return i(new ae(
          "Request body larger than maxBodyLength limit",
          ae.ERR_BAD_REQUEST,
          t
        ));
    }
    const H = Z.toFiniteNumber(R.getContentLength());
    Z.isArray(V) ? (b = V[0], F = V[1]) : b = F = V, o && (w || b) && (Z.isStream(o) || (o = It.Readable.from(o, { objectMode: !1 })), o = It.pipeline([o, new UE({
      maxRate: Z.toFiniteNumber(b)
    })], Z.noop), w && o.on("progress", zE(
      o,
      eu(
        H,
        Ws(tu(w), !1, 3)
      )
    )));
    let q;
    if (t.auth) {
      const D = t.auth.username || "", I = t.auth.password || "";
      q = D + ":" + I;
    }
    if (!q && y.username) {
      const D = y.username, I = y.password;
      q = D + ":" + I;
    }
    q && R.delete("authorization");
    let $;
    try {
      $ = by(
        y.pathname + y.search,
        t.params,
        t.paramsSerializer
      ).replace(/^\?/, "");
    } catch (D) {
      const I = new Error(D.message);
      return I.config = t, I.url = t.url, I.exists = !0, i(I);
    }
    R.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (qE ? ", br" : ""),
      !1
    );
    const x = {
      path: $,
      method: f,
      headers: R.toJSON(),
      agents: { http: t.httpAgent, https: t.httpsAgent },
      auth: q,
      protocol: E,
      family: c,
      beforeRedirect: iG,
      beforeRedirects: {}
    };
    !Z.isUndefined(a) && (x.lookup = a), t.socketPath ? x.socketPath = t.socketPath : (x.hostname = y.hostname.startsWith("[") ? y.hostname.slice(1, -1) : y.hostname, x.port = y.port, sT(x, t.proxy, E + "//" + y.hostname + (y.port ? ":" + y.port : "") + x.path));
    let A;
    const P = nG.test(x.protocol);
    if (x.agent = P ? t.httpsAgent : t.httpAgent, t.transport ? A = t.transport : t.maxRedirects === 0 ? A = P ? cm : vu : (t.maxRedirects && (x.maxRedirects = t.maxRedirects), t.beforeRedirect && (x.beforeRedirects.config = t.beforeRedirect), A = P ? rG : tG), t.maxBodyLength > -1 ? x.maxBodyLength = t.maxBodyLength : x.maxBodyLength = 1 / 0, t.insecureHTTPParser && (x.insecureHTTPParser = t.insecureHTTPParser), d = A.request(x, function(I) {
      if (d.destroyed) return;
      const L = [I], j = +I.headers["content-length"];
      if (C || F) {
        const N = new UE({
          maxRate: Z.toFiniteNumber(F)
        });
        C && N.on("progress", zE(
          N,
          eu(
            j,
            Ws(tu(C), !0, 3)
          )
        )), L.push(N);
      }
      let k = I;
      const U = I.req || d;
      if (t.decompress !== !1 && I.headers["content-encoding"])
        switch ((f === "HEAD" || I.statusCode === 204) && delete I.headers["content-encoding"], (I.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            L.push(Pr.createUnzip(HE)), delete I.headers["content-encoding"];
            break;
          case "deflate":
            L.push(new J8()), L.push(Pr.createUnzip(HE)), delete I.headers["content-encoding"];
            break;
          case "br":
            qE && (L.push(Pr.createBrotliDecompress(eG)), delete I.headers["content-encoding"]);
        }
      k = L.length > 1 ? It.pipeline(L, Z.noop) : L[0];
      const M = It.finished(k, () => {
        M(), _();
      }), T = {
        status: I.statusCode,
        statusText: I.statusMessage,
        headers: new Lt(I.headers),
        config: t,
        request: U
      };
      if (u === "stream")
        T.data = k, Rs(n, i, T);
      else {
        const N = [];
        let G = 0;
        k.on("data", function(S) {
          N.push(S), G += S.length, t.maxContentLength > -1 && G > t.maxContentLength && (p = !0, k.destroy(), i(new ae(
            "maxContentLength size of " + t.maxContentLength + " exceeded",
            ae.ERR_BAD_RESPONSE,
            t,
            U
          )));
        }), k.on("aborted", function() {
          if (p)
            return;
          const S = new ae(
            "stream has been aborted",
            ae.ERR_BAD_RESPONSE,
            t,
            U
          );
          k.destroy(S), i(S);
        }), k.on("error", function(S) {
          d.destroyed || i(ae.from(S, null, t, U));
        }), k.on("end", function() {
          try {
            let S = N.length === 1 ? N[0] : Buffer.concat(N);
            u !== "arraybuffer" && (S = S.toString(l), (!l || l === "utf8") && (S = Z.stripBOM(S))), T.data = S;
          } catch (S) {
            return i(ae.from(S, null, t, T.request, T));
          }
          Rs(n, i, T);
        });
      }
      h.once("abort", (N) => {
        k.destroyed || (k.emit("error", N), k.destroy());
      });
    }), h.once("abort", (D) => {
      i(D), d.destroy(D);
    }), d.on("error", function(I) {
      i(ae.from(I, null, t, d));
    }), d.on("socket", function(I) {
      I.setKeepAlive(!0, 1e3 * 60);
    }), t.timeout) {
      const D = parseInt(t.timeout, 10);
      if (Number.isNaN(D)) {
        i(new ae(
          "error trying to parse `config.timeout` to int",
          ae.ERR_BAD_OPTION_VALUE,
          t,
          d
        ));
        return;
      }
      d.setTimeout(D, function() {
        if (m) return;
        let L = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
        const j = t.transitional || Ey;
        t.timeoutErrorMessage && (L = t.timeoutErrorMessage), i(new ae(
          L,
          j.clarifyTimeoutError ? ae.ETIMEDOUT : ae.ECONNABORTED,
          t,
          d
        )), g();
      });
    }
    if (Z.isStream(o)) {
      let D = !1, I = !1;
      o.on("end", () => {
        D = !0;
      }), o.once("error", (L) => {
        I = !0, d.destroy(L);
      }), o.on("close", () => {
        !D && !I && g(new Qn("Request stream has been aborted", t, d));
      }), o.pipe(d);
    } else
      d.end(o);
  });
}, lG = st.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (r) => (r = new URL(r, st.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(
  new URL(st.origin),
  st.navigator && /(msie|trident)/i.test(st.navigator.userAgent)
) : () => !0, uG = st.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, i, s) {
      const o = [e + "=" + encodeURIComponent(t)];
      Z.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Z.isString(n) && o.push("path=" + n), Z.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
), GE = (e) => e instanceof Lt ? { ...e } : e;
function zi(e, t) {
  t = t || {};
  const r = {};
  function n(u, l, f, m) {
    return Z.isPlainObject(u) && Z.isPlainObject(l) ? Z.merge.call({ caseless: m }, u, l) : Z.isPlainObject(l) ? Z.merge({}, l) : Z.isArray(l) ? l.slice() : l;
  }
  function i(u, l, f, m) {
    if (Z.isUndefined(l)) {
      if (!Z.isUndefined(u))
        return n(void 0, u, f, m);
    } else return n(u, l, f, m);
  }
  function s(u, l) {
    if (!Z.isUndefined(l))
      return n(void 0, l);
  }
  function o(u, l) {
    if (Z.isUndefined(l)) {
      if (!Z.isUndefined(u))
        return n(void 0, u);
    } else return n(void 0, l);
  }
  function a(u, l, f) {
    if (f in t)
      return n(u, l);
    if (f in e)
      return n(void 0, u);
  }
  const c = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (u, l, f) => i(GE(u), GE(l), f, !0)
  };
  return Z.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const f = c[l] || i, m = f(e[l], t[l], l);
    Z.isUndefined(m) && f !== a || (r[l] = m);
  }), r;
}
const oT = (e) => {
  const t = zi({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = t;
  t.headers = o = Lt.from(o), t.url = by(Sy(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (Z.isFormData(r)) {
    if (st.hasStandardBrowserEnv || st.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
      o.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (st.hasStandardBrowserEnv && (n && Z.isFunction(n) && (n = n(t)), n || n !== !1 && lG(t.url))) {
    const u = i && s && uG.read(s);
    u && o.set(i, u);
  }
  return t;
}, fG = typeof XMLHttpRequest < "u", dG = fG && function(e) {
  return new Promise(function(r, n) {
    const i = oT(e);
    let s = i.data;
    const o = Lt.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: u } = i, l, f, m, p, d;
    function h() {
      p && p(), d && d(), i.cancelToken && i.cancelToken.unsubscribe(l), i.signal && i.signal.removeEventListener("abort", l);
    }
    let _ = new XMLHttpRequest();
    _.open(i.method.toUpperCase(), i.url, !0), _.timeout = i.timeout;
    function g() {
      if (!_)
        return;
      const y = Lt.from(
        "getAllResponseHeaders" in _ && _.getAllResponseHeaders()
      ), R = {
        data: !a || a === "text" || a === "json" ? _.responseText : _.response,
        status: _.status,
        statusText: _.statusText,
        headers: y,
        config: e,
        request: _
      };
      Rs(function(C) {
        r(C), h();
      }, function(C) {
        n(C), h();
      }, R), _ = null;
    }
    "onloadend" in _ ? _.onloadend = g : _.onreadystatechange = function() {
      !_ || _.readyState !== 4 || _.status === 0 && !(_.responseURL && _.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, _.onabort = function() {
      _ && (n(new ae("Request aborted", ae.ECONNABORTED, e, _)), _ = null);
    }, _.onerror = function() {
      n(new ae("Network Error", ae.ERR_NETWORK, e, _)), _ = null;
    }, _.ontimeout = function() {
      let E = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const R = i.transitional || Ey;
      i.timeoutErrorMessage && (E = i.timeoutErrorMessage), n(new ae(
        E,
        R.clarifyTimeoutError ? ae.ETIMEDOUT : ae.ECONNABORTED,
        e,
        _
      )), _ = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in _ && Z.forEach(o.toJSON(), function(E, R) {
      _.setRequestHeader(R, E);
    }), Z.isUndefined(i.withCredentials) || (_.withCredentials = !!i.withCredentials), a && a !== "json" && (_.responseType = i.responseType), u && ([m, d] = Ws(u, !0), _.addEventListener("progress", m)), c && _.upload && ([f, p] = Ws(c), _.upload.addEventListener("progress", f), _.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (l = (y) => {
      _ && (n(!y || y.type ? new Qn(null, e, _) : y), _.abort(), _ = null);
    }, i.cancelToken && i.cancelToken.subscribe(l), i.signal && (i.signal.aborted ? l() : i.signal.addEventListener("abort", l)));
    const v = nT(i.url);
    if (v && st.protocols.indexOf(v) === -1) {
      n(new ae("Unsupported protocol " + v + ":", ae.ERR_BAD_REQUEST, e));
      return;
    }
    _.send(s || null);
  });
}, pG = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), i;
    const s = function(u) {
      if (!i) {
        i = !0, a();
        const l = u instanceof Error ? u : this.reason;
        n.abort(l instanceof ae ? l : new Qn(l instanceof Error ? l.message : l));
      }
    };
    let o = t && setTimeout(() => {
      o = null, s(new ae(`timeout ${t} of ms exceeded`, ae.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(s) : u.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", s));
    const { signal: c } = n;
    return c.unsubscribe = () => Z.asap(a), c;
  }
}, hG = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + t, yield e.slice(n, i), n = i;
}, mG = async function* (e, t) {
  for await (const r of gG(e))
    yield* hG(r, t);
}, gG = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
}, WE = (e, t, r, n) => {
  const i = mG(e, t);
  let s = 0, o, a = (c) => {
    o || (o = !0, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await i.next();
        if (u) {
          a(), c.close();
          return;
        }
        let f = l.byteLength;
        if (r) {
          let m = s += f;
          r(m);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, df = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", aT = df && typeof ReadableStream == "function", yG = df && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), cT = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, vG = aT && cT(() => {
  let e = !1;
  const t = new Request(st.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), KE = 64 * 1024, Bh = aT && cT(() => Z.isReadableStream(new Response("").body)), ru = {
  stream: Bh && ((e) => e.body)
};
df && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !ru[t] && (ru[t] = Z.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new ae(`Response type '${t}' is not supported`, ae.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const _G = async (e) => {
  if (e == null)
    return 0;
  if (Z.isBlob(e))
    return e.size;
  if (Z.isSpecCompliantForm(e))
    return (await new Request(st.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (Z.isArrayBufferView(e) || Z.isArrayBuffer(e))
    return e.byteLength;
  if (Z.isURLSearchParams(e) && (e = e + ""), Z.isString(e))
    return (await yG(e)).byteLength;
}, bG = async (e, t) => {
  const r = Z.toFiniteNumber(e.getContentLength());
  return r ?? _G(t);
}, EG = df && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: f = "same-origin",
    fetchOptions: m
  } = oT(e);
  u = u ? (u + "").toLowerCase() : "text";
  let p = pG([i, s && s.toAbortSignal()], o), d;
  const h = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let _;
  try {
    if (c && vG && r !== "get" && r !== "head" && (_ = await bG(l, n)) !== 0) {
      let R = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), w;
      if (Z.isFormData(n) && (w = R.headers.get("content-type")) && l.setContentType(w), R.body) {
        const [C, V] = eu(
          _,
          Ws(tu(c))
        );
        n = WE(R.body, KE, C, V);
      }
    }
    Z.isString(f) || (f = f ? "include" : "omit");
    const g = "credentials" in Request.prototype;
    d = new Request(t, {
      ...m,
      signal: p,
      method: r.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: g ? f : void 0
    });
    let v = await fetch(d);
    const y = Bh && (u === "stream" || u === "response");
    if (Bh && (a || y && h)) {
      const R = {};
      ["status", "statusText", "headers"].forEach((b) => {
        R[b] = v[b];
      });
      const w = Z.toFiniteNumber(v.headers.get("content-length")), [C, V] = a && eu(
        w,
        Ws(tu(a), !0)
      ) || [];
      v = new Response(
        WE(v.body, KE, C, () => {
          V && V(), h && h();
        }),
        R
      );
    }
    u = u || "text";
    let E = await ru[Z.findKey(ru, u) || "text"](v, e);
    return !y && h && h(), await new Promise((R, w) => {
      Rs(R, w, {
        data: E,
        headers: Lt.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: e,
        request: d
      });
    });
  } catch (g) {
    throw h && h(), g && g.name === "TypeError" && /fetch/i.test(g.message) ? Object.assign(
      new ae("Network Error", ae.ERR_NETWORK, e, d),
      {
        cause: g.cause || g
      }
    ) : ae.from(g, g && g.code, e, d);
  }
}), zh = {
  http: cG,
  xhr: dG,
  fetch: EG
};
Z.forEach(zh, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const YE = (e) => `- ${e}`, wG = (e) => Z.isFunction(e) || e === null || e === !1, lT = {
  getAdapter: (e) => {
    e = Z.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const i = {};
    for (let s = 0; s < t; s++) {
      r = e[s];
      let o;
      if (n = r, !wG(r) && (n = zh[(o = String(r)).toLowerCase()], n === void 0))
        throw new ae(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? s.length > 1 ? `since :
` + s.map(YE).join(`
`) : " " + YE(s[0]) : "as no adapter specified";
      throw new ae(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: zh
};
function Fp(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Qn(null, e);
}
function JE(e) {
  return Fp(e), e.headers = Lt.from(e.headers), e.data = Cp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), lT.getAdapter(e.adapter || ec.adapter)(e).then(function(n) {
    return Fp(e), n.data = Cp.call(
      e,
      e.transformResponse,
      n
    ), n.headers = Lt.from(n.headers), n;
  }, function(n) {
    return Y1(n) || (Fp(e), n && n.response && (n.response.data = Cp.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = Lt.from(n.response.headers))), Promise.reject(n);
  });
}
const pf = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  pf[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const XE = {};
pf.transitional = function(t, r, n) {
  function i(s, o) {
    return "[Axios v" + Ql + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (t === !1)
      throw new ae(
        i(o, " has been removed" + (r ? " in " + r : "")),
        ae.ERR_DEPRECATED
      );
    return r && !XE[o] && (XE[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(s, o, a) : !0;
  };
};
pf.spelling = function(t) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function SG(e, t, r) {
  if (typeof e != "object")
    throw new ae("options must be an object", ae.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = t[s];
    if (o) {
      const a = e[s], c = a === void 0 || o(a, s, e);
      if (c !== !0)
        throw new ae("option " + s + " must be " + c, ae.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new ae("Unknown option " + s, ae.ERR_BAD_OPTION);
  }
}
const Ol = {
  assertOptions: SG,
  validators: pf
}, Jr = Ol.validators;
let Fi = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new CE(),
      response: new CE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = zi(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && Ol.assertOptions(n, {
      silentJSONParsing: Jr.transitional(Jr.boolean),
      forcedJSONParsing: Jr.transitional(Jr.boolean),
      clarifyTimeoutError: Jr.transitional(Jr.boolean)
    }, !1), i != null && (Z.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : Ol.assertOptions(i, {
      encode: Jr.function,
      serialize: Jr.function
    }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Ol.assertOptions(r, {
      baseUrl: Jr.spelling("baseURL"),
      withXsrfToken: Jr.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Z.merge(
      s.common,
      s[r.method]
    );
    s && Z.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (d) => {
        delete s[d];
      }
    ), r.headers = Lt.concat(o, s);
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(h) {
      typeof h.runWhen == "function" && h.runWhen(r) === !1 || (c = c && h.synchronous, a.unshift(h.fulfilled, h.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(h) {
      u.push(h.fulfilled, h.rejected);
    });
    let l, f = 0, m;
    if (!c) {
      const d = [JE.bind(this), void 0];
      for (d.unshift.apply(d, a), d.push.apply(d, u), m = d.length, l = Promise.resolve(r); f < m; )
        l = l.then(d[f++], d[f++]);
      return l;
    }
    m = a.length;
    let p = r;
    for (f = 0; f < m; ) {
      const d = a[f++], h = a[f++];
      try {
        p = d(p);
      } catch (_) {
        h.call(this, _);
        break;
      }
    }
    try {
      l = JE.call(this, p);
    } catch (d) {
      return Promise.reject(d);
    }
    for (f = 0, m = u.length; f < m; )
      l = l.then(u[f++], u[f++]);
    return l;
  }
  getUri(t) {
    t = zi(this.defaults, t);
    const r = Sy(t.baseURL, t.url, t.allowAbsoluteUrls);
    return by(r, t.params, t.paramsSerializer);
  }
};
Z.forEach(["delete", "get", "head", "options"], function(t) {
  Fi.prototype[t] = function(r, n) {
    return this.request(zi(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
Z.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(s, o, a) {
      return this.request(zi(a || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  Fi.prototype[t] = r(), Fi.prototype[t + "Form"] = r(!0);
});
let xG = class uT {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, t(function(s, o, a) {
      n.reason || (n.reason = new Qn(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new uT(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function RG(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function $G(e) {
  return Z.isObject(e) && e.isAxiosError === !0;
}
const Vh = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Vh).forEach(([e, t]) => {
  Vh[t] = e;
});
function fT(e) {
  const t = new Fi(e), r = m1(Fi.prototype.request, t);
  return Z.extend(r, Fi.prototype, t, { allOwnKeys: !0 }), Z.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(i) {
    return fT(zi(e, i));
  }, r;
}
const tt = fT(ec);
tt.Axios = Fi;
tt.CanceledError = Qn;
tt.CancelToken = xG;
tt.isCancel = Y1;
tt.VERSION = Ql;
tt.toFormData = ff;
tt.AxiosError = ae;
tt.Cancel = tt.CanceledError;
tt.all = function(t) {
  return Promise.all(t);
};
tt.spread = RG;
tt.isAxiosError = $G;
tt.mergeConfig = zi;
tt.AxiosHeaders = Lt;
tt.formToJSON = (e) => K1(Z.isHTMLForm(e) ? new FormData(e) : e);
tt.getAdapter = lT.getAdapter;
tt.HttpStatusCode = Vh;
tt.default = tt;
const {
  Axios: Ree,
  AxiosError: $ee,
  CanceledError: Tee,
  isCancel: Oee,
  CancelToken: Pee,
  VERSION: Cee,
  all: Aee,
  Cancel: Iee,
  isAxiosError: Nee,
  spread: kee,
  toFormData: Dee,
  AxiosHeaders: Lee,
  HttpStatusCode: Fee,
  formToJSON: jee,
  getAdapter: Uee,
  mergeConfig: Mee
} = tt;
var dT = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(me, function() {
    var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", o = "second", a = "minute", c = "hour", u = "day", l = "week", f = "month", m = "quarter", p = "year", d = "date", h = "Invalid Date", _ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(x) {
      var A = ["th", "st", "nd", "rd"], P = x % 100;
      return "[" + x + (A[(P - 20) % 10] || A[P] || A[0]) + "]";
    } }, y = function(x, A, P) {
      var D = String(x);
      return !D || D.length >= A ? x : "" + Array(A + 1 - D.length).join(P) + x;
    }, E = { s: y, z: function(x) {
      var A = -x.utcOffset(), P = Math.abs(A), D = Math.floor(P / 60), I = P % 60;
      return (A <= 0 ? "+" : "-") + y(D, 2, "0") + ":" + y(I, 2, "0");
    }, m: function x(A, P) {
      if (A.date() < P.date()) return -x(P, A);
      var D = 12 * (P.year() - A.year()) + (P.month() - A.month()), I = A.clone().add(D, f), L = P - I < 0, j = A.clone().add(D + (L ? -1 : 1), f);
      return +(-(D + (P - I) / (L ? I - j : j - I)) || 0);
    }, a: function(x) {
      return x < 0 ? Math.ceil(x) || 0 : Math.floor(x);
    }, p: function(x) {
      return { M: f, y: p, w: l, d: u, D: d, h: c, m: a, s: o, ms: s, Q: m }[x] || String(x || "").toLowerCase().replace(/s$/, "");
    }, u: function(x) {
      return x === void 0;
    } }, R = "en", w = {};
    w[R] = v;
    var C = "$isDayjsObject", V = function(x) {
      return x instanceof q || !(!x || !x[C]);
    }, b = function x(A, P, D) {
      var I;
      if (!A) return R;
      if (typeof A == "string") {
        var L = A.toLowerCase();
        w[L] && (I = L), P && (w[L] = P, I = L);
        var j = A.split("-");
        if (!I && j.length > 1) return x(j[0]);
      } else {
        var k = A.name;
        w[k] = A, I = k;
      }
      return !D && I && (R = I), I || !D && R;
    }, F = function(x, A) {
      if (V(x)) return x.clone();
      var P = typeof A == "object" ? A : {};
      return P.date = x, P.args = arguments, new q(P);
    }, H = E;
    H.l = b, H.i = V, H.w = function(x, A) {
      return F(x, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
    };
    var q = function() {
      function x(P) {
        this.$L = b(P.locale, null, !0), this.parse(P), this.$x = this.$x || P.x || {}, this[C] = !0;
      }
      var A = x.prototype;
      return A.parse = function(P) {
        this.$d = function(D) {
          var I = D.date, L = D.utc;
          if (I === null) return /* @__PURE__ */ new Date(NaN);
          if (H.u(I)) return /* @__PURE__ */ new Date();
          if (I instanceof Date) return new Date(I);
          if (typeof I == "string" && !/Z$/i.test(I)) {
            var j = I.match(_);
            if (j) {
              var k = j[2] - 1 || 0, U = (j[7] || "0").substring(0, 3);
              return L ? new Date(Date.UTC(j[1], k, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, U)) : new Date(j[1], k, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, U);
            }
          }
          return new Date(I);
        }(P), this.init();
      }, A.init = function() {
        var P = this.$d;
        this.$y = P.getFullYear(), this.$M = P.getMonth(), this.$D = P.getDate(), this.$W = P.getDay(), this.$H = P.getHours(), this.$m = P.getMinutes(), this.$s = P.getSeconds(), this.$ms = P.getMilliseconds();
      }, A.$utils = function() {
        return H;
      }, A.isValid = function() {
        return this.$d.toString() !== h;
      }, A.isSame = function(P, D) {
        var I = F(P);
        return this.startOf(D) <= I && I <= this.endOf(D);
      }, A.isAfter = function(P, D) {
        return F(P) < this.startOf(D);
      }, A.isBefore = function(P, D) {
        return this.endOf(D) < F(P);
      }, A.$g = function(P, D, I) {
        return H.u(P) ? this[D] : this.set(I, P);
      }, A.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, A.valueOf = function() {
        return this.$d.getTime();
      }, A.startOf = function(P, D) {
        var I = this, L = !!H.u(D) || D, j = H.p(P), k = function(W, z) {
          var Q = H.w(I.$u ? Date.UTC(I.$y, z, W) : new Date(I.$y, z, W), I);
          return L ? Q : Q.endOf(u);
        }, U = function(W, z) {
          return H.w(I.toDate()[W].apply(I.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(z)), I);
        }, M = this.$W, T = this.$M, N = this.$D, G = "set" + (this.$u ? "UTC" : "");
        switch (j) {
          case p:
            return L ? k(1, 0) : k(31, 11);
          case f:
            return L ? k(1, T) : k(0, T + 1);
          case l:
            var O = this.$locale().weekStart || 0, S = (M < O ? M + 7 : M) - O;
            return k(L ? N - S : N + (6 - S), T);
          case u:
          case d:
            return U(G + "Hours", 0);
          case c:
            return U(G + "Minutes", 1);
          case a:
            return U(G + "Seconds", 2);
          case o:
            return U(G + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, A.endOf = function(P) {
        return this.startOf(P, !1);
      }, A.$set = function(P, D) {
        var I, L = H.p(P), j = "set" + (this.$u ? "UTC" : ""), k = (I = {}, I[u] = j + "Date", I[d] = j + "Date", I[f] = j + "Month", I[p] = j + "FullYear", I[c] = j + "Hours", I[a] = j + "Minutes", I[o] = j + "Seconds", I[s] = j + "Milliseconds", I)[L], U = L === u ? this.$D + (D - this.$W) : D;
        if (L === f || L === p) {
          var M = this.clone().set(d, 1);
          M.$d[k](U), M.init(), this.$d = M.set(d, Math.min(this.$D, M.daysInMonth())).$d;
        } else k && this.$d[k](U);
        return this.init(), this;
      }, A.set = function(P, D) {
        return this.clone().$set(P, D);
      }, A.get = function(P) {
        return this[H.p(P)]();
      }, A.add = function(P, D) {
        var I, L = this;
        P = Number(P);
        var j = H.p(D), k = function(T) {
          var N = F(L);
          return H.w(N.date(N.date() + Math.round(T * P)), L);
        };
        if (j === f) return this.set(f, this.$M + P);
        if (j === p) return this.set(p, this.$y + P);
        if (j === u) return k(1);
        if (j === l) return k(7);
        var U = (I = {}, I[a] = n, I[c] = i, I[o] = r, I)[j] || 1, M = this.$d.getTime() + P * U;
        return H.w(M, this);
      }, A.subtract = function(P, D) {
        return this.add(-1 * P, D);
      }, A.format = function(P) {
        var D = this, I = this.$locale();
        if (!this.isValid()) return I.invalidDate || h;
        var L = P || "YYYY-MM-DDTHH:mm:ssZ", j = H.z(this), k = this.$H, U = this.$m, M = this.$M, T = I.weekdays, N = I.months, G = I.meridiem, O = function(z, Q, K, X) {
          return z && (z[Q] || z(D, L)) || K[Q].slice(0, X);
        }, S = function(z) {
          return H.s(k % 12 || 12, z, "0");
        }, W = G || function(z, Q, K) {
          var X = z < 12 ? "AM" : "PM";
          return K ? X.toLowerCase() : X;
        };
        return L.replace(g, function(z, Q) {
          return Q || function(K) {
            switch (K) {
              case "YY":
                return String(D.$y).slice(-2);
              case "YYYY":
                return H.s(D.$y, 4, "0");
              case "M":
                return M + 1;
              case "MM":
                return H.s(M + 1, 2, "0");
              case "MMM":
                return O(I.monthsShort, M, N, 3);
              case "MMMM":
                return O(N, M);
              case "D":
                return D.$D;
              case "DD":
                return H.s(D.$D, 2, "0");
              case "d":
                return String(D.$W);
              case "dd":
                return O(I.weekdaysMin, D.$W, T, 2);
              case "ddd":
                return O(I.weekdaysShort, D.$W, T, 3);
              case "dddd":
                return T[D.$W];
              case "H":
                return String(k);
              case "HH":
                return H.s(k, 2, "0");
              case "h":
                return S(1);
              case "hh":
                return S(2);
              case "a":
                return W(k, U, !0);
              case "A":
                return W(k, U, !1);
              case "m":
                return String(U);
              case "mm":
                return H.s(U, 2, "0");
              case "s":
                return String(D.$s);
              case "ss":
                return H.s(D.$s, 2, "0");
              case "SSS":
                return H.s(D.$ms, 3, "0");
              case "Z":
                return j;
            }
            return null;
          }(z) || j.replace(":", "");
        });
      }, A.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, A.diff = function(P, D, I) {
        var L, j = this, k = H.p(D), U = F(P), M = (U.utcOffset() - this.utcOffset()) * n, T = this - U, N = function() {
          return H.m(j, U);
        };
        switch (k) {
          case p:
            L = N() / 12;
            break;
          case f:
            L = N();
            break;
          case m:
            L = N() / 3;
            break;
          case l:
            L = (T - M) / 6048e5;
            break;
          case u:
            L = (T - M) / 864e5;
            break;
          case c:
            L = T / i;
            break;
          case a:
            L = T / n;
            break;
          case o:
            L = T / r;
            break;
          default:
            L = T;
        }
        return I ? L : H.a(L);
      }, A.daysInMonth = function() {
        return this.endOf(f).$D;
      }, A.$locale = function() {
        return w[this.$L];
      }, A.locale = function(P, D) {
        if (!P) return this.$L;
        var I = this.clone(), L = b(P, D, !0);
        return L && (I.$L = L), I;
      }, A.clone = function() {
        return H.w(this.$d, this);
      }, A.toDate = function() {
        return new Date(this.valueOf());
      }, A.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, A.toISOString = function() {
        return this.$d.toISOString();
      }, A.toString = function() {
        return this.$d.toUTCString();
      }, x;
    }(), $ = q.prototype;
    return F.prototype = $, [["$ms", s], ["$s", o], ["$m", a], ["$H", c], ["$W", u], ["$M", f], ["$y", p], ["$D", d]].forEach(function(x) {
      $[x[1]] = function(A) {
        return this.$g(A, x[0], x[1]);
      };
    }), F.extend = function(x, A) {
      return x.$i || (x(A, q, F), x.$i = !0), F;
    }, F.locale = b, F.isDayjs = V, F.unix = function(x) {
      return F(1e3 * x);
    }, F.en = w[R], F.Ls = w, F.p = {}, F;
  });
})(dT);
var TG = dT.exports;
const pT = /* @__PURE__ */ La(TG);
var uo = { exports: {} }, hT = {
  /* The local file header */
  LOCHDR: 30,
  // LOC header size
  LOCSIG: 67324752,
  // "PK\003\004"
  LOCVER: 4,
  // version needed to extract
  LOCFLG: 6,
  // general purpose bit flag
  LOCHOW: 8,
  // compression method
  LOCTIM: 10,
  // modification time (2 bytes time, 2 bytes date)
  LOCCRC: 14,
  // uncompressed file crc-32 value
  LOCSIZ: 18,
  // compressed size
  LOCLEN: 22,
  // uncompressed size
  LOCNAM: 26,
  // filename length
  LOCEXT: 28,
  // extra field length
  /* The Data descriptor */
  EXTSIG: 134695760,
  // "PK\007\008"
  EXTHDR: 16,
  // EXT header size
  EXTCRC: 4,
  // uncompressed file crc-32 value
  EXTSIZ: 8,
  // compressed size
  EXTLEN: 12,
  // uncompressed size
  /* The central directory file header */
  CENHDR: 46,
  // CEN header size
  CENSIG: 33639248,
  // "PK\001\002"
  CENVEM: 4,
  // version made by
  CENVER: 6,
  // version needed to extract
  CENFLG: 8,
  // encrypt, decrypt flags
  CENHOW: 10,
  // compression method
  CENTIM: 12,
  // modification time (2 bytes time, 2 bytes date)
  CENCRC: 16,
  // uncompressed file crc-32 value
  CENSIZ: 20,
  // compressed size
  CENLEN: 24,
  // uncompressed size
  CENNAM: 28,
  // filename length
  CENEXT: 30,
  // extra field length
  CENCOM: 32,
  // file comment length
  CENDSK: 34,
  // volume number start
  CENATT: 36,
  // internal file attributes
  CENATX: 38,
  // external file attributes (host system dependent)
  CENOFF: 42,
  // LOC header offset
  /* The entries in the end of central directory */
  ENDHDR: 22,
  // END header size
  ENDSIG: 101010256,
  // "PK\005\006"
  ENDSUB: 8,
  // number of entries on this disk
  ENDTOT: 10,
  // total number of entries
  ENDSIZ: 12,
  // central directory size in bytes
  ENDOFF: 16,
  // offset of first CEN header
  ENDCOM: 20,
  // zip file comment length
  END64HDR: 20,
  // zip64 END header size
  END64SIG: 117853008,
  // zip64 Locator signature, "PK\006\007"
  END64START: 4,
  // number of the disk with the start of the zip64
  END64OFF: 8,
  // relative offset of the zip64 end of central directory
  END64NUMDISKS: 16,
  // total number of disks
  ZIP64SIG: 101075792,
  // zip64 signature, "PK\006\006"
  ZIP64HDR: 56,
  // zip64 record minimum size
  ZIP64LEAD: 12,
  // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
  ZIP64SIZE: 4,
  // zip64 size of the central directory record
  ZIP64VEM: 12,
  // zip64 version made by
  ZIP64VER: 14,
  // zip64 version needed to extract
  ZIP64DSK: 16,
  // zip64 number of this disk
  ZIP64DSKDIR: 20,
  // number of the disk with the start of the record directory
  ZIP64SUB: 24,
  // number of entries on this disk
  ZIP64TOT: 32,
  // total number of entries
  ZIP64SIZB: 40,
  // zip64 central directory size in bytes
  ZIP64OFF: 48,
  // offset of start of central directory with respect to the starting disk number
  ZIP64EXTRA: 56,
  // extensible data sector
  /* Compression methods */
  STORED: 0,
  // no compression
  SHRUNK: 1,
  // shrunk
  REDUCED1: 2,
  // reduced with compression factor 1
  REDUCED2: 3,
  // reduced with compression factor 2
  REDUCED3: 4,
  // reduced with compression factor 3
  REDUCED4: 5,
  // reduced with compression factor 4
  IMPLODED: 6,
  // imploded
  // 7 reserved for Tokenizing compression algorithm
  DEFLATED: 8,
  // deflated
  ENHANCED_DEFLATED: 9,
  // enhanced deflated
  PKWARE: 10,
  // PKWare DCL imploded
  // 11 reserved by PKWARE
  BZIP2: 12,
  //  compressed using BZIP2
  // 13 reserved by PKWARE
  LZMA: 14,
  // LZMA
  // 15-17 reserved by PKWARE
  IBM_TERSE: 18,
  // compressed using IBM TERSE
  IBM_LZ77: 19,
  // IBM LZ77 z
  AES_ENCRYPT: 99,
  // WinZIP AES encryption method
  /* General purpose bit flag */
  // values can obtained with expression 2**bitnr
  FLG_ENC: 1,
  // Bit 0: encrypted file
  FLG_COMP1: 2,
  // Bit 1, compression option
  FLG_COMP2: 4,
  // Bit 2, compression option
  FLG_DESC: 8,
  // Bit 3, data descriptor
  FLG_ENH: 16,
  // Bit 4, enhanced deflating
  FLG_PATCH: 32,
  // Bit 5, indicates that the file is compressed patched data.
  FLG_STR: 64,
  // Bit 6, strong encryption (patented)
  // Bits 7-10: Currently unused.
  FLG_EFS: 2048,
  // Bit 11: Language encoding flag (EFS)
  // Bit 12: Reserved by PKWARE for enhanced compression.
  // Bit 13: encrypted the Central Directory (patented).
  // Bits 14-15: Reserved by PKWARE.
  FLG_MSK: 4096,
  // mask header values
  /* Load type */
  FILE: 2,
  BUFFER: 1,
  NONE: 0,
  /* 4.5 Extensible data fields */
  EF_ID: 0,
  EF_SIZE: 2,
  /* Header IDs */
  ID_ZIP64: 1,
  ID_AVINFO: 7,
  ID_PFS: 8,
  ID_OS2: 9,
  ID_NTFS: 10,
  ID_OPENVMS: 12,
  ID_UNIX: 13,
  ID_FORK: 14,
  ID_PATCH: 15,
  ID_X509_PKCS7: 20,
  ID_X509_CERTID_F: 21,
  ID_X509_CERTID_C: 22,
  ID_STRONGENC: 23,
  ID_RECORD_MGT: 24,
  ID_X509_PKCS7_RL: 25,
  ID_IBM1: 101,
  ID_IBM2: 102,
  ID_POSZIP: 18064,
  EF_ZIP64_OR_32: 4294967295,
  EF_ZIP64_OR_16: 65535,
  EF_ZIP64_SUNCOMP: 0,
  EF_ZIP64_SCOMP: 8,
  EF_ZIP64_RHO: 16,
  EF_ZIP64_DSN: 24
}, hf = {};
(function(e) {
  const t = {
    /* Header error messages */
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",
    /* Descriptor */
    DESCRIPTOR_NOT_EXIST: "No descriptor present",
    DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
    DESCRIPTOR_FAULTY: "Descriptor data is malformed",
    /* ZipEntry error messages*/
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed {0}",
    FILE_IN_THE_WAY: "There is a file in the way: {0}",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",
    /* Inflater error messages */
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
    /* ADM-ZIP error messages */
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: 'File not found: "{0}"',
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
    INVALID_PASS_PARAM: "Incompatible password parameter",
    WRONG_PASSWORD: "Wrong Password",
    /* ADM-ZIP */
    COMMENT_TOO_LONG: "Comment is too long",
    // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)
    EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
  };
  function r(n) {
    return function(...i) {
      return i.length && (n = n.replace(/\{(\d)\}/g, (s, o) => i[o] || "")), new Error("ADM-ZIP: " + n);
    };
  }
  for (const n of Object.keys(t))
    e[n] = r(t[n]);
})(hf);
const OG = Ue, gt = _e, ZE = hT, PG = hf, CG = typeof process == "object" && process.platform === "win32", QE = (e) => typeof e == "object" && e !== null, mT = new Uint32Array(256).map((e, t) => {
  for (let r = 0; r < 8; r++)
    t & 1 ? t = 3988292384 ^ t >>> 1 : t >>>= 1;
  return t >>> 0;
});
function lt(e) {
  this.sep = gt.sep, this.fs = OG, QE(e) && QE(e.fs) && typeof e.fs.statSync == "function" && (this.fs = e.fs);
}
var AG = lt;
lt.prototype.makeDir = function(e) {
  const t = this;
  function r(n) {
    let i = n.split(t.sep)[0];
    n.split(t.sep).forEach(function(s) {
      if (!(!s || s.substr(-1, 1) === ":")) {
        i += t.sep + s;
        var o;
        try {
          o = t.fs.statSync(i);
        } catch {
          t.fs.mkdirSync(i);
        }
        if (o && o.isFile()) throw PG.FILE_IN_THE_WAY(`"${i}"`);
      }
    });
  }
  r(e);
};
lt.prototype.writeFileTo = function(e, t, r, n) {
  const i = this;
  if (i.fs.existsSync(e)) {
    if (!r) return !1;
    var s = i.fs.statSync(e);
    if (s.isDirectory())
      return !1;
  }
  var o = gt.dirname(e);
  i.fs.existsSync(o) || i.makeDir(o);
  var a;
  try {
    a = i.fs.openSync(e, "w", 438);
  } catch {
    i.fs.chmodSync(e, 438), a = i.fs.openSync(e, "w", 438);
  }
  if (a)
    try {
      i.fs.writeSync(a, t, 0, t.length, 0);
    } finally {
      i.fs.closeSync(a);
    }
  return i.fs.chmodSync(e, n || 438), !0;
};
lt.prototype.writeFileToAsync = function(e, t, r, n, i) {
  typeof n == "function" && (i = n, n = void 0);
  const s = this;
  s.fs.exists(e, function(o) {
    if (o && !r) return i(!1);
    s.fs.stat(e, function(a, c) {
      if (o && c.isDirectory())
        return i(!1);
      var u = gt.dirname(e);
      s.fs.exists(u, function(l) {
        l || s.makeDir(u), s.fs.open(e, "w", 438, function(f, m) {
          f ? s.fs.chmod(e, 438, function() {
            s.fs.open(e, "w", 438, function(p, d) {
              s.fs.write(d, t, 0, t.length, 0, function() {
                s.fs.close(d, function() {
                  s.fs.chmod(e, n || 438, function() {
                    i(!0);
                  });
                });
              });
            });
          }) : m ? s.fs.write(m, t, 0, t.length, 0, function() {
            s.fs.close(m, function() {
              s.fs.chmod(e, n || 438, function() {
                i(!0);
              });
            });
          }) : s.fs.chmod(e, n || 438, function() {
            i(!0);
          });
        });
      });
    });
  });
};
lt.prototype.findFiles = function(e) {
  const t = this;
  function r(n, i, s) {
    let o = [];
    return t.fs.readdirSync(n).forEach(function(a) {
      const c = gt.join(n, a), u = t.fs.statSync(c);
      o.push(gt.normalize(c) + (u.isDirectory() ? t.sep : "")), u.isDirectory() && s && (o = o.concat(r(c, i, s)));
    }), o;
  }
  return r(e, void 0, !0);
};
lt.prototype.findFilesAsync = function(e, t) {
  const r = this;
  let n = [];
  r.fs.readdir(e, function(i, s) {
    if (i) return t(i);
    let o = s.length;
    if (!o) return t(null, n);
    s.forEach(function(a) {
      a = gt.join(e, a), r.fs.stat(a, function(c, u) {
        if (c) return t(c);
        u && (n.push(gt.normalize(a) + (u.isDirectory() ? r.sep : "")), u.isDirectory() ? r.findFilesAsync(a, function(l, f) {
          if (l) return t(l);
          n = n.concat(f), --o || t(null, n);
        }) : --o || t(null, n));
      });
    });
  });
};
lt.prototype.getAttributes = function() {
};
lt.prototype.setAttributes = function() {
};
lt.crc32update = function(e, t) {
  return mT[(e ^ t) & 255] ^ e >>> 8;
};
lt.crc32 = function(e) {
  typeof e == "string" && (e = Buffer.from(e, "utf8"));
  let t = e.length, r = -1;
  for (let n = 0; n < t; ) r = lt.crc32update(r, e[n++]);
  return ~r >>> 0;
};
lt.methodToString = function(e) {
  switch (e) {
    case ZE.STORED:
      return "STORED (" + e + ")";
    case ZE.DEFLATED:
      return "DEFLATED (" + e + ")";
    default:
      return "UNSUPPORTED (" + e + ")";
  }
};
lt.canonical = function(e) {
  if (!e) return "";
  const t = gt.posix.normalize("/" + e.split("\\").join("/"));
  return gt.join(".", t);
};
lt.zipnamefix = function(e) {
  if (!e) return "";
  const t = gt.posix.normalize("/" + e.split("\\").join("/"));
  return gt.posix.join(".", t);
};
lt.findLast = function(e, t) {
  if (!Array.isArray(e)) throw new TypeError("arr is not array");
  const r = e.length >>> 0;
  for (let n = r - 1; n >= 0; n--)
    if (t(e[n], n, e))
      return e[n];
};
lt.sanitize = function(e, t) {
  e = gt.resolve(gt.normalize(e));
  for (var r = t.split("/"), n = 0, i = r.length; n < i; n++) {
    var s = gt.normalize(gt.join(e, r.slice(n, i).join(gt.sep)));
    if (s.indexOf(e) === 0)
      return s;
  }
  return gt.normalize(gt.join(e, gt.basename(t)));
};
lt.toBuffer = function(t, r) {
  return Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? Buffer.from(t) : typeof t == "string" ? r(t) : Buffer.alloc(0);
};
lt.readBigUInt64LE = function(e, t) {
  var r = Buffer.from(e.slice(t, t + 8));
  return r.swap64(), parseInt(`0x${r.toString("hex")}`);
};
lt.fromDOS2Date = function(e) {
  return new Date((e >> 25 & 127) + 1980, Math.max((e >> 21 & 15) - 1, 0), Math.max(e >> 16 & 31, 1), e >> 11 & 31, e >> 5 & 63, (e & 31) << 1);
};
lt.fromDate2DOS = function(e) {
  let t = 0, r = 0;
  return e.getFullYear() > 1979 && (t = (e.getFullYear() - 1980 & 127) << 9 | e.getMonth() + 1 << 5 | e.getDate(), r = e.getHours() << 11 | e.getMinutes() << 5 | e.getSeconds() >> 1), t << 16 | r;
};
lt.isWin = CG;
lt.crcTable = mT;
const IG = _e;
var NG = function(e, { fs: t }) {
  var r = e || "", n = s(), i = null;
  function s() {
    return {
      directory: !1,
      readonly: !1,
      hidden: !1,
      executable: !1,
      mtime: 0,
      atime: 0
    };
  }
  return r && t.existsSync(r) ? (i = t.statSync(r), n.directory = i.isDirectory(), n.mtime = i.mtime, n.atime = i.atime, n.executable = (73 & i.mode) !== 0, n.readonly = (128 & i.mode) === 0, n.hidden = IG.basename(r)[0] === ".") : console.warn("Invalid path: " + r), {
    get directory() {
      return n.directory;
    },
    get readOnly() {
      return n.readonly;
    },
    get hidden() {
      return n.hidden;
    },
    get mtime() {
      return n.mtime;
    },
    get atime() {
      return n.atime;
    },
    get executable() {
      return n.executable;
    },
    decodeAttributes: function() {
    },
    encodeAttributes: function() {
    },
    toJSON: function() {
      return {
        path: r,
        isDirectory: n.directory,
        isReadOnly: n.readonly,
        isHidden: n.hidden,
        isExecutable: n.executable,
        mTime: n.mtime,
        aTime: n.atime
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
}, kG = {
  efs: !0,
  encode: (e) => Buffer.from(e, "utf8"),
  decode: (e) => e.toString("utf8")
};
uo.exports = AG;
uo.exports.Constants = hT;
uo.exports.Errors = hf;
uo.exports.FileAttr = NG;
uo.exports.decoder = kG;
var nc = uo.exports, mf = {}, Un = nc, oe = Un.Constants, DG = function() {
  var e = 20, t = 10, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, c = 0, u = 0, l = 0, f = 0, m = 0, p = 0, d = 0;
  e |= Un.isWin ? 2560 : 768, r |= oe.FLG_EFS;
  const h = {
    extraLen: 0
  }, _ = (v) => Math.max(0, v) >>> 0, g = (v) => Math.max(0, v) & 255;
  return i = Un.fromDate2DOS(/* @__PURE__ */ new Date()), {
    get made() {
      return e;
    },
    set made(v) {
      e = v;
    },
    get version() {
      return t;
    },
    set version(v) {
      t = v;
    },
    get flags() {
      return r;
    },
    set flags(v) {
      r = v;
    },
    get flags_efs() {
      return (r & oe.FLG_EFS) > 0;
    },
    set flags_efs(v) {
      v ? r |= oe.FLG_EFS : r &= ~oe.FLG_EFS;
    },
    get flags_desc() {
      return (r & oe.FLG_DESC) > 0;
    },
    set flags_desc(v) {
      v ? r |= oe.FLG_DESC : r &= ~oe.FLG_DESC;
    },
    get method() {
      return n;
    },
    set method(v) {
      switch (v) {
        case oe.STORED:
          this.version = 10;
        case oe.DEFLATED:
        default:
          this.version = 20;
      }
      n = v;
    },
    get time() {
      return Un.fromDOS2Date(this.timeval);
    },
    set time(v) {
      this.timeval = Un.fromDate2DOS(v);
    },
    get timeval() {
      return i;
    },
    set timeval(v) {
      i = _(v);
    },
    get timeHighByte() {
      return g(i >>> 8);
    },
    get crc() {
      return s;
    },
    set crc(v) {
      s = _(v);
    },
    get compressedSize() {
      return o;
    },
    set compressedSize(v) {
      o = _(v);
    },
    get size() {
      return a;
    },
    set size(v) {
      a = _(v);
    },
    get fileNameLength() {
      return c;
    },
    set fileNameLength(v) {
      c = v;
    },
    get extraLength() {
      return u;
    },
    set extraLength(v) {
      u = v;
    },
    get extraLocalLength() {
      return h.extraLen;
    },
    set extraLocalLength(v) {
      h.extraLen = v;
    },
    get commentLength() {
      return l;
    },
    set commentLength(v) {
      l = v;
    },
    get diskNumStart() {
      return f;
    },
    set diskNumStart(v) {
      f = _(v);
    },
    get inAttr() {
      return m;
    },
    set inAttr(v) {
      m = _(v);
    },
    get attr() {
      return p;
    },
    set attr(v) {
      p = _(v);
    },
    // get Unix file permissions
    get fileAttr() {
      return (p || 0) >> 16 & 4095;
    },
    get offset() {
      return d;
    },
    set offset(v) {
      d = _(v);
    },
    get encrypted() {
      return (r & oe.FLG_ENC) === oe.FLG_ENC;
    },
    get centralHeaderSize() {
      return oe.CENHDR + c + u + l;
    },
    get realDataOffset() {
      return d + oe.LOCHDR + h.fnameLen + h.extraLen;
    },
    get localHeader() {
      return h;
    },
    loadLocalHeaderFromBinary: function(v) {
      var y = v.slice(d, d + oe.LOCHDR);
      if (y.readUInt32LE(0) !== oe.LOCSIG)
        throw Un.Errors.INVALID_LOC();
      h.version = y.readUInt16LE(oe.LOCVER), h.flags = y.readUInt16LE(oe.LOCFLG), h.method = y.readUInt16LE(oe.LOCHOW), h.time = y.readUInt32LE(oe.LOCTIM), h.crc = y.readUInt32LE(oe.LOCCRC), h.compressedSize = y.readUInt32LE(oe.LOCSIZ), h.size = y.readUInt32LE(oe.LOCLEN), h.fnameLen = y.readUInt16LE(oe.LOCNAM), h.extraLen = y.readUInt16LE(oe.LOCEXT);
      const E = d + oe.LOCHDR + h.fnameLen, R = E + h.extraLen;
      return v.slice(E, R);
    },
    loadFromBinary: function(v) {
      if (v.length !== oe.CENHDR || v.readUInt32LE(0) !== oe.CENSIG)
        throw Un.Errors.INVALID_CEN();
      e = v.readUInt16LE(oe.CENVEM), t = v.readUInt16LE(oe.CENVER), r = v.readUInt16LE(oe.CENFLG), n = v.readUInt16LE(oe.CENHOW), i = v.readUInt32LE(oe.CENTIM), s = v.readUInt32LE(oe.CENCRC), o = v.readUInt32LE(oe.CENSIZ), a = v.readUInt32LE(oe.CENLEN), c = v.readUInt16LE(oe.CENNAM), u = v.readUInt16LE(oe.CENEXT), l = v.readUInt16LE(oe.CENCOM), f = v.readUInt16LE(oe.CENDSK), m = v.readUInt16LE(oe.CENATT), p = v.readUInt32LE(oe.CENATX), d = v.readUInt32LE(oe.CENOFF);
    },
    localHeaderToBinary: function() {
      var v = Buffer.alloc(oe.LOCHDR);
      return v.writeUInt32LE(oe.LOCSIG, 0), v.writeUInt16LE(t, oe.LOCVER), v.writeUInt16LE(r, oe.LOCFLG), v.writeUInt16LE(n, oe.LOCHOW), v.writeUInt32LE(i, oe.LOCTIM), v.writeUInt32LE(s, oe.LOCCRC), v.writeUInt32LE(o, oe.LOCSIZ), v.writeUInt32LE(a, oe.LOCLEN), v.writeUInt16LE(c, oe.LOCNAM), v.writeUInt16LE(h.extraLen, oe.LOCEXT), v;
    },
    centralHeaderToBinary: function() {
      var v = Buffer.alloc(oe.CENHDR + c + u + l);
      return v.writeUInt32LE(oe.CENSIG, 0), v.writeUInt16LE(e, oe.CENVEM), v.writeUInt16LE(t, oe.CENVER), v.writeUInt16LE(r, oe.CENFLG), v.writeUInt16LE(n, oe.CENHOW), v.writeUInt32LE(i, oe.CENTIM), v.writeUInt32LE(s, oe.CENCRC), v.writeUInt32LE(o, oe.CENSIZ), v.writeUInt32LE(a, oe.CENLEN), v.writeUInt16LE(c, oe.CENNAM), v.writeUInt16LE(u, oe.CENEXT), v.writeUInt16LE(l, oe.CENCOM), v.writeUInt16LE(f, oe.CENDSK), v.writeUInt16LE(m, oe.CENATT), v.writeUInt32LE(p, oe.CENATX), v.writeUInt32LE(d, oe.CENOFF), v;
    },
    toJSON: function() {
      const v = function(y) {
        return y + " bytes";
      };
      return {
        made: e,
        version: t,
        flags: r,
        method: Un.methodToString(n),
        time: this.time,
        crc: "0x" + s.toString(16).toUpperCase(),
        compressedSize: v(o),
        size: v(a),
        fileNameLength: v(c),
        extraLength: v(u),
        commentLength: v(l),
        diskNumStart: f,
        inAttr: m,
        attr: p,
        offset: d,
        centralHeaderSize: v(oe.CENHDR + c + u + l)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
}, Es = nc, Ze = Es.Constants, LG = function() {
  var e = 0, t = 0, r = 0, n = 0, i = 0;
  return {
    get diskEntries() {
      return e;
    },
    set diskEntries(s) {
      e = t = s;
    },
    get totalEntries() {
      return t;
    },
    set totalEntries(s) {
      t = e = s;
    },
    get size() {
      return r;
    },
    set size(s) {
      r = s;
    },
    get offset() {
      return n;
    },
    set offset(s) {
      n = s;
    },
    get commentLength() {
      return i;
    },
    set commentLength(s) {
      i = s;
    },
    get mainHeaderSize() {
      return Ze.ENDHDR + i;
    },
    loadFromBinary: function(s) {
      if ((s.length !== Ze.ENDHDR || s.readUInt32LE(0) !== Ze.ENDSIG) && (s.length < Ze.ZIP64HDR || s.readUInt32LE(0) !== Ze.ZIP64SIG))
        throw Es.Errors.INVALID_END();
      s.readUInt32LE(0) === Ze.ENDSIG ? (e = s.readUInt16LE(Ze.ENDSUB), t = s.readUInt16LE(Ze.ENDTOT), r = s.readUInt32LE(Ze.ENDSIZ), n = s.readUInt32LE(Ze.ENDOFF), i = s.readUInt16LE(Ze.ENDCOM)) : (e = Es.readBigUInt64LE(s, Ze.ZIP64SUB), t = Es.readBigUInt64LE(s, Ze.ZIP64TOT), r = Es.readBigUInt64LE(s, Ze.ZIP64SIZE), n = Es.readBigUInt64LE(s, Ze.ZIP64OFF), i = 0);
    },
    toBinary: function() {
      var s = Buffer.alloc(Ze.ENDHDR + i);
      return s.writeUInt32LE(Ze.ENDSIG, 0), s.writeUInt32LE(0, 4), s.writeUInt16LE(e, Ze.ENDSUB), s.writeUInt16LE(t, Ze.ENDTOT), s.writeUInt32LE(r, Ze.ENDSIZ), s.writeUInt32LE(n, Ze.ENDOFF), s.writeUInt16LE(i, Ze.ENDCOM), s.fill(" ", Ze.ENDHDR), s;
    },
    toJSON: function() {
      const s = function(o, a) {
        let c = o.toString(16).toUpperCase();
        for (; c.length < a; ) c = "0" + c;
        return "0x" + c;
      };
      return {
        diskEntries: e,
        totalEntries: t,
        size: r + " bytes",
        offset: s(n, 4),
        commentLength: i
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
mf.EntryHeader = DG;
mf.MainHeader = LG;
var gf = {}, FG = function(e) {
  var t = Pr, r = { chunkSize: (parseInt(e.length / 1024) + 1) * 1024 };
  return {
    deflate: function() {
      return t.deflateRawSync(e, r);
    },
    deflateAsync: function(n) {
      var i = t.createDeflateRaw(r), s = [], o = 0;
      i.on("data", function(a) {
        s.push(a), o += a.length;
      }), i.on("end", function() {
        var a = Buffer.alloc(o), c = 0;
        a.fill(0);
        for (var u = 0; u < s.length; u++) {
          var l = s[u];
          l.copy(a, c), c += l.length;
        }
        n && n(a);
      }), i.end(e);
    }
  };
};
const jG = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
var UG = function(e, t) {
  var r = Pr;
  const n = jG >= 15 && t > 0 ? { maxOutputLength: t } : {};
  return {
    inflate: function() {
      return r.inflateRawSync(e, n);
    },
    inflateAsync: function(i) {
      var s = r.createInflateRaw(n), o = [], a = 0;
      s.on("data", function(c) {
        o.push(c), a += c.length;
      }), s.on("end", function() {
        var c = Buffer.alloc(a), u = 0;
        c.fill(0);
        for (var l = 0; l < o.length; l++) {
          var f = o[l];
          f.copy(c, u), u += f.length;
        }
        i && i(c);
      }), s.end(e);
    }
  };
};
const { randomFillSync: ew } = Ki, MG = hf, HG = new Uint32Array(256).map((e, t) => {
  for (let r = 0; r < 8; r++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t >>>= 1;
  return t >>> 0;
}), gT = (e, t) => Math.imul(e, t) >>> 0, tw = (e, t) => HG[(e ^ t) & 255] ^ e >>> 8, ma = () => typeof ew == "function" ? ew(Buffer.alloc(12)) : ma.node();
ma.node = () => {
  const e = Buffer.alloc(12), t = e.length;
  for (let r = 0; r < t; r++) e[r] = Math.random() * 256 & 255;
  return e;
};
const Pl = {
  genSalt: ma
};
function yf(e) {
  const t = Buffer.isBuffer(e) ? e : Buffer.from(e);
  this.keys = new Uint32Array([305419896, 591751049, 878082192]);
  for (let r = 0; r < t.length; r++)
    this.updateKeys(t[r]);
}
yf.prototype.updateKeys = function(e) {
  const t = this.keys;
  return t[0] = tw(t[0], e), t[1] += t[0] & 255, t[1] = gT(t[1], 134775813) + 1, t[2] = tw(t[2], t[1] >>> 24), e;
};
yf.prototype.next = function() {
  const e = (this.keys[2] | 2) >>> 0;
  return gT(e, e ^ 1) >> 8 & 255;
};
function qG(e) {
  const t = new yf(e);
  return function(r) {
    const n = Buffer.alloc(r.length);
    let i = 0;
    for (let s of r)
      n[i++] = t.updateKeys(s ^ t.next());
    return n;
  };
}
function BG(e) {
  const t = new yf(e);
  return function(r, n, i = 0) {
    n || (n = Buffer.alloc(r.length));
    for (let s of r) {
      const o = t.next();
      n[i++] = s ^ o, t.updateKeys(s);
    }
    return n;
  };
}
function zG(e, t, r) {
  if (!e || !Buffer.isBuffer(e) || e.length < 12)
    return Buffer.alloc(0);
  const n = qG(r), i = n(e.slice(0, 12)), s = (t.flags & 8) === 8 ? t.timeHighByte : t.crc >>> 24;
  if (i[11] !== s)
    throw MG.WRONG_PASSWORD();
  return n(e.slice(12));
}
function VG(e) {
  Buffer.isBuffer(e) && e.length >= 12 ? Pl.genSalt = function() {
    return e.slice(0, 12);
  } : e === "node" ? Pl.genSalt = ma.node : Pl.genSalt = ma;
}
function GG(e, t, r, n = !1) {
  e == null && (e = Buffer.alloc(0)), Buffer.isBuffer(e) || (e = Buffer.from(e.toString()));
  const i = BG(r), s = Pl.genSalt();
  s[11] = t.crc >>> 24 & 255, n && (s[10] = t.crc >>> 16 & 255);
  const o = Buffer.alloc(e.length + 12);
  return i(s, o), i(e, o, 12);
}
var WG = { decrypt: zG, encrypt: GG, _salter: VG };
gf.Deflater = FG;
gf.Inflater = UG;
gf.ZipCrypto = WG;
var Fe = nc, KG = mf, nt = Fe.Constants, jp = gf, yT = function(e, t) {
  var r = new KG.EntryHeader(), n = Buffer.alloc(0), i = Buffer.alloc(0), s = !1, o = null, a = Buffer.alloc(0), c = Buffer.alloc(0), u = !0;
  const l = e, f = typeof l.decoder == "object" ? l.decoder : Fe.decoder;
  u = f.hasOwnProperty("efs") ? f.efs : !1;
  function m() {
    return !t || !(t instanceof Uint8Array) ? Buffer.alloc(0) : (c = r.loadLocalHeaderFromBinary(t), t.slice(r.realDataOffset, r.realDataOffset + r.compressedSize));
  }
  function p(y) {
    if (r.flags_desc) {
      const E = {}, R = r.realDataOffset + r.compressedSize;
      if (t.readUInt32LE(R) == nt.LOCSIG || t.readUInt32LE(R) == nt.CENSIG)
        throw Fe.Errors.DESCRIPTOR_NOT_EXIST();
      if (t.readUInt32LE(R) == nt.EXTSIG)
        E.crc = t.readUInt32LE(R + nt.EXTCRC), E.compressedSize = t.readUInt32LE(R + nt.EXTSIZ), E.size = t.readUInt32LE(R + nt.EXTLEN);
      else if (t.readUInt16LE(R + 12) === 19280)
        E.crc = t.readUInt32LE(R + nt.EXTCRC - 4), E.compressedSize = t.readUInt32LE(R + nt.EXTSIZ - 4), E.size = t.readUInt32LE(R + nt.EXTLEN - 4);
      else
        throw Fe.Errors.DESCRIPTOR_UNKNOWN();
      if (E.compressedSize !== r.compressedSize || E.size !== r.size || E.crc !== r.crc)
        throw Fe.Errors.DESCRIPTOR_FAULTY();
      if (Fe.crc32(y) !== E.crc)
        return !1;
    } else if (Fe.crc32(y) !== r.localHeader.crc)
      return !1;
    return !0;
  }
  function d(y, E, R) {
    if (typeof E > "u" && typeof y == "string" && (R = y, y = void 0), s)
      return y && E && E(Buffer.alloc(0), Fe.Errors.DIRECTORY_CONTENT_ERROR()), Buffer.alloc(0);
    var w = m();
    if (w.length === 0)
      return y && E && E(w), w;
    if (r.encrypted) {
      if (typeof R != "string" && !Buffer.isBuffer(R))
        throw Fe.Errors.INVALID_PASS_PARAM();
      w = jp.ZipCrypto.decrypt(w, r, R);
    }
    var C = Buffer.alloc(r.size);
    switch (r.method) {
      case Fe.Constants.STORED:
        if (w.copy(C), p(C))
          return y && E && E(C), C;
        throw y && E && E(C, Fe.Errors.BAD_CRC()), Fe.Errors.BAD_CRC();
      case Fe.Constants.DEFLATED:
        var V = new jp.Inflater(w, r.size);
        if (y)
          V.inflateAsync(function(b) {
            b.copy(b, 0), E && (p(b) ? E(b) : E(b, Fe.Errors.BAD_CRC()));
          });
        else {
          if (V.inflate(C).copy(C, 0), !p(C))
            throw Fe.Errors.BAD_CRC(`"${f.decode(n)}"`);
          return C;
        }
        break;
      default:
        throw y && E && E(Buffer.alloc(0), Fe.Errors.UNKNOWN_METHOD()), Fe.Errors.UNKNOWN_METHOD();
    }
  }
  function h(y, E) {
    if ((!o || !o.length) && Buffer.isBuffer(t))
      return y && E && E(m()), m();
    if (o.length && !s) {
      var R;
      switch (r.method) {
        case Fe.Constants.STORED:
          return r.compressedSize = r.size, R = Buffer.alloc(o.length), o.copy(R), y && E && E(R), R;
        default:
        case Fe.Constants.DEFLATED:
          var w = new jp.Deflater(o);
          if (y)
            w.deflateAsync(function(V) {
              R = Buffer.alloc(V.length), r.compressedSize = V.length, V.copy(R), E && E(R);
            });
          else {
            var C = w.deflate();
            return r.compressedSize = C.length, C;
          }
          w = null;
          break;
      }
    } else if (y && E)
      E(Buffer.alloc(0));
    else
      return Buffer.alloc(0);
  }
  function _(y, E) {
    return (y.readUInt32LE(E + 4) << 4) + y.readUInt32LE(E);
  }
  function g(y) {
    try {
      for (var E = 0, R, w, C; E + 4 < y.length; )
        R = y.readUInt16LE(E), E += 2, w = y.readUInt16LE(E), E += 2, C = y.slice(E, E + w), E += w, nt.ID_ZIP64 === R && v(C);
    } catch {
      throw Fe.Errors.EXTRA_FIELD_PARSE_ERROR();
    }
  }
  function v(y) {
    var E, R, w, C;
    y.length >= nt.EF_ZIP64_SCOMP && (E = _(y, nt.EF_ZIP64_SUNCOMP), r.size === nt.EF_ZIP64_OR_32 && (r.size = E)), y.length >= nt.EF_ZIP64_RHO && (R = _(y, nt.EF_ZIP64_SCOMP), r.compressedSize === nt.EF_ZIP64_OR_32 && (r.compressedSize = R)), y.length >= nt.EF_ZIP64_DSN && (w = _(y, nt.EF_ZIP64_RHO), r.offset === nt.EF_ZIP64_OR_32 && (r.offset = w)), y.length >= nt.EF_ZIP64_DSN + 4 && (C = y.readUInt32LE(nt.EF_ZIP64_DSN), r.diskNumStart === nt.EF_ZIP64_OR_16 && (r.diskNumStart = C));
  }
  return {
    get entryName() {
      return f.decode(n);
    },
    get rawEntryName() {
      return n;
    },
    set entryName(y) {
      n = Fe.toBuffer(y, f.encode);
      var E = n[n.length - 1];
      s = E === 47 || E === 92, r.fileNameLength = n.length;
    },
    get efs() {
      return typeof u == "function" ? u(this.entryName) : u;
    },
    get extra() {
      return a;
    },
    set extra(y) {
      a = y, r.extraLength = y.length, g(y);
    },
    get comment() {
      return f.decode(i);
    },
    set comment(y) {
      if (i = Fe.toBuffer(y, f.encode), r.commentLength = i.length, i.length > 65535) throw Fe.Errors.COMMENT_TOO_LONG();
    },
    get name() {
      var y = f.decode(n);
      return s ? y.substr(y.length - 1).split("/").pop() : y.split("/").pop();
    },
    get isDirectory() {
      return s;
    },
    getCompressedData: function() {
      return h(!1, null);
    },
    getCompressedDataAsync: function(y) {
      h(!0, y);
    },
    setData: function(y) {
      o = Fe.toBuffer(y, Fe.decoder.encode), !s && o.length ? (r.size = o.length, r.method = Fe.Constants.DEFLATED, r.crc = Fe.crc32(y), r.changed = !0) : r.method = Fe.Constants.STORED;
    },
    getData: function(y) {
      return r.changed ? o : d(!1, null, y);
    },
    getDataAsync: function(y, E) {
      r.changed ? y(o) : d(!0, y, E);
    },
    set attr(y) {
      r.attr = y;
    },
    get attr() {
      return r.attr;
    },
    set header(y) {
      r.loadFromBinary(y);
    },
    get header() {
      return r;
    },
    packCentralHeader: function() {
      r.flags_efs = this.efs, r.extraLength = a.length;
      var y = r.centralHeaderToBinary(), E = Fe.Constants.CENHDR;
      return n.copy(y, E), E += n.length, a.copy(y, E), E += r.extraLength, i.copy(y, E), y;
    },
    packLocalHeader: function() {
      let y = 0;
      r.flags_efs = this.efs, r.extraLocalLength = c.length;
      const E = r.localHeaderToBinary(), R = Buffer.alloc(E.length + n.length + r.extraLocalLength);
      return E.copy(R, y), y += E.length, n.copy(R, y), y += n.length, c.copy(R, y), y += c.length, R;
    },
    toJSON: function() {
      const y = function(E) {
        return "<" + (E && E.length + " bytes buffer" || "null") + ">";
      };
      return {
        entryName: this.entryName,
        name: this.name,
        comment: this.comment,
        isDirectory: this.isDirectory,
        header: r.toJSON(),
        compressedData: y(t),
        data: y(o)
      };
    },
    toString: function() {
      return JSON.stringify(this.toJSON(), null, "	");
    }
  };
};
const rw = yT, YG = mf, Ot = nc;
var JG = function(e, t) {
  var r = [], n = {}, i = Buffer.alloc(0), s = new YG.MainHeader(), o = !1;
  const a = /* @__PURE__ */ new Set(), c = t, { noSort: u, decoder: l } = c;
  e ? p(c.readEntries) : o = !0;
  function f() {
    const h = /* @__PURE__ */ new Set();
    for (const _ of Object.keys(n)) {
      const g = _.split("/");
      if (g.pop(), !!g.length)
        for (let v = 0; v < g.length; v++) {
          const y = g.slice(0, v + 1).join("/") + "/";
          h.add(y);
        }
    }
    for (const _ of h)
      if (!(_ in n)) {
        const g = new rw(c);
        g.entryName = _, g.attr = 16, g.temporary = !0, r.push(g), n[g.entryName] = g, a.add(g);
      }
  }
  function m() {
    if (o = !0, n = {}, s.diskEntries > (e.length - s.offset) / Ot.Constants.CENHDR)
      throw Ot.Errors.DISK_ENTRY_TOO_LARGE();
    r = new Array(s.diskEntries);
    for (var h = s.offset, _ = 0; _ < r.length; _++) {
      var g = h, v = new rw(c, e);
      v.header = e.slice(g, g += Ot.Constants.CENHDR), v.entryName = e.slice(g, g += v.header.fileNameLength), v.header.extraLength && (v.extra = e.slice(g, g += v.header.extraLength)), v.header.commentLength && (v.comment = e.slice(g, g + v.header.commentLength)), h += v.header.centralHeaderSize, r[_] = v, n[v.entryName] = v;
    }
    a.clear(), f();
  }
  function p(h) {
    var _ = e.length - Ot.Constants.ENDHDR, g = Math.max(0, _ - 65535), v = g, y = e.length, E = -1, R = 0;
    for ((typeof c.trailingSpace == "boolean" ? c.trailingSpace : !1) && (g = 0), _; _ >= v; _--)
      if (e[_] === 80) {
        if (e.readUInt32LE(_) === Ot.Constants.ENDSIG) {
          E = _, R = _, y = _ + Ot.Constants.ENDHDR, v = _ - Ot.Constants.END64HDR;
          continue;
        }
        if (e.readUInt32LE(_) === Ot.Constants.END64SIG) {
          v = g;
          continue;
        }
        if (e.readUInt32LE(_) === Ot.Constants.ZIP64SIG) {
          E = _, y = _ + Ot.readBigUInt64LE(e, _ + Ot.Constants.ZIP64SIZE) + Ot.Constants.ZIP64LEAD;
          break;
        }
      }
    if (E == -1) throw Ot.Errors.INVALID_FORMAT();
    s.loadFromBinary(e.slice(E, y)), s.commentLength && (i = e.slice(R + Ot.Constants.ENDHDR)), h && m();
  }
  function d() {
    r.length > 1 && !u && r.sort((h, _) => h.entryName.toLowerCase().localeCompare(_.entryName.toLowerCase()));
  }
  return {
    /**
     * Returns an array of ZipEntry objects existent in the current opened archive
     * @return Array
     */
    get entries() {
      return o || m(), r.filter((h) => !a.has(h));
    },
    /**
     * Archive comment
     * @return {String}
     */
    get comment() {
      return l.decode(i);
    },
    set comment(h) {
      i = Ot.toBuffer(h, l.encode), s.commentLength = i.length;
    },
    getEntryCount: function() {
      return o ? r.length : s.diskEntries;
    },
    forEach: function(h) {
      this.entries.forEach(h);
    },
    /**
     * Returns a reference to the entry with the given name or null if entry is inexistent
     *
     * @param entryName
     * @return ZipEntry
     */
    getEntry: function(h) {
      return o || m(), n[h] || null;
    },
    /**
     * Adds the given entry to the entry list
     *
     * @param entry
     */
    setEntry: function(h) {
      o || m(), r.push(h), n[h.entryName] = h, s.totalEntries = r.length;
    },
    /**
     * Removes the file with the given name from the entry list.
     *
     * If the entry is a directory, then all nested files and directories will be removed
     * @param entryName
     * @returns {void}
     */
    deleteFile: function(h, _ = !0) {
      o || m();
      const g = n[h];
      this.getEntryChildren(g, _).map((y) => y.entryName).forEach(this.deleteEntry);
    },
    /**
     * Removes the entry with the given name from the entry list.
     *
     * @param {string} entryName
     * @returns {void}
     */
    deleteEntry: function(h) {
      o || m();
      const _ = n[h], g = r.indexOf(_);
      g >= 0 && (r.splice(g, 1), delete n[h], s.totalEntries = r.length);
    },
    /**
     *  Iterates and returns all nested files and directories of the given entry
     *
     * @param entry
     * @return Array
     */
    getEntryChildren: function(h, _ = !0) {
      if (o || m(), typeof h == "object")
        if (h.isDirectory && _) {
          const g = [], v = h.entryName;
          for (const y of r)
            y.entryName.startsWith(v) && g.push(y);
          return g;
        } else
          return [h];
      return [];
    },
    /**
     *  How many child elements entry has
     *
     * @param {ZipEntry} entry
     * @return {integer}
     */
    getChildCount: function(h) {
      if (h && h.isDirectory) {
        const _ = this.getEntryChildren(h);
        return _.includes(h) ? _.length - 1 : _.length;
      }
      return 0;
    },
    /**
     * Returns the zip file
     *
     * @return Buffer
     */
    compressToBuffer: function() {
      o || m(), d();
      const h = [], _ = [];
      let g = 0, v = 0;
      s.size = 0, s.offset = 0;
      let y = 0;
      for (const w of this.entries) {
        const C = w.getCompressedData();
        w.header.offset = v;
        const V = w.packLocalHeader(), b = V.length + C.length;
        v += b, h.push(V), h.push(C);
        const F = w.packCentralHeader();
        _.push(F), s.size += F.length, g += b + F.length, y++;
      }
      g += s.mainHeaderSize, s.offset = v, s.totalEntries = y, v = 0;
      const E = Buffer.alloc(g);
      for (const w of h)
        w.copy(E, v), v += w.length;
      for (const w of _)
        w.copy(E, v), v += w.length;
      const R = s.toBinary();
      return i && i.copy(R, Ot.Constants.ENDHDR), R.copy(E, v), e = E, o = !1, E;
    },
    toAsyncBuffer: function(h, _, g, v) {
      try {
        o || m(), d();
        const y = [], E = [];
        let R = 0, w = 0, C = 0;
        s.size = 0, s.offset = 0;
        const V = function(b) {
          if (b.length > 0) {
            const F = b.shift(), H = F.entryName + F.extra.toString();
            g && g(H), F.getCompressedDataAsync(function(q) {
              v && v(H), F.header.offset = w;
              const $ = F.packLocalHeader(), x = $.length + q.length;
              w += x, y.push($), y.push(q);
              const A = F.packCentralHeader();
              E.push(A), s.size += A.length, R += x + A.length, C++, V(b);
            });
          } else {
            R += s.mainHeaderSize, s.offset = w, s.totalEntries = C, w = 0;
            const F = Buffer.alloc(R);
            y.forEach(function(q) {
              q.copy(F, w), w += q.length;
            }), E.forEach(function(q) {
              q.copy(F, w), w += q.length;
            });
            const H = s.toBinary();
            i && i.copy(H, Ot.Constants.ENDHDR), H.copy(F, w), e = F, o = !1, h(F);
          }
        };
        V(Array.from(this.entries));
      } catch (y) {
        _(y);
      }
    }
  };
};
const Qe = nc, it = _e, XG = yT, ZG = JG, _i = (...e) => Qe.findLast(e, (t) => typeof t == "boolean"), nw = (...e) => Qe.findLast(e, (t) => typeof t == "string"), QG = (...e) => Qe.findLast(e, (t) => typeof t == "function"), eW = {
  // option "noSort" : if true it disables files sorting
  noSort: !1,
  // read entries during load (initial loading may be slower)
  readEntries: !1,
  // default method is none
  method: Qe.Constants.NONE,
  // file system
  fs: null
};
var tW = function(e, t) {
  let r = null;
  const n = Object.assign(/* @__PURE__ */ Object.create(null), eW);
  e && typeof e == "object" && (e instanceof Uint8Array || (Object.assign(n, e), e = n.input ? n.input : void 0, n.input && delete n.input), Buffer.isBuffer(e) && (r = e, n.method = Qe.Constants.BUFFER, e = void 0)), Object.assign(n, t);
  const i = new Qe(n);
  if ((typeof n.decoder != "object" || typeof n.decoder.encode != "function" || typeof n.decoder.decode != "function") && (n.decoder = Qe.decoder), e && typeof e == "string")
    if (i.fs.existsSync(e))
      n.method = Qe.Constants.FILE, n.filename = e, r = i.fs.readFileSync(e);
    else
      throw Qe.Errors.INVALID_FILENAME();
  const s = new ZG(r, n), { canonical: o, sanitize: a, zipnamefix: c } = Qe;
  function u(p) {
    if (p && s) {
      var d;
      if (typeof p == "string" && (d = s.getEntry(it.posix.normalize(p))), typeof p == "object" && typeof p.entryName < "u" && typeof p.header < "u" && (d = s.getEntry(p.entryName)), d)
        return d;
    }
    return null;
  }
  function l(p) {
    const { join: d, normalize: h, sep: _ } = it.posix;
    return d(".", h(_ + p.split("\\").join(_) + _));
  }
  function f(p) {
    return p instanceof RegExp ? /* @__PURE__ */ function(d) {
      return function(h) {
        return d.test(h);
      };
    }(p) : typeof p != "function" ? () => !0 : p;
  }
  const m = (p, d) => {
    let h = d.slice(-1);
    return h = h === i.sep ? i.sep : "", it.relative(p, d) + h;
  };
  return {
    /**
     * Extracts the given entry from the archive and returns the content as a Buffer object
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {Buffer|string} [pass] - password
     * @return Buffer or Null in case of error
     */
    readFile: function(p, d) {
      var h = u(p);
      return h && h.getData(d) || null;
    },
    /**
     * Returns how many child elements has on entry (directories) on files it is always 0
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @returns {integer}
     */
    childCount: function(p) {
      const d = u(p);
      if (d)
        return s.getChildCount(d);
    },
    /**
     * Asynchronous readFile
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     *
     * @return Buffer or Null in case of error
     */
    readFileAsync: function(p, d) {
      var h = u(p);
      h ? h.getDataAsync(d) : d(null, "getEntry failed for:" + p);
    },
    /**
     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
     * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry
     * @param {string} encoding - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsText: function(p, d) {
      var h = u(p);
      if (h) {
        var _ = h.getData();
        if (_ && _.length)
          return _.toString(d || "utf8");
      }
      return "";
    },
    /**
     * Asynchronous readAsText
     * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry
     * @param {callback} callback
     * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsTextAsync: function(p, d, h) {
      var _ = u(p);
      _ ? _.getDataAsync(function(g, v) {
        if (v) {
          d(g, v);
          return;
        }
        g && g.length ? d(g.toString(h || "utf8")) : d("");
      }) : d("");
    },
    /**
     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteFile: function(p, d = !0) {
      var h = u(p);
      h && s.deleteFile(h.entryName, d);
    },
    /**
     * Remove the entry from the file or directory without affecting any nested entries
     *
     * @param {ZipEntry|string} entry
     * @returns {void}
     */
    deleteEntry: function(p) {
      var d = u(p);
      d && s.deleteEntry(d.entryName);
    },
    /**
     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
     *
     * @param {string} comment
     */
    addZipComment: function(p) {
      s.comment = p;
    },
    /**
     * Returns the zip comment
     *
     * @return String
     */
    getZipComment: function() {
      return s.comment || "";
    },
    /**
     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
     * The comment cannot exceed 65535 characters in length
     *
     * @param {ZipEntry} entry
     * @param {string} comment
     */
    addZipEntryComment: function(p, d) {
      var h = u(p);
      h && (h.comment = d);
    },
    /**
     * Returns the comment of the specified entry
     *
     * @param {ZipEntry} entry
     * @return String
     */
    getZipEntryComment: function(p) {
      var d = u(p);
      return d && d.comment || "";
    },
    /**
     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
     *
     * @param {ZipEntry} entry
     * @param {Buffer} content
     */
    updateFile: function(p, d) {
      var h = u(p);
      h && h.setData(d);
    },
    /**
     * Adds a file from the disk to the archive
     *
     * @param {string} localPath File to add to zip
     * @param {string} [zipPath] Optional path inside the zip
     * @param {string} [zipName] Optional name for the file
     * @param {string} [comment] Optional file comment
     */
    addLocalFile: function(p, d, h, _) {
      if (i.fs.existsSync(p)) {
        d = d ? l(d) : "";
        const g = it.win32.basename(it.win32.normalize(p));
        d += h || g;
        const v = i.fs.statSync(p), y = v.isFile() ? i.fs.readFileSync(p) : Buffer.alloc(0);
        v.isDirectory() && (d += i.sep), this.addFile(d, y, _, v);
      } else
        throw Qe.Errors.FILE_NOT_FOUND(p);
    },
    /**
     * Callback for showing if everything was done.
     *
     * @callback doneCallback
     * @param {Error} err - Error object
     * @param {boolean} done - was request fully completed
     */
    /**
     * Adds a file from the disk to the archive
     *
     * @param {(object|string)} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the file.
     * @param {string} [options.comment] - Optional file comment.
     * @param {string} [options.zipPath] - Optional path inside the zip
     * @param {string} [options.zipName] - Optional name for the file
     * @param {doneCallback} callback - The callback that handles the response.
     */
    addLocalFileAsync: function(p, d) {
      p = typeof p == "object" ? p : { localPath: p };
      const h = it.resolve(p.localPath), { comment: _ } = p;
      let { zipPath: g, zipName: v } = p;
      const y = this;
      i.fs.stat(h, function(E, R) {
        if (E) return d(E, !1);
        g = g ? l(g) : "";
        const w = it.win32.basename(it.win32.normalize(h));
        if (g += v || w, R.isFile())
          i.fs.readFile(h, function(C, V) {
            return C ? d(C, !1) : (y.addFile(g, V, _, R), setImmediate(d, void 0, !0));
          });
        else if (R.isDirectory())
          return g += i.sep, y.addFile(g, Buffer.alloc(0), _, R), setImmediate(d, void 0, !0);
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - local path to the folder
     * @param {string} [zipPath] - optional path inside zip
     * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.
     */
    addLocalFolder: function(p, d, h) {
      if (h = f(h), d = d ? l(d) : "", p = it.normalize(p), i.fs.existsSync(p)) {
        const _ = i.findFiles(p), g = this;
        if (_.length)
          for (const v of _) {
            const y = it.join(d, m(p, v));
            h(y) && g.addLocalFile(v, it.dirname(y));
          }
      } else
        throw Qe.Errors.FILE_NOT_FOUND(p);
    },
    /**
     * Asynchronous addLocalFolder
     * @param {string} localPath
     * @param {callback} callback
     * @param {string} [zipPath] optional path inside zip
     * @param {RegExp|function} [filter] optional RegExp or Function if files match will
     *               be included.
     */
    addLocalFolderAsync: function(p, d, h, _) {
      _ = f(_), h = h ? l(h) : "", p = it.normalize(p);
      var g = this;
      i.fs.open(p, "r", function(v) {
        if (v && v.code === "ENOENT")
          d(void 0, Qe.Errors.FILE_NOT_FOUND(p));
        else if (v)
          d(void 0, v);
        else {
          var y = i.findFiles(p), E = -1, R = function() {
            if (E += 1, E < y.length) {
              var w = y[E], C = m(p, w).split("\\").join("/");
              C = C.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, ""), _(C) ? i.fs.stat(w, function(V, b) {
                V && d(void 0, V), b.isFile() ? i.fs.readFile(w, function(F, H) {
                  F ? d(void 0, F) : (g.addFile(h + C, H, "", b), R());
                }) : (g.addFile(h + C + "/", Buffer.alloc(0), "", b), R());
              }) : process.nextTick(() => {
                R();
              });
            } else
              d(!0, void 0);
          };
          R();
        }
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {object | string} options - options object, if it is string it us used as localPath.
     * @param {string} options.localPath - Local path to the folder.
     * @param {string} [options.zipPath] - optional path inside zip.
     * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [options.namefix] - optional function to help fix filename
     * @param {doneCallback} callback - The callback that handles the response.
     *
     */
    addLocalFolderAsync2: function(p, d) {
      const h = this;
      p = typeof p == "object" ? p : { localPath: p }, localPath = it.resolve(l(p.localPath));
      let { zipPath: _, filter: g, namefix: v } = p;
      g instanceof RegExp ? g = /* @__PURE__ */ function(R) {
        return function(w) {
          return R.test(w);
        };
      }(g) : typeof g != "function" && (g = function() {
        return !0;
      }), _ = _ ? l(_) : "", v == "latin1" && (v = (R) => R.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "")), typeof v != "function" && (v = (R) => R);
      const y = (R) => it.join(_, v(m(localPath, R))), E = (R) => it.win32.basename(it.win32.normalize(v(R)));
      i.fs.open(localPath, "r", function(R) {
        R && R.code === "ENOENT" ? d(void 0, Qe.Errors.FILE_NOT_FOUND(localPath)) : R ? d(void 0, R) : i.findFilesAsync(localPath, function(w, C) {
          if (w) return d(w);
          C = C.filter((V) => g(y(V))), C.length || d(void 0, !1), setImmediate(
            C.reverse().reduce(function(V, b) {
              return function(F, H) {
                if (F || H === !1) return setImmediate(V, F, !1);
                h.addLocalFileAsync(
                  {
                    localPath: b,
                    zipPath: it.dirname(y(b)),
                    zipName: E(b)
                  },
                  V
                );
              };
            }, d)
          );
        });
      });
    },
    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param {string} localPath - path where files will be extracted
     * @param {object} props - optional properties
     * @param {string} [props.zipPath] - optional path inside zip
     * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.
     * @param {function|string} [props.namefix] - optional function to help fix filename
     */
    addLocalFolderPromise: function(p, d) {
      return new Promise((h, _) => {
        this.addLocalFolderAsync2(Object.assign({ localPath: p }, d), (g, v) => {
          g && _(g), v && h(this);
        });
      });
    },
    /**
     * Allows you to create a entry (file or directory) in the zip file.
     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
     * Comment and attributes are optional
     *
     * @param {string} entryName
     * @param {Buffer | string} content - file content as buffer or utf8 coded string
     * @param {string} [comment] - file comment
     * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object
     */
    addFile: function(p, d, h, _) {
      p = c(p);
      let g = u(p);
      const v = g != null;
      v || (g = new XG(n), g.entryName = p), g.comment = h || "";
      const y = typeof _ == "object" && _ instanceof i.fs.Stats;
      y && (g.header.time = _.mtime);
      var E = g.isDirectory ? 16 : 0;
      let R = g.isDirectory ? 16384 : 32768;
      return y ? R |= 4095 & _.mode : typeof _ == "number" ? R |= 4095 & _ : R |= g.isDirectory ? 493 : 420, E = (E | R << 16) >>> 0, g.attr = E, g.setData(d), v || s.setEntry(g), g;
    },
    /**
     * Returns an array of ZipEntry objects representing the files and folders inside the archive
     *
     * @param {string} [password]
     * @returns Array
     */
    getEntries: function(p) {
      return s.password = p, s ? s.entries : [];
    },
    /**
     * Returns a ZipEntry object representing the file or folder specified by ``name``.
     *
     * @param {string} name
     * @return ZipEntry
     */
    getEntry: function(p) {
      return u(p);
    },
    getEntryCount: function() {
      return s.getEntryCount();
    },
    forEach: function(p) {
      return s.forEach(p);
    },
    /**
     * Extracts the given entry to the given targetPath
     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
     *
     * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry
     * @param {string} targetPath - Target folder where to write the file
     * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE
     * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.
     * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.
     * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)
     *
     * @return Boolean
     */
    extractEntryTo: function(p, d, h, _, g, v) {
      _ = _i(!1, _), g = _i(!1, g), h = _i(!0, h), v = nw(g, v);
      var y = u(p);
      if (!y)
        throw Qe.Errors.NO_ENTRY();
      var E = o(y.entryName), R = a(d, v && !y.isDirectory ? v : h ? E : it.basename(E));
      if (y.isDirectory) {
        var w = s.getEntryChildren(y);
        return w.forEach(function(b) {
          if (b.isDirectory) return;
          var F = b.getData();
          if (!F)
            throw Qe.Errors.CANT_EXTRACT_FILE();
          var H = o(b.entryName), q = a(d, h ? H : it.basename(H));
          const $ = g ? b.header.fileAttr : void 0;
          i.writeFileTo(q, F, _, $);
        }), !0;
      }
      var C = y.getData(s.password);
      if (!C) throw Qe.Errors.CANT_EXTRACT_FILE();
      if (i.fs.existsSync(R) && !_)
        throw Qe.Errors.CANT_OVERRIDE();
      const V = g ? p.header.fileAttr : void 0;
      return i.writeFileTo(R, C, _, V), !0;
    },
    /**
     * Test the archive
     * @param {string} [pass]
     */
    test: function(p) {
      if (!s)
        return !1;
      for (var d in s.entries)
        try {
          if (d.isDirectory)
            continue;
          var h = s.entries[d].getData(p);
          if (!h)
            return !1;
        } catch {
          return !1;
        }
      return !0;
    },
    /**
     * Extracts the entire archive to the given location
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {string|Buffer} [pass] password
     */
    extractAllTo: function(p, d, h, _) {
      if (h = _i(!1, h), _ = nw(h, _), d = _i(!1, d), !s) throw Qe.Errors.NO_ZIP();
      s.entries.forEach(function(g) {
        var v = a(p, o(g.entryName));
        if (g.isDirectory) {
          i.makeDir(v);
          return;
        }
        var y = g.getData(_);
        if (!y)
          throw Qe.Errors.CANT_EXTRACT_FILE();
        const E = h ? g.header.fileAttr : void 0;
        i.writeFileTo(v, y, d, E);
        try {
          i.fs.utimesSync(v, g.header.time, g.header.time);
        } catch {
          throw Qe.Errors.CANT_EXTRACT_FILE();
        }
      });
    },
    /**
     * Asynchronous extractAllTo
     *
     * @param {string} targetPath Target location
     * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.
     */
    extractAllToAsync: function(p, d, h, _) {
      if (_ = QG(d, h, _), h = _i(!1, h), d = _i(!1, d), !_)
        return new Promise((R, w) => {
          this.extractAllToAsync(p, d, h, function(C) {
            C ? w(C) : R(this);
          });
        });
      if (!s) {
        _(Qe.Errors.NO_ZIP());
        return;
      }
      p = it.resolve(p);
      const g = (R) => a(p, it.normalize(o(R.entryName))), v = (R, w) => new Error(R + ': "' + w + '"'), y = [], E = [];
      s.entries.forEach((R) => {
        R.isDirectory ? y.push(R) : E.push(R);
      });
      for (const R of y) {
        const w = g(R), C = h ? R.header.fileAttr : void 0;
        try {
          i.makeDir(w), C && i.fs.chmodSync(w, C), i.fs.utimesSync(w, R.header.time, R.header.time);
        } catch {
          _(v("Unable to create folder", w));
        }
      }
      E.reverse().reduce(function(R, w) {
        return function(C) {
          if (C)
            R(C);
          else {
            const V = it.normalize(o(w.entryName)), b = a(p, V);
            w.getDataAsync(function(F, H) {
              if (H)
                R(H);
              else if (!F)
                R(Qe.Errors.CANT_EXTRACT_FILE());
              else {
                const q = h ? w.header.fileAttr : void 0;
                i.writeFileToAsync(b, F, d, q, function($) {
                  $ || R(v("Unable to write file", b)), i.fs.utimes(b, w.header.time, w.header.time, function(x) {
                    x ? R(v("Unable to set times", b)) : R();
                  });
                });
              }
            });
          }
        };
      }, _)();
    },
    /**
     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
     *
     * @param {string} targetFileName
     * @param {function} callback
     */
    writeZip: function(p, d) {
      if (arguments.length === 1 && typeof p == "function" && (d = p, p = ""), !p && n.filename && (p = n.filename), !!p) {
        var h = s.compressToBuffer();
        if (h) {
          var _ = i.writeFileTo(p, h, !0);
          typeof d == "function" && d(_ ? null : new Error("failed"), "");
        }
      }
    },
    /**
             *
             * @param {string} targetFileName
             * @param {object} [props]
             * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.
             * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.
    
             * @returns {Promise<void>}
             */
    writeZipPromise: function(p, d) {
      const { overwrite: h, perm: _ } = Object.assign({ overwrite: !0 }, d);
      return new Promise((g, v) => {
        !p && n.filename && (p = n.filename), p || v("ADM-ZIP: ZIP File Name Missing"), this.toBufferPromise().then((y) => {
          const E = (R) => R ? g(R) : v("ADM-ZIP: Wasn't able to write zip file");
          i.writeFileToAsync(p, y, h, _, E);
        }, v);
      });
    },
    /**
     * @returns {Promise<Buffer>} A promise to the Buffer.
     */
    toBufferPromise: function() {
      return new Promise((p, d) => {
        s.toAsyncBuffer(p, d);
      });
    },
    /**
     * Returns the content of the entire zip file as a Buffer object
     *
     * @prop {function} [onSuccess]
     * @prop {function} [onFail]
     * @prop {function} [onItemStart]
     * @prop {function} [onItemEnd]
     * @returns {Buffer}
     */
    toBuffer: function(p, d, h, _) {
      return typeof p == "function" ? (s.toAsyncBuffer(p, d, h, _), null) : s.compressToBuffer();
    }
  };
};
const rW = /* @__PURE__ */ La(tW);
function nW(e) {
  try {
    let t;
    process.platform === "win32" ? t = `netstat -ano | findstr :${e}` : t = `lsof -i :${e} | awk 'NR>1 {print $2}'`;
    const r = cl(t, { encoding: "utf8" }).trim();
    if (!r) return null;
    let n;
    if (process.platform === "win32") {
      const i = /\s+(\d+)\s*$/;
      n = r.split(`
`).map((s) => {
        const o = s.match(i);
        return o ? parseInt(o[1], 10) : NaN;
      }).filter((s) => !isNaN(s));
    } else
      n = r.split(`
`).map((i) => parseInt(i.trim(), 10)).filter((i) => !isNaN(i));
    return [...new Set(n)];
  } catch {
    return null;
  }
}
function Up(e) {
  const t = nW(e);
  return !!(t && t.length > 0);
}
function iW(e) {
  const t = /^\[(.*?)\] \[(.*?)\] \[(.*?)\] \[(.*?::\d+::.*?)\] (.*)$/, r = e.match(t);
  return r ? {
    time: r[1],
    // 时间
    level: r[2],
    // 日志等级
    app: r[3],
    // 日志应用
    line: r[4],
    // 日志位置
    message: r[5]
    // 日志消息
  } : null;
}
const vT = gC(import.meta.url), sW = vT("koffi"), oW = vT("node-cron");
class aW {
  constructor(t) {
    we(this, "Wcf_directory");
    we(this, "wcfconfigPath");
    we(this, "wcfConfig");
    we(this, "windown");
    we(this, "server");
    we(this, "WxInitSDK");
    we(this, "WxDestroySDK");
    we(this, "scheduleJobs");
    //   上报配置文件
    we(this, "reportConfig", () => {
      this.windown.webContents.send("wcf:config", this.wcfConfig);
    });
    //   写入配置文件
    we(this, "writeConfig", (t) => {
      this.wcfConfig = t, Ue.writeFileSync(this.wcfconfigPath, JSON.stringify(t, null, 4));
    });
    //   发送日志
    we(this, "sendLog", (t, r) => {
      this.windown.webContents.send("wcf:log", { message: t, level: r || "INFO", timestamp: pT().format("YYYY-MM-DD HH:mm:ss.SSS ") });
    });
    //   检测WCF是否有更新
    we(this, "checkUpdate", async () => {
      const t = _e.join(this.Wcf_directory, "config.json");
      if (Ue.existsSync(t)) {
        const n = JSON.parse(Ue.readFileSync(t, "utf-8")).version.replace("v", "").split(".").join("") || "0", i = await this.getWCFVersion(), s = (i == null ? void 0 : i.version.replace("v", "").split(".").join("")) || "0";
        if (Number(n) < Number(s))
          return { status: !0, version: (i == null ? void 0 : i.version) || "" };
      }
      return { staus: !1, version: this.wcfConfig.version };
    });
    //   检测WCF是否存在
    we(this, "checkWCF", () => {
      const t = _e.join(this.Wcf_directory, "sdk.dll");
      return !!Ue.existsSync(t);
    });
    // 获取WCF版本信息
    we(this, "getWCFVersion", async () => {
      const t = "https://api.github.com/repos/lich0821/WeChatFerry/releases/latest";
      try {
        const r = await tt.get(t, {
          responseType: "json",
          validateStatus: (n) => n < 500
        });
        return !r || !r.data || !r.data.assets || r.data.assets.length === 0 ? (this.sendLog("Failed to retrieve valid data from GitHub API.", "ERROR"), r.data.message && this.sendLog(r.data.message, "ERROR"), { version: "", download_url: "" }) : {
          version: r.data.tag_name,
          download_url: r.data.assets[0].browser_download_url
        };
      } catch (r) {
        return this.sendLog(`获取WCF版本信息失败:${r == null ? void 0 : r.message}`, "ERROR"), null;
      }
    });
<<<<<<< HEAD
    __publicField(this, "downloadFile", async (url2, dest) => {
      const writer = fs$k.createWriteStream(dest);
      try {
        const proxyurl = this.wcfConfig.proxy_url ? this.wcfConfig.proxy_url + "/" : "";
        const down_url = proxyurl + url2;
        this.sendLog(`开始下载文件:${down_url}`, "INFO");
        const download = await axios({
          method: "get",
          url: down_url,
          responseType: "stream",
          timeout: 12e3
        });
        download.data.pipe(writer);
        return await new Promise((resolve2, reject) => {
          writer.on("finish", async () => {
            this.sendLog("下载完成", "SUCCESS");
            resolve2(true);
          });
          writer.on("error", reject);
        });
      } catch (error2) {
        await writer.close();
        this.sendLog(`下载失败:${error2.message},url:${url2}`, "ERROR");
        fs$k.unlinkSync(dest);
        return false;
=======
    we(this, "downloadFile", async (t, r) => {
      try {
        const i = (this.wcfConfig.proxy_url ? this.wcfConfig.proxy_url + "/" : "") + t;
        this.sendLog(`开始下载文件:${i}`, "INFO");
        const s = Ue.createWriteStream(r);
        return (await tt({
          method: "get",
          url: i,
          responseType: "stream"
        })).data.pipe(s), await new Promise((a, c) => {
          s.on("finish", async () => {
            this.sendLog("下载完成", "SUCCESS"), a(!0);
          }), s.on("error", c);
        });
      } catch (n) {
        return this.sendLog(`下载失败:${n.message},url:${t}`, "ERROR"), !1;
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
      }
    });
    //   下载最新版的WCF
    we(this, "downloadWCF", async () => {
      this.sendLog("开始下载最新版本的WCF", "INFO");
      let t = "";
      try {
<<<<<<< HEAD
        const result = await this.getWCFVersion();
        this.sendLog(`✅ 获取WCF最新版本信息成功:${result == null ? void 0 : result.version}`, "SUCCESS");
        this.wcfConfig.version = (result == null ? void 0 : result.version) || "";
        const filename = require$$1$4.basename(result == null ? void 0 : result.download_url);
        output = require$$1$4.join(this.Wcf_directory, filename);
        if (fs$k.existsSync(output)) {
          console.log("文件存在跳过下载");
          return await this.unzipFile(output);
        }
        const res2 = await this.downloadFile(result == null ? void 0 : result.download_url, output);
        if (!res2) return res2;
        const unCompress = await this.unzipFile(output);
        if (unCompress) {
          this.wcfConfig.version = (result == null ? void 0 : result.version) || "";
          this.writeConfig(this.wcfConfig);
          this.reportConfig();
        }
      } catch (error2) {
        this.sendLog(`下载WCF失败:${error2.message}`, "ERROR");
        return false;
=======
        const r = await this.getWCFVersion();
        this.sendLog(`✅ 获取WCF最新版本信息成功:${r == null ? void 0 : r.version}`, "SUCCESS"), this.wcfConfig.version = (r == null ? void 0 : r.version) || "";
        const n = _e.basename(r == null ? void 0 : r.download_url);
        if (t = _e.join(this.Wcf_directory, n), Ue.existsSync(t))
          return await this.unzipFile(t);
        const i = await this.downloadFile(r == null ? void 0 : r.download_url, t);
        if (!i) return i;
        await this.unzipFile(t) && (this.wcfConfig.version = (r == null ? void 0 : r.version) || "", this.writeConfig(this.wcfConfig), this.reportConfig());
      } catch (r) {
        return this.sendLog(`下载WCF失败:${r.message}`, "ERROR"), Ue.unlinkSync(t), !1;
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
      }
    });
    // 注入Dll
    we(this, "InjectWCF", async () => {
      if (process.platform !== "win32") {
        this.sendLog("当前系统不支持WCF注入", "ERROR");
        return;
      }
      this.checkWCF() || (this.sendLog("WCF核心不存在，即将自动下载", "WARN"), await this.downloadWCF());
      const r = await this.checkWCFIsRun();
      if (!r.wcf_run && r.portOcc)
        return this.sendLog(`当前端口已被占用:${this.wcfConfig.port}请修改系统设置端口，避免启动失败！`, "WARN"), !1;
      this.sendLog("开始注入WCF", "INFO");
      const n = _e.join(this.Wcf_directory, "sdk.dll"), i = sW.load(n);
      return this.WxInitSDK = i.func("int WxInitSDK(bool, int)", "stdcall"), this.WxDestroySDK = i.func("WxDestroySDK", "void", []), !0;
    });
    // 启动WCF
    we(this, "startWCF", async () => {
      var t;
      try {
        const r = await this.InjectWCF();
        if (!r) return r;
        const n = (t = this.WxInitSDK) == null ? void 0 : t.call(this, this.wcfConfig.debug, this.wcfConfig.port);
        if (n !== 0) {
          this.sendLog(`WCF启动失败：${n}`, "ERROR");
          return;
        }
        return this.sendLog(`✅WCF启动成功:Tcp://0.0.0.0:${this.wcfConfig.port}`, "SUCCESS"), this.checkWCFIsRun(), !0;
      } catch (r) {
        this.sendLog(`启动WCF失败:${r.message}`, "ERROR");
      }
    });
    // 更新WCFdLL
    we(this, "updateWCF", async () => {
      var r;
      (await this.checkWCFIsRun()).wcf_run && ((r = this.WxDestroySDK) == null || r.call(this), this.sendLog("WCF已关闭", "INFO")), await this.downloadWCF(), await this.startWCF();
    });
    // 重启WCF
    we(this, "restartWCF", async () => {
      var r;
      (await this.checkWCFIsRun()).wcf_run && await ((r = this.WxDestroySDK) == null ? void 0 : r.call(this)), await this.startWCF();
    });
    // 关闭WCF
    we(this, "closeWCF", async () => {
      this.WxDestroySDK ? (this.WxDestroySDK(), this.sendLog("WCF已关闭", "INFO")) : this.sendLog("WCF未运行", "INFO"), this.checkWCFIsRun(), this.clearWcfLog();
    });
    // 修改WCF配置文件
    we(this, "modifyWCFConfig", async (t, r) => {
      this.wcfConfig = { ...this.wcfConfig, ...r }, this.writeConfig(this.wcfConfig), this.reportConfig();
    });
    // 获取配置文件
    we(this, "getWCFConfig", async () => this.wcfConfig);
    //   检测WCF是否在运行
    we(this, "checkWCFIsRun", async () => {
      const t = {
        portOcc: Up(this.wcfConfig.port),
        wcf_run: Up(this.wcfConfig.port) && !!this.WxInitSDK,
        http: !!(this.server && Up(this.wcfConfig.httpPort))
      };
      return this.windown.webContents.send("wcf:startEvent", t), t;
    });
    // 重置WCF环境
    we(this, "resetWCF", async () => {
      this.sendLog("开始重置WCF环境", "INFO"), await this.KillPort(this.wcfConfig.port), await this.KillPort(+this.wcfConfig.port + 1), this.checkWCFIsRun();
    });
    we(this, "KillPort", async (t) => {
      try {
        const r = await this.getPidsByPort(t), n = r.filter((i) => i !== 0);
        if (n.length == 0) {
          this.sendLog(`当前端口:${t}没有被占用`, "INFO");
          return;
        }
        if (r.length == 0) {
          this.sendLog(`当前端口:${t}没有被占用`, "INFO");
          return;
        }
        this.sendLog(`成功检测${t}端口对应的PID:${r},即将终止相关PID进程`, "INFO"), n.forEach((i) => {
          const s = this.killProcessByPid(i);
          this.sendLog(s.message, s.success ? "SUCCESS" : "ERROR");
        });
      } catch (r) {
        this.sendLog(`重置WCF环境失败:${r.message}`, "ERROR");
      }
    });
    // 开启http服务
    we(this, "startWcfServer", async () => {
      try {
        const t = E6({ trustProxy: !0 });
        t.get("/", async () => ({ code: 0, ...this.wcfConfig })), t.get("/start-wcf", async () => await this.startWCF() ? { code: 0, message: "WCF启动成功" } : { code: 1, message: "WCF启动失败,详情请看软件日志区域" }), t.get("/close-wcf", async () => (await this.closeWCF(), { code: 0, message: "WCF关闭成功" })), t.addHook("onSend", async (r, n, i) => {
          this.sendLog(`HTTP LOG: Method: ${r.method}、Url: ${r.url}、ClientIp:${r.ip}、Response:${i}`, "INFO");
        }), await t.listen({ host: "0.0.0.0", port: this.wcfConfig.httpPort }), this.sendLog(`✅ HTTP SERVER IS START:0.0.0.0:${this.wcfConfig.httpPort}`, "SUCCESS"), this.server = t, this.checkWCFIsRun();
      } catch (t) {
        this.sendLog(t.message, "ERROR");
      }
    });
    // 关闭http服务
    we(this, "closeWcfServer", async () => {
      this.server && (await this.server.close(), this.sendLog("Http Server Is Close", "INFO")), this.checkWCFIsRun();
    });
    // 注册定时任务
    we(this, "registerSchedule", (t, r) => {
      const n = oW.schedule(t, r);
      this.scheduleJobs.push(n), n.start();
    });
    // 清空定时任务
    we(this, "clearSchedule", () => {
      this.scheduleJobs.map((t) => {
        t.stop();
      }), this.scheduleJobs.length = 0;
    });
    // 检测端口对应的pid
    we(this, "getPidsByPort", async (t) => {
      try {
        const n = cl(`netstat -ano | findstr :${t}`, { encoding: "utf-8" }).split(`
`).filter((s) => s.includes(`:${t}`));
        return n.length === 0 ? [] : n.map((s) => {
          const o = s.trim().split(/\s+/).pop();
          return Number(o);
        });
      } catch {
        return [];
      }
    });
    we(this, "killProcessByPid", (t) => {
      try {
        return cl(`taskkill /PID ${t} /F`, { stdio: "ignore" }), { success: !0, message: `✅ 成功终止 PID ${t} 的进程` };
      } catch {
        return { success: !1, message: `❌ 无法终止 PID ${t}，可能不存在或已退出,请打开任务管理器核对` };
      }
    });
    // 唤醒微信
    we(this, "wakeUpWeChat", () => {
      try {
        if (process.platform === "win32")
          cl("start weixin://");
        else if (process.platform === "darwin")
          open("open weixin://");
        else {
          this.sendLog("❌ 当前系统不支持微信协议唤醒", "ERROR");
          return;
        }
        console.log("✅ 微信客户端已唤醒");
      } catch (t) {
        this.sendLog(`❌ 无法唤醒微信:${t.message}`, "ERROR");
      }
    });
    we(this, "injectVersionDll", async (t, r = !1) => {
      const n = yr.getPath("downloads");
      this.closeWCF(), this.sendLog(`开始检测指定版本:${t}是否存在`, "INFO");
      const i = `https://api.github.com/repos/lich0821/WeChatFerry/releases/tags/${t}`, o = (await tt.get(i, {
        validateStatus: (h) => h < 500
      })).data;
      if (o.status == 404)
        return this.sendLog(`指定版本:${t}不存在`, "ERROR"), 404;
      const a = o.assets, [c, u] = a, l = c.browser_download_url;
      this.sendLog(`✅ 获取指定版本:${t}下载地址成功:${l}`, "SUCCESS");
      const f = _e.basename(l), m = _e.join(this.Wcf_directory, f), p = await this.downloadFile(l, m);
      if (!p) return p;
      const d = await this.unzipFile(m, this.Wcf_directory);
      if (d && (this.wcfConfig.version = t || "", this.writeConfig(this.wcfConfig), this.reportConfig()), !d) return d;
      if (this.sendLog(`✅ 指定版本:${t}下载完成`, "SUCCESS"), r) {
        const h = u.browser_download_url, _ = _e.basename(h);
        this.sendLog(`开始下载指定版本:${t}对应的${u.name}`, "INFO");
        const g = _e.join(n, _), v = await this.downloadFile(h, g);
        if (!v) return v;
        this.sendLog(`✅ 指定版本:${t}对应的${u.name}下载完成`, "SUCCESS"), this.sendLog(`文件已保存:${g}`, "INFO"), this.sendLog("安装指定版本微信登录成功后 重新启动WCF即可", "INFO");
      }
    });
    // 读取wcf日志
    we(this, "readWcfLog", () => {
      const t = _e.join(yr.getAppPath(), "logs/wcf.txt");
      return Ue.existsSync(t) ? Ue.readFileSync(t, "utf-8").split(`
`).reverse().map((n) => iW(n)).filter((n) => n) : (this.sendLog("WCF日志文件不存在", "ERROR"), this.sendLog("请先启动WCF后再查看日志", "ERROR"), []);
    });
    //清空日志
    we(this, "clearWcfLog", () => {
      const t = _e.join(yr.getAppPath(), "logs/wcf.txt");
      Ue.existsSync(t) && Ue.writeFileSync(t, "");
    });
    this.windown = t, this.server = null, this.Wcf_directory = _e.join(yr.getPath("documents"), "WCFApp"), this.wcfconfigPath = _e.join(this.Wcf_directory, "config.json"), this.WxInitSDK = null, this.WxDestroySDK = null, Ue.existsSync(this.Wcf_directory) || Ue.mkdirSync(this.Wcf_directory, { recursive: !0 });
    const r = yr.getVersion(), n = {
      port: 10086,
      debug: !1,
      proxy_url: "",
      version: "",
      httpPort: 9200,
      cronCheck: 12,
      app_version: r
    };
    if (Ue.existsSync(this.wcfconfigPath)) {
      const i = JSON.parse(Ue.readFileSync(this.wcfconfigPath, "utf-8"));
      this.wcfConfig = { ...n, ...i, app_version: r };
    } else
      this.wcfConfig = n;
    this.writeConfig(this.wcfConfig), this.scheduleJobs = [];
  }
  //   解压文件
  async unzipFile(t, r = this.Wcf_directory) {
    try {
      this.sendLog("开始解压文件", "INFO");
<<<<<<< HEAD
      const zip = new AdmZip(filePath);
      return await new Promise((resolve2, reject) => {
        try {
          zip.extractAllToAsync(dest, true, (err2) => {
            console.log(err2, 195);
            if (err2) reject(err2);
            else {
              this.sendLog("✅ 解压文件完成", "SUCCESS");
              fs$k.unlinkSync(filePath);
              resolve2(true);
            }
          });
        } catch (err2) {
          console.log(err2, 205);
        }
=======
      const n = new rW(t);
      return await new Promise((i, s) => {
        n.extractAllToAsync(r, !0, (o) => {
          o ? s(o) : (this.sendLog("✅ 解压文件完成", "SUCCESS"), Ue.unlinkSync(t), i(!0));
        });
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
      });
    } catch (n) {
      return this.sendLog(`解压文件失败: ${n}`, "ERROR"), Ue.unlinkSync(t), !1;
    }
  }
}
var ws = {}, Zi = {}, nr = {};
nr.fromCallback = function(e) {
  return Object.defineProperty(function(...t) {
    if (typeof t[t.length - 1] == "function") e.apply(this, t);
    else
      return new Promise((r, n) => {
        t.push((i, s) => i != null ? n(i) : r(s)), e.apply(this, t);
      });
  }, "name", { value: e.name });
};
nr.fromPromise = function(e) {
  return Object.defineProperty(function(...t) {
    const r = t[t.length - 1];
    if (typeof r != "function") return e.apply(this, t);
    t.pop(), e.apply(this, t).then((n) => r(null, n), r);
  }, "name", { value: e.name });
};
var Ln = RC, cW = process.cwd, Cl = null, lW = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return Cl || (Cl = cW.call(process)), Cl;
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var iw = process.chdir;
  process.chdir = function(e) {
    Cl = null, iw.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, iw);
}
var uW = fW;
function fW(e) {
  Ln.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || r(e), e.chown = s(e.chown), e.fchown = s(e.fchown), e.lchown = s(e.lchown), e.chmod = n(e.chmod), e.fchmod = n(e.fchmod), e.lchmod = n(e.lchmod), e.chownSync = o(e.chownSync), e.fchownSync = o(e.fchownSync), e.lchownSync = o(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync = i(e.lchmodSync), e.stat = a(e.stat), e.fstat = a(e.fstat), e.lstat = a(e.lstat), e.statSync = c(e.statSync), e.fstatSync = c(e.fstatSync), e.lstatSync = c(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(l, f, m) {
    m && process.nextTick(m);
  }, e.lchmodSync = function() {
  }), e.chown && !e.lchown && (e.lchown = function(l, f, m, p) {
    p && process.nextTick(p);
  }, e.lchownSync = function() {
  }), lW === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(l) {
    function f(m, p, d) {
      var h = Date.now(), _ = 0;
      l(m, p, function g(v) {
        if (v && (v.code === "EACCES" || v.code === "EPERM" || v.code === "EBUSY") && Date.now() - h < 6e4) {
          setTimeout(function() {
            e.stat(p, function(y, E) {
              y && y.code === "ENOENT" ? l(m, p, g) : d(v);
            });
          }, _), _ < 100 && (_ += 10);
          return;
        }
        d && d(v);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(f, l), f;
  }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(l) {
    function f(m, p, d, h, _, g) {
      var v;
      if (g && typeof g == "function") {
        var y = 0;
        v = function(E, R, w) {
          if (E && E.code === "EAGAIN" && y < 10)
            return y++, l.call(e, m, p, d, h, _, v);
          g.apply(this, arguments);
        };
      }
      return l.call(e, m, p, d, h, _, v);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(f, l), f;
  }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(l) {
    return function(f, m, p, d, h) {
      for (var _ = 0; ; )
        try {
          return l.call(e, f, m, p, d, h);
        } catch (g) {
          if (g.code === "EAGAIN" && _ < 10) {
            _++;
            continue;
          }
          throw g;
        }
    };
  }(e.readSync);
  function t(l) {
    l.lchmod = function(f, m, p) {
      l.open(
        f,
        Ln.O_WRONLY | Ln.O_SYMLINK,
        m,
        function(d, h) {
          if (d) {
            p && p(d);
            return;
          }
          l.fchmod(h, m, function(_) {
            l.close(h, function(g) {
              p && p(_ || g);
            });
          });
        }
      );
    }, l.lchmodSync = function(f, m) {
      var p = l.openSync(f, Ln.O_WRONLY | Ln.O_SYMLINK, m), d = !0, h;
      try {
        h = l.fchmodSync(p, m), d = !1;
      } finally {
        if (d)
          try {
            l.closeSync(p);
          } catch {
          }
        else
          l.closeSync(p);
      }
      return h;
    };
  }
  function r(l) {
    Ln.hasOwnProperty("O_SYMLINK") && l.futimes ? (l.lutimes = function(f, m, p, d) {
      l.open(f, Ln.O_SYMLINK, function(h, _) {
        if (h) {
          d && d(h);
          return;
        }
        l.futimes(_, m, p, function(g) {
          l.close(_, function(v) {
            d && d(g || v);
          });
        });
      });
    }, l.lutimesSync = function(f, m, p) {
      var d = l.openSync(f, Ln.O_SYMLINK), h, _ = !0;
      try {
        h = l.futimesSync(d, m, p), _ = !1;
      } finally {
        if (_)
          try {
            l.closeSync(d);
          } catch {
          }
        else
          l.closeSync(d);
      }
      return h;
    }) : l.futimes && (l.lutimes = function(f, m, p, d) {
      d && process.nextTick(d);
    }, l.lutimesSync = function() {
    });
  }
  function n(l) {
    return l && function(f, m, p) {
      return l.call(e, f, m, function(d) {
        u(d) && (d = null), p && p.apply(this, arguments);
      });
    };
  }
  function i(l) {
    return l && function(f, m) {
      try {
        return l.call(e, f, m);
      } catch (p) {
        if (!u(p)) throw p;
      }
    };
  }
  function s(l) {
    return l && function(f, m, p, d) {
      return l.call(e, f, m, p, function(h) {
        u(h) && (h = null), d && d.apply(this, arguments);
      });
    };
  }
  function o(l) {
    return l && function(f, m, p) {
      try {
        return l.call(e, f, m, p);
      } catch (d) {
        if (!u(d)) throw d;
      }
    };
  }
  function a(l) {
    return l && function(f, m, p) {
      typeof m == "function" && (p = m, m = null);
      function d(h, _) {
        _ && (_.uid < 0 && (_.uid += 4294967296), _.gid < 0 && (_.gid += 4294967296)), p && p.apply(this, arguments);
      }
      return m ? l.call(e, f, m, d) : l.call(e, f, d);
    };
  }
  function c(l) {
    return l && function(f, m) {
      var p = m ? l.call(e, f, m) : l.call(e, f);
      return p && (p.uid < 0 && (p.uid += 4294967296), p.gid < 0 && (p.gid += 4294967296)), p;
    };
  }
  function u(l) {
    if (!l || l.code === "ENOSYS")
      return !0;
    var f = !process.getuid || process.getuid() !== 0;
    return !!(f && (l.code === "EINVAL" || l.code === "EPERM"));
  }
}
var sw = It.Stream, dW = pW;
function pW(e) {
  return {
    ReadStream: t,
    WriteStream: r
  };
  function t(n, i) {
    if (!(this instanceof t)) return new t(n, i);
    sw.call(this);
    var s = this;
    this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i = i || {};
    for (var o = Object.keys(i), a = 0, c = o.length; a < c; a++) {
      var u = o[a];
      this[u] = i[u];
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        s._read();
      });
      return;
    }
    e.open(this.path, this.flags, this.mode, function(l, f) {
      if (l) {
        s.emit("error", l), s.readable = !1;
        return;
      }
      s.fd = f, s.emit("open", f), s._read();
    });
  }
  function r(n, i) {
    if (!(this instanceof r)) return new r(n, i);
    sw.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
    for (var s = Object.keys(i), o = 0, a = s.length; o < a; o++) {
      var c = s[o];
      this[c] = i[c];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
var hW = gW, mW = Object.getPrototypeOf || function(e) {
  return e.__proto__;
};
function gW(e) {
  if (e === null || typeof e != "object")
    return e;
  if (e instanceof Object)
    var t = { __proto__: mW(e) };
  else
    var t = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(e).forEach(function(r) {
    Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
  }), t;
}
var et = Ue, yW = uW, vW = dW, _W = hW, el = Sn, Dt, nu;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (Dt = Symbol.for("graceful-fs.queue"), nu = Symbol.for("graceful-fs.previous")) : (Dt = "___graceful-fs.queue", nu = "___graceful-fs.previous");
function bW() {
}
function _T(e, t) {
  Object.defineProperty(e, Dt, {
    get: function() {
      return t;
    }
  });
}
var ji = bW;
el.debuglog ? ji = el.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (ji = function() {
  var e = el.format.apply(el, arguments);
  e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
});
if (!et[Dt]) {
  var EW = me[Dt] || [];
  _T(et, EW), et.close = function(e) {
    function t(r, n) {
      return e.call(et, r, function(i) {
        i || ow(), typeof n == "function" && n.apply(this, arguments);
      });
    }
    return Object.defineProperty(t, nu, {
      value: e
    }), t;
  }(et.close), et.closeSync = function(e) {
    function t(r) {
      e.apply(et, arguments), ow();
    }
    return Object.defineProperty(t, nu, {
      value: e
    }), t;
  }(et.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    ji(et[Dt]), Da.equal(et[Dt].length, 0);
  });
}
me[Dt] || _T(me, et[Dt]);
var ir = Iy(_W(et));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !et.__patched && (ir = Iy(et), et.__patched = !0);
function Iy(e) {
  yW(e), e.gracefulify = Iy, e.createReadStream = R, e.createWriteStream = w;
  var t = e.readFile;
  e.readFile = r;
  function r(b, F, H) {
    return typeof F == "function" && (H = F, F = null), q(b, F, H);
    function q($, x, A, P) {
      return t($, x, function(D) {
        D && (D.code === "EMFILE" || D.code === "ENFILE") ? ps([q, [$, x, A], D, P || Date.now(), Date.now()]) : typeof A == "function" && A.apply(this, arguments);
      });
    }
  }
  var n = e.writeFile;
  e.writeFile = i;
  function i(b, F, H, q) {
    return typeof H == "function" && (q = H, H = null), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return n(x, A, P, function(L) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? ps([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  var s = e.appendFile;
  s && (e.appendFile = o);
  function o(b, F, H, q) {
    return typeof H == "function" && (q = H, H = null), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return s(x, A, P, function(L) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? ps([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  var a = e.copyFile;
  a && (e.copyFile = c);
  function c(b, F, H, q) {
    return typeof H == "function" && (q = H, H = 0), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return a(x, A, P, function(L) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? ps([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  var u = e.readdir;
  e.readdir = f;
  var l = /^v[0-5]\./;
  function f(b, F, H) {
    typeof F == "function" && (H = F, F = null);
    var q = l.test(process.version) ? function(A, P, D, I) {
      return u(A, $(
        A,
        P,
        D,
        I
      ));
    } : function(A, P, D, I) {
      return u(A, P, $(
        A,
        P,
        D,
        I
      ));
    };
    return q(b, F, H);
    function $(x, A, P, D) {
      return function(I, L) {
        I && (I.code === "EMFILE" || I.code === "ENFILE") ? ps([
          q,
          [x, A, P],
          I,
          D || Date.now(),
          Date.now()
        ]) : (L && L.sort && L.sort(), typeof P == "function" && P.call(this, I, L));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var m = vW(e);
    g = m.ReadStream, y = m.WriteStream;
  }
  var p = e.ReadStream;
  p && (g.prototype = Object.create(p.prototype), g.prototype.open = v);
  var d = e.WriteStream;
  d && (y.prototype = Object.create(d.prototype), y.prototype.open = E), Object.defineProperty(e, "ReadStream", {
    get: function() {
      return g;
    },
    set: function(b) {
      g = b;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e, "WriteStream", {
    get: function() {
      return y;
    },
    set: function(b) {
      y = b;
    },
    enumerable: !0,
    configurable: !0
  });
  var h = g;
  Object.defineProperty(e, "FileReadStream", {
    get: function() {
      return h;
    },
    set: function(b) {
      h = b;
    },
    enumerable: !0,
    configurable: !0
  });
  var _ = y;
  Object.defineProperty(e, "FileWriteStream", {
    get: function() {
      return _;
    },
    set: function(b) {
      _ = b;
    },
    enumerable: !0,
    configurable: !0
  });
  function g(b, F) {
    return this instanceof g ? (p.apply(this, arguments), this) : g.apply(Object.create(g.prototype), arguments);
  }
  function v() {
    var b = this;
    V(b.path, b.flags, b.mode, function(F, H) {
      F ? (b.autoClose && b.destroy(), b.emit("error", F)) : (b.fd = H, b.emit("open", H), b.read());
    });
  }
  function y(b, F) {
    return this instanceof y ? (d.apply(this, arguments), this) : y.apply(Object.create(y.prototype), arguments);
  }
  function E() {
    var b = this;
    V(b.path, b.flags, b.mode, function(F, H) {
      F ? (b.destroy(), b.emit("error", F)) : (b.fd = H, b.emit("open", H));
    });
  }
  function R(b, F) {
    return new e.ReadStream(b, F);
  }
  function w(b, F) {
    return new e.WriteStream(b, F);
  }
  var C = e.open;
  e.open = V;
  function V(b, F, H, q) {
    return typeof H == "function" && (q = H, H = null), $(b, F, H, q);
    function $(x, A, P, D, I) {
      return C(x, A, P, function(L, j) {
        L && (L.code === "EMFILE" || L.code === "ENFILE") ? ps([$, [x, A, P, D], L, I || Date.now(), Date.now()]) : typeof D == "function" && D.apply(this, arguments);
      });
    }
  }
  return e;
}
function ps(e) {
  ji("ENQUEUE", e[0].name, e[1]), et[Dt].push(e), Ny();
}
var tl;
function ow() {
  for (var e = Date.now(), t = 0; t < et[Dt].length; ++t)
    et[Dt][t].length > 2 && (et[Dt][t][3] = e, et[Dt][t][4] = e);
  Ny();
}
function Ny() {
  if (clearTimeout(tl), tl = void 0, et[Dt].length !== 0) {
    var e = et[Dt].shift(), t = e[0], r = e[1], n = e[2], i = e[3], s = e[4];
    if (i === void 0)
      ji("RETRY", t.name, r), t.apply(null, r);
    else if (Date.now() - i >= 6e4) {
      ji("TIMEOUT", t.name, r);
      var o = r.pop();
      typeof o == "function" && o.call(null, n);
    } else {
      var a = Date.now() - s, c = Math.max(s - i, 1), u = Math.min(c * 1.2, 100);
      a >= u ? (ji("RETRY", t.name, r), t.apply(null, r.concat([i]))) : et[Dt].push(e);
    }
    tl === void 0 && (tl = setTimeout(Ny, 0));
  }
}
(function(e) {
  const t = nr.fromCallback, r = ir, n = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((i) => typeof r[i] == "function");
  Object.assign(e, r), n.forEach((i) => {
    e[i] = t(r[i]);
  }), e.exists = function(i, s) {
    return typeof s == "function" ? r.exists(i, s) : new Promise((o) => r.exists(i, o));
  }, e.read = function(i, s, o, a, c, u) {
    return typeof u == "function" ? r.read(i, s, o, a, c, u) : new Promise((l, f) => {
      r.read(i, s, o, a, c, (m, p, d) => {
        if (m) return f(m);
        l({ bytesRead: p, buffer: d });
      });
    });
  }, e.write = function(i, s, ...o) {
    return typeof o[o.length - 1] == "function" ? r.write(i, s, ...o) : new Promise((a, c) => {
      r.write(i, s, ...o, (u, l, f) => {
        if (u) return c(u);
        a({ bytesWritten: l, buffer: f });
      });
    });
  }, typeof r.writev == "function" && (e.writev = function(i, s, ...o) {
    return typeof o[o.length - 1] == "function" ? r.writev(i, s, ...o) : new Promise((a, c) => {
      r.writev(i, s, ...o, (u, l, f) => {
        if (u) return c(u);
        a({ bytesWritten: l, buffers: f });
      });
    });
  }), typeof r.realpath.native == "function" ? e.realpath.native = t(r.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(Zi);
var ky = {}, bT = {};
const wW = _e;
bT.checkPath = function(t) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(wW.parse(t).root, ""))) {
    const n = new Error(`Path contains invalid characters: ${t}`);
    throw n.code = "EINVAL", n;
  }
};
const ET = Zi, { checkPath: wT } = bT, ST = (e) => {
  const t = { mode: 511 };
  return typeof e == "number" ? e : { ...t, ...e }.mode;
};
ky.makeDir = async (e, t) => (wT(e), ET.mkdir(e, {
  mode: ST(t),
  recursive: !0
}));
ky.makeDirSync = (e, t) => (wT(e), ET.mkdirSync(e, {
  mode: ST(t),
  recursive: !0
}));
const SW = nr.fromPromise, { makeDir: xW, makeDirSync: Mp } = ky, Hp = SW(xW);
var cn = {
  mkdirs: Hp,
  mkdirsSync: Mp,
  // alias
  mkdirp: Hp,
  mkdirpSync: Mp,
  ensureDir: Hp,
  ensureDirSync: Mp
};
const RW = nr.fromPromise, xT = Zi;
function $W(e) {
  return xT.access(e).then(() => !0).catch(() => !1);
}
var Qi = {
  pathExists: RW($W),
  pathExistsSync: xT.existsSync
};
const js = ir;
function TW(e, t, r, n) {
  js.open(e, "r+", (i, s) => {
    if (i) return n(i);
    js.futimes(s, t, r, (o) => {
      js.close(s, (a) => {
        n && n(o || a);
      });
    });
  });
}
function OW(e, t, r) {
  const n = js.openSync(e, "r+");
  return js.futimesSync(n, t, r), js.closeSync(n);
}
var RT = {
  utimesMillis: TW,
  utimesMillisSync: OW
};
const Ks = Zi, xt = _e, PW = Sn;
function CW(e, t, r) {
  const n = r.dereference ? (i) => Ks.stat(i, { bigint: !0 }) : (i) => Ks.lstat(i, { bigint: !0 });
  return Promise.all([
    n(e),
    n(t).catch((i) => {
      if (i.code === "ENOENT") return null;
      throw i;
    })
  ]).then(([i, s]) => ({ srcStat: i, destStat: s }));
}
function AW(e, t, r) {
  let n;
  const i = r.dereference ? (o) => Ks.statSync(o, { bigint: !0 }) : (o) => Ks.lstatSync(o, { bigint: !0 }), s = i(e);
  try {
    n = i(t);
  } catch (o) {
    if (o.code === "ENOENT") return { srcStat: s, destStat: null };
    throw o;
  }
  return { srcStat: s, destStat: n };
}
function IW(e, t, r, n, i) {
  PW.callbackify(CW)(e, t, n, (s, o) => {
    if (s) return i(s);
    const { srcStat: a, destStat: c } = o;
    if (c) {
      if (ic(a, c)) {
        const u = xt.basename(e), l = xt.basename(t);
        return r === "move" && u !== l && u.toLowerCase() === l.toLowerCase() ? i(null, { srcStat: a, destStat: c, isChangingCase: !0 }) : i(new Error("Source and destination must not be the same."));
      }
      if (a.isDirectory() && !c.isDirectory())
        return i(new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`));
      if (!a.isDirectory() && c.isDirectory())
        return i(new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`));
    }
    return a.isDirectory() && Dy(e, t) ? i(new Error(vf(e, t, r))) : i(null, { srcStat: a, destStat: c });
  });
}
function NW(e, t, r, n) {
  const { srcStat: i, destStat: s } = AW(e, t, n);
  if (s) {
    if (ic(i, s)) {
      const o = xt.basename(e), a = xt.basename(t);
      if (r === "move" && o !== a && o.toLowerCase() === a.toLowerCase())
        return { srcStat: i, destStat: s, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !s.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
    if (!i.isDirectory() && s.isDirectory())
      throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
  }
  if (i.isDirectory() && Dy(e, t))
    throw new Error(vf(e, t, r));
  return { srcStat: i, destStat: s };
}
function $T(e, t, r, n, i) {
  const s = xt.resolve(xt.dirname(e)), o = xt.resolve(xt.dirname(r));
  if (o === s || o === xt.parse(o).root) return i();
  Ks.stat(o, { bigint: !0 }, (a, c) => a ? a.code === "ENOENT" ? i() : i(a) : ic(t, c) ? i(new Error(vf(e, r, n))) : $T(e, t, o, n, i));
}
function TT(e, t, r, n) {
  const i = xt.resolve(xt.dirname(e)), s = xt.resolve(xt.dirname(r));
  if (s === i || s === xt.parse(s).root) return;
  let o;
  try {
    o = Ks.statSync(s, { bigint: !0 });
  } catch (a) {
    if (a.code === "ENOENT") return;
    throw a;
  }
  if (ic(t, o))
    throw new Error(vf(e, r, n));
  return TT(e, t, s, n);
}
function ic(e, t) {
  return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
}
function Dy(e, t) {
  const r = xt.resolve(e).split(xt.sep).filter((i) => i), n = xt.resolve(t).split(xt.sep).filter((i) => i);
  return r.reduce((i, s, o) => i && n[o] === s, !0);
}
function vf(e, t, r) {
  return `Cannot ${r} '${e}' to a subdirectory of itself, '${t}'.`;
}
var fo = {
  checkPaths: IW,
  checkPathsSync: NW,
  checkParentPaths: $T,
  checkParentPathsSync: TT,
  isSrcSubdir: Dy,
  areIdentical: ic
};
const lr = ir, ga = _e, kW = cn.mkdirs, DW = Qi.pathExists, LW = RT.utimesMillis, ya = fo;
function FW(e, t, r, n) {
  typeof r == "function" && !n ? (n = r, r = {}) : typeof r == "function" && (r = { filter: r }), n = n || function() {
  }, r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  ), ya.checkPaths(e, t, "copy", r, (i, s) => {
    if (i) return n(i);
    const { srcStat: o, destStat: a } = s;
    ya.checkParentPaths(e, o, t, "copy", (c) => c ? n(c) : r.filter ? OT(aw, a, e, t, r, n) : aw(a, e, t, r, n));
  });
}
function aw(e, t, r, n, i) {
  const s = ga.dirname(r);
  DW(s, (o, a) => {
    if (o) return i(o);
    if (a) return iu(e, t, r, n, i);
    kW(s, (c) => c ? i(c) : iu(e, t, r, n, i));
  });
}
function OT(e, t, r, n, i, s) {
  Promise.resolve(i.filter(r, n)).then((o) => o ? e(t, r, n, i, s) : s(), (o) => s(o));
}
function jW(e, t, r, n, i) {
  return n.filter ? OT(iu, e, t, r, n, i) : iu(e, t, r, n, i);
}
function iu(e, t, r, n, i) {
  (n.dereference ? lr.stat : lr.lstat)(t, (o, a) => o ? i(o) : a.isDirectory() ? VW(a, e, t, r, n, i) : a.isFile() || a.isCharacterDevice() || a.isBlockDevice() ? UW(a, e, t, r, n, i) : a.isSymbolicLink() ? KW(e, t, r, n, i) : a.isSocket() ? i(new Error(`Cannot copy a socket file: ${t}`)) : a.isFIFO() ? i(new Error(`Cannot copy a FIFO pipe: ${t}`)) : i(new Error(`Unknown file: ${t}`)));
}
function UW(e, t, r, n, i, s) {
  return t ? MW(e, r, n, i, s) : PT(e, r, n, i, s);
}
function MW(e, t, r, n, i) {
  if (n.overwrite)
    lr.unlink(r, (s) => s ? i(s) : PT(e, t, r, n, i));
  else return n.errorOnExist ? i(new Error(`'${r}' already exists`)) : i();
}
function PT(e, t, r, n, i) {
  lr.copyFile(t, r, (s) => s ? i(s) : n.preserveTimestamps ? HW(e.mode, t, r, i) : _f(r, e.mode, i));
}
function HW(e, t, r, n) {
  return qW(e) ? BW(r, e, (i) => i ? n(i) : cw(e, t, r, n)) : cw(e, t, r, n);
}
function qW(e) {
  return (e & 128) === 0;
}
function BW(e, t, r) {
  return _f(e, t | 128, r);
}
function cw(e, t, r, n) {
  zW(t, r, (i) => i ? n(i) : _f(r, e, n));
}
function _f(e, t, r) {
  return lr.chmod(e, t, r);
}
function zW(e, t, r) {
  lr.stat(e, (n, i) => n ? r(n) : LW(t, i.atime, i.mtime, r));
}
function VW(e, t, r, n, i, s) {
  return t ? CT(r, n, i, s) : GW(e.mode, r, n, i, s);
}
function GW(e, t, r, n, i) {
  lr.mkdir(r, (s) => {
    if (s) return i(s);
    CT(t, r, n, (o) => o ? i(o) : _f(r, e, i));
  });
}
function CT(e, t, r, n) {
  lr.readdir(e, (i, s) => i ? n(i) : AT(s, e, t, r, n));
}
function AT(e, t, r, n, i) {
  const s = e.pop();
  return s ? WW(e, s, t, r, n, i) : i();
}
function WW(e, t, r, n, i, s) {
  const o = ga.join(r, t), a = ga.join(n, t);
  ya.checkPaths(o, a, "copy", i, (c, u) => {
    if (c) return s(c);
    const { destStat: l } = u;
    jW(l, o, a, i, (f) => f ? s(f) : AT(e, r, n, i, s));
  });
}
function KW(e, t, r, n, i) {
  lr.readlink(t, (s, o) => {
    if (s) return i(s);
    if (n.dereference && (o = ga.resolve(process.cwd(), o)), e)
      lr.readlink(r, (a, c) => a ? a.code === "EINVAL" || a.code === "UNKNOWN" ? lr.symlink(o, r, i) : i(a) : (n.dereference && (c = ga.resolve(process.cwd(), c)), ya.isSrcSubdir(o, c) ? i(new Error(`Cannot copy '${o}' to a subdirectory of itself, '${c}'.`)) : e.isDirectory() && ya.isSrcSubdir(c, o) ? i(new Error(`Cannot overwrite '${c}' with '${o}'.`)) : YW(o, r, i)));
    else
      return lr.symlink(o, r, i);
  });
}
function YW(e, t, r) {
  lr.unlink(t, (n) => n ? r(n) : lr.symlink(e, t, r));
}
var JW = FW;
const Wt = ir, va = _e, XW = cn.mkdirsSync, ZW = RT.utimesMillisSync, _a = fo;
function QW(e, t, r) {
  typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: n, destStat: i } = _a.checkPathsSync(e, t, "copy", r);
  return _a.checkParentPathsSync(e, n, t, "copy"), e7(i, e, t, r);
}
function e7(e, t, r, n) {
  if (n.filter && !n.filter(t, r)) return;
  const i = va.dirname(r);
  return Wt.existsSync(i) || XW(i), IT(e, t, r, n);
}
function t7(e, t, r, n) {
  if (!(n.filter && !n.filter(t, r)))
    return IT(e, t, r, n);
}
function IT(e, t, r, n) {
  const s = (n.dereference ? Wt.statSync : Wt.lstatSync)(t);
  if (s.isDirectory()) return c7(s, e, t, r, n);
  if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice()) return r7(s, e, t, r, n);
  if (s.isSymbolicLink()) return f7(e, t, r, n);
  throw s.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : s.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(`Unknown file: ${t}`);
}
function r7(e, t, r, n, i) {
  return t ? n7(e, r, n, i) : NT(e, r, n, i);
}
function n7(e, t, r, n) {
  if (n.overwrite)
    return Wt.unlinkSync(r), NT(e, t, r, n);
  if (n.errorOnExist)
    throw new Error(`'${r}' already exists`);
}
function NT(e, t, r, n) {
  return Wt.copyFileSync(t, r), n.preserveTimestamps && i7(e.mode, t, r), Ly(r, e.mode);
}
function i7(e, t, r) {
  return s7(e) && o7(r, e), a7(t, r);
}
function s7(e) {
  return (e & 128) === 0;
}
function o7(e, t) {
  return Ly(e, t | 128);
}
function Ly(e, t) {
  return Wt.chmodSync(e, t);
}
function a7(e, t) {
  const r = Wt.statSync(e);
  return ZW(t, r.atime, r.mtime);
}
function c7(e, t, r, n, i) {
  return t ? kT(r, n, i) : l7(e.mode, r, n, i);
}
function l7(e, t, r, n) {
  return Wt.mkdirSync(r), kT(t, r, n), Ly(r, e);
}
function kT(e, t, r) {
  Wt.readdirSync(e).forEach((n) => u7(n, e, t, r));
}
function u7(e, t, r, n) {
  const i = va.join(t, e), s = va.join(r, e), { destStat: o } = _a.checkPathsSync(i, s, "copy", n);
  return t7(o, i, s, n);
}
function f7(e, t, r, n) {
  let i = Wt.readlinkSync(t);
  if (n.dereference && (i = va.resolve(process.cwd(), i)), e) {
    let s;
    try {
      s = Wt.readlinkSync(r);
    } catch (o) {
      if (o.code === "EINVAL" || o.code === "UNKNOWN") return Wt.symlinkSync(i, r);
      throw o;
    }
    if (n.dereference && (s = va.resolve(process.cwd(), s)), _a.isSrcSubdir(i, s))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${s}'.`);
    if (Wt.statSync(r).isDirectory() && _a.isSrcSubdir(s, i))
      throw new Error(`Cannot overwrite '${s}' with '${i}'.`);
    return d7(i, r);
  } else
    return Wt.symlinkSync(i, r);
}
function d7(e, t) {
  return Wt.unlinkSync(t), Wt.symlinkSync(e, t);
}
var p7 = QW;
const h7 = nr.fromCallback;
var Fy = {
  copy: h7(JW),
  copySync: p7
};
const lw = ir, DT = _e, qe = Da, ba = process.platform === "win32";
function LT(e) {
  [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ].forEach((r) => {
    e[r] = e[r] || lw[r], r = r + "Sync", e[r] = e[r] || lw[r];
  }), e.maxBusyTries = e.maxBusyTries || 3;
}
function jy(e, t, r) {
  let n = 0;
  typeof t == "function" && (r = t, t = {}), qe(e, "rimraf: missing path"), qe.strictEqual(typeof e, "string", "rimraf: path should be a string"), qe.strictEqual(typeof r, "function", "rimraf: callback function required"), qe(t, "rimraf: invalid options argument provided"), qe.strictEqual(typeof t, "object", "rimraf: options should be object"), LT(t), uw(e, t, function i(s) {
    if (s) {
      if ((s.code === "EBUSY" || s.code === "ENOTEMPTY" || s.code === "EPERM") && n < t.maxBusyTries) {
        n++;
        const o = n * 100;
        return setTimeout(() => uw(e, t, i), o);
      }
      s.code === "ENOENT" && (s = null);
    }
    r(s);
  });
}
function uw(e, t, r) {
  qe(e), qe(t), qe(typeof r == "function"), t.lstat(e, (n, i) => {
    if (n && n.code === "ENOENT")
      return r(null);
    if (n && n.code === "EPERM" && ba)
      return fw(e, t, n, r);
    if (i && i.isDirectory())
      return Al(e, t, n, r);
    t.unlink(e, (s) => {
      if (s) {
        if (s.code === "ENOENT")
          return r(null);
        if (s.code === "EPERM")
          return ba ? fw(e, t, s, r) : Al(e, t, s, r);
        if (s.code === "EISDIR")
          return Al(e, t, s, r);
      }
      return r(s);
    });
  });
}
function fw(e, t, r, n) {
  qe(e), qe(t), qe(typeof n == "function"), t.chmod(e, 438, (i) => {
    i ? n(i.code === "ENOENT" ? null : r) : t.stat(e, (s, o) => {
      s ? n(s.code === "ENOENT" ? null : r) : o.isDirectory() ? Al(e, t, r, n) : t.unlink(e, n);
    });
  });
}
function dw(e, t, r) {
  let n;
  qe(e), qe(t);
  try {
    t.chmodSync(e, 438);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  try {
    n = t.statSync(e);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw r;
  }
  n.isDirectory() ? Il(e, t, r) : t.unlinkSync(e);
}
function Al(e, t, r, n) {
  qe(e), qe(t), qe(typeof n == "function"), t.rmdir(e, (i) => {
    i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") ? m7(e, t, n) : i && i.code === "ENOTDIR" ? n(r) : n(i);
  });
}
function m7(e, t, r) {
  qe(e), qe(t), qe(typeof r == "function"), t.readdir(e, (n, i) => {
    if (n) return r(n);
    let s = i.length, o;
    if (s === 0) return t.rmdir(e, r);
    i.forEach((a) => {
      jy(DT.join(e, a), t, (c) => {
        if (!o) {
          if (c) return r(o = c);
          --s === 0 && t.rmdir(e, r);
        }
      });
    });
  });
}
function FT(e, t) {
  let r;
  t = t || {}, LT(t), qe(e, "rimraf: missing path"), qe.strictEqual(typeof e, "string", "rimraf: path should be a string"), qe(t, "rimraf: missing options"), qe.strictEqual(typeof t, "object", "rimraf: options should be object");
  try {
    r = t.lstatSync(e);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    n.code === "EPERM" && ba && dw(e, t, n);
  }
  try {
    r && r.isDirectory() ? Il(e, t, null) : t.unlinkSync(e);
  } catch (n) {
    if (n.code === "ENOENT")
      return;
    if (n.code === "EPERM")
      return ba ? dw(e, t, n) : Il(e, t, n);
    if (n.code !== "EISDIR")
      throw n;
    Il(e, t, n);
  }
}
function Il(e, t, r) {
  qe(e), qe(t);
  try {
    t.rmdirSync(e);
  } catch (n) {
    if (n.code === "ENOTDIR")
      throw r;
    if (n.code === "ENOTEMPTY" || n.code === "EEXIST" || n.code === "EPERM")
      g7(e, t);
    else if (n.code !== "ENOENT")
      throw n;
  }
}
function g7(e, t) {
  if (qe(e), qe(t), t.readdirSync(e).forEach((r) => FT(DT.join(e, r), t)), ba) {
    const r = Date.now();
    do
      try {
        return t.rmdirSync(e, t);
      } catch {
      }
    while (Date.now() - r < 500);
  } else
    return t.rmdirSync(e, t);
}
var y7 = jy;
jy.sync = FT;
const su = ir, v7 = nr.fromCallback, jT = y7;
function _7(e, t) {
  if (su.rm) return su.rm(e, { recursive: !0, force: !0 }, t);
  jT(e, t);
}
function b7(e) {
  if (su.rmSync) return su.rmSync(e, { recursive: !0, force: !0 });
  jT.sync(e);
}
var bf = {
  remove: v7(_7),
  removeSync: b7
};
const E7 = nr.fromPromise, UT = Zi, MT = _e, HT = cn, qT = bf, pw = E7(async function(t) {
  let r;
  try {
    r = await UT.readdir(t);
  } catch {
    return HT.mkdirs(t);
  }
  return Promise.all(r.map((n) => qT.remove(MT.join(t, n))));
});
function hw(e) {
  let t;
  try {
    t = UT.readdirSync(e);
  } catch {
    return HT.mkdirsSync(e);
  }
  t.forEach((r) => {
    r = MT.join(e, r), qT.removeSync(r);
  });
}
var w7 = {
  emptyDirSync: hw,
  emptydirSync: hw,
  emptyDir: pw,
  emptydir: pw
};
const S7 = nr.fromCallback, BT = _e, Wn = ir, zT = cn;
function x7(e, t) {
  function r() {
    Wn.writeFile(e, "", (n) => {
      if (n) return t(n);
      t();
    });
  }
  Wn.stat(e, (n, i) => {
    if (!n && i.isFile()) return t();
    const s = BT.dirname(e);
    Wn.stat(s, (o, a) => {
      if (o)
        return o.code === "ENOENT" ? zT.mkdirs(s, (c) => {
          if (c) return t(c);
          r();
        }) : t(o);
      a.isDirectory() ? r() : Wn.readdir(s, (c) => {
        if (c) return t(c);
      });
    });
  });
}
function R7(e) {
  let t;
  try {
    t = Wn.statSync(e);
  } catch {
  }
  if (t && t.isFile()) return;
  const r = BT.dirname(e);
  try {
    Wn.statSync(r).isDirectory() || Wn.readdirSync(r);
  } catch (n) {
    if (n && n.code === "ENOENT") zT.mkdirsSync(r);
    else throw n;
  }
  Wn.writeFileSync(e, "");
}
var $7 = {
  createFile: S7(x7),
  createFileSync: R7
};
const T7 = nr.fromCallback, VT = _e, qn = ir, GT = cn, O7 = Qi.pathExists, { areIdentical: WT } = fo;
function P7(e, t, r) {
  function n(i, s) {
    qn.link(i, s, (o) => {
      if (o) return r(o);
      r(null);
    });
  }
  qn.lstat(t, (i, s) => {
    qn.lstat(e, (o, a) => {
      if (o)
        return o.message = o.message.replace("lstat", "ensureLink"), r(o);
      if (s && WT(a, s)) return r(null);
      const c = VT.dirname(t);
      O7(c, (u, l) => {
        if (u) return r(u);
        if (l) return n(e, t);
        GT.mkdirs(c, (f) => {
          if (f) return r(f);
          n(e, t);
        });
      });
    });
  });
}
function C7(e, t) {
  let r;
  try {
    r = qn.lstatSync(t);
  } catch {
  }
  try {
    const s = qn.lstatSync(e);
    if (r && WT(s, r)) return;
  } catch (s) {
    throw s.message = s.message.replace("lstat", "ensureLink"), s;
  }
  const n = VT.dirname(t);
  return qn.existsSync(n) || GT.mkdirsSync(n), qn.linkSync(e, t);
}
var A7 = {
  createLink: T7(P7),
  createLinkSync: C7
};
const Kn = _e, ea = ir, I7 = Qi.pathExists;
function N7(e, t, r) {
  if (Kn.isAbsolute(e))
    return ea.lstat(e, (n) => n ? (n.message = n.message.replace("lstat", "ensureSymlink"), r(n)) : r(null, {
      toCwd: e,
      toDst: e
    }));
  {
    const n = Kn.dirname(t), i = Kn.join(n, e);
    return I7(i, (s, o) => s ? r(s) : o ? r(null, {
      toCwd: i,
      toDst: e
    }) : ea.lstat(e, (a) => a ? (a.message = a.message.replace("lstat", "ensureSymlink"), r(a)) : r(null, {
      toCwd: e,
      toDst: Kn.relative(n, e)
    })));
  }
}
function k7(e, t) {
  let r;
  if (Kn.isAbsolute(e)) {
    if (r = ea.existsSync(e), !r) throw new Error("absolute srcpath does not exist");
    return {
      toCwd: e,
      toDst: e
    };
  } else {
    const n = Kn.dirname(t), i = Kn.join(n, e);
    if (r = ea.existsSync(i), r)
      return {
        toCwd: i,
        toDst: e
      };
    if (r = ea.existsSync(e), !r) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: Kn.relative(n, e)
    };
  }
}
var D7 = {
  symlinkPaths: N7,
  symlinkPathsSync: k7
};
const KT = ir;
function L7(e, t, r) {
  if (r = typeof t == "function" ? t : r, t = typeof t == "function" ? !1 : t, t) return r(null, t);
  KT.lstat(e, (n, i) => {
    if (n) return r(null, "file");
    t = i && i.isDirectory() ? "dir" : "file", r(null, t);
  });
}
function F7(e, t) {
  let r;
  if (t) return t;
  try {
    r = KT.lstatSync(e);
  } catch {
    return "file";
  }
  return r && r.isDirectory() ? "dir" : "file";
}
var j7 = {
  symlinkType: L7,
  symlinkTypeSync: F7
};
const U7 = nr.fromCallback, YT = _e, Ur = Zi, JT = cn, M7 = JT.mkdirs, H7 = JT.mkdirsSync, XT = D7, q7 = XT.symlinkPaths, B7 = XT.symlinkPathsSync, ZT = j7, z7 = ZT.symlinkType, V7 = ZT.symlinkTypeSync, G7 = Qi.pathExists, { areIdentical: QT } = fo;
function W7(e, t, r, n) {
  n = typeof r == "function" ? r : n, r = typeof r == "function" ? !1 : r, Ur.lstat(t, (i, s) => {
    !i && s.isSymbolicLink() ? Promise.all([
      Ur.stat(e),
      Ur.stat(t)
    ]).then(([o, a]) => {
      if (QT(o, a)) return n(null);
      mw(e, t, r, n);
    }) : mw(e, t, r, n);
  });
}
function mw(e, t, r, n) {
  q7(e, t, (i, s) => {
    if (i) return n(i);
    e = s.toDst, z7(s.toCwd, r, (o, a) => {
      if (o) return n(o);
      const c = YT.dirname(t);
      G7(c, (u, l) => {
        if (u) return n(u);
        if (l) return Ur.symlink(e, t, a, n);
        M7(c, (f) => {
          if (f) return n(f);
          Ur.symlink(e, t, a, n);
        });
      });
    });
  });
}
function K7(e, t, r) {
  let n;
  try {
    n = Ur.lstatSync(t);
  } catch {
  }
  if (n && n.isSymbolicLink()) {
    const a = Ur.statSync(e), c = Ur.statSync(t);
    if (QT(a, c)) return;
  }
  const i = B7(e, t);
  e = i.toDst, r = V7(i.toCwd, r);
  const s = YT.dirname(t);
  return Ur.existsSync(s) || H7(s), Ur.symlinkSync(e, t, r);
}
var Y7 = {
  createSymlink: U7(W7),
  createSymlinkSync: K7
};
const { createFile: gw, createFileSync: yw } = $7, { createLink: vw, createLinkSync: _w } = A7, { createSymlink: bw, createSymlinkSync: Ew } = Y7;
var J7 = {
  // file
  createFile: gw,
  createFileSync: yw,
  ensureFile: gw,
  ensureFileSync: yw,
  // link
  createLink: vw,
  createLinkSync: _w,
  ensureLink: vw,
  ensureLinkSync: _w,
  // symlink
  createSymlink: bw,
  createSymlinkSync: Ew,
  ensureSymlink: bw,
  ensureSymlinkSync: Ew
};
function X7(e, { EOL: t = `
`, finalEOL: r = !0, replacer: n = null, spaces: i } = {}) {
  const s = r ? t : "";
  return JSON.stringify(e, n, i).replace(/\n/g, t) + s;
}
function Z7(e) {
  return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
}
var Uy = { stringify: X7, stripBom: Z7 };
let Ys;
try {
  Ys = ir;
} catch {
  Ys = Ue;
}
const Ef = nr, { stringify: eO, stripBom: tO } = Uy;
async function Q7(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const r = t.fs || Ys, n = "throws" in t ? t.throws : !0;
  let i = await Ef.fromCallback(r.readFile)(e, t);
  i = tO(i);
  let s;
  try {
    s = JSON.parse(i, t ? t.reviver : null);
  } catch (o) {
    if (n)
      throw o.message = `${e}: ${o.message}`, o;
    return null;
  }
  return s;
}
const eK = Ef.fromPromise(Q7);
function tK(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const r = t.fs || Ys, n = "throws" in t ? t.throws : !0;
  try {
    let i = r.readFileSync(e, t);
    return i = tO(i), JSON.parse(i, t.reviver);
  } catch (i) {
    if (n)
      throw i.message = `${e}: ${i.message}`, i;
    return null;
  }
}
async function rK(e, t, r = {}) {
  const n = r.fs || Ys, i = eO(t, r);
  await Ef.fromCallback(n.writeFile)(e, i, r);
}
const nK = Ef.fromPromise(rK);
function iK(e, t, r = {}) {
  const n = r.fs || Ys, i = eO(t, r);
  return n.writeFileSync(e, i, r);
}
const sK = {
  readFile: eK,
  readFileSync: tK,
  writeFile: nK,
  writeFileSync: iK
};
var oK = sK;
const rl = oK;
var aK = {
  // jsonfile exports
  readJson: rl.readFile,
  readJsonSync: rl.readFileSync,
  writeJson: rl.writeFile,
  writeJsonSync: rl.writeFileSync
};
const cK = nr.fromCallback, ta = ir, rO = _e, nO = cn, lK = Qi.pathExists;
function uK(e, t, r, n) {
  typeof r == "function" && (n = r, r = "utf8");
  const i = rO.dirname(e);
  lK(i, (s, o) => {
    if (s) return n(s);
    if (o) return ta.writeFile(e, t, r, n);
    nO.mkdirs(i, (a) => {
      if (a) return n(a);
      ta.writeFile(e, t, r, n);
    });
  });
}
function fK(e, ...t) {
  const r = rO.dirname(e);
  if (ta.existsSync(r))
    return ta.writeFileSync(e, ...t);
  nO.mkdirsSync(r), ta.writeFileSync(e, ...t);
}
var My = {
  outputFile: cK(uK),
  outputFileSync: fK
};
const { stringify: dK } = Uy, { outputFile: pK } = My;
async function hK(e, t, r = {}) {
  const n = dK(t, r);
  await pK(e, n, r);
}
var mK = hK;
const { stringify: gK } = Uy, { outputFileSync: yK } = My;
function vK(e, t, r) {
  const n = gK(t, r);
  yK(e, n, r);
}
var _K = vK;
const bK = nr.fromPromise, tr = aK;
tr.outputJson = bK(mK);
tr.outputJsonSync = _K;
tr.outputJSON = tr.outputJson;
tr.outputJSONSync = tr.outputJsonSync;
tr.writeJSON = tr.writeJson;
tr.writeJSONSync = tr.writeJsonSync;
tr.readJSON = tr.readJson;
tr.readJSONSync = tr.readJsonSync;
var EK = tr;
const wK = ir, Gh = _e, SK = Fy.copy, iO = bf.remove, xK = cn.mkdirp, RK = Qi.pathExists, ww = fo;
function $K(e, t, r, n) {
  typeof r == "function" && (n = r, r = {}), r = r || {};
  const i = r.overwrite || r.clobber || !1;
  ww.checkPaths(e, t, "move", r, (s, o) => {
    if (s) return n(s);
    const { srcStat: a, isChangingCase: c = !1 } = o;
    ww.checkParentPaths(e, a, t, "move", (u) => {
      if (u) return n(u);
      if (TK(t)) return Sw(e, t, i, c, n);
      xK(Gh.dirname(t), (l) => l ? n(l) : Sw(e, t, i, c, n));
    });
  });
}
function TK(e) {
  const t = Gh.dirname(e);
  return Gh.parse(t).root === t;
}
function Sw(e, t, r, n, i) {
  if (n) return qp(e, t, r, i);
  if (r)
    return iO(t, (s) => s ? i(s) : qp(e, t, r, i));
  RK(t, (s, o) => s ? i(s) : o ? i(new Error("dest already exists.")) : qp(e, t, r, i));
}
function qp(e, t, r, n) {
  wK.rename(e, t, (i) => i ? i.code !== "EXDEV" ? n(i) : OK(e, t, r, n) : n());
}
function OK(e, t, r, n) {
  SK(e, t, {
    overwrite: r,
    errorOnExist: !0
  }, (s) => s ? n(s) : iO(e, n));
}
var PK = $K;
const sO = ir, Wh = _e, CK = Fy.copySync, oO = bf.removeSync, AK = cn.mkdirpSync, xw = fo;
function IK(e, t, r) {
  r = r || {};
  const n = r.overwrite || r.clobber || !1, { srcStat: i, isChangingCase: s = !1 } = xw.checkPathsSync(e, t, "move", r);
  return xw.checkParentPathsSync(e, i, t, "move"), NK(t) || AK(Wh.dirname(t)), kK(e, t, n, s);
}
function NK(e) {
  const t = Wh.dirname(e);
  return Wh.parse(t).root === t;
}
function kK(e, t, r, n) {
  if (n) return Bp(e, t, r);
  if (r)
    return oO(t), Bp(e, t, r);
  if (sO.existsSync(t)) throw new Error("dest already exists.");
  return Bp(e, t, r);
}
function Bp(e, t, r) {
  try {
    sO.renameSync(e, t);
  } catch (n) {
    if (n.code !== "EXDEV") throw n;
    return DK(e, t, r);
  }
}
function DK(e, t, r) {
  return CK(e, t, {
    overwrite: r,
    errorOnExist: !0
  }), oO(e);
}
var LK = IK;
const FK = nr.fromCallback;
var jK = {
  move: FK(PK),
  moveSync: LK
}, si = {
  // Export promiseified graceful-fs:
  ...Zi,
  // Export extra methods:
  ...Fy,
  ...w7,
  ...J7,
  ...EK,
  ...cn,
  ...jK,
  ...My,
  ...Qi,
  ...bf
}, Rn = {}, ei = {}, Rt = {}, ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.CancellationError = ti.CancellationToken = void 0;
const UK = yu;
class MK extends UK.EventEmitter {
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(t) {
    this.removeParentCancelHandler(), this._parent = t, this.parentCancelHandler = () => this.cancel(), this._parent.onCancel(this.parentCancelHandler);
  }
  // babel cannot compile ... correctly for super calls
  constructor(t) {
    super(), this.parentCancelHandler = null, this._parent = null, this._cancelled = !1, t != null && (this.parent = t);
  }
  cancel() {
    this._cancelled = !0, this.emit("cancel");
  }
  onCancel(t) {
    this.cancelled ? t() : this.once("cancel", t);
  }
  createPromise(t) {
    if (this.cancelled)
      return Promise.reject(new Kh());
    const r = () => {
      if (n != null)
        try {
          this.removeListener("cancel", n), n = null;
        } catch {
        }
    };
    let n = null;
    return new Promise((i, s) => {
      let o = null;
      if (n = () => {
        try {
          o != null && (o(), o = null);
        } finally {
          s(new Kh());
        }
      }, this.cancelled) {
        n();
        return;
      }
      this.onCancel(n), t(i, s, (a) => {
        o = a;
      });
    }).then((i) => (r(), i)).catch((i) => {
      throw r(), i;
    });
  }
  removeParentCancelHandler() {
    const t = this._parent;
    t != null && this.parentCancelHandler != null && (t.removeListener("cancel", this.parentCancelHandler), this.parentCancelHandler = null);
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners(), this._parent = null;
    }
  }
}
ti.CancellationToken = MK;
class Kh extends Error {
  constructor() {
    super("cancelled");
  }
}
ti.CancellationError = Kh;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.newError = HK;
function HK(e, t) {
  const r = new Error(e);
  return r.code = t, r;
}
var er = {}, sc = {};
Object.defineProperty(sc, "__esModule", { value: !0 });
sc.ProgressCallbackTransform = void 0;
const qK = It;
class BK extends qK.Transform {
  constructor(t, r, n) {
    super(), this.total = t, this.cancellationToken = r, this.onProgress = n, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.nextUpdate = this.start + 1e3;
  }
  _transform(t, r, n) {
    if (this.cancellationToken.cancelled) {
      n(new Error("cancelled"), null);
      return;
    }
    this.transferred += t.length, this.delta += t.length;
    const i = Date.now();
    i >= this.nextUpdate && this.transferred !== this.total && (this.nextUpdate = i + 1e3, this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.total * 100,
      bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3))
    }), this.delta = 0), n(null, t);
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    }), this.delta = 0, t(null);
  }
}
sc.ProgressCallbackTransform = BK;
Object.defineProperty(er, "__esModule", { value: !0 });
er.DigestTransform = er.HttpExecutor = er.HttpError = void 0;
er.createHttpError = Yh;
er.parseJson = XK;
er.configureRequestOptionsFromUrl = cO;
er.configureRequestUrl = qy;
er.safeGetHeader = Us;
er.configureRequestOptions = au;
er.safeStringifyJson = cu;
const zK = Ki, VK = Z1, GK = Ue, WK = It, aO = qr, KK = ti, Rw = po, YK = sc, Uo = (0, VK.default)("electron-builder");
function Yh(e, t = null) {
  return new Hy(e.statusCode || -1, `${e.statusCode} ${e.statusMessage}` + (t == null ? "" : `
` + JSON.stringify(t, null, "  ")) + `
Headers: ` + cu(e.headers), t);
}
const JK = /* @__PURE__ */ new Map([
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
class Hy extends Error {
  constructor(t, r = `HTTP error: ${JK.get(t) || t}`, n = null) {
    super(r), this.statusCode = t, this.description = n, this.name = "HttpError", this.code = `HTTP_ERROR_${t}`;
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
er.HttpError = Hy;
function XK(e) {
  return e.then((t) => t == null || t.length === 0 ? null : JSON.parse(t));
}
class ou {
  constructor() {
    this.maxRedirects = 10;
  }
  request(t, r = new KK.CancellationToken(), n) {
    au(t);
    const i = n == null ? void 0 : JSON.stringify(n), s = i ? Buffer.from(i) : void 0;
    if (s != null) {
      Uo(i);
      const { headers: o, ...a } = t;
      t = {
        method: "post",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": s.length,
          ...o
        },
        ...a
      };
    }
    return this.doApiRequest(t, r, (o) => o.end(s));
  }
  doApiRequest(t, r, n, i = 0) {
    return Uo.enabled && Uo(`Request: ${cu(t)}`), r.createPromise((s, o, a) => {
      const c = this.createRequest(t, (u) => {
        try {
          this.handleResponse(u, t, r, s, o, i, n);
        } catch (l) {
          o(l);
        }
      });
      this.addErrorAndTimeoutHandlers(c, o, t.timeout), this.addRedirectHandlers(c, t, o, i, (u) => {
        this.doApiRequest(u, r, n, i).then(s).catch(o);
      }), n(c, o), a(() => c.abort());
    });
  }
  // noinspection JSUnusedLocalSymbols
  // eslint-disable-next-line
  addRedirectHandlers(t, r, n, i, s) {
  }
  addErrorAndTimeoutHandlers(t, r, n = 60 * 1e3) {
    this.addTimeOutHandler(t, r, n), t.on("error", r), t.on("aborted", () => {
      r(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(t, r, n, i, s, o, a) {
    var c;
    if (Uo.enabled && Uo(`Response: ${t.statusCode} ${t.statusMessage}, request options: ${cu(r)}`), t.statusCode === 404) {
      s(Yh(t, `method: ${r.method || "GET"} url: ${r.protocol || "https:"}//${r.hostname}${r.port ? `:${r.port}` : ""}${r.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (t.statusCode === 204) {
      i();
      return;
    }
    const u = (c = t.statusCode) !== null && c !== void 0 ? c : 0, l = u >= 300 && u < 400, f = Us(t, "location");
    if (l && f != null) {
      if (o > this.maxRedirects) {
        s(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(ou.prepareRedirectUrlOptions(f, r), n, a, o).then(i).catch(s);
      return;
    }
    t.setEncoding("utf8");
    let m = "";
    t.on("error", s), t.on("data", (p) => m += p), t.on("end", () => {
      try {
        if (t.statusCode != null && t.statusCode >= 400) {
          const p = Us(t, "content-type"), d = p != null && (Array.isArray(p) ? p.find((h) => h.includes("json")) != null : p.includes("json"));
          s(Yh(t, `method: ${r.method || "GET"} url: ${r.protocol || "https:"}//${r.hostname}${r.port ? `:${r.port}` : ""}${r.path}

          Data:
          ${d ? JSON.stringify(JSON.parse(m)) : m}
          `));
        } else
          i(m.length === 0 ? null : m);
      } catch (p) {
        s(p);
      }
    });
  }
  async downloadToBuffer(t, r) {
    return await r.cancellationToken.createPromise((n, i, s) => {
      const o = [], a = {
        headers: r.headers || void 0,
        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
        redirect: "manual"
      };
      qy(t, a), au(a), this.doDownload(a, {
        destination: null,
        options: r,
        onCancel: s,
        callback: (c) => {
          c == null ? n(Buffer.concat(o)) : i(c);
        },
        responseHandler: (c, u) => {
          let l = 0;
          c.on("data", (f) => {
            if (l += f.length, l > 524288e3) {
              u(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            o.push(f);
          }), c.on("end", () => {
            u(null);
          });
        }
      }, 0);
    });
  }
  doDownload(t, r, n) {
    const i = this.createRequest(t, (s) => {
      if (s.statusCode >= 400) {
        r.callback(new Error(`Cannot download "${t.protocol || "https:"}//${t.hostname}${t.path}", status ${s.statusCode}: ${s.statusMessage}`));
        return;
      }
      s.on("error", r.callback);
      const o = Us(s, "location");
      if (o != null) {
        n < this.maxRedirects ? this.doDownload(ou.prepareRedirectUrlOptions(o, t), r, n++) : r.callback(this.createMaxRedirectError());
        return;
      }
      r.responseHandler == null ? QK(r, s) : r.responseHandler(s, r.callback);
    });
    this.addErrorAndTimeoutHandlers(i, r.callback, t.timeout), this.addRedirectHandlers(i, t, r.callback, n, (s) => {
      this.doDownload(s, r, n++);
    }), i.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(t, r, n) {
    t.on("socket", (i) => {
      i.setTimeout(n, () => {
        t.abort(), r(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(t, r) {
    const n = cO(t, { ...r }), i = n.headers;
    if (i != null && i.authorization) {
      const s = new aO.URL(t);
      (s.hostname.endsWith(".amazonaws.com") || s.searchParams.has("X-Amz-Credential")) && delete i.authorization;
    }
    return n;
  }
  static retryOnServerError(t, r = 3) {
    for (let n = 0; ; n++)
      try {
        return t();
      } catch (i) {
        if (n < r && (i instanceof Hy && i.isServerError() || i.code === "EPIPE"))
          continue;
        throw i;
      }
  }
}
er.HttpExecutor = ou;
function cO(e, t) {
  const r = au(t);
  return qy(new aO.URL(e), r), r;
}
function qy(e, t) {
  t.protocol = e.protocol, t.hostname = e.hostname, e.port ? t.port = e.port : t.port && delete t.port, t.path = e.pathname + e.search;
}
class Jh extends WK.Transform {
  // noinspection JSUnusedGlobalSymbols
  get actual() {
    return this._actual;
  }
  constructor(t, r = "sha512", n = "base64") {
    super(), this.expected = t, this.algorithm = r, this.encoding = n, this._actual = null, this.isValidateOnEnd = !0, this.digester = (0, zK.createHash)(r);
  }
  // noinspection JSUnusedGlobalSymbols
  _transform(t, r, n) {
    this.digester.update(t), n(null, t);
  }
  // noinspection JSUnusedGlobalSymbols
  _flush(t) {
    if (this._actual = this.digester.digest(this.encoding), this.isValidateOnEnd)
      try {
        this.validate();
      } catch (r) {
        t(r);
        return;
      }
    t(null);
  }
  validate() {
    if (this._actual == null)
      throw (0, Rw.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    if (this._actual !== this.expected)
      throw (0, Rw.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    return null;
  }
}
er.DigestTransform = Jh;
function ZK(e, t, r) {
  return e != null && t != null && e !== t ? (r(new Error(`checksum mismatch: expected ${t} but got ${e} (X-Checksum-Sha2 header)`)), !1) : !0;
}
function Us(e, t) {
  const r = e.headers[t];
  return r == null ? null : Array.isArray(r) ? r.length === 0 ? null : r[r.length - 1] : r;
}
function QK(e, t) {
  if (!ZK(Us(t, "X-Checksum-Sha2"), e.options.sha2, e.callback))
    return;
  const r = [];
  if (e.options.onProgress != null) {
    const o = Us(t, "content-length");
    o != null && r.push(new YK.ProgressCallbackTransform(parseInt(o, 10), e.options.cancellationToken, e.options.onProgress));
  }
  const n = e.options.sha512;
  n != null ? r.push(new Jh(n, "sha512", n.length === 128 && !n.includes("+") && !n.includes("Z") && !n.includes("=") ? "hex" : "base64")) : e.options.sha2 != null && r.push(new Jh(e.options.sha2, "sha256", "hex"));
  const i = (0, GK.createWriteStream)(e.destination);
  r.push(i);
  let s = t;
  for (const o of r)
    o.on("error", (a) => {
      i.close(), e.options.cancellationToken.cancelled || e.callback(a);
    }), s = s.pipe(o);
  i.on("finish", () => {
    i.close(e.callback);
  });
}
function au(e, t, r) {
  r != null && (e.method = r), e.headers = { ...e.headers };
  const n = e.headers;
  return t != null && (n.authorization = t.startsWith("Basic") || t.startsWith("Bearer") ? t : `token ${t}`), n["User-Agent"] == null && (n["User-Agent"] = "electron-builder"), (r == null || r === "GET" || n["Cache-Control"] == null) && (n["Cache-Control"] = "no-cache"), e.protocol == null && process.versions.electron != null && (e.protocol = "https:"), e;
}
function cu(e, t) {
  return JSON.stringify(e, (r, n) => r.endsWith("Authorization") || r.endsWith("authorization") || r.endsWith("Password") || r.endsWith("PASSWORD") || r.endsWith("Token") || r.includes("password") || r.includes("token") || t != null && t.has(r) ? "<stripped sensitive data>" : n, 2);
}
var wf = {};
Object.defineProperty(wf, "__esModule", { value: !0 });
wf.MemoLazy = void 0;
class eY {
  constructor(t, r) {
    this.selector = t, this.creator = r, this.selected = void 0, this._value = void 0;
  }
  get hasValue() {
    return this._value !== void 0;
  }
  get value() {
    const t = this.selector();
    if (this._value !== void 0 && lO(this.selected, t))
      return this._value;
    this.selected = t;
    const r = this.creator(t);
    return this.value = r, r;
  }
  set value(t) {
    this._value = t;
  }
}
wf.MemoLazy = eY;
function lO(e, t) {
  if (typeof e == "object" && e !== null && (typeof t == "object" && t !== null)) {
    const i = Object.keys(e), s = Object.keys(t);
    return i.length === s.length && i.every((o) => lO(e[o], t[o]));
  }
  return e === t;
}
var Sf = {};
Object.defineProperty(Sf, "__esModule", { value: !0 });
Sf.githubUrl = tY;
Sf.getS3LikeProviderBaseUrl = rY;
function tY(e, t = "github.com") {
  return `${e.protocol || "https"}://${e.host || t}`;
}
function rY(e) {
  const t = e.provider;
  if (t === "s3")
    return nY(e);
  if (t === "spaces")
    return iY(e);
  throw new Error(`Not supported provider: ${t}`);
}
function nY(e) {
  let t;
  if (e.accelerate == !0)
    t = `https://${e.bucket}.s3-accelerate.amazonaws.com`;
  else if (e.endpoint != null)
    t = `${e.endpoint}/${e.bucket}`;
  else if (e.bucket.includes(".")) {
    if (e.region == null)
      throw new Error(`Bucket name "${e.bucket}" includes a dot, but S3 region is missing`);
    e.region === "us-east-1" ? t = `https://s3.amazonaws.com/${e.bucket}` : t = `https://s3-${e.region}.amazonaws.com/${e.bucket}`;
  } else e.region === "cn-north-1" ? t = `https://${e.bucket}.s3.${e.region}.amazonaws.com.cn` : t = `https://${e.bucket}.s3.amazonaws.com`;
  return uO(t, e.path);
}
function uO(e, t) {
  return t != null && t.length > 0 && (t.startsWith("/") || (e += "/"), e += t), e;
}
function iY(e) {
  if (e.name == null)
    throw new Error("name is missing");
  if (e.region == null)
    throw new Error("region is missing");
  return uO(`https://${e.name}.${e.region}.digitaloceanspaces.com`, e.path);
}
var By = {};
Object.defineProperty(By, "__esModule", { value: !0 });
By.retry = fO;
const sY = ti;
async function fO(e, t, r, n = 0, i = 0, s) {
  var o;
  const a = new sY.CancellationToken();
  try {
    return await e();
  } catch (c) {
    if ((!((o = s == null ? void 0 : s(c)) !== null && o !== void 0) || o) && t > 0 && !a.cancelled)
      return await new Promise((u) => setTimeout(u, r + n * i)), await fO(e, t - 1, r, n, i + 1, s);
    throw c;
  }
}
var zy = {};
Object.defineProperty(zy, "__esModule", { value: !0 });
zy.parseDn = oY;
function oY(e) {
  let t = !1, r = null, n = "", i = 0;
  e = e.trim();
  const s = /* @__PURE__ */ new Map();
  for (let o = 0; o <= e.length; o++) {
    if (o === e.length) {
      r !== null && s.set(r, n);
      break;
    }
    const a = e[o];
    if (t) {
      if (a === '"') {
        t = !1;
        continue;
      }
    } else {
      if (a === '"') {
        t = !0;
        continue;
      }
      if (a === "\\") {
        o++;
        const c = parseInt(e.slice(o, o + 2), 16);
        Number.isNaN(c) ? n += e[o] : (o++, n += String.fromCharCode(c));
        continue;
      }
      if (r === null && a === "=") {
        r = n, n = "";
        continue;
      }
      if (a === "," || a === ";" || a === "+") {
        r !== null && s.set(r, n), r = null, n = "";
        continue;
      }
    }
    if (a === " " && !t) {
      if (n.length === 0)
        continue;
      if (o > i) {
        let c = o;
        for (; e[c] === " "; )
          c++;
        i = c;
      }
      if (i >= e.length || e[i] === "," || e[i] === ";" || r === null && e[i] === "=" || r !== null && e[i] === "+") {
        o = i - 1;
        continue;
      }
    }
    n += a;
  }
  return s;
}
var Js = {};
Object.defineProperty(Js, "__esModule", { value: !0 });
Js.nil = Js.UUID = void 0;
const dO = Ki, pO = po, aY = "options.name must be either a string or a Buffer", $w = (0, dO.randomBytes)(16);
$w[0] = $w[0] | 1;
const Nl = {}, Ie = [];
for (let e = 0; e < 256; e++) {
  const t = (e + 256).toString(16).substr(1);
  Nl[t] = e, Ie[e] = t;
}
class Vi {
  constructor(t) {
    this.ascii = null, this.binary = null;
    const r = Vi.check(t);
    if (!r)
      throw new Error("not a UUID");
    this.version = r.version, r.format === "ascii" ? this.ascii = t : this.binary = t;
  }
  static v5(t, r) {
    return cY(t, "sha1", 80, r);
  }
  toString() {
    return this.ascii == null && (this.ascii = lY(this.binary)), this.ascii;
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(t, r = 0) {
    if (typeof t == "string")
      return t = t.toLowerCase(), /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(t) ? t === "00000000-0000-0000-0000-000000000000" ? { version: void 0, variant: "nil", format: "ascii" } : {
        version: (Nl[t[14] + t[15]] & 240) >> 4,
        variant: Tw((Nl[t[19] + t[20]] & 224) >> 5),
        format: "ascii"
      } : !1;
    if (Buffer.isBuffer(t)) {
      if (t.length < r + 16)
        return !1;
      let n = 0;
      for (; n < 16 && t[r + n] === 0; n++)
        ;
      return n === 16 ? { version: void 0, variant: "nil", format: "binary" } : {
        version: (t[r + 6] & 240) >> 4,
        variant: Tw((t[r + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, pO.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  // read stringified uuid into a Buffer
  static parse(t) {
    const r = Buffer.allocUnsafe(16);
    let n = 0;
    for (let i = 0; i < 16; i++)
      r[i] = Nl[t[n++] + t[n++]], (i === 3 || i === 5 || i === 7 || i === 9) && (n += 1);
    return r;
  }
}
Js.UUID = Vi;
Vi.OID = Vi.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function Tw(e) {
  switch (e) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
var ra;
(function(e) {
  e[e.ASCII = 0] = "ASCII", e[e.BINARY = 1] = "BINARY", e[e.OBJECT = 2] = "OBJECT";
})(ra || (ra = {}));
function cY(e, t, r, n, i = ra.ASCII) {
  const s = (0, dO.createHash)(t);
  if (typeof e != "string" && !Buffer.isBuffer(e))
    throw (0, pO.newError)(aY, "ERR_INVALID_UUID_NAME");
  s.update(n), s.update(e);
  const a = s.digest();
  let c;
  switch (i) {
    case ra.BINARY:
      a[6] = a[6] & 15 | r, a[8] = a[8] & 63 | 128, c = a;
      break;
    case ra.OBJECT:
      a[6] = a[6] & 15 | r, a[8] = a[8] & 63 | 128, c = new Vi(a);
      break;
    default:
      c = Ie[a[0]] + Ie[a[1]] + Ie[a[2]] + Ie[a[3]] + "-" + Ie[a[4]] + Ie[a[5]] + "-" + Ie[a[6] & 15 | r] + Ie[a[7]] + "-" + Ie[a[8] & 63 | 128] + Ie[a[9]] + "-" + Ie[a[10]] + Ie[a[11]] + Ie[a[12]] + Ie[a[13]] + Ie[a[14]] + Ie[a[15]];
      break;
  }
  return c;
}
function lY(e) {
  return Ie[e[0]] + Ie[e[1]] + Ie[e[2]] + Ie[e[3]] + "-" + Ie[e[4]] + Ie[e[5]] + "-" + Ie[e[6]] + Ie[e[7]] + "-" + Ie[e[8]] + Ie[e[9]] + "-" + Ie[e[10]] + Ie[e[11]] + Ie[e[12]] + Ie[e[13]] + Ie[e[14]] + Ie[e[15]];
}
Js.nil = new Vi("00000000-0000-0000-0000-000000000000");
var oc = {}, hO = {};
(function(e) {
  (function(t) {
    t.parser = function(O, S) {
      return new n(O, S);
    }, t.SAXParser = n, t.SAXStream = l, t.createStream = u, t.MAX_BUFFER_LENGTH = 64 * 1024;
    var r = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    t.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function n(O, S) {
      if (!(this instanceof n))
        return new n(O, S);
      var W = this;
      s(W), W.q = W.c = "", W.bufferCheckPosition = t.MAX_BUFFER_LENGTH, W.opt = S || {}, W.opt.lowercase = W.opt.lowercase || W.opt.lowercasetags, W.looseCase = W.opt.lowercase ? "toLowerCase" : "toUpperCase", W.tags = [], W.closed = W.closedRoot = W.sawRoot = !1, W.tag = W.error = null, W.strict = !!O, W.noscript = !!(O || W.opt.noscript), W.state = b.BEGIN, W.strictEntities = W.opt.strictEntities, W.ENTITIES = W.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), W.attribList = [], W.opt.xmlns && (W.ns = Object.create(h)), W.opt.unquotedAttributeValues === void 0 && (W.opt.unquotedAttributeValues = !O), W.trackPosition = W.opt.position !== !1, W.trackPosition && (W.position = W.line = W.column = 0), H(W, "onready");
    }
    Object.create || (Object.create = function(O) {
      function S() {
      }
      S.prototype = O;
      var W = new S();
      return W;
    }), Object.keys || (Object.keys = function(O) {
      var S = [];
      for (var W in O) O.hasOwnProperty(W) && S.push(W);
      return S;
    });
    function i(O) {
      for (var S = Math.max(t.MAX_BUFFER_LENGTH, 10), W = 0, z = 0, Q = r.length; z < Q; z++) {
        var K = O[r[z]].length;
        if (K > S)
          switch (r[z]) {
            case "textNode":
              $(O);
              break;
            case "cdata":
              q(O, "oncdata", O.cdata), O.cdata = "";
              break;
            case "script":
              q(O, "onscript", O.script), O.script = "";
              break;
            default:
              A(O, "Max buffer length exceeded: " + r[z]);
          }
        W = Math.max(W, K);
      }
      var X = t.MAX_BUFFER_LENGTH - W;
      O.bufferCheckPosition = X + O.position;
    }
    function s(O) {
      for (var S = 0, W = r.length; S < W; S++)
        O[r[S]] = "";
    }
    function o(O) {
      $(O), O.cdata !== "" && (q(O, "oncdata", O.cdata), O.cdata = ""), O.script !== "" && (q(O, "onscript", O.script), O.script = "");
    }
    n.prototype = {
      end: function() {
        P(this);
      },
      write: G,
      resume: function() {
        return this.error = null, this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        o(this);
      }
    };
    var a;
    try {
      a = require("stream").Stream;
    } catch {
      a = function() {
      };
    }
    a || (a = function() {
    });
    var c = t.EVENTS.filter(function(O) {
      return O !== "error" && O !== "end";
    });
    function u(O, S) {
      return new l(O, S);
    }
    function l(O, S) {
      if (!(this instanceof l))
        return new l(O, S);
      a.apply(this), this._parser = new n(O, S), this.writable = !0, this.readable = !0;
      var W = this;
      this._parser.onend = function() {
        W.emit("end");
      }, this._parser.onerror = function(z) {
        W.emit("error", z), W._parser.error = null;
      }, this._decoder = null, c.forEach(function(z) {
        Object.defineProperty(W, "on" + z, {
          get: function() {
            return W._parser["on" + z];
          },
          set: function(Q) {
            if (!Q)
              return W.removeAllListeners(z), W._parser["on" + z] = Q, Q;
            W.on(z, Q);
          },
          enumerable: !0,
          configurable: !1
        });
      });
    }
    l.prototype = Object.create(a.prototype, {
      constructor: {
        value: l
      }
    }), l.prototype.write = function(O) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(O)) {
        if (!this._decoder) {
          var S = $C.StringDecoder;
          this._decoder = new S("utf8");
        }
        O = this._decoder.write(O);
      }
      return this._parser.write(O.toString()), this.emit("data", O), !0;
    }, l.prototype.end = function(O) {
      return O && O.length && this.write(O), this._parser.end(), !0;
    }, l.prototype.on = function(O, S) {
      var W = this;
      return !W._parser["on" + O] && c.indexOf(O) !== -1 && (W._parser["on" + O] = function() {
        var z = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        z.splice(0, 0, O), W.emit.apply(W, z);
      }), a.prototype.on.call(W, O, S);
    };
    var f = "[CDATA[", m = "DOCTYPE", p = "http://www.w3.org/XML/1998/namespace", d = "http://www.w3.org/2000/xmlns/", h = { xml: p, xmlns: d }, _ = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, g = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, v = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function E(O) {
      return O === " " || O === `
` || O === "\r" || O === "	";
    }
    function R(O) {
      return O === '"' || O === "'";
    }
    function w(O) {
      return O === ">" || E(O);
    }
    function C(O, S) {
      return O.test(S);
    }
    function V(O, S) {
      return !C(O, S);
    }
    var b = 0;
    t.STATE = {
      BEGIN: b++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: b++,
      // leading whitespace
      TEXT: b++,
      // general stuff
      TEXT_ENTITY: b++,
      // &amp and such.
      OPEN_WAKA: b++,
      // <
      SGML_DECL: b++,
      // <!BLARG
      SGML_DECL_QUOTED: b++,
      // <!BLARG foo "bar
      DOCTYPE: b++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: b++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: b++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: b++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: b++,
      // <!-
      COMMENT: b++,
      // <!--
      COMMENT_ENDING: b++,
      // <!-- blah -
      COMMENT_ENDED: b++,
      // <!-- blah --
      CDATA: b++,
      // <![CDATA[ something
      CDATA_ENDING: b++,
      // ]
      CDATA_ENDING_2: b++,
      // ]]
      PROC_INST: b++,
      // <?hi
      PROC_INST_BODY: b++,
      // <?hi there
      PROC_INST_ENDING: b++,
      // <?hi "there" ?
      OPEN_TAG: b++,
      // <strong
      OPEN_TAG_SLASH: b++,
      // <strong /
      ATTRIB: b++,
      // <a
      ATTRIB_NAME: b++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: b++,
      // <a foo _
      ATTRIB_VALUE: b++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: b++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: b++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: b++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: b++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: b++,
      // <foo bar=&quot
      CLOSE_TAG: b++,
      // </a
      CLOSE_TAG_SAW_WHITE: b++,
      // </a   >
      SCRIPT: b++,
      // <script> ...
      SCRIPT_ENDING: b++
      // <script> ... <
    }, t.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, t.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(t.ENTITIES).forEach(function(O) {
      var S = t.ENTITIES[O], W = typeof S == "number" ? String.fromCharCode(S) : S;
      t.ENTITIES[O] = W;
    });
    for (var F in t.STATE)
      t.STATE[t.STATE[F]] = F;
    b = t.STATE;
    function H(O, S, W) {
      O[S] && O[S](W);
    }
    function q(O, S, W) {
      O.textNode && $(O), H(O, S, W);
    }
    function $(O) {
      O.textNode = x(O.opt, O.textNode), O.textNode && H(O, "ontext", O.textNode), O.textNode = "";
    }
    function x(O, S) {
      return O.trim && (S = S.trim()), O.normalize && (S = S.replace(/\s+/g, " ")), S;
    }
    function A(O, S) {
      return $(O), O.trackPosition && (S += `
Line: ` + O.line + `
Column: ` + O.column + `
Char: ` + O.c), S = new Error(S), O.error = S, H(O, "onerror", S), O;
    }
    function P(O) {
      return O.sawRoot && !O.closedRoot && D(O, "Unclosed root tag"), O.state !== b.BEGIN && O.state !== b.BEGIN_WHITESPACE && O.state !== b.TEXT && A(O, "Unexpected end"), $(O), O.c = "", O.closed = !0, H(O, "onend"), n.call(O, O.strict, O.opt), O;
    }
    function D(O, S) {
      if (typeof O != "object" || !(O instanceof n))
        throw new Error("bad call to strictFail");
      O.strict && A(O, S);
    }
    function I(O) {
      O.strict || (O.tagName = O.tagName[O.looseCase]());
      var S = O.tags[O.tags.length - 1] || O, W = O.tag = { name: O.tagName, attributes: {} };
      O.opt.xmlns && (W.ns = S.ns), O.attribList.length = 0, q(O, "onopentagstart", W);
    }
    function L(O, S) {
      var W = O.indexOf(":"), z = W < 0 ? ["", O] : O.split(":"), Q = z[0], K = z[1];
      return S && O === "xmlns" && (Q = "xmlns", K = ""), { prefix: Q, local: K };
    }
    function j(O) {
      if (O.strict || (O.attribName = O.attribName[O.looseCase]()), O.attribList.indexOf(O.attribName) !== -1 || O.tag.attributes.hasOwnProperty(O.attribName)) {
        O.attribName = O.attribValue = "";
        return;
      }
      if (O.opt.xmlns) {
        var S = L(O.attribName, !0), W = S.prefix, z = S.local;
        if (W === "xmlns")
          if (z === "xml" && O.attribValue !== p)
            D(
              O,
              "xml: prefix must be bound to " + p + `
Actual: ` + O.attribValue
            );
          else if (z === "xmlns" && O.attribValue !== d)
            D(
              O,
              "xmlns: prefix must be bound to " + d + `
Actual: ` + O.attribValue
            );
          else {
            var Q = O.tag, K = O.tags[O.tags.length - 1] || O;
            Q.ns === K.ns && (Q.ns = Object.create(K.ns)), Q.ns[z] = O.attribValue;
          }
        O.attribList.push([O.attribName, O.attribValue]);
      } else
        O.tag.attributes[O.attribName] = O.attribValue, q(O, "onattribute", {
          name: O.attribName,
          value: O.attribValue
        });
      O.attribName = O.attribValue = "";
    }
    function k(O, S) {
      if (O.opt.xmlns) {
        var W = O.tag, z = L(O.tagName);
        W.prefix = z.prefix, W.local = z.local, W.uri = W.ns[z.prefix] || "", W.prefix && !W.uri && (D(O, "Unbound namespace prefix: " + JSON.stringify(O.tagName)), W.uri = z.prefix);
        var Q = O.tags[O.tags.length - 1] || O;
        W.ns && Q.ns !== W.ns && Object.keys(W.ns).forEach(function(ze) {
          q(O, "onopennamespace", {
            prefix: ze,
            uri: W.ns[ze]
          });
        });
        for (var K = 0, X = O.attribList.length; K < X; K++) {
          var J = O.attribList[K], re = J[0], fe = J[1], ee = L(re, !0), le = ee.prefix, xe = ee.local, ye = le === "" ? "" : W.ns[le] || "", ve = {
            name: re,
            value: fe,
            prefix: le,
            local: xe,
            uri: ye
          };
          le && le !== "xmlns" && !ye && (D(O, "Unbound namespace prefix: " + JSON.stringify(le)), ve.uri = le), O.tag.attributes[re] = ve, q(O, "onattribute", ve);
        }
        O.attribList.length = 0;
      }
      O.tag.isSelfClosing = !!S, O.sawRoot = !0, O.tags.push(O.tag), q(O, "onopentag", O.tag), S || (!O.noscript && O.tagName.toLowerCase() === "script" ? O.state = b.SCRIPT : O.state = b.TEXT, O.tag = null, O.tagName = ""), O.attribName = O.attribValue = "", O.attribList.length = 0;
    }
    function U(O) {
      if (!O.tagName) {
        D(O, "Weird empty close tag."), O.textNode += "</>", O.state = b.TEXT;
        return;
      }
      if (O.script) {
        if (O.tagName !== "script") {
          O.script += "</" + O.tagName + ">", O.tagName = "", O.state = b.SCRIPT;
          return;
        }
        q(O, "onscript", O.script), O.script = "";
      }
      var S = O.tags.length, W = O.tagName;
      O.strict || (W = W[O.looseCase]());
      for (var z = W; S--; ) {
        var Q = O.tags[S];
        if (Q.name !== z)
          D(O, "Unexpected close tag");
        else
          break;
      }
      if (S < 0) {
        D(O, "Unmatched closing tag: " + O.tagName), O.textNode += "</" + O.tagName + ">", O.state = b.TEXT;
        return;
      }
      O.tagName = W;
      for (var K = O.tags.length; K-- > S; ) {
        var X = O.tag = O.tags.pop();
        O.tagName = O.tag.name, q(O, "onclosetag", O.tagName);
        var J = {};
        for (var re in X.ns)
          J[re] = X.ns[re];
        var fe = O.tags[O.tags.length - 1] || O;
        O.opt.xmlns && X.ns !== fe.ns && Object.keys(X.ns).forEach(function(ee) {
          var le = X.ns[ee];
          q(O, "onclosenamespace", { prefix: ee, uri: le });
        });
      }
      S === 0 && (O.closedRoot = !0), O.tagName = O.attribValue = O.attribName = "", O.attribList.length = 0, O.state = b.TEXT;
    }
    function M(O) {
      var S = O.entity, W = S.toLowerCase(), z, Q = "";
      return O.ENTITIES[S] ? O.ENTITIES[S] : O.ENTITIES[W] ? O.ENTITIES[W] : (S = W, S.charAt(0) === "#" && (S.charAt(1) === "x" ? (S = S.slice(2), z = parseInt(S, 16), Q = z.toString(16)) : (S = S.slice(1), z = parseInt(S, 10), Q = z.toString(10))), S = S.replace(/^0+/, ""), isNaN(z) || Q.toLowerCase() !== S ? (D(O, "Invalid character entity"), "&" + O.entity + ";") : String.fromCodePoint(z));
    }
    function T(O, S) {
      S === "<" ? (O.state = b.OPEN_WAKA, O.startTagPosition = O.position) : E(S) || (D(O, "Non-whitespace before first tag."), O.textNode = S, O.state = b.TEXT);
    }
    function N(O, S) {
      var W = "";
      return S < O.length && (W = O.charAt(S)), W;
    }
    function G(O) {
      var S = this;
      if (this.error)
        throw this.error;
      if (S.closed)
        return A(
          S,
          "Cannot write after close. Assign an onready handler."
        );
      if (O === null)
        return P(S);
      typeof O == "object" && (O = O.toString());
      for (var W = 0, z = ""; z = N(O, W++), S.c = z, !!z; )
        switch (S.trackPosition && (S.position++, z === `
` ? (S.line++, S.column = 0) : S.column++), S.state) {
          case b.BEGIN:
            if (S.state = b.BEGIN_WHITESPACE, z === "\uFEFF")
              continue;
            T(S, z);
            continue;
          case b.BEGIN_WHITESPACE:
            T(S, z);
            continue;
          case b.TEXT:
            if (S.sawRoot && !S.closedRoot) {
              for (var Q = W - 1; z && z !== "<" && z !== "&"; )
                z = N(O, W++), z && S.trackPosition && (S.position++, z === `
` ? (S.line++, S.column = 0) : S.column++);
              S.textNode += O.substring(Q, W - 1);
            }
            z === "<" && !(S.sawRoot && S.closedRoot && !S.strict) ? (S.state = b.OPEN_WAKA, S.startTagPosition = S.position) : (!E(z) && (!S.sawRoot || S.closedRoot) && D(S, "Text data outside of root node."), z === "&" ? S.state = b.TEXT_ENTITY : S.textNode += z);
            continue;
          case b.SCRIPT:
            z === "<" ? S.state = b.SCRIPT_ENDING : S.script += z;
            continue;
          case b.SCRIPT_ENDING:
            z === "/" ? S.state = b.CLOSE_TAG : (S.script += "<" + z, S.state = b.SCRIPT);
            continue;
          case b.OPEN_WAKA:
            if (z === "!")
              S.state = b.SGML_DECL, S.sgmlDecl = "";
            else if (!E(z)) if (C(_, z))
              S.state = b.OPEN_TAG, S.tagName = z;
            else if (z === "/")
              S.state = b.CLOSE_TAG, S.tagName = "";
            else if (z === "?")
              S.state = b.PROC_INST, S.procInstName = S.procInstBody = "";
            else {
              if (D(S, "Unencoded <"), S.startTagPosition + 1 < S.position) {
                var K = S.position - S.startTagPosition;
                z = new Array(K).join(" ") + z;
              }
              S.textNode += "<" + z, S.state = b.TEXT;
            }
            continue;
          case b.SGML_DECL:
            if (S.sgmlDecl + z === "--") {
              S.state = b.COMMENT, S.comment = "", S.sgmlDecl = "";
              continue;
            }
            S.doctype && S.doctype !== !0 && S.sgmlDecl ? (S.state = b.DOCTYPE_DTD, S.doctype += "<!" + S.sgmlDecl + z, S.sgmlDecl = "") : (S.sgmlDecl + z).toUpperCase() === f ? (q(S, "onopencdata"), S.state = b.CDATA, S.sgmlDecl = "", S.cdata = "") : (S.sgmlDecl + z).toUpperCase() === m ? (S.state = b.DOCTYPE, (S.doctype || S.sawRoot) && D(
              S,
              "Inappropriately located doctype declaration"
            ), S.doctype = "", S.sgmlDecl = "") : z === ">" ? (q(S, "onsgmldeclaration", S.sgmlDecl), S.sgmlDecl = "", S.state = b.TEXT) : (R(z) && (S.state = b.SGML_DECL_QUOTED), S.sgmlDecl += z);
            continue;
          case b.SGML_DECL_QUOTED:
            z === S.q && (S.state = b.SGML_DECL, S.q = ""), S.sgmlDecl += z;
            continue;
          case b.DOCTYPE:
            z === ">" ? (S.state = b.TEXT, q(S, "ondoctype", S.doctype), S.doctype = !0) : (S.doctype += z, z === "[" ? S.state = b.DOCTYPE_DTD : R(z) && (S.state = b.DOCTYPE_QUOTED, S.q = z));
            continue;
          case b.DOCTYPE_QUOTED:
            S.doctype += z, z === S.q && (S.q = "", S.state = b.DOCTYPE);
            continue;
          case b.DOCTYPE_DTD:
            z === "]" ? (S.doctype += z, S.state = b.DOCTYPE) : z === "<" ? (S.state = b.OPEN_WAKA, S.startTagPosition = S.position) : R(z) ? (S.doctype += z, S.state = b.DOCTYPE_DTD_QUOTED, S.q = z) : S.doctype += z;
            continue;
          case b.DOCTYPE_DTD_QUOTED:
            S.doctype += z, z === S.q && (S.state = b.DOCTYPE_DTD, S.q = "");
            continue;
          case b.COMMENT:
            z === "-" ? S.state = b.COMMENT_ENDING : S.comment += z;
            continue;
          case b.COMMENT_ENDING:
            z === "-" ? (S.state = b.COMMENT_ENDED, S.comment = x(S.opt, S.comment), S.comment && q(S, "oncomment", S.comment), S.comment = "") : (S.comment += "-" + z, S.state = b.COMMENT);
            continue;
          case b.COMMENT_ENDED:
            z !== ">" ? (D(S, "Malformed comment"), S.comment += "--" + z, S.state = b.COMMENT) : S.doctype && S.doctype !== !0 ? S.state = b.DOCTYPE_DTD : S.state = b.TEXT;
            continue;
          case b.CDATA:
            z === "]" ? S.state = b.CDATA_ENDING : S.cdata += z;
            continue;
          case b.CDATA_ENDING:
            z === "]" ? S.state = b.CDATA_ENDING_2 : (S.cdata += "]" + z, S.state = b.CDATA);
            continue;
          case b.CDATA_ENDING_2:
            z === ">" ? (S.cdata && q(S, "oncdata", S.cdata), q(S, "onclosecdata"), S.cdata = "", S.state = b.TEXT) : z === "]" ? S.cdata += "]" : (S.cdata += "]]" + z, S.state = b.CDATA);
            continue;
          case b.PROC_INST:
            z === "?" ? S.state = b.PROC_INST_ENDING : E(z) ? S.state = b.PROC_INST_BODY : S.procInstName += z;
            continue;
          case b.PROC_INST_BODY:
            if (!S.procInstBody && E(z))
              continue;
            z === "?" ? S.state = b.PROC_INST_ENDING : S.procInstBody += z;
            continue;
          case b.PROC_INST_ENDING:
            z === ">" ? (q(S, "onprocessinginstruction", {
              name: S.procInstName,
              body: S.procInstBody
            }), S.procInstName = S.procInstBody = "", S.state = b.TEXT) : (S.procInstBody += "?" + z, S.state = b.PROC_INST_BODY);
            continue;
          case b.OPEN_TAG:
            C(g, z) ? S.tagName += z : (I(S), z === ">" ? k(S) : z === "/" ? S.state = b.OPEN_TAG_SLASH : (E(z) || D(S, "Invalid character in tag name"), S.state = b.ATTRIB));
            continue;
          case b.OPEN_TAG_SLASH:
            z === ">" ? (k(S, !0), U(S)) : (D(S, "Forward-slash in opening tag not followed by >"), S.state = b.ATTRIB);
            continue;
          case b.ATTRIB:
            if (E(z))
              continue;
            z === ">" ? k(S) : z === "/" ? S.state = b.OPEN_TAG_SLASH : C(_, z) ? (S.attribName = z, S.attribValue = "", S.state = b.ATTRIB_NAME) : D(S, "Invalid attribute name");
            continue;
          case b.ATTRIB_NAME:
            z === "=" ? S.state = b.ATTRIB_VALUE : z === ">" ? (D(S, "Attribute without value"), S.attribValue = S.attribName, j(S), k(S)) : E(z) ? S.state = b.ATTRIB_NAME_SAW_WHITE : C(g, z) ? S.attribName += z : D(S, "Invalid attribute name");
            continue;
          case b.ATTRIB_NAME_SAW_WHITE:
            if (z === "=")
              S.state = b.ATTRIB_VALUE;
            else {
              if (E(z))
                continue;
              D(S, "Attribute without value"), S.tag.attributes[S.attribName] = "", S.attribValue = "", q(S, "onattribute", {
                name: S.attribName,
                value: ""
              }), S.attribName = "", z === ">" ? k(S) : C(_, z) ? (S.attribName = z, S.state = b.ATTRIB_NAME) : (D(S, "Invalid attribute name"), S.state = b.ATTRIB);
            }
            continue;
          case b.ATTRIB_VALUE:
            if (E(z))
              continue;
            R(z) ? (S.q = z, S.state = b.ATTRIB_VALUE_QUOTED) : (S.opt.unquotedAttributeValues || A(S, "Unquoted attribute value"), S.state = b.ATTRIB_VALUE_UNQUOTED, S.attribValue = z);
            continue;
          case b.ATTRIB_VALUE_QUOTED:
            if (z !== S.q) {
              z === "&" ? S.state = b.ATTRIB_VALUE_ENTITY_Q : S.attribValue += z;
              continue;
            }
            j(S), S.q = "", S.state = b.ATTRIB_VALUE_CLOSED;
            continue;
          case b.ATTRIB_VALUE_CLOSED:
            E(z) ? S.state = b.ATTRIB : z === ">" ? k(S) : z === "/" ? S.state = b.OPEN_TAG_SLASH : C(_, z) ? (D(S, "No whitespace between attributes"), S.attribName = z, S.attribValue = "", S.state = b.ATTRIB_NAME) : D(S, "Invalid attribute name");
            continue;
          case b.ATTRIB_VALUE_UNQUOTED:
            if (!w(z)) {
              z === "&" ? S.state = b.ATTRIB_VALUE_ENTITY_U : S.attribValue += z;
              continue;
            }
            j(S), z === ">" ? k(S) : S.state = b.ATTRIB;
            continue;
          case b.CLOSE_TAG:
            if (S.tagName)
              z === ">" ? U(S) : C(g, z) ? S.tagName += z : S.script ? (S.script += "</" + S.tagName, S.tagName = "", S.state = b.SCRIPT) : (E(z) || D(S, "Invalid tagname in closing tag"), S.state = b.CLOSE_TAG_SAW_WHITE);
            else {
              if (E(z))
                continue;
              V(_, z) ? S.script ? (S.script += "</" + z, S.state = b.SCRIPT) : D(S, "Invalid tagname in closing tag.") : S.tagName = z;
            }
            continue;
          case b.CLOSE_TAG_SAW_WHITE:
            if (E(z))
              continue;
            z === ">" ? U(S) : D(S, "Invalid characters in closing tag");
            continue;
          case b.TEXT_ENTITY:
          case b.ATTRIB_VALUE_ENTITY_Q:
          case b.ATTRIB_VALUE_ENTITY_U:
            var X, J;
            switch (S.state) {
              case b.TEXT_ENTITY:
                X = b.TEXT, J = "textNode";
                break;
              case b.ATTRIB_VALUE_ENTITY_Q:
                X = b.ATTRIB_VALUE_QUOTED, J = "attribValue";
                break;
              case b.ATTRIB_VALUE_ENTITY_U:
                X = b.ATTRIB_VALUE_UNQUOTED, J = "attribValue";
                break;
            }
            if (z === ";") {
              var re = M(S);
              S.opt.unparsedEntities && !Object.values(t.XML_ENTITIES).includes(re) ? (S.entity = "", S.state = X, S.write(re)) : (S[J] += re, S.entity = "", S.state = X);
            } else C(S.entity.length ? y : v, z) ? S.entity += z : (D(S, "Invalid character in entity name"), S[J] += "&" + S.entity + z, S.entity = "", S.state = X);
            continue;
          default:
            throw new Error(S, "Unknown state: " + S.state);
        }
      return S.position >= S.bufferCheckPosition && i(S), S;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    String.fromCodePoint || function() {
      var O = String.fromCharCode, S = Math.floor, W = function() {
        var z = 16384, Q = [], K, X, J = -1, re = arguments.length;
        if (!re)
          return "";
        for (var fe = ""; ++J < re; ) {
          var ee = Number(arguments[J]);
          if (!isFinite(ee) || // `NaN`, `+Infinity`, or `-Infinity`
          ee < 0 || // not a valid Unicode code point
          ee > 1114111 || // not a valid Unicode code point
          S(ee) !== ee)
            throw RangeError("Invalid code point: " + ee);
          ee <= 65535 ? Q.push(ee) : (ee -= 65536, K = (ee >> 10) + 55296, X = ee % 1024 + 56320, Q.push(K, X)), (J + 1 === re || Q.length > z) && (fe += O.apply(null, Q), Q.length = 0);
        }
        return fe;
      };
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: W,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = W;
    }();
  })(e);
})(hO);
Object.defineProperty(oc, "__esModule", { value: !0 });
oc.XElement = void 0;
oc.parseXml = pY;
const uY = hO, nl = po;
class mO {
  constructor(t) {
    if (this.name = t, this.value = "", this.attributes = null, this.isCData = !1, this.elements = null, !t)
      throw (0, nl.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    if (!dY(t))
      throw (0, nl.newError)(`Invalid element name: ${t}`, "ERR_XML_ELEMENT_INVALID_NAME");
  }
  attribute(t) {
    const r = this.attributes === null ? null : this.attributes[t];
    if (r == null)
      throw (0, nl.newError)(`No attribute "${t}"`, "ERR_XML_MISSED_ATTRIBUTE");
    return r;
  }
  removeAttribute(t) {
    this.attributes !== null && delete this.attributes[t];
  }
  element(t, r = !1, n = null) {
    const i = this.elementOrNull(t, r);
    if (i === null)
      throw (0, nl.newError)(n || `No element "${t}"`, "ERR_XML_MISSED_ELEMENT");
    return i;
  }
  elementOrNull(t, r = !1) {
    if (this.elements === null)
      return null;
    for (const n of this.elements)
      if (Ow(n, t, r))
        return n;
    return null;
  }
  getElements(t, r = !1) {
    return this.elements === null ? [] : this.elements.filter((n) => Ow(n, t, r));
  }
  elementValueOrEmpty(t, r = !1) {
    const n = this.elementOrNull(t, r);
    return n === null ? "" : n.value;
  }
}
oc.XElement = mO;
const fY = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function dY(e) {
  return fY.test(e);
}
function Ow(e, t, r) {
  const n = e.name;
  return n === t || r === !0 && n.length === t.length && n.toLowerCase() === t.toLowerCase();
}
function pY(e) {
  let t = null;
  const r = uY.parser(!0, {}), n = [];
  return r.onopentag = (i) => {
    const s = new mO(i.name);
    if (s.attributes = i.attributes, t === null)
      t = s;
    else {
      const o = n[n.length - 1];
      o.elements == null && (o.elements = []), o.elements.push(s);
    }
    n.push(s);
  }, r.onclosetag = () => {
    n.pop();
  }, r.ontext = (i) => {
    n.length > 0 && (n[n.length - 1].value = i);
  }, r.oncdata = (i) => {
    const s = n[n.length - 1];
    s.value = i, s.isCData = !0;
  }, r.onerror = (i) => {
    throw i;
  }, r.write(e), t;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CURRENT_APP_PACKAGE_FILE_NAME = e.CURRENT_APP_INSTALLER_FILE_NAME = e.XElement = e.parseXml = e.UUID = e.parseDn = e.retry = e.githubUrl = e.getS3LikeProviderBaseUrl = e.ProgressCallbackTransform = e.MemoLazy = e.safeStringifyJson = e.safeGetHeader = e.parseJson = e.HttpExecutor = e.HttpError = e.DigestTransform = e.createHttpError = e.configureRequestUrl = e.configureRequestOptionsFromUrl = e.configureRequestOptions = e.newError = e.CancellationToken = e.CancellationError = void 0, e.asArray = f;
  var t = ti;
  Object.defineProperty(e, "CancellationError", { enumerable: !0, get: function() {
    return t.CancellationError;
  } }), Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } });
  var r = po;
  Object.defineProperty(e, "newError", { enumerable: !0, get: function() {
    return r.newError;
  } });
  var n = er;
  Object.defineProperty(e, "configureRequestOptions", { enumerable: !0, get: function() {
    return n.configureRequestOptions;
  } }), Object.defineProperty(e, "configureRequestOptionsFromUrl", { enumerable: !0, get: function() {
    return n.configureRequestOptionsFromUrl;
  } }), Object.defineProperty(e, "configureRequestUrl", { enumerable: !0, get: function() {
    return n.configureRequestUrl;
  } }), Object.defineProperty(e, "createHttpError", { enumerable: !0, get: function() {
    return n.createHttpError;
  } }), Object.defineProperty(e, "DigestTransform", { enumerable: !0, get: function() {
    return n.DigestTransform;
  } }), Object.defineProperty(e, "HttpError", { enumerable: !0, get: function() {
    return n.HttpError;
  } }), Object.defineProperty(e, "HttpExecutor", { enumerable: !0, get: function() {
    return n.HttpExecutor;
  } }), Object.defineProperty(e, "parseJson", { enumerable: !0, get: function() {
    return n.parseJson;
  } }), Object.defineProperty(e, "safeGetHeader", { enumerable: !0, get: function() {
    return n.safeGetHeader;
  } }), Object.defineProperty(e, "safeStringifyJson", { enumerable: !0, get: function() {
    return n.safeStringifyJson;
  } });
  var i = wf;
  Object.defineProperty(e, "MemoLazy", { enumerable: !0, get: function() {
    return i.MemoLazy;
  } });
  var s = sc;
  Object.defineProperty(e, "ProgressCallbackTransform", { enumerable: !0, get: function() {
    return s.ProgressCallbackTransform;
  } });
  var o = Sf;
  Object.defineProperty(e, "getS3LikeProviderBaseUrl", { enumerable: !0, get: function() {
    return o.getS3LikeProviderBaseUrl;
  } }), Object.defineProperty(e, "githubUrl", { enumerable: !0, get: function() {
    return o.githubUrl;
  } });
  var a = By;
  Object.defineProperty(e, "retry", { enumerable: !0, get: function() {
    return a.retry;
  } });
  var c = zy;
  Object.defineProperty(e, "parseDn", { enumerable: !0, get: function() {
    return c.parseDn;
  } });
  var u = Js;
  Object.defineProperty(e, "UUID", { enumerable: !0, get: function() {
    return u.UUID;
  } });
  var l = oc;
  Object.defineProperty(e, "parseXml", { enumerable: !0, get: function() {
    return l.parseXml;
  } }), Object.defineProperty(e, "XElement", { enumerable: !0, get: function() {
    return l.XElement;
  } }), e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe", e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function f(m) {
    return m == null ? [] : Array.isArray(m) ? m : [m];
  }
})(Rt);
var jt = {}, Vy = {}, Wr = {};
function gO(e) {
  return typeof e > "u" || e === null;
}
function hY(e) {
  return typeof e == "object" && e !== null;
}
function mY(e) {
  return Array.isArray(e) ? e : gO(e) ? [] : [e];
}
function gY(e, t) {
  var r, n, i, s;
  if (t)
    for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1)
      i = s[r], e[i] = t[i];
  return e;
}
function yY(e, t) {
  var r = "", n;
  for (n = 0; n < t; n += 1)
    r += e;
  return r;
}
function vY(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
Wr.isNothing = gO;
Wr.isObject = hY;
Wr.toArray = mY;
Wr.repeat = yY;
Wr.isNegativeZero = vY;
Wr.extend = gY;
function yO(e, t) {
  var r = "", n = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), n + " " + r) : n;
}
function Ea(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = yO(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Ea.prototype = Object.create(Error.prototype);
Ea.prototype.constructor = Ea;
Ea.prototype.toString = function(t) {
  return this.name + ": " + yO(this, t);
};
var ac = Ea, Vo = Wr;
function zp(e, t, r, n, i) {
  var s = "", o = "", a = Math.floor(i / 2) - 1;
  return n - t > a && (s = " ... ", t = n - a + s.length), r - n > a && (o = " ...", r = n + a - o.length), {
    str: s + e.slice(t, r).replace(/\t/g, "→") + o,
    pos: n - t + s.length
    // relative position
  };
}
function Vp(e, t) {
  return Vo.repeat(" ", t - e.length) + e;
}
function _Y(e, t) {
  if (t = Object.create(t || null), !e.buffer) return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1; s = r.exec(e.buffer); )
    i.push(s.index), n.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = n.length - 2);
  o < 0 && (o = n.length - 1);
  var a = "", c, u, l = Math.min(e.line + t.linesAfter, i.length).toString().length, f = t.maxLength - (t.indent + l + 3);
  for (c = 1; c <= t.linesBefore && !(o - c < 0); c++)
    u = zp(
      e.buffer,
      n[o - c],
      i[o - c],
      e.position - (n[o] - n[o - c]),
      f
    ), a = Vo.repeat(" ", t.indent) + Vp((e.line - c + 1).toString(), l) + " | " + u.str + `
` + a;
  for (u = zp(e.buffer, n[o], i[o], e.position, f), a += Vo.repeat(" ", t.indent) + Vp((e.line + 1).toString(), l) + " | " + u.str + `
`, a += Vo.repeat("-", t.indent + l + 3 + u.pos) + `^
`, c = 1; c <= t.linesAfter && !(o + c >= i.length); c++)
    u = zp(
      e.buffer,
      n[o + c],
      i[o + c],
      e.position - (n[o] - n[o + c]),
      f
    ), a += Vo.repeat(" ", t.indent) + Vp((e.line + c + 1).toString(), l) + " | " + u.str + `
`;
  return a.replace(/\n$/, "");
}
var bY = _Y, Pw = ac, EY = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], wY = [
  "scalar",
  "sequence",
  "mapping"
];
function SY(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(n) {
      t[String(n)] = r;
    });
  }), t;
}
function xY(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (EY.indexOf(r) === -1)
      throw new Pw('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = SY(t.styleAliases || null), wY.indexOf(this.kind) === -1)
    throw new Pw('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var sr = xY, Mo = ac, Gp = sr;
function Cw(e, t) {
  var r = [];
  return e[t].forEach(function(n) {
    var i = r.length;
    r.forEach(function(s, o) {
      s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = o);
    }), r[i] = n;
  }), r;
}
function RY() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function n(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(n);
  return e;
}
function Xh(e) {
  return this.extend(e);
}
Xh.prototype.extend = function(t) {
  var r = [], n = [];
  if (t instanceof Gp)
    n.push(t);
  else if (Array.isArray(t))
    n = n.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (n = n.concat(t.explicit));
  else
    throw new Mo("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(s) {
    if (!(s instanceof Gp))
      throw new Mo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Mo("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Mo("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n.forEach(function(s) {
    if (!(s instanceof Gp))
      throw new Mo("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(Xh.prototype);
  return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = Cw(i, "implicit"), i.compiledExplicit = Cw(i, "explicit"), i.compiledTypeMap = RY(i.compiledImplicit, i.compiledExplicit), i;
};
var vO = Xh, $Y = sr, _O = new $Y("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), TY = sr, bO = new TY("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), OY = sr, EO = new OY("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), PY = vO, wO = new PY({
  explicit: [
    _O,
    bO,
    EO
  ]
}), CY = sr;
function AY(e) {
  if (e === null) return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function IY() {
  return null;
}
function NY(e) {
  return e === null;
}
var SO = new CY("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: AY,
  construct: IY,
  predicate: NY,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), kY = sr;
function DY(e) {
  if (e === null) return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function LY(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function FY(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var xO = new kY("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: DY,
  construct: LY,
  predicate: FY,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), jY = Wr, UY = sr;
function MY(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function HY(e) {
  return 48 <= e && e <= 55;
}
function qY(e) {
  return 48 <= e && e <= 57;
}
function BY(e) {
  if (e === null) return !1;
  var t = e.length, r = 0, n = !1, i;
  if (!t) return !1;
  if (i = e[r], (i === "-" || i === "+") && (i = e[++r]), i === "0") {
    if (r + 1 === t) return !0;
    if (i = e[++r], i === "b") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (!MY(e.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < t; r++)
        if (i = e[r], i !== "_") {
          if (!HY(e.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; r < t; r++)
    if (i = e[r], i !== "_") {
      if (!qY(e.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !(!n || i === "_");
}
function zY(e) {
  var t = e, r = 1, n;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), n = t[0], (n === "-" || n === "+") && (n === "-" && (r = -1), t = t.slice(1), n = t[0]), t === "0") return 0;
  if (n === "0") {
    if (t[1] === "b") return r * parseInt(t.slice(2), 2);
    if (t[1] === "x") return r * parseInt(t.slice(2), 16);
    if (t[1] === "o") return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
function VY(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !jY.isNegativeZero(e);
}
var RO = new UY("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: BY,
  construct: zY,
  predicate: VY,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), $O = Wr, GY = sr, WY = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function KY(e) {
  return !(e === null || !WY.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function YY(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
var JY = /^[-+]?[0-9]+e/;
function XY(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if ($O.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), JY.test(r) ? r.replace("e", ".e") : r;
}
function ZY(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || $O.isNegativeZero(e));
}
var TO = new GY("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: KY,
  construct: YY,
  predicate: ZY,
  represent: XY,
  defaultStyle: "lowercase"
}), OO = wO.extend({
  implicit: [
    SO,
    xO,
    RO,
    TO
  ]
}), PO = OO, QY = sr, CO = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), AO = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function eJ(e) {
  return e === null ? !1 : CO.exec(e) !== null || AO.exec(e) !== null;
}
function tJ(e) {
  var t, r, n, i, s, o, a, c = 0, u = null, l, f, m;
  if (t = CO.exec(e), t === null && (t = AO.exec(e)), t === null) throw new Error("Date resolve error");
  if (r = +t[1], n = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +t[4], o = +t[5], a = +t[6], t[7]) {
    for (c = t[7].slice(0, 3); c.length < 3; )
      c += "0";
    c = +c;
  }
  return t[9] && (l = +t[10], f = +(t[11] || 0), u = (l * 60 + f) * 6e4, t[9] === "-" && (u = -u)), m = new Date(Date.UTC(r, n, i, s, o, a, c)), u && m.setTime(m.getTime() - u), m;
}
function rJ(e) {
  return e.toISOString();
}
var IO = new QY("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: eJ,
  construct: tJ,
  instanceOf: Date,
  represent: rJ
}), nJ = sr;
function iJ(e) {
  return e === "<<" || e === null;
}
var NO = new nJ("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: iJ
}), sJ = sr, Gy = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function oJ(e) {
  if (e === null) return !1;
  var t, r, n = 0, i = e.length, s = Gy;
  for (r = 0; r < i; r++)
    if (t = s.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0) return !1;
      n += 6;
    }
  return n % 8 === 0;
}
function aJ(e) {
  var t, r, n = e.replace(/[\r\n=]/g, ""), i = n.length, s = Gy, o = 0, a = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(n.charAt(t));
  return r = i % 4 * 6, r === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : r === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : r === 12 && a.push(o >> 4 & 255), new Uint8Array(a);
}
function cJ(e) {
  var t = "", r = 0, n, i, s = e.length, o = Gy;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (t += o[r >> 18 & 63], t += o[r >> 12 & 63], t += o[r >> 6 & 63], t += o[r & 63]), r = (r << 8) + e[n];
  return i = s % 3, i === 0 ? (t += o[r >> 18 & 63], t += o[r >> 12 & 63], t += o[r >> 6 & 63], t += o[r & 63]) : i === 2 ? (t += o[r >> 10 & 63], t += o[r >> 4 & 63], t += o[r << 2 & 63], t += o[64]) : i === 1 && (t += o[r >> 2 & 63], t += o[r << 4 & 63], t += o[64], t += o[64]), t;
}
function lJ(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var kO = new sJ("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: oJ,
  construct: aJ,
  predicate: lJ,
  represent: cJ
}), uJ = sr, fJ = Object.prototype.hasOwnProperty, dJ = Object.prototype.toString;
function pJ(e) {
  if (e === null) return !0;
  var t = [], r, n, i, s, o, a = e;
  for (r = 0, n = a.length; r < n; r += 1) {
    if (i = a[r], o = !1, dJ.call(i) !== "[object Object]") return !1;
    for (s in i)
      if (fJ.call(i, s))
        if (!o) o = !0;
        else return !1;
    if (!o) return !1;
    if (t.indexOf(s) === -1) t.push(s);
    else return !1;
  }
  return !0;
}
function hJ(e) {
  return e !== null ? e : [];
}
var DO = new uJ("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: pJ,
  construct: hJ
}), mJ = sr, gJ = Object.prototype.toString;
function yJ(e) {
  if (e === null) return !0;
  var t, r, n, i, s, o = e;
  for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
    if (n = o[t], gJ.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return !1;
    s[t] = [i[0], n[i[0]]];
  }
  return !0;
}
function vJ(e) {
  if (e === null) return [];
  var t, r, n, i, s, o = e;
  for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
    n = o[t], i = Object.keys(n), s[t] = [i[0], n[i[0]]];
  return s;
}
var LO = new mJ("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: yJ,
  construct: vJ
}), _J = sr, bJ = Object.prototype.hasOwnProperty;
function EJ(e) {
  if (e === null) return !0;
  var t, r = e;
  for (t in r)
    if (bJ.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
function wJ(e) {
  return e !== null ? e : {};
}
var FO = new _J("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: EJ,
  construct: wJ
}), Wy = PO.extend({
  implicit: [
    IO,
    NO
  ],
  explicit: [
    kO,
    DO,
    LO,
    FO
  ]
}), Ci = Wr, jO = ac, SJ = bY, xJ = Wy, ri = Object.prototype.hasOwnProperty, lu = 1, UO = 2, MO = 3, uu = 4, Wp = 1, RJ = 2, Aw = 3, $J = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, TJ = /[\x85\u2028\u2029]/, OJ = /[,\[\]\{\}]/, HO = /^(?:!|!!|![a-z\-]+!)$/i, qO = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Iw(e) {
  return Object.prototype.toString.call(e);
}
function rn(e) {
  return e === 10 || e === 13;
}
function Ui(e) {
  return e === 9 || e === 32;
}
function ur(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Ts(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function PJ(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function CJ(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function AJ(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function Nw(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function IJ(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var BO = new Array(256), zO = new Array(256);
for (var hs = 0; hs < 256; hs++)
  BO[hs] = Nw(hs) ? 1 : 0, zO[hs] = Nw(hs);
function NJ(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || xJ, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function VO(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = SJ(r), new jO(t, r);
}
function pe(e, t) {
  throw VO(e, t);
}
function fu(e, t) {
  e.onWarning && e.onWarning.call(null, VO(e, t));
}
var kw = {
  YAML: function(t, r, n) {
    var i, s, o;
    t.version !== null && pe(t, "duplication of %YAML directive"), n.length !== 1 && pe(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && pe(t, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && pe(t, "unacceptable YAML version of the document"), t.version = n[0], t.checkLineBreaks = o < 2, o !== 1 && o !== 2 && fu(t, "unsupported YAML version of the document");
  },
  TAG: function(t, r, n) {
    var i, s;
    n.length !== 2 && pe(t, "TAG directive accepts exactly two arguments"), i = n[0], s = n[1], HO.test(i) || pe(t, "ill-formed tag handle (first argument) of the TAG directive"), ri.call(t.tagMap, i) && pe(t, 'there is a previously declared suffix for "' + i + '" tag handle'), qO.test(s) || pe(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      pe(t, "tag prefix is malformed: " + s);
    }
    t.tagMap[i] = s;
  }
};
function Xn(e, t, r, n) {
  var i, s, o, a;
  if (t < r) {
    if (a = e.input.slice(t, r), n)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || pe(e, "expected valid JSON character");
    else $J.test(a) && pe(e, "the stream contains non-printable characters");
    e.result += a;
  }
}
function Dw(e, t, r, n) {
  var i, s, o, a;
  for (Ci.isObject(r) || pe(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), o = 0, a = i.length; o < a; o += 1)
    s = i[o], ri.call(t, s) || (t[s] = r[s], n[s] = !0);
}
function Os(e, t, r, n, i, s, o, a, c) {
  var u, l;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, l = i.length; u < l; u += 1)
      Array.isArray(i[u]) && pe(e, "nested arrays are not supported inside keys"), typeof i == "object" && Iw(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && Iw(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (u = 0, l = s.length; u < l; u += 1)
        Dw(e, t, s[u], r);
    else
      Dw(e, t, s, r);
  else
    !e.json && !ri.call(r, i) && ri.call(t, i) && (e.line = o || e.line, e.lineStart = a || e.lineStart, e.position = c || e.position, pe(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : t[i] = s, delete r[i];
  return t;
}
function Ky(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : pe(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function ht(e, t, r) {
  for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Ui(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (rn(i))
      for (Ky(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && e.lineIndent < r && fu(e, "deficient indentation"), n;
}
function xf(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || ur(r)));
}
function Yy(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Ci.repeat(`
`, t - 1));
}
function kJ(e, t, r) {
  var n, i, s, o, a, c, u, l, f = e.kind, m = e.result, p;
  if (p = e.input.charCodeAt(e.position), ur(p) || Ts(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = e.input.charCodeAt(e.position + 1), ur(i) || r && Ts(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", s = o = e.position, a = !1; p !== 0; ) {
    if (p === 58) {
      if (i = e.input.charCodeAt(e.position + 1), ur(i) || r && Ts(i))
        break;
    } else if (p === 35) {
      if (n = e.input.charCodeAt(e.position - 1), ur(n))
        break;
    } else {
      if (e.position === e.lineStart && xf(e) || r && Ts(p))
        break;
      if (rn(p))
        if (c = e.line, u = e.lineStart, l = e.lineIndent, ht(e, !1, -1), e.lineIndent >= t) {
          a = !0, p = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = c, e.lineStart = u, e.lineIndent = l;
          break;
        }
    }
    a && (Xn(e, s, o, !1), Yy(e, e.line - c), s = o = e.position, a = !1), Ui(p) || (o = e.position + 1), p = e.input.charCodeAt(++e.position);
  }
  return Xn(e, s, o, !1), e.result ? !0 : (e.kind = f, e.result = m, !1);
}
function DJ(e, t) {
  var r, n, i;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = i = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (Xn(e, n, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        n = e.position, e.position++, i = e.position;
      else
        return !0;
    else rn(r) ? (Xn(e, n, i, !0), Yy(e, ht(e, !1, t)), n = i = e.position) : e.position === e.lineStart && xf(e) ? pe(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  pe(e, "unexpected end of the stream within a single quoted scalar");
}
function LJ(e, t) {
  var r, n, i, s, o, a;
  if (a = e.input.charCodeAt(e.position), a !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = n = e.position; (a = e.input.charCodeAt(e.position)) !== 0; ) {
    if (a === 34)
      return Xn(e, r, e.position, !0), e.position++, !0;
    if (a === 92) {
      if (Xn(e, r, e.position, !0), a = e.input.charCodeAt(++e.position), rn(a))
        ht(e, !1, t);
      else if (a < 256 && BO[a])
        e.result += zO[a], e.position++;
      else if ((o = CJ(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = e.input.charCodeAt(++e.position), (o = PJ(a)) >= 0 ? s = (s << 4) + o : pe(e, "expected hexadecimal character");
        e.result += IJ(s), e.position++;
      } else
        pe(e, "unknown escape sequence");
      r = n = e.position;
    } else rn(a) ? (Xn(e, r, n, !0), Yy(e, ht(e, !1, t)), r = n = e.position) : e.position === e.lineStart && xf(e) ? pe(e, "unexpected end of the document within a double quoted scalar") : (e.position++, n = e.position);
  }
  pe(e, "unexpected end of the stream within a double quoted scalar");
}
function FJ(e, t) {
  var r = !0, n, i, s, o = e.tag, a, c = e.anchor, u, l, f, m, p, d = /* @__PURE__ */ Object.create(null), h, _, g, v;
  if (v = e.input.charCodeAt(e.position), v === 91)
    l = 93, p = !1, a = [];
  else if (v === 123)
    l = 125, p = !0, a = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), v = e.input.charCodeAt(++e.position); v !== 0; ) {
    if (ht(e, !0, t), v = e.input.charCodeAt(e.position), v === l)
      return e.position++, e.tag = o, e.anchor = c, e.kind = p ? "mapping" : "sequence", e.result = a, !0;
    r ? v === 44 && pe(e, "expected the node content, but found ','") : pe(e, "missed comma between flow collection entries"), _ = h = g = null, f = m = !1, v === 63 && (u = e.input.charCodeAt(e.position + 1), ur(u) && (f = m = !0, e.position++, ht(e, !0, t))), n = e.line, i = e.lineStart, s = e.position, Xs(e, t, lu, !1, !0), _ = e.tag, h = e.result, ht(e, !0, t), v = e.input.charCodeAt(e.position), (m || e.line === n) && v === 58 && (f = !0, v = e.input.charCodeAt(++e.position), ht(e, !0, t), Xs(e, t, lu, !1, !0), g = e.result), p ? Os(e, a, d, _, h, g, n, i, s) : f ? a.push(Os(e, null, d, _, h, g, n, i, s)) : a.push(h), ht(e, !0, t), v = e.input.charCodeAt(e.position), v === 44 ? (r = !0, v = e.input.charCodeAt(++e.position)) : r = !1;
  }
  pe(e, "unexpected end of the stream within a flow collection");
}
function jJ(e, t) {
  var r, n, i = Wp, s = !1, o = !1, a = t, c = 0, u = !1, l, f;
  if (f = e.input.charCodeAt(e.position), f === 124)
    n = !1;
  else if (f === 62)
    n = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (f = e.input.charCodeAt(++e.position), f === 43 || f === 45)
      Wp === i ? i = f === 43 ? Aw : RJ : pe(e, "repeat of a chomping mode identifier");
    else if ((l = AJ(f)) >= 0)
      l === 0 ? pe(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? pe(e, "repeat of an indentation width identifier") : (a = t + l - 1, o = !0);
    else
      break;
  if (Ui(f)) {
    do
      f = e.input.charCodeAt(++e.position);
    while (Ui(f));
    if (f === 35)
      do
        f = e.input.charCodeAt(++e.position);
      while (!rn(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (Ky(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position); (!o || e.lineIndent < a) && f === 32; )
      e.lineIndent++, f = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > a && (a = e.lineIndent), rn(f)) {
      c++;
      continue;
    }
    if (e.lineIndent < a) {
      i === Aw ? e.result += Ci.repeat(`
`, s ? 1 + c : c) : i === Wp && s && (e.result += `
`);
      break;
    }
    for (n ? Ui(f) ? (u = !0, e.result += Ci.repeat(`
`, s ? 1 + c : c)) : u ? (u = !1, e.result += Ci.repeat(`
`, c + 1)) : c === 0 ? s && (e.result += " ") : e.result += Ci.repeat(`
`, c) : e.result += Ci.repeat(`
`, s ? 1 + c : c), s = !0, o = !0, c = 0, r = e.position; !rn(f) && f !== 0; )
      f = e.input.charCodeAt(++e.position);
    Xn(e, r, e.position, !1);
  }
  return !0;
}
function Lw(e, t) {
  var r, n = e.tag, i = e.anchor, s = [], o, a = !1, c;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), c = e.input.charCodeAt(e.position); c !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, pe(e, "tab characters must not be used in indentation")), !(c !== 45 || (o = e.input.charCodeAt(e.position + 1), !ur(o)))); ) {
    if (a = !0, e.position++, ht(e, !0, -1) && e.lineIndent <= t) {
      s.push(null), c = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, Xs(e, t, MO, !1, !0), s.push(e.result), ht(e, !0, -1), c = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && c !== 0)
      pe(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return a ? (e.tag = n, e.anchor = i, e.kind = "sequence", e.result = s, !0) : !1;
}
function UJ(e, t, r) {
  var n, i, s, o, a, c, u = e.tag, l = e.anchor, f = {}, m = /* @__PURE__ */ Object.create(null), p = null, d = null, h = null, _ = !1, g = !1, v;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = f), v = e.input.charCodeAt(e.position); v !== 0; ) {
    if (!_ && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, pe(e, "tab characters must not be used in indentation")), n = e.input.charCodeAt(e.position + 1), s = e.line, (v === 63 || v === 58) && ur(n))
      v === 63 ? (_ && (Os(e, f, m, p, d, null, o, a, c), p = d = h = null), g = !0, _ = !0, i = !0) : _ ? (_ = !1, i = !0) : pe(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, v = n;
    else {
      if (o = e.line, a = e.lineStart, c = e.position, !Xs(e, r, UO, !1, !0))
        break;
      if (e.line === s) {
        for (v = e.input.charCodeAt(e.position); Ui(v); )
          v = e.input.charCodeAt(++e.position);
        if (v === 58)
          v = e.input.charCodeAt(++e.position), ur(v) || pe(e, "a whitespace character is expected after the key-value separator within a block mapping"), _ && (Os(e, f, m, p, d, null, o, a, c), p = d = h = null), g = !0, _ = !1, i = !1, p = e.tag, d = e.result;
        else if (g)
          pe(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = u, e.anchor = l, !0;
      } else if (g)
        pe(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = u, e.anchor = l, !0;
    }
    if ((e.line === s || e.lineIndent > t) && (_ && (o = e.line, a = e.lineStart, c = e.position), Xs(e, t, uu, !0, i) && (_ ? d = e.result : h = e.result), _ || (Os(e, f, m, p, d, h, o, a, c), p = d = h = null), ht(e, !0, -1), v = e.input.charCodeAt(e.position)), (e.line === s || e.lineIndent > t) && v !== 0)
      pe(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return _ && Os(e, f, m, p, d, null, o, a, c), g && (e.tag = u, e.anchor = l, e.kind = "mapping", e.result = f), g;
}
function MJ(e) {
  var t, r = !1, n = !1, i, s, o;
  if (o = e.input.charCodeAt(e.position), o !== 33) return !1;
  if (e.tag !== null && pe(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (r = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (n = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, r) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (s = e.input.slice(t, e.position), o = e.input.charCodeAt(++e.position)) : pe(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !ur(o); )
      o === 33 && (n ? pe(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), HO.test(i) || pe(e, "named tag handle cannot contain such characters"), n = !0, t = e.position + 1)), o = e.input.charCodeAt(++e.position);
    s = e.input.slice(t, e.position), OJ.test(s) && pe(e, "tag suffix cannot contain flow indicator characters");
  }
  s && !qO.test(s) && pe(e, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    pe(e, "tag name is malformed: " + s);
  }
  return r ? e.tag = s : ri.call(e.tagMap, i) ? e.tag = e.tagMap[i] + s : i === "!" ? e.tag = "!" + s : i === "!!" ? e.tag = "tag:yaml.org,2002:" + s : pe(e, 'undeclared tag handle "' + i + '"'), !0;
}
function HJ(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38) return !1;
  for (e.anchor !== null && pe(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !ur(r) && !Ts(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && pe(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function qJ(e) {
  var t, r, n;
  if (n = e.input.charCodeAt(e.position), n !== 42) return !1;
  for (n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !ur(n) && !Ts(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && pe(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), ri.call(e.anchorMap, r) || pe(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], ht(e, !0, -1), !0;
}
function Xs(e, t, r, n, i) {
  var s, o, a, c = 1, u = !1, l = !1, f, m, p, d, h, _;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, s = o = a = uu === r || MO === r, n && ht(e, !0, -1) && (u = !0, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)), c === 1)
    for (; MJ(e) || HJ(e); )
      ht(e, !0, -1) ? (u = !0, a = s, e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)) : a = !1;
  if (a && (a = u || i), (c === 1 || uu === r) && (lu === r || UO === r ? h = t : h = t + 1, _ = e.position - e.lineStart, c === 1 ? a && (Lw(e, _) || UJ(e, _, h)) || FJ(e, h) ? l = !0 : (o && jJ(e, h) || DJ(e, h) || LJ(e, h) ? l = !0 : qJ(e) ? (l = !0, (e.tag !== null || e.anchor !== null) && pe(e, "alias node should not have any properties")) : kJ(e, h, lu === r) && (l = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : c === 0 && (l = a && Lw(e, _))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && pe(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), f = 0, m = e.implicitTypes.length; f < m; f += 1)
      if (d = e.implicitTypes[f], d.resolve(e.result)) {
        e.result = d.construct(e.result), e.tag = d.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (ri.call(e.typeMap[e.kind || "fallback"], e.tag))
      d = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (d = null, p = e.typeMap.multi[e.kind || "fallback"], f = 0, m = p.length; f < m; f += 1)
        if (e.tag.slice(0, p[f].tag.length) === p[f].tag) {
          d = p[f];
          break;
        }
    d || pe(e, "unknown tag !<" + e.tag + ">"), e.result !== null && d.kind !== e.kind && pe(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + d.kind + '", not "' + e.kind + '"'), d.resolve(e.result, e.tag) ? (e.result = d.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : pe(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || l;
}
function BJ(e) {
  var t = e.position, r, n, i, s = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (ht(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = e.input.charCodeAt(++e.position), r = e.position; o !== 0 && !ur(o); )
      o = e.input.charCodeAt(++e.position);
    for (n = e.input.slice(r, e.position), i = [], n.length < 1 && pe(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; Ui(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !rn(o));
        break;
      }
      if (rn(o)) break;
      for (r = e.position; o !== 0 && !ur(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(r, e.position));
    }
    o !== 0 && Ky(e), ri.call(kw, n) ? kw[n](e, n, i) : fu(e, 'unknown document directive "' + n + '"');
  }
  if (ht(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, ht(e, !0, -1)) : s && pe(e, "directives end mark is expected"), Xs(e, e.lineIndent - 1, uu, !1, !0), ht(e, !0, -1), e.checkLineBreaks && TJ.test(e.input.slice(t, e.position)) && fu(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && xf(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, ht(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    pe(e, "end of the stream or a document separator is expected");
  else
    return;
}
function GO(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new NJ(e, t), n = e.indexOf("\0");
  for (n !== -1 && (r.position = n, pe(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    BJ(r);
  return r.documents;
}
function zJ(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var n = GO(e, r);
  if (typeof t != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    t(n[i]);
}
function VJ(e, t) {
  var r = GO(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new jO("expected a single document in the stream, but found more");
  }
}
Vy.loadAll = zJ;
Vy.load = VJ;
var WO = {}, Rf = Wr, cc = ac, GJ = Wy, KO = Object.prototype.toString, YO = Object.prototype.hasOwnProperty, Jy = 65279, WJ = 9, wa = 10, KJ = 13, YJ = 32, JJ = 33, XJ = 34, Zh = 35, ZJ = 37, QJ = 38, eX = 39, tX = 42, JO = 44, rX = 45, du = 58, nX = 61, iX = 62, sX = 63, oX = 64, XO = 91, ZO = 93, aX = 96, QO = 123, cX = 124, eP = 125, Yt = {};
Yt[0] = "\\0";
Yt[7] = "\\a";
Yt[8] = "\\b";
Yt[9] = "\\t";
Yt[10] = "\\n";
Yt[11] = "\\v";
Yt[12] = "\\f";
Yt[13] = "\\r";
Yt[27] = "\\e";
Yt[34] = '\\"';
Yt[92] = "\\\\";
Yt[133] = "\\N";
Yt[160] = "\\_";
Yt[8232] = "\\L";
Yt[8233] = "\\P";
var lX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], uX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function fX(e, t) {
  var r, n, i, s, o, a, c;
  if (t === null) return {};
  for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
    o = n[i], a = String(t[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), c = e.compiledTypeMap.fallback[o], c && YO.call(c.styleAliases, a) && (a = c.styleAliases[a]), r[o] = a;
  return r;
}
function dX(e) {
  var t, r, n;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", n = 2;
  else if (e <= 65535)
    r = "u", n = 4;
  else if (e <= 4294967295)
    r = "U", n = 8;
  else
    throw new cc("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Rf.repeat("0", n - t.length) + t;
}
var pX = 1, Sa = 2;
function hX(e) {
  this.schema = e.schema || GJ, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = Rf.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = fX(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Sa : pX, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function Fw(e, t) {
  for (var r = Rf.repeat(" ", t), n = 0, i = -1, s = "", o, a = e.length; n < a; )
    i = e.indexOf(`
`, n), i === -1 ? (o = e.slice(n), n = a) : (o = e.slice(n, i + 1), n = i + 1), o.length && o !== `
` && (s += r), s += o;
  return s;
}
function Qh(e, t) {
  return `
` + Rf.repeat(" ", e.indent * t);
}
function mX(e, t) {
  var r, n, i;
  for (r = 0, n = e.implicitTypes.length; r < n; r += 1)
    if (i = e.implicitTypes[r], i.resolve(t))
      return !0;
  return !1;
}
function pu(e) {
  return e === YJ || e === WJ;
}
function xa(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== Jy || 65536 <= e && e <= 1114111;
}
function jw(e) {
  return xa(e) && e !== Jy && e !== KJ && e !== wa;
}
function Uw(e, t, r) {
  var n = jw(e), i = n && !pu(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && e !== JO && e !== XO && e !== ZO && e !== QO && e !== eP) && e !== Zh && !(t === du && !i) || jw(t) && !pu(t) && e === Zh || t === du && i
  );
}
function gX(e) {
  return xa(e) && e !== Jy && !pu(e) && e !== rX && e !== sX && e !== du && e !== JO && e !== XO && e !== ZO && e !== QO && e !== eP && e !== Zh && e !== QJ && e !== tX && e !== JJ && e !== cX && e !== nX && e !== iX && e !== eX && e !== XJ && e !== ZJ && e !== oX && e !== aX;
}
function yX(e) {
  return !pu(e) && e !== du;
}
function Go(e, t) {
  var r = e.charCodeAt(t), n;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (n = e.charCodeAt(t + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
function tP(e) {
  var t = /^\n* /;
  return t.test(e);
}
var rP = 1, em = 2, nP = 3, iP = 4, Ss = 5;
function vX(e, t, r, n, i, s, o, a) {
  var c, u = 0, l = null, f = !1, m = !1, p = n !== -1, d = -1, h = gX(Go(e, 0)) && yX(Go(e, e.length - 1));
  if (t || o)
    for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) {
      if (u = Go(e, c), !xa(u))
        return Ss;
      h = h && Uw(u, l, a), l = u;
    }
  else {
    for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) {
      if (u = Go(e, c), u === wa)
        f = !0, p && (m = m || // Foldable line = too long, and not more-indented.
        c - d - 1 > n && e[d + 1] !== " ", d = c);
      else if (!xa(u))
        return Ss;
      h = h && Uw(u, l, a), l = u;
    }
    m = m || p && c - d - 1 > n && e[d + 1] !== " ";
  }
  return !f && !m ? h && !o && !i(e) ? rP : s === Sa ? Ss : em : r > 9 && tP(e) ? Ss : o ? s === Sa ? Ss : em : m ? iP : nP;
}
function _X(e, t, r, n, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Sa ? '""' : "''";
    if (!e.noCompatMode && (lX.indexOf(t) !== -1 || uX.test(t)))
      return e.quotingType === Sa ? '"' + t + '"' : "'" + t + "'";
    var s = e.indent * Math.max(1, r), o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s), a = n || e.flowLevel > -1 && r >= e.flowLevel;
    function c(u) {
      return mX(e, u);
    }
    switch (vX(
      t,
      a,
      e.indent,
      o,
      c,
      e.quotingType,
      e.forceQuotes && !n,
      i
    )) {
      case rP:
        return t;
      case em:
        return "'" + t.replace(/'/g, "''") + "'";
      case nP:
        return "|" + Mw(t, e.indent) + Hw(Fw(t, s));
      case iP:
        return ">" + Mw(t, e.indent) + Hw(Fw(bX(t, o), s));
      case Ss:
        return '"' + EX(t) + '"';
      default:
        throw new cc("impossible error: invalid scalar style");
    }
  }();
}
function Mw(e, t) {
  var r = tP(e) ? String(t) : "", n = e[e.length - 1] === `
`, i = n && (e[e.length - 2] === `
` || e === `
`), s = i ? "+" : n ? "" : "-";
  return r + s + `
`;
}
function Hw(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function bX(e, t) {
  for (var r = /(\n+)([^\n]*)/g, n = function() {
    var u = e.indexOf(`
`);
    return u = u !== -1 ? u : e.length, r.lastIndex = u, qw(e.slice(0, u), t);
  }(), i = e[0] === `
` || e[0] === " ", s, o; o = r.exec(e); ) {
    var a = o[1], c = o[2];
    s = c[0] === " ", n += a + (!i && !s && c !== "" ? `
` : "") + qw(c, t), i = s;
  }
  return n;
}
function qw(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var r = / [^ ]/g, n, i = 0, s, o = 0, a = 0, c = ""; n = r.exec(e); )
    a = n.index, a - i > t && (s = o > i ? o : a, c += `
` + e.slice(i, s), i = s + 1), o = a;
  return c += `
`, e.length - i > t && o > i ? c += e.slice(i, o) + `
` + e.slice(o + 1) : c += e.slice(i), c.slice(1);
}
function EX(e) {
  for (var t = "", r = 0, n, i = 0; i < e.length; r >= 65536 ? i += 2 : i++)
    r = Go(e, i), n = Yt[r], !n && xa(r) ? (t += e[i], r >= 65536 && (t += e[i + 1])) : t += n || dX(r);
  return t;
}
function wX(e, t, r) {
  var n = "", i = e.tag, s, o, a;
  for (s = 0, o = r.length; s < o; s += 1)
    a = r[s], e.replacer && (a = e.replacer.call(r, String(s), a)), (wn(e, t, a, !1, !1) || typeof a > "u" && wn(e, t, null, !1, !1)) && (n !== "" && (n += "," + (e.condenseFlow ? "" : " ")), n += e.dump);
  e.tag = i, e.dump = "[" + n + "]";
}
function Bw(e, t, r, n) {
  var i = "", s = e.tag, o, a, c;
  for (o = 0, a = r.length; o < a; o += 1)
    c = r[o], e.replacer && (c = e.replacer.call(r, String(o), c)), (wn(e, t + 1, c, !0, !0, !1, !0) || typeof c > "u" && wn(e, t + 1, null, !0, !0, !1, !0)) && ((!n || i !== "") && (i += Qh(e, t)), e.dump && wa === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = s, e.dump = i || "[]";
}
function SX(e, t, r) {
  var n = "", i = e.tag, s = Object.keys(r), o, a, c, u, l;
  for (o = 0, a = s.length; o < a; o += 1)
    l = "", n !== "" && (l += ", "), e.condenseFlow && (l += '"'), c = s[o], u = r[c], e.replacer && (u = e.replacer.call(r, c, u)), wn(e, t, c, !1, !1) && (e.dump.length > 1024 && (l += "? "), l += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), wn(e, t, u, !1, !1) && (l += e.dump, n += l));
  e.tag = i, e.dump = "{" + n + "}";
}
function xX(e, t, r, n) {
  var i = "", s = e.tag, o = Object.keys(r), a, c, u, l, f, m;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new cc("sortKeys must be a boolean or a function");
  for (a = 0, c = o.length; a < c; a += 1)
    m = "", (!n || i !== "") && (m += Qh(e, t)), u = o[a], l = r[u], e.replacer && (l = e.replacer.call(r, u, l)), wn(e, t + 1, u, !0, !0, !0) && (f = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, f && (e.dump && wa === e.dump.charCodeAt(0) ? m += "?" : m += "? "), m += e.dump, f && (m += Qh(e, t)), wn(e, t + 1, l, !0, f) && (e.dump && wa === e.dump.charCodeAt(0) ? m += ":" : m += ": ", m += e.dump, i += m));
  e.tag = s, e.dump = i || "{}";
}
function zw(e, t, r) {
  var n, i, s, o, a, c;
  for (i = r ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (a = i[s], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof t == "object" && t instanceof a.instanceOf) && (!a.predicate || a.predicate(t))) {
      if (r ? a.multi && a.representName ? e.tag = a.representName(t) : e.tag = a.tag : e.tag = "?", a.represent) {
        if (c = e.styleMap[a.tag] || a.defaultStyle, KO.call(a.represent) === "[object Function]")
          n = a.represent(t, c);
        else if (YO.call(a.represent, c))
          n = a.represent[c](t, c);
        else
          throw new cc("!<" + a.tag + '> tag resolver accepts not "' + c + '" style');
        e.dump = n;
      }
      return !0;
    }
  return !1;
}
function wn(e, t, r, n, i, s, o) {
  e.tag = null, e.dump = r, zw(e, r, !1) || zw(e, r, !0);
  var a = KO.call(e.dump), c = n, u;
  n && (n = e.flowLevel < 0 || e.flowLevel > t);
  var l = a === "[object Object]" || a === "[object Array]", f, m;
  if (l && (f = e.duplicates.indexOf(r), m = f !== -1), (e.tag !== null && e.tag !== "?" || m || e.indent !== 2 && t > 0) && (i = !1), m && e.usedDuplicates[f])
    e.dump = "*ref_" + f;
  else {
    if (l && m && !e.usedDuplicates[f] && (e.usedDuplicates[f] = !0), a === "[object Object]")
      n && Object.keys(e.dump).length !== 0 ? (xX(e, t, e.dump, i), m && (e.dump = "&ref_" + f + e.dump)) : (SX(e, t, e.dump), m && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object Array]")
      n && e.dump.length !== 0 ? (e.noArrayIndent && !o && t > 0 ? Bw(e, t - 1, e.dump, i) : Bw(e, t, e.dump, i), m && (e.dump = "&ref_" + f + e.dump)) : (wX(e, t, e.dump), m && (e.dump = "&ref_" + f + " " + e.dump));
    else if (a === "[object String]")
      e.tag !== "?" && _X(e, e.dump, t, s, c);
    else {
      if (a === "[object Undefined]")
        return !1;
      if (e.skipInvalid) return !1;
      throw new cc("unacceptable kind of an object to dump " + a);
    }
    e.tag !== null && e.tag !== "?" && (u = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", e.dump = u + " " + e.dump);
  }
  return !0;
}
function RX(e, t) {
  var r = [], n = [], i, s;
  for (tm(e, r, n), i = 0, s = n.length; i < s; i += 1)
    t.duplicates.push(r[n[i]]);
  t.usedDuplicates = new Array(s);
}
function tm(e, t, r) {
  var n, i, s;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, s = e.length; i < s; i += 1)
        tm(e[i], t, r);
    else
      for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
        tm(e[n[i]], t, r);
}
function $X(e, t) {
  t = t || {};
  var r = new hX(t);
  r.noRefs || RX(e, r);
  var n = e;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), wn(r, 0, n, !0, !0) ? r.dump + `
` : "";
}
WO.dump = $X;
var sP = Vy, TX = WO;
function Xy(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
jt.Type = sr;
jt.Schema = vO;
jt.FAILSAFE_SCHEMA = wO;
jt.JSON_SCHEMA = OO;
jt.CORE_SCHEMA = PO;
jt.DEFAULT_SCHEMA = Wy;
jt.load = sP.load;
jt.loadAll = sP.loadAll;
jt.dump = TX.dump;
jt.YAMLException = ac;
jt.types = {
  binary: kO,
  float: TO,
  map: EO,
  null: SO,
  pairs: LO,
  set: FO,
  timestamp: IO,
  bool: xO,
  int: RO,
  merge: NO,
  omap: DO,
  seq: bO,
  str: _O
};
jt.safeLoad = Xy("safeLoad", "load");
jt.safeLoadAll = Xy("safeLoadAll", "loadAll");
jt.safeDump = Xy("safeDump", "dump");
var $f = {};
Object.defineProperty($f, "__esModule", { value: !0 });
$f.Lazy = void 0;
class OX {
  constructor(t) {
    this._value = null, this.creator = t;
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null)
      return this._value;
    const t = this.creator();
    return this.value = t, t;
  }
  set value(t) {
    this._value = t, this.creator = null;
  }
}
$f.Lazy = OX;
var lc = {}, hu = { exports: {} };
hu.exports;
(function(e, t) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", c = "[object Array]", u = "[object AsyncFunction]", l = "[object Boolean]", f = "[object Date]", m = "[object Error]", p = "[object Function]", d = "[object GeneratorFunction]", h = "[object Map]", _ = "[object Number]", g = "[object Null]", v = "[object Object]", y = "[object Promise]", E = "[object Proxy]", R = "[object RegExp]", w = "[object Set]", C = "[object String]", V = "[object Symbol]", b = "[object Undefined]", F = "[object WeakMap]", H = "[object ArrayBuffer]", q = "[object DataView]", $ = "[object Float32Array]", x = "[object Float64Array]", A = "[object Int8Array]", P = "[object Int16Array]", D = "[object Int32Array]", I = "[object Uint8Array]", L = "[object Uint8ClampedArray]", j = "[object Uint16Array]", k = "[object Uint32Array]", U = /[\\^$.*+?()[\]{}|]/g, M = /^\[object .+?Constructor\]$/, T = /^(?:0|[1-9]\d*)$/, N = {};
  N[$] = N[x] = N[A] = N[P] = N[D] = N[I] = N[L] = N[j] = N[k] = !0, N[a] = N[c] = N[H] = N[l] = N[q] = N[f] = N[m] = N[p] = N[h] = N[_] = N[v] = N[R] = N[w] = N[C] = N[F] = !1;
  var G = typeof me == "object" && me && me.Object === Object && me, O = typeof self == "object" && self && self.Object === Object && self, S = G || O || Function("return this")(), W = t && !t.nodeType && t, z = W && !0 && e && !e.nodeType && e, Q = z && z.exports === W, K = Q && G.process, X = function() {
    try {
      return K && K.binding && K.binding("util");
    } catch {
    }
  }(), J = X && X.isTypedArray;
  function re(B, Y) {
    for (var te = -1, ce = B == null ? 0 : B.length, We = 0, Ee = []; ++te < ce; ) {
      var rt = B[te];
      Y(rt, te, B) && (Ee[We++] = rt);
    }
    return Ee;
  }
  function fe(B, Y) {
    for (var te = -1, ce = Y.length, We = B.length; ++te < ce; )
      B[We + te] = Y[te];
    return B;
  }
  function ee(B, Y) {
    for (var te = -1, ce = B == null ? 0 : B.length; ++te < ce; )
      if (Y(B[te], te, B))
        return !0;
    return !1;
  }
  function le(B, Y) {
    for (var te = -1, ce = Array(B); ++te < B; )
      ce[te] = Y(te);
    return ce;
  }
  function xe(B) {
    return function(Y) {
      return B(Y);
    };
  }
  function ye(B, Y) {
    return B.has(Y);
  }
  function ve(B, Y) {
    return B == null ? void 0 : B[Y];
  }
  function ze(B) {
    var Y = -1, te = Array(B.size);
    return B.forEach(function(ce, We) {
      te[++Y] = [We, ce];
    }), te;
  }
  function Ae(B, Y) {
    return function(te) {
      return B(Y(te));
    };
  }
  function $t(B) {
    var Y = -1, te = Array(B.size);
    return B.forEach(function(ce) {
      te[++Y] = ce;
    }), te;
  }
  var $n = Array.prototype, Le = Function.prototype, Ut = Object.prototype, Er = S["__core-js_shared__"], Ne = Le.toString, je = Ut.hasOwnProperty, mo = function() {
    var B = /[^.]+$/.exec(Er && Er.keys && Er.keys.IE_PROTO || "");
    return B ? "Symbol(src)_1." + B : "";
  }(), Mt = Ut.toString, dr = RegExp(
    "^" + Ne.call(je).replace(U, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), go = Q ? S.Buffer : void 0, Ye = S.Symbol, ts = S.Uint8Array, ai = Ut.propertyIsEnumerable, _t = $n.splice, wr = Ye ? Ye.toStringTag : void 0, pc = Object.getOwnPropertySymbols, Tn = go ? go.isBuffer : void 0, Jt = Ae(Object.keys, Object), kr = rs(S, "DataView"), Ht = rs(S, "Map"), Sr = rs(S, "Promise"), ln = rs(S, "Set"), or = rs(S, "WeakMap"), ci = rs(Object, "create"), Df = fi(kr), hc = fi(Ht), yo = fi(Sr), mc = fi(ln), Lf = fi(or), vo = Ye ? Ye.prototype : void 0, _o = vo ? vo.valueOf : void 0;
  function li(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.clear(); ++Y < te; ) {
      var ce = B[Y];
      this.set(ce[0], ce[1]);
    }
  }
  function bP() {
    this.__data__ = ci ? ci(null) : {}, this.size = 0;
  }
  function EP(B) {
    var Y = this.has(B) && delete this.__data__[B];
    return this.size -= Y ? 1 : 0, Y;
  }
  function wP(B) {
    var Y = this.__data__;
    if (ci) {
      var te = Y[B];
      return te === n ? void 0 : te;
    }
    return je.call(Y, B) ? Y[B] : void 0;
  }
  function SP(B) {
    var Y = this.__data__;
    return ci ? Y[B] !== void 0 : je.call(Y, B);
  }
  function xP(B, Y) {
    var te = this.__data__;
    return this.size += this.has(B) ? 0 : 1, te[B] = ci && Y === void 0 ? n : Y, this;
  }
  li.prototype.clear = bP, li.prototype.delete = EP, li.prototype.get = wP, li.prototype.has = SP, li.prototype.set = xP;
  function un(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.clear(); ++Y < te; ) {
      var ce = B[Y];
      this.set(ce[0], ce[1]);
    }
  }
  function RP() {
    this.__data__ = [], this.size = 0;
  }
  function $P(B) {
    var Y = this.__data__, te = yc(Y, B);
    if (te < 0)
      return !1;
    var ce = Y.length - 1;
    return te == ce ? Y.pop() : _t.call(Y, te, 1), --this.size, !0;
  }
  function TP(B) {
    var Y = this.__data__, te = yc(Y, B);
    return te < 0 ? void 0 : Y[te][1];
  }
  function OP(B) {
    return yc(this.__data__, B) > -1;
  }
  function PP(B, Y) {
    var te = this.__data__, ce = yc(te, B);
    return ce < 0 ? (++this.size, te.push([B, Y])) : te[ce][1] = Y, this;
  }
  un.prototype.clear = RP, un.prototype.delete = $P, un.prototype.get = TP, un.prototype.has = OP, un.prototype.set = PP;
  function ui(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.clear(); ++Y < te; ) {
      var ce = B[Y];
      this.set(ce[0], ce[1]);
    }
  }
  function CP() {
    this.size = 0, this.__data__ = {
      hash: new li(),
      map: new (Ht || un)(),
      string: new li()
    };
  }
  function AP(B) {
    var Y = vc(this, B).delete(B);
    return this.size -= Y ? 1 : 0, Y;
  }
  function IP(B) {
    return vc(this, B).get(B);
  }
  function NP(B) {
    return vc(this, B).has(B);
  }
  function kP(B, Y) {
    var te = vc(this, B), ce = te.size;
    return te.set(B, Y), this.size += te.size == ce ? 0 : 1, this;
  }
  ui.prototype.clear = CP, ui.prototype.delete = AP, ui.prototype.get = IP, ui.prototype.has = NP, ui.prototype.set = kP;
  function gc(B) {
    var Y = -1, te = B == null ? 0 : B.length;
    for (this.__data__ = new ui(); ++Y < te; )
      this.add(B[Y]);
  }
  function DP(B) {
    return this.__data__.set(B, n), this;
  }
  function LP(B) {
    return this.__data__.has(B);
  }
  gc.prototype.add = gc.prototype.push = DP, gc.prototype.has = LP;
  function On(B) {
    var Y = this.__data__ = new un(B);
    this.size = Y.size;
  }
  function FP() {
    this.__data__ = new un(), this.size = 0;
  }
  function jP(B) {
    var Y = this.__data__, te = Y.delete(B);
    return this.size = Y.size, te;
  }
  function UP(B) {
    return this.__data__.get(B);
  }
  function MP(B) {
    return this.__data__.has(B);
  }
  function HP(B, Y) {
    var te = this.__data__;
    if (te instanceof un) {
      var ce = te.__data__;
      if (!Ht || ce.length < r - 1)
        return ce.push([B, Y]), this.size = ++te.size, this;
      te = this.__data__ = new ui(ce);
    }
    return te.set(B, Y), this.size = te.size, this;
  }
  On.prototype.clear = FP, On.prototype.delete = jP, On.prototype.get = UP, On.prototype.has = MP, On.prototype.set = HP;
  function qP(B, Y) {
    var te = _c(B), ce = !te && nC(B), We = !te && !ce && Ff(B), Ee = !te && !ce && !We && lv(B), rt = te || ce || We || Ee, bt = rt ? le(B.length, String) : [], Tt = bt.length;
    for (var Je in B)
      je.call(B, Je) && !(rt && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Je == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      We && (Je == "offset" || Je == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ee && (Je == "buffer" || Je == "byteLength" || Je == "byteOffset") || // Skip index properties.
      ZP(Je, Tt))) && bt.push(Je);
    return bt;
  }
  function yc(B, Y) {
    for (var te = B.length; te--; )
      if (sv(B[te][0], Y))
        return te;
    return -1;
  }
  function BP(B, Y, te) {
    var ce = Y(B);
    return _c(B) ? ce : fe(ce, te(B));
  }
  function bo(B) {
    return B == null ? B === void 0 ? b : g : wr && wr in Object(B) ? JP(B) : rC(B);
  }
  function tv(B) {
    return Eo(B) && bo(B) == a;
  }
  function rv(B, Y, te, ce, We) {
    return B === Y ? !0 : B == null || Y == null || !Eo(B) && !Eo(Y) ? B !== B && Y !== Y : zP(B, Y, te, ce, rv, We);
  }
  function zP(B, Y, te, ce, We, Ee) {
    var rt = _c(B), bt = _c(Y), Tt = rt ? c : Pn(B), Je = bt ? c : Pn(Y);
    Tt = Tt == a ? v : Tt, Je = Je == a ? v : Je;
    var pr = Tt == v, Dr = Je == v, qt = Tt == Je;
    if (qt && Ff(B)) {
      if (!Ff(Y))
        return !1;
      rt = !0, pr = !1;
    }
    if (qt && !pr)
      return Ee || (Ee = new On()), rt || lv(B) ? nv(B, Y, te, ce, We, Ee) : KP(B, Y, Tt, te, ce, We, Ee);
    if (!(te & i)) {
      var xr = pr && je.call(B, "__wrapped__"), Rr = Dr && je.call(Y, "__wrapped__");
      if (xr || Rr) {
        var Cn = xr ? B.value() : B, fn = Rr ? Y.value() : Y;
        return Ee || (Ee = new On()), We(Cn, fn, te, ce, Ee);
      }
    }
    return qt ? (Ee || (Ee = new On()), YP(B, Y, te, ce, We, Ee)) : !1;
  }
  function VP(B) {
    if (!cv(B) || eC(B))
      return !1;
    var Y = ov(B) ? dr : M;
    return Y.test(fi(B));
  }
  function GP(B) {
    return Eo(B) && av(B.length) && !!N[bo(B)];
  }
  function WP(B) {
    if (!tC(B))
      return Jt(B);
    var Y = [];
    for (var te in Object(B))
      je.call(B, te) && te != "constructor" && Y.push(te);
    return Y;
  }
  function nv(B, Y, te, ce, We, Ee) {
    var rt = te & i, bt = B.length, Tt = Y.length;
    if (bt != Tt && !(rt && Tt > bt))
      return !1;
    var Je = Ee.get(B);
    if (Je && Ee.get(Y))
      return Je == Y;
    var pr = -1, Dr = !0, qt = te & s ? new gc() : void 0;
    for (Ee.set(B, Y), Ee.set(Y, B); ++pr < bt; ) {
      var xr = B[pr], Rr = Y[pr];
      if (ce)
        var Cn = rt ? ce(Rr, xr, pr, Y, B, Ee) : ce(xr, Rr, pr, B, Y, Ee);
      if (Cn !== void 0) {
        if (Cn)
          continue;
        Dr = !1;
        break;
      }
      if (qt) {
        if (!ee(Y, function(fn, di) {
          if (!ye(qt, di) && (xr === fn || We(xr, fn, te, ce, Ee)))
            return qt.push(di);
        })) {
          Dr = !1;
          break;
        }
      } else if (!(xr === Rr || We(xr, Rr, te, ce, Ee))) {
        Dr = !1;
        break;
      }
    }
    return Ee.delete(B), Ee.delete(Y), Dr;
  }
  function KP(B, Y, te, ce, We, Ee, rt) {
    switch (te) {
      case q:
        if (B.byteLength != Y.byteLength || B.byteOffset != Y.byteOffset)
          return !1;
        B = B.buffer, Y = Y.buffer;
      case H:
        return !(B.byteLength != Y.byteLength || !Ee(new ts(B), new ts(Y)));
      case l:
      case f:
      case _:
        return sv(+B, +Y);
      case m:
        return B.name == Y.name && B.message == Y.message;
      case R:
      case C:
        return B == Y + "";
      case h:
        var bt = ze;
      case w:
        var Tt = ce & i;
        if (bt || (bt = $t), B.size != Y.size && !Tt)
          return !1;
        var Je = rt.get(B);
        if (Je)
          return Je == Y;
        ce |= s, rt.set(B, Y);
        var pr = nv(bt(B), bt(Y), ce, We, Ee, rt);
        return rt.delete(B), pr;
      case V:
        if (_o)
          return _o.call(B) == _o.call(Y);
    }
    return !1;
  }
  function YP(B, Y, te, ce, We, Ee) {
    var rt = te & i, bt = iv(B), Tt = bt.length, Je = iv(Y), pr = Je.length;
    if (Tt != pr && !rt)
      return !1;
    for (var Dr = Tt; Dr--; ) {
      var qt = bt[Dr];
      if (!(rt ? qt in Y : je.call(Y, qt)))
        return !1;
    }
    var xr = Ee.get(B);
    if (xr && Ee.get(Y))
      return xr == Y;
    var Rr = !0;
    Ee.set(B, Y), Ee.set(Y, B);
    for (var Cn = rt; ++Dr < Tt; ) {
      qt = bt[Dr];
      var fn = B[qt], di = Y[qt];
      if (ce)
        var uv = rt ? ce(di, fn, qt, Y, B, Ee) : ce(fn, di, qt, B, Y, Ee);
      if (!(uv === void 0 ? fn === di || We(fn, di, te, ce, Ee) : uv)) {
        Rr = !1;
        break;
      }
      Cn || (Cn = qt == "constructor");
    }
    if (Rr && !Cn) {
      var bc = B.constructor, Ec = Y.constructor;
      bc != Ec && "constructor" in B && "constructor" in Y && !(typeof bc == "function" && bc instanceof bc && typeof Ec == "function" && Ec instanceof Ec) && (Rr = !1);
    }
    return Ee.delete(B), Ee.delete(Y), Rr;
  }
  function iv(B) {
    return BP(B, oC, XP);
  }
  function vc(B, Y) {
    var te = B.__data__;
    return QP(Y) ? te[typeof Y == "string" ? "string" : "hash"] : te.map;
  }
  function rs(B, Y) {
    var te = ve(B, Y);
    return VP(te) ? te : void 0;
  }
  function JP(B) {
    var Y = je.call(B, wr), te = B[wr];
    try {
      B[wr] = void 0;
      var ce = !0;
    } catch {
    }
    var We = Mt.call(B);
    return ce && (Y ? B[wr] = te : delete B[wr]), We;
  }
  var XP = pc ? function(B) {
    return B == null ? [] : (B = Object(B), re(pc(B), function(Y) {
      return ai.call(B, Y);
    }));
  } : aC, Pn = bo;
  (kr && Pn(new kr(new ArrayBuffer(1))) != q || Ht && Pn(new Ht()) != h || Sr && Pn(Sr.resolve()) != y || ln && Pn(new ln()) != w || or && Pn(new or()) != F) && (Pn = function(B) {
    var Y = bo(B), te = Y == v ? B.constructor : void 0, ce = te ? fi(te) : "";
    if (ce)
      switch (ce) {
        case Df:
          return q;
        case hc:
          return h;
        case yo:
          return y;
        case mc:
          return w;
        case Lf:
          return F;
      }
    return Y;
  });
  function ZP(B, Y) {
    return Y = Y ?? o, !!Y && (typeof B == "number" || T.test(B)) && B > -1 && B % 1 == 0 && B < Y;
  }
  function QP(B) {
    var Y = typeof B;
    return Y == "string" || Y == "number" || Y == "symbol" || Y == "boolean" ? B !== "__proto__" : B === null;
  }
  function eC(B) {
    return !!mo && mo in B;
  }
  function tC(B) {
    var Y = B && B.constructor, te = typeof Y == "function" && Y.prototype || Ut;
    return B === te;
  }
  function rC(B) {
    return Mt.call(B);
  }
  function fi(B) {
    if (B != null) {
      try {
        return Ne.call(B);
      } catch {
      }
      try {
        return B + "";
      } catch {
      }
    }
    return "";
  }
  function sv(B, Y) {
    return B === Y || B !== B && Y !== Y;
  }
  var nC = tv(/* @__PURE__ */ function() {
    return arguments;
  }()) ? tv : function(B) {
    return Eo(B) && je.call(B, "callee") && !ai.call(B, "callee");
  }, _c = Array.isArray;
  function iC(B) {
    return B != null && av(B.length) && !ov(B);
  }
  var Ff = Tn || cC;
  function sC(B, Y) {
    return rv(B, Y);
  }
  function ov(B) {
    if (!cv(B))
      return !1;
    var Y = bo(B);
    return Y == p || Y == d || Y == u || Y == E;
  }
  function av(B) {
    return typeof B == "number" && B > -1 && B % 1 == 0 && B <= o;
  }
  function cv(B) {
    var Y = typeof B;
    return B != null && (Y == "object" || Y == "function");
  }
  function Eo(B) {
    return B != null && typeof B == "object";
  }
  var lv = J ? xe(J) : GP;
  function oC(B) {
    return iC(B) ? qP(B) : WP(B);
  }
  function aC() {
    return [];
  }
  function cC() {
    return !1;
  }
  e.exports = sC;
})(hu, hu.exports);
var PX = hu.exports;
Object.defineProperty(lc, "__esModule", { value: !0 });
lc.DownloadedUpdateHelper = void 0;
lc.createTempUpdateFile = kX;
const CX = Ki, AX = Ue, Vw = PX, xi = si, na = _e;
class IX {
  constructor(t) {
    this.cacheDir = t, this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, this._downloadedFileInfo = null;
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return na.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(t, r, n, i) {
    if (this.versionInfo != null && this.file === t && this.fileInfo != null)
      return Vw(this.versionInfo, r) && Vw(this.fileInfo.info, n.info) && await (0, xi.pathExists)(t) ? t : null;
    const s = await this.getValidCachedUpdateFile(n, i);
    return s === null ? null : (i.info(`Update has already been downloaded to ${t}).`), this._file = s, s);
  }
  async setDownloadedFile(t, r, n, i, s, o) {
    this._file = t, this._packageFile = r, this.versionInfo = n, this.fileInfo = i, this._downloadedFileInfo = {
      fileName: s,
      sha512: i.info.sha512,
      isAdminRightsRequired: i.info.isAdminRightsRequired === !0
    }, o && await (0, xi.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
  }
  async clear() {
    this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, xi.emptyDir)(this.cacheDirForPendingUpdate);
    } catch {
    }
  }
  /**
   * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
   * @param fileInfo
   * @param logger
   */
  async getValidCachedUpdateFile(t, r) {
    const n = this.getUpdateInfoFile();
    if (!await (0, xi.pathExists)(n))
      return null;
    let s;
    try {
      s = await (0, xi.readJson)(n);
    } catch (u) {
      let l = "No cached update info available";
      return u.code !== "ENOENT" && (await this.cleanCacheDirForPendingUpdate(), l += ` (error on read: ${u.message})`), r.info(l), null;
    }
    if (!((s == null ? void 0 : s.fileName) !== null))
      return r.warn("Cached update info is corrupted: no fileName, directory for cached update will be cleaned"), await this.cleanCacheDirForPendingUpdate(), null;
    if (t.info.sha512 !== s.sha512)
      return r.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${s.sha512}, expected: ${t.info.sha512}. Directory for cached update will be cleaned`), await this.cleanCacheDirForPendingUpdate(), null;
    const a = na.join(this.cacheDirForPendingUpdate, s.fileName);
    if (!await (0, xi.pathExists)(a))
      return r.info("Cached update file doesn't exist"), null;
    const c = await NX(a);
    return t.info.sha512 !== c ? (r.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${c}, expected: ${t.info.sha512}`), await this.cleanCacheDirForPendingUpdate(), null) : (this._downloadedFileInfo = s, a);
  }
  getUpdateInfoFile() {
    return na.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
lc.DownloadedUpdateHelper = IX;
function NX(e, t = "sha512", r = "base64", n) {
  return new Promise((i, s) => {
    const o = (0, CX.createHash)(t);
    o.on("error", s).setEncoding(r), (0, AX.createReadStream)(e, {
      ...n,
      highWaterMark: 1024 * 1024
      /* better to use more memory but hash faster */
    }).on("error", s).on("end", () => {
      o.end(), i(o.read());
    }).pipe(o, { end: !1 });
  });
}
async function kX(e, t, r) {
  let n = 0, i = na.join(t, e);
  for (let s = 0; s < 3; s++)
    try {
      return await (0, xi.unlink)(i), i;
    } catch (o) {
      if (o.code === "ENOENT")
        return i;
      r.warn(`Error on remove temp update file: ${o}`), i = na.join(t, `${n++}-${e}`);
    }
  return i;
}
var Tf = {}, Zy = {};
Object.defineProperty(Zy, "__esModule", { value: !0 });
Zy.getAppCacheDir = LX;
const Kp = _e, DX = _u;
function LX() {
  const e = (0, DX.homedir)();
  let t;
  return process.platform === "win32" ? t = process.env.LOCALAPPDATA || Kp.join(e, "AppData", "Local") : process.platform === "darwin" ? t = Kp.join(e, "Library", "Caches") : t = process.env.XDG_CACHE_HOME || Kp.join(e, ".cache"), t;
}
Object.defineProperty(Tf, "__esModule", { value: !0 });
Tf.ElectronAppAdapter = void 0;
const Gw = _e, FX = Zy;
class jX {
  constructor(t = Mi.app) {
    this.app = t;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === !0;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? Gw.join(process.resourcesPath, "app-update.yml") : Gw.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return (0, FX.getAppCacheDir)();
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(t) {
    this.app.once("quit", (r, n) => t(n));
  }
}
Tf.ElectronAppAdapter = jX;
var oP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ElectronHttpExecutor = e.NET_SESSION_NAME = void 0, e.getNetSession = r;
  const t = Rt;
  e.NET_SESSION_NAME = "electron-updater";
  function r() {
    return Mi.session.fromPartition(e.NET_SESSION_NAME, {
      cache: !1
    });
  }
  class n extends t.HttpExecutor {
    constructor(s) {
      super(), this.proxyLoginCallback = s, this.cachedSession = null;
    }
    async download(s, o, a) {
      return await a.cancellationToken.createPromise((c, u, l) => {
        const f = {
          headers: a.headers || void 0,
          redirect: "manual"
        };
        (0, t.configureRequestUrl)(s, f), (0, t.configureRequestOptions)(f), this.doDownload(f, {
          destination: o,
          options: a,
          onCancel: l,
          callback: (m) => {
            m == null ? c(o) : u(m);
          },
          responseHandler: null
        }, 0);
      });
    }
    createRequest(s, o) {
      s.headers && s.headers.Host && (s.host = s.headers.Host, delete s.headers.Host), this.cachedSession == null && (this.cachedSession = r());
      const a = Mi.net.request({
        ...s,
        session: this.cachedSession
      });
      return a.on("response", o), this.proxyLoginCallback != null && a.on("login", this.proxyLoginCallback), a;
    }
    addRedirectHandlers(s, o, a, c, u) {
      s.on("redirect", (l, f, m) => {
        s.abort(), c > this.maxRedirects ? a(this.createMaxRedirectError()) : u(t.HttpExecutor.prepareRedirectUrlOptions(m, o));
      });
    }
  }
  e.ElectronHttpExecutor = n;
})(oP);
var uc = {}, Nr = {}, UX = "[object Symbol]", aP = /[\\^$.*+?()[\]{}|]/g, MX = RegExp(aP.source), HX = typeof me == "object" && me && me.Object === Object && me, qX = typeof self == "object" && self && self.Object === Object && self, BX = HX || qX || Function("return this")(), zX = Object.prototype, VX = zX.toString, Ww = BX.Symbol, Kw = Ww ? Ww.prototype : void 0, Yw = Kw ? Kw.toString : void 0;
function GX(e) {
  if (typeof e == "string")
    return e;
  if (KX(e))
    return Yw ? Yw.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function WX(e) {
  return !!e && typeof e == "object";
}
function KX(e) {
  return typeof e == "symbol" || WX(e) && VX.call(e) == UX;
}
function YX(e) {
  return e == null ? "" : GX(e);
}
function JX(e) {
  return e = YX(e), e && MX.test(e) ? e.replace(aP, "\\$&") : e;
}
var XX = JX;
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.newBaseUrl = QX;
Nr.newUrlFromBase = rm;
Nr.getChannelFilename = eZ;
Nr.blockmapFiles = tZ;
const cP = qr, ZX = XX;
function QX(e) {
  const t = new cP.URL(e);
  return t.pathname.endsWith("/") || (t.pathname += "/"), t;
}
function rm(e, t, r = !1) {
  const n = new cP.URL(e, t), i = t.search;
  return i != null && i.length !== 0 ? n.search = i : r && (n.search = `noCache=${Date.now().toString(32)}`), n;
}
function eZ(e) {
  return `${e}.yml`;
}
function tZ(e, t, r) {
  const n = rm(`${e.pathname}.blockmap`, e);
  return [rm(`${e.pathname.replace(new RegExp(ZX(r), "g"), t)}.blockmap`, e), n];
}
var vt = {};
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.Provider = void 0;
vt.findFile = iZ;
vt.parseUpdateInfo = sZ;
vt.getFileList = lP;
vt.resolveFiles = oZ;
const ni = Rt, rZ = jt, Jw = Nr;
class nZ {
  constructor(t) {
    this.runtimeOptions = t, this.requestHeaders = null, this.executor = t.executor;
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== !1;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const t = process.env.TEST_UPDATER_ARCH || process.arch;
      return "-linux" + (t === "x64" ? "" : `-${t}`);
    } else
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
  }
  // due to historical reasons for windows we use channel name without platform specifier
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(t) {
    return `${t}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(t) {
    this.requestHeaders = t;
  }
  /**
   * Method to perform API request only to resolve update info, but not to download update.
   */
  httpRequest(t, r, n) {
    return this.executor.request(this.createRequestOptions(t, r), n);
  }
  createRequestOptions(t, r) {
    const n = {};
    return this.requestHeaders == null ? r != null && (n.headers = r) : n.headers = r == null ? this.requestHeaders : { ...this.requestHeaders, ...r }, (0, ni.configureRequestUrl)(t, n), n;
  }
}
vt.Provider = nZ;
function iZ(e, t, r) {
  if (e.length === 0)
    throw (0, ni.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  const n = e.find((i) => i.url.pathname.toLowerCase().endsWith(`.${t}`));
  return n ?? (r == null ? e[0] : e.find((i) => !r.some((s) => i.url.pathname.toLowerCase().endsWith(`.${s}`))));
}
function sZ(e, t, r) {
  if (e == null)
    throw (0, ni.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${r}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  let n;
  try {
    n = (0, rZ.load)(e);
  } catch (i) {
    throw (0, ni.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${r}): ${i.stack || i.message}, rawData: ${e}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  return n;
}
function lP(e) {
  const t = e.files;
  if (t != null && t.length > 0)
    return t;
  if (e.path != null)
    return [
      {
        url: e.path,
        sha2: e.sha2,
        sha512: e.sha512
      }
    ];
  throw (0, ni.newError)(`No files provided: ${(0, ni.safeStringifyJson)(e)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
}
function oZ(e, t, r = (n) => n) {
  const i = lP(e).map((a) => {
    if (a.sha2 == null && a.sha512 == null)
      throw (0, ni.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, ni.safeStringifyJson)(a)}`, "ERR_UPDATER_NO_CHECKSUM");
    return {
      url: (0, Jw.newUrlFromBase)(r(a.url), t),
      info: a
    };
  }), s = e.packages, o = s == null ? null : s[process.arch] || s.ia32;
  return o != null && (i[0].packageInfo = {
    ...o,
    path: (0, Jw.newUrlFromBase)(r(o.path), t).href
  }), i;
}
Object.defineProperty(uc, "__esModule", { value: !0 });
uc.GenericProvider = void 0;
const Xw = Rt, Yp = Nr, Jp = vt;
class aZ extends Jp.Provider {
  constructor(t, r, n) {
    super(n), this.configuration = t, this.updater = r, this.baseUrl = (0, Yp.newBaseUrl)(this.configuration.url);
  }
  get channel() {
    const t = this.updater.channel || this.configuration.channel;
    return t == null ? this.getDefaultChannelName() : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    const t = (0, Yp.getChannelFilename)(this.channel), r = (0, Yp.newUrlFromBase)(t, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let n = 0; ; n++)
      try {
        return (0, Jp.parseUpdateInfo)(await this.httpRequest(r), t, r);
      } catch (i) {
        if (i instanceof Xw.HttpError && i.statusCode === 404)
          throw (0, Xw.newError)(`Cannot find channel "${t}" update info: ${i.stack || i.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        if (i.code === "ECONNREFUSED" && n < 3) {
          await new Promise((s, o) => {
            try {
              setTimeout(s, 1e3 * n);
            } catch (a) {
              o(a);
            }
          });
          continue;
        }
        throw i;
      }
  }
  resolveFiles(t) {
    return (0, Jp.resolveFiles)(t, this.baseUrl);
  }
}
uc.GenericProvider = aZ;
var Of = {}, Pf = {};
Object.defineProperty(Pf, "__esModule", { value: !0 });
Pf.BitbucketProvider = void 0;
const Zw = Rt, Xp = Nr, Zp = vt;
class cZ extends Zp.Provider {
  constructor(t, r, n) {
    super({
      ...n,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = r;
    const { owner: i, slug: s } = t;
    this.baseUrl = (0, Xp.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${i}/${s}/downloads`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const t = new Zw.CancellationToken(), r = (0, Xp.getChannelFilename)(this.getCustomChannelName(this.channel)), n = (0, Xp.newUrlFromBase)(r, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(n, void 0, t);
      return (0, Zp.parseUpdateInfo)(i, r, n);
    } catch (i) {
      throw (0, Zw.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, Zp.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { owner: t, slug: r } = this.configuration;
    return `Bitbucket (owner: ${t}, slug: ${r}, channel: ${this.channel})`;
  }
}
Pf.BitbucketProvider = cZ;
var ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.GitHubProvider = ii.BaseGitHubProvider = void 0;
ii.computeReleaseNotes = fP;
const dn = Rt, Ps = ay, lZ = qr, Cs = Nr, nm = vt, Qp = /\/tag\/([^/]+)$/;
class uP extends nm.Provider {
  constructor(t, r, n) {
    super({
      ...n,
      /* because GitHib uses S3 */
      isUseMultipleRangeRequest: !1
    }), this.options = t, this.baseUrl = (0, Cs.newBaseUrl)((0, dn.githubUrl)(t, r));
    const i = r === "github.com" ? "api.github.com" : r;
    this.baseApiUrl = (0, Cs.newBaseUrl)((0, dn.githubUrl)(t, i));
  }
  computeGithubBasePath(t) {
    const r = this.options.host;
    return r && !["github.com", "api.github.com"].includes(r) ? `/api/v3${t}` : t;
  }
}
ii.BaseGitHubProvider = uP;
class uZ extends uP {
  constructor(t, r, n) {
    super(t, "github.com", n), this.options = t, this.updater = r;
  }
  get channel() {
    const t = this.updater.channel || this.options.channel;
    return t == null ? this.getDefaultChannelName() : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    var t, r, n, i, s;
    const o = new dn.CancellationToken(), a = await this.httpRequest((0, Cs.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, o), c = (0, dn.parseXml)(a);
    let u = c.element("entry", !1, "No published versions on GitHub"), l = null;
    try {
      if (this.updater.allowPrerelease) {
        const _ = ((t = this.updater) === null || t === void 0 ? void 0 : t.channel) || ((r = Ps.prerelease(this.updater.currentVersion)) === null || r === void 0 ? void 0 : r[0]) || null;
        if (_ === null)
          l = Qp.exec(u.element("link").attribute("href"))[1];
        else
          for (const g of c.getElements("entry")) {
            const v = Qp.exec(g.element("link").attribute("href"));
            if (v === null)
              continue;
            const y = v[1], E = ((n = Ps.prerelease(y)) === null || n === void 0 ? void 0 : n[0]) || null, R = !_ || ["alpha", "beta"].includes(_), w = E !== null && !["alpha", "beta"].includes(String(E));
            if (R && !w && !(_ === "beta" && E === "alpha")) {
              l = y;
              break;
            }
            if (E && E === _) {
              l = y;
              break;
            }
          }
      } else {
        l = await this.getLatestTagName(o);
        for (const _ of c.getElements("entry"))
          if (Qp.exec(_.element("link").attribute("href"))[1] === l) {
            u = _;
            break;
          }
      }
    } catch (_) {
      throw (0, dn.newError)(`Cannot parse releases feed: ${_.stack || _.message},
XML:
${a}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
    if (l == null)
      throw (0, dn.newError)("No published versions on GitHub", "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    let f, m = "", p = "";
    const d = async (_) => {
      m = (0, Cs.getChannelFilename)(_), p = (0, Cs.newUrlFromBase)(this.getBaseDownloadPath(String(l), m), this.baseUrl);
      const g = this.createRequestOptions(p);
      try {
        return await this.executor.request(g, o);
      } catch (v) {
        throw v instanceof dn.HttpError && v.statusCode === 404 ? (0, dn.newError)(`Cannot find ${m} in the latest release artifacts (${p}): ${v.stack || v.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : v;
      }
    };
    try {
      let _ = this.channel;
      this.updater.allowPrerelease && (!((i = Ps.prerelease(l)) === null || i === void 0) && i[0]) && (_ = this.getCustomChannelName(String((s = Ps.prerelease(l)) === null || s === void 0 ? void 0 : s[0]))), f = await d(_);
    } catch (_) {
      if (this.updater.allowPrerelease)
        f = await d(this.getDefaultChannelName());
      else
        throw _;
    }
    const h = (0, nm.parseUpdateInfo)(f, m, p);
    return h.releaseName == null && (h.releaseName = u.elementValueOrEmpty("title")), h.releaseNotes == null && (h.releaseNotes = fP(this.updater.currentVersion, this.updater.fullChangelog, c, u)), {
      tag: l,
      ...h
    };
  }
  async getLatestTagName(t) {
    const r = this.options, n = r.host == null || r.host === "github.com" ? (0, Cs.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new lZ.URL(`${this.computeGithubBasePath(`/repos/${r.owner}/${r.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const i = await this.httpRequest(n, { Accept: "application/json" }, t);
      return i == null ? null : JSON.parse(i).tag_name;
    } catch (i) {
      throw (0, dn.newError)(`Unable to find latest version on GitHub (${n}), please ensure a production release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(t) {
    return (0, nm.resolveFiles)(t, this.baseUrl, (r) => this.getBaseDownloadPath(t.tag, r.replace(/ /g, "-")));
  }
  getBaseDownloadPath(t, r) {
    return `${this.basePath}/download/${t}/${r}`;
  }
}
ii.GitHubProvider = uZ;
function Qw(e) {
  const t = e.elementValueOrEmpty("content");
  return t === "No content." ? "" : t;
}
function fP(e, t, r, n) {
  if (!t)
    return Qw(n);
  const i = [];
  for (const s of r.getElements("entry")) {
    const o = /\/tag\/v?([^/]+)$/.exec(s.element("link").attribute("href"))[1];
    Ps.lt(e, o) && i.push({
      version: o,
      note: Qw(s)
    });
  }
  return i.sort((s, o) => Ps.rcompare(s.version, o.version));
}
var Cf = {};
Object.defineProperty(Cf, "__esModule", { value: !0 });
Cf.KeygenProvider = void 0;
const eS = Rt, eh = Nr, th = vt;
class fZ extends th.Provider {
  constructor(t, r, n) {
    super({
      ...n,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = r, this.defaultHostname = "api.keygen.sh";
    const i = this.configuration.host || this.defaultHostname;
    this.baseUrl = (0, eh.newBaseUrl)(`https://${i}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const t = new eS.CancellationToken(), r = (0, eh.getChannelFilename)(this.getCustomChannelName(this.channel)), n = (0, eh.newUrlFromBase)(r, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(n, {
        Accept: "application/vnd.api+json",
        "Keygen-Version": "1.1"
      }, t);
      return (0, th.parseUpdateInfo)(i, r, n);
    } catch (i) {
      throw (0, eS.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, th.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { account: t, product: r, platform: n } = this.configuration;
    return `Keygen (account: ${t}, product: ${r}, platform: ${n}, channel: ${this.channel})`;
  }
}
Cf.KeygenProvider = fZ;
var Af = {};
Object.defineProperty(Af, "__esModule", { value: !0 });
Af.PrivateGitHubProvider = void 0;
const ms = Rt, dZ = jt, pZ = _e, tS = qr, rS = Nr, hZ = ii, mZ = vt;
class gZ extends hZ.BaseGitHubProvider {
  constructor(t, r, n, i) {
    super(t, "api.github.com", i), this.updater = r, this.token = n;
  }
  createRequestOptions(t, r) {
    const n = super.createRequestOptions(t, r);
    return n.redirect = "manual", n;
  }
  async getLatestVersion() {
    const t = new ms.CancellationToken(), r = (0, rS.getChannelFilename)(this.getDefaultChannelName()), n = await this.getLatestVersionInfo(t), i = n.assets.find((a) => a.name === r);
    if (i == null)
      throw (0, ms.newError)(`Cannot find ${r} in the release ${n.html_url || n.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    const s = new tS.URL(i.url);
    let o;
    try {
      o = (0, dZ.load)(await this.httpRequest(s, this.configureHeaders("application/octet-stream"), t));
    } catch (a) {
      throw a instanceof ms.HttpError && a.statusCode === 404 ? (0, ms.newError)(`Cannot find ${r} in the latest release artifacts (${s}): ${a.stack || a.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : a;
    }
    return o.assets = n.assets, o;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(t) {
    return {
      accept: t,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(t) {
    const r = this.updater.allowPrerelease;
    let n = this.basePath;
    r || (n = `${n}/latest`);
    const i = (0, rS.newUrlFromBase)(n, this.baseUrl);
    try {
      const s = JSON.parse(await this.httpRequest(i, this.configureHeaders("application/vnd.github.v3+json"), t));
      return r ? s.find((o) => o.prerelease) || s[0] : s;
    } catch (s) {
      throw (0, ms.newError)(`Unable to find latest version on GitHub (${i}), please ensure a production release exists: ${s.stack || s.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
  resolveFiles(t) {
    return (0, mZ.getFileList)(t).map((r) => {
      const n = pZ.posix.basename(r.url).replace(/ /g, "-"), i = t.assets.find((s) => s != null && s.name === n);
      if (i == null)
        throw (0, ms.newError)(`Cannot find asset "${n}" in: ${JSON.stringify(t.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      return {
        url: new tS.URL(i.url),
        info: r
      };
    });
  }
}
Af.PrivateGitHubProvider = gZ;
Object.defineProperty(Of, "__esModule", { value: !0 });
Of.isUrlProbablySupportMultiRangeRequests = dP;
Of.createClient = EZ;
const il = Rt, yZ = Pf, nS = uc, vZ = ii, _Z = Cf, bZ = Af;
function dP(e) {
  return !e.includes("s3.amazonaws.com");
}
function EZ(e, t, r) {
  if (typeof e == "string")
    throw (0, il.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  const n = e.provider;
  switch (n) {
    case "github": {
      const i = e, s = (i.private ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN : null) || i.token;
      return s == null ? new vZ.GitHubProvider(i, t, r) : new bZ.PrivateGitHubProvider(i, t, s, r);
    }
    case "bitbucket":
      return new yZ.BitbucketProvider(e, t, r);
    case "keygen":
      return new _Z.KeygenProvider(e, t, r);
    case "s3":
    case "spaces":
      return new nS.GenericProvider({
        provider: "generic",
        url: (0, il.getS3LikeProviderBaseUrl)(e),
        channel: e.channel || null
      }, t, {
        ...r,
        // https://github.com/minio/minio/issues/5285#issuecomment-350428955
        isUseMultipleRangeRequest: !1
      });
    case "generic": {
      const i = e;
      return new nS.GenericProvider(i, t, {
        ...r,
        isUseMultipleRangeRequest: i.useMultipleRangeRequest !== !1 && dP(i.url)
      });
    }
    case "custom": {
      const i = e, s = i.updateProvider;
      if (!s)
        throw (0, il.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      return new s(i, t, r);
    }
    default:
      throw (0, il.newError)(`Unsupported provider: ${n}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
var If = {}, fc = {}, ho = {}, es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
es.OperationKind = void 0;
es.computeOperations = wZ;
var Ni;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(Ni || (es.OperationKind = Ni = {}));
function wZ(e, t, r) {
  const n = sS(e.files), i = sS(t.files);
  let s = null;
  const o = t.files[0], a = [], c = o.name, u = n.get(c);
  if (u == null)
    throw new Error(`no file ${c} in old blockmap`);
  const l = i.get(c);
  let f = 0;
  const { checksumToOffset: m, checksumToOldSize: p } = xZ(n.get(c), u.offset, r);
  let d = o.offset;
  for (let h = 0; h < l.checksums.length; d += l.sizes[h], h++) {
    const _ = l.sizes[h], g = l.checksums[h];
    let v = m.get(g);
    v != null && p.get(g) !== _ && (r.warn(`Checksum ("${g}") matches, but size differs (old: ${p.get(g)}, new: ${_})`), v = void 0), v === void 0 ? (f++, s != null && s.kind === Ni.DOWNLOAD && s.end === d ? s.end += _ : (s = {
      kind: Ni.DOWNLOAD,
      start: d,
      end: d + _
      // oldBlocks: null,
    }, iS(s, a, g, h))) : s != null && s.kind === Ni.COPY && s.end === v ? s.end += _ : (s = {
      kind: Ni.COPY,
      start: v,
      end: v + _
      // oldBlocks: [checksum]
    }, iS(s, a, g, h));
  }
  return f > 0 && r.info(`File${o.name === "file" ? "" : " " + o.name} has ${f} changed blocks`), a;
}
const SZ = process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
function iS(e, t, r, n) {
  if (SZ && t.length !== 0) {
    const i = t[t.length - 1];
    if (i.kind === e.kind && e.start < i.end && e.start > i.start) {
      const s = [i.start, i.end, e.start, e.end].reduce((o, a) => o < a ? o : a);
      throw new Error(`operation (block index: ${n}, checksum: ${r}, kind: ${Ni[e.kind]}) overlaps previous operation (checksum: ${r}):
abs: ${i.start} until ${i.end} and ${e.start} until ${e.end}
rel: ${i.start - s} until ${i.end - s} and ${e.start - s} until ${e.end - s}`);
    }
  }
  t.push(e);
}
function xZ(e, t, r) {
  const n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  let s = t;
  for (let o = 0; o < e.checksums.length; o++) {
    const a = e.checksums[o], c = e.sizes[o], u = i.get(a);
    if (u === void 0)
      n.set(a, s), i.set(a, c);
    else if (r.debug != null) {
      const l = u === c ? "(same size)" : `(size: ${u}, this size: ${c})`;
      r.debug(`${a} duplicated in blockmap ${l}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    s += c;
  }
  return { checksumToOffset: n, checksumToOldSize: i };
}
function sS(e) {
  const t = /* @__PURE__ */ new Map();
  for (const r of e)
    t.set(r.name, r);
  return t;
}
Object.defineProperty(ho, "__esModule", { value: !0 });
ho.DataSplitter = void 0;
ho.copyData = pP;
const sl = Rt, RZ = Ue, $Z = It, TZ = es, oS = Buffer.from(`\r
\r
`);
var Mn;
(function(e) {
  e[e.INIT = 0] = "INIT", e[e.HEADER = 1] = "HEADER", e[e.BODY = 2] = "BODY";
})(Mn || (Mn = {}));
function pP(e, t, r, n, i) {
  const s = (0, RZ.createReadStream)("", {
    fd: r,
    autoClose: !1,
    start: e.start,
    // end is inclusive
    end: e.end - 1
  });
  s.on("error", n), s.once("end", i), s.pipe(t, {
    end: !1
  });
}
class OZ extends $Z.Writable {
  constructor(t, r, n, i, s, o) {
    super(), this.out = t, this.options = r, this.partIndexToTaskIndex = n, this.partIndexToLength = s, this.finishHandler = o, this.partIndex = -1, this.headerListBuffer = null, this.readState = Mn.INIT, this.ignoreByteCount = 0, this.remainingPartDataCount = 0, this.actualPartLength = 0, this.boundaryLength = i.length + 4, this.ignoreByteCount = this.boundaryLength - 2;
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  // noinspection JSUnusedGlobalSymbols
  _write(t, r, n) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${t.length} bytes`);
      return;
    }
    this.handleData(t).then(n).catch(n);
  }
  async handleData(t) {
    let r = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
      throw (0, sl.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    if (this.ignoreByteCount > 0) {
      const n = Math.min(this.ignoreByteCount, t.length);
      this.ignoreByteCount -= n, r = n;
    } else if (this.remainingPartDataCount > 0) {
      const n = Math.min(this.remainingPartDataCount, t.length);
      this.remainingPartDataCount -= n, await this.processPartData(t, 0, n), r = n;
    }
    if (r !== t.length) {
      if (this.readState === Mn.HEADER) {
        const n = this.searchHeaderListEnd(t, r);
        if (n === -1)
          return;
        r = n, this.readState = Mn.BODY, this.headerListBuffer = null;
      }
      for (; ; ) {
        if (this.readState === Mn.BODY)
          this.readState = Mn.INIT;
        else {
          this.partIndex++;
          let o = this.partIndexToTaskIndex.get(this.partIndex);
          if (o == null)
            if (this.isFinished)
              o = this.options.end;
            else
              throw (0, sl.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          const a = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (a < o)
            await this.copyExistingData(a, o);
          else if (a > o)
            throw (0, sl.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
          if (this.isFinished) {
            this.onPartEnd(), this.finishHandler();
            return;
          }
          if (r = this.searchHeaderListEnd(t, r), r === -1) {
            this.readState = Mn.HEADER;
            return;
          }
        }
        const n = this.partIndexToLength[this.partIndex], i = r + n, s = Math.min(i, t.length);
        if (await this.processPartStarted(t, r, s), this.remainingPartDataCount = n - (s - r), this.remainingPartDataCount > 0)
          return;
        if (r = i + this.boundaryLength, r >= t.length) {
          this.ignoreByteCount = this.boundaryLength - (t.length - i);
          return;
        }
      }
    }
  }
  copyExistingData(t, r) {
    return new Promise((n, i) => {
      const s = () => {
        if (t === r) {
          n();
          return;
        }
        const o = this.options.tasks[t];
        if (o.kind !== TZ.OperationKind.COPY) {
          i(new Error("Task kind must be COPY"));
          return;
        }
        pP(o, this.out, this.options.oldFileFd, i, () => {
          t++, s();
        });
      };
      s();
    });
  }
  searchHeaderListEnd(t, r) {
    const n = t.indexOf(oS, r);
    if (n !== -1)
      return n + oS.length;
    const i = r === 0 ? t : t.slice(r);
    return this.headerListBuffer == null ? this.headerListBuffer = i : this.headerListBuffer = Buffer.concat([this.headerListBuffer, i]), -1;
  }
  onPartEnd() {
    const t = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== t)
      throw (0, sl.newError)(`Expected length: ${t} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    this.actualPartLength = 0;
  }
  processPartStarted(t, r, n) {
    return this.partIndex !== 0 && this.onPartEnd(), this.processPartData(t, r, n);
  }
  processPartData(t, r, n) {
    this.actualPartLength += n - r;
    const i = this.out;
    return i.write(r === 0 && t.length === n ? t : t.slice(r, n)) ? Promise.resolve() : new Promise((s, o) => {
      i.on("error", o), i.once("drain", () => {
        i.removeListener("error", o), s();
      });
    });
  }
}
ho.DataSplitter = OZ;
var Nf = {};
Object.defineProperty(Nf, "__esModule", { value: !0 });
Nf.executeTasksUsingMultipleRangeRequests = PZ;
Nf.checkIsRangesSupported = sm;
const im = Rt, aS = ho, cS = es;
function PZ(e, t, r, n, i) {
  const s = (o) => {
    if (o >= t.length) {
      e.fileMetadataBuffer != null && r.write(e.fileMetadataBuffer), r.end();
      return;
    }
    const a = o + 1e3;
    CZ(e, {
      tasks: t,
      start: o,
      end: Math.min(t.length, a),
      oldFileFd: n
    }, r, () => s(a), i);
  };
  return s;
}
function CZ(e, t, r, n, i) {
  let s = "bytes=", o = 0;
  const a = /* @__PURE__ */ new Map(), c = [];
  for (let f = t.start; f < t.end; f++) {
    const m = t.tasks[f];
    m.kind === cS.OperationKind.DOWNLOAD && (s += `${m.start}-${m.end - 1}, `, a.set(o, f), o++, c.push(m.end - m.start));
  }
  if (o <= 1) {
    const f = (m) => {
      if (m >= t.end) {
        n();
        return;
      }
      const p = t.tasks[m++];
      if (p.kind === cS.OperationKind.COPY)
        (0, aS.copyData)(p, r, t.oldFileFd, i, () => f(m));
      else {
        const d = e.createRequestOptions();
        d.headers.Range = `bytes=${p.start}-${p.end - 1}`;
        const h = e.httpExecutor.createRequest(d, (_) => {
          sm(_, i) && (_.pipe(r, {
            end: !1
          }), _.once("end", () => f(m)));
        });
        e.httpExecutor.addErrorAndTimeoutHandlers(h, i), h.end();
      }
    };
    f(t.start);
    return;
  }
  const u = e.createRequestOptions();
  u.headers.Range = s.substring(0, s.length - 2);
  const l = e.httpExecutor.createRequest(u, (f) => {
    if (!sm(f, i))
      return;
    const m = (0, im.safeGetHeader)(f, "content-type"), p = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(m);
    if (p == null) {
      i(new Error(`Content-Type "multipart/byteranges" is expected, but got "${m}"`));
      return;
    }
    const d = new aS.DataSplitter(r, t, a, p[1] || p[2], c, n);
    d.on("error", i), f.pipe(d), f.on("end", () => {
      setTimeout(() => {
        l.abort(), i(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  e.httpExecutor.addErrorAndTimeoutHandlers(l, i), l.end();
}
function sm(e, t) {
  if (e.statusCode >= 400)
    return t((0, im.createHttpError)(e)), !1;
  if (e.statusCode !== 206) {
    const r = (0, im.safeGetHeader)(e, "accept-ranges");
    if (r == null || r === "none")
      return t(new Error(`Server doesn't support Accept-Ranges (response code ${e.statusCode})`)), !1;
  }
  return !0;
}
var kf = {};
Object.defineProperty(kf, "__esModule", { value: !0 });
kf.ProgressDifferentialDownloadCallbackTransform = void 0;
const AZ = It;
var As;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(As || (As = {}));
class IZ extends AZ.Transform {
  constructor(t, r, n) {
    super(), this.progressDifferentialDownloadInfo = t, this.cancellationToken = r, this.onProgress = n, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.expectedBytes = 0, this.index = 0, this.operationType = As.COPY, this.nextUpdate = this.start + 1e3;
  }
  _transform(t, r, n) {
    if (this.cancellationToken.cancelled) {
      n(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == As.COPY) {
      n(null, t);
      return;
    }
    this.transferred += t.length, this.delta += t.length;
    const i = Date.now();
    i >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && (this.nextUpdate = i + 1e3, this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
      bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3))
    }), this.delta = 0), n(null, t);
  }
  beginFileCopy() {
    this.operationType = As.COPY;
  }
  beginRangeDownload() {
    this.operationType = As.DOWNLOAD, this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
  }
  // Called when we are 100% done with the connection/download
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    }), this.delta = 0, this.transferred = 0, t(null);
  }
}
kf.ProgressDifferentialDownloadCallbackTransform = IZ;
Object.defineProperty(fc, "__esModule", { value: !0 });
fc.DifferentialDownloader = void 0;
const Ho = Rt, rh = si, NZ = Ue, kZ = ho, DZ = qr, ol = es, lS = Nf, LZ = kf;
class FZ {
  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
  constructor(t, r, n) {
    this.blockAwareFileInfo = t, this.httpExecutor = r, this.options = n, this.fileMetadataBuffer = null, this.logger = n.logger;
  }
  createRequestOptions() {
    const t = {
      headers: {
        ...this.options.requestHeaders,
        accept: "*/*"
      }
    };
    return (0, Ho.configureRequestUrl)(this.options.newUrl, t), (0, Ho.configureRequestOptions)(t), t;
  }
  doDownload(t, r) {
    if (t.version !== r.version)
      throw new Error(`version is different (${t.version} - ${r.version}), full download is required`);
    const n = this.logger, i = (0, ol.computeOperations)(t, r, n);
    n.debug != null && n.debug(JSON.stringify(i, null, 2));
    let s = 0, o = 0;
    for (const c of i) {
      const u = c.end - c.start;
      c.kind === ol.OperationKind.DOWNLOAD ? s += u : o += u;
    }
    const a = this.blockAwareFileInfo.size;
    if (s + o + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== a)
      throw new Error(`Internal error, size mismatch: downloadSize: ${s}, copySize: ${o}, newSize: ${a}`);
    return n.info(`Full: ${uS(a)}, To download: ${uS(s)} (${Math.round(s / (a / 100))}%)`), this.downloadFile(i);
  }
  downloadFile(t) {
    const r = [], n = () => Promise.all(r.map((i) => (0, rh.close)(i.descriptor).catch((s) => {
      this.logger.error(`cannot close file "${i.path}": ${s}`);
    })));
    return this.doDownloadFile(t, r).then(n).catch((i) => n().catch((s) => {
      try {
        this.logger.error(`cannot close files: ${s}`);
      } catch (o) {
        try {
          console.error(o);
        } catch {
        }
      }
      throw i;
    }).then(() => {
      throw i;
    }));
  }
  async doDownloadFile(t, r) {
    const n = await (0, rh.open)(this.options.oldFile, "r");
    r.push({ descriptor: n, path: this.options.oldFile });
    const i = await (0, rh.open)(this.options.newFile, "w");
    r.push({ descriptor: i, path: this.options.newFile });
    const s = (0, NZ.createWriteStream)(this.options.newFile, { fd: i });
    await new Promise((o, a) => {
      const c = [];
      let u;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const g = [];
        let v = 0;
        for (const E of t)
          E.kind === ol.OperationKind.DOWNLOAD && (g.push(E.end - E.start), v += E.end - E.start);
        const y = {
          expectedByteCounts: g,
          grandTotal: v
        };
        u = new LZ.ProgressDifferentialDownloadCallbackTransform(y, this.options.cancellationToken, this.options.onProgress), c.push(u);
      }
      const l = new Ho.DigestTransform(this.blockAwareFileInfo.sha512);
      l.isValidateOnEnd = !1, c.push(l), s.on("finish", () => {
        s.close(() => {
          r.splice(1, 1);
          try {
            l.validate();
          } catch (g) {
            a(g);
            return;
          }
          o(void 0);
        });
      }), c.push(s);
      let f = null;
      for (const g of c)
        g.on("error", a), f == null ? f = g : f = f.pipe(g);
      const m = c[0];
      let p;
      if (this.options.isUseMultipleRangeRequest) {
        p = (0, lS.executeTasksUsingMultipleRangeRequests)(this, t, m, n, a), p(0);
        return;
      }
      let d = 0, h = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const _ = this.createRequestOptions();
      _.redirect = "manual", p = (g) => {
        var v, y;
        if (g >= t.length) {
          this.fileMetadataBuffer != null && m.write(this.fileMetadataBuffer), m.end();
          return;
        }
        const E = t[g++];
        if (E.kind === ol.OperationKind.COPY) {
          u && u.beginFileCopy(), (0, kZ.copyData)(E, m, n, a, () => p(g));
          return;
        }
        const R = `bytes=${E.start}-${E.end - 1}`;
        _.headers.range = R, (y = (v = this.logger) === null || v === void 0 ? void 0 : v.debug) === null || y === void 0 || y.call(v, `download range: ${R}`), u && u.beginRangeDownload();
        const w = this.httpExecutor.createRequest(_, (C) => {
          C.on("error", a), C.on("aborted", () => {
            a(new Error("response has been aborted by the server"));
          }), C.statusCode >= 400 && a((0, Ho.createHttpError)(C)), C.pipe(m, {
            end: !1
          }), C.once("end", () => {
            u && u.endRangeDownload(), ++d === 100 ? (d = 0, setTimeout(() => p(g), 1e3)) : p(g);
          });
        });
        w.on("redirect", (C, V, b) => {
          this.logger.info(`Redirect to ${jZ(b)}`), h = b, (0, Ho.configureRequestUrl)(new DZ.URL(h), _), w.followRedirect();
        }), this.httpExecutor.addErrorAndTimeoutHandlers(w, a), w.end();
      }, p(0);
    });
  }
  async readRemoteBytes(t, r) {
    const n = Buffer.allocUnsafe(r + 1 - t), i = this.createRequestOptions();
    i.headers.range = `bytes=${t}-${r}`;
    let s = 0;
    if (await this.request(i, (o) => {
      o.copy(n, s), s += o.length;
    }), s !== n.length)
      throw new Error(`Received data length ${s} is not equal to expected ${n.length}`);
    return n;
  }
  request(t, r) {
    return new Promise((n, i) => {
      const s = this.httpExecutor.createRequest(t, (o) => {
        (0, lS.checkIsRangesSupported)(o, i) && (o.on("error", i), o.on("aborted", () => {
          i(new Error("response has been aborted by the server"));
        }), o.on("data", r), o.on("end", () => n()));
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(s, i), s.end();
    });
  }
}
fc.DifferentialDownloader = FZ;
function uS(e, t = " KB") {
  return new Intl.NumberFormat("en").format((e / 1024).toFixed(2)) + t;
}
function jZ(e) {
  const t = e.indexOf("?");
  return t < 0 ? e : e.substring(0, t);
}
Object.defineProperty(If, "__esModule", { value: !0 });
If.GenericDifferentialDownloader = void 0;
const UZ = fc;
class MZ extends UZ.DifferentialDownloader {
  download(t, r) {
    return this.doDownload(t, r);
  }
}
If.GenericDifferentialDownloader = MZ;
var oi = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.UpdaterSignal = e.UPDATE_DOWNLOADED = e.DOWNLOAD_PROGRESS = e.CancellationToken = void 0, e.addHandler = n;
  const t = Rt;
  Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } }), e.DOWNLOAD_PROGRESS = "download-progress", e.UPDATE_DOWNLOADED = "update-downloaded";
  class r {
    constructor(s) {
      this.emitter = s;
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(s) {
      n(this.emitter, "login", s);
    }
    progress(s) {
      n(this.emitter, e.DOWNLOAD_PROGRESS, s);
    }
    updateDownloaded(s) {
      n(this.emitter, e.UPDATE_DOWNLOADED, s);
    }
    updateCancelled(s) {
      n(this.emitter, "update-cancelled", s);
    }
  }
  e.UpdaterSignal = r;
  function n(i, s, o) {
    i.on(s, o);
  }
})(oi);
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.NoOpLogger = ei.AppUpdater = void 0;
const Xt = Rt, HZ = Ki, qZ = _u, BZ = yu, gs = si, zZ = jt, nh = $f, bi = _e, Ri = ay, fS = lc, VZ = Tf, dS = oP, GZ = uc, ih = Of, WZ = Pr, KZ = Nr, YZ = If, ys = oi;
class Qy extends BZ.EventEmitter {
  /**
   * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
   */
  get channel() {
    return this._channel;
  }
  /**
   * Set the update channel. Overrides `channel` in the update configuration.
   *
   * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
   */
  set channel(t) {
    if (this._channel != null) {
      if (typeof t != "string")
        throw (0, Xt.newError)(`Channel must be a string, but got: ${t}`, "ERR_UPDATER_INVALID_CHANNEL");
      if (t.length === 0)
        throw (0, Xt.newError)("Channel must be not an empty string", "ERR_UPDATER_INVALID_CHANNEL");
    }
    this._channel = t, this.allowDowngrade = !0;
  }
  /**
   *  Shortcut for explicitly adding auth tokens to request headers
   */
  addAuthHeader(t) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: t
    });
  }
  // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  get netSession() {
    return (0, dS.getNetSession)();
  }
  /**
   * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
   * Set it to `null` if you would like to disable a logging feature.
   */
  get logger() {
    return this._logger;
  }
  set logger(t) {
    this._logger = t ?? new hP();
  }
  // noinspection JSUnusedGlobalSymbols
  /**
   * test only
   * @private
   */
  set updateConfigPath(t) {
    this.clientPromise = null, this._appUpdateConfigPath = t, this.configOnDisk = new nh.Lazy(() => this.loadUpdateConfig());
  }
  /**
   * Allows developer to override default logic for determining if an update is supported.
   * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
   */
  get isUpdateSupported() {
    return this._isUpdateSupported;
  }
  set isUpdateSupported(t) {
    t && (this._isUpdateSupported = t);
  }
  constructor(t, r) {
    super(), this.autoDownload = !0, this.autoInstallOnAppQuit = !0, this.autoRunAppAfterInstall = !0, this.allowPrerelease = !1, this.fullChangelog = !1, this.allowDowngrade = !1, this.disableWebInstaller = !1, this.disableDifferentialDownload = !1, this.forceDevUpdateConfig = !1, this._channel = null, this.downloadedUpdateHelper = null, this.requestHeaders = null, this._logger = console, this.signals = new ys.UpdaterSignal(this), this._appUpdateConfigPath = null, this._isUpdateSupported = (s) => this.checkIfUpdateSupported(s), this.clientPromise = null, this.stagingUserIdPromise = new nh.Lazy(() => this.getOrCreateStagingUserId()), this.configOnDisk = new nh.Lazy(() => this.loadUpdateConfig()), this.checkForUpdatesPromise = null, this.downloadPromise = null, this.updateInfoAndProvider = null, this._testOnlyOptions = null, this.on("error", (s) => {
      this._logger.error(`Error: ${s.stack || s.message}`);
    }), r == null ? (this.app = new VZ.ElectronAppAdapter(), this.httpExecutor = new dS.ElectronHttpExecutor((s, o) => this.emit("login", s, o))) : (this.app = r, this.httpExecutor = null);
    const n = this.app.version, i = (0, Ri.parse)(n);
    if (i == null)
      throw (0, Xt.newError)(`App version is not a valid semver version: "${n}"`, "ERR_UPDATER_INVALID_VERSION");
    this.currentVersion = i, this.allowPrerelease = JZ(i), t != null && (this.setFeedURL(t), typeof t != "string" && t.requestHeaders && (this.requestHeaders = t.requestHeaders));
  }
  //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  /**
   * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
   * @param options If you want to override configuration in the `app-update.yml`.
   */
  setFeedURL(t) {
    const r = this.createProviderRuntimeOptions();
    let n;
    typeof t == "string" ? n = new GZ.GenericProvider({ provider: "generic", url: t }, this, {
      ...r,
      isUseMultipleRangeRequest: (0, ih.isUrlProbablySupportMultiRangeRequests)(t)
    }) : n = (0, ih.createClient)(t, this, r), this.clientPromise = Promise.resolve(n);
  }
  /**
   * Asks the server whether there is an update.
   * @returns null if the updater is disabled, otherwise info about the latest version
   */
  checkForUpdates() {
    if (!this.isUpdaterActive())
      return Promise.resolve(null);
    let t = this.checkForUpdatesPromise;
    if (t != null)
      return this._logger.info("Checking for update (already in progress)"), t;
    const r = () => this.checkForUpdatesPromise = null;
    return this._logger.info("Checking for update"), t = this.doCheckForUpdates().then((n) => (r(), n)).catch((n) => {
      throw r(), this.emit("error", n, `Cannot check for updates: ${(n.stack || n).toString()}`), n;
    }), this.checkForUpdatesPromise = t, t;
  }
  isUpdaterActive() {
    return this.app.isPackaged || this.forceDevUpdateConfig ? !0 : (this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced"), !1);
  }
  // noinspection JSUnusedGlobalSymbols
  checkForUpdatesAndNotify(t) {
    return this.checkForUpdates().then((r) => r != null && r.downloadPromise ? (r.downloadPromise.then(() => {
      const n = Qy.formatDownloadNotification(r.updateInfo.version, this.app.name, t);
      new Mi.Notification(n).show();
    }), r) : (this._logger.debug != null && this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null"), r));
  }
  static formatDownloadNotification(t, r, n) {
    return n == null && (n = {
      title: "A new update is ready to install",
      body: "{appName} version {version} has been downloaded and will be automatically installed on exit"
    }), n = {
      title: n.title.replace("{appName}", r).replace("{version}", t),
      body: n.body.replace("{appName}", r).replace("{version}", t)
    }, n;
  }
  async isStagingMatch(t) {
    const r = t.stagingPercentage;
    let n = r;
    if (n == null)
      return !0;
    if (n = parseInt(n, 10), isNaN(n))
      return this._logger.warn(`Staging percentage is NaN: ${r}`), !0;
    n = n / 100;
    const i = await this.stagingUserIdPromise.value, o = Xt.UUID.parse(i).readUInt32BE(12) / 4294967295;
    return this._logger.info(`Staging percentage: ${n}, percentage: ${o}, user id: ${i}`), o < n;
  }
  computeFinalHeaders(t) {
    return this.requestHeaders != null && Object.assign(t, this.requestHeaders), t;
  }
  async isUpdateAvailable(t) {
    const r = (0, Ri.parse)(t.version);
    if (r == null)
      throw (0, Xt.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${t.version}"`, "ERR_UPDATER_INVALID_VERSION");
    const n = this.currentVersion;
    if ((0, Ri.eq)(r, n) || !await Promise.resolve(this.isUpdateSupported(t)) || !await this.isStagingMatch(t))
      return !1;
    const s = (0, Ri.gt)(r, n), o = (0, Ri.lt)(r, n);
    return s ? !0 : this.allowDowngrade && o;
  }
  checkIfUpdateSupported(t) {
    const r = t == null ? void 0 : t.minimumSystemVersion, n = (0, qZ.release)();
    if (r)
      try {
        if ((0, Ri.lt)(n, r))
          return this._logger.info(`Current OS version ${n} is less than the minimum OS version required ${r} for version ${n}`), !1;
      } catch (i) {
        this._logger.warn(`Failed to compare current OS version(${n}) with minimum OS version(${r}): ${(i.message || i).toString()}`);
      }
    return !0;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady(), this.clientPromise == null && (this.clientPromise = this.configOnDisk.value.then((n) => (0, ih.createClient)(n, this, this.createProviderRuntimeOptions())));
    const t = await this.clientPromise, r = await this.stagingUserIdPromise.value;
    return t.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": r })), {
      info: await t.getLatestVersion(),
      provider: t
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: !0,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const t = await this.getUpdateInfoAndProvider(), r = t.info;
    if (!await this.isUpdateAvailable(r))
      return this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${r.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`), this.emit("update-not-available", r), {
        isUpdateAvailable: !1,
        versionInfo: r,
        updateInfo: r
      };
    this.updateInfoAndProvider = t, this.onUpdateAvailable(r);
    const n = new Xt.CancellationToken();
    return {
      isUpdateAvailable: !0,
      versionInfo: r,
      updateInfo: r,
      cancellationToken: n,
      downloadPromise: this.autoDownload ? this.downloadUpdate(n) : null
    };
  }
  onUpdateAvailable(t) {
    this._logger.info(`Found version ${t.version} (url: ${(0, Xt.asArray)(t.files).map((r) => r.url).join(", ")})`), this.emit("update-available", t);
  }
  /**
   * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
   * @returns {Promise<Array<string>>} Paths to downloaded files.
   */
  downloadUpdate(t = new Xt.CancellationToken()) {
    const r = this.updateInfoAndProvider;
    if (r == null) {
      const i = new Error("Please check update first");
      return this.dispatchError(i), Promise.reject(i);
    }
    if (this.downloadPromise != null)
      return this._logger.info("Downloading update (already in progress)"), this.downloadPromise;
    this._logger.info(`Downloading update from ${(0, Xt.asArray)(r.info.files).map((i) => i.url).join(", ")}`);
    const n = (i) => {
      if (!(i instanceof Xt.CancellationError))
        try {
          this.dispatchError(i);
        } catch (s) {
          this._logger.warn(`Cannot dispatch error event: ${s.stack || s}`);
        }
      return i;
    };
    return this.downloadPromise = this.doDownloadUpdate({
      updateInfoAndProvider: r,
      requestHeaders: this.computeRequestHeaders(r.provider),
      cancellationToken: t,
      disableWebInstaller: this.disableWebInstaller,
      disableDifferentialDownload: this.disableDifferentialDownload
    }).catch((i) => {
      throw n(i);
    }).finally(() => {
      this.downloadPromise = null;
    }), this.downloadPromise;
  }
  dispatchError(t) {
    this.emit("error", t, (t.stack || t).toString());
  }
  dispatchUpdateDownloaded(t) {
    this.emit(ys.UPDATE_DOWNLOADED, t);
  }
  async loadUpdateConfig() {
    return this._appUpdateConfigPath == null && (this._appUpdateConfigPath = this.app.appUpdateConfigPath), (0, zZ.load)(await (0, gs.readFile)(this._appUpdateConfigPath, "utf-8"));
  }
  computeRequestHeaders(t) {
    const r = t.fileExtraDownloadHeaders;
    if (r != null) {
      const n = this.requestHeaders;
      return n == null ? r : {
        ...r,
        ...n
      };
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const t = bi.join(this.app.userDataPath, ".updaterId");
    try {
      const n = await (0, gs.readFile)(t, "utf-8");
      if (Xt.UUID.check(n))
        return n;
      this._logger.warn(`Staging user id file exists, but content was invalid: ${n}`);
    } catch (n) {
      n.code !== "ENOENT" && this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${n}`);
    }
    const r = Xt.UUID.v5((0, HZ.randomBytes)(4096), Xt.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${r}`);
    try {
      await (0, gs.outputFile)(t, r);
    } catch (n) {
      this._logger.warn(`Couldn't write out staging user ID: ${n}`);
    }
    return r;
  }
  /** @internal */
  get isAddNoCacheQuery() {
    const t = this.requestHeaders;
    if (t == null)
      return !0;
    for (const r of Object.keys(t)) {
      const n = r.toLowerCase();
      if (n === "authorization" || n === "private-token")
        return !1;
    }
    return !0;
  }
  async getOrCreateDownloadHelper() {
    let t = this.downloadedUpdateHelper;
    if (t == null) {
      const r = (await this.configOnDisk.value).updaterCacheDirName, n = this._logger;
      r == null && n.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      const i = bi.join(this.app.baseCachePath, r || this.app.name);
      n.debug != null && n.debug(`updater cache dir: ${i}`), t = new fS.DownloadedUpdateHelper(i), this.downloadedUpdateHelper = t;
    }
    return t;
  }
  async executeDownload(t) {
    const r = t.fileInfo, n = {
      headers: t.downloadUpdateOptions.requestHeaders,
      cancellationToken: t.downloadUpdateOptions.cancellationToken,
      sha2: r.info.sha2,
      sha512: r.info.sha512
    };
    this.listenerCount(ys.DOWNLOAD_PROGRESS) > 0 && (n.onProgress = (v) => this.emit(ys.DOWNLOAD_PROGRESS, v));
    const i = t.downloadUpdateOptions.updateInfoAndProvider.info, s = i.version, o = r.packageInfo;
    function a() {
      const v = decodeURIComponent(t.fileInfo.url.pathname);
      return v.endsWith(`.${t.fileExtension}`) ? bi.basename(v) : t.fileInfo.info.url;
    }
    const c = await this.getOrCreateDownloadHelper(), u = c.cacheDirForPendingUpdate;
    await (0, gs.mkdir)(u, { recursive: !0 });
    const l = a();
    let f = bi.join(u, l);
    const m = o == null ? null : bi.join(u, `package-${s}${bi.extname(o.path) || ".7z"}`), p = async (v) => (await c.setDownloadedFile(f, m, i, r, l, v), await t.done({
      ...i,
      downloadedFile: f
    }), m == null ? [f] : [f, m]), d = this._logger, h = await c.validateDownloadedPath(f, i, r, d);
    if (h != null)
      return f = h, await p(!1);
    const _ = async () => (await c.clear().catch(() => {
    }), await (0, gs.unlink)(f).catch(() => {
    })), g = await (0, fS.createTempUpdateFile)(`temp-${l}`, u, d);
    try {
      await t.task(g, n, m, _), await (0, Xt.retry)(() => (0, gs.rename)(g, f), 60, 500, 0, 0, (v) => v instanceof Error && /^EBUSY:/.test(v.message));
    } catch (v) {
      throw await _(), v instanceof Xt.CancellationError && (d.info("cancelled"), this.emit("update-cancelled", i)), v;
    }
    return d.info(`New version ${s} has been downloaded to ${f}`), await p(!0);
  }
  async differentialDownloadInstaller(t, r, n, i, s) {
    try {
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload)
        return !0;
      const o = (0, KZ.blockmapFiles)(t.url, this.app.version, r.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${o[0]}", new: ${o[1]})`);
      const a = async (l) => {
        const f = await this.httpExecutor.downloadToBuffer(l, {
          headers: r.requestHeaders,
          cancellationToken: r.cancellationToken
        });
        if (f == null || f.length === 0)
          throw new Error(`Blockmap "${l.href}" is empty`);
        try {
          return JSON.parse((0, WZ.gunzipSync)(f).toString());
        } catch (m) {
          throw new Error(`Cannot parse blockmap "${l.href}", error: ${m}`);
        }
      }, c = {
        newUrl: t.url,
        oldFile: bi.join(this.downloadedUpdateHelper.cacheDir, s),
        logger: this._logger,
        newFile: n,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        requestHeaders: r.requestHeaders,
        cancellationToken: r.cancellationToken
      };
      this.listenerCount(ys.DOWNLOAD_PROGRESS) > 0 && (c.onProgress = (l) => this.emit(ys.DOWNLOAD_PROGRESS, l));
      const u = await Promise.all(o.map((l) => a(l)));
      return await new YZ.GenericDifferentialDownloader(t.info, this.httpExecutor, c).download(u[0], u[1]), !1;
    } catch (o) {
      if (this._logger.error(`Cannot download differentially, fallback to full download: ${o.stack || o}`), this._testOnlyOptions != null)
        throw o;
      return !0;
    }
  }
}
ei.AppUpdater = Qy;
function JZ(e) {
  const t = (0, Ri.prerelease)(e);
  return t != null && t.length > 0;
}
class hP {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  info(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  warn(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  error(t) {
  }
}
ei.NoOpLogger = hP;
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.BaseUpdater = void 0;
const pS = bu, XZ = ei;
class ZZ extends XZ.AppUpdater {
  constructor(t, r) {
    super(t, r), this.quitAndInstallCalled = !1, this.quitHandlerAdded = !1;
  }
  quitAndInstall(t = !1, r = !1) {
    this._logger.info("Install on explicit quitAndInstall"), this.install(t, t ? r : this.autoRunAppAfterInstall) ? setImmediate(() => {
      Mi.autoUpdater.emit("before-quit-for-update"), this.app.quit();
    }) : this.quitAndInstallCalled = !1;
  }
  executeDownload(t) {
    return super.executeDownload({
      ...t,
      done: (r) => (this.dispatchUpdateDownloaded(r), this.addQuitHandler(), Promise.resolve())
    });
  }
  get installerPath() {
    return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
  }
  // must be sync (because quit even handler is not async)
  install(t = !1, r = !1) {
    if (this.quitAndInstallCalled)
      return this._logger.warn("install call ignored: quitAndInstallCalled is set to true"), !1;
    const n = this.downloadedUpdateHelper, i = this.installerPath, s = n == null ? null : n.downloadedFileInfo;
    if (i == null || s == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    this.quitAndInstallCalled = !0;
    try {
      return this._logger.info(`Install: isSilent: ${t}, isForceRunAfter: ${r}`), this.doInstall({
        isSilent: t,
        isForceRunAfter: r,
        isAdminRightsRequired: s.isAdminRightsRequired
      });
    } catch (o) {
      return this.dispatchError(o), !1;
    }
  }
  addQuitHandler() {
    this.quitHandlerAdded || !this.autoInstallOnAppQuit || (this.quitHandlerAdded = !0, this.app.onQuit((t) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (t !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${t}`);
        return;
      }
      this._logger.info("Auto install update on quit"), this.install(!0, !1);
    }));
  }
  wrapSudo() {
    const { name: t } = this.app, r = `"${t} would like to update"`, n = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu"), i = [n];
    return /kdesudo/i.test(n) ? (i.push("--comment", r), i.push("-c")) : /gksudo/i.test(n) ? i.push("--message", r) : /pkexec/i.test(n) && i.push("--disable-internal-agent"), i.join(" ");
  }
  spawnSyncLog(t, r = [], n = {}) {
    this._logger.info(`Executing: ${t} with args: ${r}`);
    const i = (0, pS.spawnSync)(t, r, {
      env: { ...process.env, ...n },
      encoding: "utf-8",
      shell: !0
    }), { error: s, status: o, stdout: a, stderr: c } = i;
    if (s != null)
      throw this._logger.error(c), s;
    if (o != null && o !== 0)
      throw this._logger.error(c), new Error(`Command ${t} exited with code ${o}`);
    return a.trim();
  }
  /**
   * This handles both node 8 and node 10 way of emitting error when spawning a process
   *   - node 8: Throws the error
   *   - node 10: Emit the error(Need to listen with on)
   */
  // https://github.com/electron-userland/electron-builder/issues/1129
  // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
  async spawnLog(t, r = [], n = void 0, i = "ignore") {
    return this._logger.info(`Executing: ${t} with args: ${r}`), new Promise((s, o) => {
      try {
        const a = { stdio: i, env: n, detached: !0 }, c = (0, pS.spawn)(t, r, a);
        c.on("error", (u) => {
          o(u);
        }), c.unref(), c.pid !== void 0 && s(!0);
      } catch (a) {
        o(a);
      }
    });
  }
}
Rn.BaseUpdater = ZZ;
var Ra = {}, dc = {};
Object.defineProperty(dc, "__esModule", { value: !0 });
dc.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const vs = si, QZ = fc, eQ = Pr;
class tQ extends QZ.DifferentialDownloader {
  async download() {
    const t = this.blockAwareFileInfo, r = t.size, n = r - (t.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(n, r - 1);
    const i = mP(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await rQ(this.options.oldFile), i);
  }
}
dc.FileWithEmbeddedBlockMapDifferentialDownloader = tQ;
function mP(e) {
  return JSON.parse((0, eQ.inflateRawSync)(e).toString());
}
async function rQ(e) {
  const t = await (0, vs.open)(e, "r");
  try {
    const r = (await (0, vs.fstat)(t)).size, n = Buffer.allocUnsafe(4);
    await (0, vs.read)(t, n, 0, n.length, r - n.length);
    const i = Buffer.allocUnsafe(n.readUInt32BE(0));
    return await (0, vs.read)(t, i, 0, i.length, r - n.length - i.length), await (0, vs.close)(t), mP(i);
  } catch (r) {
    throw await (0, vs.close)(t), r;
  }
}
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.AppImageUpdater = void 0;
const hS = Rt, mS = bu, nQ = si, iQ = Ue, qo = _e, sQ = Rn, oQ = dc, aQ = vt, gS = oi;
class cQ extends sQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  isUpdaterActive() {
    return process.env.APPIMAGE == null ? (process.env.SNAP == null ? this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage") : this._logger.info("SNAP env is defined, updater is disabled"), !1) : super.isUpdaterActive();
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, aQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        const o = process.env.APPIMAGE;
        if (o == null)
          throw (0, hS.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        (t.disableDifferentialDownload || await this.downloadDifferential(n, o, i, r, t)) && await this.httpExecutor.download(n.url, i, s), await (0, nQ.chmod)(i, 493);
      }
    });
  }
  async downloadDifferential(t, r, n, i, s) {
    try {
      const o = {
        newUrl: t.url,
        oldFile: r,
        logger: this._logger,
        newFile: n,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        requestHeaders: s.requestHeaders,
        cancellationToken: s.cancellationToken
      };
      return this.listenerCount(gS.DOWNLOAD_PROGRESS) > 0 && (o.onProgress = (a) => this.emit(gS.DOWNLOAD_PROGRESS, a)), await new oQ.FileWithEmbeddedBlockMapDifferentialDownloader(t.info, this.httpExecutor, o).download(), !1;
    } catch (o) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${o.stack || o}`), process.platform === "linux";
    }
  }
  doInstall(t) {
    const r = process.env.APPIMAGE;
    if (r == null)
      throw (0, hS.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    (0, iQ.unlinkSync)(r);
    let n;
    const i = qo.basename(r), s = this.installerPath;
    if (s == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    qo.basename(s) === i || !/\d+\.\d+\.\d+/.test(i) ? n = r : n = qo.join(qo.dirname(r), qo.basename(s)), (0, mS.execFileSync)("mv", ["-f", s, n]), n !== r && this.emit("appimage-filename-updated", n);
    const o = {
      ...process.env,
      APPIMAGE_SILENT_INSTALL: "true"
    };
    return t.isForceRunAfter ? this.spawnLog(n, [], o) : (o.APPIMAGE_EXIT_AFTER_INSTALL = "true", (0, mS.execFileSync)(n, [], { env: o })), !0;
  }
}
Ra.AppImageUpdater = cQ;
var $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.DebUpdater = void 0;
const lQ = Rn, uQ = vt, yS = oi;
class fQ extends lQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, uQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        this.listenerCount(yS.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(yS.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(n.url, i, s);
      }
    });
  }
  get installerPath() {
    var t, r;
    return (r = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && r !== void 0 ? r : null;
  }
  doInstall(t) {
    const r = this.wrapSudo(), n = /pkexec/i.test(r) ? "" : '"', i = this.installerPath;
    if (i == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const s = ["dpkg", "-i", i, "||", "apt-get", "install", "-f", "-y"];
    return this.spawnSyncLog(r, [`${n}/bin/bash`, "-c", `'${s.join(" ")}'${n}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
$a.DebUpdater = fQ;
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.PacmanUpdater = void 0;
const dQ = Rn, vS = oi, pQ = vt;
class hQ extends dQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, pQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
    return this.executeDownload({
      fileExtension: "pacman",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        this.listenerCount(vS.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(vS.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(n.url, i, s);
      }
    });
  }
  get installerPath() {
    var t, r;
    return (r = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && r !== void 0 ? r : null;
  }
  doInstall(t) {
    const r = this.wrapSudo(), n = /pkexec/i.test(r) ? "" : '"', i = this.installerPath;
    if (i == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const s = ["pacman", "-U", "--noconfirm", i];
    return this.spawnSyncLog(r, [`${n}/bin/bash`, "-c", `'${s.join(" ")}'${n}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
Ta.PacmanUpdater = hQ;
var Oa = {};
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.RpmUpdater = void 0;
const mQ = Rn, _S = oi, gQ = vt;
class yQ extends mQ.BaseUpdater {
  constructor(t, r) {
    super(t, r);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, gQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo: n,
      downloadUpdateOptions: t,
      task: async (i, s) => {
        this.listenerCount(_S.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(_S.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(n.url, i, s);
      }
    });
  }
  get installerPath() {
    var t, r;
    return (r = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && r !== void 0 ? r : null;
  }
  doInstall(t) {
    const r = this.wrapSudo(), n = /pkexec/i.test(r) ? "" : '"', i = this.spawnSyncLog("which zypper"), s = this.installerPath;
    if (s == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    let o;
    return i ? o = [i, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", s] : o = [this.spawnSyncLog("which dnf || which yum"), "-y", "install", s], this.spawnSyncLog(r, [`${n}/bin/bash`, "-c", `'${o.join(" ")}'${n}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
Oa.RpmUpdater = yQ;
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.MacUpdater = void 0;
const bS = Rt, sh = si, vQ = Ue, ES = _e, _Q = vu, bQ = ei, EQ = vt, wS = bu, SS = Ki;
class wQ extends bQ.AppUpdater {
  constructor(t, r) {
    super(t, r), this.nativeUpdater = Mi.autoUpdater, this.squirrelDownloadedUpdate = !1, this.nativeUpdater.on("error", (n) => {
      this._logger.warn(n), this.emit("error", n);
    }), this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = !0, this.debug("nativeUpdater.update-downloaded");
    });
  }
  debug(t) {
    this._logger.debug != null && this._logger.debug(t);
  }
  closeServerIfExists() {
    this.server && (this.debug("Closing proxy server"), this.server.close((t) => {
      t && this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
    }));
  }
  async doDownloadUpdate(t) {
    let r = t.updateInfoAndProvider.provider.resolveFiles(t.updateInfoAndProvider.info);
    const n = this._logger, i = "sysctl.proc_translated";
    let s = !1;
    try {
      this.debug("Checking for macOS Rosetta environment"), s = (0, wS.execFileSync)("sysctl", [i], { encoding: "utf8" }).includes(`${i}: 1`), n.info(`Checked for macOS Rosetta environment (isRosetta=${s})`);
    } catch (f) {
      n.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${f}`);
    }
    let o = !1;
    try {
      this.debug("Checking for arm64 in uname");
      const m = (0, wS.execFileSync)("uname", ["-a"], { encoding: "utf8" }).includes("ARM");
      n.info(`Checked 'uname -a': arm64=${m}`), o = o || m;
    } catch (f) {
      n.warn(`uname shell command to check for arm64 failed: ${f}`);
    }
    o = o || process.arch === "arm64" || s;
    const a = (f) => {
      var m;
      return f.url.pathname.includes("arm64") || ((m = f.info.url) === null || m === void 0 ? void 0 : m.includes("arm64"));
    };
    o && r.some(a) ? r = r.filter((f) => o === a(f)) : r = r.filter((f) => !a(f));
    const c = (0, EQ.findFile)(r, "zip", ["pkg", "dmg"]);
    if (c == null)
      throw (0, bS.newError)(`ZIP file not provided: ${(0, bS.safeStringifyJson)(r)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    const u = t.updateInfoAndProvider.provider, l = "update.zip";
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: c,
      downloadUpdateOptions: t,
      task: async (f, m) => {
        const p = ES.join(this.downloadedUpdateHelper.cacheDir, l), d = () => (0, sh.pathExistsSync)(p) ? !t.disableDifferentialDownload : (n.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download"), !1);
        let h = !0;
        d() && (h = await this.differentialDownloadInstaller(c, t, f, u, l)), h && await this.httpExecutor.download(c.url, f, m);
      },
      done: async (f) => {
        if (!t.disableDifferentialDownload)
          try {
            const m = ES.join(this.downloadedUpdateHelper.cacheDir, l);
            await (0, sh.copyFile)(f.downloadedFile, m);
          } catch (m) {
            this._logger.warn(`Unable to copy file for caching for future differential downloads: ${m.message}`);
          }
        return this.updateDownloaded(c, f);
      }
    });
  }
  async updateDownloaded(t, r) {
    var n;
    const i = r.downloadedFile, s = (n = t.info.size) !== null && n !== void 0 ? n : (await (0, sh.stat)(i)).size, o = this._logger, a = `fileToProxy=${t.url.href}`;
    this.closeServerIfExists(), this.debug(`Creating proxy server for native Squirrel.Mac (${a})`), this.server = (0, _Q.createServer)(), this.debug(`Proxy server for native Squirrel.Mac is created (${a})`), this.server.on("close", () => {
      o.info(`Proxy server for native Squirrel.Mac is closed (${a})`);
    });
    const c = (u) => {
      const l = u.address();
      return typeof l == "string" ? l : `http://127.0.0.1:${l == null ? void 0 : l.port}`;
    };
    return await new Promise((u, l) => {
      const f = (0, SS.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-"), m = Buffer.from(`autoupdater:${f}`, "ascii"), p = `/${(0, SS.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (d, h) => {
        const _ = d.url;
        if (o.info(`${_} requested`), _ === "/") {
          if (!d.headers.authorization || d.headers.authorization.indexOf("Basic ") === -1) {
            h.statusCode = 401, h.statusMessage = "Invalid Authentication Credentials", h.end(), o.warn("No authenthication info");
            return;
          }
          const y = d.headers.authorization.split(" ")[1], E = Buffer.from(y, "base64").toString("ascii"), [R, w] = E.split(":");
          if (R !== "autoupdater" || w !== f) {
            h.statusCode = 401, h.statusMessage = "Invalid Authentication Credentials", h.end(), o.warn("Invalid authenthication credentials");
            return;
          }
          const C = Buffer.from(`{ "url": "${c(this.server)}${p}" }`);
          h.writeHead(200, { "Content-Type": "application/json", "Content-Length": C.length }), h.end(C);
          return;
        }
        if (!_.startsWith(p)) {
          o.warn(`${_} requested, but not supported`), h.writeHead(404), h.end();
          return;
        }
        o.info(`${p} requested by Squirrel.Mac, pipe ${i}`);
        let g = !1;
        h.on("finish", () => {
          g || (this.nativeUpdater.removeListener("error", l), u([]));
        });
        const v = (0, vQ.createReadStream)(i);
        v.on("error", (y) => {
          try {
            h.end();
          } catch (E) {
            o.warn(`cannot end response: ${E}`);
          }
          g = !0, this.nativeUpdater.removeListener("error", l), l(new Error(`Cannot pipe "${i}": ${y}`));
        }), h.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": s
        }), v.pipe(h);
      }), this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${a})`), this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${c(this.server)}, ${a})`), this.nativeUpdater.setFeedURL({
          url: c(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${m.toString("base64")}`
          }
        }), this.dispatchUpdateDownloaded(r), this.autoInstallOnAppQuit ? (this.nativeUpdater.once("error", l), this.nativeUpdater.checkForUpdates()) : u([]);
      });
    });
  }
  handleUpdateDownloaded() {
    this.autoRunAppAfterInstall ? this.nativeUpdater.quitAndInstall() : this.app.quit(), this.closeServerIfExists();
  }
  quitAndInstall() {
    this.squirrelDownloadedUpdate ? this.handleUpdateDownloaded() : (this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded()), this.autoInstallOnAppQuit || this.nativeUpdater.checkForUpdates());
  }
}
Pa.MacUpdater = wQ;
var Ca = {}, ev = {};
Object.defineProperty(ev, "__esModule", { value: !0 });
ev.verifySignature = xQ;
const xS = Rt, gP = bu, SQ = _u, RS = _e;
function xQ(e, t, r) {
  return new Promise((n, i) => {
    const s = t.replace(/'/g, "''");
    r.info(`Verifying signature ${s}`), (0, gP.execFile)('set "PSModulePath=" & chcp 65001 >NUL & powershell.exe', ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${s}' | ConvertTo-Json -Compress"`], {
      shell: !0,
      timeout: 20 * 1e3
    }, (o, a, c) => {
      var u;
      try {
        if (o != null || c) {
          oh(r, o, c, i), n(null);
          return;
        }
        const l = RQ(a);
        if (l.Status === 0) {
          try {
            const d = RS.normalize(l.Path), h = RS.normalize(t);
            if (r.info(`LiteralPath: ${d}. Update Path: ${h}`), d !== h) {
              oh(r, new Error(`LiteralPath of ${d} is different than ${h}`), c, i), n(null);
              return;
            }
          } catch (d) {
            r.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(u = d.message) !== null && u !== void 0 ? u : d.stack}`);
          }
          const m = (0, xS.parseDn)(l.SignerCertificate.Subject);
          let p = !1;
          for (const d of e) {
            const h = (0, xS.parseDn)(d);
            if (h.size ? p = Array.from(h.keys()).every((g) => h.get(g) === m.get(g)) : d === m.get("CN") && (r.warn(`Signature validated using only CN ${d}. Please add your full Distinguished Name (DN) to publisherNames configuration`), p = !0), p) {
              n(null);
              return;
            }
          }
        }
        const f = `publisherNames: ${e.join(" | ")}, raw info: ` + JSON.stringify(l, (m, p) => m === "RawData" ? void 0 : p, 2);
        r.warn(`Sign verification failed, installer signed with incorrect certificate: ${f}`), n(f);
      } catch (l) {
        oh(r, l, null, i), n(null);
        return;
      }
    });
  });
}
function RQ(e) {
  const t = JSON.parse(e);
  delete t.PrivateKey, delete t.IsOSBinary, delete t.SignatureType;
  const r = t.SignerCertificate;
  return r != null && (delete r.Archived, delete r.Extensions, delete r.Handle, delete r.HasPrivateKey, delete r.SubjectName), t;
}
function oh(e, t, r, n) {
  if ($Q()) {
    e.warn(`Cannot execute Get-AuthenticodeSignature: ${t || r}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    (0, gP.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (i) {
    e.warn(`Cannot execute ConvertTo-Json: ${i.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  t != null && n(t), r && n(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${r}. Failing signature validation due to unknown stderr.`));
}
function $Q() {
  const e = SQ.release();
  return e.startsWith("6.") && !e.startsWith("6.3");
}
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.NsisUpdater = void 0;
const al = Rt, $S = _e, TQ = Rn, OQ = dc, TS = oi, PQ = vt, CQ = si, AQ = ev, OS = qr;
class IQ extends TQ.BaseUpdater {
  constructor(t, r) {
    super(t, r), this._verifyUpdateCodeSignature = (n, i) => (0, AQ.verifySignature)(n, i, this._logger);
  }
  /**
   * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
   * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
   */
  get verifyUpdateCodeSignature() {
    return this._verifyUpdateCodeSignature;
  }
  set verifyUpdateCodeSignature(t) {
    t && (this._verifyUpdateCodeSignature = t);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const r = t.updateInfoAndProvider.provider, n = (0, PQ.findFile)(r.resolveFiles(t.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions: t,
      fileInfo: n,
      task: async (i, s, o, a) => {
        const c = n.packageInfo, u = c != null && o != null;
        if (u && t.disableWebInstaller)
          throw (0, al.newError)(`Unable to download new version ${t.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        !u && !t.disableWebInstaller && this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version."), (u || t.disableDifferentialDownload || await this.differentialDownloadInstaller(n, t, i, r, al.CURRENT_APP_INSTALLER_FILE_NAME)) && await this.httpExecutor.download(n.url, i, s);
        const l = await this.verifySignature(i);
        if (l != null)
          throw await a(), (0, al.newError)(`New version ${t.updateInfoAndProvider.info.version} is not signed by the application owner: ${l}`, "ERR_UPDATER_INVALID_SIGNATURE");
        if (u && await this.differentialDownloadWebPackage(t, c, o, r))
          try {
            await this.httpExecutor.download(new OS.URL(c.path), o, {
              headers: t.requestHeaders,
              cancellationToken: t.cancellationToken,
              sha512: c.sha512
            });
          } catch (f) {
            try {
              await (0, CQ.unlink)(o);
            } catch {
            }
            throw f;
          }
      }
    });
  }
  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
  async verifySignature(t) {
    let r;
    try {
      if (r = (await this.configOnDisk.value).publisherName, r == null)
        return null;
    } catch (n) {
      if (n.code === "ENOENT")
        return null;
      throw n;
    }
    return await this._verifyUpdateCodeSignature(Array.isArray(r) ? r : [r], t);
  }
  doInstall(t) {
    const r = this.installerPath;
    if (r == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const n = ["--updated"];
    t.isSilent && n.push("/S"), t.isForceRunAfter && n.push("--force-run"), this.installDirectory && n.push(`/D=${this.installDirectory}`);
    const i = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    i != null && n.push(`--package-file=${i}`);
    const s = () => {
      this.spawnLog($S.join(process.resourcesPath, "elevate.exe"), [r].concat(n)).catch((o) => this.dispatchError(o));
    };
    return t.isAdminRightsRequired ? (this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe"), s(), !0) : (this.spawnLog(r, n).catch((o) => {
      const a = o.code;
      this._logger.info(`Cannot run installer: error code: ${a}, error message: "${o.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`), a === "UNKNOWN" || a === "EACCES" ? s() : a === "ENOENT" ? Mi.shell.openPath(r).catch((c) => this.dispatchError(c)) : this.dispatchError(o);
    }), !0);
  }
  async differentialDownloadWebPackage(t, r, n, i) {
    if (r.blockMapSize == null)
      return !0;
    try {
      const s = {
        newUrl: new OS.URL(r.path),
        oldFile: $S.join(this.downloadedUpdateHelper.cacheDir, al.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: n,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        cancellationToken: t.cancellationToken
      };
      this.listenerCount(TS.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (o) => this.emit(TS.DOWNLOAD_PROGRESS, o)), await new OQ.FileWithEmbeddedBlockMapDifferentialDownloader(r, this.httpExecutor, s).download();
    } catch (s) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${s.stack || s}`), process.platform === "win32";
    }
    return !1;
  }
}
Ca.NsisUpdater = IQ;
(function(e) {
  var t = me && me.__createBinding || (Object.create ? function(_, g, v, y) {
    y === void 0 && (y = v);
    var E = Object.getOwnPropertyDescriptor(g, v);
    (!E || ("get" in E ? !g.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
      return g[v];
    } }), Object.defineProperty(_, y, E);
  } : function(_, g, v, y) {
    y === void 0 && (y = v), _[y] = g[v];
  }), r = me && me.__exportStar || function(_, g) {
    for (var v in _) v !== "default" && !Object.prototype.hasOwnProperty.call(g, v) && t(g, _, v);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.NsisUpdater = e.MacUpdater = e.RpmUpdater = e.PacmanUpdater = e.DebUpdater = e.AppImageUpdater = e.Provider = e.NoOpLogger = e.AppUpdater = e.BaseUpdater = void 0;
  const n = si, i = _e;
  var s = Rn;
  Object.defineProperty(e, "BaseUpdater", { enumerable: !0, get: function() {
    return s.BaseUpdater;
  } });
  var o = ei;
  Object.defineProperty(e, "AppUpdater", { enumerable: !0, get: function() {
    return o.AppUpdater;
  } }), Object.defineProperty(e, "NoOpLogger", { enumerable: !0, get: function() {
    return o.NoOpLogger;
  } });
  var a = vt;
  Object.defineProperty(e, "Provider", { enumerable: !0, get: function() {
    return a.Provider;
  } });
  var c = Ra;
  Object.defineProperty(e, "AppImageUpdater", { enumerable: !0, get: function() {
    return c.AppImageUpdater;
  } });
  var u = $a;
  Object.defineProperty(e, "DebUpdater", { enumerable: !0, get: function() {
    return u.DebUpdater;
  } });
  var l = Ta;
  Object.defineProperty(e, "PacmanUpdater", { enumerable: !0, get: function() {
    return l.PacmanUpdater;
  } });
  var f = Oa;
  Object.defineProperty(e, "RpmUpdater", { enumerable: !0, get: function() {
    return f.RpmUpdater;
  } });
  var m = Pa;
  Object.defineProperty(e, "MacUpdater", { enumerable: !0, get: function() {
    return m.MacUpdater;
  } });
  var p = Ca;
  Object.defineProperty(e, "NsisUpdater", { enumerable: !0, get: function() {
    return p.NsisUpdater;
  } }), r(oi, e);
  let d;
  function h() {
    if (process.platform === "win32")
      d = new Ca.NsisUpdater();
    else if (process.platform === "darwin")
      d = new Pa.MacUpdater();
    else {
      d = new Ra.AppImageUpdater();
      try {
        const _ = i.join(process.resourcesPath, "package-type");
        if (!(0, n.existsSync)(_))
          return d;
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const g = (0, n.readFileSync)(_).toString().trim();
        switch (console.info("Found package-type:", g), g) {
          case "deb":
            d = new $a.DebUpdater();
            break;
          case "rpm":
            d = new Oa.RpmUpdater();
            break;
          case "pacman":
            d = new Ta.PacmanUpdater();
            break;
          default:
            break;
        }
      } catch (_) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", _.message);
      }
    }
    return d;
  }
  Object.defineProperty(e, "autoUpdater", {
    enumerable: !0,
    get: () => d || h()
  });
})(ws);
class NQ {
  constructor(t) {
    we(this, "updateInProgress");
    we(this, "windown");
    //   发送日志
    we(this, "sendLog", (t, r) => {
      this.windown.webContents.send("wcf:log", { message: t, level: r || "INFO", timestamp: pT().format("YYYY-MM-DD HH:mm:ss.SSS ") });
    });
    // 检查更新
    we(this, "checkUpdate", async () => {
      try {
        if (!yr.isPackaged) return 0;
        if (this.updateInProgress) return 2;
        this.updateInProgress = !0;
        const t = await ws.autoUpdater.checkForUpdates();
        return ws.autoUpdater.on("update-not-available", () => {
          this.updateInProgress = !1;
        }), ws.autoUpdater.on("error", () => {
          console.log(666), this.updateInProgress = !1;
        }), ws.autoUpdater.on("update-downloaded", () => {
          fC.showMessageBox({
            type: "info",
            title: "更新已下载",
            message: "新版本已准备好，是否现在安装？",
            buttons: ["安装并重启", "稍后"]
          }).then((r) => {
            r.response === 0 && ws.autoUpdater.quitAndInstall(), this.updateInProgress = !1;
          });
        }), t && (t == null ? void 0 : t.updateInfo.version) !== yr.getVersion() ? 1 : 0;
      } catch (t) {
        this.updateInProgress = !1, this.sendLog(t.message, "ERROR");
      }
    });
    this.updateInProgress = !1, this.windown = t;
  }
}
<<<<<<< HEAD
const __dirname$1 = path$n.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$n.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$n.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$n.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$n.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
let wcf = null;
let electronUpdate = null;
function startMemoryMonitor(win2) {
  const memoryUsage = process.memoryUsage();
  const totalMB = (memoryUsage.rss / 1024 / 1024).toFixed(1);
  win2 == null ? void 0 : win2.webContents.send("memory-usage", totalMB);
=======
const yP = mn.dirname(mC(import.meta.url));
console.log("app.getVersion()", yr.getVersion());
console.log("app.getAppPath()", yr.getAppPath());
process.env.APP_ROOT = mn.join(yP, "..");
const om = process.env.VITE_DEV_SERVER_URL, Hee = mn.join(process.env.APP_ROOT, "dist-electron"), vP = mn.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = om ? mn.join(process.env.APP_ROOT, "public") : vP;
let Me, Re = null, Fn = null;
function PS(e) {
  const r = (process.memoryUsage().rss / 1024 / 1024).toFixed(1);
  e == null || e.webContents.send("memory-usage", r);
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
}
function _P() {
  Me = new IS({
    width: 1200,
    height: 800,
    minWidth: 1200,
    minHeight: 800,
    icon: mn.join(process.env.VITE_PUBLIC, "logo.png"),
    webPreferences: {
      preload: mn.join(yP, "preload.mjs")
    }
  }), Re = new aW(Me), Fn = new NQ(Me), Me.webContents.on("did-finish-load", () => {
    Fn == null || Fn.checkUpdate(), PS(Me), Re == null || Re.registerSchedule("*/2 * * * *", () => {
      PS(Me);
    }), Re == null || Re.registerSchedule("0 */12 * * *", async () => {
      const e = await (Re == null ? void 0 : Re.checkUpdate());
      Fn == null || Fn.checkUpdate(), Me == null || Me.webContents.send("wcf:checkUpdateNotiy", e);
    }), Me == null || Me.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString()), Re == null || Re.reportConfig();
  }), om ? (Me.loadURL(om), Me == null || Me.webContents.toggleDevTools()) : Me.loadFile(mn.join(vP, "index.html")), Bt.handle("wcf:checkUpdate", Re.checkUpdate), Bt.handle("wcf:checkWCF", Re.checkWCF), Bt.handle("wcf:downloadWCF", Re.downloadWCF), Bt.handle("wcf:chekWcfIsRun", Re.checkWCFIsRun), Bt.handle("wcf:startWcfHttpServer", Re.startWcfServer), Bt.handle("wcf:closeWcfHttpServer", Re.closeWcfServer), Bt.handle("wcf:updateConfig", Re.modifyWCFConfig), Bt.handle("wcf:config", Re.getWCFConfig), Bt.handle("wcf:restartWcf", Re.restartWCF), Bt.handle("wcf:closeWcf", Re.closeWCF), Bt.handle("wcf:startWCF", Re.startWCF), Bt.handle("wcf:resetWcf", Re.resetWCF), Bt.handle("wcf:readWcfLog", Re.readWcfLog), Bt.handle("wcf:injectVersionWcf", (e, t) => Re == null ? void 0 : Re.injectVersionDll(t.version, t.download_wechat || !1)), Bt.handle("open:url", (e, t) => {
    dC.openExternal(t);
  }), Bt.handle("app:update", Fn.checkUpdate), pC.register("CommandOrControl+Shift+I", () => {
    Me == null || Me.webContents.toggleDevTools();
  });
}
const kQ = AS.buildFromTemplate([]);
AS.setApplicationMenu(kQ);
yr.on("window-all-closed", () => {
  process.platform !== "darwin" && (yr.quit(), Re == null || Re.closeWcfServer(), Re == null || Re.clearSchedule(), Re == null || Re.closeWCF(), Me = null, Re = null);
});
yr.on("activate", () => {
  IS.getAllWindows().length === 0 && _P();
});
process.on("uncaughtException", (e) => {
  Me == null || Me.webContents.send("unhandledRejection", e.message);
});
<<<<<<< HEAD
process.on("unhandledRejection", (reason) => {
  win == null ? void 0 : win.webContents.send("unhandledRejection", `Pormise:${reason.message}`);
=======
process.on("unhandledRejection", (e) => {
  Me == null || Me.webContents.send("unhandledRejection", e.message);
>>>>>>> 1ecf004d17400bb42bc03167a53081ca135ba564
});
yr.whenReady().then(_P);
export {
  Hee as MAIN_DIST,
  vP as RENDERER_DIST,
  om as VITE_DEV_SERVER_URL
};
